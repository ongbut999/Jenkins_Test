/*
 * This is a template file.
 */


ASAP2_VERSION 1 61
/begin PROJECT EntryPlatform_XCP "XCP on CAN in EntryPlatform"   

	/begin HEADER ""
		VERSION   "0.0.0.0"
		PROJECT_NO EntryPlatform
	/end HEADER

  /begin MODULE template_A2L ""                         

  
    /* A2ML - Language definitions */
    /begin A2ML
/*************** start of PROTOCOL_LAYER *******************/ 
   
  struct Protocol_Layer {     /* At MODULE */ 
   
    uint;                                /* XCP protocol layer version */ 
                                         /* e.g. "1.2" = 0x0102            */ 
   
    uint;                                /* T1 [ms] */ 
    uint;                                /* T2 [ms] */ 
    uint;                                /* T3 [ms] */ 
    uint;                                /* T4 [ms] */ 
    uint;                                /* T5 [ms] */ 
    uint;                                /* T6 [ms] */ 
    uint;                                /* T7 [ms] */ 
   
    uchar;                               /* MAX_CTO */ 
    uint;                                /* MAX_DTO default for DAQ and STIM */ 
   
    enum {                               /* BYTE_ORDER */ 
      "BYTE_ORDER_MSB_LAST"  = 0, 
      "BYTE_ORDER_MSB_FIRST" = 1 
    }; 
   
    enum {                               /* ADDRESS_GRANULARITY */ 
      "ADDRESS_GRANULARITY_BYTE"    = 1, 
      "ADDRESS_GRANULARITY_WORD"    = 2, 
      "ADDRESS_GRANULARITY_DWORD"   = 4 
    }; 
   
    taggedstruct {                       /* optional                     */ 
       
      ("OPTIONAL_CMD" enum {             /* XCP-Code of optional command */  
                                         /* supported by the slave       */ 
   
        "GET_COMM_MODE_INFO"       = 0xFB, 
        "GET_ID"                   = 0xFA, 
        "SET_REQUEST"              = 0xF9, 
        "GET_SEED"                 = 0xF8, 
        "UNLOCK"                   = 0xF7, 
        "SET_MTA"                  = 0xF6, 
        "UPLOAD"                   = 0xF5, 
        "SHORT_UPLOAD"             = 0xF4, 
        "BUILD_CHECKSUM"           = 0xF3, 
        "TRANSPORT_LAYER_CMD"      = 0xF2, 
        "USER_CMD"                 = 0xF1, 
        "DOWNLOAD"                 = 0xF0, 
        "DOWNLOAD_NEXT"            = 0xEF, 
        "DOWNLOAD_MAX"             = 0xEE, 
        "SHORT_DOWNLOAD"           = 0xED, 
        "MODIFY_BITS"              = 0xEC, 
        "SET_CAL_PAGE"             = 0xEB, 
        "GET_CAL_PAGE"             = 0xEA, 
        "GET_PAG_PROCESSOR_INFO"   = 0xE9, 
        "GET_SEGMENT_INFO"         = 0xE8, 
        "GET_PAGE_INFO"            = 0xE7, 
        "SET_SEGMENT_MODE"         = 0xE6, 
        "GET_SEGMENT_MODE"         = 0xE5, 
        "COPY_CAL_PAGE"            = 0xE4, 
        "CLEAR_DAQ_LIST"           = 0xE3, 
        "SET_DAQ_PTR"              = 0xE2, 
        "WRITE_DAQ"                = 0xE1, 
        "SET_DAQ_LIST_MODE"        = 0xE0, 
        "GET_DAQ_LIST_MODE"        = 0xDF, 
        "START_STOP_DAQ_LIST"      = 0xDE, 
        "START_STOP_SYNCH"         = 0xDD, 
        "GET_DAQ_CLOCK"            = 0xDC, 
        "READ_DAQ"                 = 0xDB, 
        "GET_DAQ_PROCESSOR_INFO"   = 0xDA, 
        "GET_DAQ_RESOLUTION_INFO"  = 0xD9, 
        "GET_DAQ_LIST_INFO"        = 0xD8, 
        "GET_DAQ_EVENT_INFO"       = 0xD7, 
        "FREE_DAQ"                 = 0xD6, 
        "ALLOC_DAQ"                = 0xD5, 
        "ALLOC_ODT"                = 0xD4, 
        "ALLOC_ODT_ENTRY"          = 0xD3, 
        "PROGRAM_START"            = 0xD2, 
        "PROGRAM_CLEAR"            = 0xD1, 
        "PROGRAM"                  = 0xD0, 
        "PROGRAM_RESET"            = 0xCF, 
        "GET_PGM_PROCESSOR_INFO"   = 0xCE, 
        "GET_SECTOR_INFO"          = 0xCD, 
        "PROGRAM_PREPARE"          = 0xCC, 
        "PROGRAM_FORMAT"           = 0xCB, 
        "PROGRAM_NEXT"             = 0xCA, 
        "PROGRAM_MAX"              = 0xC9, 
        "PROGRAM_VERIFY"           = 0xC8,
        "WRITE_DAQ_MULTIPLE"       = 0xC7
      })*;           
                                          
      "COMMUNICATION_MODE_SUPPORTED" taggedunion { /* optional modes supported */ 
         "BLOCK" taggedstruct { 
            "SLAVE";                  /* Slave Block Mode supported  */ 
            "MASTER" struct {         /* Master Block Mode supported */ 
               uchar;  /* MAX_BS */ 
               uchar;  /* MIN_ST */ 
            }; 
         }; 
         "INTERLEAVED" uchar;    /* QUEUE_SIZE */  
      }; 
   
      "SEED_AND_KEY_EXTERNAL_FUNCTION" char[256];  /* Name of the Seed&Key function */ 
                                                   /* including file extension      */ 
                                                   /* without path                  */ 
      "MAX_DTO_STIM" uint;     /* overrules MAX_DTO see above for STIM use case */                                           
    }; 
   
  };

/***************** end of PROTOCOL_LAYER *******************/ 


/*********************** start of DAQ **********************/ 

  struct Daq {                         /* DAQ supported, at MODULE*/ 
    enum {                             /* DAQ_CONFIG_TYPE */ 
      "STATIC"  = 0, 
      "DYNAMIC" = 1 
    }; 
   
    uint;                               /* MAX_DAQ */ 
    uint;                               /* MAX_EVENT_CHANNEL */ 
    uchar;                              /* MIN_DAQ */ 
   
    enum {                            /* OPTIMISATION_TYPE */ 
      "OPTIMISATION_TYPE_DEFAULT"            = 0, 
      "OPTIMISATION_TYPE_ODT_TYPE_16"        = 1, 
      "OPTIMISATION_TYPE_ODT_TYPE_32"        = 2, 
      "OPTIMISATION_TYPE_ODT_TYPE_64"        = 3, 
      "OPTIMISATION_TYPE_ODT_TYPE_ALIGNMENT" = 4, 
      "OPTIMISATION_TYPE_MAX_ENTRY_SIZE"     = 5 
    }; 
   
    enum {                           /* ADDRESS_EXTENSION */ 
      "ADDRESS_EXTENSION_FREE" = 0, 
      "ADDRESS_EXTENSION_ODT"  = 1, 
      "ADDRESS_EXTENSION_DAQ"  = 3 
    }; 
   
   
    enum {                           /* IDENTIFICATION_FIELD */ 
      "IDENTIFICATION_FIELD_TYPE_ABSOLUTE"              = 0, 
      "IDENTIFICATION_FIELD_TYPE_RELATIVE_BYTE"         = 1, 
      "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD"         = 2, 
      "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD_ALIGNED" = 3 
    }; 
     
   
    enum {                        /* GRANULARITY_ODT_ENTRY_SIZE_DAQ */ 
      "GRANULARITY_ODT_ENTRY_SIZE_DAQ_BYTE"    = 1, 
      "GRANULARITY_ODT_ENTRY_SIZE_DAQ_WORD"    = 2, 
      "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DWORD"   = 4, 
      "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DLONG"   = 8 
    }; 
   
    uchar;                              /* MAX_ODT_ENTRY_SIZE_DAQ */ 
   
    enum {                              /* OVERLOAD_INDICATION */ 
      "NO_OVERLOAD_INDICATION"    = 0, 
      "OVERLOAD_INDICATION_PID"   = 1, 
      "OVERLOAD_INDICATION_EVENT" = 2 
    }; 
   
    taggedstruct {                      /* optional */ 
      "DAQ_ALTERNATING_SUPPORTED" uint; /* Display_Event_Channel_Number */
      "PRESCALER_SUPPORTED"; 
      "RESUME_SUPPORTED"; 
      "STORE_DAQ_SUPPORTED";
   
      block "STIM" struct {             /* STIM supported */ 
   
        enum {                      /* GRANULARITY_ODT_ENTRY_SIZE_STIM */ 
          "GRANULARITY_ODT_ENTRY_SIZE_STIM_BYTE"   = 1, 
          "GRANULARITY_ODT_ENTRY_SIZE_STIM_WORD"   = 2, 
          "GRANULARITY_ODT_ENTRY_SIZE_STIM_DWORD"  = 4, 
          "GRANULARITY_ODT_ENTRY_SIZE_STIM_DLONG"  = 8 
        }; 
   
        uchar;                          /* MAX_ODT_ENTRY_SIZE_STIM */ 
   
        taggedstruct {                  /* bitwise stimulation */ 
          "BIT_STIM_SUPPORTED"; 
          "MIN_ST_STIM" uchar; /* separation time between DTOs */
          /* time in units of 100 microseconds */
        }; 
      }; 
             
      block "TIMESTAMP_SUPPORTED" struct {  
        uint;                           /* TIMESTAMP_TICKS */ 
        enum { /* TIMESTAMP_SIZE */ 
          "NO_TIME_STAMP" = 0, 
          "SIZE_BYTE"     = 1, 
          "SIZE_WORD"     = 2, 
          "SIZE_DWORD"    = 4 
        }; 
        enum { /* RESOLUTION OF TIMESTAMP */ 
          "UNIT_1NS"   = 0, 
          "UNIT_10NS"  = 1, 
          "UNIT_100NS" = 2, 
          "UNIT_1US"   = 3, 
          "UNIT_10US"  = 4, 
          "UNIT_100US" = 5, 
          "UNIT_1MS"   = 6, 
          "UNIT_10MS"  = 7, 
          "UNIT_100MS" = 8, 
          "UNIT_1S"    = 9, 
          "UNIT_1PS"   = 10,
          "UNIT_10PS"  = 11,
          "UNIT_100PS" = 12
        }; 
        taggedstruct { 
          "TIMESTAMP_FIXED"; 
        }; 
      }; 
   
      "PID_OFF_SUPPORTED";
  
      "MAX_DAQ_TOTAL" uint;
      "MAX_ODT_TOTAL" uint;
      "MAX_ODT_DAQ_TOTAL" uint;
      "MAX_ODT_STIM_TOTAL" uint;
      "MAX_ODT_ENTRIES_TOTAL" uint;
	  "MAX_ODT_ENTRIES_DAQ_TOTAL" uint;
      "MAX_ODT_ENTRIES_STIM_TOTAL" uint;

      
      "CPU_LOAD_MAX_TOTAL" float;
      
      block "DAQ_MEMORY_CONSUMPTION" struct {
        ulong; /* "DAQ_MEMORY_LIMIT"		: in Elements[AG] */
        uint;  /* "DAQ_SIZE" 			: Anzahl Elements[AG] pro DAQ-Liste */
        uint;  /* "ODT_SIZE" 			: Anzahl Elements[AG] pro ODT */
        uint;  /* "ODT_ENTRY_SIZE" 		: Anzahl Elements[AG] pro ODT_Entry */
        uint;  /* "ODT_DAQ_BUFFER_ELEMENT_SIZE" : Anzahl Payload-Elements[AG]*Faktor = sizeof(Sendepuffer)[AG] */
        uint;  /* "ODT_STIM_BUFFER_ELEMENT_SIZE": Anzahl Payload-Elements[AG]*Faktor = sizeof(Empfangspuffer)[AG] */
      };
       
      /************************ start of DAQ_LIST *************************/ 
   
      (block "DAQ_LIST" struct {          /* DAQ_LIST                    */ 
                                          /* multiple possible           */ 
        uint;                             /* DAQ_LIST_NUMBER             */ 
        taggedstruct {                            /* optional */ 
          "DAQ_LIST_TYPE" enum {               
            "DAQ"      = 1,               /* DIRECTION = DAQ only     */ 
            "STIM"     = 2,               /* DIRECTION = STIM only    */ 
            "DAQ_STIM" = 3                /* both directions possible */ 
                                          /* but not simultaneously   */ 
          }; 
   
          "MAX_ODT"         uchar;        /* MAX_ODT         */ 
          "MAX_ODT_ENTRIES" uchar;        /* MAX_ODT_ENTRIES */ 
   
          "FIRST_PID" uchar;              /* FIRST_PID for this DAQ_LIST */ 
          "EVENT_FIXED" uint;             /* this DAQ_LIST always        */ 
                                          /* in this event               */ 
          block "PREDEFINED" taggedstruct { /* predefined                */ 
                                            /* not configurable DAQ_LIST */ 
             (block "ODT" struct { 
                     uchar;                   /* ODT number */ 
                     taggedstruct { 
                         ("ODT_ENTRY" struct { 
                                     uchar;   /* ODT_ENTRY number            */ 
                                     ulong;   /* address of element                 */ 
                                     uchar;   /* address extension of element */ 
                                     uchar;   /* size of element [AG]                */ 
                                     uchar;   /* BIT_OFFSET                          */ 
                           })*; 
                     }; /* end of ODT_ENTRY */ 
              })*; /* end of ODT */ 
           }; /* end of PREDEFINED */ 
        }; 
      
      })*;
      
      /********************* end of DAQ_LIST ***************************/ 
   
      /************************* start of EVENT ************************/ 
     
      (block "EVENT" struct {             /* EVENT               */ 
                                          /* multiple possible   */ 
        char[101];                        /* EVENT_CHANNEL_NAME       */ 
        char[9];                          /* EVENT_CHANNEL_SHORT_NAME */ 
        uint;                             /* EVENT_CHANNEL_NUMBER     */ 
     
        enum { 
          "DAQ"      = 1,                 /* only DAQ_LISTs         */ 
                                          /* with DIRECTION = DAQ   */ 
          "STIM"     = 2,                 /* only DAQ_LISTs         */ 
                                          /* with DIRECTION = STIM  */ 
          "DAQ_STIM" = 3                  /* both kind of DAQ_LISTs */ 
        }; 
     
        uchar;                            /* MAX_DAQ_LIST */ 
        uchar;                            /* EVENT_CHANNEL_TIME_CYCLE */
        uchar;                            /* EVENT_CHANNEL_TIME_UNIT */ 
        uchar;                            /* EVENT_CHANNEL_PRIORITY */ 
          taggedstruct { /* optional */
            
            "COMPLEMENTARY_BYPASS_EVENT_CHANNEL_NUMBER" uint;
            "CONSISTENCY" enum {
  
                 "DAQ" = 0,
                 "EVENT" = 1
            };
           
            block "MIN_CYCLE_TIME" struct { /* Configuration with 0-0 not allowed */
             uchar;                            /* EVENT_CHANNEL_TIME_CYCLE */
             uchar;                            /* EVENT_CHANNEL_TIME_UNIT  */
            };
           
           "CPU_LOAD_MAX" float;
          
           block "CPU_LOAD_CONSUMPTION_DAQ" struct {
            float;  // "DAQ_FACTOR"
            float;  // "ODT_FACTOR"
            float;  // "ODT_ENTRY_FACTOR" 
            taggedstruct { 
              (block "ODT_ENTRY_SIZE_FACTOR_TABLE" struct{// Kopierroutine
                     uint; //"SIZE" 
                     float; // "SIZE_FACTOR" 
               })*;
             };
           };
           
           block "CPU_LOAD_CONSUMPTION_STIM" struct {
            float;  // "DAQ_FACTOR"
            float;  // "ODT_FACTOR"
            float;  // "ODT_ENTRY_FACTOR" 
            taggedstruct { 
              (block "ODT_ENTRY_SIZE_FACTOR_TABLE" struct{// Kopierroutine
                     uint; //"SIZE" 
                     float; //"SIZE_FACTOR" 
               })*;
             };
           };
           
           block "CPU_LOAD_CONSUMPTION_QUEUE" struct {
              float;  // "ODT_FACTOR" 
              float;  // "ODT_ELEMENT_LOAD",length in elements[AG]
           };        
         };
      })*;
      
      /******************** end of EVENT *********************/ 
   
    }; /* end of optional at DAQ */ 
   
  }; 
  
/********************* end of DAQ **************************/  
  

/***************** start of DAQ_EVENT **********************/ 
 
  taggedunion Daq_Event {         /* at MEASUREMENT */ 
     "FIXED_EVENT_LIST" taggedstruct { 
        ("EVENT" uint)* ; 
     }; 
     "VARIABLE" taggedstruct { 
        block "AVAILABLE_EVENT_LIST" taggedstruct { 
           ("EVENT" uint)*; 
        }; 
        block "DEFAULT_EVENT_LIST" taggedstruct { 
           ("EVENT" uint)*; 
        }; 
     }; 
  }; 

/******************** end of DAQ_EVENT *********************/ 
   

/*********************** start of PAG **********************/ 
   
  struct Pag {                  /* PAG supported, at MODULE */ 
    uchar;                      /* MAX_SEGMENTS */ 
    taggedstruct {              /* optional */ 
      "FREEZE_SUPPORTED"; 
    }; 
   
  }; 

/*********************** end of PAG ************************/ 
      

/*********************** start of PGM **********************/ 
   
  struct Pgm {                  /* PGM supported, at MODULE */ 
   
    enum { 
      "PGM_MODE_ABSOLUTE"                = 1, 
      "PGM_MODE_FUNCTIONAL"              = 2, 
      "PGM_MODE_ABSOLUTE_AND_FUNCTIONAL" = 3 
    }; 
    uchar;                               /* MAX_SECTORS */ 
    uchar;                               /* MAX_CTO_PGM */ 
  
    taggedstruct {                       /* optional                */ 
      (block "SECTOR" struct {           /* SECTOR                  */ 
                                         /* multiple possible       */ 
        char[101];                       /* SECTOR_NAME             */ 
        uchar;                           /* SECTOR_NUMBER           */ 
        ulong;                           /* Address                 */ 
        ulong;                           /* Length                  */ 
        uchar;                           /* CLEAR_SEQUENCE_NUMBER   */ 
        uchar;                           /* PROGRAM_SEQUENCE_NUMBER */ 
        uchar;                           /* PROGRAM_METHOD          */ 
      })*; /* end of SECTOR */ 
                                          
      "COMMUNICATION_MODE_SUPPORTED" taggedunion { /* optional modes supported */ 
         "BLOCK" taggedstruct { 
            "SLAVE";                  /* Slave Block Mode supported  */ 
            "MASTER" struct {         /* Master Block Mode supported */ 
               uchar;  /* MAX_BS_PGM */ 
               uchar;  /* MIN_ST_PGM */ 
            }; 
         }; 
       "INTERLEAVED" uchar;    /* QUEUE_SIZE_PGM */  
       }; 
    }; 
  }; 

/*********************** end of PGM ************************/ 

  
/*********************** start of SEGMENT ******************/ 
   
  struct Segment {               /* at MEMORY_SEGMENT */ 
    uchar;                               /* SEGMENT_NUMBER     */ 
    uchar;                               /* number of pages    */ 
    uchar;                               /* ADDRESS_EXTENSION  */ 
    uchar;                               /* COMPRESSION_METHOD */ 
    uchar;                               /* ENCRYPTION_METHOD  */ 
   
    taggedstruct {                       /* optional           */ 
      block "CHECKSUM" struct { 
        enum {                           /* checksum type      */ 
          "XCP_ADD_11"       =   1, 
          "XCP_ADD_12"       =   2, 
          "XCP_ADD_14"       =   3, 
          "XCP_ADD_22"       =   4, 
          "XCP_ADD_24"       =   5, 
          "XCP_ADD_44"       =   6, 
          "XCP_CRC_16"       =   7, 
          "XCP_CRC_16_CITT"  =   8, 
          "XCP_CRC_32"       =   9, 
          "XCP_USER_DEFINED" = 255 
        }; 
   
        taggedstruct { 
          "MAX_BLOCK_SIZE"              ulong ;    /* maximum block size            */ 
                                                   /* for checksum calculation      */ 
          "EXTERNAL_FUNCTION" char[256];           /* Name of the Checksum function */ 
                                                   /* including file extension      */ 
                                                   /* without path                  */ 
        }; 
      }; 
   
      (block "PAGE" struct {               /* PAGES for this SEGMENT */ 
                                           /* multiple possible      */ 
        uchar;                             /* PAGE_NUMBER            */ 
   
        enum {            /* ECU_ACCESS_TYPE */ 
            "ECU_ACCESS_NOT_ALLOWED"      = 0, 
            "ECU_ACCESS_WITHOUT_XCP_ONLY" = 1, 
            "ECU_ACCESS_WITH_XCP_ONLY"    = 2, 
            "ECU_ACCESS_DONT_CARE"        = 3 
         }; 
   
        enum {       /* XCP_READ_ACCESS_TYPE */ 
            "XCP_READ_ACCESS_NOT_ALLOWED"      = 0, 
            "XCP_READ_ACCESS_WITHOUT_ECU_ONLY" = 1, 
            "XCP_READ_ACCESS_WITH_ECU_ONLY"    = 2, 
            "XCP_READ_ACCESS_DONT_CARE"        = 3 
         }; 
   
        enum {      /* XCP_WRITE_ACCESS_TYPE */ 
            "XCP_WRITE_ACCESS_NOT_ALLOWED"      = 0, 
            "XCP_WRITE_ACCESS_WITHOUT_ECU_ONLY" = 1, 
            "XCP_WRITE_ACCESS_WITH_ECU_ONLY"    = 2, 
            "XCP_WRITE_ACCESS_DONT_CARE"        = 3 
        }; 
        taggedstruct { 
          "INIT_SEGMENT" uchar; /* references segment that initialises this page */ 
        }; 
   
      })*; /* end of PAGE */                 
   
      (block "ADDRESS_MAPPING" struct {  /* multiple possible   */ 
                           ulong;        /* source address      */ 
                           ulong;        /* destination address */ 
                           ulong;        /* length              */ 
      })*; 
   
      "PGM_VERIFY" ulong; /* verification value for PGM */ 
    }; /* end of optional */ 
   
  }; 

/************************ end of SEGMENT *******************/ 

  
/*********************** start of Common Parameters ********/ 
 
  taggedstruct Common_Parameters {  
   
    block "PROTOCOL_LAYER" struct Protocol_Layer; 
   
    block "SEGMENT" struct Segment; 
   
    block "DAQ" struct Daq; 
    block "PAG" struct Pag; 
    block "PGM" struct Pgm; 
   
    block "DAQ_EVENT" taggedunion Daq_Event; 
   
  }; 

/********************** end of Common Parameters **********/ 


/***********************************************************/
/*                                                         */
/* ASAP2 meta language for XCP on CAN V1.2                 */
/*                                                         */
/*                                                         */
/*   Datatypes:                                            */
/*                                                         */
/*   A2ML       description                                */
/*   ----------------------------------------------------- */
/*   uchar      unsigned 8  Bit                            */
/*   char       signed 8 Bit                               */
/*   uint       unsigned integer 16 Bit                    */
/*   int        signed integer 16 Bit                      */
/*   ulong      unsigned integer 32 Bit                    */
/*   long       signed integer 32 Bit                      */
/*   float      float 32 Bit IEEE 745                      */
/*                                                         */
/***********************************************************/
/************************ start of CAN *********************/

  struct CAN_Parameters { /* At MODULE */
    uint; /* XCP on CAN version */
          /* e.g. "1.2" = 0x0102 */
    taggedstruct { /* optional */
      "CAN_ID_BROADCAST" ulong; /* Auto detection CAN-ID */
                                /* master -> slaves */
                                /* Bit31= 1: extended identifier */
      "CAN_ID_MASTER" ulong;    /* CMD/STIM CAN-ID */
                                /* master -> slave */
                                /* Bit31= 1: extended identifier */
      "CAN_ID_MASTER_INCREMENTAL";     /* master uses range of CAN-IDs  */
                                /* start of range = CAN_ID_MASTER */
                                /* end of range = CAN_ID_MASTER+MAX_BS(_PGM)-1 */
      "CAN_ID_SLAVE" ulong;     /* RES/ERR/EV/SERV/DAQ CAN-ID */
                                /* slave -> master */
                                /* Bit31= 1: extended identifier */
      "BAUDRATE" ulong;         /* BAUDRATE [Hz] */
      "SAMPLE_POINT" uchar;     /* sample point */
                                /* [% complete bit time] */
      "SAMPLE_RATE" enum {
        "SINGLE" = 1,           /* 1 sample per bit */
        "TRIPLE" = 3            /* 3 samples per bit */
      };
      "BTL_CYCLES" uchar;       /* BTL_CYCLES */
                                /* [slots per bit time] */
      "SJW" uchar;              /* length synchr. segment */
                                /* [BTL_CYCLES] */
      "SYNC_EDGE" enum {
        "SINGLE" = 1,           /* on falling edge only */
        "DUAL" = 2              /* on falling and rising edge */
      };
      "MAX_DLC_REQUIRED";       /* master to slave frames */
                                /* always to have DLC = MAX_DLC = 8 */
                              
      (block "DAQ_LIST_CAN_ID" struct { /* At IF_DATA DAQ */
        uint;                   /* reference to DAQ_LIST_NUMBER */
        taggedstruct {          /* exclusive tags */
                                /* either VARIABLE or FIXED */
          "VARIABLE";
          "FIXED" ulong;        /* this DAQ_LIST always */
                                /* on this CAN_ID */
        };
      })*;
      (block "EVENT_CAN_ID_LIST" struct { /* At IF_DATA DAQ  */
        uint;                   /* reference to EVENT_NUMBER */
        taggedstruct {          /* exclusive tags */
          ("FIXED" ulong)*;        /* this Event always on this ID */
        };
      })*;
        
      "MAX_BUS_LOAD"  ulong;    /* maximum available bus */
                                   /* load in percent */
  
      block "CAN_FD" struct {
        taggedstruct {

          "MAX_DLC" uint; /* 8, 12, 16, 20, 24, 32, 48 or 64 */
          "CAN_FD_DATA_TRANSFER_BAUDRATE" ulong; /* BAUDRATE [Hz] */
 
          "SAMPLE_POINT" uchar;   /* sample point receiver*/
                                      /* [% complete bit time] */
        
          "BTL_CYCLES" uchar;            /* BTL_CYCLES        */
                                     /* [slots per bit time]   */
          "SJW" uchar;              /* length synchr. segment */
                                     /* [BTL_CYCLES]           */
          "SYNC_EDGE" enum {
                       "SINGLE" = 1, /* on falling edge only */
                       "DUAL"   = 2  /* on falling and rising edge*/
                     };
  
          "MAX_DLC_REQUIRED";      /* master to slave frames */
                         /* always to have DLC = MAX_DLC_for CAN-FD */
  
          "SECONDARY_SAMPLE_POINT" uchar;/* sender sample point */
                                     /* [% complete bit time] */
          "TRANSCEIVER_DELAY_COMPENSATION" enum {
                         "OFF" = 0,
                         "ON" = 1
          };
                       
        };
        
      };
      
    };
    
  };

/************************* end of CAN **********************/


/***********************************************************/
/*                                                         */
/* ASAP2 meta language for XCP on TCP_IP V1.2              */
/*                                                         */
/*                                                         */
/*   Datatypes:                                            */
/*                                                         */
/*   A2ML       description                                */
/*   ----------------------------------------------------- */
/*   uchar      unsigned 8  Bit                            */
/*   char       signed 8 Bit                               */
/*   uint       unsigned integer 16 Bit                    */
/*   int        signed integer 16 Bit                      */
/*   ulong      unsigned integer 32 Bit                    */
/*   long       signed integer 32 Bit                      */
/*   float      float 32 Bit IEEE 745                      */
/*                                                         */
/***********************************************************/
/************************ start of TCP_IP ******************/

  struct TCP_IP_Parameters {

     uint; /* XCP on TCP_IP version */
           /* e.g. "1.2" = 0x0102 */
     uint; /* PORT */

     taggedunion {
       "HOST_NAME" char[256];
       "ADDRESS" char[15];
       "IPV6" char[39];
     };
     taggedstruct{
       "MAX_BUS_LOAD"  ulong; /* maximum available bus */
				     /* load in percent */
       "MAX_BIT_RATE"  ulong; /* Network speed which is */ 
                              /* the base for MAX_BUS_LOAD in Mbit*/

     };

  };

/************************* end of TCP_IP *******************/


/***********************************************************/
/*                                                         */
/* ASAP2 meta language for XCP on TCP_IP V1.2              */
/*                                                         */
/*                                                         */
/*   Datatypes:                                            */
/*                                                         */
/*   A2ML       description                                */
/*   ----------------------------------------------------- */
/*   uchar      unsigned 8  Bit                            */
/*   char       signed 8 Bit                               */
/*   uint       unsigned integer 16 Bit                    */
/*   int        signed integer 16 Bit                      */
/*   ulong      unsigned integer 32 Bit                    */
/*   long       signed integer 32 Bit                      */
/*   float      float 32 Bit IEEE 745                      */
/*                                                         */
/***********************************************************/
/************************ start of UDP_IP ******************/

  struct UDP_IP_Parameters {

     uint; /* XCP on UDP_IP version */
           /* e.g. "1.2" = 0x0102 */
     uint; /* PORT */

     taggedunion {
       "HOST_NAME" char[256];
       "ADDRESS" char[15];
       "IPV6" char[39];
     };
     taggedstruct{
       "MAX_BUS_LOAD"  ulong; /* maximum available bus */
				     /* load in percent */
       "MAX_BIT_RATE"  ulong; /* Network speed which is */ 
                              /* the base for MAX_BUS_LOAD in Mbit*/

     };

  };

/*************************** end of UDP ********************/


/***********************************************************/
/*                                                         */
/* ASAP2 meta language for XCP on FLX V1.2                 */
/*                                                         */
/*                                                         */
/*   Datatypes:                                            */
/*                                                         */
/*   A2ML       description                                */
/*   ----------------------------------------------------- */
/*   uchar      unsigned 8  Bit                            */
/*   char       signed 8 Bit                               */
/*   uint       unsigned integer 16 Bit                    */
/*   int        signed integer 16 Bit                      */
/*   ulong      unsigned integer 32 Bit                    */
/*   long       signed integer 32 Bit                      */
/*   float      float 32 Bit IEEE 745                      */
/*                                                         */
/***********************************************************/
/************************ start of FLX *********************/
  
  enum packet_assignment_type {
               "NOT_ALLOWED",
               "FIXED",
               "VARIABLE_INITIALISED",
               "VARIABLE"
               }; /* end of packet_assignment_type */
  
  struct buffer {
  
    uchar;  /* FLX_BUF */
   
    taggedstruct {
  
      "MAX_FLX_LEN_BUF" taggedunion {
               "FIXED" uchar;    /* constant value */
               "VARIABLE" uchar; /* initial value */
               }; /* end of MAX_FLX_LEN_BUF */
  
      block "LPDU_ID" taggedstruct {
  
        "FLX_SLOT_ID" taggedunion {
               "FIXED" uint;
               "VARIABLE" taggedstruct{
                   "INITIAL_VALUE" uint;
                   };
               }; /* end of FLX_SLOT_ID */
  
        "OFFSET" taggedunion {
               "FIXED" uchar;
               "VARIABLE" taggedstruct{
                   "INITIAL_VALUE" uchar;
                   };
               }; /* end of OFFSET */
  
        "CYCLE_REPETITION" taggedunion {
               "FIXED" uchar;
               "VARIABLE" taggedstruct{
                   "INITIAL_VALUE" uchar;
                   };
               }; /* end of CYCLE_REPETITION */
  
        "CHANNEL" taggedunion {
               "FIXED" enum {
                        "A" = 0,
                        "B" = 1
                       };
               "VARIABLE" taggedstruct{
                   "INITIAL_VALUE" enum {
                                    "A" = 0,
                                    "B" = 1
                                   };
                   };
               }; /* end of CHANNEL */
  
         }; /* end of LPDU_ID */
  
      block "XCP_PACKET" taggedstruct {
  
        "CMD" enum packet_assignment_type;          /* end of CMD          */
        "RES_ERR" enum packet_assignment_type;  /* end of RES_ERR */
        "EV_SERV" enum packet_assignment_type;  /* end of EV_SERV  */
        "DAQ" enum packet_assignment_type;           /* end of DAQ           */
        "STIM" enum packet_assignment_type;          /* end of STIM          */
       
         }; /* end of XCP_PACKET */
    }; 
  
  }; /* end of buffer */
  
  struct FLX_Parameters {
  
      uint;                              /* XCP on FlexRay version  */
                                           /* e.g. "1.0" = 0x0100 */
  
      uint;                          /* T1_FLX [ms] */
  
      char[256];                     /* FIBEX-file including CHI information */
                                     /* including extension    */
                                     /* without path */
  
      char[256];                     /* Cluster-ID */
  
      uchar;                         /* NAX */
  
      enum { 
        "HEADER_NAX"               = 0,
        "HEADER_NAX_FILL"          = 1,
        "HEADER_NAX_CTR"           = 2,
        "HEADER_NAX_FILL3"         = 3,
        "HEADER_NAX_CTR_FILL2"     = 4,
        "HEADER_NAX_LEN"           = 5,
        "HEADER_NAX_CTR_LEN"       = 6,
        "HEADER_NAX_FILL2_LEN"     = 7,
        "HEADER_NAX_CTR_FILL_LEN"  = 8
      };
   
  
      enum { 
        "PACKET_ALIGNMENT_8"  = 0,
        "PACKET_ALIGNMENT_16" = 1,
        "PACKET_ALIGNMENT_32" = 2
      };
  
      taggedunion {
        block "INITIAL_CMD_BUFFER" struct buffer;
      };
  
      taggedunion {    
        block "INITIAL_RES_ERR_BUFFER" struct buffer;
      };
  
      taggedstruct {
  
        (block "POOL_BUFFER" struct buffer)*;
  
      };
  
  };
  
/************************* end of FLX **********************/

  block "IF_DATA" taggedunion if_data {

/************* start of XCP on different Transport Layers *******************/

  "XCPplus" struct {
    uint;
    taggedstruct Common_Parameters ; /* default parameters */
  
    taggedstruct { /* transport layer specific parameters  */
                   /* overruling of the default parameters */
  
      (block "XCP_ON_CAN" struct {
  
        struct CAN_Parameters ;                   /* specific for CAN      */
        taggedstruct Common_Parameters;           /* overruling of default */
        taggedstruct {
          "TRANSPORT_LAYER_INSTANCE" char[101];
        };   
  
      })*;
  
      (block "XCP_ON_TCP_IP" struct {
  
        struct TCP_IP_Parameters ;                /* specific for TCP_IP   */
        taggedstruct Common_Parameters;           /* overruling of default */
        taggedstruct {
          "TRANSPORT_LAYER_INSTANCE" char[101];
        };
  
      })*;
  
      (block "XCP_ON_UDP_IP" struct {
  
        struct UDP_IP_Parameters ;                /* specific for UDP      */
        taggedstruct Common_Parameters;           /* overruling of default */
        taggedstruct {
          "TRANSPORT_LAYER_INSTANCE" char[101];
        };
  
      })*;
  
      (block "XCP_ON_FLX" struct {
  
        struct FLX_Parameters ;                   /* specific for FLX      */
        taggedstruct Common_Parameters;           /* overruling of default */
        taggedstruct {
          "TRANSPORT_LAYER_INSTANCE" char[101];
        };
  
      })*;
  
    };
  
  };
  
/************* end of XCP on different Transport Layers ********************/

}; /* End of block IF_DATA */

    /end A2ML




	/begin MOD_COMMON ""

		DEPOSIT          ABSOLUTE
		BYTE_ORDER 		MSB_LAST	//small endian

    /end MOD_COMMON
	
	 /begin MOD_PAR     ""
      VERSION          "Entry_XCP_2"    
      CUSTOMER_NO      ""
      USER             ""
      PHONE_NO         ""
      ECU              "MCU"
      CPU_TYPE         "Power Architecture"       


      /begin MEMORY_SEGMENT Cal_Data_Seg1
        "Application calibration"
        DATA
      FLASH
      INTERN
      0x801c0000 /*WARNING! __calpage_start  found in elf file */ /* __calpage_start */
      0x00004000 /*WARNING! __calpage_size  found in elf file */ /* must equal to size of block used for calibration */
        -1 -1 -1 -1 -1
    /begin IF_DATA XCPplus 0x0102
          /begin SEGMENT
            0x01 /* segment logical number starts from 0 */
            0x02 /* number of pages */
            0x00 /* address extension */
            0x00 /* compression method */
            0x00 /* encryption method */
            /begin CHECKSUM
              XCP_ADD_14
              MAX_BLOCK_SIZE 0x400        
            /end CHECKSUM
			/begin PAGE
              0x00 /* page number - reference page */
                ECU_ACCESS_WITH_XCP_ONLY
                XCP_READ_ACCESS_WITH_ECU_ONLY
				XCP_WRITE_ACCESS_NOT_ALLOWED
              INIT_SEGMENT 1
            /end PAGE
            /begin PAGE
              0x01 /* page number - working page */
                ECU_ACCESS_WITH_XCP_ONLY
                XCP_READ_ACCESS_WITH_ECU_ONLY
                XCP_WRITE_ACCESS_WITH_ECU_ONLY
              INIT_SEGMENT 1
            /end PAGE
          /end SEGMENT
        /end IF_DATA

      /end MEMORY_SEGMENT
	
 


 
      /begin MEMORY_SEGMENT AppCode        
        "Application code"
        CODE
        FLASH
        INTERN
        0x80038000  
        0x00188000   /*TODO: use linker value since this varies depending on processor*/
        -1 -1 -1 -1 -1
		/begin IF_DATA XCPplus 0x0102
		/begin SEGMENT
				0x00 								  /* segment logical number */
				0x01 								  /* number of pages */
				0x00 								  /* address extension */
				0x00 								  /* compression method */
				0x00 								  /* encryption method */
			/begin CHECKSUM 
				XCP_ADD_14                      /* checksum: add bytes to 32bit result */
				MAX_BLOCK_SIZE 0x400
			/end CHECKSUM
			/begin PAGE
				0x00                            /* page number */
				ECU_ACCESS_WITH_XCP_ONLY
				XCP_READ_ACCESS_WITH_ECU_ONLY   /*means "tool" page is the same as "ECU" page*/
				XCP_WRITE_ACCESS_NOT_ALLOWED
			INIT_SEGMENT 0
			/end PAGE
		/end SEGMENT
		/end IF_DATA  		
		
      /end MEMORY_SEGMENT
         
	  	  

/* ******************** end Block Memory Segment ******************** */	  
	  
    /end MOD_PAR



    /begin IF_DATA XCPplus 0x0102                       

      /* Include of the generated TL/PL-information */
  /* XcpTransportLayer "XcpTransportLayer_0" */
  /begin XCP_ON_CAN
/************************ start of CAN *********************/
    0x0102                                                /* XCP on CAN version */
    CAN_ID_MASTER 0x333                                   /* CMD/STIM CAN-ID */
                                                          /* master -> slave */
    CAN_ID_SLAVE 0x777                                    /* RES/ERR/EV/SERV/DAQ CAN-ID */
                                                          /* slave -> master */
                                                          /* Bit31= 1: extended identifier */
    BAUDRATE 500000                                      /* BAUDRATE [Hz] */
    SAMPLE_POINT 62                                       /* sample point */
                                                          /* [% complete bit time] */
    BTL_CYCLES 8                                         /* BTL_CYCLES */
                                                          /* [slots per bit time] */
    SJW 1                                                 /* length synchr. segment */
                                                          /* [BTL_CYCLES] */
	MAX_BUS_LOAD	100
    /begin EVENT_CAN_ID_LIST
      0                                                   /* reference to EVENT_NUMBER: 10ms */
      FIXED         0x778                                 /* this Event always on this ID */
    /end EVENT_CAN_ID_LIST
    /begin EVENT_CAN_ID_LIST
      1                                                   /* reference to EVENT_NUMBER: 100ms */
      FIXED         0x77A                                 /* this Event always on this ID */
    /end EVENT_CAN_ID_LIST
    /begin EVENT_CAN_ID_LIST
      2                                                   /* reference to EVENT_NUMBER: 50ms */
      FIXED         0x779                                 /* this Event always on this ID */
    /end EVENT_CAN_ID_LIST

/************************* end of CAN **********************/


  /* XcpTransportLayer "XcpTransportLayer_0" */
/*************** start of PROTOCOL_LAYER *******************/

  /begin PROTOCOL_LAYER                                   /* At MODULE */

    0x0102                                                /* XCP protocol layer version */

    2000                                                   /* T1 [ms] */
    2000                                                   /* T2 [ms] */
    0                                                     /* T3 [ms] */
    0                                                     /* T4 [ms] */
    0                                                     /* T5 [ms] */
    0                                                     /* T6 [ms] */
    2000                                                     /* T7 [ms] */

    8                                                     /* MAX_CTO */
    8                                                     /* MAX_DTO default for DAQ and STIM */

    BYTE_ORDER_MSB_LAST                                  /* BYTE_ORDER: INTEL */
    ADDRESS_GRANULARITY_BYTE                              /* ADDRESS_GRANULARITY */

    OPTIONAL_CMD GET_SEED
    OPTIONAL_CMD UNLOCK
    OPTIONAL_CMD SET_MTA
    OPTIONAL_CMD UPLOAD
    OPTIONAL_CMD SHORT_UPLOAD
    OPTIONAL_CMD BUILD_CHECKSUM
    OPTIONAL_CMD DOWNLOAD
    OPTIONAL_CMD DOWNLOAD_NEXT
    OPTIONAL_CMD DOWNLOAD_MAX
    OPTIONAL_CMD SET_CAL_PAGE
    OPTIONAL_CMD GET_CAL_PAGE
    OPTIONAL_CMD COPY_CAL_PAGE
    OPTIONAL_CMD CLEAR_DAQ_LIST
    OPTIONAL_CMD SET_DAQ_PTR
    OPTIONAL_CMD WRITE_DAQ
    OPTIONAL_CMD SET_DAQ_LIST_MODE
    OPTIONAL_CMD START_STOP_DAQ_LIST
    OPTIONAL_CMD START_STOP_SYNCH
    OPTIONAL_CMD GET_DAQ_CLOCK
    OPTIONAL_CMD READ_DAQ
    OPTIONAL_CMD GET_DAQ_PROCESSOR_INFO
    OPTIONAL_CMD GET_DAQ_RESOLUTION_INFO
    OPTIONAL_CMD GET_DAQ_EVENT_INFO
    OPTIONAL_CMD FREE_DAQ
    OPTIONAL_CMD ALLOC_DAQ
    OPTIONAL_CMD ALLOC_ODT
    OPTIONAL_CMD ALLOC_ODT_ENTRY

    COMMUNICATION_MODE_SUPPORTED                          /* optional modes supported */
      BLOCK
        SLAVE                                             /* Slave Block Mode supported  */
        MASTER                                            /* Master Block Mode supported */
          255                                             /* MAX_BS */
          0                                               /* MIN_ST */
    SEED_AND_KEY_EXTERNAL_FUNCTION "XcpSeedNKey.dll"                   /* Name of the SeedAndKey function */
                                                          /* including file extension      */
                                                          /* without path                  */

  /end PROTOCOL_LAYER

/***************** end of PROTOCOL_LAYER *******************/


  /* XcpTransportLayer "XcpTransportLayer_0" */
/********************* start of DAQ ************************/

  /begin DAQ                                              /* DAQ supported, at MODULE*/
    DYNAMIC                                               /* DAQ_CONFIG_TYPE */
    65535                                                 /* MAX_DAQ */
    3                                                     /* MAX_EVENT_CHANNEL */
    0                                                     /* MIN_DAQ */
    OPTIMISATION_TYPE_DEFAULT                             /* OPTIMISATION_TYPE */
    ADDRESS_EXTENSION_FREE                                /* ADDRESS_EXTENSION */
    IDENTIFICATION_FIELD_TYPE_ABSOLUTE                    /* IDENTIFICATION_FIELD */
    GRANULARITY_ODT_ENTRY_SIZE_DAQ_BYTE                   /* GRANULARITY_ODT_ENTRY_SIZE_DAQ */
    255                                                   /* MAX_ODT_ENTRY_SIZE_DAQ */
    OVERLOAD_INDICATION_EVENT                             /* OVERLOAD_INDICATION */
    PRESCALER_SUPPORTED
    /begin TIMESTAMP_SUPPORTED
      1                           /* TIMESTAMP_TICKS */
      SIZE_WORD             /* TIMESTAMP_SIZE */
      UNIT_1MS  /* RESOLUTION OF TIMESTAMP */
    /end TIMESTAMP_SUPPORTED
    /begin DAQ_MEMORY_CONSUMPTION
      1019                                                /* DAQ_MEMORY_LIMIT: in Elements[AG] */
      46                                                  /* DAQ_SIZE: number of elements[AG] per DAQ list */
      6                                                   /* ODT_SIZE: number of elements[AG] per ODT */
      5                                                   /* ODT_ENTRY_SIZE: number of elements[AG] per ODT_entry */
      2                                                   /* ODT_DAQ_BUFFER_ELEMENT_SIZE: number of */
                                                          /* payload elements[AG]*factor = sizeof(send buffer)[AG] */
      0                                                   /* ODT_STIM_BUFFER_ELEMENT_SIZE: number of */
                                                          /* payload elements[AG]*factor = sizeof(receive buffer)[AG] */
    /end DAQ_MEMORY_CONSUMPTION

/******************* start of EVENT ************************/

    /begin EVENT                                          /* EVENT               */
      "10msRStr"                             /* EVENT_CHANNEL_NAME       */
      "10ms"                                             /* EVENT_CHANNEL_SHORT_NAME */
      0                                                   /* EVENT_CHANNEL_NUMBER     */
      DAQ                                                 /* EVENT_CHANNEL_TYPE     */
      1                                                   /* MAX_DAQ_LIST */
      1                                                  /* EVENT_CHANNEL_TIME_CYCLE */
      7                                                   /* EVENT_CHANNEL_TIME_UNIT: UNIT_10MS */
      8                                                   /* EVENT_CHANNEL_PRIORITY (0xFF = highest) */
    /end EVENT

    /begin EVENT                                          /* EVENT               */
      "100msRStr"                             /* EVENT_CHANNEL_NAME       */
      "100ms"                                             /* EVENT_CHANNEL_SHORT_NAME */
      1                                                   /* EVENT_CHANNEL_NUMBER     */
      DAQ                                                 /* EVENT_CHANNEL_TYPE     */
      1                                                   /* MAX_DAQ_LIST */
      1                                                  /* EVENT_CHANNEL_TIME_CYCLE */
      8                                                   /* EVENT_CHANNEL_TIME_UNIT: UNIT_100MS */
      10                                                   /* EVENT_CHANNEL_PRIORITY (0xFF = highest) */
    /end EVENT

    /begin EVENT                                          /* EVENT               */
      "50msRStr"                             /* EVENT_CHANNEL_NAME       */
      "50ms"                                             /* EVENT_CHANNEL_SHORT_NAME */
      2                                                   /* EVENT_CHANNEL_NUMBER     */
      DAQ                                                 /* EVENT_CHANNEL_TYPE     */
      1                                                   /* MAX_DAQ_LIST */
      5                                                  /* EVENT_CHANNEL_TIME_CYCLE */
      7                                                   /* EVENT_CHANNEL_TIME_UNIT: UNIT_10MS */
      9                                                   /* EVENT_CHANNEL_PRIORITY (0xFF = highest) */
    /end EVENT

/********************* end of EVENT ************************/

  /end DAQ

/********************* end of DAQ **************************/

  /* XcpTransportLayer "XcpTransportLayer_0" */
  TRANSPORT_LAYER_INSTANCE "CAN_0_PL0"

  /end XCP_ON_CAN                    

    /end IF_DATA

/* ---------------------------------------------------------------------------*/
//base address is "Measured_Var"

	/begin MEASUREMENT Measured_Var1
		   "unsigned integer 32bit"
		   ULONG
		   NO_COMPU_METHOD
		   0
		   0
		   0
		   ‭4294967295‬
		   DISPLAY_IDENTIFIER  Measured_Var1
		   ECU_ADDRESS 0x7000acc0
	/end MEASUREMENT
	
	/begin MEASUREMENT Measured_Var2
		   "unsigned integer 32bit"
		   ULONG
		   NO_COMPU_METHOD
		   0
		   0
		   0
		   ‭4294967295‬
		   DISPLAY_IDENTIFIER  Measured_Var2
		   ECU_ADDRESS 0x7000acc4	
	/end MEASUREMENT	
 
	/begin MEASUREMENT Measured_Var3
		   "unsigned integer 32bit"
		   ULONG
		   NO_COMPU_METHOD
		   0
		   0
		   0
		   ‭4294967295‬
		   DISPLAY_IDENTIFIER  Measured_Var3
		   ECU_ADDRESS 0x7000acc8	
	/end MEASUREMENT	
 
	/begin MEASUREMENT Measured_Var4
		   "unsigned integer 32bit"
		   ULONG
		   NO_COMPU_METHOD
		   0
		   0
		   0
		   ‭4294967295‬
		   DISPLAY_IDENTIFIER  Measured_Var4
		   ECU_ADDRESS 0x7000accc	
	/end MEASUREMENT	
 
 	/begin MEASUREMENT Measured_Var5
		   "unsigned integer 32bit"
		   ULONG
		   NO_COMPU_METHOD
		   0
		   0
		   0
		   ‭4294967295‬
		   DISPLAY_IDENTIFIER  Measured_Var5
		   ECU_ADDRESS 0x7000acd0	
	/end MEASUREMENT	
 
 	/begin MEASUREMENT Measured_Var6
		   "unsigned integer 32bit"
		   ULONG
		   NO_COMPU_METHOD
		   0
		   0
		   0
		   ‭4294967295‬
		   DISPLAY_IDENTIFIER  Measured_Var6
		   ECU_ADDRESS 0x7000acd4	
	/end MEASUREMENT	
 
 	/begin MEASUREMENT Measured_Var7
		   "unsigned integer 32bit"
		   ULONG
		   NO_COMPU_METHOD
		   0
		   0
		   0
		   ‭4294967295‬
		   DISPLAY_IDENTIFIER  Measured_Var7
		   ECU_ADDRESS 0x7000acd8	
	/end MEASUREMENT	
 
 	/begin MEASUREMENT Measured_Var8
		   "unsigned integer 32bit"
		   ULONG
		   NO_COMPU_METHOD
		   0
		   0
		   0
		   ‭4294967295‬
		   DISPLAY_IDENTIFIER  Measured_Var8
		   ECU_ADDRESS 0x7000acdc	
	/end MEASUREMENT	
 
 	/begin MEASUREMENT Measured_Var9
		   "unsigned integer 32bit"
		   ULONG
		   NO_COMPU_METHOD
		   0
		   0
		   0
		   ‭4294967295‬
		   DISPLAY_IDENTIFIER  Measured_Var9
		   ECU_ADDRESS 0x7000ace0	
	/end MEASUREMENT	
 
 	/begin MEASUREMENT Measured_Var10
		   "unsigned integer 32bit"
		   ULONG
		   NO_COMPU_METHOD
		   0
		   0
		   0
		   ‭4294967295‬
		   DISPLAY_IDENTIFIER  Measured_Var10
		   ECU_ADDRESS 0x7000ace4	
	/end MEASUREMENT	
 
 	/begin MEASUREMENT Measured_Var11
		   "unsigned integer 32bit"
		   ULONG
		   NO_COMPU_METHOD
		   0
		   0
		   0
		   ‭4294967295‬
		   DISPLAY_IDENTIFIER  Measured_Var11
		   ECU_ADDRESS 0x7000ace8	
	/end MEASUREMENT	
 
 	/begin MEASUREMENT Measured_Var12
		   "unsigned integer 32bit"
		   ULONG
		   NO_COMPU_METHOD
		   0
		   0
		   0
		   ‭4294967295‬
		   DISPLAY_IDENTIFIER  Measured_Var12
		   ECU_ADDRESS 0x7000acec	
	/end MEASUREMENT	
 
 	/begin MEASUREMENT Measured_Var13
		   "unsigned integer 32bit"
		   ULONG
		   NO_COMPU_METHOD
		   0
		   0
		   0
		   ‭4294967295‬
		   DISPLAY_IDENTIFIER  Measured_Var13
		   ECU_ADDRESS 0x7000acf0	
	/end MEASUREMENT	
 
 	/begin MEASUREMENT Measured_Var14
		   "unsigned integer 32bit"
		   ULONG
		   NO_COMPU_METHOD
		   0
		   0
		   0
		   ‭4294967295‬
		   DISPLAY_IDENTIFIER  Measured_Var14
		   ECU_ADDRESS 0x7000acf4	
	/end MEASUREMENT	
 
 	/begin MEASUREMENT Measured_Var15
		   "unsigned integer 32bit"
		   ULONG
		   NO_COMPU_METHOD
		   0
		   0
		   0
		   ‭4294967295‬
		   DISPLAY_IDENTIFIER  Measured_Var15
		   ECU_ADDRESS 0x7000acf8	
	/end MEASUREMENT	
 
 	/begin MEASUREMENT Measured_Var16
		   "unsigned integer 32bit"
		   ULONG
		   NO_COMPU_METHOD
		   0
		   0
		   0
		   ‭4294967295‬
		   DISPLAY_IDENTIFIER  Measured_Var16
		   ECU_ADDRESS 0x7000acfc	
	/end MEASUREMENT	
 
 	/begin MEASUREMENT Measured_Var17
		   "unsigned integer 32bit"
		   ULONG
		   NO_COMPU_METHOD
		   0
		   0
		   0
		   ‭4294967295‬
		   DISPLAY_IDENTIFIER  Measured_Var17
		   ECU_ADDRESS 0x7000ad00	
	/end MEASUREMENT	
 
 	/begin MEASUREMENT Measured_Var18
		   "unsigned integer 32bit"
		   ULONG
		   NO_COMPU_METHOD
		   0
		   0
		   0
		   ‭4294967295‬
		   DISPLAY_IDENTIFIER  Measured_Var18
		   ECU_ADDRESS 0x7000ad04	
	/end MEASUREMENT	
 
 	/begin MEASUREMENT Measured_Var19
		   "unsigned integer 32bit"
		   ULONG
		   NO_COMPU_METHOD
		   0
		   0
		   0
		   ‭4294967295‬
		   DISPLAY_IDENTIFIER  Measured_Var19
		   ECU_ADDRESS 0x7000ad08	
	/end MEASUREMENT	
 
 	/begin MEASUREMENT Measured_Var20
		   "unsigned integer 32bit"
		   ULONG
		   NO_COMPU_METHOD
		   0
		   0
		   0
		   ‭4294967295‬
		   DISPLAY_IDENTIFIER  Measured_Var20
		   ECU_ADDRESS 0x7000ad0c	
	/end MEASUREMENT	
 
/* ---------------------------------------------------------------------------*/
/* ---------------------------------------------------------------------------*/    
/* ---------------------------------------------------------------------------*/
/* ---------------------------------------------------------------------------*/
	/begin CHARACTERISTIC test_calib1
		   "unsigned integer 32bit"
		   VALUE
		   0x801c0000
		   STANDARD_VALUE_U32
		   0.0
		   NO_COMPU_METHOD
		   0.0
		   10000.0
	/end CHARACTERISTIC	    

	/begin CHARACTERISTIC test_calib2
		   "unsigned integer 32bit"
		   VALUE
		   0x801c0004
		   STANDARD_VALUE_U32
		   0.0
		   NO_COMPU_METHOD
		   0.0
		   10000.0
	/end CHARACTERISTIC	    


/* ---------------------------------------------------------------------------*/
/* ---------------------------------------------------------------------------*/


/* ---------------------------------------------------------------------------*/
/* ---------------------------------------------------------------------------*/    
/* ---------------------------------------------------------------------------*/


    /begin RECORD_LAYOUT STANDARD_VALUE_U32
      FNC_VALUES                            /* description of function value: */
      1                                     /* position in memory */
      ULONG                                 /* data type of the constant */
      COLUMN_DIR                            /* deposited in columns (don't care) */
      DIRECT                                /* direct addressing */
    /end RECORD_LAYOUT


 /end MODULE
/end PROJECT
