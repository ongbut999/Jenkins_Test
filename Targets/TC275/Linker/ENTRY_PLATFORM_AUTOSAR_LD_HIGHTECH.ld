OUTPUT_FORMAT("elf32-tricore")
OUTPUT_ARCH(tricore)
ENTRY(_RESET)



__ISTACK_SIZE = DEFINED (__ISTACK_SIZE) ? __ISTACK_SIZE : 1K;	/* RTA-OS uses shared global stack for interrupt */
__USTACK_SIZE = DEFINED (__USTACK_SIZE) ? __USTACK_SIZE : 16K;
__HEAP = DEFINED (__HEAP_SIZE) ? __HEAP_SIZE : 0K ;
__CSA_SIZE = DEFINED (__CSA_SIZE) ? __CSA_SIZE : 4K ;

MEMORY
{
  /*Flash*/
  
             
  BMHD0                 (rx)     : org = 0x80000000, len = 32             /*boot header, BMHD0 */
  RESET_POINT           (rx!p)   : org = 0x80000020, len = 32  
  PFLASH0_STARTUP       (rx!p)   : org = 0x80020000, len = 0x300             /*startup code */
  PFLASH0_TRAP_INT_TAB  (rx!p)   : org = 0x80020300, len = 2k             /*OS interrupt & trap vector table */
  PFLASH0_CONST         (rx!p)   : org = 0x80020B00, len = 93K+255           /*for const and copy table */
  FLS_AC_ERASE_SOURCE   (rx!p)   : org = 0x80038000, len = 0x200          /*Program Flash Memory (PFLASH0)*/
  FLS_AC_WRITE_SOURCE   (rx!p)   : org = 0x80038200, len = 0x300          /*Program Flash Memory (PFLASH0)*/
  PFLASH0_CPU0_PRIVATE  (rx!p)   : org = 0x80038500, len = 288K - 0x500           /*Code on CPU0*/
  PFLASH0_CPU1_PRIVATE  (rx!p)   : org = 0x80080000, len = 512k           /*Code on CPU1*/
  PFLASH0_CPU2_PRIVATE  (rx!p)   : org = 0x80100000, len = 512k           /*Code on CPU2*/
  PFLASH0_SHARED_CODE   (rx!p)   : org = 0x80180000, len = 256K             /*Shared Program Memory (PFLASH0)*/
  PFLASH0_CALIB         (rx!p)   : org = 0x801C0000, len = 16K            /*Calibration Data */
  PFLASH0_CPU012        (rx!p)   : org = 0x80038000, len = 1568K            /*Code segment */	
	
  DF_EEPROM             (rx!p)   : org = 0xAF000000, len = 32K            /*EEPROM data */
  /*Flash*/
	LMU_SRAM              (wx)		 : org = 0xB0000000, len = 32K            /* Global LMU RAM */

  /*Ram*/
  CPU0_DSPR_CALIB       (w!xp)   : org = 0x70004000, len = 16k            /* 16K, Scratch-Pad RAM (PSPR 0)*/

  CPU0_DMI_DSPR         (w!xp)   : org = 0x70008000, len = 55k            /*Local Data RAM (DSPR)*/
  CPU0_DSPR_STACK       (w!xp)   : org = 0x70016C00, len = 17K            /*Stack, 1K istack and 16K ustack*/
  CPU0_DSPR_CSA         (w!xp)   : org = 0x7001B000, len = 4k             /*CSA*/

  CPU0_PSPR_FLS_ERASE   (w!xp)   : org = 0x70100040, len = 0x200          /*Global Scratch-Pad RAM (PSPR)*/
  CPU0_PSPR_FLS_WRITE   (w!xp)   : org = 0x70100240, len = 0x300          /*Global Scratch-Pad RAM (PSPR)*/
  

  CPU1_DMI_DSPR         (w!xp)   : org = 0x60000100, len = 99K - 256      /*Local Data RAM (DSPR)*/
  CPU1_DSPR_STACK       (w!xp)   : org = 0x60018C00, len = 17K            /*Stack, 1K istack and 16K ustack*/
  CPU1_DSPR_CSA         (w!xp)   : org = 0x6001D000, len = 4K             /*CSA*/
  
  CPU2_DMI_DSPR         (w!xp)   : org = 0x50000100, len = 99K - 256      /*Local Data RAM (DSPR)*/
  CPU2_DSPR_STACK       (w!xp)   : org = 0x50018C00, len = 17K            /*Stack, 1K istack and 16K ustack*/
  CPU2_DSPR_CSA         (w!xp)   : org = 0x5001D000, len = 4K             /*CSA*/
}



SECTIONS
{

  .STARTUP : ALIGN(4)
  {
    *(.text.cstart)
 	} > PFLASH0_STARTUP
/*---------------------------------------------------------------------*/
  .ResetPoint :
  {
	 *(.startup_code)
	   . = ALIGN(8);
 	} > RESET_POINT
/*---------------------------------------------------------------------*/
  /* Code Allocation */
  .BMHD0   : ALIGN(4)
  {
    *(.BMD_HDR_CONST_FAR_UNSPECIFIED*)
  } > BMHD0

/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/
  /*
   * The startup code should be placed where the CPU expects it after a reset,
   * so we try to locate it first, no matter where it appears in the list of
   * objects and libraries (note: because the wildcard pattern doesn't match
   * directories, we'll try to find crt0.o in various (sub)directories).
   */
	/* startup hand over to boot */




	/*
	* Discard trap and interrupt vector tables which are not generated by OS.
	*/
	.DISCARD :
	{
	  *(.text._trap*)
	  *(.text.cpu*trap*)
	}

	 /* Section for interrupt table */
	.inttab :
	{
		KEEP (*(.inttab));
		KEEP (*(.*.inttab));
    *(.inttab.osinterrupts)
    *(.inttab.ostraps)
    *(.inttab.osstubs)  /* <- Emitted when the OS is not generating vector table */
		. = ALIGN(8) ;
	} > PFLASH0_TRAP_INT_TAB
/*---------------------------------------------------------------------*/ 
  .RODATA_CALIB   : ALIGN(4)
  {
    PROVIDE(__RODATA_CALIB_START = .);
    *(.rodata.Calib_bool*)
    *(.rodata.Calib_8*)
    *(.rodata.Calib_16*)
    *(.rodata.Calib_32*)
    *(.rodata.Calib_unspec*)
    FILL(0xFF);
    . = ALIGN(LENGTH(PFLASH0_CALIB));        
    PROVIDE(__RODATA_CALIB_END = .);
  } > PFLASH0_CALIB
/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/
  .RODATA   : ALIGN(4)
  {
    PROVIDE(__RODATA_START = .);
    *(.rodata*)
    *(.rodata.*)
    PROVIDE(__RODATA_END = .);
  } > PFLASH0_CONST
/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/
  .clear_sec :
  {
    . = ALIGN(8);
    PROVIDE(__cpu0_clear_table = .) ;
    LONG(0 + ADDR(.CPU0_TRUSTED_BSS)); LONG(SIZEOF(.CPU0_TRUSTED_BSS));
    LONG(0 + ADDR(.CPU0_UNTRUSTED_BSS)); LONG(SIZEOF(.CPU0_UNTRUSTED_BSS));


    PROVIDE(__cpu1_clear_table = .) ;
    LONG(0 + ADDR(.CPU1_TRUSTED_BSS)); LONG(SIZEOF(.CPU1_TRUSTED_BSS));
    LONG(0 + ADDR(.CPU1_UNTRUSTED_BSS)); LONG(SIZEOF(.CPU1_UNTRUSTED_BSS));

	  PROVIDE(__cpu2_clear_table = .) ;
    LONG(0 + ADDR(.CPU2_TRUSTED_BSS)); LONG(SIZEOF(.CPU2_TRUSTED_BSS));
    LONG(0 + ADDR(.CPU2_UNTRUSTED_BSS)); LONG(SIZEOF(.CPU2_UNTRUSTED_BSS));

    LONG(-1);                 LONG(-1);

  } > PFLASH0_CONST
/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/
  .copy_sec :
  {
    . = ALIGN(8);
    PROVIDE(__cpu0_copy_table = .) ;
    LONG(LOADADDR(.CPU0_TRUSTED_DATA)); LONG(0 + ADDR(.CPU0_TRUSTED_DATA)); LONG(SIZEOF(.CPU0_TRUSTED_DATA));
    LONG(LOADADDR(.CPU0_UNTRUSTED_DATA)); LONG(0 + ADDR(.CPU0_UNTRUSTED_DATA)); LONG(SIZEOF(.CPU0_UNTRUSTED_DATA));
    LONG(LOADADDR(.FLS_AC_ERASE));      LONG(0 + ADDR(.FLS_AC_ERASE)); LONG(SIZEOF(.FLS_AC_ERASE));
	  LONG(LOADADDR(.FLS_AC_WRITE));      LONG(0 + ADDR(.FLS_AC_WRITE)); LONG(SIZEOF(.FLS_AC_WRITE));
    LONG(LOADADDR(.SHARED_DATA_TRUSTED)); LONG(0 + ADDR(.SHARED_DATA_TRUSTED)); LONG(SIZEOF(.SHARED_DATA_TRUSTED));
    LONG(LOADADDR(.SHARED_DATA_UNTRUSTED)); LONG(0 + ADDR(.SHARED_DATA_UNTRUSTED)); LONG(SIZEOF(.SHARED_DATA_UNTRUSTED));


    PROVIDE(__cpu1_copy_table = .) ;
    LONG(LOADADDR(.CPU1_TRUSTED_DATA)); LONG(0 + ADDR(.CPU1_TRUSTED_DATA)); LONG(SIZEOF(.CPU1_TRUSTED_DATA));
    LONG(LOADADDR(.CPU1_UNTRUSTED_DATA)); LONG(0 + ADDR(.CPU1_UNTRUSTED_DATA)); LONG(SIZEOF(.CPU1_UNTRUSTED_DATA));
	
	  PROVIDE(__cpu2_copy_table = .) ;
    LONG(LOADADDR(.CPU2_TRUSTED_DATA)); LONG(0 + ADDR(.CPU2_TRUSTED_DATA)); LONG(SIZEOF(.CPU2_TRUSTED_DATA));
    LONG(LOADADDR(.CPU2_UNTRUSTED_DATA)); LONG(0 + ADDR(.CPU2_UNTRUSTED_DATA)); LONG(SIZEOF(.CPU2_UNTRUSTED_DATA));

    /*PROTECTED REGION ID(Protection: iROM copy section) ENABLED START*/
      /*Protection-Area for your own LDF-Code*/
    /*PROTECTED REGION END*/
    LONG(-1);                 LONG(-1);                  LONG(-1);
  } > PFLASH0_CONST
/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/
  .shared_clear_sec :
  {
    . = ALIGN(8);

    PROVIDE(__shared_clear_table = .) ;
    LONG(0 + ADDR(.SHARED_BSS_UNTRUSTED)); LONG(SIZEOF(.SHARED_BSS_UNTRUSTED));
    LONG(0 + ADDR(.SHARED_BSS_TRUSTED)); LONG(SIZEOF(.SHARED_BSS_TRUSTED));
    LONG(-1);                 LONG(-1);
  } > PFLASH0_CONST

  .shared_copy_sec :
  {
    . = ALIGN(8);

    PROVIDE(__shared_copy_table = .) ;
    LONG(LOADADDR(.SHARED_DATA_UNTRUSTED)); LONG(0 + ADDR(.SHARED_DATA_UNTRUSTED)); LONG(SIZEOF(.SHARED_DATA_UNTRUSTED));
    LONG(LOADADDR(.SHARED_DATA_TRUSTED)); LONG(0 + ADDR(.SHARED_DATA_TRUSTED)); LONG(SIZEOF(.SHARED_DATA_TRUSTED));
    LONG(-1);                 LONG(-1);                  LONG(-1);
  } > PFLASH0_CONST
/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/
  .FLS_AC_ERASE_SOURCE : ALIGN(4)
  {
  __CPU0_TRUSTED_CODE_START = .;
    PROVIDE(FLS_AC_ERASE_SOURCE_START = .);
    KEEP(*(.text.FLS_AC_ERASE_SOURCE))
    PROVIDE(FLS_AC_ERASE_SOURCE_END = .);
  }> FLS_AC_ERASE_SOURCE

  .FLS_AC_WRITE_SOURCE : ALIGN(4)
  {
    PROVIDE(FLS_AC_WRITE_SOURCE_START = .);
    KEEP(*(.text.FLS_AC_WRITE_SOURCE))
    PROVIDE(FLS_AC_WRITE_SOURCE_END = .);
  }> FLS_AC_WRITE_SOURCE

  .FLS_AC_ERASE : ALIGN(4)
  {
    IROM_BASE_ERASE = .;
    *(.FLS_AC_ERASE)
    *(.FLS_AC_ERASE.*)
    . = ALIGN(8);
  } > CPU0_PSPR_FLS_ERASE AT > FLS_AC_ERASE_SOURCE = 0

  .FLS_AC_WRITE : ALIGN(4)
  {
    IROM_BASE_WRITE = .;
    *(.FLS_AC_WRITE)
    *(.FLS_AC_WRITE.*)
    . = ALIGN(8);
  } > CPU0_PSPR_FLS_WRITE AT > FLS_AC_WRITE_SOURCE = 0
/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/
/* Code section for Os Application on Core 0 */
  .CPU0_TRUSTED_CODE : ALIGN(4)
  {
  *(.text.RE_ASW*)
  *(.text.RE_BSW*)
  *(.text.IC_BswM*)
  *(.text.CPU0_Code)
  *(.text.Os_Entry_OsTask*)
  *(.text.Os_Entry_ECU_StartupTask*)
  *(.text.RE*Os*)

  *(.text.*SWC_func*)
  *(.text.*Mcal*)

  *(.text.BswM*)
  *(.text.CPU*)
  *(.text.Can*)
  *(.text.Com*)
  *(.text.ComM*)
  *(.text.Crc*)
  *(.text.Dcm*)
  *(.text.Dem*)
  *(.text.Det*)
  
  *(.text.Fee*)
  *(.text.Fls*)
  *(.text.Gpt*)
  *(.text.Gtm*)
  *(.text.Icu*)
  *(.text.Mcu*)
  *(.text.MemIf*)
  *(.text.Nm*)
  *(.text.TestNm*)
  *(.text.NM*)
  *(.text.NvM*)
  *(.text.NVM*)
  *(.text.PduR*)
  *(.text.Port*)

  *(.text.Wdg*)
  *(.text.WDG*)
  *(.text.Xcp*)
  *(.text.rba*)
  *(.text.Diag*)
  *(.text.RunnableEntity_0_func)

  *(.text.GetSeed)
  *(.text.Overlay*)
  *(.text.Bfx*)
  *(.text.CompareKey)
  *(.text.UpdatePIMWithValue)
  *(.text.CheckCondition)
  *(.text.*Core0*)
  *(.text.*CORE0*)

  *(.text.IdleTick)

  *(.text.*Dio*)

    __CPU0_TRUSTED_CODE_END = .;
  } > PFLASH0_CPU0_PRIVATE

  .CPU0_UNTRUSTED_CODE : ALIGN(4)
  {
    __CPU0_UNTRUSTED_CODE_START = .;
    *(.text.CPU0*UNTRUSTED*)
    __CPU0_UNTRUSTED_CODE_END = .;
  } > PFLASH0_CPU0_PRIVATE
/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/
/* Code section for Os Application on Core 1 */

  .CPU1_TRUSTED_CODE : ALIGN(4)
  {
    __CPU1_TRUSTED_CODE_START = .;
    *(.text.CPU1_Code)
    *(.text.*Core1*)
    *(.text.*CORE1*)
    *(.text.Os_Entry_Core1_OsTask*)
    __CPU1_TRUSTED_CODE_END = .;
  } > PFLASH0_CPU1_PRIVATE
  .CPU1_UNTRUSTED_CODE : ALIGN(4)
  {
    __CPU1_UNTRUSTED_CODE_START = .;
    *(.text.CPU1*UNTRUSTED*)
    __CPU1_UNTRUSTED_CODE_END = .;
  } > PFLASH0_CPU1_PRIVATE
/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/
/* Code section for Os Application on Core 2 */
  .CPU2_TRUSTED_CODE : ALIGN(4)
  {
    __CPU2_TRUSTED_CODE_START = .;
    *(.text.CPU2_Code)
    *(.text.*Core2*)
    *(.text.*CORE2*)
    *(.text.Os_Entry_Core2_OsTask*)
    __CPU2_TRUSTED_CODE_END = .;
  } > PFLASH0_CPU2_PRIVATE
  .CPU2_TRUSTED_CODE : ALIGN(4)
  {
    __CPU2_UNTRUSTED_CODE_START = .;

    *(.text.CPU2*UNTRUSTED*)
    __CPU2_UNTRUSTED_CODE_END = .;
  } > PFLASH0_CPU2_PRIVATE

/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/
/* Code accessed by Trusted-with-Protectin OsApp */
  .SHARED_CODE_TRUSTED : ALIGN(4)
  {
  __SHARED_CODE_TRUSTED_START = .;
    *(.text)
    *(.text.Os_*)
    *(.text.Loop_EcuM*)
    *(.text.SharedTrusted_Code)
    *(.text.EcuM*)
    *(.text.VectorTable_Init)
    *(.text.*lib*)
    *(.text.*Hook*)
    *(.text.IC*Time)
  __SHARED_CODE_TRUSTED_END = .;
  } > PFLASH0_SHARED_CODE

  .SHARED_CODE_UNTRUSTED : ALIGN(4)
  {
  __SHARED_CODE_UNTRUSTED_START = .;
    *(.text.*Rte*)
    *(.text.SchM*)
  __SHARED_CODE_UNTRUSTED_END = .;
  } > PFLASH0_SHARED_CODE
/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/
/* Data section for Shared data on LMU RAM, Read & Write access */
  .SHARED_DATA_UNTRUSTED : ALIGN(4)
  {
	__SHARED_DATA_UNTRUSTED_START = .; 
    *(.data.Rte*)  
  } > LMU_SRAM AT > PFLASH0_SHARED_CODE
  
  .SHARED_BSS_UNTRUSTED : ALIGN(4)
  {  
    	*(.bss.Rte*)
	__SHARED_DATA_UNTRUSTED_END = .;
  } > LMU_SRAM
/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/ 
  /* Shared data among partitions, Untrusted Partition only has Read access */
  .SHARED_DATA_TRUSTED : ALIGN(4)
  {
    __SHARED_DATA_TRUSTED_START = .;
    *(.data.Os*)
    *(.data.EcuM*) 
  } > LMU_SRAM AT > PFLASH0_SHARED_CODE
  
  .SHARED_BSS_TRUSTED : ALIGN(4)
  {
    *(.bss.Os*)
    *(.bss.OS*)
    *(.bss.Millisecond_count)
    *(.bss.err_cnt*)
    *(.bss.err_log*)
    *(.bss.OS*)  
    *(.bss.EcuM*)
    *(.bss.*DEFAULT*) 
    
	__SHARED_DATA_TRUSTED_END = .;
  } > LMU_SRAM 
/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/
/* Data section for Os Application on Core 0 */

  .CPU0_TRUSTED_DATA : ALIGN(4)
  {
  __CPU0_TRUSTED_DATA_START = .;
      
      *(.data.SWC_func*)
      *(.data.Mcal*)
      *(.data.Bsw*)
      *(.data.CPU*)
      *(.data.Can*)
      *(.data.Com*)
      *(.data.ComM*)
      *(.data.Crc*)
      *(.data.Dcm*)
      *(.data.Dem*)
      *(.data.Det*)
      *(.data.Fee*)
      *(.data.Fls*)
      *(.data.Gpt*)
      *(.data.Gtm*)
      *(.data.Icu*)
      *(.data.Mcu*)
      *(.data.MemIf*)
      *(.data.Nm*)
      *(.data.NM*)
      *(.data.NvM*)
      *(.data.NVM*)
      *(.data.Nvm*)
      *(.data.PduR*)
      *(.data.Port*)

      *(.data.SchM*)
      *(.data.Wdg*)
      *(.data.WDG*)
      *(.data.Xcp*)
      *(.data.rba*)
      *(.data.Diag*)
      *(.data.*Core0*)
      *(.data.*CORE0*)
      *(.data.Dio*)

      *(.data.*Inte*)
      *(.data.*SWC_*)
      *(.data.*libc*)

      *(.data.x*)
      *(.data.write*)
      *(.data.*dsd*)
      *(.data.SetOsTest)
      *(.data.Condition)
      *(.data.stDsdSubState_u8)

	. = ALIGN(4);
   } > CPU0_DMI_DSPR AT > PFLASH0_CPU0_PRIVATE

  .CPU0_TRUSTED_BSS : ALIGN(4)
  {
    *(.bss.SWC_func*)
    *(.bss.Mcal*)
    *(.bss.Bsw*)
    *(.bss.CPU*)
    *(.bss.Can*)
    *(.bss.Com*)
    *(.bss.ComM*)
    *(.bss.Crc*)
    *(.bss.Dcm*)
    *(.bss.Dem*)
    *(.bss.Det*)
    *(.bss.Fee*)
    *(.bss.Fls*)
    *(.bss.Gpt*)
    *(.bss.Gtm*)
    *(.bss.Icu*)
    *(.bss.Mcu*)
    *(.bss.MemIf*)
    *(.bss.Nm*)
    *(.bss.NM*)
    *(.bss.NvM*)
    *(.bss.NVM*)
    *(.bss.Nvm*)
    *(.bss.PduR*)
    *(.bss.Port*)
    *(.bss.Rte*)
    *(.bss.SchM*)
    *(.bss.Wdg*)
    *(.bss.WDG*)
    *(.bss.Xcp*)
    *(.bss.rba*)
    *(.bss.Diag*)
    *(.bss.*Core0*)
    *(.bss.*CORE0*)
    *(.bss.Dio*) 

    *(.bss.Os_*) 
    *(.bss.SWC*) 

    *(.bss.main*) 
    *(.bss.stub_*) 
    *(.bss.*libc*) 

    *(.bss.Test_*) 
    *(.bss.test*)
    *(.bss.count*) 
    *(.bss.ret*) 
    *(.bss.read*)
    *(.bss.Read*)
    *(.bss.write*)
    *(.bss.Write*)
    *(.bss.Pfc*)
    *(.bss.*DID*) 
    *(.bss.shutdown_b)
    *(.bss.genUint8) 
    *(.bss.VacuumPumpPressure_Data) 
    *(.bss.Pfc*)
    *(.bss.status*)
    *(.bss.Counter*)
    *(.bss.TEST_DATA_NVM*)
    *(.bss.InvalidData)
    *(.bss.MngData*)
    *(.bss.Entity1_Count*)
    *(.bss.s_*)
    *(.bss.Dsp*)
    *(.bss.stDsd*)
    *(.bss.dataRet*)  
    *(.bss.retRead*)  
    *(.bss.stDsdState_en*)
    *(.bss.Task_*ms_cnt*)
    *(.bss.osTask_*ms_cnt*)
    *(.bss.Task*ms_flag*)
    *(.bss.cnt*)
    *(.bss.Entity1_Count*)
    *(.bss.dataRet*)
    *(.bss.genUint8)
    *(.bss.isQualified)
    *(.bss.lastIndexPreviousMain)
    *(.bss.mode_routine)
    *(.bss.tmp*)
    *(.bss.MDF*)
    *(.bss.Measured*)
    *(.bss.lastIndexPreviousMain*)
    *(.bss.passive*)
    *(.bss.active*)
    *(.bss.x*)
    *(.bss.preTotalTick*)
    *(.bss.Swdt*)
    *(.bss.Wdt*)


	__CPU0_TRUSTED_DATA_END = .;
  } > CPU0_DMI_DSPR

  .CPU0_UNTRUSTED_DATA : ALIGN(4)
  {
    __CPU0_UNTRUSTED_DATA_START = .;
	. = ALIGN(4);
	*(.data.CPU0*UNTRUSTED*)
   } > CPU0_DMI_DSPR AT > PFLASH0_CPU0_PRIVATE

  .CPU0_UNTRUSTED_BSS : ALIGN(4)
  {
  . = ALIGN(4);
  *(.bss.CPU0*UNTRUSTED*)
	. = ALIGN(4);
	__CPU0_UNTRUSTED_DATA_END = .;
  } > CPU0_DMI_DSPR

/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/
/* Data section for Trusted Os Application on Core 1 */

  .CPU1_TRUSTED_DATA : ALIGN(4)
  {
    __CPU1_TRUSTED_DATA_START = .;
    *(.data.CPU1_unspec*)
    *(.data.CPU1_bool*)
    *(.data.CPU1_8*)
    *(.data.CPU1_16*)
    *(.data.CPU1_32*)
  } > CPU1_DMI_DSPR  AT > PFLASH0_CPU1_PRIVATE

  .CPU1_TRUSTED_BSS : ALIGN(4)
  {
	*(.bss.CPU1_unspec*)
    *(.bss.CPU1_bool*)
    *(.bss.CPU1_8*)
    *(.bss.CPU1_16*)
    *(.bss.CPU1_32*)
    *(.bss.CPU1.CPU1*)
    __CPU1_TRUSTED_DATA_END = .;
  } > CPU1_DMI_DSPR

  .CPU1_UNTRUSTED_DATA : ALIGN(4)
  {
    __CPU1_UNTRUSTED_DATA_START = .;
    *(.data.CPU1*UNTRUSTED*)
	. = ALIGN(4);
   } > CPU1_DMI_DSPR AT > PFLASH0_CPU1_PRIVATE

  .CPU1_UNTRUSTED_BSS : ALIGN(4)
  {
  
  	*(.bss.CPU1*UNTRUSTED*)
	. = ALIGN(4);
	__CPU1_UNTRUSTED_DATA_END = .;
  } > CPU1_DMI_DSPR
  
/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/ 
/* Data section for Trusted Os Application on Core 2 */

  .CPU2_TRUSTED_DATA : ALIGN(4)
  {
  __CPU2_TRUSTED_DATA_START = .;
    *(.data.CPU2_unspec*)
    *(.data.CPU2_bool*)
    *(.data.CPU2_8*)
    *(.data.CPU2_16*)
    *(.data.CPU2_32*)
  } > CPU2_DMI_DSPR  AT > PFLASH0_CPU2_PRIVATE

  .CPU2_TRUSTED_BSS : ALIGN(4)
  {
	*(.bss.CPU2_unspec*)
    *(.bss.CPU2_bool*)
    *(.bss.CPU2_8*)
    *(.bss.CPU2_16*)
    *(.bss.CPU2_32*)
	__CPU2_TRUSTED_DATA_END = .;
  } > CPU2_DMI_DSPR

 .CPU2_UNTRUSTED_DATA : ALIGN(4)
  {
  __CPU2_UNTRUSTED_DATA_START = .;
	. = ALIGN(4);
	*(.data.CPU2*UNTRUSTED*)
   } > CPU2_DMI_DSPR AT > PFLASH0_CPU2_PRIVATE

  .CPU2_UNTRUSTED_BSS : ALIGN(4)
  {
  . = ALIGN(4);
  *(.bss.CPU2*UNTRUSTED*)
	__CPU2_UNTRUSTED_DATA_END = .;
  } > CPU2_DMI_DSPR
/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/
/* Reserve for overlay memory */
  .OVERLAY_RAM_DATA	:
  {
    PROVIDE(__OVERLAY_RAM_START = .);
  } > CPU0_DSPR_CALIB

/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/
  /* Initialized sdata section */
  .CPU0_PRIVATE_SDATA  :
  {
    __CPU0_SMALL_DATA = . + 0x8000;
    __CPU0_SMALL_DATA_end = .;
  } > CPU0_DMI_DSPR  AT > PFLASH0_CPU0_PRIVATE


  .CPU1_PRIVATE_SDATA  :
  {
    __CPU1_SMALL_DATA = . + 0x8000;
    __CPU1_SMALL_DATA_end = .;
  } > CPU1_DMI_DSPR  AT > PFLASH0_CPU1_PRIVATE

  .CPU2_PRIVATE_SDATA  :
  {
    __CPU2_SMALL_DATA = . + 0x8000;
    __CPU2_SMALL_DATA_end = .;
  } > CPU2_DMI_DSPR  AT > PFLASH0_CPU2_PRIVATE
  
  /* Initialized sdata section */
  .CPU0_PRIVATE_SDATA2  :
  {
    __CPU0_SMALL_DATA2 = . + 0x8000;
    __CPU0_SMALL_DATA2_end = .;
  } > CPU0_DMI_DSPR  AT > PFLASH0_CPU0_PRIVATE

  .CPU1_PRIVATE_SDATA2  :
  {
    __CPU1_SMALL_DATA2 = . + 0x8000;
  } > CPU1_DMI_DSPR  AT > PFLASH0_CPU1_PRIVATE
  
    .CPU2_PRIVATE_SDATA2  :
  {
    __CPU2_SMALL_DATA2 = . + 0x8000;
  } > CPU2_DMI_DSPR  AT > PFLASH0_CPU2_PRIVATE
/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/
  /* Initialized zdata section */

  .CPU0_PRIVATE_ZDATA  :
  {
    PROVIDE(__CPU0_PRIVATE_ZDATA_start = .);
    PROVIDE(__CPU0_PRIVATE_ZDATA_end = .);
  } > CPU0_DMI_DSPR  AT > PFLASH0_CPU0_PRIVATE

  .CPU1_PRIVATE_ZDATA  :
  {
    PROVIDE(__CPU1_PRIVATE_ZDATA_start = .);
    PROVIDE(__CPU1_PRIVATE_ZDATA_end = .);
  } > CPU1_DMI_DSPR  AT > PFLASH0_CPU1_PRIVATE
  
  .CPU2_PRIVATE_ZDATA  :
  {
    PROVIDE(__CPU2_PRIVATE_ZDATA_start = .);
    PROVIDE(__CPU2_PRIVATE_ZDATA_end = .);
  } > CPU2_DMI_DSPR  AT > PFLASH0_CPU2_PRIVATE
/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/
  /* Initialized bit data section */
  .CPU0_PRIVATE_BDATA  :
  {
    PROVIDE(__CPU0_PRIVATE_BDATA_start = .);
    PROVIDE(__CPU0_PRIVATE_BDATA_end = .);
  } > CPU0_DMI_DSPR  AT > PFLASH0_CPU0_PRIVATE

  .CPU1_PRIVATE_BDATA  :
  {
    PROVIDE(__CPU1_PRIVATE_BDATA_start = .);
    PROVIDE(__CPU1_PRIVATE_BDATA_end = .);
  } > CPU1_DMI_DSPR  AT > PFLASH0_CPU1_PRIVATE
  
   .CPU2_PRIVATE_BDATA  :
  {
    PROVIDE(__CPU2_PRIVATE_BDATA_start = .);
    *(.bdata.CPU2.Private*)
    PROVIDE(__CPU2_PRIVATE_BDATA_end = .);
  } > CPU2_DMI_DSPR  AT > PFLASH0_CPU2_PRIVATE
/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/
  .cpu0_csa :
  {
     . = ALIGN(64);
     __CPU0_CSA_BEGIN = . ;
     . += __CSA_SIZE;
     __CPU0_CSA_END = .;
  } > CPU0_DSPR_CSA

  .cpu0_istack :
  {
    . =  ALIGN(8);
    . += __ISTACK_SIZE;
    __CPU0_ISTACK = .;
  } > CPU0_DSPR_STACK

  .cpu0_ustack :
  {
    . =  ALIGN(8);
    . += __USTACK_SIZE;
    __CPU0_USTACK = .;
  } > CPU0_DSPR_STACK
/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/
  .cpu1_csa :
  {
     . = ALIGN(64);
     __CPU1_CSA_BEGIN = . ;
     . += __CSA_SIZE;
     . = ALIGN(64);
     __CPU1_CSA_END = .;
  } > CPU1_DSPR_CSA

  .cpu1_istack :
  {
    . =  ALIGN(8);
    . += __ISTACK_SIZE;
    __CPU1_ISTACK = .;
  } > CPU1_DSPR_STACK

  .cpu1_ustack :
  {
    . =  ALIGN(8);
    . += __USTACK_SIZE;
    __CPU1_USTACK = .;
  } > CPU1_DSPR_STACK
/*---------------------------------------------------------------------*/
/*---------------------------------------------------------------------*/
   .cpu2_csa :
  {
     . = ALIGN(64);
     __CPU2_CSA_BEGIN = . ;
     . += __CSA_SIZE;
     . = ALIGN(64);
     __CPU2_CSA_END = .;
  } > CPU2_DSPR_CSA

  .cpu2_istack :
  {
    . =  ALIGN(8);
    . += __ISTACK_SIZE;
    __CPU2_ISTACK = .;
  } > CPU2_DSPR_STACK

  .cpu2_ustack :
  {
    . =  ALIGN(8);
    . += __USTACK_SIZE;
    __CPU2_USTACK = .;
  } > CPU2_DSPR_STACK
/*---------------------------------------------------------------------*/
}

