	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 19053136 SN 09001910"
	.compiler_invocation	"ctc -f cc15616a -c99 --integer-enumeration -D__CPU__=tc27x -D__CPU_TC27X__ --core=tc1.6.x --eabi-compliant --fp-model=-float -D_TASKING_C_TRICORE_=1 -I.\\output\\inc -g2 -t4 --language=-comments,-gcc,+volatile,-strings --default-near-size=0 -O2ROPYGKLF-predict --default-a1-size=0 --default-a0-size=0 --source --switch=auto -o output\\objs\\BSW\\src\\BSW\\Gen\\Fee\\Fee_Medium.src BSW\\src\\BSW\\Gen\\Fee\\src\\Fee_Medium.c"
	.compiler_name		"ctc"
	;source	'BSW\\src\\BSW\\Gen\\Fee\\src\\Fee_Medium.c'

	
$TC16X
	
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L3:
	.word	9183
	.half	3
	.word	.L4
	.byte	4
.L2:
	.byte	1
	.byte	'BSW\\src\\BSW\\Gen\\Fee\\src\\Fee_Medium.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L5
	.byte	2,1,3
	.word	136
	.byte	4
	.byte	'__codeptr',0,1,1,1
	.word	138
	.byte	5
	.byte	'char',0,1,6,4
	.byte	'sint8',0,2,76,25
	.word	161
	.byte	5
	.byte	'unsigned char',0,1,8,4
	.byte	'uint8',0,2,81,25
	.word	183
	.byte	5
	.byte	'unsigned short int',0,2,7,4
	.byte	'uint16',0,2,91,25
	.word	214
	.byte	5
	.byte	'unsigned int',0,4,7,4
	.byte	'uint32',0,2,106,24
	.word	251
	.byte	5
	.byte	'unsigned long long int',0,8,7,4
	.byte	'uint64',0,2,111,30
	.word	282
	.byte	4
	.byte	'boolean',0,2,127,25
	.word	183
	.byte	4
	.byte	'StatusType',0,3,191,1,27
	.word	183
	.byte	4
	.byte	'Std_ReturnType',0,3,199,1,15
	.word	183
	.byte	6,3,206,1,9,8,7
	.byte	'vendorID',0
	.word	214
	.byte	2,2,35,0,7
	.byte	'moduleID',0
	.word	214
	.byte	2,2,35,2,7
	.byte	'sw_major_version',0
	.word	183
	.byte	1,2,35,4,7
	.byte	'sw_minor_version',0
	.word	183
	.byte	1,2,35,5,7
	.byte	'sw_patch_version',0
	.word	183
	.byte	1,2,35,6,0,4
	.byte	'Std_VersionInfoType',0,3,213,1,3
	.word	383
	.byte	6,4,93,9,8,7
	.byte	'Class',0
	.word	183
	.byte	1,2,35,0,7
	.byte	'TIN',0
	.word	183
	.byte	1,2,35,1,7
	.byte	'ReturnAddress',0
	.word	251
	.byte	4,2,35,4,0,4
	.byte	'OsTrapInfoType',0,4,97,3
	.word	533
	.byte	8,68
	.word	251
	.byte	9,16,0,6,4,154,1,9,68,7
	.byte	'store',0
	.word	613
	.byte	68,2,35,0,0,8,68
	.word	622
	.byte	9,0,0,4
	.byte	'Os_JumpBufType',0,4,156,1,3
	.word	644
	.byte	4
	.byte	'Os_StackTraceType',0,4,174,1,18
	.word	251
	.byte	6,4,175,1,9,8,7
	.byte	'sp',0
	.word	251
	.byte	4,2,35,0,7
	.byte	'ctx',0
	.word	251
	.byte	4,2,35,4,0,4
	.byte	'Os_StackValueType',0,4,175,1,63
	.word	704
	.byte	4
	.byte	'Os_StackSizeType',0,4,176,1,27
	.word	704
	.byte	10,1,1,3
	.word	789
	.byte	4
	.byte	'Os_VoidVoidFunctionType',0,4,179,1,16
	.word	792
	.byte	4
	.byte	'ApplicationType',0,4,193,1,23
	.word	183
	.byte	11
	.byte	'Os_ApplicationConfigurationType_s',0,4,198,1,16,2,7
	.byte	'app_id',0
	.word	183
	.byte	1,2,35,0,7
	.byte	'access',0
	.word	183
	.byte	1,2,35,1,0,4
	.byte	'Os_ApplicationConfigurationType',0,4,201,1,3
	.word	855
	.byte	4
	.byte	'Os_CoreStateType',0,4,203,1,16
	.word	251
	.byte	4
	.byte	'AreaIdType',0,4,204,1,16
	.word	214
	.byte	4
	.byte	'Os_PeripheralAddressType',0,4,212,1,22
	.word	251
	.byte	4
	.byte	'TickType',0,4,221,1,22
	.word	251
	.byte	4
	.byte	'Os_StopwatchTickType',0,4,225,1,22
	.word	251
	.byte	3
	.word	251
	.byte	4
	.byte	'Os_Lockable',0,4,234,1,18
	.word	1097
	.byte	4
	.byte	'CoreIdType',0,4,236,1,16
	.word	214
	.byte	4
	.byte	'SpinlockIdType',0,4,237,1,16
	.word	214
	.byte	12,4,239,1,9,4,13
	.byte	'TRYTOGETSPINLOCK_SUCCESS',0,0,13
	.byte	'TRYTOGETSPINLOCK_NOSUCCESS',0,1,0,4
	.byte	'TryToGetSpinlockType',0,4,239,1,74
	.word	1167
	.byte	12,4,174,2,9,4,13
	.byte	'APPLICATION_ACCESSIBLE',0,0,13
	.byte	'APPLICATION_RESTARTING',0,1,13
	.byte	'APPLICATION_TERMINATED',0,2,0,4
	.byte	'ApplicationStateType',0,4,174,2,92
	.word	1260
	.byte	14
	.byte	'void',0,3
	.word	1372
	.byte	15,1,1,16
	.word	183
	.byte	16
	.word	1378
	.byte	0,3
	.word	1383
	.byte	4
	.byte	'Os_FunctionEntryType',0,4,183,2,16
	.word	1397
	.byte	11
	.byte	'Os_MeterInfoType_s',0,4,193,2,16,48,7
	.byte	'elapsed',0
	.word	251
	.byte	4,2,35,0,7
	.byte	'previous',0
	.word	251
	.byte	4,2,35,4,7
	.byte	'max',0
	.word	251
	.byte	4,2,35,8,7
	.byte	'cumulative',0
	.word	251
	.byte	4,2,35,12,7
	.byte	'stackbase',0
	.word	704
	.byte	8,2,35,16,7
	.byte	'stackusage',0
	.word	704
	.byte	8,2,35,24,7
	.byte	'stackmax',0
	.word	704
	.byte	8,2,35,32,7
	.byte	'stackbudget',0
	.word	704
	.byte	8,2,35,40,0,4
	.byte	'Os_MeterInfoType',0,4,202,2,3
	.word	1432
	.byte	3
	.word	1432
	.byte	4
	.byte	'Os_MeterInfoRefType',0,4,203,2,50
	.word	1630
	.byte	4
	.byte	'EventMaskType',0,4,206,2,15
	.word	183
	.byte	4
	.byte	'Os_imaskType',0,4,211,2,16
	.word	251
	.byte	11
	.byte	'Os_ISRDynType_s',0,4,213,2,16,48,7
	.byte	'meter',0
	.word	1432
	.byte	48,2,35,0,0,4
	.byte	'Os_ISRDynType',0,4,215,2,3
	.word	1709
	.byte	3
	.word	1709
	.byte	17
	.word	1770
	.byte	11
	.byte	'Os_ISRType_s',0,4,216,2,16,24,7
	.byte	'entry_function',0
	.word	797
	.byte	4,2,35,0,7
	.byte	'dynamic',0
	.word	1775
	.byte	4,2,35,4,7
	.byte	'imask',0
	.word	251
	.byte	4,2,35,8,7
	.byte	'stackbudget',0
	.word	704
	.byte	8,2,35,12,7
	.byte	'access',0
	.word	183
	.byte	1,2,35,20,7
	.byte	'application',0
	.word	183
	.byte	1,2,35,21,0,4
	.byte	'Os_ISRType',0,4,223,2,3
	.word	1780
	.byte	3
	.word	789
	.byte	17
	.word	1780
	.byte	3
	.word	1939
	.byte	4
	.byte	'ISRType',0,4,224,2,46
	.word	1944
	.byte	4
	.byte	'Os_bitmask',0,4,239,2,22
	.word	251
	.byte	4
	.byte	'Os_pset0Type',0,4,240,2,20
	.word	251
	.byte	4
	.byte	'Os_pset1Type',0,4,241,2,20
	.word	251
	.byte	4
	.byte	'Os_pset2Type',0,4,242,2,20
	.word	251
	.byte	18,4,243,2,9,4,7
	.byte	'p0',0
	.word	251
	.byte	4,2,35,0,7
	.byte	'p1',0
	.word	251
	.byte	4,2,35,0,7
	.byte	'p2',0
	.word	251
	.byte	4,2,35,0,0,4
	.byte	'Os_psetType',0,4,247,2,3
	.word	2052
	.byte	18,4,249,2,9,4,7
	.byte	't0',0
	.word	251
	.byte	4,2,35,0,7
	.byte	't1',0
	.word	251
	.byte	4,2,35,0,7
	.byte	't2',0
	.word	251
	.byte	4,2,35,0,0,4
	.byte	'Os_tpmaskType',0,4,253,2,3
	.word	2116
	.byte	4
	.byte	'Os_ActivationCountType',0,4,254,2,23
	.word	183
	.byte	11
	.byte	'Os_TaskDynType_s',0,4,128,3,16,120,7
	.byte	'terminate_jump_buf',0
	.word	653
	.byte	68,2,35,0,7
	.byte	'meter',0
	.word	1432
	.byte	48,2,35,68,7
	.byte	'activation_count',0
	.word	183
	.byte	1,2,35,116,0,4
	.byte	'Os_TaskDynType',0,4,132,3,3
	.word	2214
	.byte	8,68
	.word	622
	.byte	9,0,0,3
	.word	2214
	.byte	17
	.word	2340
	.byte	11
	.byte	'Os_TaskType_s',0,4,134,3,16,40,7
	.byte	'dynamic',0
	.word	2345
	.byte	4,2,35,0,7
	.byte	'entry_function',0
	.word	797
	.byte	4,2,35,4,7
	.byte	'pset',0
	.word	2052
	.byte	4,2,35,8,7
	.byte	'base_tpmask',0
	.word	2116
	.byte	4,2,35,12,7
	.byte	'tpmask',0
	.word	2116
	.byte	4,2,35,16,7
	.byte	'core_id',0
	.word	214
	.byte	2,2,35,20,7
	.byte	'index',0
	.word	251
	.byte	4,2,35,24,7
	.byte	'stackbudget',0
	.word	704
	.byte	8,2,35,28,7
	.byte	'activation_count',0
	.word	183
	.byte	1,2,35,36,7
	.byte	'access',0
	.word	183
	.byte	1,2,35,37,7
	.byte	'application',0
	.word	183
	.byte	1,2,35,38,0,4
	.byte	'Os_TaskType',0,4,146,3,3
	.word	2350
	.byte	17
	.word	2350
	.byte	3
	.word	2600
	.byte	4
	.byte	'TaskType',0,4,147,3,47
	.word	2605
	.byte	19
	.byte	'Os_TaskStateType',0,4,155,3,6,4,13
	.byte	'SUSPENDED',0,0,13
	.byte	'READY',0,1,13
	.byte	'WAITING',0,2,13
	.byte	'RUNNING',0,3,0,4
	.byte	'TaskStateType',0,4,156,3,31
	.word	2628
	.byte	18,4,167,3,3,4,7
	.byte	'tpmask',0
	.word	2116
	.byte	4,2,35,0,0,11
	.byte	'Os_ResourceDynType_s',0,4,166,3,16,4,7
	.byte	'saved_priority',0
	.word	2715
	.byte	4,2,35,0,0,4
	.byte	'Os_ResourceDynType',0,4,170,3,3
	.word	2738
	.byte	3
	.word	2738
	.byte	17
	.word	2818
	.byte	11
	.byte	'Os_ResourceType_s',0,4,171,3,16,12,7
	.byte	'dynamic',0
	.word	2823
	.byte	4,2,35,0,7
	.byte	'tpmask',0
	.word	2116
	.byte	4,2,35,4,7
	.byte	'access',0
	.word	183
	.byte	1,2,35,8,0,4
	.byte	'Os_ResourceType',0,4,175,3,3
	.word	2828
	.byte	6,4,181,3,9,12,7
	.byte	'maxallowedvalue',0
	.word	251
	.byte	4,2,35,0,7
	.byte	'ticksperbase',0
	.word	251
	.byte	4,2,35,4,7
	.byte	'mincycle',0
	.word	251
	.byte	4,2,35,8,0,4
	.byte	'AlarmBaseType',0,4,185,3,3
	.word	2927
	.byte	6,4,206,3,9,8,7
	.byte	'Running',0
	.word	183
	.byte	1,2,35,0,7
	.byte	'Pending',0
	.word	183
	.byte	1,2,35,1,7
	.byte	'Delay',0
	.word	251
	.byte	4,2,35,4,0,4
	.byte	'Os_CounterStatusType',0,4,210,3,3
	.word	3022
	.byte	20
	.word	183
	.byte	1,1,3
	.word	3108
	.byte	4
	.byte	'Os_CounterIncrAdvType',0,4,217,3,22
	.word	3115
	.byte	11
	.byte	's_swd',0,4,222,3,12,4,7
	.byte	'count',0
	.word	251
	.byte	4,2,35,0,0,18,4,221,3,3,4,7
	.byte	'sw',0
	.word	3151
	.byte	4,2,35,0,0,11
	.byte	'Os_CounterDynType_s',0,4,220,3,16,4,7
	.byte	'type_dependent',0
	.word	3179
	.byte	4,2,35,0,0,4
	.byte	'Os_CounterDynType',0,4,226,3,3
	.word	3198
	.byte	3
	.word	3198
	.byte	17
	.word	3276
	.byte	11
	.byte	'Os_CounterType_s',0,4,227,3,16,28,7
	.byte	'dynamic',0
	.word	3281
	.byte	4,2,35,0,7
	.byte	'advincr',0
	.word	3120
	.byte	4,2,35,4,7
	.byte	'base',0
	.word	2927
	.byte	12,2,35,8,7
	.byte	'core',0
	.word	1378
	.byte	4,2,35,20,7
	.byte	'access',0
	.word	183
	.byte	1,2,35,24,7
	.byte	'application',0
	.word	183
	.byte	1,2,35,25,0,4
	.byte	'Os_CounterType',0,4,234,3,3
	.word	3286
	.byte	3
	.word	3108
	.byte	17
	.word	3286
	.byte	3
	.word	3438
	.byte	4
	.byte	'CounterType',0,4,235,3,52
	.word	3443
	.byte	19
	.byte	'Os_ScheduleTableStatusType',0,4,240,3,6,4,13
	.byte	'SCHEDULETABLE_STOPPED',0,0,13
	.byte	'SCHEDULETABLE_NEXT',0,1,13
	.byte	'SCHEDULETABLE_WAITING',0,2,13
	.byte	'SCHEDULETABLE_RUNNING',0,3,13
	.byte	'SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS',0,4,0,4
	.byte	'ScheduleTableStatusType',0,4,241,3,41
	.word	3469
	.byte	17
	.word	.L6-.L3
	.byte	3
	.word	3669
	.byte	4
	.byte	'ScheduleTableType',0,4,128,4,58
	.word	3674
	.byte	11
	.byte	'Os_ScheduleTableDynType_s',0,4,130,4,16,16,7
	.byte	'match',0
	.word	251
	.byte	4,2,35,0,7
	.byte	'next',0
	.word	3679
	.byte	4,2,35,4,7
	.byte	'state',0
	.word	3469
	.byte	4,2,35,8,7
	.byte	'config',0
	.word	214
	.byte	2,2,35,12,0,3
	.word	3706
	.byte	17
	.word	3799
.L6:
	.byte	11
	.byte	'Os_ScheduleTableType_s',0,4,247,3,16,16,7
	.byte	'dynamic',0
	.word	3804
	.byte	4,2,35,0,7
	.byte	'counter',0
	.word	3448
	.byte	4,2,35,4,7
	.byte	'repeat',0
	.word	183
	.byte	1,2,35,8,7
	.byte	'config',0
	.word	214
	.byte	2,2,35,10,7
	.byte	'initial',0
	.word	183
	.byte	1,2,35,12,7
	.byte	'access',0
	.word	183
	.byte	1,2,35,13,7
	.byte	'application',0
	.word	183
	.byte	1,2,35,14,0,4
	.byte	'Os_ScheduleTableType',0,4,255,3,3
	.word	3809
	.byte	17
	.word	3809
	.byte	3
	.word	3989
	.byte	17
	.word	3286
	.byte	3
	.word	3999
	.byte	21
	.word	1102
	.byte	21
	.word	2052
	.byte	21
	.word	1949
	.byte	21
	.word	2610
	.byte	21
	.word	2116
	.byte	21
	.word	183
	.byte	21
	.word	2610
	.byte	11
	.byte	'Os_ControlledCoreType_s',0,4,251,6,16,112,7
	.byte	'TrapInfo',0
	.word	533
	.byte	8,2,35,0,7
	.byte	'lock_taskaccess',0
	.word	4009
	.byte	4,2,35,8,7
	.byte	'ReadyTasks',0
	.word	4014
	.byte	4,2,35,12,7
	.byte	'RunningISR',0
	.word	4019
	.byte	4,2,35,16,7
	.byte	'RunningTask',0
	.word	4024
	.byte	4,2,35,20,7
	.byte	'RunningTPMask',0
	.word	4029
	.byte	4,2,35,24,7
	.byte	'CurrentMeteredObject',0
	.word	1635
	.byte	4,2,35,28,7
	.byte	'IdleMeter',0
	.word	1432
	.byte	48,2,35,32,7
	.byte	'AppAccess',0
	.word	183
	.byte	1,2,35,80,7
	.byte	'AppOverride',0
	.word	4034
	.byte	1,2,35,81,7
	.byte	'GetStackValueAdjust',0
	.word	704
	.byte	8,2,35,84,7
	.byte	'InErrorHook',0
	.word	183
	.byte	1,2,35,92,7
	.byte	'ChainTaskRef',0
	.word	4039
	.byte	4,2,35,96,7
	.byte	'GetStackUsageAdjust',0
	.word	704
	.byte	8,2,35,100,7
	.byte	'InProtectionHook',0
	.word	183
	.byte	1,2,35,108,7
	.byte	'CoreIsActive',0
	.word	183
	.byte	1,2,35,109,7
	.byte	'InShutdownHook',0
	.word	183
	.byte	1,2,35,110,0,4
	.byte	'Os_ControlledCoreType',0,4,141,7,3
	.word	4044
	.byte	3
	.word	251
	.byte	17
	.word	1780
	.byte	3
	.word	4500
	.byte	17
	.word	2350
	.byte	3
	.word	4510
	.byte	3
	.word	1432
	.byte	11
	.byte	'Os_AnyCoreType_s',0,4,151,7,16,96,7
	.byte	'DisableAllImask',0
	.word	251
	.byte	4,2,35,0,7
	.byte	'SuspendAllImask',0
	.word	251
	.byte	4,2,35,4,7
	.byte	'SuspendOSImask',0
	.word	251
	.byte	4,2,35,8,7
	.byte	'DisableAllCount',0
	.word	251
	.byte	4,2,35,12,7
	.byte	'SuspendAllCount',0
	.word	251
	.byte	4,2,35,16,7
	.byte	'SuspendOSCount',0
	.word	251
	.byte	4,2,35,20,7
	.byte	'RestartJumpBuf',0
	.word	653
	.byte	68,2,35,24,7
	.byte	'Restartable',0
	.word	183
	.byte	1,2,35,92,0,4
	.byte	'Os_AnyCoreType',0,4,160,7,3
	.word	4525
	.byte	4
	.byte	'unsigned_int',0,5,116,22
	.word	251
	.byte	12,6,31,9,4,13
	.byte	'MEMIF_JOB_OK',0,0,13
	.byte	'MEMIF_JOB_FAILED',0,1,13
	.byte	'MEMIF_JOB_PENDING',0,2,13
	.byte	'MEMIF_JOB_CANCELED',0,3,13
	.byte	'MEMIF_BLOCK_INCONSISTENT',0,4,13
	.byte	'MEMIF_BLOCK_INVALID',0,5,0,4
	.byte	'MemIf_JobResultType',0,6,39,2
	.word	4787
	.byte	12,6,41,9,4,13
	.byte	'MEMIF_MODE_SLOW',0,0,13
	.byte	'MEMIF_MODE_FAST',0,1,0,4
	.byte	'MemIf_ModeType',0,6,45,2
	.word	4945
	.byte	4
	.byte	'PduIdType',0,7,22,19
	.word	214
	.byte	4
	.byte	'PduLengthType',0,7,26,19
	.word	214
	.byte	12,8,113,9,4,13
	.byte	'TP_DATACONF',0,0,13
	.byte	'TP_DATARETRY',0,1,13
	.byte	'TP_CONFPENDING',0,2,0,4
	.byte	'TpDataStateType',0,8,118,3
	.word	5050
	.byte	4
	.byte	'Can_IdType',0,9,32,16
	.word	251
	.byte	4
	.byte	'Can_HwHandleType',0,9,43,16
	.word	214
	.byte	4
	.byte	'Can_TxObjPriorityClassType',0,10,219,3,16
	.word	251
	.byte	11
	.byte	'Can_TxHwObjectConfigType',0,10,231,3,16,8,7
	.byte	'MsgObjId',0
	.word	183
	.byte	1,2,35,0,7
	.byte	'HwControllerId',0
	.word	183
	.byte	1,2,35,1,7
	.byte	'TxObjPriorityClass',0
	.word	251
	.byte	4,2,35,4,0,4
	.byte	'Can_TxHwObjectConfigType',0,10,252,3,3
	.word	5206
	.byte	11
	.byte	'Can_RxHwObjectConfigType',0,10,129,4,16,12,7
	.byte	'MaskRef',0
	.word	251
	.byte	4,2,35,0,7
	.byte	'MsgId',0
	.word	251
	.byte	4,2,35,4,7
	.byte	'MsgObjId',0
	.word	183
	.byte	1,2,35,8,7
	.byte	'HwControllerId',0
	.word	183
	.byte	1,2,35,9,0,4
	.byte	'Can_RxHwObjectConfigType',0,10,147,4,3
	.word	5342
	.byte	8,4
	.word	183
	.byte	9,3,0,11
	.byte	'Can_ControllerMOMapConfigType',0,10,181,4,16,4,7
	.byte	'ControllerMOMap',0
	.word	5482
	.byte	4,2,35,0,0,4
	.byte	'Can_ControllerMOMapConfigType',0,10,184,4,3
	.word	5491
	.byte	11
	.byte	'Can_NPCRValueType',0,10,188,4,16,2,7
	.byte	'Can_NPCRValue',0
	.word	214
	.byte	2,2,35,0,0,4
	.byte	'Can_NPCRValueType',0,10,191,4,3
	.word	5592
	.byte	11
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,10,194,4,16,8,7
	.byte	'CanControllerBaudrate',0
	.word	251
	.byte	4,2,35,0,7
	.byte	'CanControllerBaudrateCfg',0
	.word	214
	.byte	2,2,35,4,0,4
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,10,198,4,3
	.word	5667
	.byte	17
	.word	5667
	.byte	3
	.word	5832
	.byte	11
	.byte	'Can_BaudrateConfigPtrType',0,10,201,4,16,4,7
	.byte	'Can_kBaudrateConfigPtr',0
	.word	5837
	.byte	4,2,35,0,0,4
	.byte	'Can_BaudrateConfigPtrType',0,10,204,4,3
	.word	5842
	.byte	11
	.byte	'Can_EventHandlingType',0,10,226,4,16,4,7
	.byte	'CanEventType',0
	.word	5482
	.byte	4,2,35,0,0,4
	.byte	'Can_EventHandlingType',0,10,229,4,3
	.word	5942
	.byte	4
	.byte	'Rte_TransformerErrorCode',0,11,130,1,15
	.word	183
	.byte	4
	.byte	'Rte_TransformerClass',0,11,131,1,15
	.word	183
	.byte	6,11,168,1,9,12,7
	.byte	'in',0
	.word	1378
	.byte	4,2,35,0,7
	.byte	'out',0
	.word	1378
	.byte	4,2,35,4,7
	.byte	'used',0
	.word	214
	.byte	2,2,35,8,7
	.byte	'lost_data',0
	.word	183
	.byte	1,2,35,10,0,4
	.byte	'Rte_QDynType',0,11,173,1,3
	.word	6088
	.byte	12,11,175,1,9,4,13
	.byte	'RTE_DRA',0,0,13
	.byte	'RTE_WOWP',0,1,13
	.byte	'RTE_TASK',0,2,13
	.byte	'RTE_ARE',0,3,13
	.byte	'RTE_EV',0,4,13
	.byte	'RTE_MSI',0,5,0,4
	.byte	'Rte_NotificationType',0,11,182,1,3
	.word	6175
	.byte	8,128,8
	.word	183
	.byte	9,255,7,0,4
	.byte	'Impl_NVM_DstPtrType_1024',0,12,50,15
	.word	6273
	.byte	4
	.byte	'CanIf_u32_impl',0,12,69,16
	.word	251
	.byte	4
	.byte	'CanIf_u16_impl',0,12,71,16
	.word	214
	.byte	4
	.byte	'CanIf_u8_impl',0,12,73,15
	.word	183
	.byte	4
	.byte	'CanIf_ControllerModeType_Enum_impl',0,12,88,15
	.word	183
	.byte	4
	.byte	'CanIf_PduModeType_Enum_impl',0,12,90,15
	.word	183
	.byte	6,12,92,9,2,7
	.byte	'DeviceMode',0
	.word	183
	.byte	1,2,35,0,7
	.byte	'ChannelMode',0
	.word	183
	.byte	1,2,35,1,0,4
	.byte	'CanIf_ControllerStateType_struct_impl',0,12,95,3
	.word	6464
	.byte	4
	.byte	'CanIf_NotifStatusType_Enum_impl',0,12,100,15
	.word	183
	.byte	4
	.byte	'CanSM_boolean_Impl',0,12,120,15
	.word	183
	.byte	4
	.byte	'CanSM_u8_Impl',0,12,123,15
	.word	183
	.byte	4
	.byte	'CanSM_BusOffRecoveryStateType_Enum_impl',0,12,128,1,15
	.word	183
	.byte	4
	.byte	'CanSM_NetworkModeStateType_Enum_impl',0,12,132,1,15
	.word	183
	.byte	4
	.byte	'CanSM_u16_Impl',0,12,136,1,16
	.word	214
	.byte	4
	.byte	'CanSM_TimerStateType_Enum_impl',0,12,138,1,15
	.word	183
	.byte	6,12,140,1,9,4,7
	.byte	'cntTick_u16',0
	.word	214
	.byte	2,2,35,0,7
	.byte	'stTimer',0
	.word	183
	.byte	1,2,35,2,0,4
	.byte	'CanSM_TimerConfig_tst_struct_impl',0,12,143,1,3
	.word	6805
	.byte	4
	.byte	'Com_impl_u16',0,12,154,1,16
	.word	214
	.byte	4
	.byte	'Com_impl_u8',0,12,157,1,15
	.word	183
	.byte	4
	.byte	'ComM_uint32_Impl',0,12,173,1,16
	.word	251
	.byte	4
	.byte	'ComM_uint16_Impl',0,12,175,1,16
	.word	214
	.byte	4
	.byte	'ComM_uint8_Impl',0,12,177,1,15
	.word	183
	.byte	4
	.byte	'ComM_bool_Impl',0,12,179,1,15
	.word	183
	.byte	6,12,181,1,9,24,7
	.byte	'ChannelState_e',0
	.word	251
	.byte	4,2,35,0,7
	.byte	'LightTimeoutCtr_u32',0
	.word	251
	.byte	4,2,35,4,7
	.byte	'MinFullComTimeoutCtr_u16',0
	.word	214
	.byte	2,2,35,8,7
	.byte	'ChannelMode_u8',0
	.word	183
	.byte	1,2,35,10,7
	.byte	'BusSmMode_u8',0
	.word	183
	.byte	1,2,35,11,7
	.byte	'UserRequestCtr_u8',0
	.word	183
	.byte	1,2,35,12,7
	.byte	'PassiveRequestState_u8',0
	.word	183
	.byte	1,2,35,13,7
	.byte	'PncRequestCtr_u8',0
	.word	183
	.byte	1,2,35,14,7
	.byte	'InhibitionReqStatus_u8',0
	.word	183
	.byte	1,2,35,15,7
	.byte	'NmNetworkRequestStatus_b',0
	.word	183
	.byte	1,2,35,16,7
	.byte	'DiagnosticRequestState_b',0
	.word	183
	.byte	1,2,35,17,7
	.byte	'CommunicationAllowed_b',0
	.word	183
	.byte	1,2,35,18,7
	.byte	'NmBusSleepIndicationStatus_b',0
	.word	183
	.byte	1,2,35,19,7
	.byte	'NmPrepareBusSleepIndicationStatus_b',0
	.word	183
	.byte	1,2,35,20,7
	.byte	'NmNetworkModeStatus_b',0
	.word	183
	.byte	1,2,35,21,0,4
	.byte	'ComM_ChannelStruct_Impl',0,12,197,1,3
	.word	7037
	.byte	6,12,206,1,9,10,7
	.byte	'WakeUpInhibitionCtr_u16',0
	.word	214
	.byte	2,2,35,0,7
	.byte	'LimitToNoComCtr_u16',0
	.word	214
	.byte	2,2,35,2,7
	.byte	'RequestedUserMode_t',0
	.word	183
	.byte	1,2,35,4,7
	.byte	'IndicatedUserMode_t',0
	.word	183
	.byte	1,2,35,5,7
	.byte	'numChannelsInFullCom_u8',0
	.word	183
	.byte	1,2,35,6,7
	.byte	'numChannelsInSilentCom_u8',0
	.word	183
	.byte	1,2,35,7,7
	.byte	'numChannelsInNoCom_u8',0
	.word	183
	.byte	1,2,35,8,0,4
	.byte	'ComM_UserStruct_Impl',0,12,214,1,3
	.word	7541
	.byte	4
	.byte	'Dcm_IOOperationResponseType',0,12,252,1,15
	.word	183
	.byte	4
	.byte	'Dcm_RequestDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspRequestRoutineResultsOutSignal_0PrimitivType',0
	.byte	12,138,2,15
	.word	183
	.byte	4
	.byte	'Dcm_StartDataIn_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineInSignalPrimitivType',0,12,146,2,15
	.word	183
	.byte	4
	.byte	'Dcm_StartDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineOutSignalPrimitivType',0,12,150,2,15
	.word	183
	.byte	4
	.byte	'Dcm_StopDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStopRoutineOutSignalPrimitivType',0,12,154,2,15
	.word	183
	.byte	4
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockNative_1024_Type',0,12,243,3,34
	.word	6284
	.byte	8,128,8
	.word	183
	.byte	9,255,7,0,4
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockRedundant_1024_Type',0,12,246,3,34
	.word	6284
	.byte	4
	.byte	'Fls_LengthType',0,13,173,3,16
	.word	251
	.byte	11
	.byte	'Fls_JobStartType',0,13,175,3,16,1,22
	.byte	'Reserved1',0,1
	.word	183
	.byte	1,7,2,35,0,22
	.byte	'Write',0,1
	.word	183
	.byte	1,6,2,35,0,22
	.byte	'Erase',0,1
	.word	183
	.byte	1,5,2,35,0,22
	.byte	'Read',0,1
	.word	183
	.byte	1,4,2,35,0,22
	.byte	'Compare',0,1
	.word	183
	.byte	1,3,2,35,0,22
	.byte	'Reserved2',0,1
	.word	183
	.byte	3,0,2,35,0,0,4
	.byte	'Fls_JobStartType',0,13,183,3,3
	.word	8383
	.byte	4
	.byte	'Fls_17_Pmu_Job_Type',0,13,187,3,15
	.word	183
	.byte	3
	.word	183
	.byte	17
	.word	183
	.byte	3
	.word	8578
	.byte	8,2
	.word	183
	.byte	9,1,0,11
	.byte	'Fls_17_Pmu_StateType',0,13,198,3,16,48,7
	.byte	'FlsReadAddress',0
	.word	251
	.byte	4,2,35,0,7
	.byte	'FlsWriteAddress',0
	.word	251
	.byte	4,2,35,4,7
	.byte	'FlsEraseTimeoutCycleCount',0
	.word	251
	.byte	4,2,35,8,7
	.byte	'FlsWriteTimeoutCycleCount',0
	.word	251
	.byte	4,2,35,12,7
	.byte	'FlsReadLength',0
	.word	251
	.byte	4,2,35,16,7
	.byte	'FlsWriteLength',0
	.word	251
	.byte	4,2,35,20,7
	.byte	'FlsReadBufferPtr',0
	.word	8573
	.byte	4,2,35,24,7
	.byte	'FlsWriteBufferPtr',0
	.word	8583
	.byte	4,2,35,28,7
	.byte	'FlsJobResult',0
	.word	4787
	.byte	4,2,35,32,7
	.byte	'FlsMode',0
	.word	4945
	.byte	4,2,35,36,7
	.byte	'NotifCaller',0
	.word	183
	.byte	1,2,35,40,7
	.byte	'JobStarted',0
	.word	8383
	.byte	1,2,35,41,7
	.byte	'FlsJobType',0
	.word	8588
	.byte	2,2,35,42,7
	.byte	'FlsOper',0
	.word	183
	.byte	1,2,35,44,7
	.byte	'FlsTimeoutErr',0
	.word	183
	.byte	1,2,35,45,7
	.byte	'FlsTimeoutControl',0
	.word	183
	.byte	1,2,35,46,0,4
	.byte	'Fls_17_Pmu_StateType',0,13,130,4,3
	.word	8597
	.byte	4
	.byte	'Fls_NotifFunctionPtrType',0,13,137,4,16
	.word	792
	.byte	17
	.word	251
	.byte	3
	.word	9075
	.byte	15,1,1,16
	.word	251
	.byte	16
	.word	251
	.byte	16
	.word	9080
	.byte	16
	.word	183
	.byte	0,3
	.word	9085
	.byte	4
	.byte	'Fls_WriteCmdPtrType',0,13,139,4,16
	.word	9109
	.byte	15,1,1,16
	.word	251
	.byte	0,3
	.word	9143
	.byte	4
	.byte	'Fls_EraseCmdPtrType',0,13,144,4,16
	.word	9152
	.byte	0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L4:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,21,0,54,15,0,0,3,15,0,73,19,0,0,4,22,0,3,8,58,15,59,15
	.byte	57,15,73,19,0,0,5,36,0,3,8,11,15,62,15,0,0,6,19,1,58,15,59,15,57,15,11,15,0,0,7,13,0,3,8,73,19,11,15,56
	.byte	9,0,0,8,1,1,11,15,73,19,0,0,9,33,0,47,15,0,0,10,21,0,54,15,39,12,0,0,11,19,1,3,8,58,15,59,15,57,15,11
	.byte	15,0,0,12,4,1,58,15,59,15,57,15,11,15,0,0,13,40,0,3,8,28,13,0,0,14,59,0,3,8,0,0,15,21,1,54,15,39,12,0
	.byte	0,16,5,0,73,19,0,0,17,38,0,73,19,0,0,18,23,1,58,15,59,15,57,15,11,15,0,0,19,4,1,3,8,58,15,59,15,57,15
	.byte	11,15,0,0,20,21,0,73,19,54,15,39,12,0,0,21,53,0,73,19,0,0,22,13,0,3,8,11,15,73,19,13,15,12,15,56,9,0,0
	.byte	0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L5:
	.word	.L8-.L7
.L7:
	.half	3
	.word	.L10-.L9
.L9:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Fee\\src\\Fee_Medium.c',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Platform\\Platform_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Std_Types.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\RTOS_T\\Gen\\inc\\Os.h',0,0,0,0
	.byte	'.\\Integration\\TargetIntegration\\TC275\\Include\\Mcal_TcLib.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\MemIf\\api\\MemIf_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Can_GeneralTypes.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Can_17_MCanP\\inc\\Can_17_MCanP.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Type.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Fls\\inc\\Fls_17_Pmu.h',0,0,0,0,0
.L10:
.L8:

; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	     1  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	     2  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	     3  /*
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	     4   **********************************************************************************************************************
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	     5   * Includes
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	     7  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	     8  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	     9  #include "Fee.h"
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    10  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    11  /* Disable the Fee common part when the Fs1 is selected - currently the Fs1 is a complete Fee */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    12  #if(defined(FEE_PRV_CFG_SELECTED_FS) && (1 != FEE_PRV_CFG_SELECTED_FS))
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    13  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    14  #include "Crc.h"
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    15  #include "Fee_Prv.h"
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    16  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    17  /*
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    18   **********************************************************************************************************************
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    19   * Defines
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    20   **********************************************************************************************************************
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    21  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    22  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    23  #define FEE_PRV_MEDIUM_MAXSHREDDER  (FEE_SEC_HEADER_SIZE)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    24  #define FEE_PRV_MEDIUM_FLASHBEG     (FEE_PHYS_SEC_START0)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    25  #define FEE_PRV_MEDIUM_FLASHEND     (FEE_PRV_MEDIUM_FLASHBEG + (((FEE_PHYS_SEC_END0 + 1u) - FEE_PHYS_SEC_START0) * FEE_NUM_FLASH_BANKS_AVAILABLE))
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    26  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    27  /*
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    28   **********************************************************************************************************************
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    29   * Variables
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    30   **********************************************************************************************************************
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    31  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    32  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    33  #define FEE_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    34  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    35  /* Static */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    36  static Fee_Prv_MediumCalcCrc_tst    Fee_Prv_MediumCalcCrc_st;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    37  static Fee_Prv_MediumLoad_tst       Fee_Prv_MediumLoad_st;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    38  static Fee_Prv_MediumWrite_tst      Fee_Prv_MediumWrite_st;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    39  static Fee_Prv_MediumCopy_tst       Fee_Prv_MediumCopy_st;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    40  static Fee_Prv_Medium_tst           Fee_Prv_Medium_st;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    41  #define FEE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    42  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    43  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    44  /*
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    45   * In case of all three conditions listed below are fulfilled
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    46   * - DMA is writing into the buffer
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    47   * - data cache controller (CC) is enabled
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    48   * - buffer is linked to a cached memory region
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    49   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    50   * Fee_Prv_MediumBuffer_un has to be fully cache line aligned (start address has to be aligned to the start of a
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    51   * cache line and the buffer size has to be multiple of cache line size).
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    52   * The DMA is always bypassing the CC and has to invalidate the cache lines before writing to it,
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    53   * in order to keep cache coherence between DMA (direct writer without CC) and core (reader via CC).
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    54   * Otherwise if the cache line is shared with data of another application, the data may get corrupted.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    55  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    56  #define FEE_START_SEC_VAR_CLEARED_SECURED_CACHE_LINE_ALIGNED_UNSPECIFIED
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    57  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    58  static Fee_Prv_MediumBuffer_tun     Fee_Prv_MediumBuffer_un;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    59  #define FEE_STOP_SEC_VAR_CLEARED_SECURED_CACHE_LINE_ALIGNED_UNSPECIFIED
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    60  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    61  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    62  #if (defined(FLS_RB_ROBUST_PROG_STATUS_API) && (TRUE == FLS_RB_ROBUST_PROG_STATUS_API))
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    63  #define FEE_START_SEC_VAR_CLEARED_SECURED_8
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    64  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    65  static uint8 Fee_Prv_MediumRescueBfr_au8[RBA_FLS_WORDLINE_SIZE];
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    66  #define FEE_STOP_SEC_VAR_CLEARED_SECURED_8
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    67  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    68  #endif
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    69  /*
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    70   **********************************************************************************************************************
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    71   * Implementation
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    72   **********************************************************************************************************************
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    73  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    74  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    75  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    76  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    77  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    78  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    79   * \brief   Check the status of flash jobs.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    80   *          In synchronous mode call the Fls_MainFunction until the job is not pending any more.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    81   *          To reduce the number of software paths, MEMIF_JOB_FAILED and E_NOT_OK are both mapped to MEMIF_JOB_FAILED.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    82   *          This way the higher layers do not know whether an error occurred during job placing or job execution.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    83   *          In the end the reaction is typically always the same: Retry or abort.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    84   *          In order to differentiate between hardware failures (with return value MEMIF_JOB_FAILED) and comparison
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    85   *          mismatches of Fls compare jobs, the return value MEMIF_BLOCK_INCONSISTENT is kept for the latter. For
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    86   *          these two situations, different reaction strategies can be required.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    87   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    88   * \retval  MEMIF_JOB_PENDING          Job still pending
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    89   * \retval  MEMIF_JOB_OK               Job finished successfully
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    90   * \retval  MEMIF_JOB_FAILED           Job finished with errors
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    91   * \retval  MEMIF_BLOCK_INCONSISTENT   Compare job finished with mismatch between contents in flash and data buffer
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    92  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    93  static MemIf_JobResultType Fee_Prv_MediumFlsDo(void)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    94  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    95      MemIf_JobResultType result_en = MEMIF_JOB_FAILED;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    96      if(E_OK == Fee_Prv_Medium_st.lastFlsResult_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    97      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    98          if(TRUE == Fee_Prv_Medium_st.sync_b)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	    99          {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   100              do
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   101              {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   102                  Fls_MainFunction();
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   103                  result_en = Fls_GetJobResult();
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   104              } while(MEMIF_JOB_PENDING == result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   105          }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   106          else
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   107          {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   108              result_en = Fls_GetJobResult();
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   109          }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   110          Fee_Prv_DbgFailDump(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   111      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   112      else
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   113      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   114          Fee_Prv_DbgDump();
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   115      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   116      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   117  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   118  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   119  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   120   * \brief   Mark the medium buffer dirty
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   121  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   122  static void Fee_Prv_MediumSetBfrDirty(void)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   123  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   124      Fee_Prv_Medium_st.limitLo_u32 = 0u;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   125      Fee_Prv_Medium_st.limitHi_u32 = 0u;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   126  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   127  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   128  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   129   * \brief   Load some data from the flash to the RAM in the medium buffer.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   130   *          This is useful for buffered access to the flash.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   131   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   132   * \param   adr_u32     Address in the flash to load from
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   133   * \param   length_u32  Amount of bytes to load
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   134   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   135   * \retval  MEMIF_JOB_PENDING   Loading still going on
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   136   * \retval  MEMIF_JOB_OK        Loading finished successfully
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   137   * \retval  MEMIF_JOB_FAILED    Loading finished with an error (in this case the content of the buffer is undefined
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   138  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   139  static MemIf_JobResultType Fee_Prv_MediumLoad(uint32 adr_u32, uint32 length_u32, Fee_Prv_MediumLoadMode_ten loadMode_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   140  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   141      MemIf_JobResultType result_en = MEMIF_JOB_PENDING;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   142  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   143      if(
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   144          (Fee_Prv_Medium_st.limitLo_u32 <= (adr_u32 + 0u         )   ) &&
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   145          (Fee_Prv_Medium_st.limitHi_u32 >= (adr_u32 + length_u32 )   )
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   146      )
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   147      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   148          result_en = MEMIF_JOB_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   149      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   150      else
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   151      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   152          if(FEE_PRV_LOAD_BUSY_E != Fee_Prv_MediumLoad_st.state_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   153          {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   154              if(
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   155                  (FEE_PRV_MEDIUM_FLASHBEG <= (adr_u32 + 0u           )               ) && /* Address must be valid DFLASH address                            */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   156                  (FEE_PRV_MEDIUM_FLASHEND >= (adr_u32 + length_u32   )               ) && /* Address must be valid DFLASH address                            */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   157                  (length_u32              <= sizeof(Fee_Prv_MediumBuffer_un.u8)      ) && /* Request amount must fit into buffer                             */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   158                  (0u                      == ((FEE_VIRTUAL_PAGE_SIZE - 1u) & adr_u32))    /* Only allow 32 bit aligned accesses to avoid alignment problems  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   159              )
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   160              {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   161                  if(FEE_PRV_POSTLOAD_E == loadMode_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   162                  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   163                      Fee_Prv_MediumLoad_st.reloadAdr_u32 = Fee_Prv_LibMin(
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   164                          adr_u32,
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   165                          FEE_PRV_MEDIUM_FLASHEND - sizeof(Fee_Prv_MediumBuffer_un.u8)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   166                      );
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   167                  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   168                  else
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   169                  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   170                      Fee_Prv_MediumLoad_st.reloadAdr_u32 = Fee_Prv_LibMax(
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   171                          (adr_u32 - sizeof(Fee_Prv_MediumBuffer_un.u8)) + length_u32,
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   172                          FEE_PRV_MEDIUM_FLASHBEG
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   173                      );
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   174                  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   175  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   176                  /* Set buffer dirty */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   177                  Fee_Prv_MediumSetBfrDirty();
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   178  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   179                  /* Start buffer load */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   180                  /* MR12 DIR 1.1 VIOLATION: uint8 * can always be converted safely to void * */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   181                  Fee_Prv_MediumRead(Fee_Prv_MediumLoad_st.reloadAdr_u32, &Fee_Prv_MediumBuffer_un.u8[0u], sizeof(Fee_Prv_MediumBuffer_un.u8));
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   182  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   183                  Fee_Prv_MediumLoad_st.state_en = FEE_PRV_LOAD_BUSY_E;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   184              }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   185              else
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   186              {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   187                  result_en = MEMIF_JOB_FAILED;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   188              }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   189          }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   190  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   191          if(MEMIF_JOB_PENDING == result_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   192          {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   193              result_en = Fee_Prv_MediumReadDo();
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   194          }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   195  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   196          if(MEMIF_JOB_PENDING != result_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   197          {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   198              Fee_Prv_MediumLoad_st.state_en = FEE_PRV_LOAD_IDLE_E;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   199  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   200              if(MEMIF_JOB_OK == result_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   201              {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   202                  Fee_Prv_Medium_st.limitLo_u32 = Fee_Prv_MediumLoad_st.reloadAdr_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   203                  Fee_Prv_Medium_st.limitHi_u32 = Fee_Prv_MediumLoad_st.reloadAdr_u32 + sizeof(Fee_Prv_MediumBuffer_un.u8);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   204              }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   205          }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   206      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   207  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   208      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   209  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   210  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   211  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   212   * \brief   Start a programming operation on the flash.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   213   *          Contains the sole call of Fls_Write in the whole Fee!
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   214   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   215   * \param   adr_u32     Address to write to
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   216   * \param   bfr_pcv     Buffer to write from
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   217   * \param   length_u32  Amount of bytes to write
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   218  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   219  static void Fee_Prv_MediumProgram(uint32 adr_u32, void const * bfr_pcv, uint32 length_u32)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   220  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   221      Fee_Prv_MediumSetBfrDirty();
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   222  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   223      /* MR12 RULE 11.5 VIOLATION: uint8 * alignment is not stricter than void * alignment */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   224      Fee_Prv_Medium_st.lastFlsResult_en = Fls_Write(adr_u32, bfr_pcv, length_u32);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   225  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   226  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   227  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   228   * \brief   Do the work for a program job.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   229  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   230  static MemIf_JobResultType Fee_Prv_MediumProgramDo(void)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   231  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   232      return(Fee_Prv_MediumFlsDo());
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   233  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   234  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   235  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   236   * \brief   Set synchronous (polling) or asynchronous flash access.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   237   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   238   * \param   newSync_b   TRUE = synchronous, FALSE = asynchronous
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   239   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   240   * \attention   If the flash access is set to synchronous the Fee_MainFunction can take very long!
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   241   *              Calling this function must consider the scheduling environment.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   242   *              Typically synchronous flash access is only acceptable in init.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   243  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   244  void Fee_Prv_MediumSetSync(boolean newSync_b)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   245  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   246      Fee_Prv_Medium_st.sync_b = newSync_b;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   247  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   248  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   249  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   250   * \brief   Start a read operation from the flash.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   251   *          Contains the sole call of Fls_Read in the whole Fee!
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   252   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   253   * \param   adr_u32     Address to read from
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   254   * \param   bfr_pv      Buffer to read to
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   255   * \param   length_u32  Amount of bytes to read
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   256  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   257  void Fee_Prv_MediumRead(uint32 adr_u32, void * bfr_pv, uint32 length_u32)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   258  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   259      /* MR12 RULE 11.5 VIOLATION: uint8 * alignment is not stricter than void * alignment */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   260      Fee_Prv_Medium_st.lastFlsResult_en = Fls_Read(adr_u32, bfr_pv, length_u32);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   261  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   262  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   263  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   264   * \brief   Start a write operation to the flash.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   265   *          Contains the sole call of Fls_Write in the whole Fee!
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   266   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   267   * \param   adr_u32     Address to write to
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   268   * \param   bfr_pcv     Buffer to write from
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   269   * \param   length_u32  Amount of bytes to write
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   270  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   271  void Fee_Prv_MediumWrite(uint32 adr_u32, void const * bfr_pcv, uint32 length_u32)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   272  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   273      Fee_Prv_MediumWrite_st.adr_u32      = adr_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   274      Fee_Prv_MediumWrite_st.bfr_pcv      = bfr_pcv;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   275      Fee_Prv_MediumWrite_st.length_u32   = length_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   276      Fee_Prv_MediumWrite_st.done_u32     = 0u;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   277  # if (defined(FLS_RB_BLANK_CHECK_API) && (STD_OFF != FLS_RB_BLANK_CHECK_API))
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   278      FEE_PRV_LIBTRANS(Fee_Prv_MediumWrite_st, FEE_PRV_MEDIUM_WRITE_BLANKCHECK_E);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   279  # else
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   280      FEE_PRV_LIBTRANS(Fee_Prv_MediumWrite_st, FEE_PRV_MEDIUM_WRITE_PROGRAM_E);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   281  # endif
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   282  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   283  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   284  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   285   * \brief   Erase a part of the flash.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   286   *          Contains the sole call of Fls_Erase in the whole Fee!
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   287   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   288   * \param   adr_u32     Address where the erase shall begin
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   289   * \param   length_u32  Amount of bytes to erase
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   290  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   291  void Fee_Prv_MediumErase(uint32 adr_u32, uint32 length_u32)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   292  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   293      Fee_Prv_MediumSetBfrDirty();
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   294      Fee_Prv_Medium_st.lastFlsResult_en = Fls_Erase(adr_u32, length_u32);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   295  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   296  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   297  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   298   * \brief   Compare the content of a piece of flash with the content of a piece of RAM
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   299   *          Contains the sole call of Fls_Compare in the whole Fee!
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   300   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   301   * \param   flsAdr_u32  Address in flash where the compare shall start
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   302   * \param   bfr_pcv     Address in the RAM where the compare shall start
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   303   * \param   length_u32  Amount of bytes to compare
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   304  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   305  void Fee_Prv_MediumCompare(uint32 flsAdr_u32, void const * bfr_pcv, uint32 length_u32)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   306  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   307      /* MR12 RULE 11.5 VIOLATION: uint8 * alignment is not stricter than void * alignment */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   308      Fee_Prv_Medium_st.lastFlsResult_en = Fls_Compare(flsAdr_u32, bfr_pcv, length_u32);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   309  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   310  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   311  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   312   * \brief   Check whether a piece of flash is erased or programmed.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   313   *          Contains the sole call of Fls_Rb_BlankCheck in the whole Fee!
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   314   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   315   * \param   adr_u32     Address in flash where the blank check shall start
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   316   * \param   length_u32  Amount of bytes which shall be checked
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   317  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   318  void Fee_Prv_MediumBlankCheck(uint32 adr_u32, uint32 length_u32)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   319  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   320  # if (defined(FLS_RB_BLANK_CHECK_API) && (STD_OFF != FLS_RB_BLANK_CHECK_API))
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   321  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   322      /*
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   323       * Currently a buffer for the blank check is not provided to the flash (NULL_PTR argument).
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   324       * This is done since the Fee does currently not support any flashes which need a buffer for a blank check.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   325       * For example RENESAS flash is not yet supported since it does not support overprogramming of flash cells.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   326       */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   327      Fee_Prv_Medium_st.lastFlsResult_en = Fls_Rb_BlankCheck(adr_u32, NULL_PTR, length_u32);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   328  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   329  # else
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   330  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   331      /* Unused parameters */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   332      (void)adr_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   333      (void)length_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   334  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   335      /*
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   336       * If the Fls doesn't provide a blank check, we don't trigger it in function Fee_Prv_MediumWrite (i.e. state
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   337       * FEE_PRV_MEDIUM_WRITE_BLANKCHECK_E is skipped). Instead, the programming is executed directly (i.e. state
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   338       * FEE_PRV_MEDIUM_WRITE_PROGRAM_E is chosen). Therefore, Fee_Prv_MediumBlankCheck won't be called. If called,
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   339       * something is completely wrong, and E_NOT_OK is returned to indicate the problem in the control flow.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   340       */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   341      Fee_Prv_Medium_st.lastFlsResult_en = E_NOT_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   342  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   343  # endif
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   344  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   345  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   346  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   347   * \brief   Destroy already programmed data.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   348   *          This is typically realized by overprogramming with the inverse erase pattern.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   349   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   350   * \param   adr_u32     Address of the data which shall be shredded
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   351   * \param   length_u32  Amount of bytes to shredder
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   352  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   353  void Fee_Prv_MediumShredder(uint32 adr_u32, uint32 length_u32)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   354  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   355      if(length_u32 <= sizeof(Fee_Prv_MediumBuffer_un.u8))
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   356      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   357          Fee_Prv_MediumSetBfrDirty();
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   358          /* MR12 DIR 1.1 VIOLATION: uint8 * can always be converted safely to void * */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   359          Fee_Prv_LibMemSet(&Fee_Prv_MediumBuffer_un.u8[0], (uint8)(~FEE_PRV_CFG_ERASE_PATTERN_8BIT), length_u32);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   360  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   361          /* MR12 DIR 1.1 VIOLATION: uint8 * can always be converted safely to void * */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   362          Fee_Prv_MediumProgram(
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   363              adr_u32,
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   364              &Fee_Prv_MediumBuffer_un.u8[0u],
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   365              length_u32
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   366          );
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   367      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   368      else
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   369      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   370          Fee_Prv_Medium_st.lastFlsResult_en = E_NOT_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   371      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   372  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   373  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   374  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   375   * \brief   Calculate the CRC directly from the flash.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   376   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   377   * \param   adr_u32     Address where the calculation shall start
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   378   * \param   length_u32  Amount of bytes to consider
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   379   * \param   crc_pu32    Point to an uint32 where the result is placed
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   380   * \param   firstCall_b Is this the first call for a chain of CRC calculations or not
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   381  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   382  void Fee_Prv_MediumCalcCrc(uint32 adr_u32, uint32 length_u32, uint32 * crc_pu32, boolean firstCall_b)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   383  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   384      Fee_Prv_MediumCalcCrc_st.nrBytesDone_u32    = 0u;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   385      Fee_Prv_MediumCalcCrc_st.length_u32         = length_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   386      Fee_Prv_MediumCalcCrc_st.crc_pu32           = crc_pu32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   387      Fee_Prv_MediumCalcCrc_st.firstCall_b        = firstCall_b;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   388  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   389      Fee_Prv_MediumSetIterator(adr_u32);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   390  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   391  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   392  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   393   * \brief   Start a copy operation from one flash location to another (using internal buffer).
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   394   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   395   * \param   adrSrc_u32  Source address in flash
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   396   * \param   adrDest_u32 Target address in flash
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   397   * \param   length_u32  Bytes to copy in total
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   398  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   399  void Fee_Prv_MediumCopy(uint32 adrSrc_u32, uint32 adrDest_u32, uint32 length_u32)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   400  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   401      Fee_Prv_MediumCopy_st.adrSrc_u32     = adrSrc_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   402      Fee_Prv_MediumCopy_st.adrDest_u32    = adrDest_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   403      Fee_Prv_MediumCopy_st.length_u32     = length_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   404      Fee_Prv_MediumCopy_st.done_u32       = 0u;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   405  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   406      FEE_PRV_LIBTRANS(Fee_Prv_MediumCopy_st, FEE_PRV_MEDIUM_COPY_READ_E);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   407  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   408  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   409  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   410   * \brief   Do the work for a read job.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   411  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   412  MemIf_JobResultType Fee_Prv_MediumReadDo(void)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   413  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   414      return(Fee_Prv_MediumFlsDo());
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   415  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   416  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   417  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   418   * \brief   Before programming assure that the space which shall be programmed is blank
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   419   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   420   * \pre     (BLANKCHECK == state)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   421   * \post    (MEMIF_JOB_OK      == result) && (PROGRAM       == state) && (TRUE == entry )
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   422   *          (MEMIF_JOB_PENDING == result) && (BLANKCHECK    == state) && (FALSE == entry)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   423   *          (MEMIF_JOB_FAILED  == result)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   424  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   425  static MemIf_JobResultType Fee_Prv_MediumWrite_BlankCheck(Fee_Prv_MediumWrite_tst * fsm_pst)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   426  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   427      MemIf_JobResultType result_en;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   428  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   429      if(FEE_PRV_LIBENTRY)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   430      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   431          Fee_Prv_MediumBlankCheck(fsm_pst->adr_u32, fsm_pst->length_u32);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   432      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   433  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   434      result_en = Fee_Prv_MediumBlankCheckDo();
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   435  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   436      if(MEMIF_JOB_OK == result_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   437      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   438          FEE_PRV_LIBSC(FEE_PRV_MEDIUM_WRITE_PROGRAM_E);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   439      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   440  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   441      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   442  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   443  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   444  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   445   * \brief   After it was checked that the space is blank,
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   446   *          copy the user data to an internal buffer and start programming using this buffer.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   447   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   448   * \pre     (WRITE == state)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   449   * \post    (bytes2Program_u32 = min(size(Internal Buffer), length - done))
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   450   * \post    (Internal Buffer == External Buffer)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   451   * \post    (Dirty(Internal Buffer))
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   452   * \post    (MEMIF_JOB_OK      == result) && (COMPARE == state) && (TRUE == entry )
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   453   *          (MEMIF_JOB_PENDING == result) && (PROGRAM == state) && (FALSE == entry)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   454   *          (MEMIF_JOB_FAILED  == result)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   455  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   456  static MemIf_JobResultType Fee_Prv_MediumWrite_Program(Fee_Prv_MediumWrite_tst * fsm_pst)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   457  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   458      MemIf_JobResultType result_en;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   459      uint8 const *       startAdr_pcu8;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   460  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   461      if(FEE_PRV_LIBENTRY)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   462      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   463          /*
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   464           * Need to convert the void const * to a uint8 const * pointer to add the offset of the already done bytes.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   465           * Pointer arithmetic with void pointers is not senseful
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   466           */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   467  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   468          /* MR12 RULE 11.5 VIOLATION: uint8 * alignment is not stricter than void * alignment */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   469          startAdr_pcu8  = fsm_pst->bfr_pcv;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   470          startAdr_pcu8 += fsm_pst->done_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   471  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   472          fsm_pst->bytes2Program_u32 = Fee_Prv_LibMin(sizeof(Fee_Prv_MediumBuffer_un.u8), fsm_pst->length_u32 - fsm_pst->done_u32);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   473  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   474          /* If necessary, copy user data to internal buffer */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   475          if(startAdr_pcu8 != &Fee_Prv_MediumBuffer_un.u8[0u])
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   476          {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   477              /* MR12 DIR 1.1 VIOLATION: uint8 * can always be converted safely to void * */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   478              Fee_Prv_LibMemCopy(startAdr_pcu8, &Fee_Prv_MediumBuffer_un.u8[0u], fsm_pst->bytes2Program_u32);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   479          }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   480          else
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   481          {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   482              /* Fee_Prv_MediumWrite was called from Fee_Prv_MediumCopy_Write, where the data to program is already
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   483               * stored inside Fee_Prv_MediumBuffer_un. I.e. we can/should skip the call of Fee_Prv_LibMemCopy. */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   484          }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   485  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   486          Fee_Prv_MediumSetBfrDirty();
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   487  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   488          /* MR12 DIR 1.1 VIOLATION: uint8 * can always be converted safely to void * */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   489          Fee_Prv_MediumProgram(fsm_pst->adr_u32 + fsm_pst->done_u32, &Fee_Prv_MediumBuffer_un.u8[0u], fsm_pst->bytes2Program_u32);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   490      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   491  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   492      result_en = Fee_Prv_MediumProgramDo();
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   493  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   494      if(MEMIF_JOB_OK == result_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   495      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   496          FEE_PRV_LIBSC(FEE_PRV_MEDIUM_WRITE_COMPARE_E);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   497      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   498  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   499      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   500  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   501  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   502  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   503   * \brief   Compare what should have been programmed with what was actually programmed
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   504   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   505   * \pre     (COMPARE == state)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   506   * \post    (MEMIF_JOB_OK      == result) && (PROGRAM   == state) && (TRUE  == entry) && (done = doneOld + bytes2Program) && (done <  length)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   507   *          (MEMIF_JOB_OK      == result) && (FINAL     == state) && (TRUE  == entry) && (done = doneOld + bytes2Program) && (done >= length)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   508   *          (MEMIF_JOB_PENDING == result) && (COMPARE   == state) && (FALSE == entry)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   509   *          (MEMIF_JOB_FAILED  == result)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   510  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   511  static MemIf_JobResultType Fee_Prv_MediumWrite_Compare(Fee_Prv_MediumWrite_tst * fsm_pst)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   512  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   513      MemIf_JobResultType result_en;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   514  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   515      if(FEE_PRV_LIBENTRY)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   516      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   517          /* MR12 DIR 1.1 VIOLATION: uint8 * can always be converted safely to void * */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   518          Fee_Prv_MediumCompare(fsm_pst->adr_u32 + fsm_pst->done_u32, &Fee_Prv_MediumBuffer_un.u8[0u], fsm_pst->bytes2Program_u32);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   519      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   520  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   521      result_en = Fee_Prv_MediumCompareDo();
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   522  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   523      if(MEMIF_JOB_OK == result_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   524      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   525          fsm_pst->done_u32 += fsm_pst->bytes2Program_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   526          if(fsm_pst->done_u32 < fsm_pst->length_u32)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   527          {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   528              FEE_PRV_LIBSC(FEE_PRV_MEDIUM_WRITE_PROGRAM_E);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   529          }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   530          else
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   531          {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   532              FEE_PRV_LIBSC(FEE_PRV_MEDIUM_WRITE_FINAL_E);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   533          }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   534      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   535      else if(MEMIF_BLOCK_INCONSISTENT == result_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   536      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   537          result_en = MEMIF_JOB_FAILED;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   538      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   539      else
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   540      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   541          /* intentionally empty */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   542      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   543  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   544      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   545  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   546  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   547  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   548   * \brief   Do the work for a write job.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   549  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   550  MemIf_JobResultType Fee_Prv_MediumWriteDo(void)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   551  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   552      Fee_Prv_MediumWrite_tst *   fsm_pst;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   553      MemIf_JobResultType         result_en;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   554  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   555      fsm_pst = &Fee_Prv_MediumWrite_st;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   556  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   557      do
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   558      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   559          switch(fsm_pst->state_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   560          {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   561              case FEE_PRV_MEDIUM_WRITE_BLANKCHECK_E: result_en = Fee_Prv_MediumWrite_BlankCheck(fsm_pst);    break;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   562              case FEE_PRV_MEDIUM_WRITE_PROGRAM_E:    result_en = Fee_Prv_MediumWrite_Program(fsm_pst);       break;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   563              case FEE_PRV_MEDIUM_WRITE_COMPARE_E:    result_en = Fee_Prv_MediumWrite_Compare(fsm_pst);       break;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   564              default:                                result_en = MEMIF_JOB_FAILED;                           break;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   565          }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   566      } while((MEMIF_JOB_OK == result_en) && (FEE_PRV_MEDIUM_WRITE_FINAL_E != fsm_pst->state_en));
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   567  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   568      if(MEMIF_JOB_PENDING != result_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   569      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   570          FEE_PRV_LIBSC(FEE_PRV_MEDIUM_WRITE_IDLE_E);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   571      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   572  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   573      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   574  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   575  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   576  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   577  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   578   * \brief   Do the work for an erase job.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   579  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   580  MemIf_JobResultType Fee_Prv_MediumEraseDo(void)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   581  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   582      return(Fee_Prv_MediumFlsDo());
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   583  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   584  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   585  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   586   * \brief   Do the work for a compare job.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   587  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   588  MemIf_JobResultType Fee_Prv_MediumCompareDo(void)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   589  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   590      return(Fee_Prv_MediumFlsDo());
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   591  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   592  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   593  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   594   * \brief   Do the work for a blank check job.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   595  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   596  MemIf_JobResultType Fee_Prv_MediumBlankCheckDo(void)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   597  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   598      return(Fee_Prv_MediumFlsDo());
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   599  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   600  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   601  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   602   * \brief   Do the work for a shredder job.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   603  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   604  MemIf_JobResultType Fee_Prv_MediumShredderDo(void)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   605  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   606      MemIf_JobResultType result_en;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   607  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   608      result_en = Fee_Prv_MediumProgramDo();
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   609  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   610      if(MEMIF_JOB_FAILED == result_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   611      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   612          /*
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   613           * IFX flash driver returns MEMIF_JOB_OK on overprogramming already programmed pages.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   614           * JDP/ST flash driver returns MEMIF_JOB_FAILED on overprogramming.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   615           * In order to equalize the behaviour a FAILED job is interpreted as OK job for overprogramming.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   616           */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   617          result_en = MEMIF_JOB_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   618      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   619  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   620      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   621  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   622  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   623  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   624   * \brief   The worker function for the CRC calculation.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   625   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   626   * \return                      Job status
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   627   * \retval  MEMIF_JOB_PENDING:  Job pending
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   628   * \retval  MEMIF_JOB_OK:       CRC calculation successful
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   629   * \retval  MEMIF_JOB_FAILED:   CRC calculation not successful (currently not possible)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   630  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   631  MemIf_JobResultType Fee_Prv_MediumCalcCrcDo(void)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   632  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   633      void               const *  ptr_pcv;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   634      MemIf_JobResultType         result_en   = MEMIF_JOB_PENDING;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   635      uint32 nrBytesToConsider_u32            = Fee_Prv_LibMin(
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   636          sizeof(Fee_Prv_MediumBuffer_un.u8),
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   637          Fee_Prv_MediumCalcCrc_st.length_u32 - Fee_Prv_MediumCalcCrc_st.nrBytesDone_u32
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   638      );
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   639  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   640      if(0u < nrBytesToConsider_u32)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   641      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   642          if(MEMIF_JOB_OK == Fee_Prv_MediumNext(nrBytesToConsider_u32, &ptr_pcv))
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   643          {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   644              /* MR12 RULE 11.5 VIOLATION: uint8 * alignment is not stricter than void * alignment */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   645              *Fee_Prv_MediumCalcCrc_st.crc_pu32 = Crc_CalculateCRC32(
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   646                  ptr_pcv,
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   647                  nrBytesToConsider_u32,
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   648                  *Fee_Prv_MediumCalcCrc_st.crc_pu32,
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   649                  Fee_Prv_MediumCalcCrc_st.firstCall_b
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   650              );
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   651  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   652              Fee_Prv_MediumCalcCrc_st.nrBytesDone_u32 += nrBytesToConsider_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   653              Fee_Prv_MediumCalcCrc_st.firstCall_b      = FALSE;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   654          }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   655      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   656  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   657      /* Length should never be smaller, but to be safe consider it */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   658      if(Fee_Prv_MediumCalcCrc_st.length_u32 <= Fee_Prv_MediumCalcCrc_st.nrBytesDone_u32)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   659      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   660          result_en = MEMIF_JOB_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   661      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   662  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   663      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   664  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   665  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   666  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   667   * \brief   Read data from the flash to the internal buffer.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   668  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   669  static MemIf_JobResultType Fee_Prv_MediumCopy_Read(Fee_Prv_MediumCopy_tst * fsm_pst)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   670  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   671      MemIf_JobResultType result_en;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   672  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   673      if(FEE_PRV_LIBENTRY)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   674      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   675          fsm_pst->bytes2Copy_u32 = Fee_Prv_LibMin(fsm_pst->length_u32 - fsm_pst->done_u32, sizeof(Fee_Prv_MediumBuffer_un.u8));
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   676          /* MR12 DIR 1.1 VIOLATION: uint8 * can always be converted safely to void * */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   677          Fee_Prv_MediumRead(fsm_pst->adrSrc_u32 + fsm_pst->done_u32, &Fee_Prv_MediumBuffer_un.u8[0u], fsm_pst->bytes2Copy_u32);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   678          Fee_Prv_MediumSetBfrDirty();
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   679      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   680  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   681      result_en = Fee_Prv_MediumReadDo();
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   682  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   683      if(MEMIF_JOB_OK == result_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   684      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   685          FEE_PRV_LIBSC(FEE_PRV_MEDIUM_COPY_WRITE_E);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   686      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   687  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   688      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   689  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   690  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   691  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   692   * \brief   Write data from the internal buffer to the flash.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   693  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   694  static MemIf_JobResultType Fee_Prv_MediumCopy_Write(Fee_Prv_MediumCopy_tst * fsm_pst)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   695  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   696      MemIf_JobResultType result_en;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   697  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   698      if(FEE_PRV_LIBENTRY)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   699      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   700          /* MR12 DIR 1.1 VIOLATION: uint8 * can always be converted safely to void * */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   701          Fee_Prv_MediumWrite(fsm_pst->adrDest_u32 + fsm_pst->done_u32, &Fee_Prv_MediumBuffer_un.u8[0u], fsm_pst->bytes2Copy_u32);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   702      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   703  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   704      result_en = Fee_Prv_MediumWriteDo();
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   705  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   706      if(MEMIF_JOB_OK == result_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   707      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   708          fsm_pst->done_u32 += fsm_pst->bytes2Copy_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   709          if(fsm_pst->done_u32 < fsm_pst->length_u32)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   710          {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   711              FEE_PRV_LIBSC(FEE_PRV_MEDIUM_COPY_READ_E);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   712          }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   713          else
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   714          {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   715              FEE_PRV_LIBSC(FEE_PRV_MEDIUM_COPY_FINAL_E);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   716          }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   717      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   718  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   719      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   720  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   721  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   722  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   723   * \brief   Do the work for a copy operation.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   724  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   725  MemIf_JobResultType Fee_Prv_MediumCopyDo(void)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   726  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   727      Fee_Prv_MediumCopy_tst *   fsm_pst;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   728      MemIf_JobResultType        result_en;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   729  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   730      fsm_pst = &Fee_Prv_MediumCopy_st;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   731  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   732      do
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   733      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   734          switch(fsm_pst->state_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   735          {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   736              case FEE_PRV_MEDIUM_COPY_READ_E:    result_en = Fee_Prv_MediumCopy_Read(fsm_pst);    break;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   737              case FEE_PRV_MEDIUM_COPY_WRITE_E:   result_en = Fee_Prv_MediumCopy_Write(fsm_pst);   break;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   738              default:                            result_en = MEMIF_JOB_FAILED;                    break;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   739          }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   740      } while((MEMIF_JOB_OK == result_en) && (FEE_PRV_MEDIUM_COPY_FINAL_E != fsm_pst->state_en));
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   741  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   742      if(MEMIF_JOB_PENDING != result_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   743      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   744          FEE_PRV_LIBSC(FEE_PRV_MEDIUM_COPY_IDLE_E);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   745      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   746  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   747      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   748  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   749  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   750  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   751   * \brief   Set the iterator to a location in the flash.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   752   *          From there on the iterator can be used to step forwards or backwards through the flash.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   753   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   754   * \param   adr_u32     Address in flash where the iterator shall point to
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   755  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   756  void Fee_Prv_MediumSetIterator(uint32 adr_u32)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   757  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   758      Fee_Prv_Medium_st.iterator_u32 = adr_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   759  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   760  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   761  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   762   * \brief   Get the value of the flash iterator.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   763   * \seealso Fee_Prv_MediumSetIterator
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   764  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   765  uint32 Fee_Prv_MediumGetIterator(void)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   766  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   767      return(Fee_Prv_Medium_st.iterator_u32);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   768  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   769  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   770  # if (defined(FLS_RB_ROBUST_PROG_STATUS_API) && (TRUE == FLS_RB_ROBUST_PROG_STATUS_API))
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   771  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   772  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   773   * \brief   Get the size of a single wordline.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   774   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   775   * \return  Size of a wordline in the flash in bytes
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   776  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   777  uint32 Fee_Prv_MediumGetWlSize(void)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   778  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   779      return(RBA_FLS_WORDLINE_SIZE);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   780  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   781  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   782   * \brief   Find out whether the flash lost data on the same word line during last programming action.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   783   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   784   * \return  Word line error occurred YES/NO
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   785  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   786  boolean Fee_Prv_MediumHasWlError(void)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   787  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   788      uint32              dummyErrorAdr_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   789      uint8           *   dummyBfr_pu8;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   790      uint32              dummyLength_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   791      Std_ReturnType      status_en;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   792      boolean             result_b;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   793  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   794      status_en = Fls_Rb_GetRobustProgStatus(&dummyErrorAdr_u32, &dummyBfr_pu8, &dummyLength_u32);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   795  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   796      result_b = FALSE;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   797      if(E_NOT_OK == status_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   798      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   799          result_b = TRUE;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   800      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   801      return(result_b);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   802  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   803  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   804  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   805   *  \brief  Get the address of a damaged word line.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   806   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   807   * \return  Address of the damaged word line that was damaged with the last programming action
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   808  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   809  uint32 Fee_Prv_MediumGetWlErrorAdr(void)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   810  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   811      uint32      errorAdr_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   812      uint8   *   dummyBfr_pu8;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   813      uint32      dummyLength_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   814  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   815      (void)Fls_Rb_GetRobustProgStatus(&errorAdr_u32, &dummyBfr_pu8, &dummyLength_u32);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   816  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   817      return(errorAdr_u32);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   818  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   819  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   820  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   821   *  \brief  Get the amount of data that was rescued before a word line was damaged.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   822   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   823   * \return  Amount of rescued data
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   824  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   825  uint32 Fee_Prv_MediumGetWlErrorLength(void)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   826  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   827      uint32      dummyErrorAdr_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   828      uint8   *   dummyBfr_pu8;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   829      uint32      length_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   830  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   831      (void)Fls_Rb_GetRobustProgStatus(&dummyErrorAdr_u32, &dummyBfr_pu8, &length_u32);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   832  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   833      return(length_u32);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   834  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   835  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   836  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   837   * \brief   Safe the data of the defect wordline from the flash buffer to the Fee buffer.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   838   *          This is required since the data of the wordline can be thrown away with every flash job.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   839  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   840  void Fee_Prv_MediumRescueWlData(void)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   841  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   842      uint32              dummyErrorAdr_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   843      uint8           *   flsBfr_pu8;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   844      uint32              length_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   845      Std_ReturnType      status_en;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   846  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   847      status_en = Fls_Rb_GetRobustProgStatus(&dummyErrorAdr_u32, &flsBfr_pu8, &length_u32);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   848  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   849      if((E_NOT_OK == status_en) && (NULL_PTR != flsBfr_pu8))
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   850      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   851          /* MR12 DIR 1.1 VIOLATION: uint8 * can always be converted safely to void * */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   852          Fee_Prv_LibMemCopy(flsBfr_pu8, &Fee_Prv_MediumRescueBfr_au8[0u], length_u32);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   853      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   854  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   855  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   856  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   857   * \brief   Get a pointer to the data that was previously rescued with Fee_Prv_MediumRescueWlData().
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   858   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   859   * \return  Pointer to previously rescued data
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   860  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   861  uint8 const * Fee_Prv_MediumGetWlData(void)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   862  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   863      return((uint8 const *)&Fee_Prv_MediumRescueBfr_au8[0u]);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   864  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   865  # endif
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   866  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   867  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   868  /*
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   869   * Those functions are activated if direct read from the Fls is not active.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   870   * Currently this is not fully supported in the whole Fee so that part must currently always stay OFF.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   871  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   872  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   873  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   874   * \brief   Set a pointer to the current iterator then increase the iterator for specified length.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   875   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   876   * \param   length_u32  Amount of bytes to step after pointer is set to current iterator
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   877   * \param   ptr_cppcv   Pointer to the pointer which shall be set to the address of the iterator
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   878   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   879   * \retval  MEMIF_JOB_PENDING   Job still pending
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   880   * \retval  MEMIF_JOB_OK        Job finished successfully
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   881   * \retval  MEMIF_JOB_FAILED    Job finished with errors
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   882  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   883  MemIf_JobResultType Fee_Prv_MediumNext(uint32 length_u32, void const * * ptr_cppcv)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   884  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   885      MemIf_JobResultType result_en = Fee_Prv_MediumLoad(Fee_Prv_Medium_st.iterator_u32, length_u32, FEE_PRV_POSTLOAD_E);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   886  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   887      if(MEMIF_JOB_OK == result_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   888      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   889          uint32 index_u32                = Fee_Prv_Medium_st.iterator_u32 - Fee_Prv_Medium_st.limitLo_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   890          /* MR12 DIR 1.1, 18.6 VIOLATION: uint8 * can always be converted safely to void *, returns the pointer to a global buffer at a specific offset */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   891          *ptr_cppcv                      = &Fee_Prv_MediumBuffer_un.u8[index_u32];
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   892          Fee_Prv_Medium_st.iterator_u32  += length_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   893      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   894  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   895      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   896  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   897  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   898  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   899   * \brief   Set a pointer to the current iterator then increase the iterator for specified length.
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   900   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   901   * \param   length_u32  Amount of bytes to step after pointer is set to current iterator
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   902   * \param   ptr_cppcv   Pointer to the pointer which shall be set to the address of the iterator
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   903   *
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   904   * \retval  MEMIF_JOB_PENDING   Job still pending
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   905   * \retval  MEMIF_JOB_OK        Job finished successfully
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   906   * \retval  MEMIF_JOB_FAILED    Job finished with errors
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   907  */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   908  MemIf_JobResultType Fee_Prv_MediumPre(uint32 length_u32, void const * * ptr_cppcv)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   909  {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   910      MemIf_JobResultType result_en = Fee_Prv_MediumLoad(Fee_Prv_Medium_st.iterator_u32, length_u32, FEE_PRV_PRELOAD_E);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   911  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   912      if(MEMIF_JOB_OK == result_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   913      {
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   914          uint32 index_u32                = Fee_Prv_Medium_st.iterator_u32 - Fee_Prv_Medium_st.limitLo_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   915          /* MR12 DIR 1.1, 18.6 VIOLATION: uint8 * can always be converted safely to void *, returns the pointer to a global buffer at a specific offset */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   916          *ptr_cppcv                      = &Fee_Prv_MediumBuffer_un.u8[index_u32];
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   917          Fee_Prv_Medium_st.iterator_u32  -= length_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   918      }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   919  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   920      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   921  }
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   922  
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   923  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   924  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   925  /* 1 != FEE_PRV_CFG_SELECTED_FS */
; BSW\src\BSW\Gen\Fee\src\Fee_Medium.c	   926  #endif

	; Module end
