	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 19053136 SN 09001910"
	.compiler_invocation	"ctc -f cc15724a -c99 --integer-enumeration -D__CPU__=tc27x -D__CPU_TC27X__ --core=tc1.6.x --eabi-compliant --fp-model=-float -D_TASKING_C_TRICORE_=1 -I.\\output\\inc -g2 -t4 --language=-comments,-gcc,+volatile,-strings --default-near-size=0 -O2ROPYGKLF-predict --default-a1-size=0 --default-a0-size=0 --source --switch=auto -o output\\objs\\BSW\\src\\BSW\\Gen\\Fee\\Fee_Order.src BSW\\src\\BSW\\Gen\\Fee\\src\\Fee_Order.c"
	.compiler_name		"ctc"
	;source	'BSW\\src\\BSW\\Gen\\Fee\\src\\Fee_Order.c'

	
$TC16X
	
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L3:
	.word	9182
	.half	3
	.word	.L4
	.byte	4
.L2:
	.byte	1
	.byte	'BSW\\src\\BSW\\Gen\\Fee\\src\\Fee_Order.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L5
	.byte	2,1,3
	.word	135
	.byte	4
	.byte	'__codeptr',0,1,1,1
	.word	137
	.byte	5
	.byte	'char',0,1,6,4
	.byte	'sint8',0,2,76,25
	.word	160
	.byte	5
	.byte	'unsigned char',0,1,8,4
	.byte	'uint8',0,2,81,25
	.word	182
	.byte	5
	.byte	'unsigned short int',0,2,7,4
	.byte	'uint16',0,2,91,25
	.word	213
	.byte	5
	.byte	'unsigned int',0,4,7,4
	.byte	'uint32',0,2,106,24
	.word	250
	.byte	5
	.byte	'unsigned long long int',0,8,7,4
	.byte	'uint64',0,2,111,30
	.word	281
	.byte	4
	.byte	'boolean',0,2,127,25
	.word	182
	.byte	4
	.byte	'StatusType',0,3,191,1,27
	.word	182
	.byte	4
	.byte	'Std_ReturnType',0,3,199,1,15
	.word	182
	.byte	6,3,206,1,9,8,7
	.byte	'vendorID',0
	.word	213
	.byte	2,2,35,0,7
	.byte	'moduleID',0
	.word	213
	.byte	2,2,35,2,7
	.byte	'sw_major_version',0
	.word	182
	.byte	1,2,35,4,7
	.byte	'sw_minor_version',0
	.word	182
	.byte	1,2,35,5,7
	.byte	'sw_patch_version',0
	.word	182
	.byte	1,2,35,6,0,4
	.byte	'Std_VersionInfoType',0,3,213,1,3
	.word	382
	.byte	6,4,93,9,8,7
	.byte	'Class',0
	.word	182
	.byte	1,2,35,0,7
	.byte	'TIN',0
	.word	182
	.byte	1,2,35,1,7
	.byte	'ReturnAddress',0
	.word	250
	.byte	4,2,35,4,0,4
	.byte	'OsTrapInfoType',0,4,97,3
	.word	532
	.byte	8,68
	.word	250
	.byte	9,16,0,6,4,154,1,9,68,7
	.byte	'store',0
	.word	612
	.byte	68,2,35,0,0,8,68
	.word	621
	.byte	9,0,0,4
	.byte	'Os_JumpBufType',0,4,156,1,3
	.word	643
	.byte	4
	.byte	'Os_StackTraceType',0,4,174,1,18
	.word	250
	.byte	6,4,175,1,9,8,7
	.byte	'sp',0
	.word	250
	.byte	4,2,35,0,7
	.byte	'ctx',0
	.word	250
	.byte	4,2,35,4,0,4
	.byte	'Os_StackValueType',0,4,175,1,63
	.word	703
	.byte	4
	.byte	'Os_StackSizeType',0,4,176,1,27
	.word	703
	.byte	10,1,1,3
	.word	788
	.byte	4
	.byte	'Os_VoidVoidFunctionType',0,4,179,1,16
	.word	791
	.byte	4
	.byte	'ApplicationType',0,4,193,1,23
	.word	182
	.byte	11
	.byte	'Os_ApplicationConfigurationType_s',0,4,198,1,16,2,7
	.byte	'app_id',0
	.word	182
	.byte	1,2,35,0,7
	.byte	'access',0
	.word	182
	.byte	1,2,35,1,0,4
	.byte	'Os_ApplicationConfigurationType',0,4,201,1,3
	.word	854
	.byte	4
	.byte	'Os_CoreStateType',0,4,203,1,16
	.word	250
	.byte	4
	.byte	'AreaIdType',0,4,204,1,16
	.word	213
	.byte	4
	.byte	'Os_PeripheralAddressType',0,4,212,1,22
	.word	250
	.byte	4
	.byte	'TickType',0,4,221,1,22
	.word	250
	.byte	4
	.byte	'Os_StopwatchTickType',0,4,225,1,22
	.word	250
	.byte	3
	.word	250
	.byte	4
	.byte	'Os_Lockable',0,4,234,1,18
	.word	1096
	.byte	4
	.byte	'CoreIdType',0,4,236,1,16
	.word	213
	.byte	4
	.byte	'SpinlockIdType',0,4,237,1,16
	.word	213
	.byte	12,4,239,1,9,4,13
	.byte	'TRYTOGETSPINLOCK_SUCCESS',0,0,13
	.byte	'TRYTOGETSPINLOCK_NOSUCCESS',0,1,0,4
	.byte	'TryToGetSpinlockType',0,4,239,1,74
	.word	1166
	.byte	12,4,174,2,9,4,13
	.byte	'APPLICATION_ACCESSIBLE',0,0,13
	.byte	'APPLICATION_RESTARTING',0,1,13
	.byte	'APPLICATION_TERMINATED',0,2,0,4
	.byte	'ApplicationStateType',0,4,174,2,92
	.word	1259
	.byte	14
	.byte	'void',0,3
	.word	1371
	.byte	15,1,1,16
	.word	182
	.byte	16
	.word	1377
	.byte	0,3
	.word	1382
	.byte	4
	.byte	'Os_FunctionEntryType',0,4,183,2,16
	.word	1396
	.byte	11
	.byte	'Os_MeterInfoType_s',0,4,193,2,16,48,7
	.byte	'elapsed',0
	.word	250
	.byte	4,2,35,0,7
	.byte	'previous',0
	.word	250
	.byte	4,2,35,4,7
	.byte	'max',0
	.word	250
	.byte	4,2,35,8,7
	.byte	'cumulative',0
	.word	250
	.byte	4,2,35,12,7
	.byte	'stackbase',0
	.word	703
	.byte	8,2,35,16,7
	.byte	'stackusage',0
	.word	703
	.byte	8,2,35,24,7
	.byte	'stackmax',0
	.word	703
	.byte	8,2,35,32,7
	.byte	'stackbudget',0
	.word	703
	.byte	8,2,35,40,0,4
	.byte	'Os_MeterInfoType',0,4,202,2,3
	.word	1431
	.byte	3
	.word	1431
	.byte	4
	.byte	'Os_MeterInfoRefType',0,4,203,2,50
	.word	1629
	.byte	4
	.byte	'EventMaskType',0,4,206,2,15
	.word	182
	.byte	4
	.byte	'Os_imaskType',0,4,211,2,16
	.word	250
	.byte	11
	.byte	'Os_ISRDynType_s',0,4,213,2,16,48,7
	.byte	'meter',0
	.word	1431
	.byte	48,2,35,0,0,4
	.byte	'Os_ISRDynType',0,4,215,2,3
	.word	1708
	.byte	3
	.word	1708
	.byte	17
	.word	1769
	.byte	11
	.byte	'Os_ISRType_s',0,4,216,2,16,24,7
	.byte	'entry_function',0
	.word	796
	.byte	4,2,35,0,7
	.byte	'dynamic',0
	.word	1774
	.byte	4,2,35,4,7
	.byte	'imask',0
	.word	250
	.byte	4,2,35,8,7
	.byte	'stackbudget',0
	.word	703
	.byte	8,2,35,12,7
	.byte	'access',0
	.word	182
	.byte	1,2,35,20,7
	.byte	'application',0
	.word	182
	.byte	1,2,35,21,0,4
	.byte	'Os_ISRType',0,4,223,2,3
	.word	1779
	.byte	3
	.word	788
	.byte	17
	.word	1779
	.byte	3
	.word	1938
	.byte	4
	.byte	'ISRType',0,4,224,2,46
	.word	1943
	.byte	4
	.byte	'Os_bitmask',0,4,239,2,22
	.word	250
	.byte	4
	.byte	'Os_pset0Type',0,4,240,2,20
	.word	250
	.byte	4
	.byte	'Os_pset1Type',0,4,241,2,20
	.word	250
	.byte	4
	.byte	'Os_pset2Type',0,4,242,2,20
	.word	250
	.byte	18,4,243,2,9,4,7
	.byte	'p0',0
	.word	250
	.byte	4,2,35,0,7
	.byte	'p1',0
	.word	250
	.byte	4,2,35,0,7
	.byte	'p2',0
	.word	250
	.byte	4,2,35,0,0,4
	.byte	'Os_psetType',0,4,247,2,3
	.word	2051
	.byte	18,4,249,2,9,4,7
	.byte	't0',0
	.word	250
	.byte	4,2,35,0,7
	.byte	't1',0
	.word	250
	.byte	4,2,35,0,7
	.byte	't2',0
	.word	250
	.byte	4,2,35,0,0,4
	.byte	'Os_tpmaskType',0,4,253,2,3
	.word	2115
	.byte	4
	.byte	'Os_ActivationCountType',0,4,254,2,23
	.word	182
	.byte	11
	.byte	'Os_TaskDynType_s',0,4,128,3,16,120,7
	.byte	'terminate_jump_buf',0
	.word	652
	.byte	68,2,35,0,7
	.byte	'meter',0
	.word	1431
	.byte	48,2,35,68,7
	.byte	'activation_count',0
	.word	182
	.byte	1,2,35,116,0,4
	.byte	'Os_TaskDynType',0,4,132,3,3
	.word	2213
	.byte	8,68
	.word	621
	.byte	9,0,0,3
	.word	2213
	.byte	17
	.word	2339
	.byte	11
	.byte	'Os_TaskType_s',0,4,134,3,16,40,7
	.byte	'dynamic',0
	.word	2344
	.byte	4,2,35,0,7
	.byte	'entry_function',0
	.word	796
	.byte	4,2,35,4,7
	.byte	'pset',0
	.word	2051
	.byte	4,2,35,8,7
	.byte	'base_tpmask',0
	.word	2115
	.byte	4,2,35,12,7
	.byte	'tpmask',0
	.word	2115
	.byte	4,2,35,16,7
	.byte	'core_id',0
	.word	213
	.byte	2,2,35,20,7
	.byte	'index',0
	.word	250
	.byte	4,2,35,24,7
	.byte	'stackbudget',0
	.word	703
	.byte	8,2,35,28,7
	.byte	'activation_count',0
	.word	182
	.byte	1,2,35,36,7
	.byte	'access',0
	.word	182
	.byte	1,2,35,37,7
	.byte	'application',0
	.word	182
	.byte	1,2,35,38,0,4
	.byte	'Os_TaskType',0,4,146,3,3
	.word	2349
	.byte	17
	.word	2349
	.byte	3
	.word	2599
	.byte	4
	.byte	'TaskType',0,4,147,3,47
	.word	2604
	.byte	19
	.byte	'Os_TaskStateType',0,4,155,3,6,4,13
	.byte	'SUSPENDED',0,0,13
	.byte	'READY',0,1,13
	.byte	'WAITING',0,2,13
	.byte	'RUNNING',0,3,0,4
	.byte	'TaskStateType',0,4,156,3,31
	.word	2627
	.byte	18,4,167,3,3,4,7
	.byte	'tpmask',0
	.word	2115
	.byte	4,2,35,0,0,11
	.byte	'Os_ResourceDynType_s',0,4,166,3,16,4,7
	.byte	'saved_priority',0
	.word	2714
	.byte	4,2,35,0,0,4
	.byte	'Os_ResourceDynType',0,4,170,3,3
	.word	2737
	.byte	3
	.word	2737
	.byte	17
	.word	2817
	.byte	11
	.byte	'Os_ResourceType_s',0,4,171,3,16,12,7
	.byte	'dynamic',0
	.word	2822
	.byte	4,2,35,0,7
	.byte	'tpmask',0
	.word	2115
	.byte	4,2,35,4,7
	.byte	'access',0
	.word	182
	.byte	1,2,35,8,0,4
	.byte	'Os_ResourceType',0,4,175,3,3
	.word	2827
	.byte	6,4,181,3,9,12,7
	.byte	'maxallowedvalue',0
	.word	250
	.byte	4,2,35,0,7
	.byte	'ticksperbase',0
	.word	250
	.byte	4,2,35,4,7
	.byte	'mincycle',0
	.word	250
	.byte	4,2,35,8,0,4
	.byte	'AlarmBaseType',0,4,185,3,3
	.word	2926
	.byte	6,4,206,3,9,8,7
	.byte	'Running',0
	.word	182
	.byte	1,2,35,0,7
	.byte	'Pending',0
	.word	182
	.byte	1,2,35,1,7
	.byte	'Delay',0
	.word	250
	.byte	4,2,35,4,0,4
	.byte	'Os_CounterStatusType',0,4,210,3,3
	.word	3021
	.byte	20
	.word	182
	.byte	1,1,3
	.word	3107
	.byte	4
	.byte	'Os_CounterIncrAdvType',0,4,217,3,22
	.word	3114
	.byte	11
	.byte	's_swd',0,4,222,3,12,4,7
	.byte	'count',0
	.word	250
	.byte	4,2,35,0,0,18,4,221,3,3,4,7
	.byte	'sw',0
	.word	3150
	.byte	4,2,35,0,0,11
	.byte	'Os_CounterDynType_s',0,4,220,3,16,4,7
	.byte	'type_dependent',0
	.word	3178
	.byte	4,2,35,0,0,4
	.byte	'Os_CounterDynType',0,4,226,3,3
	.word	3197
	.byte	3
	.word	3197
	.byte	17
	.word	3275
	.byte	11
	.byte	'Os_CounterType_s',0,4,227,3,16,28,7
	.byte	'dynamic',0
	.word	3280
	.byte	4,2,35,0,7
	.byte	'advincr',0
	.word	3119
	.byte	4,2,35,4,7
	.byte	'base',0
	.word	2926
	.byte	12,2,35,8,7
	.byte	'core',0
	.word	1377
	.byte	4,2,35,20,7
	.byte	'access',0
	.word	182
	.byte	1,2,35,24,7
	.byte	'application',0
	.word	182
	.byte	1,2,35,25,0,4
	.byte	'Os_CounterType',0,4,234,3,3
	.word	3285
	.byte	3
	.word	3107
	.byte	17
	.word	3285
	.byte	3
	.word	3437
	.byte	4
	.byte	'CounterType',0,4,235,3,52
	.word	3442
	.byte	19
	.byte	'Os_ScheduleTableStatusType',0,4,240,3,6,4,13
	.byte	'SCHEDULETABLE_STOPPED',0,0,13
	.byte	'SCHEDULETABLE_NEXT',0,1,13
	.byte	'SCHEDULETABLE_WAITING',0,2,13
	.byte	'SCHEDULETABLE_RUNNING',0,3,13
	.byte	'SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS',0,4,0,4
	.byte	'ScheduleTableStatusType',0,4,241,3,41
	.word	3468
	.byte	17
	.word	.L6-.L3
	.byte	3
	.word	3668
	.byte	4
	.byte	'ScheduleTableType',0,4,128,4,58
	.word	3673
	.byte	11
	.byte	'Os_ScheduleTableDynType_s',0,4,130,4,16,16,7
	.byte	'match',0
	.word	250
	.byte	4,2,35,0,7
	.byte	'next',0
	.word	3678
	.byte	4,2,35,4,7
	.byte	'state',0
	.word	3468
	.byte	4,2,35,8,7
	.byte	'config',0
	.word	213
	.byte	2,2,35,12,0,3
	.word	3705
	.byte	17
	.word	3798
.L6:
	.byte	11
	.byte	'Os_ScheduleTableType_s',0,4,247,3,16,16,7
	.byte	'dynamic',0
	.word	3803
	.byte	4,2,35,0,7
	.byte	'counter',0
	.word	3447
	.byte	4,2,35,4,7
	.byte	'repeat',0
	.word	182
	.byte	1,2,35,8,7
	.byte	'config',0
	.word	213
	.byte	2,2,35,10,7
	.byte	'initial',0
	.word	182
	.byte	1,2,35,12,7
	.byte	'access',0
	.word	182
	.byte	1,2,35,13,7
	.byte	'application',0
	.word	182
	.byte	1,2,35,14,0,4
	.byte	'Os_ScheduleTableType',0,4,255,3,3
	.word	3808
	.byte	17
	.word	3808
	.byte	3
	.word	3988
	.byte	17
	.word	3285
	.byte	3
	.word	3998
	.byte	21
	.word	1101
	.byte	21
	.word	2051
	.byte	21
	.word	1948
	.byte	21
	.word	2609
	.byte	21
	.word	2115
	.byte	21
	.word	182
	.byte	21
	.word	2609
	.byte	11
	.byte	'Os_ControlledCoreType_s',0,4,251,6,16,112,7
	.byte	'TrapInfo',0
	.word	532
	.byte	8,2,35,0,7
	.byte	'lock_taskaccess',0
	.word	4008
	.byte	4,2,35,8,7
	.byte	'ReadyTasks',0
	.word	4013
	.byte	4,2,35,12,7
	.byte	'RunningISR',0
	.word	4018
	.byte	4,2,35,16,7
	.byte	'RunningTask',0
	.word	4023
	.byte	4,2,35,20,7
	.byte	'RunningTPMask',0
	.word	4028
	.byte	4,2,35,24,7
	.byte	'CurrentMeteredObject',0
	.word	1634
	.byte	4,2,35,28,7
	.byte	'IdleMeter',0
	.word	1431
	.byte	48,2,35,32,7
	.byte	'AppAccess',0
	.word	182
	.byte	1,2,35,80,7
	.byte	'AppOverride',0
	.word	4033
	.byte	1,2,35,81,7
	.byte	'GetStackValueAdjust',0
	.word	703
	.byte	8,2,35,84,7
	.byte	'InErrorHook',0
	.word	182
	.byte	1,2,35,92,7
	.byte	'ChainTaskRef',0
	.word	4038
	.byte	4,2,35,96,7
	.byte	'GetStackUsageAdjust',0
	.word	703
	.byte	8,2,35,100,7
	.byte	'InProtectionHook',0
	.word	182
	.byte	1,2,35,108,7
	.byte	'CoreIsActive',0
	.word	182
	.byte	1,2,35,109,7
	.byte	'InShutdownHook',0
	.word	182
	.byte	1,2,35,110,0,4
	.byte	'Os_ControlledCoreType',0,4,141,7,3
	.word	4043
	.byte	3
	.word	250
	.byte	17
	.word	1779
	.byte	3
	.word	4499
	.byte	17
	.word	2349
	.byte	3
	.word	4509
	.byte	3
	.word	1431
	.byte	11
	.byte	'Os_AnyCoreType_s',0,4,151,7,16,96,7
	.byte	'DisableAllImask',0
	.word	250
	.byte	4,2,35,0,7
	.byte	'SuspendAllImask',0
	.word	250
	.byte	4,2,35,4,7
	.byte	'SuspendOSImask',0
	.word	250
	.byte	4,2,35,8,7
	.byte	'DisableAllCount',0
	.word	250
	.byte	4,2,35,12,7
	.byte	'SuspendAllCount',0
	.word	250
	.byte	4,2,35,16,7
	.byte	'SuspendOSCount',0
	.word	250
	.byte	4,2,35,20,7
	.byte	'RestartJumpBuf',0
	.word	652
	.byte	68,2,35,24,7
	.byte	'Restartable',0
	.word	182
	.byte	1,2,35,92,0,4
	.byte	'Os_AnyCoreType',0,4,160,7,3
	.word	4524
	.byte	4
	.byte	'unsigned_int',0,5,116,22
	.word	250
	.byte	12,6,31,9,4,13
	.byte	'MEMIF_JOB_OK',0,0,13
	.byte	'MEMIF_JOB_FAILED',0,1,13
	.byte	'MEMIF_JOB_PENDING',0,2,13
	.byte	'MEMIF_JOB_CANCELED',0,3,13
	.byte	'MEMIF_BLOCK_INCONSISTENT',0,4,13
	.byte	'MEMIF_BLOCK_INVALID',0,5,0,4
	.byte	'MemIf_JobResultType',0,6,39,2
	.word	4786
	.byte	12,6,41,9,4,13
	.byte	'MEMIF_MODE_SLOW',0,0,13
	.byte	'MEMIF_MODE_FAST',0,1,0,4
	.byte	'MemIf_ModeType',0,6,45,2
	.word	4944
	.byte	4
	.byte	'PduIdType',0,7,22,19
	.word	213
	.byte	4
	.byte	'PduLengthType',0,7,26,19
	.word	213
	.byte	12,8,113,9,4,13
	.byte	'TP_DATACONF',0,0,13
	.byte	'TP_DATARETRY',0,1,13
	.byte	'TP_CONFPENDING',0,2,0,4
	.byte	'TpDataStateType',0,8,118,3
	.word	5049
	.byte	4
	.byte	'Can_IdType',0,9,32,16
	.word	250
	.byte	4
	.byte	'Can_HwHandleType',0,9,43,16
	.word	213
	.byte	4
	.byte	'Can_TxObjPriorityClassType',0,10,219,3,16
	.word	250
	.byte	11
	.byte	'Can_TxHwObjectConfigType',0,10,231,3,16,8,7
	.byte	'MsgObjId',0
	.word	182
	.byte	1,2,35,0,7
	.byte	'HwControllerId',0
	.word	182
	.byte	1,2,35,1,7
	.byte	'TxObjPriorityClass',0
	.word	250
	.byte	4,2,35,4,0,4
	.byte	'Can_TxHwObjectConfigType',0,10,252,3,3
	.word	5205
	.byte	11
	.byte	'Can_RxHwObjectConfigType',0,10,129,4,16,12,7
	.byte	'MaskRef',0
	.word	250
	.byte	4,2,35,0,7
	.byte	'MsgId',0
	.word	250
	.byte	4,2,35,4,7
	.byte	'MsgObjId',0
	.word	182
	.byte	1,2,35,8,7
	.byte	'HwControllerId',0
	.word	182
	.byte	1,2,35,9,0,4
	.byte	'Can_RxHwObjectConfigType',0,10,147,4,3
	.word	5341
	.byte	8,4
	.word	182
	.byte	9,3,0,11
	.byte	'Can_ControllerMOMapConfigType',0,10,181,4,16,4,7
	.byte	'ControllerMOMap',0
	.word	5481
	.byte	4,2,35,0,0,4
	.byte	'Can_ControllerMOMapConfigType',0,10,184,4,3
	.word	5490
	.byte	11
	.byte	'Can_NPCRValueType',0,10,188,4,16,2,7
	.byte	'Can_NPCRValue',0
	.word	213
	.byte	2,2,35,0,0,4
	.byte	'Can_NPCRValueType',0,10,191,4,3
	.word	5591
	.byte	11
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,10,194,4,16,8,7
	.byte	'CanControllerBaudrate',0
	.word	250
	.byte	4,2,35,0,7
	.byte	'CanControllerBaudrateCfg',0
	.word	213
	.byte	2,2,35,4,0,4
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,10,198,4,3
	.word	5666
	.byte	17
	.word	5666
	.byte	3
	.word	5831
	.byte	11
	.byte	'Can_BaudrateConfigPtrType',0,10,201,4,16,4,7
	.byte	'Can_kBaudrateConfigPtr',0
	.word	5836
	.byte	4,2,35,0,0,4
	.byte	'Can_BaudrateConfigPtrType',0,10,204,4,3
	.word	5841
	.byte	11
	.byte	'Can_EventHandlingType',0,10,226,4,16,4,7
	.byte	'CanEventType',0
	.word	5481
	.byte	4,2,35,0,0,4
	.byte	'Can_EventHandlingType',0,10,229,4,3
	.word	5941
	.byte	4
	.byte	'Rte_TransformerErrorCode',0,11,130,1,15
	.word	182
	.byte	4
	.byte	'Rte_TransformerClass',0,11,131,1,15
	.word	182
	.byte	6,11,168,1,9,12,7
	.byte	'in',0
	.word	1377
	.byte	4,2,35,0,7
	.byte	'out',0
	.word	1377
	.byte	4,2,35,4,7
	.byte	'used',0
	.word	213
	.byte	2,2,35,8,7
	.byte	'lost_data',0
	.word	182
	.byte	1,2,35,10,0,4
	.byte	'Rte_QDynType',0,11,173,1,3
	.word	6087
	.byte	12,11,175,1,9,4,13
	.byte	'RTE_DRA',0,0,13
	.byte	'RTE_WOWP',0,1,13
	.byte	'RTE_TASK',0,2,13
	.byte	'RTE_ARE',0,3,13
	.byte	'RTE_EV',0,4,13
	.byte	'RTE_MSI',0,5,0,4
	.byte	'Rte_NotificationType',0,11,182,1,3
	.word	6174
	.byte	8,128,8
	.word	182
	.byte	9,255,7,0,4
	.byte	'Impl_NVM_DstPtrType_1024',0,12,50,15
	.word	6272
	.byte	4
	.byte	'CanIf_u32_impl',0,12,69,16
	.word	250
	.byte	4
	.byte	'CanIf_u16_impl',0,12,71,16
	.word	213
	.byte	4
	.byte	'CanIf_u8_impl',0,12,73,15
	.word	182
	.byte	4
	.byte	'CanIf_ControllerModeType_Enum_impl',0,12,88,15
	.word	182
	.byte	4
	.byte	'CanIf_PduModeType_Enum_impl',0,12,90,15
	.word	182
	.byte	6,12,92,9,2,7
	.byte	'DeviceMode',0
	.word	182
	.byte	1,2,35,0,7
	.byte	'ChannelMode',0
	.word	182
	.byte	1,2,35,1,0,4
	.byte	'CanIf_ControllerStateType_struct_impl',0,12,95,3
	.word	6463
	.byte	4
	.byte	'CanIf_NotifStatusType_Enum_impl',0,12,100,15
	.word	182
	.byte	4
	.byte	'CanSM_boolean_Impl',0,12,120,15
	.word	182
	.byte	4
	.byte	'CanSM_u8_Impl',0,12,123,15
	.word	182
	.byte	4
	.byte	'CanSM_BusOffRecoveryStateType_Enum_impl',0,12,128,1,15
	.word	182
	.byte	4
	.byte	'CanSM_NetworkModeStateType_Enum_impl',0,12,132,1,15
	.word	182
	.byte	4
	.byte	'CanSM_u16_Impl',0,12,136,1,16
	.word	213
	.byte	4
	.byte	'CanSM_TimerStateType_Enum_impl',0,12,138,1,15
	.word	182
	.byte	6,12,140,1,9,4,7
	.byte	'cntTick_u16',0
	.word	213
	.byte	2,2,35,0,7
	.byte	'stTimer',0
	.word	182
	.byte	1,2,35,2,0,4
	.byte	'CanSM_TimerConfig_tst_struct_impl',0,12,143,1,3
	.word	6804
	.byte	4
	.byte	'Com_impl_u16',0,12,154,1,16
	.word	213
	.byte	4
	.byte	'Com_impl_u8',0,12,157,1,15
	.word	182
	.byte	4
	.byte	'ComM_uint32_Impl',0,12,173,1,16
	.word	250
	.byte	4
	.byte	'ComM_uint16_Impl',0,12,175,1,16
	.word	213
	.byte	4
	.byte	'ComM_uint8_Impl',0,12,177,1,15
	.word	182
	.byte	4
	.byte	'ComM_bool_Impl',0,12,179,1,15
	.word	182
	.byte	6,12,181,1,9,24,7
	.byte	'ChannelState_e',0
	.word	250
	.byte	4,2,35,0,7
	.byte	'LightTimeoutCtr_u32',0
	.word	250
	.byte	4,2,35,4,7
	.byte	'MinFullComTimeoutCtr_u16',0
	.word	213
	.byte	2,2,35,8,7
	.byte	'ChannelMode_u8',0
	.word	182
	.byte	1,2,35,10,7
	.byte	'BusSmMode_u8',0
	.word	182
	.byte	1,2,35,11,7
	.byte	'UserRequestCtr_u8',0
	.word	182
	.byte	1,2,35,12,7
	.byte	'PassiveRequestState_u8',0
	.word	182
	.byte	1,2,35,13,7
	.byte	'PncRequestCtr_u8',0
	.word	182
	.byte	1,2,35,14,7
	.byte	'InhibitionReqStatus_u8',0
	.word	182
	.byte	1,2,35,15,7
	.byte	'NmNetworkRequestStatus_b',0
	.word	182
	.byte	1,2,35,16,7
	.byte	'DiagnosticRequestState_b',0
	.word	182
	.byte	1,2,35,17,7
	.byte	'CommunicationAllowed_b',0
	.word	182
	.byte	1,2,35,18,7
	.byte	'NmBusSleepIndicationStatus_b',0
	.word	182
	.byte	1,2,35,19,7
	.byte	'NmPrepareBusSleepIndicationStatus_b',0
	.word	182
	.byte	1,2,35,20,7
	.byte	'NmNetworkModeStatus_b',0
	.word	182
	.byte	1,2,35,21,0,4
	.byte	'ComM_ChannelStruct_Impl',0,12,197,1,3
	.word	7036
	.byte	6,12,206,1,9,10,7
	.byte	'WakeUpInhibitionCtr_u16',0
	.word	213
	.byte	2,2,35,0,7
	.byte	'LimitToNoComCtr_u16',0
	.word	213
	.byte	2,2,35,2,7
	.byte	'RequestedUserMode_t',0
	.word	182
	.byte	1,2,35,4,7
	.byte	'IndicatedUserMode_t',0
	.word	182
	.byte	1,2,35,5,7
	.byte	'numChannelsInFullCom_u8',0
	.word	182
	.byte	1,2,35,6,7
	.byte	'numChannelsInSilentCom_u8',0
	.word	182
	.byte	1,2,35,7,7
	.byte	'numChannelsInNoCom_u8',0
	.word	182
	.byte	1,2,35,8,0,4
	.byte	'ComM_UserStruct_Impl',0,12,214,1,3
	.word	7540
	.byte	4
	.byte	'Dcm_IOOperationResponseType',0,12,252,1,15
	.word	182
	.byte	4
	.byte	'Dcm_RequestDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspRequestRoutineResultsOutSignal_0PrimitivType',0
	.byte	12,138,2,15
	.word	182
	.byte	4
	.byte	'Dcm_StartDataIn_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineInSignalPrimitivType',0,12,146,2,15
	.word	182
	.byte	4
	.byte	'Dcm_StartDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineOutSignalPrimitivType',0,12,150,2,15
	.word	182
	.byte	4
	.byte	'Dcm_StopDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStopRoutineOutSignalPrimitivType',0,12,154,2,15
	.word	182
	.byte	4
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockNative_1024_Type',0,12,243,3,34
	.word	6283
	.byte	8,128,8
	.word	182
	.byte	9,255,7,0,4
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockRedundant_1024_Type',0,12,246,3,34
	.word	6283
	.byte	4
	.byte	'Fls_LengthType',0,13,173,3,16
	.word	250
	.byte	11
	.byte	'Fls_JobStartType',0,13,175,3,16,1,22
	.byte	'Reserved1',0,1
	.word	182
	.byte	1,7,2,35,0,22
	.byte	'Write',0,1
	.word	182
	.byte	1,6,2,35,0,22
	.byte	'Erase',0,1
	.word	182
	.byte	1,5,2,35,0,22
	.byte	'Read',0,1
	.word	182
	.byte	1,4,2,35,0,22
	.byte	'Compare',0,1
	.word	182
	.byte	1,3,2,35,0,22
	.byte	'Reserved2',0,1
	.word	182
	.byte	3,0,2,35,0,0,4
	.byte	'Fls_JobStartType',0,13,183,3,3
	.word	8382
	.byte	4
	.byte	'Fls_17_Pmu_Job_Type',0,13,187,3,15
	.word	182
	.byte	3
	.word	182
	.byte	17
	.word	182
	.byte	3
	.word	8577
	.byte	8,2
	.word	182
	.byte	9,1,0,11
	.byte	'Fls_17_Pmu_StateType',0,13,198,3,16,48,7
	.byte	'FlsReadAddress',0
	.word	250
	.byte	4,2,35,0,7
	.byte	'FlsWriteAddress',0
	.word	250
	.byte	4,2,35,4,7
	.byte	'FlsEraseTimeoutCycleCount',0
	.word	250
	.byte	4,2,35,8,7
	.byte	'FlsWriteTimeoutCycleCount',0
	.word	250
	.byte	4,2,35,12,7
	.byte	'FlsReadLength',0
	.word	250
	.byte	4,2,35,16,7
	.byte	'FlsWriteLength',0
	.word	250
	.byte	4,2,35,20,7
	.byte	'FlsReadBufferPtr',0
	.word	8572
	.byte	4,2,35,24,7
	.byte	'FlsWriteBufferPtr',0
	.word	8582
	.byte	4,2,35,28,7
	.byte	'FlsJobResult',0
	.word	4786
	.byte	4,2,35,32,7
	.byte	'FlsMode',0
	.word	4944
	.byte	4,2,35,36,7
	.byte	'NotifCaller',0
	.word	182
	.byte	1,2,35,40,7
	.byte	'JobStarted',0
	.word	8382
	.byte	1,2,35,41,7
	.byte	'FlsJobType',0
	.word	8587
	.byte	2,2,35,42,7
	.byte	'FlsOper',0
	.word	182
	.byte	1,2,35,44,7
	.byte	'FlsTimeoutErr',0
	.word	182
	.byte	1,2,35,45,7
	.byte	'FlsTimeoutControl',0
	.word	182
	.byte	1,2,35,46,0,4
	.byte	'Fls_17_Pmu_StateType',0,13,130,4,3
	.word	8596
	.byte	4
	.byte	'Fls_NotifFunctionPtrType',0,13,137,4,16
	.word	791
	.byte	17
	.word	250
	.byte	3
	.word	9074
	.byte	15,1,1,16
	.word	250
	.byte	16
	.word	250
	.byte	16
	.word	9079
	.byte	16
	.word	182
	.byte	0,3
	.word	9084
	.byte	4
	.byte	'Fls_WriteCmdPtrType',0,13,139,4,16
	.word	9108
	.byte	15,1,1,16
	.word	250
	.byte	0,3
	.word	9142
	.byte	4
	.byte	'Fls_EraseCmdPtrType',0,13,144,4,16
	.word	9151
	.byte	0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L4:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,21,0,54,15,0,0,3,15,0,73,19,0,0,4,22,0,3,8,58,15,59,15
	.byte	57,15,73,19,0,0,5,36,0,3,8,11,15,62,15,0,0,6,19,1,58,15,59,15,57,15,11,15,0,0,7,13,0,3,8,73,19,11,15,56
	.byte	9,0,0,8,1,1,11,15,73,19,0,0,9,33,0,47,15,0,0,10,21,0,54,15,39,12,0,0,11,19,1,3,8,58,15,59,15,57,15,11
	.byte	15,0,0,12,4,1,58,15,59,15,57,15,11,15,0,0,13,40,0,3,8,28,13,0,0,14,59,0,3,8,0,0,15,21,1,54,15,39,12,0
	.byte	0,16,5,0,73,19,0,0,17,38,0,73,19,0,0,18,23,1,58,15,59,15,57,15,11,15,0,0,19,4,1,3,8,58,15,59,15,57,15
	.byte	11,15,0,0,20,21,0,73,19,54,15,39,12,0,0,21,53,0,73,19,0,0,22,13,0,3,8,11,15,73,19,13,15,12,15,56,9,0,0
	.byte	0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L5:
	.word	.L8-.L7
.L7:
	.half	3
	.word	.L10-.L9
.L9:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Fee\\src\\Fee_Order.c',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Platform\\Platform_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Std_Types.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\RTOS_T\\Gen\\inc\\Os.h',0,0,0,0
	.byte	'.\\Integration\\TargetIntegration\\TC275\\Include\\Mcal_TcLib.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\MemIf\\api\\MemIf_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Can_GeneralTypes.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Can_17_MCanP\\inc\\Can_17_MCanP.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Type.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Fls\\inc\\Fls_17_Pmu.h',0,0,0,0,0
.L10:
.L8:

; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	     1  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	     2  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	     3  /*
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	     4   **********************************************************************************************************************
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	     5   * Includes
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	     7  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	     8  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	     9  #include "Fee.h"
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    10  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    11  /* Disable the Fee common part when the Fs1 is selected - currently the Fs1 is a complete Fee */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    12  #if(defined(FEE_PRV_CFG_SELECTED_FS) && (1 != FEE_PRV_CFG_SELECTED_FS))
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    13  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    14  #include "Fee_Prv.h"
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    15  #include "Fee_Cfg_SchM.h"
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    16  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    17  #if (STD_ON == FEE_DEV_ERROR_DETECT)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    18  #include "Det.h"
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    19  #endif
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    20  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    21  /*
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    22   **********************************************************************************************************************
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    23   * Variables
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    24   **********************************************************************************************************************
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    25  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    26  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    27  #define FEE_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    28  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    29  static Fee_Prv_Order_tst Fee_Prv_Order_st;  /* Internal variables of the order unit */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    30  #define FEE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    31  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    32  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    33  /*
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    35   * Static declaration
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    37  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    38  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    39  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    40  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    41  static void Fee_Prv_OrderDetReport(uint8 apiId_u8, uint8 errorId_u8);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    42  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    43  static Std_ReturnType Fee_Prv_OrderDetCheckModuleInit       (uint8 apiId_u8                                                         );
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    44  static Std_ReturnType Fee_Prv_OrderDetCheckModuleIdle       (uint8 apiId_u8                                                         );
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    45  static Std_ReturnType Fee_Prv_OrderDetCheckBlkCfg           (uint8 apiId_u8, uint16 blkNr_u16                                       );
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    46  static Std_ReturnType Fee_Prv_OrderDetCheckAdrPtr           (uint8 apiId_u8, void const * bfr_pcv                                   );
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    47  static Std_ReturnType Fee_Prv_OrderDetCheckBlkOfs           (uint8 apiId_u8, uint16 blkNr_u16, uint16 blkOfs_u16                    );
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    48  static Std_ReturnType Fee_Prv_OrderDetCheckBlkLen           (uint8 apiId_u8, uint16 blkNr_u16, uint16 blkOfs_u16, uint16 blkLen_u16 );
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    49  static Std_ReturnType Fee_Prv_OrderDetCheckBlkLenNull       (uint8 apiId_u8, uint16 blkLen_u16                                      );
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    50  static Std_ReturnType Fee_Prv_OrderDetCheckBlkVarLenCfg     (uint8 apiId_u8, uint16 blkNr_u16, boolean active_b                     );
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    51  static Std_ReturnType Fee_Prv_OrderDetCheckBlkMigrationCfg  (uint8 apiId_u8, uint16 blkNr_u16, boolean active_b                     );
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    52  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    53  static Std_ReturnType Fee_Prv_OrderPut(uint8 apiId_u8, Fee_Prv_OrderJob_tst const * order_pcst);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    54  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    55  /*
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    56   **********************************************************************************************************************
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    57   * Implementation
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    58   **********************************************************************************************************************
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    59  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    60  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    61  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    62   * \brief   Forward an error the Det module.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    63   *          In case Det error reporting is turned off, it is not forwarded here.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    64   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    65   * \param   apiId_u8    The ID of the API
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    66   * \param   errorId_u8  The ID of the error
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    67  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    68  static void Fee_Prv_OrderDetReport(uint8 apiId_u8, uint8 errorId_u8)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    69  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    70      #if (STD_ON == FEE_DEV_ERROR_DETECT)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    71      (void)Det_ReportError(FEE_MODULE_ID, FEE_INSTANCE_ID, apiId_u8, errorId_u8);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    72      #else
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    73      (void)apiId_u8;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    74      (void)errorId_u8;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    75      #endif
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    76  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    77  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    78  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    79  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    80   * \brief   Check whether the Fee is initialized (Fee_Init was called).
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    81   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    82   * \param   apiId_u8    The API which requests this check, needed for Det_ReportError in case of failure
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    83   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    84   * \retval  E_OK        Fee is initialized
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    85   * \retval  E_NOT_OK    Fee is not initialized
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    86  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    87  static Std_ReturnType Fee_Prv_OrderDetCheckModuleInit(uint8 apiId_u8)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    88  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    89      Std_ReturnType result_en = E_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    90      if(MEMIF_UNINIT == Fee_GetStatus())
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    91      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    92          Fee_Prv_OrderDetReport(apiId_u8, FEE_E_UNINIT);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    93          result_en = E_NOT_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    94      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    95      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    96  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    97  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    98  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	    99   * \brief   Check whether the Fee is currently idle
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   100   *          - Fee_Init was called
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   101   *          - No internal or external action is being processed
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   102   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   103   * \param   apiId_u8    The API which requests this check, needed for Det_ReportError in case of failure
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   104   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   105   * \retval  E_OK        Fee_GetStatus() returns MEMIF_IDLE
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   106   * \retval  E_NOT_OK    Fee_GetStatus() does not return MEMIF_IDLE
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   107  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   108  static Std_ReturnType Fee_Prv_OrderDetCheckModuleIdle(uint8 apiId_u8)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   109  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   110      Std_ReturnType result_en;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   111  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   112      switch(Fee_GetStatus())
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   113      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   114          case MEMIF_IDLE:
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   115              result_en = E_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   116              break;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   117  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   118          case MEMIF_UNINIT:
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   119              Fee_Prv_OrderDetReport(apiId_u8, FEE_E_UNINIT);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   120              result_en = E_NOT_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   121              break;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   122  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   123          case MEMIF_BUSY_INTERNAL:
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   124              Fee_Prv_OrderDetReport(apiId_u8, FEE_E_BUSY_INTERNAL);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   125              result_en = E_NOT_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   126              break;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   127  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   128          case MEMIF_BUSY:
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   129              Fee_Prv_OrderDetReport(apiId_u8, FEE_E_BUSY);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   130              result_en = E_NOT_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   131              break;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   132  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   133          default:
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   134              result_en = E_NOT_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   135              break;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   136      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   137  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   138      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   139  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   140  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   141  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   142   * \brief   Check whether a block number is valid.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   143   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   144   * \param   apiId_u8    The API which requests this check, needed for Det_ReportError in case of failure
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   145   * \param   blkNr_u16   The block number that shall be checked
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   146   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   147   * \retval  E_OK        The block number is valid
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   148   * \retval  E_NOT_OK    The block number is not valid
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   149  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   150  static Std_ReturnType Fee_Prv_OrderDetCheckBlkCfg(uint8 apiId_u8, uint16 blkNr_u16)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   151  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   152      Std_ReturnType result_en = E_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   153      if(FEE_NUM_BLOCKS <= blkNr_u16)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   154      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   155          Fee_Prv_OrderDetReport(apiId_u8, FEE_E_INVALID_BLOCK_NO);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   156          result_en = E_NOT_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   157      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   158      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   159  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   160  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   161  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   162   * \brief   Check whether a pointer is a NULL_PTR.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   163   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   164   * \param   apiId_u8    The API which requests this check, needed for Det_ReportError in case of failure
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   165   * \param   bfr_pcv     The pointer that shall be checked
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   166   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   167   * \retval  E_OK        The pointer is not a NULL_PTR
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   168   * \retval  E_NOT_OK    The pointer is a NULL_PTR
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   169  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   170  static Std_ReturnType Fee_Prv_OrderDetCheckAdrPtr(uint8 apiId_u8, void const * bfr_pcv)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   171  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   172      Std_ReturnType result_en = E_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   173      if(NULL_PTR == bfr_pcv)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   174      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   175          Fee_Prv_OrderDetReport(apiId_u8, FEE_E_INVALID_DATA_PTR);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   176          result_en = E_NOT_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   177      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   178      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   179  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   180  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   181  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   182   * \brief   Check whether an offset is longer or equal the block length.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   183   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   184   * \param   apiId_u8    The API which requests this check, needed for Det_ReportError in case of failure
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   185   * \param   blkNr_u16   The block number
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   186   * \param   blkOfs_u16  The offset that shall be checked
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   187   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   188   * \retval  E_OK        The offset is smaller than the length of the block
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   189   * \retval  E_NOT_OK    The offset is longer or equal the length of the block
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   190  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   191  static Std_ReturnType Fee_Prv_OrderDetCheckBlkOfs(uint8 apiId_u8, uint16 blkNr_u16, uint16 blkOfs_u16)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   192  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   193      Std_ReturnType result_en = E_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   194      if(blkOfs_u16 >= Fee_Prv_ConfigGetBlockLengthByBlockNr(blkNr_u16))
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   195      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   196          Fee_Prv_OrderDetReport(apiId_u8, FEE_E_INVALID_BLOCK_OFS);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   197          result_en = E_NOT_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   198      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   199      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   200  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   201  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   202  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   203   * \brief   Check that length + offset do not exceed block length.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   204   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   205   * \param   apiId_u8    The API which requests this check, needed for Det_ReportError in case of failure
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   206   * \param   blkNr_u16   The block number
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   207   * \param   blkOfs_u16  The offset
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   208   * \param   blkLen_u16  The requested length
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   209   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   210   * \retval  E_OK        Offset + Length are bigger than the block length
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   211   * \retval  E_NOT_OK    Offset + Length are smaller or equal the block length
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   212  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   213  static Std_ReturnType Fee_Prv_OrderDetCheckBlkLen(uint8 apiId_u8, uint16 blkNr_u16, uint16 blkOfs_u16, uint16 blkLen_u16)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   214  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   215      Std_ReturnType result_en = E_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   216      if((blkOfs_u16 + blkLen_u16) > Fee_Prv_ConfigGetBlockLengthByBlockNr(blkNr_u16))
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   217      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   218          Fee_Prv_OrderDetReport(apiId_u8, FEE_E_INVALID_BLOCK_LEN);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   219          result_en = E_NOT_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   220      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   221      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   222  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   223  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   224  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   225   * \brief   Check that requested block length is not zero.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   226   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   227   * \param   apiId_u8    The API which requests this check, needed for Det_ReportError in case of failure
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   228   * \param   blkNr_u16   The block number
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   229   * \param   blkLen_u16  The requested length
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   230   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   231   * \retval  E_OK        Requested length is bigger than zero
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   232   * \retval  E_NOT_OK    Requested length is zero
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   233  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   234  static Std_ReturnType Fee_Prv_OrderDetCheckBlkLenNull(uint8 apiId_u8, uint16 blkLen_u16)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   235  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   236      Std_ReturnType result_en = E_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   237      if(0u == blkLen_u16)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   238      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   239          Fee_Prv_OrderDetReport(apiId_u8, FEE_E_INVALID_BLOCK_LEN);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   240          result_en = E_NOT_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   241      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   242      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   243  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   244  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   245  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   246   * \brief   Checks that requested block is configured for variable block length.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   247   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   248   * \param   apiId_u8    The API which requests this check, needed for Det_ReportError in case of failure
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   249   * \param   blkNr_u16   The block number
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   250   * \param   active_b    Under which condition the det error should be set
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   251   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   252   * \retval  E_OK        Block is configured for variable block length
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   253   * \retval  E_NOT_OK    Block is not configured for variable block length
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   254  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   255  static Std_ReturnType Fee_Prv_OrderDetCheckBlkVarLenCfg(uint8 apiId_u8, uint16 blkNr_u16, boolean active_b)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   256  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   257      Std_ReturnType result_en = E_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   258      if(active_b != Fee_Prv_ConfigIsBlockLengthVariable(blkNr_u16))
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   259      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   260          Fee_Prv_OrderDetReport(apiId_u8, FEE_E_INVALID_VAR_BLK_LEN_CFG);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   261          result_en = E_NOT_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   262      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   263      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   264  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   265  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   266  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   267   * \brief   Checks that requested block is configured for migration.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   268   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   269   * \param   apiId_u8    The API which requests this check, needed for Det_ReportError in case of failure
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   270   * \param   blkNr_u16   The block number
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   271   * \param   active_b    Under which condition the det error should be set
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   272   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   273   * \retval  E_OK        Block is configured for migration
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   274   * \retval  E_NOT_OK    Block is not configured for migration
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   275  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   276  static Std_ReturnType Fee_Prv_OrderDetCheckBlkMigrationCfg(uint8 apiId_u8, uint16 blkNr_u16, boolean active_b)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   277  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   278      Std_ReturnType result_en        = E_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   279      uint16         persistentId_u16 = Fee_BlockProperties_st[blkNr_u16].BlockPersistentId_u16;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   280  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   281      if(active_b != Fee_Prv_ConfigIsMigrationActive(persistentId_u16))
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   282      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   283          Fee_Prv_OrderDetReport(apiId_u8, FEE_E_INVALID_MIGRATION_CFG);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   284          result_en = E_NOT_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   285      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   286      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   287  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   288  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   289  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   290   * \brief   Try to place an order in the internal order slot.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   291   *          Based on block configuration the order slots is chosen.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   292   *          If the Fee is not ready or the order slot is occupied E_NOT_OK is returned.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   293   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   294   * \param   apiId_u8    The ID of the API which places the order
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   295   * \param   order_pcst  The order that shall be placed
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   296   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   297   * \retval  E_OK        Order placed successfully
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   298   * \retval  E_NOT_OK    Order could not be placed
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   299  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   300  static Std_ReturnType Fee_Prv_OrderPut(uint8 apiId_u8, Fee_Prv_OrderJob_tst const * order_pcst)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   301  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   302      Std_ReturnType              result_en       = E_NOT_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   303      Fee_Prv_ConfigRequester_ten requester_en    = Fee_Prv_ConfigGetRequester(order_pcst->blockNumber_u16);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   304  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   305      SchM_Enter_Fee_Order();
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   306      /*
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   307       * Make sure the order slot is free.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   308       * A spin lock is needed since the main function might want to finish an order asynchronous.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   309       */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   310      if(FEE_PRV_ORDERTYPE_NONE_E == Fee_Prv_Order_st.jobs_ast[requester_en].type_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   311      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   312          /* Set job and result of the current order */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   313          Fee_Prv_Order_st.jobs_ast   [requester_en] = *order_pcst;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   314          Fee_Prv_Order_st.results_aen[requester_en] = MEMIF_JOB_PENDING;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   315          result_en = E_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   316      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   317      SchM_Exit_Fee_Order();
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   318  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   319      /*
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   320       * In case placing the order of NvM or an adapter did not work trigger Det error.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   321       * Do not do this for internal orders.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   322       * Do not do this under interrupt lock!
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   323       */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   324      if(E_NOT_OK == result_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   325      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   326          switch(requester_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   327          {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   328              case FEE_PRV_REQUESTER_NVM_E:       Fee_Prv_OrderDetReport(apiId_u8, FEE_E_BUSY         );  break;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   329              case FEE_PRV_REQUESTER_ADAPTER_E:   Fee_Prv_OrderDetReport(apiId_u8, FEE_E_BUSY_INTERNAL);  break;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   330              default:                            /* Not DET report for internal orders */                break;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   331          }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   332      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   333  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   334      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   335  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   336  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   337  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   338   * \brief   Called by the main function if it wants to begin an order.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   339   *          NvM orders always have priority before adapter orders.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   340   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   341   * \return  The next order that shall be started.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   342  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   343  Fee_Prv_OrderJob_tst * Fee_Prv_OrderBegin(void)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   344  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   345      uint32 requester_u32;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   346      Fee_Prv_OrderJob_tst * result_pst = NULL_PTR;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   347  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   348      for(requester_u32 = (uint32)FEE_PRV_REQUESTER_NVM_E; (requester_u32 < (uint32)FEE_PRV_REQUESTER_MAX_E) && (NULL_PTR == result_pst); requester_u32++)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   349      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   350          if(FEE_PRV_ORDERTYPE_NONE_E != Fee_Prv_Order_st.jobs_ast[requester_u32].type_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   351          {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   352              /* Begin order under interrupt lock since at the same time an external requester might modify the order. */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   353              SchM_Enter_Fee_Order();
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   354              result_pst = &Fee_Prv_Order_st.jobs_ast[requester_u32];
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   355              SchM_Exit_Fee_Order();
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   356          }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   357      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   358  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   359      return(result_pst);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   360  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   361  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   362  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   363   * \brief   Called by the main function if it wants to finish an order.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   364   *          If a callback is configured the callback is called.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   365   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   366   * \param   order_pst   The order that shall be finished
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   367   * \param   result_en   Result of that order
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   368   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   369   * \attention   This function calls Fee user callbacks under spin lock!
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   370   *              That means the Fee user shall only do very short operations in its callback!
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   371  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   372  void Fee_Prv_OrderEnd(Fee_Prv_OrderJob_tst * order_pst, MemIf_JobResultType result_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   373  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   374      Fee_Prv_ConfigNotification_tpfn notification_pfn    = NULL_PTR;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   375      Fee_Prv_ConfigRequester_ten     requester_en        = Fee_Prv_ConfigGetRequester(order_pst->blockNumber_u16);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   376  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   377       /* Find out the configured notification for this job results and this block */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   378      if(
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   379          (MEMIF_JOB_OK           == result_en) ||
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   380          (MEMIF_BLOCK_INVALID    == result_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   381      )
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   382      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   383          notification_pfn = Fee_Prv_ConfigGetJobEndNotification(order_pst->blockNumber_u16);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   384      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   385      else
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   386      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   387          notification_pfn = Fee_Prv_ConfigGetJobErrorNotification(order_pst->blockNumber_u16);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   388      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   389  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   390      /* Finish an order under spin lock */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   391      SchM_Enter_Fee_Order();
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   392  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   393      Fee_Prv_Order_st.results_aen[requester_en] = result_en;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   394  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   395      /* Calculate migration result in case a read order is finished */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   396      if(FEE_PRV_ORDERTYPE_READ_E == order_pst->type_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   397      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   398          /* Check if migration result was already set */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   399          if(MEMIF_RB_MIGRATION_RESULT_INIT_E == Fee_Prv_Order_st.firstInitMigrationResult_aen[order_pst->blockNumber_u16])
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   400          {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   401              Fee_Prv_Order_st.firstInitMigrationResult_aen[order_pst->blockNumber_u16] =
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   402                      Fee_Prv_Order_st.currentMigrationResult_en;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   403          }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   404      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   405  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   406      order_pst->type_en = FEE_PRV_ORDERTYPE_NONE_E;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   407  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   408      if(NULL_PTR != notification_pfn)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   409      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   410          notification_pfn();
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   411      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   412  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   413      SchM_Exit_Fee_Order();
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   414  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   415  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   416  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   417   * \brief   Start a read job.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   418   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   419   * \param   Blocknumber     Block number as generated in Fee_Cfg.h - This is not the persistent ID!
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   420   * \param   BlockOffset     The offset where the read shall start from in bytes
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   421   * \param   DataBufferPtr   Buffer to read data to
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   422   * \param   Length          Amount of data to read in bytes
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   423   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   424   * \retval  E_OK        Order accepted, will be executed asynchronously
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   425   * \retval  E_NOT_OK    Order not accepted
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   426  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   427  Std_ReturnType Fee_Read(uint16 Blocknumber, uint16 BlockOffset, uint8 * DataBufferPtr, uint16 Length)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   428  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   429      Std_ReturnType result_en = E_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   430  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   431      /* Check parameters */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   432      if(E_OK != Fee_Prv_OrderDetCheckModuleInit    (FEE_SID_READ)                                  ) { result_en = E_NOT_OK; }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   433      /* MR12 DIR 1.1 VIOLATION: uint8 * can always be converted safely to void * */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   434      if(E_OK != Fee_Prv_OrderDetCheckAdrPtr        (FEE_SID_READ, (void const *)DataBufferPtr)     ) { result_en = E_NOT_OK; }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   435      if(E_OK == Fee_Prv_OrderDetCheckBlkCfg(FEE_SID_READ, Blocknumber))
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   436      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   437          if(E_OK != Fee_Prv_OrderDetCheckBlkOfs          (FEE_SID_READ, Blocknumber, BlockOffset)        ) { result_en = E_NOT_OK; }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   438          if(E_OK != Fee_Prv_OrderDetCheckBlkLen          (FEE_SID_READ, Blocknumber, BlockOffset, Length)) { result_en = E_NOT_OK; }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   439          if(E_OK != Fee_Prv_OrderDetCheckBlkMigrationCfg (FEE_SID_READ, Blocknumber, FALSE)              ) { result_en = E_NOT_OK; }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   440      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   441      else
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   442      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   443          result_en = E_NOT_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   444      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   445  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   446      if(E_OK == result_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   447      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   448          Fee_Prv_OrderJob_tst order_st;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   449  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   450          /*
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   451           * Prepare order and try to place it.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   452           * If placing the order is not possible E_NOT_OK is returned by Fee_Prv_OrderPut.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   453           */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   454          order_st.type_en                = FEE_PRV_ORDERTYPE_READ_E;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   455          order_st.migrationResult_pen    = &(Fee_Prv_Order_st.currentMigrationResult_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   456          order_st.bfr_pu8                = DataBufferPtr;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   457          order_st.bfr_pcu8               = NULL_PTR;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   458          order_st.blockNumber_u16        = Blocknumber;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   459          order_st.length_u16             = Length;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   460          order_st.offset_u16             = BlockOffset;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   461  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   462          result_en = Fee_Prv_OrderPut(FEE_SID_READ, &order_st);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   463      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   464  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   465      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   466  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   467  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   468  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   469   * \brief   Starts a read job when block length is variable and calculated on runtime.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   470   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   471   * \param   Blocknumber     Block number as generated in Fee_Cfg.h - This is not the persistent ID!
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   472   * \param   BlockOffset     The offset where the read shall start from in bytes
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   473   * \param   DataBufferPtr   Buffer to read data to
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   474   * \param   Length          Amount of data to read in bytes
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   475   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   476   * \retval  E_OK        Order accepted, will be executed asynchronously
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   477   * \retval  E_NOT_OK    Order not accepted
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   478  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   479  Std_ReturnType Fee_Rb_VarLenRead(uint16 Blocknumber, uint16 BlockOffset, uint8 * DataBufferPtr, uint16 Length)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   480  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   481      Std_ReturnType result_en = E_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   482  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   483      /* Check parameters */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   484      if(E_OK != Fee_Prv_OrderDetCheckModuleInit      (FEE_SID_RB_VARLENREAD)                                 ) { result_en = E_NOT_OK; }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   485      /* MR12 DIR 1.1 VIOLATION: uint8 * can always be converted safely to void * */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   486      if(E_OK != Fee_Prv_OrderDetCheckAdrPtr          (FEE_SID_RB_VARLENREAD, (void const *)DataBufferPtr)    ) { result_en = E_NOT_OK; }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   487      if(E_OK != Fee_Prv_OrderDetCheckBlkLenNull      (FEE_SID_RB_VARLENREAD, Length)                         ) { result_en = E_NOT_OK; }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   488  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   489      if(E_OK == Fee_Prv_OrderDetCheckBlkCfg(FEE_SID_RB_VARLENREAD, Blocknumber))
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   490      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   491          if(E_OK != Fee_Prv_OrderDetCheckBlkMigrationCfg (FEE_SID_RB_VARLENREAD, Blocknumber, TRUE)          ) { result_en = E_NOT_OK; }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   492      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   493      else
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   494      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   495          result_en = E_NOT_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   496      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   497  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   498      if(E_OK == result_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   499      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   500          Fee_Prv_OrderJob_tst order_st;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   501  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   502          /*
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   503           * Prepare order and try to place it.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   504           * If placing the order is not possible E_NOT_OK is returned by Fee_Prv_OrderPut.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   505           */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   506          order_st.type_en                = FEE_PRV_ORDERTYPE_READ_E;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   507          order_st.migrationResult_pen    = &(Fee_Prv_Order_st.currentMigrationResult_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   508          order_st.bfr_pu8                = DataBufferPtr;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   509          order_st.bfr_pcu8               = NULL_PTR;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   510          order_st.blockNumber_u16        = Blocknumber;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   511          order_st.length_u16             = Length;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   512          order_st.offset_u16             = BlockOffset;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   513  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   514          result_en = Fee_Prv_OrderPut(FEE_SID_RB_VARLENREAD, &order_st);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   515      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   516  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   517      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   518  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   519  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   520  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   521   * \brief   Start a write job.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   522   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   523   * \param   Blocknumber     Block number as generated in Fee_Cfg.h - This is not the persistent ID!
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   524   * \param   DataBufferPtr   Buffer to write data from
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   525   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   526   * \retval  E_OK        Order accepted, will be executed asynchronously
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   527   * \retval  E_NOT_OK    Order not accepted
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   528  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   529  /* MR12 RULE 8.13 VIOLATION: DataBufferPtr is not const because it is also not const in the public header file */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   530  Std_ReturnType Fee_Write(uint16 Blocknumber, uint8 * DataBufferPtr)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   531  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   532      Std_ReturnType result_en = E_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   533  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   534      /* Check parameters */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   535      if(E_OK != Fee_Prv_OrderDetCheckModuleInit    (FEE_SID_WRITE)                                 ) { result_en = E_NOT_OK; }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   536      /* MR12 DIR 1.1 VIOLATION: uint8 * can always be converted safely to void * */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   537      if(E_OK != Fee_Prv_OrderDetCheckAdrPtr        (FEE_SID_WRITE, (void const *)DataBufferPtr)    ) { result_en = E_NOT_OK; }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   538  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   539      if(E_OK == Fee_Prv_OrderDetCheckBlkCfg(FEE_SID_WRITE, Blocknumber))
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   540      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   541          if(E_OK != Fee_Prv_OrderDetCheckBlkVarLenCfg  (FEE_SID_WRITE, Blocknumber, FALSE)         ) { result_en = E_NOT_OK; }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   542      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   543      else
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   544      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   545          result_en = E_NOT_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   546      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   547  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   548      if(E_OK == result_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   549      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   550          Fee_Prv_OrderJob_tst order_st;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   551  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   552          /*
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   553           * Prepare order and try to place it.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   554           * If placing the order is not possible E_NOT_OK is returned by Fee_Prv_OrderPut.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   555           */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   556          order_st.type_en            = FEE_PRV_ORDERTYPE_WRITE_E;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   557          order_st.bfr_pu8            = NULL_PTR;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   558          order_st.bfr_pcu8           = DataBufferPtr;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   559          order_st.blockNumber_u16    = Blocknumber;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   560          order_st.length_u16         = Fee_Prv_ConfigGetBlockLengthByBlockNr(Blocknumber);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   561          order_st.offset_u16         = 0;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   562  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   563          result_en = Fee_Prv_OrderPut(FEE_SID_WRITE, &order_st);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   564      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   565  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   566      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   567  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   568  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   569  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   570   * \brief   Starts a write job when block length is variable and calculated on runtime.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   571   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   572   * \param   Blocknumber     Block number as generated in Fee_Cfg.h - This is not the persistent ID!
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   573   * \param   DataBufferPtr   Buffer to write data from
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   574   * \param   Length          NV block length
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   575   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   576   * \retval  E_OK        Order accepted, will be executed asynchronously
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   577   * \retval  E_NOT_OK    Order not accepted
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   578  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   579  /* MR12 RULE 8.13 VIOLATION: DataBufferPtr is not const because it is also not const in the public header file */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   580  Std_ReturnType Fee_Rb_VarLenWrite(uint16 Blocknumber, uint8 * DataBufferPtr, uint16 Length)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   581  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   582      Std_ReturnType result_en = E_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   583  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   584      /* Check parameters */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   585      if(E_OK != Fee_Prv_OrderDetCheckModuleInit    (FEE_SID_RB_VARLENWRITE)                                 ) { result_en = E_NOT_OK; }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   586      /* MR12 DIR 1.1 VIOLATION: uint8 * can always be converted safely to void * */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   587      if(E_OK != Fee_Prv_OrderDetCheckAdrPtr        (FEE_SID_RB_VARLENWRITE, (void const *)DataBufferPtr)    ) { result_en = E_NOT_OK; }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   588      if(E_OK != Fee_Prv_OrderDetCheckBlkLenNull    (FEE_SID_RB_VARLENWRITE, Length)                         ) { result_en = E_NOT_OK; }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   589  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   590      if(E_OK == Fee_Prv_OrderDetCheckBlkCfg(FEE_SID_RB_VARLENWRITE, Blocknumber))
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   591      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   592          if(E_OK != Fee_Prv_OrderDetCheckBlkVarLenCfg  (FEE_SID_RB_VARLENWRITE, Blocknumber, TRUE)          ) { result_en = E_NOT_OK; }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   593      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   594      else
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   595      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   596          result_en = E_NOT_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   597      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   598  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   599      if(E_OK == result_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   600      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   601          Fee_Prv_OrderJob_tst order_st;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   602  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   603          /*
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   604           * Prepare order and try to place it.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   605           * If placing the order is not possible E_NOT_OK is returned by Fee_Prv_OrderPut.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   606           */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   607          order_st.type_en            = FEE_PRV_ORDERTYPE_WRITE_E;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   608          order_st.bfr_pu8            = NULL_PTR;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   609          order_st.bfr_pcu8           = DataBufferPtr;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   610          order_st.blockNumber_u16    = Blocknumber;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   611          order_st.length_u16         = Length;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   612          order_st.offset_u16         = 0;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   613  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   614          result_en = Fee_Prv_OrderPut(FEE_SID_RB_VARLENWRITE, &order_st);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   615      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   616  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   617      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   618  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   619  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   620  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   621   * \brief   Start an invalidate job.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   622   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   623   * \param   Blocknumber     Block number as generated in Fee_Cfg.h - This is not the persistent ID!
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   624   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   625   * \retval  E_OK        Order accepted, will be executed asynchronously
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   626   * \retval  E_NOT_OK    Order not accepted
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   627  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   628  Std_ReturnType Fee_InvalidateBlock(uint16 Blocknumber)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   629  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   630      Std_ReturnType result_en = E_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   631  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   632      /* Check parameters */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   633      if(E_OK != Fee_Prv_OrderDetCheckModuleInit    (FEE_SID_INVALIDATE)                ) { result_en = E_NOT_OK; }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   634      if(E_OK != Fee_Prv_OrderDetCheckBlkCfg        (FEE_SID_INVALIDATE, Blocknumber)   ) { result_en = E_NOT_OK; }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   635  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   636      if(E_OK == result_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   637      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   638          Fee_Prv_OrderJob_tst order_st;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   639  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   640          /*
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   641           * Prepare order and try to place it.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   642           * If placing the order is not possible E_NOT_OK is returned by Fee_Prv_OrderPut.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   643           */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   644          order_st.type_en            = FEE_PRV_ORDERTYPE_INVALIDATE_E;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   645          order_st.bfr_pu8            = NULL_PTR;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   646          order_st.bfr_pcu8           = NULL_PTR;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   647          order_st.blockNumber_u16    = Blocknumber;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   648          order_st.length_u16         = 0;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   649          order_st.offset_u16         = 0;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   650  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   651          result_en = Fee_Prv_OrderPut(FEE_SID_INVALIDATE, &order_st);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   652      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   653  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   654      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   655  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   656  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   657  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   658   * \brief   Erase immediate data.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   659   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   660   * \param   Blocknumber     Block number as generated in Fee_Cfg.h - This is not the persistent ID!
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   661   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   662   * \retval  E_OK        Order accepted, will be executed asynchronously
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   663   * \retval  E_NOT_OK    Order not accepted
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   664   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   665   * \attention   Currently not supported!
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   666  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   667  Std_ReturnType Fee_EraseImmediateBlock(uint16 BlockNumber)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   668  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   669      (void)BlockNumber;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   670      return(E_NOT_OK);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   671  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   672  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   673  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   674   * \brief   Cancel running operation.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   675   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   676   * \attention   Currently not supported!
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   677  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   678  void Fee_Cancel(void)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   679  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   680  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   681  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   682  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   683   * \brief   Get the status of the Fee module.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   684   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   685   * \retval  MEMIF_UNINIT        The Fee_Init was not called yet
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   686   * \retval  MEMIF_IDLE          The Fee_Init was called, NvM and adapter slots are free, no background operation running
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   687   * \retval  MEMIF_BUSY_INTERNAL a) Adapter job is running b) Background operation (maybe erase) is running c) Fee_Init is running
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   688   * \retval  MEMIF_BUSY          NvM order is running
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   689  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   690  MemIf_StatusType Fee_GetStatus(void)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   691  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   692      MemIf_StatusType result_en = MEMIF_UNINIT;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   693  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   694      if(FEE_PRV_DRIVERSTATE_INIT_E < Fee_Prv_DriverState_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   695      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   696          result_en = MEMIF_IDLE;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   697          if(FEE_PRV_ORDERTYPE_NONE_E != Fee_Prv_Order_st.jobs_ast[FEE_PRV_REQUESTER_NVM_E].type_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   698          {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   699              result_en = MEMIF_BUSY;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   700          }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   701          else if(
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   702              (FEE_PRV_ORDERTYPE_NONE_E != Fee_Prv_Order_st.jobs_ast[FEE_PRV_REQUESTER_ADAPTER_E].type_en ) ||
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   703              (FEE_PRV_ORDERTYPE_NONE_E != Fee_Prv_Order_st.jobs_ast[FEE_PRV_REQUESTER_DEBUG_E].type_en   )
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   704          )
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   705          {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   706              result_en = MEMIF_BUSY_INTERNAL;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   707          }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   708          else if(FEE_PRV_DRIVERSTATE_BACKGROUND_E == Fee_Prv_DriverState_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   709          {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   710              result_en = MEMIF_BUSY_INTERNAL;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   711          }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   712          else
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   713          {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   714              /* intentionally empty */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   715          }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   716      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   717      else if(FEE_PRV_DRIVERSTATE_INIT_E == Fee_Prv_DriverState_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   718      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   719          result_en = MEMIF_BUSY_INTERNAL;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   720      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   721      else
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   722      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   723          /* intentionally empty */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   724      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   725  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   726      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   727  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   728  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   729  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   730   * \brief   Return the result of the last NvM order.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   731   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   732   * \retval  MEMIF_JOB_OK                Last job executed successfully
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   733   * \retval  MEMIF_JOB_FAILED            Last job failed unexpected
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   734   * \retval  MEMIF_JOB_PENDING           Last job is still running
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   735   * \retval  MEMIF_BLOCK_INCONSISTENT    Last job was a read and
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   736   *                                      a) Not a single instance of all instances has consistent data
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   737   *                                      b) The block is not present at all
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   738   * \retval  MEMIF_BLOCK_INVALIDATED     Last job was a read and the block was invalidated intentionally
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   739   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   740   * \attention   Since the job result can change asynchronously a time consuming spin lock is needed!
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   741   *              Please consider this when creating do/while wait loops for the Fee.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   742  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   743  MemIf_JobResultType Fee_GetJobResult(void)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   744  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   745      MemIf_JobResultType result_en;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   746  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   747      if(E_OK != Fee_Prv_OrderDetCheckModuleInit(FEE_SID_GETJOBRESULT))
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   748      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   749          result_en = MEMIF_JOB_FAILED;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   750      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   751      else
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   752      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   753          /* Copy job result under spin lock since this can change every time asynchronously */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   754          SchM_Enter_Fee_Order();
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   755          result_en = Fee_Prv_Order_st.results_aen[FEE_PRV_REQUESTER_NVM_E];
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   756          SchM_Exit_Fee_Order();
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   757      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   758  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   759      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   760  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   761  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   762  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   763   * \brief   Return the result of the last Adapter order.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   764   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   765   * \retval  MEMIF_JOB_OK                Last job executed successfully
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   766   * \retval  MEMIF_JOB_FAILED            Last job failed unexpected
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   767   * \retval  MEMIF_JOB_PENDING           Last job is still running
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   768   * \retval  MEMIF_BLOCK_INCONSISTENT    Last job was a read and
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   769   *                                      a) Not a single instance of all instances has consistent data
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   770   *                                      b) The block is not present at all
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   771   * \retval  MEMIF_BLOCK_INVALIDATED     Last job was a read and the block was invalidated intentionally
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   772   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   773   * \attention   Since the job result can change asynchronously a time consuming spin lock is needed!
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   774   *              Please consider this when creating do/while wait loops for the Fee.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   775  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   776  MemIf_JobResultType Fee_Rb_GetAdapterJobResult(void)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   777  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   778      MemIf_JobResultType result_en;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   779  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   780      if(E_OK != Fee_Prv_OrderDetCheckModuleInit(FEE_SID_RB_ADAPTERGETJOBRESULT))
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   781      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   782          result_en = MEMIF_JOB_FAILED;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   783      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   784      else
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   785      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   786          /* Copy job result under spin lock since this can change every time asynchronously */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   787          SchM_Enter_Fee_Order();
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   788          result_en = Fee_Prv_Order_st.results_aen[FEE_PRV_REQUESTER_ADAPTER_E];
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   789          SchM_Exit_Fee_Order();
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   790      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   791  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   792      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   793  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   794  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   795  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   796   * \brief   Returns the migration result of data reading during initialisation
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   797   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   798   * \param  Blocknumber  Block number as generated in Fee_Cfg.h
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   799   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   800   * \retval  MEMIF_RB_MIGRATION_RESULT_INIT_E               Initialization value, result not yet available
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   801   * \retval  MEMIF_RB_MIGRATION_RESULT_NOT_NECESSARY_E      RAM size == EEPROM size (migration not necessary)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   802   * \retval  MEMIF_RB_MIGRATION_RESULT_TO_SMALLER_SIZE_E    RAM size < EEPROM size (remaining data discarded)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   803   * \retval  MEMIF_RB_MIGRATION_RESULT_TO_BIGGER_SIZE_E     RAM size > EEPROM size (remaining data filled with zero)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   804   * \retval  MEMIF_RB_MIGRATION_RESULT_NOT_DONE_E           Migration not done, because data were not read
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   805   * \retval  MEMIF_RB_MIGRATION_RESULT_DEACTIVATED_E        Migrations is deactivated by configuration
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   806   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   807   * \attention   Since the migration result can change asynchronously a time consuming spin lock is needed!
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   808   *              Please consider this when creating do/while wait loops for the Fee.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   809  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   810  MemIf_Rb_MigrationResult_ten Fee_Rb_GetMigrationResult(uint16 Blocknumber)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   811  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   812      MemIf_Rb_MigrationResult_ten result_en;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   813  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   814      if(E_OK != Fee_Prv_OrderDetCheckModuleInit(FEE_SID_GETMIGRATIONRESULT))
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   815      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   816          result_en = MEMIF_RB_MIGRATION_RESULT_INIT_E;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   817      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   818      else if(E_OK != Fee_Prv_OrderDetCheckBlkCfg(FEE_SID_GETMIGRATIONRESULT,Blocknumber))
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   819      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   820          result_en = MEMIF_RB_MIGRATION_RESULT_INIT_E;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   821      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   822      else
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   823      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   824          /* Copy migration result under spin lock since this can change every time asynchronously */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   825          SchM_Enter_Fee_Order();
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   826          result_en = Fee_Prv_Order_st.firstInitMigrationResult_aen[Blocknumber];
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   827          SchM_Exit_Fee_Order();
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   828      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   829  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   830      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   831  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   832  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   833  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   834  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   835  #if (STD_ON == FEE_SET_MODE_SUPPORTED)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   836  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   837   * \brief   Set the mode of the Fee and the underlying flash driver.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   838   *          It must be assured that the main function is not running when calling this interface.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   839   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   840   * \param   Mode    New mode
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   841  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   842  void Fee_SetMode(MemIf_ModeType Mode)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   843  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   844      if(E_OK != Fee_Prv_OrderDetCheckModuleIdle(FEE_SID_SETMODE))
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   845      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   846          /* Do nothing */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   847      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   848      else
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   849      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   850          if(FEE_PRV_DRIVERSTATE_IDLE_E == Fee_Prv_DriverState_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   851          {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   852              Fls_SetMode(Mode);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   853              SchM_Enter_Fee_Order();
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   854              Fee_Prv_DriverMode_en = Mode;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   855              SchM_Exit_Fee_Order();
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   856          }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   857      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   858  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   859  #endif
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   860  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   861  #if (STD_ON == FEE_VERSION_INFO_API)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   862  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   863   * \brief   Get version information about this Fee.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   864   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   865   * \param   VersionInfoPtr  Pointer to a standard version struct that shall be filled
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   866  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   867  void Fee_GetVersionInfo(Std_VersionInfoType * VersionInfoPtr)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   868  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   869      /* MR12 DIR 1.1 VIOLATION: uint8 * can always be converted safely to void * */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   870      if(E_OK != Fee_Prv_OrderDetCheckAdrPtr(FEE_SID_GETVERSIONINFO, (void const *)VersionInfoPtr))
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   871      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   872          /* Do nothing */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   873      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   874      else
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   875      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   876          VersionInfoPtr->vendorID            = FEE_VENDOR_ID;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   877          VersionInfoPtr->moduleID            = FEE_MODULE_ID;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   878          VersionInfoPtr->sw_major_version    = FEE_SW_MAJOR_VERSION;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   879          VersionInfoPtr->sw_minor_version    = FEE_SW_MINOR_VERSION;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   880          VersionInfoPtr->sw_patch_version    = FEE_SW_PATCH_VERSION;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   881      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   882  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   883  #endif
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   884  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   885  #if(FEE_RB_MAINTAIN != FALSE)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   886  /**
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   887   * \brief   Make sure that the double storage of a specified block number is intact.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   888   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   889   * \param   Blocknumber     The block number as defined in Fee_Cfg.h - This is not the persistent ID!
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   890   *
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   891   * \attention   This API is currently not supported!
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   892   *              Nevertheless E_OK is returned and the job result is set to MEMIF_JOB_OK if there is currently no job running.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   893   *              Reason:
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   894   *              There is an automatic repair mechanism which will repair the redundant storage if it gets lost once.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   895   *              This is active during a soft reorganization of the DFLASH in the background.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   896  */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   897  Std_ReturnType Fee_Rb_BlockMaintenance(uint16 Blocknumber)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   898  {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   899      Std_ReturnType result_en = E_OK;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   900  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   901      /* Check parameters */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   902      if(E_OK != Fee_Prv_OrderDetCheckModuleInit    (FEE_SID_MAINTAIN)                ) { result_en = E_NOT_OK; }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   903      if(E_OK != Fee_Prv_OrderDetCheckBlkCfg        (FEE_SID_MAINTAIN, Blocknumber)   ) { result_en = E_NOT_OK; }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   904  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   905      if(E_OK == result_en)
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   906      {
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   907          Fee_Prv_OrderJob_tst order_st;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   908  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   909          /*
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   910           * Prepare order and try to place it.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   911           * If placing the order is not possible E_NOT_OK is returned by Fee_Prv_OrderPut.
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   912           */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   913          order_st.type_en            = FEE_PRV_ORDERTYPE_BLOCKMAINTENANCE_E;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   914          order_st.bfr_pu8            = NULL_PTR;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   915          order_st.bfr_pcu8           = NULL_PTR;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   916          order_st.blockNumber_u16    = Blocknumber;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   917          order_st.length_u16         = Fee_Prv_ConfigGetBlockLengthByBlockNr(Blocknumber);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   918          order_st.offset_u16         = 0;
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   919  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   920          result_en = Fee_Prv_OrderPut(FEE_SID_MAINTAIN, &order_st);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   921      }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   922  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   923      return(result_en);
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   924  }
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   925  #endif
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   926  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   927  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   928  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   929  
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   930  /* 1 != FEE_PRV_CFG_SELECTED_FS */
; BSW\src\BSW\Gen\Fee\src\Fee_Order.c	   931  #endif

	; Module end
