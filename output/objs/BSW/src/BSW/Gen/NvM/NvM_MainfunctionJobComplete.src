	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 19053136 SN 09001910"
	.compiler_invocation	"ctc -f cc15572a -c99 --integer-enumeration -D__CPU__=tc27x -D__CPU_TC27X__ --core=tc1.6.x --eabi-compliant --fp-model=-float -D_TASKING_C_TRICORE_=1 -I.\\output\\inc -g2 -t4 --language=-comments,-gcc,+volatile,-strings --default-near-size=0 -O2ROPYGKLF-predict --default-a1-size=0 --default-a0-size=0 --source --switch=auto -o output\\objs\\BSW\\src\\BSW\\Gen\\NvM\\NvM_MainfunctionJobComplete.src BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainfunctionJobComplete.c"
	.compiler_name		"ctc"
	;source	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainfunctionJobComplete.c'

	
$TC16X
	
	.sdecl	'.text.NvM_MainfunctionJobComplete.NvM_Prv_JobComplete_Read',code,cluster('NvM_Prv_JobComplete_Read')
	.sect	'.text.NvM_MainfunctionJobComplete.NvM_Prv_JobComplete_Read'
	.align	2
	

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	     2  /*
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	     3   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	     4   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	     5   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	     6   */
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	     7  #include "NvM.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	     8  #include "Rte_NvM.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	     9  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    10  #include "NvM_Prv.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    11  #include "NvM_Prv_BlockData.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    12  #include "NvM_Prv_ErrorDetection.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    13  #include "NvM_Prv_ExplicitSynchronization.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    14  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    15  /*
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    17   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    18   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    19   */
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    20  typedef void (*NvM_Prv_JobComplete_tpfct)(NvM_Prv_JobData_tst* JobData_pst);
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    21  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    22  /*
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    23   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    24   * Local declarations
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    26   */
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    27  static void NvM_Prv_JobComplete_Read(NvM_Prv_JobData_tst* JobData_pst);
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    28  static void NvM_Prv_JobComplete_Restore(NvM_Prv_JobData_tst* JobData_pst);
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    29  static void NvM_Prv_JobComplete_InvalidateAllDatasets(NvM_Prv_JobData_tst* JobData_pst);
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    30  static void NvM_Prv_JobComplete_Validate(NvM_Prv_JobData_tst* JobData_pst);
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    31  static NvM_Prv_JobComplete_tpfct NvM_Prv_GetFctJobComplete(NvM_Prv_idJob_ten idJob_en);
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    35   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    38  #define NvM_Prv_JobComplete_Idle_pfct                               NULL_PTR
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    39  #define NvM_Prv_JobComplete_Read_pfct                               NvM_Prv_JobComplete_Read
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    40  #define NvM_Prv_JobComplete_Write_pfct                              NULL_PTR
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    41  #define NvM_Prv_JobComplete_Erase_pfct                              NULL_PTR
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    42  #define NvM_Prv_JobComplete_Restore_pfct                            NvM_Prv_JobComplete_Restore
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    43  #define NvM_Prv_JobComplete_Maintain_pfct                           NULL_PTR
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    44  #define NvM_Prv_JobComplete_Validate_pfct                           NvM_Prv_JobComplete_Validate
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    45  #define NvM_Prv_JobComplete_Invalidate_pfct                         NULL_PTR
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    46  #define NvM_Prv_JobComplete_ReadIdConfigForReadAll_pfct             NvM_Prv_JobComplete_Read
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    47  #define NvM_Prv_JobComplete_InvalidateForFirstInitAll_pfct          NvM_Prv_JobComplete_InvalidateAllDatasets
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    48  #define NvM_Prv_JobComplete_RestoreForImplicitRecovery_pfct         NvM_Prv_JobComplete_Restore
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    49  #define NvM_Prv_JobComplete_InvalidateForRemoveNonResistant_pfct    NvM_Prv_JobComplete_InvalidateAllDatasets
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    50  #define NvM_Prv_JobComplete_Invalid_pfct                            NULL_PTR
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    51  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    52  /**
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    53   * Function-like macro: LIST_ENTRY_JOB_COMPLETE_FCT
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    54   *
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    55   * This macro generates an entry for a complete job function in a list of all jobs provided by NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    56   * s.a. macro LIST_ID_JOB to generate a list for all jobs provided by NvM
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    57   *
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    58   * Paramater:
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    59   * Name: name of the job for which a complete job function will be generated.
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    60   */
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    61  #define LIST_ENTRY_JOB_COMPLETE_FCT(Name)   NvM_Prv_JobComplete_##Name##_pfct,
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    63  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    65  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    66  static NvM_Prv_JobComplete_tpfct const NvM_Prv_JobCompleteFcts_capfct[NvM_Prv_idJob_Count_e] =
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    67  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    68      LIST_ID_JOB(LIST_ENTRY_JOB_COMPLETE_FCT)
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    69  };
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    70  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    72  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    74  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    75  /*
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    76   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    77   * Inline declarations
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    78   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    79   */
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    80  LOCAL_INLINE void NvM_Prv_CopyBlockDataFromRom(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    81                                                 uint8* RamBlock_pu8,
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    82                                                 uint8 idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    83  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    84  /*
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    85   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    86   * NvM-private code
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    87   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    88   */
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    89  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    90  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    91  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    92  static void NvM_Prv_JobComplete_Read(NvM_Prv_JobData_tst* JobData_pst)
; Function NvM_Prv_JobComplete_Read
.L59:
NvM_Prv_JobComplete_Read:	.type	func
	mov.aa	a12,a4
.L209:

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    93  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    94      // check whether MemIf has finished the read job successfully or explicit synchronization is ongoing
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    95      if ((MEMIF_JOB_OK == JobData_pst->Result_en) || (MEMIF_JOB_PENDING == JobData_pst->Result_en))
	ld.w	d15,[a12]16
.L259:
	jeq	d15,#0,.L2
.L260:
	jne	d15,#2,.L3
.L2:

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    96      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    97          // trigger the read callback for explicit synchronization
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    98          JobData_pst->Result_en = NvM_Prv_ExplicitSync_CopyData(NvM_Prv_GetCopyFctForRead(JobData_pst->idBlock_uo),
	ld.hu	d4,[a12]4
.L116:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   392  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   393   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   394   * This NvM private function checks for the given block whether the configured block length is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   395   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   396   * \param idBlock
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   397   * ID of the block for which the block length will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   398   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   399   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   400   * - TRUE = block length is valid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   401   * - FALSE = block length is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   402   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   403  LOCAL_INLINE boolean NvM_Prv_IsBlockLengthValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   404  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   405      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   406              (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   407              (0u != *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   408  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   409  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   410  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   411   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   412   * This NvM private function checks whether the given block is configured with immediate priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   413   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   414   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   415   * ID of the block for which the priority will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   416   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   417   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   418   * - TRUE = block is configured with immediate priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   419   * - FALSE = block is configured with standard priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   420   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   421  LOCAL_INLINE boolean NvM_Prv_HasBlockImmediateJobPriority(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   423      boolean HasBlockImmediateJobPriority_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   425  #if (NVM_JOB_PRIORITIZATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   426      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   427          (NVM_PRV_JOB_PRIORITY_IMMEDIATE == NvM_Prv_BlockDescriptors_acst[idBlock_uo].JobPriority_u8))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   428      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   429          HasBlockImmediateJobPriority_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   430      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   431  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   433  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   434  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   435  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   436   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   437   * This NvM private function returns the configured block size for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   438   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   439   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   440   * ID of the block for which the configured block size will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   441   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   442   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   443   * Configured block size
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   444   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   445  LOCAL_INLINE uint16 NvM_Prv_GetBlockSize(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   446  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   447      uint16 BlockSize_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   448  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   451      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   452          BlockSize_u16 = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   453      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   454  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   455      return BlockSize_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   456  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   457  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   458  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   459   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   460   * This NvM private function returns the configured block management type for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   461   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   462   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   463   * ID of the block for which the configured block management type will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   464   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   465   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   466   * Configured block management type
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   467   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   468  LOCAL_INLINE NvM_BlockManagementType NvM_Prv_GetBlockType(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   469  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   470      NvM_BlockManagementType BlockType = NVM_BLOCK_NATIVE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   472      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   473          BlockType = NvM_Prv_BlockDescriptors_acst[idBlock_uo].BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   474      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   475      return BlockType;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   476  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   477  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   478  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   479   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   480   * This NvM private function returns the configured number of non-volatile data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   481   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   482   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   483   * ID of the block for which the configured number of non-volatile data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   484   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   485   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   486   * Configured number of non-volatile data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   487   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   488  LOCAL_INLINE uint8 NvM_Prv_GetNrNonVolatileBlocks(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   489  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   490      uint8 nrNvBlocks_u8 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   491      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   492      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   493          nrNvBlocks_u8 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   494      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   495      return nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   496  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   497  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   498  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   499   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   500   * This NvM private function returns the configured overall number of data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   501   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   502   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   503   * ID of the block for which the configured overall number of data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   504   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   505   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   506   * Configured number of data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   507   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   508  LOCAL_INLINE uint16 NvM_Prv_GetNrDataIndexes(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   509  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   510      uint8 nrDataIndexes = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   511      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   512      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   513          nrDataIndexes = (NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8 +
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   514                           NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrRomBlocks_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   515      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   516      return nrDataIndexes;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   517  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   518  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   519  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   520   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   521   * This NvM private function returns the pointer to the configured permanent RAM block for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   522   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   523   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   524   * If no permanent RAM block is configured for a block then this function returns a NULL pointer.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   525   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   526   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   527   * ID of the block for which the pointer to the configured permanent RAM block will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   528   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   529   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   530   * Pointer to the configured permanent RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   531   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   532  LOCAL_INLINE void * NvM_Prv_GetPRamBlockAddress(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   533  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   534      void * PRamBlockAddress_pv = NULL_PTR;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   535      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   536          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   537      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   538          PRamBlockAddress_pv = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   539      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   540  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   541      return PRamBlockAddress_pv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   542  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   543  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   544  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   545   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   546   * This NvM private function returns the pointer to the configured ROM block for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   547   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   548   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   549   * If no ROM block is configured for a block then this function returns a NULL pointer.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   550   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   551   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   552   * ID of the block for which the pointer to the configured ROM block will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   553   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   554   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   555   * Pointer to the configured ROM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   556   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   557  LOCAL_INLINE void const* NvM_Prv_GetRomBlockAddress(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   558  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   559      void const* adrRomBlock_pcv = NULL_PTR;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   560      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   561      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   562          adrRomBlock_pcv = NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   563      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   564      return adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   565  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   566  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   567  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   568   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   569   * This NvM private function returns the configured block ID used by the mem interface for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   570   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   571   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   572   * ID of the block for which the block ID used by the mem interface will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   573   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   574   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   575   * Configured block ID used by the mem interface
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   576   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   577  LOCAL_INLINE uint16 NvM_Prv_GetIdBlockMemIf(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   578  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   579      uint16 idBlockMemIf_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   580      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   581      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   582          idBlockMemIf_u16 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   583      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   584      return idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   585  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   586  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   587  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   588   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   589   * This NvM private function returns the configured device index where the given block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   590   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   591   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   592   * ID of the block for which the configured device index will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   593   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   594   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   595   * Configured device index where the given block is located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   596   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   597  LOCAL_INLINE uint8 NvM_Prv_GetIdxDevice(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   598  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   599      uint8 idxDevice_u8 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   600      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   601      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   602          idxDevice_u8 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   603      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   604      return idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   605  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   606  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   607  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   608   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   609   * This NvM private function returns the configured persistent ID of a block identified by index for persistent IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   610   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   611   * \param idxPersistentId_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   612   * Index of the required persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   613   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   614   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   615   * Configured persistent ID of a block identified by index for persistent IDs
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   616   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   617  LOCAL_INLINE uint16 NvM_Prv_GetIdPersistent(uint16 idxPersistentId_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   618  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   619      uint16 PersistentId_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   620      if (idxPersistentId_u16 < NVM_PRV_NR_PERSISTENT_IDS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   621      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   622          PersistentId_u16 = NvM_Prv_PersId_BlockId_acst[idxPersistentId_u16].PersistentId_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   623      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   624      return PersistentId_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   625  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   626  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   627  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   628   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   629   * This NvM private function returns the configured NvM ID of a block identified by index for persistent IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   630   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   631   * \param idxPersistentId_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   632   * Index of the required persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   633   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   634   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   635   * Configured NvM ID of a block identified by index for persistent IDs
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   636   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   637  LOCAL_INLINE NvM_BlockIdType NvM_Prv_GetIdBlock(uint16 idxPersistentId_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   638  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   639      uint16 BlockId_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   640      if (idxPersistentId_u16 < NVM_PRV_NR_PERSISTENT_IDS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   641      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   642          BlockId_u16 = NvM_Prv_PersId_BlockId_acst[idxPersistentId_u16].BlockId_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   643      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   644      return BlockId_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   645  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   646  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   647  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   648   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   649   * This NvM private function returns the configured pointer to the block specific callback function
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   650   * to copy data from the NvM mirror to the application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   651   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   652   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   653   * ID of the block for which the configured copy function will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   654   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   655   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   656   * Configured pointer to the copy function
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   657   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   658  LOCAL_INLINE NvM_Prv_ExplicitSync_Copy_tpfct NvM_Prv_GetCopyFctForRead(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   659  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   660      NvM_Prv_ExplicitSync_Copy_tpfct ReadRamBlockFromNvm_pfct = NULL_PTR;
	mov.a	a4,#0
.L208:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   661      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
	jge.u	d4,#14,.L4
.L261:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   661      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   662      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   663          ReadRamBlockFromNvm_pfct = NvM_Prv_BlockDescriptors_acst[idBlock_uo].ReadRamBlockFromNvm_pfct;
	mul	d15,d4,#48
.L262:
	movh.a	a2,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a2,[a2]@los(NvM_Prv_BlockDescriptors_acst)
.L263:
	addsc.a	a15,a2,d15,#0
.L264:
	ld.a	a4,[a15]32

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   661      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
.L4:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   665      return ReadRamBlockFromNvm_pfct;      (inlined)
	j	.L5

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   666  }      (inlined)
.L5:

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	    99                                                                 JobData_pst->idBlock_uo);
	call	NvM_Prv_ExplicitSync_CopyData
.L117:
	st.w	[a12]16,d2
.L265:
	j	.L6
.L3:

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   100      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   101      else
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   102      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   103          // Check whether a read job for an NvM block having a ROM block did not finish successfully
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   104          // -> if so, turn the read job into a restore job and start it ("implicit recovery")
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   105          // Note: As opposed to NVM389, implicit recovery is (currently?) not supported for DATASET blocks
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   106          if ((MEMIF_BLOCK_INVALID != JobData_pst->Result_en) &&
	jeq	d15,#5,.L7
.L266:

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   107              (NvM_Prv_IsDefaultDataAvailable(JobData_pst->idBlock_uo)) &&
	ld.hu	d5,[a12]4
.L124:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
	mov	d15,#0
.L267:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
	jge.u	d5,#14,.L8
.L268:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
	mul	d0,d5,#48
.L269:
	movh.a	a2,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a2,[a2]@los(NvM_Prv_BlockDescriptors_acst)
.L270:
	addsc.a	a15,a2,d0,#0
.L271:
	mov.a	a2,#0
.L272:
	ld.a	a4,[a15]16
.L210:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||      (inlined)
	jne.a	a2,a4,.L9
.L273:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
	mov.a	a2,#0
.L274:
	ld.a	a15,[a15]28
.L275:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));      (inlined)
	jeq.a	a2,a15,.L10

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||      (inlined)
.L9:
	mov	d15,#1

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
.L10:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));      (inlined)
.L8:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
	j	.L11

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }      (inlined)
.L11:
	jeq	d15,#0,.L12
.L125:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   392  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   393   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   394   * This NvM private function checks for the given block whether the configured block length is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   395   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   396   * \param idBlock
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   397   * ID of the block for which the block length will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   398   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   399   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   400   * - TRUE = block length is valid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   401   * - FALSE = block length is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   402   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   403  LOCAL_INLINE boolean NvM_Prv_IsBlockLengthValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   404  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   405      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   406              (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   407              (0u != *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   408  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   409  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   410  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   411   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   412   * This NvM private function checks whether the given block is configured with immediate priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   413   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   414   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   415   * ID of the block for which the priority will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   416   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   417   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   418   * - TRUE = block is configured with immediate priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   419   * - FALSE = block is configured with standard priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   420   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   421  LOCAL_INLINE boolean NvM_Prv_HasBlockImmediateJobPriority(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   423      boolean HasBlockImmediateJobPriority_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   425  #if (NVM_JOB_PRIORITIZATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   426      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   427          (NVM_PRV_JOB_PRIORITY_IMMEDIATE == NvM_Prv_BlockDescriptors_acst[idBlock_uo].JobPriority_u8))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   428      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   429          HasBlockImmediateJobPriority_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   430      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   431  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   433  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   434  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   435  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   436   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   437   * This NvM private function returns the configured block size for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   438   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   439   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   440   * ID of the block for which the configured block size will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   441   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   442   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   443   * Configured block size
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   444   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   445  LOCAL_INLINE uint16 NvM_Prv_GetBlockSize(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   446  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   447      uint16 BlockSize_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   448  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   451      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   452          BlockSize_u16 = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   453      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   454  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   455      return BlockSize_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   456  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   457  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   458  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   459   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   460   * This NvM private function returns the configured block management type for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   461   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   462   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   463   * ID of the block for which the configured block management type will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   464   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   465   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   466   * Configured block management type
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   467   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   468  LOCAL_INLINE NvM_BlockManagementType NvM_Prv_GetBlockType(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   469  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   470      NvM_BlockManagementType BlockType = NVM_BLOCK_NATIVE;
	mov	d15,#0
.L211:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
	jge.u	d5,#14,.L13
.L276:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   472      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   473          BlockType = NvM_Prv_BlockDescriptors_acst[idBlock_uo].BlockManagementType_en;
	mul	d15,d5,#48
.L212:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L277:
	addsc.a	a15,a15,d15,#0
.L278:
	ld.w	d15,[a15]40

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
.L13:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   475      return BlockType;      (inlined)
	j	.L14

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   476  }      (inlined)
.L14:

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   108              (NVM_BLOCK_DATASET != NvM_Prv_GetBlockType(JobData_pst->idBlock_uo)))
	jeq	d15,#2,.L15
.L130:

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   109          {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   110              // TRACE[NVM389] Recover an unsuccessful read operation by performing a Restore operation
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   111              //               for all NvM block types
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   112              // TRACE[NVM390] Same as NVM389 but for redundant NvM blocks
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   113              // TRACE[NVM171] Provide implicit recovery to restore data from ROM to RAM if read data is found inconsistent
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   114              // TRACE[NVM388] Same as NVM171 in case of NvM_ReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   115              // TRACE[NVM172] The NV block is not modified during implicit recovery
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   116              // TRACE[NVM657] Load default data if the read request fails in the underlying layers
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   117              //               by doing the same actions as a restore operation
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   118              // TRACE[NVM679] Same as NVM657 applied to NvM_ReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   119              NvM_Prv_StartJob(NvM_Prv_idJob_RestoreForImplicitRecovery_e,
	mov	d4,#10
.L279:

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   120                               JobData_pst->idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   121                               JobData_pst->RamBlock_pu8,
	ld.a	a4,[a12]8
.L280:

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   122                               JobData_pst->idxDataset_u8);
	ld.bu	d6,[a12]12
	call	NvM_Prv_StartJob
.L15:
.L12:
.L7:
.L6:

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   123          }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   124      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   125  }
	ret
.L112:
	
__NvM_Prv_JobComplete_Read_function_end:
	.size	NvM_Prv_JobComplete_Read,__NvM_Prv_JobComplete_Read_function_end-NvM_Prv_JobComplete_Read
.L83:
	; End of function
	
	.sdecl	'.text.NvM_MainfunctionJobComplete.NvM_Prv_JobComplete_Restore',code,cluster('NvM_Prv_JobComplete_Restore')
	.sect	'.text.NvM_MainfunctionJobComplete.NvM_Prv_JobComplete_Restore'
	.align	2
	

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   126  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   127  static void NvM_Prv_JobComplete_Restore(NvM_Prv_JobData_tst* JobData_pst)
; Function NvM_Prv_JobComplete_Restore
.L61:
NvM_Prv_JobComplete_Restore:	.type	func
	mov.aa	a12,a4
.L214:

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   128  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   129      // TRACE[NVM392] Restore job is done without any MemIf interaction
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   130      // TRACE[NVM392] Leave the NV block untouched
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   131      // Determine the source of the block defaults
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   132      if (NULL_PTR != NvM_Prv_GetRomBlockAddress(JobData_pst->idBlock_uo))
	ld.hu	d15,[a12]4
.L139:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   392  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   393   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   394   * This NvM private function checks for the given block whether the configured block length is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   395   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   396   * \param idBlock
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   397   * ID of the block for which the block length will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   398   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   399   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   400   * - TRUE = block length is valid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   401   * - FALSE = block length is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   402   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   403  LOCAL_INLINE boolean NvM_Prv_IsBlockLengthValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   404  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   405      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   406              (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   407              (0u != *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   408  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   409  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   410  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   411   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   412   * This NvM private function checks whether the given block is configured with immediate priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   413   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   414   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   415   * ID of the block for which the priority will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   416   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   417   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   418   * - TRUE = block is configured with immediate priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   419   * - FALSE = block is configured with standard priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   420   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   421  LOCAL_INLINE boolean NvM_Prv_HasBlockImmediateJobPriority(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   423      boolean HasBlockImmediateJobPriority_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   425  #if (NVM_JOB_PRIORITIZATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   426      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   427          (NVM_PRV_JOB_PRIORITY_IMMEDIATE == NvM_Prv_BlockDescriptors_acst[idBlock_uo].JobPriority_u8))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   428      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   429          HasBlockImmediateJobPriority_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   430      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   431  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   433  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   434  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   435  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   436   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   437   * This NvM private function returns the configured block size for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   438   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   439   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   440   * ID of the block for which the configured block size will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   441   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   442   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   443   * Configured block size
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   444   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   445  LOCAL_INLINE uint16 NvM_Prv_GetBlockSize(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   446  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   447      uint16 BlockSize_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   448  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   451      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   452          BlockSize_u16 = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   453      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   454  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   455      return BlockSize_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   456  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   457  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   458  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   459   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   460   * This NvM private function returns the configured block management type for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   461   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   462   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   463   * ID of the block for which the configured block management type will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   464   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   465   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   466   * Configured block management type
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   467   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   468  LOCAL_INLINE NvM_BlockManagementType NvM_Prv_GetBlockType(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   469  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   470      NvM_BlockManagementType BlockType = NVM_BLOCK_NATIVE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   472      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   473          BlockType = NvM_Prv_BlockDescriptors_acst[idBlock_uo].BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   474      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   475      return BlockType;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   476  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   477  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   478  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   479   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   480   * This NvM private function returns the configured number of non-volatile data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   481   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   482   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   483   * ID of the block for which the configured number of non-volatile data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   484   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   485   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   486   * Configured number of non-volatile data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   487   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   488  LOCAL_INLINE uint8 NvM_Prv_GetNrNonVolatileBlocks(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   489  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   490      uint8 nrNvBlocks_u8 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   491      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   492      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   493          nrNvBlocks_u8 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   494      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   495      return nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   496  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   497  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   498  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   499   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   500   * This NvM private function returns the configured overall number of data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   501   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   502   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   503   * ID of the block for which the configured overall number of data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   504   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   505   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   506   * Configured number of data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   507   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   508  LOCAL_INLINE uint16 NvM_Prv_GetNrDataIndexes(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   509  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   510      uint8 nrDataIndexes = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   511      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   512      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   513          nrDataIndexes = (NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8 +
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   514                           NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrRomBlocks_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   515      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   516      return nrDataIndexes;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   517  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   518  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   519  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   520   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   521   * This NvM private function returns the pointer to the configured permanent RAM block for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   522   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   523   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   524   * If no permanent RAM block is configured for a block then this function returns a NULL pointer.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   525   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   526   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   527   * ID of the block for which the pointer to the configured permanent RAM block will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   528   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   529   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   530   * Pointer to the configured permanent RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   531   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   532  LOCAL_INLINE void * NvM_Prv_GetPRamBlockAddress(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   533  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   534      void * PRamBlockAddress_pv = NULL_PTR;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   535      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   536          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   537      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   538          PRamBlockAddress_pv = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   539      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   540  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   541      return PRamBlockAddress_pv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   542  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   543  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   544  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   545   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   546   * This NvM private function returns the pointer to the configured ROM block for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   547   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   548   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   549   * If no ROM block is configured for a block then this function returns a NULL pointer.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   550   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   551   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   552   * ID of the block for which the pointer to the configured ROM block will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   553   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   554   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   555   * Pointer to the configured ROM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   556   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   557  LOCAL_INLINE void const* NvM_Prv_GetRomBlockAddress(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   558  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   559      void const* adrRomBlock_pcv = NULL_PTR;
	mov.a	a2,#0
.L215:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   560      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
	jge.u	d15,#14,.L16
.L285:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   560      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   561      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   562          adrRomBlock_pcv = NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv;
	mul	d15,d15,#48
.L286:
	movh.a	a2,#@his(NvM_Prv_BlockDescriptors_acst)
.L216:
	lea	a2,[a2]@los(NvM_Prv_BlockDescriptors_acst)
.L287:
	addsc.a	a15,a2,d15,#0
.L288:
	ld.a	a2,[a15]16

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   560      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
.L16:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   564      return adrRomBlock_pcv;      (inlined)
	j	.L17

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   565  }      (inlined)
.L17:
	mov.a	a15,#0
.L144:
	jeq.a	a15,a2,.L18
.L145:

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   133      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   134          // A ROM block is configured for this block
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   135          // TRACE[NVM267] Fill the block data buffer with ROM block data
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   136          if (!NvM_Prv_ExplicitSync_IsOngoing())
	call	NvM_Prv_ExplicitSync_IsOngoing
.L213:
	jne	d2,#0,.L19
.L289:

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   137          {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   138              NvM_Prv_CopyBlockDataFromRom(JobData_pst->idBlock_uo,
	ld.hu	d0,[a12]4
.L290:

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   139                                           JobData_pst->RamBlock_pu8,
	ld.a	a4,[a12]8
.L291:

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   140                                           JobData_pst->idxDataset_u8);
	ld.bu	d1,[a12]12
.L149:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   392  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   393   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   394   * This NvM private function checks for the given block whether the configured block length is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   395   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   396   * \param idBlock
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   397   * ID of the block for which the block length will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   398   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   399   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   400   * - TRUE = block length is valid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   401   * - FALSE = block length is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   402   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   403  LOCAL_INLINE boolean NvM_Prv_IsBlockLengthValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   404  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   405      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   406              (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   407              (0u != *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   408  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   409  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   410  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   411   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   412   * This NvM private function checks whether the given block is configured with immediate priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   413   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   414   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   415   * ID of the block for which the priority will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   416   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   417   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   418   * - TRUE = block is configured with immediate priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   419   * - FALSE = block is configured with standard priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   420   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   421  LOCAL_INLINE boolean NvM_Prv_HasBlockImmediateJobPriority(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   423      boolean HasBlockImmediateJobPriority_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   425  #if (NVM_JOB_PRIORITIZATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   426      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   427          (NVM_PRV_JOB_PRIORITY_IMMEDIATE == NvM_Prv_BlockDescriptors_acst[idBlock_uo].JobPriority_u8))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   428      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   429          HasBlockImmediateJobPriority_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   430      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   431  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   433  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   434  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   435  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   436   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   437   * This NvM private function returns the configured block size for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   438   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   439   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   440   * ID of the block for which the configured block size will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   441   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   442   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   443   * Configured block size
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   444   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   445  LOCAL_INLINE uint16 NvM_Prv_GetBlockSize(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   446  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   447      uint16 BlockSize_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   448  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   451      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   452          BlockSize_u16 = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   453      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   454  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   455      return BlockSize_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   456  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   457  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   458  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   459   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   460   * This NvM private function returns the configured block management type for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   461   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   462   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   463   * ID of the block for which the configured block management type will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   464   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   465   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   466   * Configured block management type
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   467   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   468  LOCAL_INLINE NvM_BlockManagementType NvM_Prv_GetBlockType(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   469  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   470      NvM_BlockManagementType BlockType = NVM_BLOCK_NATIVE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   472      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   473          BlockType = NvM_Prv_BlockDescriptors_acst[idBlock_uo].BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   474      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   475      return BlockType;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   476  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   477  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   478  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   479   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   480   * This NvM private function returns the configured number of non-volatile data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   481   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   482   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   483   * ID of the block for which the configured number of non-volatile data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   484   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   485   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   486   * Configured number of non-volatile data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   487   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   488  LOCAL_INLINE uint8 NvM_Prv_GetNrNonVolatileBlocks(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   489  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   490      uint8 nrNvBlocks_u8 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   491      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   492      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   493          nrNvBlocks_u8 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   494      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   495      return nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   496  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   497  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   498  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   499   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   500   * This NvM private function returns the configured overall number of data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   501   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   502   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   503   * ID of the block for which the configured overall number of data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   504   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   505   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   506   * Configured number of data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   507   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   508  LOCAL_INLINE uint16 NvM_Prv_GetNrDataIndexes(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   509  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   510      uint8 nrDataIndexes = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   511      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   512      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   513          nrDataIndexes = (NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8 +
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   514                           NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrRomBlocks_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   515      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   516      return nrDataIndexes;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   517  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   518  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   519  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   520   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   521   * This NvM private function returns the pointer to the configured permanent RAM block for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   522   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   523   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   524   * If no permanent RAM block is configured for a block then this function returns a NULL pointer.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   525   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   526   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   527   * ID of the block for which the pointer to the configured permanent RAM block will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   528   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   529   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   530   * Pointer to the configured permanent RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   531   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   532  LOCAL_INLINE void * NvM_Prv_GetPRamBlockAddress(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   533  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   534      void * PRamBlockAddress_pv = NULL_PTR;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   535      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   536          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   537      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   538          PRamBlockAddress_pv = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   539      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   540  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   541      return PRamBlockAddress_pv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   542  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   543  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   544  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   545   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   546   * This NvM private function returns the pointer to the configured ROM block for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   547   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   548   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   549   * If no ROM block is configured for a block then this function returns a NULL pointer.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   550   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   551   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   552   * ID of the block for which the pointer to the configured ROM block will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   553   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   554   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   555   * Pointer to the configured ROM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   556   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   557  LOCAL_INLINE void const* NvM_Prv_GetRomBlockAddress(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   558  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   559      void const* adrRomBlock_pcv = NULL_PTR;
	mov.a	a5,#0
.L217:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   560      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
	jge.u	d0,#14,.L20
.L292:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   560      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   561      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   562          adrRomBlock_pcv = NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv;
	mul	d15,d0,#48
.L293:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L294:
	addsc.a	a15,a15,d15,#0
.L295:
	ld.a	a5,[a15]16

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   560      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
.L20:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   564      return adrRomBlock_pcv;      (inlined)
	j	.L21

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   565  }      (inlined)
.L21:
	mov	d2,#0
.L218:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
	jge.u	d0,#14,.L22
.L296:
	mul	d15,d0,#48
.L297:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L298:
	addsc.a	a15,a15,d15,#0
.L299:
	ld.a	a15,[a15]4
.L300:
	mov.a	a2,#0
.L301:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))      (inlined)
	jeq.a	a2,a15,.L23
.L302:
	ld.hu	d2,[a15]0

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
.L23:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))      (inlined)
.L22:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   455      return BlockSize_u16;      (inlined)
	j	.L24

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   456  }      (inlined)
.L24:
	mov	d3,#0
.L219:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   491      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
	jge.u	d0,#14,.L25
.L303:
	mul	d15,d0,#48
.L304:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L305:
	addsc.a	a15,a15,d15,#0
.L306:
	ld.bu	d3,[a15]9

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   491      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
.L25:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   495      return nrNvBlocks_u8;      (inlined)
	j	.L26

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   496  }      (inlined)
.L26:
	mov	d15,#0
.L220:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
	jge.u	d0,#14,.L27
.L307:
	mul	d15,d0,#48
.L221:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L308:
	addsc.a	a15,a15,d15,#0
.L309:
	ld.w	d15,[a15]40

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
.L27:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   475      return BlockType;      (inlined)
	j	.L28

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   476  }      (inlined)
.L28:

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   286      if (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo))      (inlined)
	jne	d15,#2,.L29
.L180:

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   141          }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   142  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   143          // Copy data into the RAM block for explicit sync because data was restored from ROM
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   144          // trigger the read callback for explicit synchronization
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   145          JobData_pst->Result_en = NvM_Prv_ExplicitSync_CopyData(NvM_Prv_GetCopyFctForRead(JobData_pst->idBlock_uo),
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   146                                                                 JobData_pst->idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   147      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   148      else
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   149      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   150          // data was not restored from ROM -> restore data by calling the InitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   151          // InitBlockCallback shall be called only if available and only for non-auxiliary services
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   152          if (!NvM_Prv_IsAuxServiceActive())
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   153          {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   154              // Invoke the init block callback
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   155              if (E_OK == NvM_Prv_InvokeInitBlockCallback(JobData_pst->idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   156              {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   157                  JobData_pst->Result_en = MEMIF_JOB_OK;
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   158              }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   159              else
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   160              {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   161                  JobData_pst->Result_en = MEMIF_JOB_FAILED;
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   162              }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   163          }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   164      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   165  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   166      if (MEMIF_JOB_OK == JobData_pst->Result_en)
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   167      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   168          // Check if the restore job succeeded, which is the case if
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   169          // - the copy operation from ROM to RAM was successful or
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   170          // - the Init-Callback was successful
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   171          // Notes:
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   172          // - A finally failed explicit sync read callback sets the job result to MEMIF_JOB_FAILED,
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   173          //   so we neither trigger an init block callback nor a write job in this case
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   174          // - The init block callback doesn't need to be prohibited for jobs triggered by an auxiliary user here
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   175          //   because we only come here if the current service is FirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   176          if (NVM_SERVICE_ID_RB_FIRST_INIT_ALL == NvM_Prv_GetActiveService())
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   177          {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   178              // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2834] If this restore job was part of a first initialization,
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   179              //                                               trigger a write job
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   180              NvM_Prv_StartJob(NvM_Prv_idJob_Write_e,
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   181                               JobData_pst->idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   182                               JobData_pst->RamBlock_pu8,
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   183                               JobData_pst->idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   184          }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   185      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   186  }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   187  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   188  static void NvM_Prv_JobComplete_InvalidateAllDatasets(NvM_Prv_JobData_tst* JobData_pst)
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   189  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   190      // check whether MemIf has finished the invalidate job successfully
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   191      if (MEMIF_JOB_OK == JobData_pst->Result_en)
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   192      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   193          // Check whether the next DATASET block needs to be invalidated
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   194          // -> if so, advance the current dataset index to the next DATASET instance and start another invalidation
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   195          // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2850] Invalidate all the NV blocks of an NvM block of type DATASET
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   196          //                                               which is selected for FirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   197          // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2852] Remove all the NV blocks of a non-resistant NvM block
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   198          //                                               of type DATASET during the removal phase
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   199          if ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(JobData_pst->idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   200              (JobData_pst->idxDataset_u8 < (NvM_Prv_GetNrNonVolatileBlocks(JobData_pst->idBlock_uo) - 1)))
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   201          {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   202              if (NVM_SERVICE_ID_RB_FIRST_INIT_ALL == NvM_Prv_GetActiveService())
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   203              {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   204                  NvM_Prv_StartJob(NvM_Prv_idJob_InvalidateForFirstInitAll_e,
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   205                                   JobData_pst->idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   206                                   JobData_pst->RamBlock_pu8,
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   207                                   JobData_pst->idxDataset_u8 + 1);
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   208              }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   209              else
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   210              {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   211                  NvM_Prv_StartJob(NvM_Prv_idJob_InvalidateForRemoveNonResistant_e,
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   212                                   JobData_pst->idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   213                                   JobData_pst->RamBlock_pu8,
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   214                                   JobData_pst->idxDataset_u8 + 1);
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   215              }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   216          }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   217      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   218  }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   219  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   220  static void NvM_Prv_JobComplete_Validate(NvM_Prv_JobData_tst* JobData_pst)
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   221  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   222      // Note: Setting the job result to MEMIF_JOB_OK is done to simplify implementation.
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   223      //       MemIf is not required for an auto validation operation.
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   224      // The actual auto validation operation is done during result evaluation
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   225      JobData_pst->Result_en = MEMIF_JOB_OK;
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   226  }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   227  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   228  static NvM_Prv_JobComplete_tpfct NvM_Prv_GetFctJobComplete(NvM_Prv_idJob_ten idJob_en)
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   229  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   230      if (idJob_en >= NvM_Prv_idJob_Count_e)
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   231      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   232          idJob_en = NvM_Prv_idJob_Invalid_e;
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   233      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   234      return NvM_Prv_JobCompleteFcts_capfct[idJob_en];
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   235  }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   236  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   237  void NvM_Prv_MainFunctionJobComplete(void)
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   238  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   239  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   240      NvM_BlockIdType idBlock_uo = NvM_Prv_Main_st.QueueEntry_pst->idBlock_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   241  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   242      if (NvM_Prv_ErrorDetection_IsJobIdValid(NVM_SERVICE_ID_MAIN_FUNCTION,
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   243                                              idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   244                                              NvM_Prv_Main_st.JobData_st.idJob_en))
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   245      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   246          NvM_Prv_JobComplete_tpfct JobComplete_pfct = NvM_Prv_GetFctJobComplete(NvM_Prv_Main_st.JobData_st.idJob_en);
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   247          if (NULL_PTR != JobComplete_pfct)
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   248          {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   249              JobComplete_pfct(&NvM_Prv_Main_st.JobData_st);
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   250          }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   251      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   252      else
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   253      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   254          // This function may only be called with a known NvM_Prv_Main_st.idActiveJob_rMwM_en
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   255          // (we should actually never get into this branch; it's just there for robustness)
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   256          NvM_Prv_Main_st.JobData_st.Result_en = MEMIF_JOB_FAILED;
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   257      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   258  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   259      // Determine the next state depending on the job start result
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   260      if (MEMIF_JOB_PENDING != NvM_Prv_Main_st.JobData_st.Result_en)
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   261      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   262          // Polling needed
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   263          NvM_Prv_Main_st.Activity_rAMwM_en = NVM_PRV_ACTIVITY_RESULT_EVAL;
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   264      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   265  }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   266  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   267  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   268  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   269  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   270  /*
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   271   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   272   * Inline code
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   273   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   274   */
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   275  LOCAL_INLINE void NvM_Prv_CopyBlockDataFromRom(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   276                                                 uint8* RamBlock_pu8,
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   277                                                 uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   278  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   279      // A ROM block is configured for this block
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   280      // TRACE[NVM267] Fill the block data buffer with ROM block data
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   281      /* MR12 RULE 11.5 VIOLATION: The actual type of the ROM block varies from block to block (not under control of NvM) */
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   282      uint8 const* adrSource_pcu8 = (uint8 const*)NvM_Prv_GetRomBlockAddress(idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   283      uint16 nrRemainingBlockBytes_u16 = NvM_Prv_GetBlockSize(idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   284      uint8 nrNonVolatileBlocks_u8 = NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   285  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   286      if (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   287      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   288          // This DATASET block has its dataset-index pointing to a ROM block
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   289          // (otherwise it wouldn't have been queued by NvM_RestoreBlockDefaults or by NvM_ReadBlock)
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   290          // -> Move the source pointer to the start address of the indexed ROM block
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   291          adrSource_pcu8 += nrRemainingBlockBytes_u16 * (idxDataset_u8 - nrNonVolatileBlocks_u8);
	sub	d1,d3
.L173:
	mul	d1,d2
.L163:
	addsc.a	a5,a5,d1,#0

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   286      if (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo))      (inlined)
.L29:

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   295      while (nrRemainingBlockBytes_u16 > 0)      (inlined)
	j	.L30
.L31:

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   292      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   293  
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   294      // Perform the restore job by copying data from the ROM-block to the RAM-block
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   295      while (nrRemainingBlockBytes_u16 > 0)
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   296      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   297          *RamBlock_pu8 = *adrSource_pcu8;
	ld.bu	d15,[a5]
.L164:
	st.b	[a4],d15
.L310:

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   298          ++RamBlock_pu8;
	add.a	a4,#1
.L165:

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   299          ++adrSource_pcu8;
	add.a	a5,#1
.L166:

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   300          --nrRemainingBlockBytes_u16;
	add	d2,#-1

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   295      while (nrRemainingBlockBytes_u16 > 0)      (inlined)
.L30:
	jne	d2,#0,.L31
.L19:
	ld.hu	d4,[a12]4
.L184:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   392  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   393   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   394   * This NvM private function checks for the given block whether the configured block length is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   395   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   396   * \param idBlock
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   397   * ID of the block for which the block length will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   398   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   399   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   400   * - TRUE = block length is valid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   401   * - FALSE = block length is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   402   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   403  LOCAL_INLINE boolean NvM_Prv_IsBlockLengthValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   404  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   405      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   406              (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   407              (0u != *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   408  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   409  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   410  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   411   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   412   * This NvM private function checks whether the given block is configured with immediate priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   413   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   414   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   415   * ID of the block for which the priority will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   416   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   417   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   418   * - TRUE = block is configured with immediate priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   419   * - FALSE = block is configured with standard priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   420   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   421  LOCAL_INLINE boolean NvM_Prv_HasBlockImmediateJobPriority(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   423      boolean HasBlockImmediateJobPriority_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   425  #if (NVM_JOB_PRIORITIZATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   426      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   427          (NVM_PRV_JOB_PRIORITY_IMMEDIATE == NvM_Prv_BlockDescriptors_acst[idBlock_uo].JobPriority_u8))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   428      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   429          HasBlockImmediateJobPriority_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   430      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   431  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   433  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   434  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   435  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   436   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   437   * This NvM private function returns the configured block size for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   438   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   439   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   440   * ID of the block for which the configured block size will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   441   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   442   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   443   * Configured block size
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   444   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   445  LOCAL_INLINE uint16 NvM_Prv_GetBlockSize(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   446  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   447      uint16 BlockSize_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   448  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   451      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   452          BlockSize_u16 = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   453      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   454  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   455      return BlockSize_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   456  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   457  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   458  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   459   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   460   * This NvM private function returns the configured block management type for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   461   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   462   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   463   * ID of the block for which the configured block management type will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   464   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   465   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   466   * Configured block management type
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   467   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   468  LOCAL_INLINE NvM_BlockManagementType NvM_Prv_GetBlockType(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   469  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   470      NvM_BlockManagementType BlockType = NVM_BLOCK_NATIVE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   472      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   473          BlockType = NvM_Prv_BlockDescriptors_acst[idBlock_uo].BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   474      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   475      return BlockType;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   476  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   477  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   478  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   479   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   480   * This NvM private function returns the configured number of non-volatile data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   481   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   482   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   483   * ID of the block for which the configured number of non-volatile data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   484   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   485   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   486   * Configured number of non-volatile data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   487   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   488  LOCAL_INLINE uint8 NvM_Prv_GetNrNonVolatileBlocks(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   489  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   490      uint8 nrNvBlocks_u8 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   491      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   492      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   493          nrNvBlocks_u8 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   494      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   495      return nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   496  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   497  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   498  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   499   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   500   * This NvM private function returns the configured overall number of data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   501   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   502   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   503   * ID of the block for which the configured overall number of data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   504   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   505   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   506   * Configured number of data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   507   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   508  LOCAL_INLINE uint16 NvM_Prv_GetNrDataIndexes(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   509  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   510      uint8 nrDataIndexes = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   511      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   512      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   513          nrDataIndexes = (NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8 +
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   514                           NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrRomBlocks_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   515      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   516      return nrDataIndexes;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   517  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   518  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   519  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   520   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   521   * This NvM private function returns the pointer to the configured permanent RAM block for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   522   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   523   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   524   * If no permanent RAM block is configured for a block then this function returns a NULL pointer.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   525   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   526   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   527   * ID of the block for which the pointer to the configured permanent RAM block will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   528   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   529   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   530   * Pointer to the configured permanent RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   531   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   532  LOCAL_INLINE void * NvM_Prv_GetPRamBlockAddress(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   533  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   534      void * PRamBlockAddress_pv = NULL_PTR;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   535      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   536          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   537      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   538          PRamBlockAddress_pv = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   539      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   540  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   541      return PRamBlockAddress_pv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   542  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   543  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   544  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   545   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   546   * This NvM private function returns the pointer to the configured ROM block for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   547   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   548   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   549   * If no ROM block is configured for a block then this function returns a NULL pointer.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   550   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   551   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   552   * ID of the block for which the pointer to the configured ROM block will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   553   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   554   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   555   * Pointer to the configured ROM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   556   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   557  LOCAL_INLINE void const* NvM_Prv_GetRomBlockAddress(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   558  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   559      void const* adrRomBlock_pcv = NULL_PTR;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   560      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   561      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   562          adrRomBlock_pcv = NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   563      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   564      return adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   565  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   566  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   567  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   568   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   569   * This NvM private function returns the configured block ID used by the mem interface for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   570   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   571   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   572   * ID of the block for which the block ID used by the mem interface will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   573   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   574   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   575   * Configured block ID used by the mem interface
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   576   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   577  LOCAL_INLINE uint16 NvM_Prv_GetIdBlockMemIf(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   578  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   579      uint16 idBlockMemIf_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   580      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   581      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   582          idBlockMemIf_u16 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   583      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   584      return idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   585  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   586  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   587  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   588   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   589   * This NvM private function returns the configured device index where the given block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   590   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   591   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   592   * ID of the block for which the configured device index will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   593   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   594   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   595   * Configured device index where the given block is located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   596   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   597  LOCAL_INLINE uint8 NvM_Prv_GetIdxDevice(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   598  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   599      uint8 idxDevice_u8 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   600      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   601      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   602          idxDevice_u8 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   603      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   604      return idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   605  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   606  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   607  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   608   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   609   * This NvM private function returns the configured persistent ID of a block identified by index for persistent IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   610   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   611   * \param idxPersistentId_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   612   * Index of the required persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   613   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   614   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   615   * Configured persistent ID of a block identified by index for persistent IDs
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   616   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   617  LOCAL_INLINE uint16 NvM_Prv_GetIdPersistent(uint16 idxPersistentId_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   618  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   619      uint16 PersistentId_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   620      if (idxPersistentId_u16 < NVM_PRV_NR_PERSISTENT_IDS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   621      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   622          PersistentId_u16 = NvM_Prv_PersId_BlockId_acst[idxPersistentId_u16].PersistentId_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   623      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   624      return PersistentId_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   625  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   626  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   627  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   628   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   629   * This NvM private function returns the configured NvM ID of a block identified by index for persistent IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   630   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   631   * \param idxPersistentId_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   632   * Index of the required persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   633   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   634   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   635   * Configured NvM ID of a block identified by index for persistent IDs
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   636   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   637  LOCAL_INLINE NvM_BlockIdType NvM_Prv_GetIdBlock(uint16 idxPersistentId_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   638  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   639      uint16 BlockId_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   640      if (idxPersistentId_u16 < NVM_PRV_NR_PERSISTENT_IDS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   641      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   642          BlockId_u16 = NvM_Prv_PersId_BlockId_acst[idxPersistentId_u16].BlockId_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   643      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   644      return BlockId_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   645  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   646  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   647  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   648   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   649   * This NvM private function returns the configured pointer to the block specific callback function
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   650   * to copy data from the NvM mirror to the application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   651   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   652   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   653   * ID of the block for which the configured copy function will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   654   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   655   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   656   * Configured pointer to the copy function
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   657   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   658  LOCAL_INLINE NvM_Prv_ExplicitSync_Copy_tpfct NvM_Prv_GetCopyFctForRead(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   659  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   660      NvM_Prv_ExplicitSync_Copy_tpfct ReadRamBlockFromNvm_pfct = NULL_PTR;
	mov.a	a4,#0
.L222:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   661      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
	jge.u	d4,#14,.L32
.L311:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   661      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   662      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   663          ReadRamBlockFromNvm_pfct = NvM_Prv_BlockDescriptors_acst[idBlock_uo].ReadRamBlockFromNvm_pfct;
	mul	d15,d4,#48
.L312:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L313:
	addsc.a	a15,a15,d15,#0
.L314:
	ld.a	a4,[a15]32

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   661      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
.L32:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   665      return ReadRamBlockFromNvm_pfct;      (inlined)
	j	.L33

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   666  }      (inlined)
.L33:
	call	NvM_Prv_ExplicitSync_CopyData
.L185:
	st.w	[a12]16,d2
.L315:
	j	.L34
.L18:
	call	NvM_Prv_IsAuxServiceActive
.L223:
	jne	d2,#0,.L35
.L316:
	ld.hu	d15,[a12]4
.L189:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   392  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   393   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   394   * This NvM private function checks for the given block whether the configured block length is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   395   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   396   * \param idBlock
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   397   * ID of the block for which the block length will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   398   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   399   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   400   * - TRUE = block length is valid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   401   * - FALSE = block length is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   402   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   403  LOCAL_INLINE boolean NvM_Prv_IsBlockLengthValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   404  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   405      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   406              (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   407              (0u != *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   408  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   409  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   410  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   411   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   412   * This NvM private function checks whether the given block is configured with immediate priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   413   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   414   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   415   * ID of the block for which the priority will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   416   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   417   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   418   * - TRUE = block is configured with immediate priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   419   * - FALSE = block is configured with standard priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   420   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   421  LOCAL_INLINE boolean NvM_Prv_HasBlockImmediateJobPriority(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   423      boolean HasBlockImmediateJobPriority_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   425  #if (NVM_JOB_PRIORITIZATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   426      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   427          (NVM_PRV_JOB_PRIORITY_IMMEDIATE == NvM_Prv_BlockDescriptors_acst[idBlock_uo].JobPriority_u8))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   428      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   429          HasBlockImmediateJobPriority_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   430      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   431  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   433  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   434  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   435  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   436   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   437   * This NvM private function returns the configured block size for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   438   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   439   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   440   * ID of the block for which the configured block size will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   441   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   442   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   443   * Configured block size
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   444   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   445  LOCAL_INLINE uint16 NvM_Prv_GetBlockSize(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   446  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   447      uint16 BlockSize_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   448  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   451      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   452          BlockSize_u16 = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   453      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   454  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   455      return BlockSize_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   456  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   457  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   458  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   459   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   460   * This NvM private function returns the configured block management type for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   461   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   462   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   463   * ID of the block for which the configured block management type will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   464   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   465   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   466   * Configured block management type
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   467   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   468  LOCAL_INLINE NvM_BlockManagementType NvM_Prv_GetBlockType(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   469  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   470      NvM_BlockManagementType BlockType = NVM_BLOCK_NATIVE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   472      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   473          BlockType = NvM_Prv_BlockDescriptors_acst[idBlock_uo].BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   474      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   475      return BlockType;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   476  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   477  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   478  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   479   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   480   * This NvM private function returns the configured number of non-volatile data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   481   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   482   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   483   * ID of the block for which the configured number of non-volatile data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   484   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   485   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   486   * Configured number of non-volatile data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   487   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   488  LOCAL_INLINE uint8 NvM_Prv_GetNrNonVolatileBlocks(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   489  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   490      uint8 nrNvBlocks_u8 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   491      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   492      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   493          nrNvBlocks_u8 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   494      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   495      return nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   496  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   497  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   498  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   499   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   500   * This NvM private function returns the configured overall number of data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   501   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   502   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   503   * ID of the block for which the configured overall number of data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   504   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   505   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   506   * Configured number of data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   507   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   508  LOCAL_INLINE uint16 NvM_Prv_GetNrDataIndexes(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   509  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   510      uint8 nrDataIndexes = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   511      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   512      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   513          nrDataIndexes = (NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8 +
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   514                           NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrRomBlocks_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   515      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   516      return nrDataIndexes;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   517  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   518  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   519  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   520   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   521   * This NvM private function returns the pointer to the configured permanent RAM block for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   522   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   523   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   524   * If no permanent RAM block is configured for a block then this function returns a NULL pointer.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   525   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   526   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   527   * ID of the block for which the pointer to the configured permanent RAM block will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   528   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   529   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   530   * Pointer to the configured permanent RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   531   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   532  LOCAL_INLINE void * NvM_Prv_GetPRamBlockAddress(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   533  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   534      void * PRamBlockAddress_pv = NULL_PTR;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   535      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   536          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   537      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   538          PRamBlockAddress_pv = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   539      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   540  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   541      return PRamBlockAddress_pv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   542  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   543  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   544  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   545   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   546   * This NvM private function returns the pointer to the configured ROM block for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   547   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   548   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   549   * If no ROM block is configured for a block then this function returns a NULL pointer.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   550   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   551   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   552   * ID of the block for which the pointer to the configured ROM block will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   553   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   554   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   555   * Pointer to the configured ROM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   556   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   557  LOCAL_INLINE void const* NvM_Prv_GetRomBlockAddress(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   558  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   559      void const* adrRomBlock_pcv = NULL_PTR;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   560      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   561      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   562          adrRomBlock_pcv = NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   563      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   564      return adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   565  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   566  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   567  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   568   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   569   * This NvM private function returns the configured block ID used by the mem interface for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   570   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   571   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   572   * ID of the block for which the block ID used by the mem interface will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   573   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   574   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   575   * Configured block ID used by the mem interface
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   576   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   577  LOCAL_INLINE uint16 NvM_Prv_GetIdBlockMemIf(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   578  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   579      uint16 idBlockMemIf_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   580      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   581      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   582          idBlockMemIf_u16 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   583      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   584      return idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   585  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   586  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   587  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   588   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   589   * This NvM private function returns the configured device index where the given block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   590   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   591   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   592   * ID of the block for which the configured device index will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   593   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   594   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   595   * Configured device index where the given block is located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   596   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   597  LOCAL_INLINE uint8 NvM_Prv_GetIdxDevice(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   598  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   599      uint8 idxDevice_u8 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   600      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   601      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   602          idxDevice_u8 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   603      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   604      return idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   605  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   606  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   607  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   608   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   609   * This NvM private function returns the configured persistent ID of a block identified by index for persistent IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   610   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   611   * \param idxPersistentId_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   612   * Index of the required persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   613   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   614   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   615   * Configured persistent ID of a block identified by index for persistent IDs
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   616   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   617  LOCAL_INLINE uint16 NvM_Prv_GetIdPersistent(uint16 idxPersistentId_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   618  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   619      uint16 PersistentId_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   620      if (idxPersistentId_u16 < NVM_PRV_NR_PERSISTENT_IDS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   621      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   622          PersistentId_u16 = NvM_Prv_PersId_BlockId_acst[idxPersistentId_u16].PersistentId_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   623      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   624      return PersistentId_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   625  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   626  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   627  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   628   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   629   * This NvM private function returns the configured NvM ID of a block identified by index for persistent IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   630   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   631   * \param idxPersistentId_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   632   * Index of the required persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   633   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   634   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   635   * Configured NvM ID of a block identified by index for persistent IDs
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   636   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   637  LOCAL_INLINE NvM_BlockIdType NvM_Prv_GetIdBlock(uint16 idxPersistentId_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   638  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   639      uint16 BlockId_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   640      if (idxPersistentId_u16 < NVM_PRV_NR_PERSISTENT_IDS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   641      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   642          BlockId_u16 = NvM_Prv_PersId_BlockId_acst[idxPersistentId_u16].BlockId_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   643      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   644      return BlockId_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   645  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   646  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   647  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   648   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   649   * This NvM private function returns the configured pointer to the block specific callback function
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   650   * to copy data from the NvM mirror to the application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   651   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   652   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   653   * ID of the block for which the configured copy function will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   654   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   655   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   656   * Configured pointer to the copy function
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   657   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   658  LOCAL_INLINE NvM_Prv_ExplicitSync_Copy_tpfct NvM_Prv_GetCopyFctForRead(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   659  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   660      NvM_Prv_ExplicitSync_Copy_tpfct ReadRamBlockFromNvm_pfct = NULL_PTR;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   661      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   662      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   663          ReadRamBlockFromNvm_pfct = NvM_Prv_BlockDescriptors_acst[idBlock_uo].ReadRamBlockFromNvm_pfct;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   664      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   665      return ReadRamBlockFromNvm_pfct;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   666  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   667  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   668  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   669   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   670   * This NvM private function returns the configured pointer to the block specific callback function
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   671   * to copy data from the application's RAM block to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   672   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   673   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   674   * ID of the block for which the configured copy function will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   675   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   676   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   677   * Configured pointer to the copy function
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   678   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   679  LOCAL_INLINE NvM_Prv_ExplicitSync_Copy_tpfct NvM_Prv_GetCopyFctForWrite(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   680  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   681      NvM_Prv_ExplicitSync_Copy_tpfct WriteRamBlockToNvm_pfct = NULL_PTR;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   682      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   683      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   684          WriteRamBlockToNvm_pfct = NvM_Prv_BlockDescriptors_acst[idBlock_uo].WriteRamBlockToNvm_pfct;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   685      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   686      return WriteRamBlockToNvm_pfct;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   687  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   688  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   689  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   690   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   691   * This NvM private function returns the configured block specific initializaton callback function.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   692   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   693   * If no initializaton callback function is configured for the passed block then this function does nothing and
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   694   * returns E_NOT_OK.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   695   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   696   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   697   * ID of the block for which the configured initialization callback function will be invoked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   698   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   699   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   700   * E_OK = initialization callback function is configured and has returned E_OK
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   701   * E_NOT_OK = no initialization callback function is configured or has returned E_NOT_OK
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   702   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   703  LOCAL_INLINE Std_ReturnType NvM_Prv_InvokeInitBlockCallback(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   704  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   705      Std_ReturnType RetValue = E_NOT_OK;
	mov	d2,#1
.L224:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   706      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
	jge.u	d15,#14,.L36
.L317:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   706      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   707          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct))
	mul	d15,d15,#48
.L318:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L319:
	addsc.a	a15,a15,d15,#0
.L320:
	ld.a	a15,[a15]28
.L321:
	mov.a	a2,#0
.L322:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   707          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct))      (inlined)
	jeq.a	a2,a15,.L37
.L323:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   708      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   709          RetValue = NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct();
	calli	a15

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   706      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
.L37:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   707          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct))      (inlined)
.L36:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   711      return RetValue;      (inlined)
	j	.L38

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   712  }      (inlined)
.L38:
	jne	d2,#0,.L39
.L324:
	mov	d15,#0
.L325:
	st.w	[a12]16,d15
.L326:
	j	.L40
.L39:
	mov	d15,#1
.L327:
	st.w	[a12]16,d15
.L40:
.L35:
.L34:
	ld.w	d15,[a12]16
.L328:
	jne	d15,#0,.L41
.L329:
	call	NvM_Prv_GetActiveService
.L330:
	mov	d15,#251
.L331:
	jne	d15,d2,.L42
.L332:
	mov	d4,#2
.L333:
	ld.hu	d5,[a12]4
.L334:
	ld.a	a4,[a12]8
.L335:
	ld.bu	d6,[a12]12
	call	NvM_Prv_StartJob
.L42:
.L41:
	ret
.L136:
	
__NvM_Prv_JobComplete_Restore_function_end:
	.size	NvM_Prv_JobComplete_Restore,__NvM_Prv_JobComplete_Restore_function_end-NvM_Prv_JobComplete_Restore
.L88:
	; End of function
	
	.sdecl	'.text.NvM_MainfunctionJobComplete.NvM_Prv_JobComplete_InvalidateAllDatasets',code,cluster('NvM_Prv_JobComplete_InvalidateAllDatasets')
	.sect	'.text.NvM_MainfunctionJobComplete.NvM_Prv_JobComplete_InvalidateAllDatasets'
	.align	2
	
; Function NvM_Prv_JobComplete_InvalidateAllDatasets
.L63:
NvM_Prv_JobComplete_InvalidateAllDatasets:	.type	func
	mov.aa	a15,a4
.L226:
	ld.w	d15,[a15]16
.L340:
	jne	d15,#0,.L43
.L341:
	ld.hu	d0,[a15]4
.L196:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   392  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   393   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   394   * This NvM private function checks for the given block whether the configured block length is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   395   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   396   * \param idBlock
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   397   * ID of the block for which the block length will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   398   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   399   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   400   * - TRUE = block length is valid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   401   * - FALSE = block length is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   402   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   403  LOCAL_INLINE boolean NvM_Prv_IsBlockLengthValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   404  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   405      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   406              (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   407              (0u != *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   408  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   409  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   410  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   411   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   412   * This NvM private function checks whether the given block is configured with immediate priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   413   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   414   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   415   * ID of the block for which the priority will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   416   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   417   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   418   * - TRUE = block is configured with immediate priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   419   * - FALSE = block is configured with standard priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   420   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   421  LOCAL_INLINE boolean NvM_Prv_HasBlockImmediateJobPriority(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   423      boolean HasBlockImmediateJobPriority_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   425  #if (NVM_JOB_PRIORITIZATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   426      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   427          (NVM_PRV_JOB_PRIORITY_IMMEDIATE == NvM_Prv_BlockDescriptors_acst[idBlock_uo].JobPriority_u8))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   428      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   429          HasBlockImmediateJobPriority_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   430      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   431  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   433  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   434  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   435  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   436   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   437   * This NvM private function returns the configured block size for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   438   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   439   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   440   * ID of the block for which the configured block size will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   441   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   442   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   443   * Configured block size
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   444   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   445  LOCAL_INLINE uint16 NvM_Prv_GetBlockSize(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   446  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   447      uint16 BlockSize_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   448  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   451      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   452          BlockSize_u16 = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   453      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   454  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   455      return BlockSize_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   456  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   457  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   458  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   459   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   460   * This NvM private function returns the configured block management type for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   461   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   462   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   463   * ID of the block for which the configured block management type will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   464   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   465   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   466   * Configured block management type
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   467   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   468  LOCAL_INLINE NvM_BlockManagementType NvM_Prv_GetBlockType(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   469  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   470      NvM_BlockManagementType BlockType = NVM_BLOCK_NATIVE;
	mov	d15,#0
.L227:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
	jge.u	d0,#14,.L44
.L342:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   472      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   473          BlockType = NvM_Prv_BlockDescriptors_acst[idBlock_uo].BlockManagementType_en;
	mul	d15,d0,#48
.L228:
	movh.a	a2,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a2,[a2]@los(NvM_Prv_BlockDescriptors_acst)
.L343:
	addsc.a	a2,a2,d15,#0
.L344:
	ld.w	d15,[a2]40

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
.L44:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   475      return BlockType;      (inlined)
	j	.L45

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   476  }      (inlined)
.L45:
	jne	d15,#2,.L46
.L197:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   392  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   393   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   394   * This NvM private function checks for the given block whether the configured block length is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   395   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   396   * \param idBlock
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   397   * ID of the block for which the block length will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   398   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   399   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   400   * - TRUE = block length is valid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   401   * - FALSE = block length is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   402   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   403  LOCAL_INLINE boolean NvM_Prv_IsBlockLengthValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   404  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   405      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   406              (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   407              (0u != *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   408  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   409  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   410  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   411   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   412   * This NvM private function checks whether the given block is configured with immediate priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   413   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   414   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   415   * ID of the block for which the priority will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   416   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   417   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   418   * - TRUE = block is configured with immediate priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   419   * - FALSE = block is configured with standard priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   420   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   421  LOCAL_INLINE boolean NvM_Prv_HasBlockImmediateJobPriority(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   423      boolean HasBlockImmediateJobPriority_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   425  #if (NVM_JOB_PRIORITIZATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   426      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   427          (NVM_PRV_JOB_PRIORITY_IMMEDIATE == NvM_Prv_BlockDescriptors_acst[idBlock_uo].JobPriority_u8))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   428      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   429          HasBlockImmediateJobPriority_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   430      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   431  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   433  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   434  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   435  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   436   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   437   * This NvM private function returns the configured block size for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   438   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   439   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   440   * ID of the block for which the configured block size will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   441   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   442   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   443   * Configured block size
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   444   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   445  LOCAL_INLINE uint16 NvM_Prv_GetBlockSize(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   446  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   447      uint16 BlockSize_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   448  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   451      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   452          BlockSize_u16 = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   453      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   454  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   455      return BlockSize_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   456  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   457  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   458  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   459   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   460   * This NvM private function returns the configured block management type for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   461   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   462   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   463   * ID of the block for which the configured block management type will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   464   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   465   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   466   * Configured block management type
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   467   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   468  LOCAL_INLINE NvM_BlockManagementType NvM_Prv_GetBlockType(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   469  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   470      NvM_BlockManagementType BlockType = NVM_BLOCK_NATIVE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   472      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   473          BlockType = NvM_Prv_BlockDescriptors_acst[idBlock_uo].BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   474      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   475      return BlockType;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   476  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   477  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   478  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   479   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   480   * This NvM private function returns the configured number of non-volatile data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   481   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   482   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   483   * ID of the block for which the configured number of non-volatile data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   484   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   485   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   486   * Configured number of non-volatile data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   487   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   488  LOCAL_INLINE uint8 NvM_Prv_GetNrNonVolatileBlocks(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   489  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   490      uint8 nrNvBlocks_u8 = 0;
	mov	d15,#0
.L229:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   491      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
	jge.u	d0,#14,.L47
.L345:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   491      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   492      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   493          nrNvBlocks_u8 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8;
	mul	d15,d0,#48
.L230:
	movh.a	a2,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a2,[a2]@los(NvM_Prv_BlockDescriptors_acst)
.L346:
	addsc.a	a2,a2,d15,#0
.L347:
	ld.bu	d15,[a2]9

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   491      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
.L47:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   495      return nrNvBlocks_u8;      (inlined)
	j	.L48

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   496  }      (inlined)
.L48:
	ld.bu	d0,[a15]12
.L348:
	add	d15,#-1
.L231:
	jge	d0,d15,.L49
.L349:
	call	NvM_Prv_GetActiveService
.L225:
	mov	d15,#251
.L350:
	jne	d15,d2,.L50
.L351:
	ld.hu	d5,[a15]4
.L352:
	mov	d4,#9
.L353:
	ld.a	a4,[a15]8
.L354:
	ld.bu	d15,[a15]12
.L355:
	add	d15,#1
	extr.u	d6,d15,#0,#8
	call	NvM_Prv_StartJob
.L356:
	j	.L51
.L50:
	ld.hu	d5,[a15]4
.L357:
	mov	d4,#11
.L358:
	ld.a	a4,[a15]8
.L359:
	ld.bu	d15,[a15]12
.L360:
	add	d15,#1
	extr.u	d6,d15,#0,#8
	call	NvM_Prv_StartJob
.L51:
.L49:
.L46:
.L43:
	ret
.L194:
	
__NvM_Prv_JobComplete_InvalidateAllDatasets_function_end:
	.size	NvM_Prv_JobComplete_InvalidateAllDatasets,__NvM_Prv_JobComplete_InvalidateAllDatasets_function_end-NvM_Prv_JobComplete_InvalidateAllDatasets
.L93:
	; End of function
	
	.sdecl	'.text.NvM_MainfunctionJobComplete.NvM_Prv_JobComplete_Validate',code,cluster('NvM_Prv_JobComplete_Validate')
	.sect	'.text.NvM_MainfunctionJobComplete.NvM_Prv_JobComplete_Validate'
	.align	2
	
; Function NvM_Prv_JobComplete_Validate
.L65:
NvM_Prv_JobComplete_Validate:	.type	func
	mov	d15,#0
.L365:
	st.w	[a4]16,d15
.L366:
	ret
.L202:
	
__NvM_Prv_JobComplete_Validate_function_end:
	.size	NvM_Prv_JobComplete_Validate,__NvM_Prv_JobComplete_Validate_function_end-NvM_Prv_JobComplete_Validate
.L98:
	; End of function
	
	.sdecl	'.text.NvM_MainfunctionJobComplete.NvM_Prv_GetFctJobComplete',code,cluster('NvM_Prv_GetFctJobComplete')
	.sect	'.text.NvM_MainfunctionJobComplete.NvM_Prv_GetFctJobComplete'
	.align	2
	
; Function NvM_Prv_GetFctJobComplete
.L67:
NvM_Prv_GetFctJobComplete:	.type	func
	mov	d15,#13
.L371:
	lt	d15,d4,d15
.L372:
	sel	d4,d15,d4,#12
.L52:
	movh.a	a15,#@his(NvM_Prv_JobCompleteFcts_capfct)
	lea	a15,[a15]@los(NvM_Prv_JobCompleteFcts_capfct)
.L373:
	addsc.a	a15,a15,d4,#2
	ld.a	a2,[a15]
.L374:
	j	.L53
.L53:
	ret
.L204:
	
__NvM_Prv_GetFctJobComplete_function_end:
	.size	NvM_Prv_GetFctJobComplete,__NvM_Prv_GetFctJobComplete_function_end-NvM_Prv_GetFctJobComplete
.L103:
	; End of function
	
	.sdecl	'.text.NvM_MainfunctionJobComplete.NvM_Prv_MainFunctionJobComplete',code,cluster('NvM_Prv_MainFunctionJobComplete')
	.sect	'.text.NvM_MainfunctionJobComplete.NvM_Prv_MainFunctionJobComplete'
	.align	2
	
	.global	NvM_Prv_MainFunctionJobComplete
; Function NvM_Prv_MainFunctionJobComplete
.L69:
NvM_Prv_MainFunctionJobComplete:	.type	func
	movh.a	a15,#@his(NvM_Prv_Main_st)
	lea	a15,[a15]@los(NvM_Prv_Main_st)
.L244:
	ld.a	a2,[a15]8
.L245:
	ld.hu	d5,[a2]2
.L232:
	lea	a12,[a15]28
.L246:
	lea	a13,[a15]12
.L247:
	mov	d4,#14
.L248:
	ld.w	d6,[a13]
	call	NvM_Prv_ErrorDetection_IsJobIdValid
.L233:
	jeq	d2,#0,.L54
.L109:
	ld.w	d4,[a13]
	call	NvM_Prv_GetFctJobComplete
.L234:
	mov.a	a4,#0
.L249:
	jeq.a	a4,a2,.L55
.L250:
	mov.aa	a4,a13
	calli	a2
.L55:
	j	.L56
.L54:
	mov	d15,#1
.L251:
	st.w	[a12],d15
.L56:
	ld.w	d15,[a12]
.L252:
	jeq	d15,#2,.L57
.L253:
	mov	d15,#6
.L254:
	st.w	[a15],d15
.L57:
	ret
.L106:
	
__NvM_Prv_MainFunctionJobComplete_function_end:
	.size	NvM_Prv_MainFunctionJobComplete,__NvM_Prv_MainFunctionJobComplete_function_end-NvM_Prv_MainFunctionJobComplete
.L78:
	; End of function
	
	.sdecl	'.rodata.NvM_MainfunctionJobComplete.NvM_Prv_JobCompleteFcts_capfct',data,rom,cluster('NvM_Prv_JobCompleteFcts_capfct')
	.sect	'.rodata.NvM_MainfunctionJobComplete.NvM_Prv_JobCompleteFcts_capfct'
	.align	4
NvM_Prv_JobCompleteFcts_capfct:	.type	object
	.size	NvM_Prv_JobCompleteFcts_capfct,52
	.space	4
	.word	NvM_Prv_JobComplete_Read
	.space	8
	.word	NvM_Prv_JobComplete_Restore
	.space	4
	.word	NvM_Prv_JobComplete_Validate
	.space	4
	.word	NvM_Prv_JobComplete_Read,NvM_Prv_JobComplete_InvalidateAllDatasets,NvM_Prv_JobComplete_Restore,NvM_Prv_JobComplete_InvalidateAllDatasets
	.space	4
	.calls	'__INDIRECT__','NvM_Prv_JobComplete_Read'
	.calls	'__INDIRECT__','NvM_Prv_JobComplete_Restore'
	.calls	'__INDIRECT__','NvM_Prv_JobComplete_InvalidateAllDatasets'
	.calls	'__INDIRECT__','NvM_Prv_JobComplete_Validate'
	.calls	'NvM_Prv_JobComplete_Read','NvM_Prv_ExplicitSync_CopyData'
	.calls	'NvM_Prv_JobComplete_Read','NvM_Prv_StartJob'
	.calls	'NvM_Prv_JobComplete_Restore','NvM_Prv_ExplicitSync_IsOngoing'
	.calls	'NvM_Prv_JobComplete_Restore','NvM_Prv_ExplicitSync_CopyData'
	.calls	'NvM_Prv_JobComplete_Restore','NvM_Prv_IsAuxServiceActive'
	.calls	'NvM_Prv_JobComplete_Restore','__INDIRECT__'
	.calls	'NvM_Prv_JobComplete_Restore','NvM_Prv_GetActiveService'
	.calls	'NvM_Prv_JobComplete_Restore','NvM_Prv_StartJob'
	.calls	'NvM_Prv_JobComplete_InvalidateAllDatasets','NvM_Prv_GetActiveService'
	.calls	'NvM_Prv_JobComplete_InvalidateAllDatasets','NvM_Prv_StartJob'
	.calls	'NvM_Prv_MainFunctionJobComplete','NvM_Prv_ErrorDetection_IsJobIdValid'
	.calls	'NvM_Prv_MainFunctionJobComplete','NvM_Prv_GetFctJobComplete'
	.calls	'NvM_Prv_MainFunctionJobComplete','__INDIRECT__'
	.calls	'NvM_Prv_JobComplete_Read','',0
	.calls	'NvM_Prv_JobComplete_Restore','',0
	.calls	'NvM_Prv_JobComplete_InvalidateAllDatasets','',0
	.calls	'NvM_Prv_JobComplete_Validate','',0
	.calls	'NvM_Prv_GetFctJobComplete','',0
	.extern	NvM_Prv_Main_st
	.extern	NvM_Prv_GetActiveService
	.extern	NvM_Prv_IsAuxServiceActive
	.extern	NvM_Prv_StartJob
	.extern	NvM_Prv_BlockDescriptors_acst
	.extern	NvM_Prv_ErrorDetection_IsJobIdValid
	.extern	NvM_Prv_ExplicitSync_IsOngoing
	.extern	NvM_Prv_ExplicitSync_CopyData
	.extern	__INDIRECT__
	.calls	'NvM_Prv_MainFunctionJobComplete','',0
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L71:
	.word	13947
	.half	3
	.word	.L72
	.byte	4
.L70:
	.byte	1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainfunctionJobComplete.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L73
.L160:
	.byte	2
	.byte	'unsigned char',0,1,8
.L107:
	.byte	2
	.byte	'unsigned short int',0,2,7
.L123:
	.byte	3
	.byte	'NvM_Prv_IsDefaultDataAvailable',0,3,1,129,3,22
	.word	153
	.byte	1,1
.L126:
	.byte	4
	.byte	'idBlock_uo',0,1,129,3,69
	.word	170
.L128:
	.byte	5,0
.L168:
	.byte	3
	.byte	'NvM_Prv_GetBlockSize',0,3,1,189,3,21
	.word	170
	.byte	1,1
.L169:
	.byte	4
	.byte	'idBlock_uo',0,1,189,3,58
	.word	170
.L171:
	.byte	5,0
.L134:
	.byte	6,2,40,9,4,7
	.byte	'NVM_BLOCK_NATIVE',0,0,7
	.byte	'NVM_BLOCK_REDUNDANT',0,1,7
	.byte	'NVM_BLOCK_DATASET',0,2,0
.L129:
	.byte	3
	.byte	'NvM_Prv_GetBlockType',0,3,1,212,3,38
	.word	312
	.byte	1,1
.L131:
	.byte	4
	.byte	'idBlock_uo',0,1,212,3,75
	.word	170
.L133:
	.byte	5,0
.L175:
	.byte	3
	.byte	'NvM_Prv_GetNrNonVolatileBlocks',0,3,1,232,3,20
	.word	153
	.byte	1,1
.L176:
	.byte	4
	.byte	'idBlock_uo',0,1,232,3,67
	.word	170
.L178:
	.byte	5,0,8
	.byte	'void',0,9
	.word	499
.L146:
	.byte	10
	.word	505
.L138:
	.byte	3
	.byte	'NvM_Prv_GetRomBlockAddress',0,3,1,173,4,26
	.word	510
	.byte	1,1
.L140:
	.byte	4
	.byte	'idBlock_uo',0,1,173,4,69
	.word	170
.L142:
	.byte	5,0,10
	.word	499
	.byte	11
	.word	153
	.byte	1,1,12
	.word	576
	.byte	0,10
	.word	581
.L121:
	.byte	13
	.byte	'NvM_Prv_ExplicitSync_Copy_tpfct',0,1,29,26
	.word	594
.L115:
	.byte	3
	.byte	'NvM_Prv_GetCopyFctForRead',0,3,1,146,5,46
	.word	599
	.byte	1,1
.L118:
	.byte	4
	.byte	'idBlock_uo',0,1,146,5,88
	.word	170
.L120:
	.byte	5,0,10
	.word	581
.L188:
	.byte	3
	.byte	'NvM_Prv_InvokeInitBlockCallback',0,3,1,191,5,29
	.word	153
	.byte	1,1
.L190:
	.byte	4
	.byte	'idBlock_uo',0,1,191,5,77
	.word	170
.L192:
	.byte	5,0,3
	.byte	'NvM_Prv_Block_IsInRom',0,3,3,142,1,22
	.word	153
	.byte	1,1,4
	.byte	'idBlock_uo',0,3,142,1,60
	.word	170
	.byte	4
	.byte	'idxDataset_u8',0,3,142,1,78
	.word	153
	.byte	14,5,5,0,0,3
	.byte	'NvM_Prv_Block_IsWriteProtected',0,3,3,148,1,22
	.word	153
	.byte	1,1,4
	.byte	'idBlock_uo',0,3,148,1,69
	.word	170
	.byte	5,0,10
	.word	153
.L148:
	.byte	15
	.byte	'NvM_Prv_CopyBlockDataFromRom',0,3,4,147,2,19,1,1
.L150:
	.byte	4
	.byte	'idBlock_uo',0,4,147,2,64
	.word	170
.L152:
	.byte	4
	.byte	'RamBlock_pu8',0,4,148,2,55
	.word	917
.L154:
	.byte	4
	.byte	'idxDataset_u8',0,4,149,2,54
	.word	153
.L156:
	.byte	14,5,5,5,5,0,0,16
	.byte	'NvM_Prv_GetActiveService',0,5,101,30
	.word	153
	.byte	1,1,1,1,16
	.byte	'NvM_Prv_IsAuxServiceActive',0,5,104,16
	.word	153
	.byte	1,1,1,1
.L205:
	.byte	6,2,104,9,4,7
	.byte	'NvM_Prv_idJob_Idle_e',0,0,7
	.byte	'NvM_Prv_idJob_Read_e',0,1,7
	.byte	'NvM_Prv_idJob_Write_e',0,2,7
	.byte	'NvM_Prv_idJob_Erase_e',0,3,7
	.byte	'NvM_Prv_idJob_Restore_e',0,4,7
	.byte	'NvM_Prv_idJob_Maintain_e',0,5,7
	.byte	'NvM_Prv_idJob_Validate_e',0,6,7
	.byte	'NvM_Prv_idJob_Invalidate_e',0,7,7
	.byte	'NvM_Prv_idJob_ReadIdConfigForReadAll_e',0,8,7
	.byte	'NvM_Prv_idJob_InvalidateForFirstInitAll_e',0,9,7
	.byte	'NvM_Prv_idJob_RestoreForImplicitRecovery_e',0,10,7
	.byte	'NvM_Prv_idJob_InvalidateForRemoveNonResistant_e',0,11,7
	.byte	'NvM_Prv_idJob_Invalid_e',0,12,7
	.byte	'NvM_Prv_idJob_Count_e',0,13,0,17
	.byte	'NvM_Prv_StartJob',0,5,106,13,1,1,1,1,4
	.byte	'idJob_en',0,5,106,48
	.word	1107
	.byte	4
	.byte	'idBlock_uo',0,5,107,46
	.word	170
	.byte	4
	.byte	'RamBlock_pu8',0,5,108,37
	.word	917
	.byte	4
	.byte	'idxDataset_u8',0,5,109,36
	.word	153
	.byte	0,6,6,31,9,4,7
	.byte	'MEMIF_JOB_OK',0,0,7
	.byte	'MEMIF_JOB_FAILED',0,1,7
	.byte	'MEMIF_JOB_PENDING',0,2,7
	.byte	'MEMIF_JOB_CANCELED',0,3,7
	.byte	'MEMIF_BLOCK_INCONSISTENT',0,4,7
	.byte	'MEMIF_BLOCK_INVALID',0,5,0,18,2,227,1,9,20,19
	.byte	'idJob_en',0
	.word	1107
	.byte	4,2,35,0,19
	.byte	'idBlock_uo',0
	.word	170
	.byte	2,2,35,4,19
	.byte	'RamBlock_pu8',0
	.word	917
	.byte	4,2,35,8,19
	.byte	'idxDataset_u8',0
	.word	153
	.byte	1,2,35,12,19
	.byte	'Result_en',0
	.word	1651
	.byte	4,2,35,16,0,10
	.word	1781
	.byte	20,1,1,12
	.word	1890
	.byte	0,10
	.word	1895
	.byte	10
	.word	1895
.L110:
	.byte	13
	.byte	'NvM_Prv_JobComplete_tpfct',0,4,20,16
	.word	1909
	.byte	21
	.word	192
	.byte	22
	.word	235
	.byte	5,0,21
	.word	257
	.byte	22
	.word	290
	.byte	5,0,21
	.word	379
	.byte	22
	.word	412
	.byte	5,0,21
	.word	434
	.byte	22
	.word	477
	.byte	5,0,21
	.word	515
	.byte	22
	.word	554
	.byte	5,0,21
	.word	639
	.byte	22
	.word	677
	.byte	5,0,21
	.word	704
	.byte	22
	.word	748
	.byte	5,0,21
	.word	770
	.byte	22
	.word	804
	.byte	22
	.word	824
	.byte	14,23
	.word	379
	.byte	22
	.word	412
	.byte	24
	.word	432
	.byte	0,5,23
	.word	434
	.byte	22
	.word	477
	.byte	24
	.word	497
	.byte	0,5,0,0,21
	.word	852
	.byte	22
	.word	895
	.byte	5,0,25
	.byte	'NvM_Prv_ErrorDetection_IsJobIdValid',0,7,60,16
	.word	153
	.byte	1,1,1,1,4
	.byte	'idService_uo',0,7,60,74
	.word	153
	.byte	4
	.byte	'idBlock_uo',0,7,61,68
	.word	170
	.byte	4
	.byte	'idJob_en',0,7,62,70
	.word	1107
	.byte	0,16
	.byte	'NvM_Prv_ExplicitSync_IsOngoing',0,8,58,16
	.word	153
	.byte	1,1,1,1,25
	.byte	'NvM_Prv_ExplicitSync_CopyData',0,8,59,28
	.word	1651
	.byte	1,1,1,1,4
	.byte	'CopyFunction_pfct',0,8,59,90
	.word	599
	.byte	4
	.byte	'idBlock_uo',0,8,60,74
	.word	170
	.byte	0
.L113:
	.byte	10
	.word	1781
	.byte	9
	.word	153
.L157:
	.byte	10
	.word	2338
	.byte	21
	.word	922
	.byte	22
	.word	959
	.byte	22
	.word	979
	.byte	22
	.word	1001
	.byte	14,23
	.word	515
	.byte	22
	.word	554
	.byte	24
	.word	574
	.byte	0,5,23
	.word	434
	.byte	22
	.word	477
	.byte	24
	.word	497
	.byte	0,5,23
	.word	379
	.byte	22
	.word	412
	.byte	24
	.word	432
	.byte	0,5,23
	.word	257
	.byte	22
	.word	290
	.byte	24
	.word	310
	.byte	0,5,0,0,26
	.byte	'__INDIRECT__',0,4,1,1,1,1,1,27,1,10
	.word	2459
	.byte	13
	.byte	'__codeptr',0,4,1,1
	.word	2461
	.byte	2
	.byte	'char',0,1,6,13
	.byte	'sint8',0,9,76,25
	.word	2484
	.byte	13
	.byte	'uint8',0,9,81,25
	.word	153
	.byte	13
	.byte	'uint16',0,9,91,25
	.word	170
	.byte	2
	.byte	'unsigned int',0,4,7,13
	.byte	'uint32',0,9,106,24
	.word	2535
	.byte	2
	.byte	'unsigned long long int',0,8,7,13
	.byte	'uint64',0,9,111,30
	.word	2566
	.byte	13
	.byte	'boolean',0,9,127,25
	.word	153
	.byte	13
	.byte	'StatusType',0,10,191,1,27
	.word	153
	.byte	13
	.byte	'Std_ReturnType',0,10,199,1,15
	.word	153
	.byte	18,10,206,1,9,8,19
	.byte	'vendorID',0
	.word	170
	.byte	2,2,35,0,19
	.byte	'moduleID',0
	.word	170
	.byte	2,2,35,2,19
	.byte	'sw_major_version',0
	.word	153
	.byte	1,2,35,4,19
	.byte	'sw_minor_version',0
	.word	153
	.byte	1,2,35,5,19
	.byte	'sw_patch_version',0
	.word	153
	.byte	1,2,35,6,0,13
	.byte	'Std_VersionInfoType',0,10,213,1,3
	.word	2667
	.byte	13
	.byte	'PduIdType',0,11,22,19
	.word	170
	.byte	13
	.byte	'PduLengthType',0,11,26,19
	.word	170
	.byte	6,12,113,9,4,7
	.byte	'TP_DATACONF',0,0,7
	.byte	'TP_DATARETRY',0,1,7
	.byte	'TP_CONFPENDING',0,2,0,13
	.byte	'TpDataStateType',0,12,118,3
	.word	2857
	.byte	13
	.byte	'Can_IdType',0,13,32,16
	.word	2535
	.byte	13
	.byte	'Can_HwHandleType',0,13,43,16
	.word	170
	.byte	18,14,93,9,8,19
	.byte	'Class',0
	.word	153
	.byte	1,2,35,0,19
	.byte	'TIN',0
	.word	153
	.byte	1,2,35,1,19
	.byte	'ReturnAddress',0
	.word	2535
	.byte	4,2,35,4,0,13
	.byte	'OsTrapInfoType',0,14,97,3
	.word	2977
	.byte	28,68
	.word	2535
	.byte	29,16,0,18,14,154,1,9,68,19
	.byte	'store',0
	.word	3057
	.byte	68,2,35,0,0,28,68
	.word	3066
	.byte	29,0,0,13
	.byte	'Os_JumpBufType',0,14,156,1,3
	.word	3088
	.byte	13
	.byte	'Os_StackTraceType',0,14,174,1,18
	.word	2535
	.byte	18,14,175,1,9,8,19
	.byte	'sp',0
	.word	2535
	.byte	4,2,35,0,19
	.byte	'ctx',0
	.word	2535
	.byte	4,2,35,4,0,13
	.byte	'Os_StackValueType',0,14,175,1,63
	.word	3148
	.byte	13
	.byte	'Os_StackSizeType',0,14,176,1,27
	.word	3148
	.byte	30,1,1,10
	.word	3233
	.byte	13
	.byte	'Os_VoidVoidFunctionType',0,14,179,1,16
	.word	3236
	.byte	13
	.byte	'ApplicationType',0,14,193,1,23
	.word	153
	.byte	31
	.byte	'Os_ApplicationConfigurationType_s',0,14,198,1,16,2,19
	.byte	'app_id',0
	.word	153
	.byte	1,2,35,0,19
	.byte	'access',0
	.word	153
	.byte	1,2,35,1,0,13
	.byte	'Os_ApplicationConfigurationType',0,14,201,1,3
	.word	3299
	.byte	13
	.byte	'Os_CoreStateType',0,14,203,1,16
	.word	2535
	.byte	13
	.byte	'AreaIdType',0,14,204,1,16
	.word	170
	.byte	13
	.byte	'Os_PeripheralAddressType',0,14,212,1,22
	.word	2535
	.byte	13
	.byte	'TickType',0,14,221,1,22
	.word	2535
	.byte	13
	.byte	'Os_StopwatchTickType',0,14,225,1,22
	.word	2535
	.byte	10
	.word	2535
	.byte	13
	.byte	'Os_Lockable',0,14,234,1,18
	.word	3541
	.byte	13
	.byte	'CoreIdType',0,14,236,1,16
	.word	170
	.byte	13
	.byte	'SpinlockIdType',0,14,237,1,16
	.word	170
	.byte	6,14,239,1,9,4,7
	.byte	'TRYTOGETSPINLOCK_SUCCESS',0,0,7
	.byte	'TRYTOGETSPINLOCK_NOSUCCESS',0,1,0,13
	.byte	'TryToGetSpinlockType',0,14,239,1,74
	.word	3611
	.byte	6,14,174,2,9,4,7
	.byte	'APPLICATION_ACCESSIBLE',0,0,7
	.byte	'APPLICATION_RESTARTING',0,1,7
	.byte	'APPLICATION_TERMINATED',0,2,0,13
	.byte	'ApplicationStateType',0,14,174,2,92
	.word	3704
	.byte	20,1,1,12
	.word	153
	.byte	12
	.word	576
	.byte	0,10
	.word	3816
	.byte	13
	.byte	'Os_FunctionEntryType',0,14,183,2,16
	.word	3830
	.byte	31
	.byte	'Os_MeterInfoType_s',0,14,193,2,16,48,19
	.byte	'elapsed',0
	.word	2535
	.byte	4,2,35,0,19
	.byte	'previous',0
	.word	2535
	.byte	4,2,35,4,19
	.byte	'max',0
	.word	2535
	.byte	4,2,35,8,19
	.byte	'cumulative',0
	.word	2535
	.byte	4,2,35,12,19
	.byte	'stackbase',0
	.word	3148
	.byte	8,2,35,16,19
	.byte	'stackusage',0
	.word	3148
	.byte	8,2,35,24,19
	.byte	'stackmax',0
	.word	3148
	.byte	8,2,35,32,19
	.byte	'stackbudget',0
	.word	3148
	.byte	8,2,35,40,0,13
	.byte	'Os_MeterInfoType',0,14,202,2,3
	.word	3865
	.byte	10
	.word	3865
	.byte	13
	.byte	'Os_MeterInfoRefType',0,14,203,2,50
	.word	4063
	.byte	13
	.byte	'EventMaskType',0,14,206,2,15
	.word	153
	.byte	13
	.byte	'Os_imaskType',0,14,211,2,16
	.word	2535
	.byte	31
	.byte	'Os_ISRDynType_s',0,14,213,2,16,48,19
	.byte	'meter',0
	.word	3865
	.byte	48,2,35,0,0,13
	.byte	'Os_ISRDynType',0,14,215,2,3
	.word	4142
	.byte	10
	.word	4142
	.byte	9
	.word	4203
	.byte	31
	.byte	'Os_ISRType_s',0,14,216,2,16,24,19
	.byte	'entry_function',0
	.word	3241
	.byte	4,2,35,0,19
	.byte	'dynamic',0
	.word	4208
	.byte	4,2,35,4,19
	.byte	'imask',0
	.word	2535
	.byte	4,2,35,8,19
	.byte	'stackbudget',0
	.word	3148
	.byte	8,2,35,12,19
	.byte	'access',0
	.word	153
	.byte	1,2,35,20,19
	.byte	'application',0
	.word	153
	.byte	1,2,35,21,0,13
	.byte	'Os_ISRType',0,14,223,2,3
	.word	4213
	.byte	10
	.word	3233
	.byte	9
	.word	4213
	.byte	10
	.word	4372
	.byte	13
	.byte	'ISRType',0,14,224,2,46
	.word	4377
	.byte	13
	.byte	'Os_bitmask',0,14,239,2,22
	.word	2535
	.byte	13
	.byte	'Os_pset0Type',0,14,240,2,20
	.word	2535
	.byte	13
	.byte	'Os_pset1Type',0,14,241,2,20
	.word	2535
	.byte	13
	.byte	'Os_pset2Type',0,14,242,2,20
	.word	2535
	.byte	32,14,243,2,9,4,19
	.byte	'p0',0
	.word	2535
	.byte	4,2,35,0,19
	.byte	'p1',0
	.word	2535
	.byte	4,2,35,0,19
	.byte	'p2',0
	.word	2535
	.byte	4,2,35,0,0,13
	.byte	'Os_psetType',0,14,247,2,3
	.word	4485
	.byte	32,14,249,2,9,4,19
	.byte	't0',0
	.word	2535
	.byte	4,2,35,0,19
	.byte	't1',0
	.word	2535
	.byte	4,2,35,0,19
	.byte	't2',0
	.word	2535
	.byte	4,2,35,0,0,13
	.byte	'Os_tpmaskType',0,14,253,2,3
	.word	4549
	.byte	13
	.byte	'Os_ActivationCountType',0,14,254,2,23
	.word	153
	.byte	31
	.byte	'Os_TaskDynType_s',0,14,128,3,16,120,19
	.byte	'terminate_jump_buf',0
	.word	3097
	.byte	68,2,35,0,19
	.byte	'meter',0
	.word	3865
	.byte	48,2,35,68,19
	.byte	'activation_count',0
	.word	153
	.byte	1,2,35,116,0,13
	.byte	'Os_TaskDynType',0,14,132,3,3
	.word	4647
	.byte	28,68
	.word	3066
	.byte	29,0,0,10
	.word	4647
	.byte	9
	.word	4773
	.byte	31
	.byte	'Os_TaskType_s',0,14,134,3,16,40,19
	.byte	'dynamic',0
	.word	4778
	.byte	4,2,35,0,19
	.byte	'entry_function',0
	.word	3241
	.byte	4,2,35,4,19
	.byte	'pset',0
	.word	4485
	.byte	4,2,35,8,19
	.byte	'base_tpmask',0
	.word	4549
	.byte	4,2,35,12,19
	.byte	'tpmask',0
	.word	4549
	.byte	4,2,35,16,19
	.byte	'core_id',0
	.word	170
	.byte	2,2,35,20,19
	.byte	'index',0
	.word	2535
	.byte	4,2,35,24,19
	.byte	'stackbudget',0
	.word	3148
	.byte	8,2,35,28,19
	.byte	'activation_count',0
	.word	153
	.byte	1,2,35,36,19
	.byte	'access',0
	.word	153
	.byte	1,2,35,37,19
	.byte	'application',0
	.word	153
	.byte	1,2,35,38,0,13
	.byte	'Os_TaskType',0,14,146,3,3
	.word	4783
	.byte	9
	.word	4783
	.byte	10
	.word	5033
	.byte	13
	.byte	'TaskType',0,14,147,3,47
	.word	5038
	.byte	33
	.byte	'Os_TaskStateType',0,14,155,3,6,4,7
	.byte	'SUSPENDED',0,0,7
	.byte	'READY',0,1,7
	.byte	'WAITING',0,2,7
	.byte	'RUNNING',0,3,0,13
	.byte	'TaskStateType',0,14,156,3,31
	.word	5061
	.byte	32,14,167,3,3,4,19
	.byte	'tpmask',0
	.word	4549
	.byte	4,2,35,0,0,31
	.byte	'Os_ResourceDynType_s',0,14,166,3,16,4,19
	.byte	'saved_priority',0
	.word	5148
	.byte	4,2,35,0,0,13
	.byte	'Os_ResourceDynType',0,14,170,3,3
	.word	5171
	.byte	10
	.word	5171
	.byte	9
	.word	5251
	.byte	31
	.byte	'Os_ResourceType_s',0,14,171,3,16,12,19
	.byte	'dynamic',0
	.word	5256
	.byte	4,2,35,0,19
	.byte	'tpmask',0
	.word	4549
	.byte	4,2,35,4,19
	.byte	'access',0
	.word	153
	.byte	1,2,35,8,0,13
	.byte	'Os_ResourceType',0,14,175,3,3
	.word	5261
	.byte	18,14,181,3,9,12,19
	.byte	'maxallowedvalue',0
	.word	2535
	.byte	4,2,35,0,19
	.byte	'ticksperbase',0
	.word	2535
	.byte	4,2,35,4,19
	.byte	'mincycle',0
	.word	2535
	.byte	4,2,35,8,0,13
	.byte	'AlarmBaseType',0,14,185,3,3
	.word	5360
	.byte	18,14,206,3,9,8,19
	.byte	'Running',0
	.word	153
	.byte	1,2,35,0,19
	.byte	'Pending',0
	.word	153
	.byte	1,2,35,1,19
	.byte	'Delay',0
	.word	2535
	.byte	4,2,35,4,0,13
	.byte	'Os_CounterStatusType',0,14,210,3,3
	.word	5455
	.byte	34
	.word	153
	.byte	1,1,10
	.word	5541
	.byte	13
	.byte	'Os_CounterIncrAdvType',0,14,217,3,22
	.word	5548
	.byte	31
	.byte	's_swd',0,14,222,3,12,4,19
	.byte	'count',0
	.word	2535
	.byte	4,2,35,0,0,32,14,221,3,3,4,19
	.byte	'sw',0
	.word	5584
	.byte	4,2,35,0,0,31
	.byte	'Os_CounterDynType_s',0,14,220,3,16,4,19
	.byte	'type_dependent',0
	.word	5612
	.byte	4,2,35,0,0,13
	.byte	'Os_CounterDynType',0,14,226,3,3
	.word	5631
	.byte	10
	.word	5631
	.byte	9
	.word	5709
	.byte	31
	.byte	'Os_CounterType_s',0,14,227,3,16,28,19
	.byte	'dynamic',0
	.word	5714
	.byte	4,2,35,0,19
	.byte	'advincr',0
	.word	5553
	.byte	4,2,35,4,19
	.byte	'base',0
	.word	5360
	.byte	12,2,35,8,19
	.byte	'core',0
	.word	576
	.byte	4,2,35,20,19
	.byte	'access',0
	.word	153
	.byte	1,2,35,24,19
	.byte	'application',0
	.word	153
	.byte	1,2,35,25,0,13
	.byte	'Os_CounterType',0,14,234,3,3
	.word	5719
	.byte	10
	.word	5541
	.byte	9
	.word	5719
	.byte	10
	.word	5871
	.byte	13
	.byte	'CounterType',0,14,235,3,52
	.word	5876
	.byte	33
	.byte	'Os_ScheduleTableStatusType',0,14,240,3,6,4,7
	.byte	'SCHEDULETABLE_STOPPED',0,0,7
	.byte	'SCHEDULETABLE_NEXT',0,1,7
	.byte	'SCHEDULETABLE_WAITING',0,2,7
	.byte	'SCHEDULETABLE_RUNNING',0,3,7
	.byte	'SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS',0,4,0,13
	.byte	'ScheduleTableStatusType',0,14,241,3,41
	.word	5902
	.byte	9
	.word	.L235-.L71
	.byte	10
	.word	6102
	.byte	13
	.byte	'ScheduleTableType',0,14,128,4,58
	.word	6107
	.byte	31
	.byte	'Os_ScheduleTableDynType_s',0,14,130,4,16,16,19
	.byte	'match',0
	.word	2535
	.byte	4,2,35,0,19
	.byte	'next',0
	.word	6112
	.byte	4,2,35,4,19
	.byte	'state',0
	.word	5902
	.byte	4,2,35,8,19
	.byte	'config',0
	.word	170
	.byte	2,2,35,12,0,10
	.word	6139
	.byte	9
	.word	6232
.L235:
	.byte	31
	.byte	'Os_ScheduleTableType_s',0,14,247,3,16,16,19
	.byte	'dynamic',0
	.word	6237
	.byte	4,2,35,0,19
	.byte	'counter',0
	.word	5881
	.byte	4,2,35,4,19
	.byte	'repeat',0
	.word	153
	.byte	1,2,35,8,19
	.byte	'config',0
	.word	170
	.byte	2,2,35,10,19
	.byte	'initial',0
	.word	153
	.byte	1,2,35,12,19
	.byte	'access',0
	.word	153
	.byte	1,2,35,13,19
	.byte	'application',0
	.word	153
	.byte	1,2,35,14,0,13
	.byte	'Os_ScheduleTableType',0,14,255,3,3
	.word	6242
	.byte	9
	.word	6242
	.byte	10
	.word	6422
	.byte	9
	.word	5719
	.byte	10
	.word	6432
	.byte	35
	.word	3546
	.byte	35
	.word	4485
	.byte	35
	.word	4382
	.byte	35
	.word	5043
	.byte	35
	.word	4549
	.byte	35
	.word	153
	.byte	35
	.word	5043
	.byte	31
	.byte	'Os_ControlledCoreType_s',0,14,251,6,16,112,19
	.byte	'TrapInfo',0
	.word	2977
	.byte	8,2,35,0,19
	.byte	'lock_taskaccess',0
	.word	6442
	.byte	4,2,35,8,19
	.byte	'ReadyTasks',0
	.word	6447
	.byte	4,2,35,12,19
	.byte	'RunningISR',0
	.word	6452
	.byte	4,2,35,16,19
	.byte	'RunningTask',0
	.word	6457
	.byte	4,2,35,20,19
	.byte	'RunningTPMask',0
	.word	6462
	.byte	4,2,35,24,19
	.byte	'CurrentMeteredObject',0
	.word	4068
	.byte	4,2,35,28,19
	.byte	'IdleMeter',0
	.word	3865
	.byte	48,2,35,32,19
	.byte	'AppAccess',0
	.word	153
	.byte	1,2,35,80,19
	.byte	'AppOverride',0
	.word	6467
	.byte	1,2,35,81,19
	.byte	'GetStackValueAdjust',0
	.word	3148
	.byte	8,2,35,84,19
	.byte	'InErrorHook',0
	.word	153
	.byte	1,2,35,92,19
	.byte	'ChainTaskRef',0
	.word	6472
	.byte	4,2,35,96,19
	.byte	'GetStackUsageAdjust',0
	.word	3148
	.byte	8,2,35,100,19
	.byte	'InProtectionHook',0
	.word	153
	.byte	1,2,35,108,19
	.byte	'CoreIsActive',0
	.word	153
	.byte	1,2,35,109,19
	.byte	'InShutdownHook',0
	.word	153
	.byte	1,2,35,110,0,13
	.byte	'Os_ControlledCoreType',0,14,141,7,3
	.word	6477
	.byte	10
	.word	2535
	.byte	9
	.word	4213
	.byte	10
	.word	6933
	.byte	9
	.word	4783
	.byte	10
	.word	6943
	.byte	10
	.word	3865
	.byte	31
	.byte	'Os_AnyCoreType_s',0,14,151,7,16,96,19
	.byte	'DisableAllImask',0
	.word	2535
	.byte	4,2,35,0,19
	.byte	'SuspendAllImask',0
	.word	2535
	.byte	4,2,35,4,19
	.byte	'SuspendOSImask',0
	.word	2535
	.byte	4,2,35,8,19
	.byte	'DisableAllCount',0
	.word	2535
	.byte	4,2,35,12,19
	.byte	'SuspendAllCount',0
	.word	2535
	.byte	4,2,35,16,19
	.byte	'SuspendOSCount',0
	.word	2535
	.byte	4,2,35,20,19
	.byte	'RestartJumpBuf',0
	.word	3097
	.byte	68,2,35,24,19
	.byte	'Restartable',0
	.word	153
	.byte	1,2,35,92,0,13
	.byte	'Os_AnyCoreType',0,14,160,7,3
	.word	6958
	.byte	13
	.byte	'Can_TxObjPriorityClassType',0,15,219,3,16
	.word	2535
	.byte	31
	.byte	'Can_TxHwObjectConfigType',0,15,231,3,16,8,19
	.byte	'MsgObjId',0
	.word	153
	.byte	1,2,35,0,19
	.byte	'HwControllerId',0
	.word	153
	.byte	1,2,35,1,19
	.byte	'TxObjPriorityClass',0
	.word	2535
	.byte	4,2,35,4,0,13
	.byte	'Can_TxHwObjectConfigType',0,15,252,3,3
	.word	7235
	.byte	31
	.byte	'Can_RxHwObjectConfigType',0,15,129,4,16,12,19
	.byte	'MaskRef',0
	.word	2535
	.byte	4,2,35,0,19
	.byte	'MsgId',0
	.word	2535
	.byte	4,2,35,4,19
	.byte	'MsgObjId',0
	.word	153
	.byte	1,2,35,8,19
	.byte	'HwControllerId',0
	.word	153
	.byte	1,2,35,9,0,13
	.byte	'Can_RxHwObjectConfigType',0,15,147,4,3
	.word	7371
	.byte	28,4
	.word	153
	.byte	29,3,0,31
	.byte	'Can_ControllerMOMapConfigType',0,15,181,4,16,4,19
	.byte	'ControllerMOMap',0
	.word	7511
	.byte	4,2,35,0,0,13
	.byte	'Can_ControllerMOMapConfigType',0,15,184,4,3
	.word	7520
	.byte	31
	.byte	'Can_NPCRValueType',0,15,188,4,16,2,19
	.byte	'Can_NPCRValue',0
	.word	170
	.byte	2,2,35,0,0,13
	.byte	'Can_NPCRValueType',0,15,191,4,3
	.word	7621
	.byte	31
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,15,194,4,16,8,19
	.byte	'CanControllerBaudrate',0
	.word	2535
	.byte	4,2,35,0,19
	.byte	'CanControllerBaudrateCfg',0
	.word	170
	.byte	2,2,35,4,0,13
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,15,198,4,3
	.word	7696
	.byte	9
	.word	7696
	.byte	10
	.word	7861
	.byte	31
	.byte	'Can_BaudrateConfigPtrType',0,15,201,4,16,4,19
	.byte	'Can_kBaudrateConfigPtr',0
	.word	7866
	.byte	4,2,35,0,0,13
	.byte	'Can_BaudrateConfigPtrType',0,15,204,4,3
	.word	7871
	.byte	31
	.byte	'Can_EventHandlingType',0,15,226,4,16,4,19
	.byte	'CanEventType',0
	.word	7511
	.byte	4,2,35,0,0,13
	.byte	'Can_EventHandlingType',0,15,229,4,3
	.word	7971
	.byte	13
	.byte	'Rte_TransformerErrorCode',0,16,130,1,15
	.word	153
	.byte	13
	.byte	'Rte_TransformerClass',0,16,131,1,15
	.word	153
	.byte	18,16,168,1,9,12,19
	.byte	'in',0
	.word	576
	.byte	4,2,35,0,19
	.byte	'out',0
	.word	576
	.byte	4,2,35,4,19
	.byte	'used',0
	.word	170
	.byte	2,2,35,8,19
	.byte	'lost_data',0
	.word	153
	.byte	1,2,35,10,0,13
	.byte	'Rte_QDynType',0,16,173,1,3
	.word	8117
	.byte	6,16,175,1,9,4,7
	.byte	'RTE_DRA',0,0,7
	.byte	'RTE_WOWP',0,1,7
	.byte	'RTE_TASK',0,2,7
	.byte	'RTE_ARE',0,3,7
	.byte	'RTE_EV',0,4,7
	.byte	'RTE_MSI',0,5,0,13
	.byte	'Rte_NotificationType',0,16,182,1,3
	.word	8204
	.byte	10
	.word	8117
	.byte	31
	.byte	'Rte_QCmnType',0,16,184,1,16,24,19
	.byte	'dynamic',0
	.word	8302
	.byte	4,2,35,0,19
	.byte	'copy',0
	.word	153
	.byte	1,2,35,4,19
	.byte	'queue_size',0
	.word	170
	.byte	2,2,35,6,19
	.byte	'element_size',0
	.word	170
	.byte	2,2,35,8,19
	.byte	'buffer_start',0
	.word	576
	.byte	4,2,35,12,19
	.byte	'buffer_end',0
	.word	576
	.byte	4,2,35,16,19
	.byte	'notification_type',0
	.word	8204
	.byte	4,2,35,20,0,13
	.byte	'Rte_QCmnType',0,16,192,1,3
	.word	8307
	.byte	13
	.byte	'Rte_AlarmRefType',0,16,224,1,32
	.word	2535
	.byte	13
	.byte	'Rte_AlarmIndexType',0,16,226,1,32
	.word	170
	.byte	28,128,8
	.word	153
	.byte	29,255,7,0,13
	.byte	'Impl_NVM_DstPtrType_1024',0,17,50,15
	.word	8545
	.byte	13
	.byte	'CanIf_u32_impl',0,17,69,16
	.word	2535
	.byte	13
	.byte	'CanIf_u16_impl',0,17,71,16
	.word	170
	.byte	13
	.byte	'CanIf_u8_impl',0,17,73,15
	.word	153
	.byte	13
	.byte	'CanIf_ControllerModeType_Enum_impl',0,17,88,15
	.word	153
	.byte	13
	.byte	'CanIf_PduModeType_Enum_impl',0,17,90,15
	.word	153
	.byte	18,17,92,9,2,19
	.byte	'DeviceMode',0
	.word	153
	.byte	1,2,35,0,19
	.byte	'ChannelMode',0
	.word	153
	.byte	1,2,35,1,0,13
	.byte	'CanIf_ControllerStateType_struct_impl',0,17,95,3
	.word	8736
	.byte	13
	.byte	'CanIf_NotifStatusType_Enum_impl',0,17,100,15
	.word	153
	.byte	13
	.byte	'CanSM_boolean_Impl',0,17,120,15
	.word	153
	.byte	13
	.byte	'CanSM_u8_Impl',0,17,123,15
	.word	153
	.byte	13
	.byte	'CanSM_BusOffRecoveryStateType_Enum_impl',0,17,128,1,15
	.word	153
	.byte	13
	.byte	'CanSM_NetworkModeStateType_Enum_impl',0,17,132,1,15
	.word	153
	.byte	13
	.byte	'CanSM_u16_Impl',0,17,136,1,16
	.word	170
	.byte	13
	.byte	'CanSM_TimerStateType_Enum_impl',0,17,138,1,15
	.word	153
	.byte	18,17,140,1,9,4,19
	.byte	'cntTick_u16',0
	.word	170
	.byte	2,2,35,0,19
	.byte	'stTimer',0
	.word	153
	.byte	1,2,35,2,0,13
	.byte	'CanSM_TimerConfig_tst_struct_impl',0,17,143,1,3
	.word	9077
	.byte	13
	.byte	'Com_impl_u16',0,17,154,1,16
	.word	170
	.byte	13
	.byte	'Com_impl_u8',0,17,157,1,15
	.word	153
	.byte	13
	.byte	'ComM_uint32_Impl',0,17,173,1,16
	.word	2535
	.byte	13
	.byte	'ComM_uint16_Impl',0,17,175,1,16
	.word	170
	.byte	13
	.byte	'ComM_uint8_Impl',0,17,177,1,15
	.word	153
	.byte	13
	.byte	'ComM_bool_Impl',0,17,179,1,15
	.word	153
	.byte	18,17,181,1,9,24,19
	.byte	'ChannelState_e',0
	.word	2535
	.byte	4,2,35,0,19
	.byte	'LightTimeoutCtr_u32',0
	.word	2535
	.byte	4,2,35,4,19
	.byte	'MinFullComTimeoutCtr_u16',0
	.word	170
	.byte	2,2,35,8,19
	.byte	'ChannelMode_u8',0
	.word	153
	.byte	1,2,35,10,19
	.byte	'BusSmMode_u8',0
	.word	153
	.byte	1,2,35,11,19
	.byte	'UserRequestCtr_u8',0
	.word	153
	.byte	1,2,35,12,19
	.byte	'PassiveRequestState_u8',0
	.word	153
	.byte	1,2,35,13,19
	.byte	'PncRequestCtr_u8',0
	.word	153
	.byte	1,2,35,14,19
	.byte	'InhibitionReqStatus_u8',0
	.word	153
	.byte	1,2,35,15,19
	.byte	'NmNetworkRequestStatus_b',0
	.word	153
	.byte	1,2,35,16,19
	.byte	'DiagnosticRequestState_b',0
	.word	153
	.byte	1,2,35,17,19
	.byte	'CommunicationAllowed_b',0
	.word	153
	.byte	1,2,35,18,19
	.byte	'NmBusSleepIndicationStatus_b',0
	.word	153
	.byte	1,2,35,19,19
	.byte	'NmPrepareBusSleepIndicationStatus_b',0
	.word	153
	.byte	1,2,35,20,19
	.byte	'NmNetworkModeStatus_b',0
	.word	153
	.byte	1,2,35,21,0,13
	.byte	'ComM_ChannelStruct_Impl',0,17,197,1,3
	.word	9309
	.byte	18,17,206,1,9,10,19
	.byte	'WakeUpInhibitionCtr_u16',0
	.word	170
	.byte	2,2,35,0,19
	.byte	'LimitToNoComCtr_u16',0
	.word	170
	.byte	2,2,35,2,19
	.byte	'RequestedUserMode_t',0
	.word	153
	.byte	1,2,35,4,19
	.byte	'IndicatedUserMode_t',0
	.word	153
	.byte	1,2,35,5,19
	.byte	'numChannelsInFullCom_u8',0
	.word	153
	.byte	1,2,35,6,19
	.byte	'numChannelsInSilentCom_u8',0
	.word	153
	.byte	1,2,35,7,19
	.byte	'numChannelsInNoCom_u8',0
	.word	153
	.byte	1,2,35,8,0,13
	.byte	'ComM_UserStruct_Impl',0,17,214,1,3
	.word	9813
	.byte	13
	.byte	'Dcm_IOOperationResponseType',0,17,252,1,15
	.word	153
	.byte	13
	.byte	'Dcm_RequestDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspRequestRoutineResultsOutSignal_0PrimitivType',0
	.byte	17,138,2,15
	.word	153
	.byte	13
	.byte	'Dcm_StartDataIn_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineInSignalPrimitivType',0,17,146,2,15
	.word	153
	.byte	13
	.byte	'Dcm_StartDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineOutSignalPrimitivType',0,17,150,2,15
	.word	153
	.byte	13
	.byte	'Dcm_StopDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStopRoutineOutSignalPrimitivType',0,17,154,2,15
	.word	153
	.byte	13
	.byte	'NvM_BlockIdType',0,17,215,2,16
	.word	170
	.byte	13
	.byte	'NvM_RequestResultType',0,17,225,2,15
	.word	153
	.byte	13
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockNative_1024_Type',0,17,243,3,34
	.word	8556
	.byte	28,128,8
	.word	153
	.byte	29,255,7,0,13
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockRedundant_1024_Type',0,17,246,3,34
	.word	8556
	.byte	13
	.byte	'MemIf_JobResultType',0,6,39,2
	.word	1651
	.byte	13
	.byte	'NvM_BlockManagementType',0,2,45,3
	.word	312
	.byte	6,2,49,9,4,7
	.byte	'NVM_PRV_ACTIVITY_NOT_INIT',0,0,7
	.byte	'NVM_PRV_ACTIVITY_IDLE',0,1,7
	.byte	'NVM_PRV_ACTIVITY_ARBITRATE',0,2,7
	.byte	'NVM_PRV_ACTIVITY_JOB_START',0,3,7
	.byte	'NVM_PRV_ACTIVITY_POLL_RESULT',0,4,7
	.byte	'NVM_PRV_ACTIVITY_JOB_COMPLETE',0,5,7
	.byte	'NVM_PRV_ACTIVITY_RESULT_EVAL',0,6,0,13
	.byte	'NvM_Prv_Activities_ten',0,2,58,3
	.word	10747
	.byte	13
	.byte	'NvM_Prv_idJob_ten',0,2,115,3
	.word	1107
	.byte	13
	.byte	'NvM_Prv_ServiceBit_tuo',0,2,168,1,16
	.word	170
	.byte	13
	.byte	'NvM_Prv_idService_tuo',0,2,173,1,15
	.word	153
	.byte	13
	.byte	'NvM_Prv_idQueue_tuo',0,2,206,1,15
	.word	153
	.byte	18,2,210,1,9,12,19
	.byte	'idService_uo',0
	.word	153
	.byte	1,2,35,0,19
	.byte	'idBlock_uo',0
	.word	170
	.byte	2,2,35,2,19
	.byte	'ServiceBit_uo',0
	.word	170
	.byte	2,2,35,4,19
	.byte	'BlockData_pv',0
	.word	576
	.byte	4,2,35,8,0,13
	.byte	'NvM_Prv_QueueEntry_tst',0,2,225,1,3
	.word	11106
	.byte	13
	.byte	'NvM_Prv_JobData_tst',0,2,240,1,3
	.word	1781
	.byte	10
	.word	11106
	.byte	18,2,245,1,9,32,19
	.byte	'Activity_rAMwM_en',0
	.word	10747
	.byte	4,2,35,0,19
	.byte	'idQueueActive_uo',0
	.word	153
	.byte	1,2,35,4,19
	.byte	'QueueEntry_pst',0
	.word	11261
	.byte	4,2,35,8,19
	.byte	'JobData_st',0
	.word	1781
	.byte	20,2,35,12,0,13
	.byte	'NvM_Prv_MainStates_tst',0,2,132,2,3
	.word	11266
	.byte	13
	.byte	'Rte_TaskRefType',0,18,184,1,32
	.word	5043
	.byte	13
	.byte	'Rte_EventRefType',0,18,185,1,32
	.word	153
	.byte	13
	.byte	'Rte_EventType',0,18,186,1,32
	.word	2535
	.byte	13
	.byte	'Rte_REActCounterType',0,18,252,1,15
	.word	153
	.byte	10
	.word	153
	.byte	13
	.byte	'Rte_REActCounterRefType',0,18,253,1,58
	.word	11506
	.byte	18,18,255,1,9,8,19
	.byte	'task',0
	.word	11402
	.byte	4,2,35,0,19
	.byte	'acnt',0
	.word	11511
	.byte	4,2,35,4,0,13
	.byte	'Rte_REContainerType',0,18,130,2,3
	.word	11544
	.byte	9
	.word	4783
	.byte	10
	.word	11608
	.byte	10
	.word	153
	.byte	9
	.word	11544
	.byte	10
	.word	11623
	.byte	13
	.byte	'Rte_REContainerRefType',0,18,132,2,60
	.word	11628
	.byte	13
	.byte	'Rte_MSICounterType',0,18,149,2,16
	.word	170
	.byte	10
	.word	170
	.byte	13
	.byte	'Rte_MSICounterRefType',0,18,150,2,56
	.word	11693
	.byte	13
	.byte	'Rte_MSIPendingFlagType',0,18,152,2,17
	.word	153
	.byte	10
	.word	153
	.byte	13
	.byte	'Rte_MSIPendingFlagRefType',0,18,153,2,60
	.word	11761
	.byte	18,18,163,2,9,24,19
	.byte	'counter',0
	.word	11698
	.byte	4,2,35,0,19
	.byte	'incCounter',0
	.word	153
	.byte	1,2,35,4,19
	.byte	'pending',0
	.word	11766
	.byte	4,2,35,8,19
	.byte	'osTask',0
	.word	11402
	.byte	4,2,35,12,19
	.byte	'acnt',0
	.word	11511
	.byte	4,2,35,16,19
	.byte	'osEvent',0
	.word	153
	.byte	1,2,35,20,19
	.byte	'MSIInit',0
	.word	170
	.byte	2,2,35,22,0,13
	.byte	'Rte_MSITableEntry',0,18,172,2,3
	.word	11801
	.byte	10
	.word	170
	.byte	10
	.word	153
	.byte	13
	.byte	'Rte_TaskArrayIndex',0,18,179,2,16
	.word	153
	.byte	13
	.byte	'Rte_NrWaitingTasks',0,18,180,2,16
	.word	153
	.byte	18,18,182,2,9,4,19
	.byte	'pending',0
	.word	153
	.byte	1,2,35,0,19
	.byte	'count',0
	.word	153
	.byte	1,2,35,1,19
	.byte	'firstWaitingTask',0
	.word	153
	.byte	1,2,35,2,0,13
	.byte	'Rte_WaitableDatum',0,18,186,2,3
	.word	12019
	.byte	10
	.word	12019
	.byte	18,18,226,2,9,12,19
	.byte	'event_id',0
	.word	2535
	.byte	4,2,35,0,19
	.byte	'wd',0
	.word	12111
	.byte	4,2,35,4,19
	.byte	'timeout',0
	.word	2535
	.byte	4,2,35,8,0,13
	.byte	'Rte_WOWP_NotificationType',0,18,230,2,3
	.word	12116
	.byte	9
	.word	12116
	.byte	10
	.word	12205
	.byte	13
	.byte	'Rte_WOWP_NotificationRefType',0,18,232,2,66
	.word	12210
	.byte	13
	.byte	'Rte_ARE_NotificationType',0,18,234,2,29
	.word	11544
	.byte	31
	.byte	'Rte_QTaskType',0,18,243,2,16,28,19
	.byte	'cmn',0
	.word	8307
	.byte	24,2,35,0,19
	.byte	'task',0
	.word	11402
	.byte	4,2,35,24,0,13
	.byte	'Rte_QTaskType',0,18,246,2,3
	.word	12287
	.byte	31
	.byte	'Rte_QREType',0,18,250,2,16,28,19
	.byte	'cmn',0
	.word	8307
	.byte	24,2,35,0,19
	.byte	're',0
	.word	11633
	.byte	4,2,35,24,0,13
	.byte	'Rte_QREType',0,18,253,2,3
	.word	12358
	.byte	9
	.word	11544
	.byte	10
	.word	12423
	.byte	31
	.byte	'Rte_QWWPType',0,18,129,3,16,28,19
	.byte	'cmn',0
	.word	8307
	.byte	24,2,35,0,19
	.byte	'wwp',0
	.word	12215
	.byte	4,2,35,24,0,13
	.byte	'Rte_QWWPType',0,18,132,3,3
	.word	12433
	.byte	9
	.word	12116
	.byte	10
	.word	12501
	.byte	31
	.byte	'Rte_QEvType',0,18,136,3,16,36,19
	.byte	'cmn',0
	.word	8307
	.byte	24,2,35,0,19
	.byte	'task',0
	.word	11402
	.byte	4,2,35,24,19
	.byte	'mask',0
	.word	153
	.byte	1,2,35,28,19
	.byte	'acnt',0
	.word	11511
	.byte	4,2,35,32,0,13
	.byte	'Rte_QEvType',0,18,141,3,3
	.word	12511
	.byte	31
	.byte	'Rte_QMSIType',0,18,145,3,16,48,19
	.byte	'cmn',0
	.word	8307
	.byte	24,2,35,0,19
	.byte	'task',0
	.word	11402
	.byte	4,2,35,24,19
	.byte	'mask',0
	.word	153
	.byte	1,2,35,28,19
	.byte	'acnt',0
	.word	11511
	.byte	4,2,35,32,19
	.byte	'msiCounter',0
	.word	11698
	.byte	4,2,35,36,19
	.byte	'msiPending',0
	.word	11766
	.byte	4,2,35,40,19
	.byte	'msiLimit',0
	.word	170
	.byte	2,2,35,44,0,13
	.byte	'Rte_QMSIType',0,18,153,3,3
	.word	12606
	.byte	36
	.byte	'NvM_Prv_Main_st',0,5,59,31
	.word	11266
	.byte	1,1,6,1,34,9,4,7
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL',0,1,7
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL',0,2,7
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL',0,4,7
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE',0,8,7
	.byte	'NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED',0,16,7
	.byte	'NVM_PRV_BLOCK_FLAG_WRITE_ONCE',0,32,7
	.byte	'NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW',0,192,0,7
	.byte	'NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM',0,128,1,7
	.byte	'NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION',0,128,2,7
	.byte	'NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH',0,128,4,7
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION',0,128,8,7
	.byte	'NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL',0,128,16,0,13
	.byte	'NvM_Prv_BlockConfiguration_ten',0,1,85,3
	.word	12787
	.byte	9
	.word	170
	.byte	10
	.word	13350
	.byte	9
	.word	576
	.byte	10
	.word	13360
	.byte	11
	.word	153
	.byte	1,1,12
	.word	153
	.byte	12
	.word	153
	.byte	0,10
	.word	13370
	.byte	11
	.word	153
	.byte	1,1,12
	.word	153
	.byte	0,10
	.word	13393
	.byte	10
	.word	5541
	.byte	18,1,121,9,48,19
	.byte	'idBlockMemIf_u16',0
	.word	170
	.byte	2,2,35,0,19
	.byte	'nrBlockBytes_pu16',0
	.word	13355
	.byte	4,2,35,4,19
	.byte	'idxDevice_u8',0
	.word	153
	.byte	1,2,35,8,19
	.byte	'nrNvBlocks_u8',0
	.word	153
	.byte	1,2,35,9,19
	.byte	'nrRomBlocks_u8',0
	.word	153
	.byte	1,2,35,10,19
	.byte	'adrRamBlock_ppv',0
	.word	13365
	.byte	4,2,35,12,19
	.byte	'adrRomBlock_pcv',0
	.word	510
	.byte	4,2,35,16,19
	.byte	'SingleBlockCallback_pfct',0
	.word	13388
	.byte	4,2,35,20,19
	.byte	'SingleBlockStartCallback_pfct',0
	.word	13406
	.byte	4,2,35,24,19
	.byte	'InitBlockCallback_pfct',0
	.word	13411
	.byte	4,2,35,28,19
	.byte	'ReadRamBlockFromNvm_pfct',0
	.word	594
	.byte	4,2,35,32,19
	.byte	'WriteRamBlockToNvm_pfct',0
	.word	594
	.byte	4,2,35,36,19
	.byte	'BlockManagementType_en',0
	.word	312
	.byte	4,2,35,40,19
	.byte	'JobPriority_u8',0
	.word	153
	.byte	1,2,35,44,19
	.byte	'stFlags_u16',0
	.word	170
	.byte	2,2,35,46,0,13
	.byte	'NvM_Prv_BlockDescriptor_tst',0,1,138,2,3
	.word	13416
	.byte	28,160,5
	.word	13416
	.byte	29,13,0,9
	.word	13880
	.byte	36
	.byte	'NvM_Prv_BlockDescriptors_acst',0,1,169,2,45
	.word	13890
	.byte	1,1,28,52
	.word	1914
	.byte	29,12,0
.L207:
	.byte	9
	.word	13936
	.byte	0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L72:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,36,0,3,8,11,15,62,15,0,0,3,46,1,3,8,32,13,58,15,59,15
	.byte	57,15,73,19,54,15,39,12,0,0,4,5,0,3,8,58,15,59,15,57,15,73,19,0,0,5,11,0,0,0,6,4,1,58,15,59,15,57,15,11
	.byte	15,0,0,7,40,0,3,8,28,13,0,0,8,59,0,3,8,0,0,9,38,0,73,19,0,0,10,15,0,73,19,0,0,11,21,1,73,19,54,15,39,12
	.byte	0,0,12,5,0,73,19,0,0,13,22,0,3,8,58,15,59,15,57,15,73,19,0,0,14,11,1,0,0,15,46,1,3,8,32,13,58,15,59,15
	.byte	57,15,54,15,39,12,0,0,16,46,0,3,8,58,15,59,15,57,15,73,19,54,15,39,12,63,12,60,12,0,0,17,46,1,3,8,58,15
	.byte	59,15,57,15,54,15,39,12,63,12,60,12,0,0,18,19,1,58,15,59,15,57,15,11,15,0,0,19,13,0,3,8,73,19,11,15,56
	.byte	9,0,0,20,21,1,54,15,39,12,0,0,21,46,1,49,19,0,0,22,5,0,49,19,0,0,23,29,1,49,19,0,0,24,11,0,49,19,0,0,25
	.byte	46,1,3,8,58,15,59,15,57,15,73,19,54,15,39,12,63,12,60,12,0,0,26,46,0,3,8,58,15,59,15,57,15,54,15,63,12
	.byte	60,12,0,0,27,21,0,54,15,0,0,28,1,1,11,15,73,19,0,0,29,33,0,47,15,0,0,30,21,0,54,15,39,12,0,0,31,19,1,3
	.byte	8,58,15,59,15,57,15,11,15,0,0,32,23,1,58,15,59,15,57,15,11,15,0,0,33,4,1,3,8,58,15,59,15,57,15,11,15,0
	.byte	0,34,21,0,73,19,54,15,39,12,0,0,35,53,0,73,19,0,0,36,52,0,3,8,58,15,59,15,57,15,73,19,63,12,60,12,0,0
	.byte	0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L73:
	.word	.L237-.L236
.L236:
	.half	3
	.word	.L239-.L238
.L238:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockDescriptor.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\NvM\\api\\NvM_Types.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockData.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainfunctionJobComplete.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\MemIf\\api\\MemIf_Types.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_ErrorDetection.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_ExplicitSynchronization.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Platform\\Platform_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Std_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Can_GeneralTypes.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\RTOS_T\\Gen\\inc\\Os.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Can_17_MCanP\\inc\\Can_17_MCanP.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Type.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Intl.h',0,0,0,0,0
.L239:
.L237:
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_MainFunctionJobComplete')
	.sect	'.debug_info'
.L74:
	.word	286
	.half	3
	.word	.L75
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainfunctionJobComplete.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L77,.L76
	.byte	2
	.word	.L70
	.byte	3
	.byte	'NvM_Prv_MainFunctionJobComplete',0,1,237,1,6,1,1,1
	.word	.L69,.L106,.L68
	.byte	4
	.word	.L69,.L106
	.byte	5
	.byte	'idBlock_uo',0,1,240,1,21
	.word	.L107,.L108
	.byte	4
	.word	.L109,.L55
	.byte	5
	.byte	'JobComplete_pfct',0,1,246,1,35
	.word	.L110,.L111
	.byte	0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_MainFunctionJobComplete')
	.sect	'.debug_abbrev'
.L75:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,11,1,17,1,18,1,0,0,5,52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_MainFunctionJobComplete')
	.sect	'.debug_line'
.L76:
	.word	.L241-.L240
.L240:
	.half	3
	.word	.L243-.L242
.L242:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainfunctionJobComplete.c',0,0,0,0,0
.L243:
	.byte	5,34,7,0,5,2
	.word	.L69
	.byte	3,239,1,1,5,49,9
	.half	.L244-.L69
	.byte	1,5,64,9
	.half	.L245-.L244
	.byte	1,5,24,9
	.half	.L232-.L245
	.byte	3,16,1,5,60,9
	.half	.L246-.L232
	.byte	3,116,1,5,45,9
	.half	.L247-.L246
	.byte	3,126,1,5,71,9
	.half	.L248-.L247
	.byte	3,2,1,5,5,9
	.half	.L233-.L248
	.byte	3,126,1,5,106,7,9
	.half	.L109-.L233
	.byte	3,4,1,5,13,9
	.half	.L234-.L109
	.byte	3,1,1,5,9,9
	.half	.L249-.L234
	.byte	1,5,46,7,9
	.half	.L250-.L249
	.byte	3,2,1,5,9,9
	.half	.L55-.L250
	.byte	3,126,1,5,48,9
	.half	.L54-.L55
	.byte	3,9,1,5,46,9
	.half	.L251-.L54
	.byte	1,5,56,9
	.half	.L56-.L251
	.byte	3,4,1,5,5,9
	.half	.L252-.L56
	.byte	1,5,45,7,9
	.half	.L253-.L252
	.byte	3,3,1,5,43,9
	.half	.L254-.L253
	.byte	1,5,1,9
	.half	.L57-.L254
	.byte	3,2,1,7,9
	.half	.L78-.L57
	.byte	0,1,1
.L241:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_MainFunctionJobComplete')
	.sect	'.debug_ranges'
.L77:
	.word	-1,.L69,0,.L78-.L69,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_JobComplete_Read')
	.sect	'.debug_info'
.L79:
	.word	408
	.half	3
	.word	.L80
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainfunctionJobComplete.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L82,.L81
	.byte	2
	.word	.L70
	.byte	3
	.byte	'NvM_Prv_JobComplete_Read',0,1,92,13,1,1
	.word	.L59,.L112,.L58
	.byte	4
	.byte	'JobData_pst',0,1,92,59
	.word	.L113,.L114
	.byte	5
	.word	.L59,.L112
	.byte	6
	.word	.L115,.L116,.L117
	.byte	7
	.word	.L118,.L119
	.byte	8
	.word	.L120,.L116,.L117
	.byte	9
	.byte	'ReadRamBlockFromNvm_pfct',0,2,148,5,37
	.word	.L121,.L122
	.byte	0,0,6
	.word	.L123,.L124,.L125
	.byte	7
	.word	.L126,.L127
	.byte	10
	.word	.L128,.L124,.L125
	.byte	0,6
	.word	.L129,.L125,.L130
	.byte	7
	.word	.L131,.L132
	.byte	8
	.word	.L133,.L125,.L130
	.byte	9
	.byte	'BlockType',0,2,214,3,29
	.word	.L134,.L135
	.byte	0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_JobComplete_Read')
	.sect	'.debug_abbrev'
.L80:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,29,1,49,16,17
	.byte	1,18,1,0,0,7,5,0,49,16,2,6,0,0,8,11,1,49,16,17,1,18,1,0,0,9,52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,10
	.byte	11,0,49,16,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_JobComplete_Read')
	.sect	'.debug_line'
.L81:
	.word	.L256-.L255
.L255:
	.half	3
	.word	.L258-.L257
.L257:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainfunctionJobComplete.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockDescriptor.h',0,0,0,0,0
.L258:
	.byte	5,13,7,0,5,2
	.word	.L59
	.byte	3,219,0,1,5,37,9
	.half	.L209-.L59
	.byte	3,3,1,5,9,9
	.half	.L259-.L209
	.byte	1,5,72,7,9
	.half	.L260-.L259
	.byte	1,5,101,7,9
	.half	.L2-.L260
	.byte	3,3,1,4,2,5,62,9
	.half	.L116-.L2
	.byte	3,178,4,1,5,5,9
	.half	.L208-.L116
	.byte	3,1,1,5,65,7,9
	.half	.L261-.L208
	.byte	3,2,1,5,36,9
	.half	.L262-.L261
	.byte	1,5,65,9
	.half	.L263-.L262
	.byte	1,5,77,9
	.half	.L264-.L263
	.byte	1,5,5,9
	.half	.L4-.L264
	.byte	3,2,1,4,1,5,75,9
	.half	.L5-.L4
	.byte	3,202,123,1,5,32,9
	.half	.L117-.L5
	.byte	3,127,1,5,89,9
	.half	.L265-.L117
	.byte	1,5,13,9
	.half	.L3-.L265
	.byte	3,8,1,5,56,7,9
	.half	.L266-.L3
	.byte	3,1,1,4,2,5,46,9
	.half	.L124-.L266
	.byte	3,152,2,1,5,13,9
	.half	.L267-.L124
	.byte	1,5,56,7,9
	.half	.L268-.L267
	.byte	3,1,1,5,27,9
	.half	.L269-.L268
	.byte	1,5,56,9
	.half	.L270-.L269
	.byte	1,5,15,9
	.half	.L271-.L270
	.byte	1,5,68,9
	.half	.L272-.L271
	.byte	1,5,14,9
	.half	.L210-.L272
	.byte	1,5,15,7,9
	.half	.L273-.L210
	.byte	3,1,1,5,68,9
	.half	.L274-.L273
	.byte	1,5,24,9
	.half	.L275-.L274
	.byte	1,5,46,7,9
	.half	.L9-.L275
	.byte	3,126,1,5,5,9
	.half	.L8-.L9
	.byte	1,4,1,5,44,9
	.half	.L11-.L8
	.byte	3,232,125,1,4,2,5,39,7,9
	.half	.L125-.L11
	.byte	3,235,2,1,5,5,9
	.half	.L211-.L125
	.byte	3,1,1,5,50,7,9
	.half	.L276-.L211
	.byte	3,2,1,5,21,9
	.half	.L212-.L276
	.byte	1,5,50,9
	.half	.L277-.L212
	.byte	1,5,62,9
	.half	.L278-.L277
	.byte	1,5,5,9
	.half	.L13-.L278
	.byte	3,2,1,4,1,5,32,9
	.half	.L14-.L13
	.byte	3,145,125,1,5,30,7,9
	.half	.L130-.L14
	.byte	3,11,1,5,41,9
	.half	.L279-.L130
	.byte	3,2,1,9
	.half	.L280-.L279
	.byte	3,1,1,5,1,9
	.half	.L6-.L280
	.byte	3,3,1,7,9
	.half	.L83-.L6
	.byte	0,1,1
.L256:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_JobComplete_Read')
	.sect	'.debug_ranges'
.L82:
	.word	-1,.L59,0,.L83-.L59,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_JobComplete_Restore')
	.sect	'.debug_info'
.L84:
	.word	997
	.half	3
	.word	.L85
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainfunctionJobComplete.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L87,.L86
	.byte	2
	.word	.L70
	.byte	3
	.byte	'NvM_Prv_JobComplete_Restore',0,1,127,13,1,1
	.word	.L61,.L136,.L60
	.byte	4
	.byte	'JobData_pst',0,1,127,62
	.word	.L113,.L137
	.byte	5
	.word	.L61,.L136
	.byte	6
	.word	.L138,.L139,.L17
	.byte	7
	.word	.L140,.L141
	.byte	8
	.word	.L142,.L143
	.byte	9
	.byte	'adrRomBlock_pcv',0,2,175,4,17
	.word	.L146,.L147
	.byte	0,0,6
	.word	.L138,.L144,.L145
	.byte	7
	.word	.L140,.L141
	.byte	0,6
	.word	.L148,.L149,.L19
	.byte	7
	.word	.L150,.L151
	.byte	7
	.word	.L152,.L153
	.byte	7
	.word	.L154,.L155
	.byte	10
	.word	.L156,.L149,.L19
	.byte	9
	.byte	'adrSource_pcu8',0,1,154,2,18
	.word	.L157,.L158
	.byte	9
	.byte	'nrRemainingBlockBytes_u16',0,1,155,2,12
	.word	.L107,.L159
	.byte	9
	.byte	'nrNonVolatileBlocks_u8',0,1,156,2,11
	.word	.L160,.L161
	.byte	6
	.word	.L138,.L149,.L21
	.byte	7
	.word	.L140,.L141
	.byte	8
	.word	.L142,.L162
	.byte	9
	.byte	'adrRomBlock_pcv',0,2,175,4,17
	.word	.L146,.L167
	.byte	0,0,6
	.word	.L168,.L21,.L24
	.byte	7
	.word	.L169,.L170
	.byte	8
	.word	.L171,.L172
	.byte	9
	.byte	'BlockSize_u16',0,2,191,3,12
	.word	.L107,.L174
	.byte	0,0,6
	.word	.L175,.L24,.L26
	.byte	7
	.word	.L176,.L177
	.byte	8
	.word	.L178,.L179
	.byte	9
	.byte	'nrNvBlocks_u8',0,2,234,3,11
	.word	.L160,.L181
	.byte	0,0,6
	.word	.L129,.L26,.L180
	.byte	7
	.word	.L131,.L182
	.byte	10
	.word	.L133,.L26,.L180
	.byte	9
	.byte	'BlockType',0,2,214,3,29
	.word	.L134,.L183
	.byte	0,0,6
	.word	.L175,.L180,.L173
	.byte	7
	.word	.L176,.L177
	.byte	0,6
	.word	.L168,.L173,.L163
	.byte	7
	.word	.L169,.L170
	.byte	0,6
	.word	.L138,.L163,.L29
	.byte	7
	.word	.L140,.L141
	.byte	0,6
	.word	.L138,.L31,.L164
	.byte	7
	.word	.L140,.L141
	.byte	0,6
	.word	.L138,.L165,.L166
	.byte	7
	.word	.L140,.L141
	.byte	0,6
	.word	.L168,.L166,.L19
	.byte	7
	.word	.L169,.L170
	.byte	0,0,0,6
	.word	.L115,.L184,.L185
	.byte	7
	.word	.L118,.L186
	.byte	10
	.word	.L120,.L184,.L185
	.byte	9
	.byte	'ReadRamBlockFromNvm_pfct',0,2,148,5,37
	.word	.L121,.L187
	.byte	0,0,6
	.word	.L188,.L189,.L38
	.byte	7
	.word	.L190,.L191
	.byte	10
	.word	.L192,.L189,.L38
	.byte	9
	.byte	'RetValue',0,2,193,5,20
	.word	.L160,.L193
	.byte	0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_JobComplete_Restore')
	.sect	'.debug_abbrev'
.L85:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,29,1,49,16,17
	.byte	1,18,1,0,0,7,5,0,49,16,2,6,0,0,8,11,1,49,16,85,6,0,0,9,52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,10,11
	.byte	1,49,16,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_JobComplete_Restore')
	.sect	'.debug_line'
.L86:
	.word	.L282-.L281
.L281:
	.half	3
	.word	.L284-.L283
.L283:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainfunctionJobComplete.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockDescriptor.h',0,0,0,0,0
.L284:
	.byte	5,13,7,0,5,2
	.word	.L61
	.byte	3,254,0,1,5,59,9
	.half	.L214-.L61
	.byte	3,5,1,4,2,5,33,9
	.half	.L139-.L214
	.byte	3,171,3,1,5,5,9
	.half	.L215-.L139
	.byte	3,1,1,5,56,7,9
	.half	.L285-.L215
	.byte	3,2,1,5,27,9
	.half	.L286-.L285
	.byte	1,5,56,9
	.half	.L287-.L286
	.byte	1,5,68,9
	.half	.L288-.L287
	.byte	1,5,5,9
	.half	.L16-.L288
	.byte	3,2,1,4,1,5,9,9
	.half	.L17-.L16
	.byte	3,208,124,1,5,5,9
	.half	.L144-.L17
	.byte	1,5,44,7,9
	.half	.L145-.L144
	.byte	3,4,1,5,14,9
	.half	.L213-.L145
	.byte	1,5,53,7,9
	.half	.L289-.L213
	.byte	3,2,1,9
	.half	.L290-.L289
	.byte	3,1,1,9
	.half	.L291-.L290
	.byte	3,1,1,4,2,5,33,9
	.half	.L149-.L291
	.byte	3,163,3,1,5,5,9
	.half	.L217-.L149
	.byte	3,1,1,5,56,7,9
	.half	.L292-.L217
	.byte	3,2,1,5,27,9
	.half	.L293-.L292
	.byte	1,5,56,9
	.half	.L294-.L293
	.byte	1,5,68,9
	.half	.L295-.L294
	.byte	1,5,5,9
	.half	.L20-.L295
	.byte	3,2,1,5,26,9
	.half	.L21-.L20
	.byte	3,139,127,1,5,9,9
	.half	.L218-.L21
	.byte	3,2,1,5,51,7,9
	.half	.L296-.L218
	.byte	3,1,1,5,22,9
	.half	.L297-.L296
	.byte	1,5,51,9
	.half	.L298-.L297
	.byte	1,5,63,9
	.half	.L299-.L298
	.byte	1,5,10,9
	.half	.L300-.L299
	.byte	1,5,19,9
	.half	.L301-.L300
	.byte	1,5,25,7,9
	.half	.L302-.L301
	.byte	3,2,1,5,5,9
	.half	.L22-.L302
	.byte	3,3,1,5,25,9
	.half	.L24-.L22
	.byte	3,35,1,5,5,9
	.half	.L219-.L24
	.byte	3,1,1,5,54,7,9
	.half	.L303-.L219
	.byte	3,2,1,5,25,9
	.half	.L304-.L303
	.byte	1,5,54,9
	.half	.L305-.L304
	.byte	1,5,66,9
	.half	.L306-.L305
	.byte	1,5,5,9
	.half	.L25-.L306
	.byte	3,2,1,5,39,9
	.half	.L26-.L25
	.byte	3,103,1,5,5,9
	.half	.L220-.L26
	.byte	3,1,1,5,50,7,9
	.half	.L307-.L220
	.byte	3,2,1,5,21,9
	.half	.L221-.L307
	.byte	1,5,50,9
	.half	.L308-.L221
	.byte	1,5,62,9
	.half	.L309-.L308
	.byte	1,5,5,9
	.half	.L27-.L309
	.byte	3,2,1,4,1,9
	.half	.L28-.L27
	.byte	3,195,126,1,5,70,7,9
	.half	.L180-.L28
	.byte	3,5,1,5,53,9
	.half	.L173-.L180
	.byte	1,5,24,9
	.half	.L163-.L173
	.byte	1,5,41,9
	.half	.L29-.L163
	.byte	3,4,1,5,25,9
	.half	.L31-.L29
	.byte	3,2,1,5,23,9
	.half	.L164-.L31
	.byte	1,5,9,9
	.half	.L310-.L164
	.byte	3,1,1,9
	.half	.L165-.L310
	.byte	3,1,1,9
	.half	.L166-.L165
	.byte	3,1,1,5,41,9
	.half	.L30-.L166
	.byte	3,123,1,5,101,7,9
	.half	.L19-.L30
	.byte	3,234,126,1,4,2,5,62,9
	.half	.L184-.L19
	.byte	3,131,4,1,5,5,9
	.half	.L222-.L184
	.byte	3,1,1,5,65,7,9
	.half	.L311-.L222
	.byte	3,2,1,5,36,9
	.half	.L312-.L311
	.byte	1,5,65,9
	.half	.L313-.L312
	.byte	1,5,77,9
	.half	.L314-.L313
	.byte	1,5,5,9
	.half	.L32-.L314
	.byte	3,2,1,4,1,5,75,9
	.half	.L33-.L32
	.byte	3,249,123,1,5,32,9
	.half	.L185-.L33
	.byte	3,127,1,5,89,9
	.half	.L315-.L185
	.byte	1,5,40,9
	.half	.L18-.L315
	.byte	3,7,1,5,14,9
	.half	.L223-.L18
	.byte	1,5,68,7,9
	.half	.L316-.L223
	.byte	3,3,1,4,2,5,29,9
	.half	.L189-.L316
	.byte	3,166,4,1,5,9,9
	.half	.L224-.L189
	.byte	3,1,1,5,51,7,9
	.half	.L317-.L224
	.byte	3,1,1,5,22,9
	.half	.L318-.L317
	.byte	1,5,51,9
	.half	.L319-.L318
	.byte	1,5,63,9
	.half	.L320-.L319
	.byte	1,5,10,9
	.half	.L321-.L320
	.byte	1,5,19,9
	.half	.L322-.L321
	.byte	1,5,84,7,9
	.half	.L323-.L322
	.byte	3,2,1,5,5,9
	.half	.L36-.L323
	.byte	3,2,1,4,1,5,13,9
	.half	.L38-.L36
	.byte	3,212,123,1,5,42,7,9
	.half	.L324-.L38
	.byte	3,2,1,5,40,9
	.half	.L325-.L324
	.byte	1,5,54,9
	.half	.L326-.L325
	.byte	1,5,42,9
	.half	.L39-.L326
	.byte	3,4,1,5,40,9
	.half	.L327-.L39
	.byte	1,5,36,9
	.half	.L34-.L327
	.byte	3,5,1,5,5,9
	.half	.L328-.L34
	.byte	1,5,73,7,9
	.half	.L329-.L328
	.byte	3,10,1,5,13,9
	.half	.L330-.L329
	.byte	1,5,9,9
	.half	.L331-.L330
	.byte	1,5,30,7,9
	.half	.L332-.L331
	.byte	3,4,1,5,41,9
	.half	.L333-.L332
	.byte	3,1,1,9
	.half	.L334-.L333
	.byte	3,1,1,9
	.half	.L335-.L334
	.byte	3,1,1,5,1,9
	.half	.L41-.L335
	.byte	3,3,1,7,9
	.half	.L88-.L41
	.byte	0,1,1
.L282:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_JobComplete_Restore')
	.sect	'.debug_ranges'
.L87:
	.word	-1,.L61,0,.L88-.L61,0,0
.L143:
	.word	-1,.L61,.L139-.L61,.L17-.L61,.L144-.L61,.L145-.L61,0,0
.L162:
	.word	-1,.L61,.L149-.L61,.L21-.L61,.L163-.L61,.L29-.L61,.L31-.L61,.L164-.L61,.L165-.L61,.L166-.L61,0,0
.L172:
	.word	-1,.L61,.L21-.L61,.L24-.L61,.L173-.L61,.L163-.L61,.L166-.L61,.L19-.L61,0,0
.L179:
	.word	-1,.L61,.L24-.L61,.L26-.L61,.L180-.L61,.L173-.L61,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_JobComplete_InvalidateAllDatasets')
	.sect	'.debug_info'
.L89:
	.word	380
	.half	3
	.word	.L90
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainfunctionJobComplete.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L92,.L91
	.byte	2
	.word	.L70
	.byte	3
	.byte	'NvM_Prv_JobComplete_InvalidateAllDatasets',0,1,188,1,13,1,1
	.word	.L63,.L194,.L62
	.byte	4
	.byte	'JobData_pst',0,1,188,1,76
	.word	.L113,.L195
	.byte	5
	.word	.L63,.L194
	.byte	6
	.word	.L129,.L196,.L197
	.byte	7
	.word	.L131,.L198
	.byte	8
	.word	.L133,.L196,.L197
	.byte	9
	.byte	'BlockType',0,2,214,3,29
	.word	.L134,.L199
	.byte	0,0,6
	.word	.L175,.L197,.L48
	.byte	7
	.word	.L176,.L200
	.byte	8
	.word	.L178,.L197,.L48
	.byte	9
	.byte	'nrNvBlocks_u8',0,2,234,3,11
	.word	.L160,.L201
	.byte	0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_JobComplete_InvalidateAllDatasets')
	.sect	'.debug_abbrev'
.L90:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,29,1,49,16,17
	.byte	1,18,1,0,0,7,5,0,49,16,2,6,0,0,8,11,1,49,16,17,1,18,1,0,0,9,52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_JobComplete_InvalidateAllDatasets')
	.sect	'.debug_line'
.L91:
	.word	.L337-.L336
.L336:
	.half	3
	.word	.L339-.L338
.L338:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainfunctionJobComplete.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockDescriptor.h',0,0,0,0,0
.L339:
	.byte	5,13,7,0,5,2
	.word	.L63
	.byte	3,187,1,1,5,36,9
	.half	.L226-.L63
	.byte	3,3,1,5,5,9
	.half	.L340-.L226
	.byte	1,5,67,7,9
	.half	.L341-.L340
	.byte	3,8,1,4,2,5,39,9
	.half	.L196-.L341
	.byte	3,143,2,1,5,5,9
	.half	.L227-.L196
	.byte	3,1,1,5,50,7,9
	.half	.L342-.L227
	.byte	3,2,1,5,21,9
	.half	.L228-.L342
	.byte	1,5,50,9
	.half	.L343-.L228
	.byte	1,5,62,9
	.half	.L344-.L343
	.byte	1,5,5,9
	.half	.L44-.L344
	.byte	3,2,1,4,1,5,13,9
	.half	.L45-.L44
	.byte	3,236,125,1,4,2,5,25,7,9
	.half	.L197-.L45
	.byte	3,163,2,1,5,5,9
	.half	.L229-.L197
	.byte	3,1,1,5,54,7,9
	.half	.L345-.L229
	.byte	3,2,1,5,25,9
	.half	.L230-.L345
	.byte	1,5,54,9
	.half	.L346-.L230
	.byte	1,5,66,9
	.half	.L347-.L346
	.byte	1,5,5,9
	.half	.L47-.L347
	.byte	3,2,1,4,1,5,25,9
	.half	.L48-.L47
	.byte	3,217,125,1,5,100,9
	.half	.L348-.L48
	.byte	1,5,41,9
	.half	.L231-.L348
	.byte	1,5,77,7,9
	.half	.L349-.L231
	.byte	3,2,1,5,17,9
	.half	.L225-.L349
	.byte	1,5,13,9
	.half	.L350-.L225
	.byte	1,5,45,7,9
	.half	.L351-.L350
	.byte	3,3,1,5,34,9
	.half	.L352-.L351
	.byte	3,127,1,5,45,9
	.half	.L353-.L352
	.byte	3,2,1,9
	.half	.L354-.L353
	.byte	3,1,1,5,61,9
	.half	.L355-.L354
	.byte	1,5,65,9
	.half	.L356-.L355
	.byte	1,5,45,9
	.half	.L50-.L356
	.byte	3,5,1,5,34,9
	.half	.L357-.L50
	.byte	3,127,1,5,45,9
	.half	.L358-.L357
	.byte	3,2,1,9
	.half	.L359-.L358
	.byte	3,1,1,5,61,9
	.half	.L360-.L359
	.byte	1,5,1,9
	.half	.L43-.L360
	.byte	3,4,1,7,9
	.half	.L93-.L43
	.byte	0,1,1
.L337:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_JobComplete_InvalidateAllDatasets')
	.sect	'.debug_ranges'
.L92:
	.word	-1,.L63,0,.L93-.L63,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_JobComplete_Validate')
	.sect	'.debug_info'
.L94:
	.word	242
	.half	3
	.word	.L95
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainfunctionJobComplete.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L97,.L96
	.byte	2
	.word	.L70
	.byte	3
	.byte	'NvM_Prv_JobComplete_Validate',0,1,220,1,13,1,1
	.word	.L65,.L202,.L64
	.byte	4
	.byte	'JobData_pst',0,1,220,1,63
	.word	.L113,.L203
	.byte	5
	.word	.L65,.L202
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_JobComplete_Validate')
	.sect	'.debug_abbrev'
.L95:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_JobComplete_Validate')
	.sect	'.debug_line'
.L96:
	.word	.L362-.L361
.L361:
	.half	3
	.word	.L364-.L363
.L363:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainfunctionJobComplete.c',0,0,0,0,0
.L364:
	.byte	5,30,7,0,5,2
	.word	.L65
	.byte	3,224,1,1,5,28,9
	.half	.L365-.L65
	.byte	1,5,1,9
	.half	.L366-.L365
	.byte	3,1,1,7,9
	.half	.L98-.L366
	.byte	0,1,1
.L362:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_JobComplete_Validate')
	.sect	'.debug_ranges'
.L97:
	.word	-1,.L65,0,.L98-.L65,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_GetFctJobComplete')
	.sect	'.debug_info'
.L99:
	.word	240
	.half	3
	.word	.L100
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainfunctionJobComplete.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L102,.L101
	.byte	2
	.word	.L70
	.byte	3
	.byte	'NvM_Prv_GetFctJobComplete',0,1,228,1,34
	.word	.L110
	.byte	1,1
	.word	.L67,.L204,.L66
	.byte	4
	.byte	'idJob_en',0,1,228,1,78
	.word	.L205,.L206
	.byte	5
	.word	.L67,.L204
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_GetFctJobComplete')
	.sect	'.debug_abbrev'
.L100:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_GetFctJobComplete')
	.sect	'.debug_line'
.L101:
	.word	.L368-.L367
.L367:
	.half	3
	.word	.L370-.L369
.L369:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainfunctionJobComplete.c',0,0,0,0,0
.L370:
	.byte	5,21,7,0,5,2
	.word	.L67
	.byte	3,229,1,1,5,5,9
	.half	.L371-.L67
	.byte	1,5,18,9
	.half	.L372-.L371
	.byte	3,2,1,5,12,9
	.half	.L52-.L372
	.byte	3,2,1,5,42,9
	.half	.L373-.L52
	.byte	1,5,5,9
	.half	.L374-.L373
	.byte	1,5,1,9
	.half	.L53-.L374
	.byte	3,1,1,7,9
	.half	.L103-.L53
	.byte	0,1,1
.L368:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_GetFctJobComplete')
	.sect	'.debug_ranges'
.L102:
	.word	-1,.L67,0,.L103-.L67,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_JobCompleteFcts_capfct')
	.sect	'.debug_info'
.L104:
	.word	196
	.half	3
	.word	.L105
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainfunctionJobComplete.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1,2
	.word	.L70
	.byte	3
	.byte	'NvM_Prv_JobCompleteFcts_capfct',0,4,66,40
	.word	.L207
	.byte	5,3
	.word	NvM_Prv_JobCompleteFcts_capfct
	.byte	0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_JobCompleteFcts_capfct')
	.sect	'.debug_abbrev'
.L105:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,0,0,2,61,0,24,16,0,0,3,52,0,3,8,58,15,59,15,57,15,73,16,2,9,0,0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_GetFctJobComplete')
	.sect	'.debug_loc'
.L66:
	.word	-1,.L67,0,.L204-.L67
	.half	2
	.byte	138,0
	.word	0,0
.L206:
	.word	-1,.L67,0,.L204-.L67
	.half	1
	.byte	84
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_JobComplete_InvalidateAllDatasets')
	.sect	'.debug_loc'
.L199:
	.word	-1,.L63,.L227-.L63,.L228-.L63
	.half	1
	.byte	95
	.word	.L44-.L63,.L229-.L63
	.half	1
	.byte	95
	.word	0,0
.L195:
	.word	-1,.L63,0,.L225-.L63
	.half	1
	.byte	100
	.word	.L226-.L63,.L194-.L63
	.half	1
	.byte	111
	.word	0,0
.L62:
	.word	-1,.L63,0,.L194-.L63
	.half	2
	.byte	138,0
	.word	0,0
.L198:
	.word	0,0
.L200:
	.word	0,0
.L201:
	.word	-1,.L63,.L229-.L63,.L230-.L63
	.half	1
	.byte	95
	.word	.L47-.L63,.L231-.L63
	.half	1
	.byte	95
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_JobComplete_Read')
	.sect	'.debug_loc'
.L135:
	.word	-1,.L59,.L211-.L59,.L212-.L59
	.half	1
	.byte	95
	.word	.L13-.L59,.L6-.L59
	.half	1
	.byte	95
	.word	0,0
.L114:
	.word	-1,.L59,0,.L208-.L59
	.half	1
	.byte	100
	.word	.L209-.L59,.L112-.L59
	.half	1
	.byte	108
	.word	.L3-.L59,.L210-.L59
	.half	1
	.byte	100
	.word	0,0
.L58:
	.word	-1,.L59,0,.L112-.L59
	.half	2
	.byte	138,0
	.word	0,0
.L122:
	.word	-1,.L59,.L208-.L59,.L117-.L59
	.half	1
	.byte	100
	.word	0,0
.L127:
	.word	0,0
.L132:
	.word	0,0
.L119:
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_JobComplete_Restore')
	.sect	'.debug_loc'
.L174:
	.word	-1,.L61,.L218-.L61,.L19-.L61
	.half	1
	.byte	82
	.word	0,0
.L183:
	.word	-1,.L61,.L220-.L61,.L221-.L61
	.half	1
	.byte	95
	.word	.L27-.L61,.L31-.L61
	.half	1
	.byte	95
	.word	0,0
.L137:
	.word	-1,.L61,0,.L213-.L61
	.half	1
	.byte	100
	.word	.L214-.L61,.L136-.L61
	.half	1
	.byte	108
	.word	.L18-.L61,.L223-.L61
	.half	1
	.byte	100
	.word	0,0
.L60:
	.word	-1,.L61,0,.L136-.L61
	.half	2
	.byte	138,0
	.word	0,0
.L153:
	.word	0,0
.L187:
	.word	-1,.L61,.L222-.L61,.L185-.L61
	.half	1
	.byte	100
	.word	0,0
.L193:
	.word	-1,.L61,.L224-.L61,.L34-.L61
	.half	1
	.byte	82
	.word	0,0
.L147:
	.word	-1,.L61,.L215-.L61,.L216-.L61
	.half	1
	.byte	98
	.word	.L16-.L61,.L213-.L61
	.half	1
	.byte	98
	.word	.L18-.L61,.L223-.L61
	.half	1
	.byte	98
	.word	0,0
.L167:
	.word	-1,.L61,.L217-.L61,.L19-.L61
	.half	1
	.byte	101
	.word	0,0
.L158:
	.word	0,0
.L151:
	.word	0,0
.L170:
	.word	0,0
.L182:
	.word	0,0
.L177:
	.word	0,0
.L141:
	.word	0,0
.L186:
	.word	0,0
.L191:
	.word	0,0
.L155:
	.word	0,0
.L161:
	.word	0,0
.L181:
	.word	-1,.L61,.L219-.L61,.L19-.L61
	.half	1
	.byte	83
	.word	0,0
.L159:
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_JobComplete_Validate')
	.sect	'.debug_loc'
.L203:
	.word	-1,.L65,0,.L202-.L65
	.half	1
	.byte	100
	.word	0,0
.L64:
	.word	-1,.L65,0,.L202-.L65
	.half	2
	.byte	138,0
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_MainFunctionJobComplete')
	.sect	'.debug_loc'
.L111:
	.word	-1,.L69,.L234-.L69,.L55-.L69
	.half	1
	.byte	98
	.word	0,0
.L68:
	.word	-1,.L69,0,.L106-.L69
	.half	2
	.byte	138,0
	.word	0,0
.L108:
	.word	-1,.L69,.L232-.L69,.L233-.L69
	.half	1
	.byte	85
	.word	0,0
	.sdecl	'.debug_frame',debug
	.sect	'.debug_frame'
.L375:
	.word	48
	.word	-1
	.byte	3,0,2,1,27,12,26,0,8,27,8,26,8,28,8,29,8,30,8,31,8,34,8,35,8,32,8,33,8,16,8,17,8,24,8,25,8,36,8,37,8,38
	.byte	8,39
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_JobComplete_Read')
	.sect	'.debug_frame'
	.word	12
	.word	.L375,.L59,.L112-.L59
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_JobComplete_Restore')
	.sect	'.debug_frame'
	.word	12
	.word	.L375,.L61,.L136-.L61
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_JobComplete_InvalidateAllDatasets')
	.sect	'.debug_frame'
	.word	12
	.word	.L375,.L63,.L194-.L63
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_JobComplete_Validate')
	.sect	'.debug_frame'
	.word	24
	.word	.L375,.L65,.L202-.L65
	.byte	8,18,8,19,8,21,8,22,8,23,0,0
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_GetFctJobComplete')
	.sect	'.debug_frame'
	.word	24
	.word	.L375,.L67,.L204-.L67
	.byte	8,19,8,20,8,21,8,22,8,23,0,0
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_MainFunctionJobComplete')
	.sect	'.debug_frame'
	.word	12
	.word	.L375,.L69,.L106-.L69

; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   301      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainfunctionJobComplete.c	   302  }

	; Module end
