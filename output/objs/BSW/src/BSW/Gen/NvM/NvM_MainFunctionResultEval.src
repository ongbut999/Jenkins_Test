	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 19053136 SN 09001910"
	.compiler_invocation	"ctc -f cc15416a -c99 --integer-enumeration -D__CPU__=tc27x -D__CPU_TC27X__ --core=tc1.6.x --eabi-compliant --fp-model=-float -D_TASKING_C_TRICORE_=1 -I.\\output\\inc -g2 -t4 --language=-comments,-gcc,+volatile,-strings --default-near-size=0 -O2ROPYGKLF-predict --default-a1-size=0 --default-a0-size=0 --source --switch=auto -o output\\objs\\BSW\\src\\BSW\\Gen\\NvM\\NvM_MainFunctionResultEval.src BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c"
	.compiler_name		"ctc"
	;source	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c'

	
$TC16X
	
	.sdecl	'.text.NvM_MainFunctionResultEval.NvM_Prv_EvalReqResult',code,cluster('NvM_Prv_EvalReqResult')
	.sect	'.text.NvM_MainFunctionResultEval.NvM_Prv_EvalReqResult'
	.align	2
	

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	     2  /*
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	     3   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	     4   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	     5   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	     6   */
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	     7  #include "NvM.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	     8  #include "NvM_Cfg_SchM.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	     9  #include "Rte_NvM.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    10  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    11  #include "NvM_Prv.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    12  #include "NvM_Prv_Queue.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    13  #include "NvM_Prv_BlockData.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    14  #include "NvM_Prv_ErrorDetection.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    15  #include "NvM_Prv_ProcessMultiBlock.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    16  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    17  /*
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    18   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    19   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    20   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    21   */
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    22  typedef NvM_RequestResultType (*NvM_Prv_JobEvalReqResult_tpfct)(NvM_Prv_JobData_tst const* JobData_pcst);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    23  typedef uint8 (*NvM_Prv_JobEvalProductionErrors_tpfct)(NvM_Prv_JobData_tst const* JobData_pcst);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    24  typedef void (*NvM_Prv_JobUpdateBlockStatus_tpfct)(NvM_Prv_JobData_tst const* JobData_pcst);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    25  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    26  /*
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    28   * Local declarations
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    29   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    30   */
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    31  static NvM_RequestResultType NvM_Prv_EvalReqResult(NvM_Prv_JobData_tst const* JobData_pcst);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    32  static NvM_RequestResultType NvM_Prv_EvalReqResult_Read(NvM_Prv_JobData_tst const* JobData_pcst);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    33  static NvM_RequestResultType NvM_Prv_EvalReqResult_InvalidateForRemoveNonResistant(NvM_Prv_JobData_tst const* JobData_pcst);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    34  static NvM_RequestResultType NvM_Prv_EvalReqResult_RestoreForImplicitRecovery(NvM_Prv_JobData_tst const* JobData_pcst);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    35  static NvM_RequestResultType NvM_Prv_EvalReqResult_ReadIdConfigForReadAll(NvM_Prv_JobData_tst const* JobData_pcst);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    36  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    37  static uint8 NvM_Prv_EvalProductionErrors(NvM_Prv_JobData_tst const* JobData_pcst);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    38  static uint8 NvM_Prv_EvalProductionErrors_Read(NvM_Prv_JobData_tst const* JobData_pcst);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    39  static uint8 NvM_Prv_EvalProductionErrors_ReadIdConfigForReadAll(NvM_Prv_JobData_tst const* JobData_pcst);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    40  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    41  static void NvM_Prv_UpdateBlockStatus_Restore(NvM_Prv_JobData_tst const* JobData_pcst);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    42  static void NvM_Prv_UpdateBlockStatus_ReadWrite(NvM_Prv_JobData_tst const* JobData_pcst);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    43  static void NvM_Prv_UpdateBlockStatusJobValidate(NvM_Prv_JobData_tst const* JobData_pcst);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    44  static void NvM_Prv_UpdateBlockStatusIdConfigForReadAll(NvM_Prv_JobData_tst const* JobData_pcst);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    46  static NvM_Prv_JobEvalReqResult_tpfct NvM_Prv_GetFctJobEvalReqResult(NvM_Prv_idJob_ten idJob_en);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    47  static NvM_Prv_JobEvalProductionErrors_tpfct NvM_Prv_GetFctJobEvalProductionErrors(NvM_Prv_idJob_ten idJob_en);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    48  static NvM_Prv_JobUpdateBlockStatus_tpfct NvM_Prv_GetFctJobUpdateBlockStatus(NvM_Prv_idJob_ten idJob_en);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    49  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    50  /*
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    51   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    52   * Inline declarations
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    53   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    54   */
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    55  LOCAL_INLINE boolean NvM_Prv_EvalCommonResults(NvM_Prv_JobData_tst const* JobData_pcst,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    56                                                 NvM_RequestResultType* stReqResult_puo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    57                                                 uint8* stProductionErrors_pu8);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    58  LOCAL_INLINE void NvM_Prv_MainFunctionResultEval_FinalBlockCallbacks(NvM_RequestResultType stRequestResult_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    59                                                                       NvM_BlockIdType idActiveBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    60                                                                       NvM_Prv_idService_tuo idActiveService_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    61  LOCAL_INLINE void NvM_Prv_MainFunctionResultEval_ResetMainStates(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    62                                                                   NvM_Prv_idQueue_tuo idQueue_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    63                                                                   NvM_Prv_idService_tuo idService_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    64                                                                   NvM_Prv_ServiceBit_tuo ServiceBit_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    65                                                                   NvM_RequestResultType stRequestResult_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    66  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    67  /*
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    68   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    69   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    70   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    71   */
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    72  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    74  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    75  #define NvM_Prv_EvalResult_Idle_pfct                            NULL_PTR
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    76  #define NvM_Prv_EvalResult_Read_pfct                            NvM_Prv_EvalReqResult_Read
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    77  #define NvM_Prv_EvalResult_Write_pfct                           NvM_Prv_EvalReqResult
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    78  #define NvM_Prv_EvalResult_Erase_pfct                           NvM_Prv_EvalReqResult
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    79  #define NvM_Prv_EvalResult_Restore_pfct                         NvM_Prv_EvalReqResult
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    80  #define NvM_Prv_EvalResult_Maintain_pfct                        NULL_PTR
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    81  #define NvM_Prv_EvalResult_Validate_pfct                        NvM_Prv_EvalReqResult
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    82  #define NvM_Prv_EvalResult_Invalidate_pfct                      NvM_Prv_EvalReqResult
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    83  #define NvM_Prv_EvalResult_ReadIdConfigForReadAll_pfct          NvM_Prv_EvalReqResult_ReadIdConfigForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    84  #define NvM_Prv_EvalResult_InvalidateForFirstInitAll_pfct       NvM_Prv_EvalReqResult
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    85  #define NvM_Prv_EvalResult_RestoreForImplicitRecovery_pfct      NvM_Prv_EvalReqResult_RestoreForImplicitRecovery
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    86  #define NvM_Prv_EvalResult_InvalidateForRemoveNonResistant_pfct NvM_Prv_EvalReqResult_InvalidateForRemoveNonResistant
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    87  #define NvM_Prv_EvalResult_Invalid_pfct                         NULL_PTR
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    88  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    89  /**
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    90   * Function-like macro: LIST_ENTRY_JOB_EVAL_REQ_RESULT_FCT
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    91   *
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    92   * This macro generates an entry for a function to evaluate request result in a list of all jobs provided by NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    93   * s.a. macro LIST_ID_JOB to generate a list for all jobs provided by NvM
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    94   *
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    95   * Paramater:
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    96   * Name: name of the job for which a function will be generated.
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    97   */
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    98  #define LIST_ENTRY_JOB_EVAL_REQ_RESULT_FCT(Name)        NvM_Prv_EvalResult_##Name##_pfct,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	    99  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   100  static NvM_Prv_JobEvalReqResult_tpfct const NvM_Prv_JobEvalReqResultFcts_capfct[NvM_Prv_idJob_Count_e] =
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   101  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   102      LIST_ID_JOB(LIST_ENTRY_JOB_EVAL_REQ_RESULT_FCT)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   103  };
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   104  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   105  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   106  #define NvM_Prv_EvalProdErrors_Idle_pfct                            NULL_PTR
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   107  #define NvM_Prv_EvalProdErrors_Read_pfct                            NvM_Prv_EvalProductionErrors_Read
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   108  #define NvM_Prv_EvalProdErrors_Write_pfct                           NvM_Prv_EvalProductionErrors
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   109  #define NvM_Prv_EvalProdErrors_Erase_pfct                           NvM_Prv_EvalProductionErrors
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   110  #define NvM_Prv_EvalProdErrors_Restore_pfct                         NvM_Prv_EvalProductionErrors
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   111  #define NvM_Prv_EvalProdErrors_Maintain_pfct                        NULL_PTR
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   112  #define NvM_Prv_EvalProdErrors_Validate_pfct                        NvM_Prv_EvalProductionErrors
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   113  #define NvM_Prv_EvalProdErrors_Invalidate_pfct                      NvM_Prv_EvalProductionErrors
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   114  #define NvM_Prv_EvalProdErrors_ReadIdConfigForReadAll_pfct          NvM_Prv_EvalProductionErrors_ReadIdConfigForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   115  #define NvM_Prv_EvalProdErrors_InvalidateForFirstInitAll_pfct       NvM_Prv_EvalProductionErrors
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   116  #define NvM_Prv_EvalProdErrors_RestoreForImplicitRecovery_pfct      NvM_Prv_EvalProductionErrors
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   117  #define NvM_Prv_EvalProdErrors_InvalidateForRemoveNonResistant_pfct NvM_Prv_EvalProductionErrors
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   118  #define NvM_Prv_EvalProdErrors_Invalid_pfct                         NULL_PTR
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   120  /**
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   121   * Function-like macro: LIST_ENTRY_JOB_EVAL_PROD_ERRORS_FCT
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   122   *
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   123   * This macro generates an entry for a function to evaluate production errors in a list of all jobs provided by NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   124   * s.a. macro LIST_ID_JOB to generate a list for all jobs provided by NvM
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   125   *
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   126   * Paramater:
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   127   * Name: name of the job for which a function will be generated.
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   128   */
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   129  #define LIST_ENTRY_JOB_EVAL_PROD_ERRORS_FCT(Name)       NvM_Prv_EvalProdErrors_##Name##_pfct,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   130  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   131  static NvM_Prv_JobEvalProductionErrors_tpfct const NvM_Prv_JobEvalProductionErrorsFcts_capfct[NvM_Prv_idJob_Count_e] =
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   132  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   133      LIST_ID_JOB(LIST_ENTRY_JOB_EVAL_PROD_ERRORS_FCT)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   134  };
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   135  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   136  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   137  #define NvM_Prv_UpdateStatus_Idle_pfct                              NULL_PTR
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   138  #define NvM_Prv_UpdateStatus_Read_pfct                              NvM_Prv_UpdateBlockStatus_ReadWrite
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   139  #define NvM_Prv_UpdateStatus_Write_pfct                             NvM_Prv_UpdateBlockStatus_ReadWrite
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   140  #define NvM_Prv_UpdateStatus_Erase_pfct                             NULL_PTR
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   141  #define NvM_Prv_UpdateStatus_Restore_pfct                           NvM_Prv_UpdateBlockStatus_Restore
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   142  #define NvM_Prv_UpdateStatus_Maintain_pfct                          NULL_PTR
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   143  #define NvM_Prv_UpdateStatus_Validate_pfct                          NvM_Prv_UpdateBlockStatusJobValidate
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   144  #define NvM_Prv_UpdateStatus_Invalidate_pfct                        NULL_PTR
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   145  #define NvM_Prv_UpdateStatus_ReadIdConfigForReadAll_pfct            NvM_Prv_UpdateBlockStatusIdConfigForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   146  #define NvM_Prv_UpdateStatus_InvalidateForFirstInitAll_pfct         NULL_PTR
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   147  #define NvM_Prv_UpdateStatus_RestoreForImplicitRecovery_pfct        NvM_Prv_UpdateBlockStatus_Restore
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   148  #define NvM_Prv_UpdateStatus_InvalidateForRemoveNonResistant_pfct   NULL_PTR
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   149  #define NvM_Prv_UpdateStatus_Invalid_pfct                           NULL_PTR
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   150  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   151  /**
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   152   * Function-like macro: LIST_ENTRY_JOB_UPDATE_BLOCK_STATUS_FCT
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   153   *
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   154   * This macro generates an entry for a function to update block status in a list of all jobs provided by NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   155   * s.a. macro LIST_ID_JOB to generate a list for all jobs provided by NvM
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   156   *
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   157   * Paramater:
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   158   * Name: name of the job for which a function will be generated.
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   159   */
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   160  #define LIST_ENTRY_JOB_UPDATE_BLOCK_STATUS_FCT(Name)    NvM_Prv_UpdateStatus_##Name##_pfct,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   161  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   162  static NvM_Prv_JobUpdateBlockStatus_tpfct const NvM_Prv_JobUpdateBlockStatusFcts_capfct[NvM_Prv_idJob_Count_e] =
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   163  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   164      LIST_ID_JOB(LIST_ENTRY_JOB_UPDATE_BLOCK_STATUS_FCT)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   165  };
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   166  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   167  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   168  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   169  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   170  /*
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   171   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   172   * NvM-private code
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   173   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   174   */
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   175  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   176  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   177  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   178  static NvM_RequestResultType NvM_Prv_EvalReqResult(NvM_Prv_JobData_tst const* JobData_pcst)
; Function NvM_Prv_EvalReqResult
.L87:
NvM_Prv_EvalReqResult:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   179  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   180      NvM_RequestResultType stRequestResult_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   181  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   182      if (MEMIF_JOB_OK == JobData_pcst->Result_en)
	ld.w	d15,[a4]16
.L521:
	ne	d2,d15,#0
.L405:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   183      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   184          stRequestResult_uo = NVM_REQ_OK;
	j	.L3
.L2:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   185      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   186      else
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   187      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   188          stRequestResult_uo = NVM_REQ_NOT_OK;
	mov	d2,#1
.L3:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   189      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   190      return stRequestResult_uo;
	j	.L4

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   191  }
.L4:
	ret
.L299:
	
__NvM_Prv_EvalReqResult_function_end:
	.size	NvM_Prv_EvalReqResult,__NvM_Prv_EvalReqResult_function_end-NvM_Prv_EvalReqResult
.L131:
	; End of function
	
	.sdecl	'.text.NvM_MainFunctionResultEval.NvM_Prv_EvalReqResult_Read',code,cluster('NvM_Prv_EvalReqResult_Read')
	.sect	'.text.NvM_MainFunctionResultEval.NvM_Prv_EvalReqResult_Read'
	.align	2
	

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   192  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   193  static NvM_RequestResultType NvM_Prv_EvalReqResult_Read(NvM_Prv_JobData_tst const* JobData_pcst)
; Function NvM_Prv_EvalReqResult_Read
.L89:
NvM_Prv_EvalReqResult_Read:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   194  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   195      NvM_RequestResultType stRequestResult_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   196      if (MEMIF_JOB_OK == JobData_pcst->Result_en)
	ld.w	d15,[a4]16
.L526:
	jne	d15,#0,.L5
.L527:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   197      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   198          stRequestResult_uo = NVM_REQ_OK;
	mov	d2,#0
.L406:
	j	.L6
.L5:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   199      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   200      else if (MEMIF_BLOCK_INVALID == JobData_pcst->Result_en)
	jne	d15,#5,.L7
.L528:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   201      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   202          stRequestResult_uo = NVM_REQ_NV_INVALIDATED;
	mov	d2,#5
.L407:
	j	.L8
.L7:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   203      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   204      else if (MEMIF_BLOCK_INCONSISTENT == JobData_pcst->Result_en)
	jne	d15,#4,.L9
.L529:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   205      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   206          stRequestResult_uo = NVM_REQ_INTEGRITY_FAILED;
	mov	d2,#3
.L408:
	j	.L10
.L9:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   207      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   208      else if (MEMIF_JOB_FAILED == JobData_pcst->Result_en)
	eq	d15,d15,#1
.L530:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   209      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   210          stRequestResult_uo = NVM_REQ_NOT_OK;
	mov	d2,#1
.L409:
	cmovn	d2,d15,#1
.L531:
	j	.L12
.L11:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   211      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   212      else // (MEMIF_JOB_CANCELED == JobData_pst->Result_en)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   213      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   214          stRequestResult_uo = NVM_REQ_NOT_OK;
	mov	d2,#1
.L12:
.L10:
.L8:
.L6:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   215      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   216      return stRequestResult_uo;
	j	.L13

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   217  }
.L13:
	ret
.L303:
	
__NvM_Prv_EvalReqResult_Read_function_end:
	.size	NvM_Prv_EvalReqResult_Read,__NvM_Prv_EvalReqResult_Read_function_end-NvM_Prv_EvalReqResult_Read
.L136:
	; End of function
	
	.sdecl	'.text.NvM_MainFunctionResultEval.NvM_Prv_EvalReqResult_InvalidateForRemoveNonResistant',code,cluster('NvM_Prv_EvalReqResult_InvalidateForRemoveNonResistant')
	.sect	'.text.NvM_MainFunctionResultEval.NvM_Prv_EvalReqResult_InvalidateForRemoveNonResistant'
	.align	2
	

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   218  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   219  static NvM_RequestResultType NvM_Prv_EvalReqResult_InvalidateForRemoveNonResistant(NvM_Prv_JobData_tst const* JobData_pcst)
; Function NvM_Prv_EvalReqResult_InvalidateForRemoveNonResistant
.L91:
NvM_Prv_EvalReqResult_InvalidateForRemoveNonResistant:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   220  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   221      NvM_RequestResultType stRequestResult_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   222      if (MEMIF_JOB_OK == JobData_pcst->Result_en)
	ld.w	d15,[a4]16
.L536:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   223      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   224          stRequestResult_uo = NVM_REQ_NV_INVALIDATED;
	mov	d2,#5
.L410:
	cmov	d2,d15,#1
.L537:
	j	.L15
.L14:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   225      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   226      else
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   227      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   228          stRequestResult_uo = NVM_REQ_NOT_OK;
	mov	d2,#1
.L15:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   229      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   230      return stRequestResult_uo;
	j	.L16

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   231  }
.L16:
	ret
.L306:
	
__NvM_Prv_EvalReqResult_InvalidateForRemoveNonResistant_function_end:
	.size	NvM_Prv_EvalReqResult_InvalidateForRemoveNonResistant,__NvM_Prv_EvalReqResult_InvalidateForRemoveNonResistant_function_end-NvM_Prv_EvalReqResult_InvalidateForRemoveNonResistant
.L141:
	; End of function
	
	.sdecl	'.text.NvM_MainFunctionResultEval.NvM_Prv_EvalReqResult_RestoreForImplicitRecovery',code,cluster('NvM_Prv_EvalReqResult_RestoreForImplicitRecovery')
	.sect	'.text.NvM_MainFunctionResultEval.NvM_Prv_EvalReqResult_RestoreForImplicitRecovery'
	.align	2
	

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   232  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   233  static NvM_RequestResultType NvM_Prv_EvalReqResult_RestoreForImplicitRecovery(NvM_Prv_JobData_tst const* JobData_pcst)
; Function NvM_Prv_EvalReqResult_RestoreForImplicitRecovery
.L93:
NvM_Prv_EvalReqResult_RestoreForImplicitRecovery:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   234  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   235      NvM_RequestResultType stRequestResult_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   236      if (MEMIF_JOB_OK == JobData_pcst->Result_en)
	ld.w	d15,[a4]16
.L542:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   237      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   238          stRequestResult_uo = NVM_REQ_RESTORED_FROM_ROM;
	mov	d2,#8
.L411:
	cmov	d2,d15,#1
.L543:
	j	.L18
.L17:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   239      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   240      else
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   241      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   242          stRequestResult_uo = NVM_REQ_NOT_OK;
	mov	d2,#1
.L18:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   243      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   244      return stRequestResult_uo;
	j	.L19

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   245  }
.L19:
	ret
.L309:
	
__NvM_Prv_EvalReqResult_RestoreForImplicitRecovery_function_end:
	.size	NvM_Prv_EvalReqResult_RestoreForImplicitRecovery,__NvM_Prv_EvalReqResult_RestoreForImplicitRecovery_function_end-NvM_Prv_EvalReqResult_RestoreForImplicitRecovery
.L146:
	; End of function
	
	.sdecl	'.text.NvM_MainFunctionResultEval.NvM_Prv_EvalReqResult_ReadIdConfigForReadAll',code,cluster('NvM_Prv_EvalReqResult_ReadIdConfigForReadAll')
	.sect	'.text.NvM_MainFunctionResultEval.NvM_Prv_EvalReqResult_ReadIdConfigForReadAll'
	.align	2
	

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   246  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   247  static NvM_RequestResultType NvM_Prv_EvalReqResult_ReadIdConfigForReadAll(NvM_Prv_JobData_tst const* JobData_pcst)
; Function NvM_Prv_EvalReqResult_ReadIdConfigForReadAll
.L95:
NvM_Prv_EvalReqResult_ReadIdConfigForReadAll:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   248  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   249      NvM_RequestResultType stRequestResult_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   250  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   251  #if ((NVM_RB_REMOVE_NON_RESISTANT_BLOCKS == STD_ON) || (NVM_RB_INIT_AT_LAYOUT_CHANGE == STD_ON))
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   252      boolean isInitAtLayoutChangeRequired_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   253      boolean isRemoveNonResistantRequired_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   254  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   255  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   256      if (MEMIF_JOB_OK == JobData_pcst->Result_en)
	ld.w	d15,[a4]16
.L548:
	jne	d15,#0,.L20
.L316:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   169  LOCAL_INLINE boolean NvM_Prv_Block_IsRequestPending(NvM_BlockIdType idBlock_uo, uint16 maskService_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   170  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   172  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   173  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   174  LOCAL_INLINE boolean NvM_Prv_Block_IsPending(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   175  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   176      return (NvM_Prv_Block_IsNvmEnqueuingForMulti(idBlock_uo) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   177              ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != 0)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   178  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   179                && (NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != (1u << NvM_Prv_ServiceBit_Maintain_e))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   180  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   181              )
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   182             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   183  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   184  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   185  LOCAL_INLINE void NvM_Prv_Block_SetIdxData(NvM_BlockIdType idBlock_uo, uint8 idxData_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   186  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   187      NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] = idxData_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   188  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   189  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   190  LOCAL_INLINE void NvM_Prv_Block_SetRequestResult(NvM_BlockIdType idBlock_uo, NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   191  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   192      NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo] = Result_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   193  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   194  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   195  LOCAL_INLINE void NvM_Prv_Block_SetRequest(NvM_BlockIdType idBlock_uo, NvM_Prv_ServiceBit_tuo ServiceBit_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   196  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   197      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= (1u << ServiceBit_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   198  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   199  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   200  LOCAL_INLINE void NvM_Prv_Block_SetRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   201  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   202      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= maskRequests_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   203  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   204  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   205  LOCAL_INLINE void NvM_Prv_Block_ClearRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   206  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   207      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] &= (~maskRequests_u16);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   208  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   209  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   210  LOCAL_INLINE void NvM_Prv_Block_SetState(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   211                                           uint8 maskBitsToChange_u8,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   212                                           uint8 maskBitsNewValue_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   213  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   214      NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] = ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & (~maskBitsToChange_u8)) |
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   215                                               (maskBitsNewValue_u8 & maskBitsToChange_u8));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   216  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   217  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   218  LOCAL_INLINE boolean NvM_Prv_Block_HasIdConfigChanged(void)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   219  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   220      return (NVM_COMPILED_CONFIG_ID != NvM_Prv_idConfigStored_rMwM_u16);
	movh.a	a15,#@his(NvM_Prv_idConfigStored_rMwM_u16)
	lea	a15,[a15]@los(NvM_Prv_idConfigStored_rMwM_u16)
	ld.hu	d15,[a15]0
.L549:
	ne	d15,d15,#0
.L550:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   220      return (NVM_COMPILED_CONFIG_ID != NvM_Prv_idConfigStored_rMwM_u16);      (inlined)
	j	.L21

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   221  }      (inlined)
.L21:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   257      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   258          if (NvM_Prv_Block_HasIdConfigChanged())
	ne	d2,d15,#0
.L412:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   259          {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   260              stRequestResult_uo = NVM_REQ_NOT_OK;
	j	.L23
.L22:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   261  #if (NVM_RB_INIT_AT_LAYOUT_CHANGE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   262              isInitAtLayoutChangeRequired_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   263  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   264  #if (NVM_RB_REMOVE_NON_RESISTANT_BLOCKS == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   265              isRemoveNonResistantRequired_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   266  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   267          }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   268          else
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   269          {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   270              stRequestResult_uo = NVM_REQ_OK;
	mov	d2,#0
.L23:
	j	.L24
.L20:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   271          }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   272      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   273      else if (MEMIF_BLOCK_INVALID == JobData_pcst->Result_en)
	jne	d15,#5,.L25
.L551:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   274      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   275          stRequestResult_uo = NVM_REQ_NV_INVALIDATED;
	mov	d2,#5
.L413:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   276          // set ConfigID to compiled value to signal that ConfigId has not changed and to avoid writing it
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   277          NvM_Prv_Block_SetIdConfig(NVM_COMPILED_CONFIG_ID);
	mov	d15,#0
.L319:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   169  LOCAL_INLINE boolean NvM_Prv_Block_IsRequestPending(NvM_BlockIdType idBlock_uo, uint16 maskService_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   170  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   172  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   173  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   174  LOCAL_INLINE boolean NvM_Prv_Block_IsPending(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   175  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   176      return (NvM_Prv_Block_IsNvmEnqueuingForMulti(idBlock_uo) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   177              ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != 0)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   178  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   179                && (NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != (1u << NvM_Prv_ServiceBit_Maintain_e))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   180  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   181              )
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   182             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   183  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   184  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   185  LOCAL_INLINE void NvM_Prv_Block_SetIdxData(NvM_BlockIdType idBlock_uo, uint8 idxData_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   186  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   187      NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] = idxData_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   188  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   189  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   190  LOCAL_INLINE void NvM_Prv_Block_SetRequestResult(NvM_BlockIdType idBlock_uo, NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   191  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   192      NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo] = Result_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   193  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   194  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   195  LOCAL_INLINE void NvM_Prv_Block_SetRequest(NvM_BlockIdType idBlock_uo, NvM_Prv_ServiceBit_tuo ServiceBit_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   196  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   197      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= (1u << ServiceBit_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   198  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   199  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   200  LOCAL_INLINE void NvM_Prv_Block_SetRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   201  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   202      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= maskRequests_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   203  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   204  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   205  LOCAL_INLINE void NvM_Prv_Block_ClearRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   206  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   207      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] &= (~maskRequests_u16);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   208  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   209  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   210  LOCAL_INLINE void NvM_Prv_Block_SetState(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   211                                           uint8 maskBitsToChange_u8,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   212                                           uint8 maskBitsNewValue_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   213  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   214      NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] = ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & (~maskBitsToChange_u8)) |
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   215                                               (maskBitsNewValue_u8 & maskBitsToChange_u8));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   216  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   217  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   218  LOCAL_INLINE boolean NvM_Prv_Block_HasIdConfigChanged(void)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   219  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   220      return (NVM_COMPILED_CONFIG_ID != NvM_Prv_idConfigStored_rMwM_u16);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   221  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   222  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   223  LOCAL_INLINE void NvM_Prv_Block_SetIdConfig(uint16 idConfigNew_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   224  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   225      NvM_Prv_idConfigStored_rMwM_u16 = idConfigNew_u16;
	movh.a	a15,#@his(NvM_Prv_idConfigStored_rMwM_u16)
	lea	a15,[a15]@los(NvM_Prv_idConfigStored_rMwM_u16)
.L552:
	st.h	[a15],d15
.L320:
	j	.L26
.L25:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   278  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   279  #if (NVM_RB_INIT_AT_LAYOUT_CHANGE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   280          isInitAtLayoutChangeRequired_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   281  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   282  #if (NVM_RB_REMOVE_NON_RESISTANT_BLOCKS == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   283          isRemoveNonResistantRequired_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   284  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   285      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   286      else if (MEMIF_BLOCK_INCONSISTENT == JobData_pcst->Result_en)
	jne	d15,#4,.L27
.L553:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   287      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   288          stRequestResult_uo = NVM_REQ_NV_INVALIDATED;
	mov	d2,#5
.L414:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   289          // set ConfigID to signal that ConfigId has changed and to trigger writing it
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   290          NvM_Prv_Block_SetIdConfig(~((uint16)NVM_COMPILED_CONFIG_ID));
	mov.u	d15,#65535
.L324:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   169  LOCAL_INLINE boolean NvM_Prv_Block_IsRequestPending(NvM_BlockIdType idBlock_uo, uint16 maskService_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   170  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   172  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   173  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   174  LOCAL_INLINE boolean NvM_Prv_Block_IsPending(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   175  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   176      return (NvM_Prv_Block_IsNvmEnqueuingForMulti(idBlock_uo) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   177              ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != 0)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   178  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   179                && (NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != (1u << NvM_Prv_ServiceBit_Maintain_e))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   180  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   181              )
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   182             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   183  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   184  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   185  LOCAL_INLINE void NvM_Prv_Block_SetIdxData(NvM_BlockIdType idBlock_uo, uint8 idxData_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   186  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   187      NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] = idxData_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   188  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   189  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   190  LOCAL_INLINE void NvM_Prv_Block_SetRequestResult(NvM_BlockIdType idBlock_uo, NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   191  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   192      NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo] = Result_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   193  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   194  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   195  LOCAL_INLINE void NvM_Prv_Block_SetRequest(NvM_BlockIdType idBlock_uo, NvM_Prv_ServiceBit_tuo ServiceBit_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   196  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   197      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= (1u << ServiceBit_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   198  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   199  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   200  LOCAL_INLINE void NvM_Prv_Block_SetRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   201  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   202      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= maskRequests_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   203  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   204  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   205  LOCAL_INLINE void NvM_Prv_Block_ClearRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   206  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   207      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] &= (~maskRequests_u16);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   208  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   209  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   210  LOCAL_INLINE void NvM_Prv_Block_SetState(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   211                                           uint8 maskBitsToChange_u8,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   212                                           uint8 maskBitsNewValue_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   213  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   214      NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] = ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & (~maskBitsToChange_u8)) |
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   215                                               (maskBitsNewValue_u8 & maskBitsToChange_u8));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   216  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   217  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   218  LOCAL_INLINE boolean NvM_Prv_Block_HasIdConfigChanged(void)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   219  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   220      return (NVM_COMPILED_CONFIG_ID != NvM_Prv_idConfigStored_rMwM_u16);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   221  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   222  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   223  LOCAL_INLINE void NvM_Prv_Block_SetIdConfig(uint16 idConfigNew_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   224  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   225      NvM_Prv_idConfigStored_rMwM_u16 = idConfigNew_u16;
	movh.a	a15,#@his(NvM_Prv_idConfigStored_rMwM_u16)
	lea	a15,[a15]@los(NvM_Prv_idConfigStored_rMwM_u16)
.L554:
	st.h	[a15],d15
.L325:
	j	.L28
.L27:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   291  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   292  #if (NVM_RB_INIT_AT_LAYOUT_CHANGE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   293          isInitAtLayoutChangeRequired_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   294  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   295  #if (NVM_RB_REMOVE_NON_RESISTANT_BLOCKS == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   296          isRemoveNonResistantRequired_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   297  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   298      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   299      else if (MEMIF_JOB_FAILED == JobData_pcst->Result_en)
	jne	d15,#1,.L29
.L555:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   300      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   301          stRequestResult_uo = NVM_REQ_INTEGRITY_FAILED;
	mov	d2,#3
.L415:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   302          // set ConfigID to signal that ConfigId has changed and to trigger writing it
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   303          NvM_Prv_Block_SetIdConfig(~((uint16)NVM_COMPILED_CONFIG_ID));
	mov.u	d15,#65535
.L326:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   169  LOCAL_INLINE boolean NvM_Prv_Block_IsRequestPending(NvM_BlockIdType idBlock_uo, uint16 maskService_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   170  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   172  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   173  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   174  LOCAL_INLINE boolean NvM_Prv_Block_IsPending(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   175  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   176      return (NvM_Prv_Block_IsNvmEnqueuingForMulti(idBlock_uo) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   177              ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != 0)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   178  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   179                && (NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != (1u << NvM_Prv_ServiceBit_Maintain_e))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   180  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   181              )
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   182             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   183  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   184  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   185  LOCAL_INLINE void NvM_Prv_Block_SetIdxData(NvM_BlockIdType idBlock_uo, uint8 idxData_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   186  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   187      NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] = idxData_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   188  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   189  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   190  LOCAL_INLINE void NvM_Prv_Block_SetRequestResult(NvM_BlockIdType idBlock_uo, NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   191  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   192      NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo] = Result_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   193  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   194  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   195  LOCAL_INLINE void NvM_Prv_Block_SetRequest(NvM_BlockIdType idBlock_uo, NvM_Prv_ServiceBit_tuo ServiceBit_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   196  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   197      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= (1u << ServiceBit_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   198  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   199  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   200  LOCAL_INLINE void NvM_Prv_Block_SetRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   201  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   202      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= maskRequests_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   203  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   204  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   205  LOCAL_INLINE void NvM_Prv_Block_ClearRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   206  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   207      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] &= (~maskRequests_u16);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   208  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   209  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   210  LOCAL_INLINE void NvM_Prv_Block_SetState(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   211                                           uint8 maskBitsToChange_u8,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   212                                           uint8 maskBitsNewValue_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   213  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   214      NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] = ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & (~maskBitsToChange_u8)) |
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   215                                               (maskBitsNewValue_u8 & maskBitsToChange_u8));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   216  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   217  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   218  LOCAL_INLINE boolean NvM_Prv_Block_HasIdConfigChanged(void)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   219  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   220      return (NVM_COMPILED_CONFIG_ID != NvM_Prv_idConfigStored_rMwM_u16);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   221  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   222  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   223  LOCAL_INLINE void NvM_Prv_Block_SetIdConfig(uint16 idConfigNew_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   224  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   225      NvM_Prv_idConfigStored_rMwM_u16 = idConfigNew_u16;
	movh.a	a15,#@his(NvM_Prv_idConfigStored_rMwM_u16)
	lea	a15,[a15]@los(NvM_Prv_idConfigStored_rMwM_u16)
.L556:
	st.h	[a15],d15
.L327:
	j	.L30
.L29:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   304  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   305  #if (NVM_RB_INIT_AT_LAYOUT_CHANGE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   306          isInitAtLayoutChangeRequired_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   307  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   308  #if (NVM_RB_REMOVE_NON_RESISTANT_BLOCKS == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   309          isRemoveNonResistantRequired_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   310  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   311      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   312      else // MEMIF_JOB_CANCELED
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   313      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   314          stRequestResult_uo = NVM_REQ_NOT_OK;
	mov	d2,#1
.L416:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   315          // set ConfigID to compiled value to signal that ConfigId has not changed and to avoid writing it
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   316          NvM_Prv_Block_SetIdConfig(NVM_COMPILED_CONFIG_ID);
	mov	d15,#0
.L328:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   169  LOCAL_INLINE boolean NvM_Prv_Block_IsRequestPending(NvM_BlockIdType idBlock_uo, uint16 maskService_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   170  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   172  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   173  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   174  LOCAL_INLINE boolean NvM_Prv_Block_IsPending(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   175  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   176      return (NvM_Prv_Block_IsNvmEnqueuingForMulti(idBlock_uo) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   177              ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != 0)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   178  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   179                && (NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != (1u << NvM_Prv_ServiceBit_Maintain_e))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   180  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   181              )
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   182             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   183  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   184  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   185  LOCAL_INLINE void NvM_Prv_Block_SetIdxData(NvM_BlockIdType idBlock_uo, uint8 idxData_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   186  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   187      NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] = idxData_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   188  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   189  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   190  LOCAL_INLINE void NvM_Prv_Block_SetRequestResult(NvM_BlockIdType idBlock_uo, NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   191  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   192      NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo] = Result_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   193  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   194  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   195  LOCAL_INLINE void NvM_Prv_Block_SetRequest(NvM_BlockIdType idBlock_uo, NvM_Prv_ServiceBit_tuo ServiceBit_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   196  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   197      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= (1u << ServiceBit_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   198  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   199  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   200  LOCAL_INLINE void NvM_Prv_Block_SetRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   201  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   202      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= maskRequests_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   203  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   204  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   205  LOCAL_INLINE void NvM_Prv_Block_ClearRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   206  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   207      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] &= (~maskRequests_u16);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   208  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   209  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   210  LOCAL_INLINE void NvM_Prv_Block_SetState(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   211                                           uint8 maskBitsToChange_u8,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   212                                           uint8 maskBitsNewValue_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   213  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   214      NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] = ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & (~maskBitsToChange_u8)) |
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   215                                               (maskBitsNewValue_u8 & maskBitsToChange_u8));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   216  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   217  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   218  LOCAL_INLINE boolean NvM_Prv_Block_HasIdConfigChanged(void)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   219  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   220      return (NVM_COMPILED_CONFIG_ID != NvM_Prv_idConfigStored_rMwM_u16);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   221  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   222  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   223  LOCAL_INLINE void NvM_Prv_Block_SetIdConfig(uint16 idConfigNew_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   224  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   225      NvM_Prv_idConfigStored_rMwM_u16 = idConfigNew_u16;
	movh.a	a15,#@his(NvM_Prv_idConfigStored_rMwM_u16)
	lea	a15,[a15]@los(NvM_Prv_idConfigStored_rMwM_u16)
.L557:
	st.h	[a15],d15
.L30:
.L28:
.L26:
.L24:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   317      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   319  #if ((NVM_RB_REMOVE_NON_RESISTANT_BLOCKS == STD_ON) || (NVM_RB_INIT_AT_LAYOUT_CHANGE == STD_ON))
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   320      NvM_Prv_InitAfterReadAll(isInitAtLayoutChangeRequired_b,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   321                               isRemoveNonResistantRequired_b);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   322  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   323  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   324      return stRequestResult_uo;
	j	.L31

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   325  }
.L31:
	ret
.L312:
	
__NvM_Prv_EvalReqResult_ReadIdConfigForReadAll_function_end:
	.size	NvM_Prv_EvalReqResult_ReadIdConfigForReadAll,__NvM_Prv_EvalReqResult_ReadIdConfigForReadAll_function_end-NvM_Prv_EvalReqResult_ReadIdConfigForReadAll
.L151:
	; End of function
	
	.sdecl	'.text.NvM_MainFunctionResultEval.NvM_Prv_EvalProductionErrors',code,cluster('NvM_Prv_EvalProductionErrors')
	.sect	'.text.NvM_MainFunctionResultEval.NvM_Prv_EvalProductionErrors'
	.align	2
	

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   326  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   327  static uint8 NvM_Prv_EvalProductionErrors(NvM_Prv_JobData_tst const* JobData_pcst)
; Function NvM_Prv_EvalProductionErrors
.L97:
NvM_Prv_EvalProductionErrors:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   328  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   329      uint8 stProductionErrors_u8 = 0;
	mov	d2,#0
.L417:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   330      if (MEMIF_JOB_OK != JobData_pcst->Result_en)
	ld.w	d15,[a4]16
.L562:
	jeq	d15,#0,.L32
.L563:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   331      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   332          stProductionErrors_u8 |= NVM_E_REQ_FAILED;
	or	d2,d2,#64
.L32:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   333      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   334      return stProductionErrors_u8;
	j	.L33

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   335  }
.L33:
	ret
.L329:
	
__NvM_Prv_EvalProductionErrors_function_end:
	.size	NvM_Prv_EvalProductionErrors,__NvM_Prv_EvalProductionErrors_function_end-NvM_Prv_EvalProductionErrors
.L156:
	; End of function
	
	.sdecl	'.text.NvM_MainFunctionResultEval.NvM_Prv_EvalProductionErrors_Read',code,cluster('NvM_Prv_EvalProductionErrors_Read')
	.sect	'.text.NvM_MainFunctionResultEval.NvM_Prv_EvalProductionErrors_Read'
	.align	2
	

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   336  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   337  static uint8 NvM_Prv_EvalProductionErrors_Read(NvM_Prv_JobData_tst const* JobData_pcst)
; Function NvM_Prv_EvalProductionErrors_Read
.L99:
NvM_Prv_EvalProductionErrors_Read:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   338  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   339      uint8 stProductionErrors_u8 = 0;
	mov	d0,#0
.L418:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   340      if (MEMIF_BLOCK_INCONSISTENT == JobData_pcst->Result_en)
	ld.w	d15,[a4]16
.L568:
	jne	d15,#4,.L34
.L569:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   341      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   342          stProductionErrors_u8 |= NVM_E_INTEGRITY_FAILED;
	or	d2,d0,#32
.L419:
	j	.L35
.L34:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   343      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   344      else if (MEMIF_JOB_FAILED == JobData_pcst->Result_en)
	jne	d15,#1,.L36
.L570:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   345      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   346          stProductionErrors_u8 |= NVM_E_REQ_FAILED;
	or	d2,d0,#64
.L420:
	j	.L37
.L36:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   347      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   348      else
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   349      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   350          // no production errors shall be reported
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   351          stProductionErrors_u8 = 0;
	mov	d2,#0
.L37:
.L35:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   352      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   353      return stProductionErrors_u8;
	j	.L38

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   354  }
.L38:
	ret
.L332:
	
__NvM_Prv_EvalProductionErrors_Read_function_end:
	.size	NvM_Prv_EvalProductionErrors_Read,__NvM_Prv_EvalProductionErrors_Read_function_end-NvM_Prv_EvalProductionErrors_Read
.L161:
	; End of function
	
	.sdecl	'.text.NvM_MainFunctionResultEval.NvM_Prv_EvalProductionErrors_ReadIdConfigForReadAll',code,cluster('NvM_Prv_EvalProductionErrors_ReadIdConfigForReadAll')
	.sect	'.text.NvM_MainFunctionResultEval.NvM_Prv_EvalProductionErrors_ReadIdConfigForReadAll'
	.align	2
	

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   355  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   356  static uint8 NvM_Prv_EvalProductionErrors_ReadIdConfigForReadAll(NvM_Prv_JobData_tst const* JobData_pcst)
; Function NvM_Prv_EvalProductionErrors_ReadIdConfigForReadAll
.L101:
NvM_Prv_EvalProductionErrors_ReadIdConfigForReadAll:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   357  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   358      uint8 stProductionErrors_u8 = 0;
	mov	d2,#0
.L421:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   359      if (MEMIF_JOB_FAILED == JobData_pcst->Result_en)
	ld.w	d15,[a4]16
.L575:
	jne	d15,#1,.L39
.L576:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   360      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   361          stProductionErrors_u8 |= NVM_E_REQ_FAILED;
	or	d2,d2,#64
.L39:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   362      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   363      return stProductionErrors_u8;
	j	.L40

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   364  }
.L40:
	ret
.L335:
	
__NvM_Prv_EvalProductionErrors_ReadIdConfigForReadAll_function_end:
	.size	NvM_Prv_EvalProductionErrors_ReadIdConfigForReadAll,__NvM_Prv_EvalProductionErrors_ReadIdConfigForReadAll_function_end-NvM_Prv_EvalProductionErrors_ReadIdConfigForReadAll
.L166:
	; End of function
	
	.sdecl	'.text.NvM_MainFunctionResultEval.NvM_Prv_UpdateBlockStatus_Restore',code,cluster('NvM_Prv_UpdateBlockStatus_Restore')
	.sect	'.text.NvM_MainFunctionResultEval.NvM_Prv_UpdateBlockStatus_Restore'
	.align	2
	

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   365  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   366  static void NvM_Prv_UpdateBlockStatus_Restore(NvM_Prv_JobData_tst const* JobData_pcst)
; Function NvM_Prv_UpdateBlockStatus_Restore
.L103:
NvM_Prv_UpdateBlockStatus_Restore:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   367  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   368      if (MEMIF_JOB_OK == JobData_pcst->Result_en)
	ld.w	d15,[a4]16
.L581:
	jne	d15,#0,.L41
.L582:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   369      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   370          if (JobData_pcst->RamBlock_pu8 == NvM_Prv_GetPRamBlockAddress(JobData_pcst->idBlock_uo))
	ld.hu	d0,[a4]4
.L341:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   392  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   393   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   394   * This NvM private function checks for the given block whether the configured block length is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   395   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   396   * \param idBlock
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   397   * ID of the block for which the block length will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   398   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   399   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   400   * - TRUE = block length is valid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   401   * - FALSE = block length is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   402   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   403  LOCAL_INLINE boolean NvM_Prv_IsBlockLengthValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   404  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   405      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   406              (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   407              (0u != *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   408  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   409  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   410  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   411   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   412   * This NvM private function checks whether the given block is configured with immediate priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   413   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   414   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   415   * ID of the block for which the priority will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   416   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   417   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   418   * - TRUE = block is configured with immediate priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   419   * - FALSE = block is configured with standard priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   420   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   421  LOCAL_INLINE boolean NvM_Prv_HasBlockImmediateJobPriority(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   423      boolean HasBlockImmediateJobPriority_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   425  #if (NVM_JOB_PRIORITIZATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   426      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   427          (NVM_PRV_JOB_PRIORITY_IMMEDIATE == NvM_Prv_BlockDescriptors_acst[idBlock_uo].JobPriority_u8))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   428      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   429          HasBlockImmediateJobPriority_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   430      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   431  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   433  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   434  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   435  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   436   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   437   * This NvM private function returns the configured block size for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   438   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   439   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   440   * ID of the block for which the configured block size will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   441   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   442   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   443   * Configured block size
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   444   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   445  LOCAL_INLINE uint16 NvM_Prv_GetBlockSize(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   446  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   447      uint16 BlockSize_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   448  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   451      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   452          BlockSize_u16 = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   453      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   454  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   455      return BlockSize_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   456  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   457  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   458  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   459   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   460   * This NvM private function returns the configured block management type for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   461   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   462   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   463   * ID of the block for which the configured block management type will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   464   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   465   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   466   * Configured block management type
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   467   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   468  LOCAL_INLINE NvM_BlockManagementType NvM_Prv_GetBlockType(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   469  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   470      NvM_BlockManagementType BlockType = NVM_BLOCK_NATIVE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   472      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   473          BlockType = NvM_Prv_BlockDescriptors_acst[idBlock_uo].BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   474      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   475      return BlockType;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   476  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   477  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   478  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   479   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   480   * This NvM private function returns the configured number of non-volatile data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   481   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   482   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   483   * ID of the block for which the configured number of non-volatile data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   484   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   485   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   486   * Configured number of non-volatile data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   487   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   488  LOCAL_INLINE uint8 NvM_Prv_GetNrNonVolatileBlocks(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   489  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   490      uint8 nrNvBlocks_u8 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   491      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   492      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   493          nrNvBlocks_u8 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   494      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   495      return nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   496  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   497  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   498  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   499   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   500   * This NvM private function returns the configured overall number of data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   501   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   502   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   503   * ID of the block for which the configured overall number of data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   504   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   505   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   506   * Configured number of data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   507   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   508  LOCAL_INLINE uint16 NvM_Prv_GetNrDataIndexes(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   509  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   510      uint8 nrDataIndexes = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   511      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   512      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   513          nrDataIndexes = (NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8 +
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   514                           NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrRomBlocks_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   515      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   516      return nrDataIndexes;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   517  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   518  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   519  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   520   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   521   * This NvM private function returns the pointer to the configured permanent RAM block for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   522   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   523   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   524   * If no permanent RAM block is configured for a block then this function returns a NULL pointer.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   525   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   526   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   527   * ID of the block for which the pointer to the configured permanent RAM block will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   528   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   529   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   530   * Pointer to the configured permanent RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   531   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   532  LOCAL_INLINE void * NvM_Prv_GetPRamBlockAddress(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   533  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   534      void * PRamBlockAddress_pv = NULL_PTR;
	mov.a	a2,#0
.L422:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   535      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
	jge.u	d0,#14,.L42
.L583:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   535      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   536          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv))
	mul	d15,d0,#48
.L584:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L585:
	addsc.a	a15,a15,d15,#0
.L586:
	ld.a	a15,[a15]12
.L587:
	mov.a	a5,#0
.L588:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   536          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv))      (inlined)
	jeq.a	a5,a15,.L43
.L589:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   537      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   538          PRamBlockAddress_pv = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv;
	ld.a	a2,[a15]

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   535      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
.L43:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   536          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv))      (inlined)
.L42:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   541      return PRamBlockAddress_pv;      (inlined)
	j	.L44

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   542  }      (inlined)
.L44:
	ld.a	a15,[a4]8
.L346:
	jne.a	a15,a2,.L45
.L347:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   371          {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   372              NvM_Prv_Block_SetState(JobData_pcst->idBlock_uo, NVM_BLOCK_STATE_RAM_MASK, NVM_BLOCK_STATE_RAM_VALID_CHANGED);
	mov	d1,#3
.L590:
	mov	d15,#3
.L351:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   169  LOCAL_INLINE boolean NvM_Prv_Block_IsRequestPending(NvM_BlockIdType idBlock_uo, uint16 maskService_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   170  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   172  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   173  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   174  LOCAL_INLINE boolean NvM_Prv_Block_IsPending(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   175  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   176      return (NvM_Prv_Block_IsNvmEnqueuingForMulti(idBlock_uo) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   177              ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != 0)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   178  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   179                && (NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != (1u << NvM_Prv_ServiceBit_Maintain_e))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   180  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   181              )
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   182             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   183  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   184  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   185  LOCAL_INLINE void NvM_Prv_Block_SetIdxData(NvM_BlockIdType idBlock_uo, uint8 idxData_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   186  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   187      NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] = idxData_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   188  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   189  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   190  LOCAL_INLINE void NvM_Prv_Block_SetRequestResult(NvM_BlockIdType idBlock_uo, NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   191  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   192      NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo] = Result_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   193  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   194  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   195  LOCAL_INLINE void NvM_Prv_Block_SetRequest(NvM_BlockIdType idBlock_uo, NvM_Prv_ServiceBit_tuo ServiceBit_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   196  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   197      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= (1u << ServiceBit_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   198  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   199  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   200  LOCAL_INLINE void NvM_Prv_Block_SetRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   201  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   202      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= maskRequests_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   203  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   204  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   205  LOCAL_INLINE void NvM_Prv_Block_ClearRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   206  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   207      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] &= (~maskRequests_u16);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   208  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   209  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   210  LOCAL_INLINE void NvM_Prv_Block_SetState(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   211                                           uint8 maskBitsToChange_u8,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   212                                           uint8 maskBitsNewValue_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   213  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   214      NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] = ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & (~maskBitsToChange_u8)) |
	movh.a	a15,#@his(NvM_Prv_stBlock_rAwAM_au8)
	lea	a15,[a15]@los(NvM_Prv_stBlock_rAwAM_au8)
.L591:
	addsc.a	a15,a15,d0,#0
	ld.bu	d0,[a15]
.L592:
	xor	d1,d1,#255
.L593:
	and	d0,d1
.L594:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   215                                               (maskBitsNewValue_u8 & maskBitsToChange_u8));
	and	d15,#3
.L595:
	or	d0,d15
.L596:
	st.b	[a15],d0
.L45:
.L41:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   373          }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   374      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   375  }
	ret
.L338:
	
__NvM_Prv_UpdateBlockStatus_Restore_function_end:
	.size	NvM_Prv_UpdateBlockStatus_Restore,__NvM_Prv_UpdateBlockStatus_Restore_function_end-NvM_Prv_UpdateBlockStatus_Restore
.L171:
	; End of function
	
	.sdecl	'.text.NvM_MainFunctionResultEval.NvM_Prv_UpdateBlockStatus_ReadWrite',code,cluster('NvM_Prv_UpdateBlockStatus_ReadWrite')
	.sect	'.text.NvM_MainFunctionResultEval.NvM_Prv_UpdateBlockStatus_ReadWrite'
	.align	2
	

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   376  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   377  static void NvM_Prv_UpdateBlockStatus_ReadWrite(NvM_Prv_JobData_tst const* JobData_pcst)
; Function NvM_Prv_UpdateBlockStatus_ReadWrite
.L105:
NvM_Prv_UpdateBlockStatus_ReadWrite:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   378  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   379      if (MEMIF_JOB_OK == JobData_pcst->Result_en)
	ld.w	d15,[a4]16
.L601:
	jne	d15,#0,.L46
.L602:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   380      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   381          if (JobData_pcst->RamBlock_pu8 == NvM_Prv_GetPRamBlockAddress(JobData_pcst->idBlock_uo))
	ld.hu	d0,[a4]4
.L361:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   392  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   393   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   394   * This NvM private function checks for the given block whether the configured block length is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   395   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   396   * \param idBlock
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   397   * ID of the block for which the block length will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   398   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   399   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   400   * - TRUE = block length is valid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   401   * - FALSE = block length is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   402   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   403  LOCAL_INLINE boolean NvM_Prv_IsBlockLengthValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   404  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   405      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   406              (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   407              (0u != *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   408  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   409  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   410  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   411   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   412   * This NvM private function checks whether the given block is configured with immediate priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   413   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   414   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   415   * ID of the block for which the priority will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   416   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   417   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   418   * - TRUE = block is configured with immediate priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   419   * - FALSE = block is configured with standard priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   420   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   421  LOCAL_INLINE boolean NvM_Prv_HasBlockImmediateJobPriority(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   423      boolean HasBlockImmediateJobPriority_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   425  #if (NVM_JOB_PRIORITIZATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   426      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   427          (NVM_PRV_JOB_PRIORITY_IMMEDIATE == NvM_Prv_BlockDescriptors_acst[idBlock_uo].JobPriority_u8))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   428      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   429          HasBlockImmediateJobPriority_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   430      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   431  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   433  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   434  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   435  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   436   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   437   * This NvM private function returns the configured block size for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   438   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   439   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   440   * ID of the block for which the configured block size will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   441   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   442   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   443   * Configured block size
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   444   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   445  LOCAL_INLINE uint16 NvM_Prv_GetBlockSize(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   446  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   447      uint16 BlockSize_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   448  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   451      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   452          BlockSize_u16 = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   453      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   454  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   455      return BlockSize_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   456  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   457  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   458  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   459   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   460   * This NvM private function returns the configured block management type for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   461   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   462   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   463   * ID of the block for which the configured block management type will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   464   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   465   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   466   * Configured block management type
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   467   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   468  LOCAL_INLINE NvM_BlockManagementType NvM_Prv_GetBlockType(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   469  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   470      NvM_BlockManagementType BlockType = NVM_BLOCK_NATIVE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   472      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   473          BlockType = NvM_Prv_BlockDescriptors_acst[idBlock_uo].BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   474      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   475      return BlockType;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   476  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   477  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   478  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   479   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   480   * This NvM private function returns the configured number of non-volatile data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   481   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   482   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   483   * ID of the block for which the configured number of non-volatile data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   484   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   485   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   486   * Configured number of non-volatile data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   487   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   488  LOCAL_INLINE uint8 NvM_Prv_GetNrNonVolatileBlocks(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   489  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   490      uint8 nrNvBlocks_u8 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   491      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   492      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   493          nrNvBlocks_u8 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   494      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   495      return nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   496  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   497  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   498  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   499   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   500   * This NvM private function returns the configured overall number of data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   501   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   502   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   503   * ID of the block for which the configured overall number of data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   504   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   505   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   506   * Configured number of data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   507   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   508  LOCAL_INLINE uint16 NvM_Prv_GetNrDataIndexes(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   509  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   510      uint8 nrDataIndexes = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   511      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   512      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   513          nrDataIndexes = (NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8 +
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   514                           NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrRomBlocks_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   515      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   516      return nrDataIndexes;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   517  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   518  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   519  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   520   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   521   * This NvM private function returns the pointer to the configured permanent RAM block for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   522   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   523   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   524   * If no permanent RAM block is configured for a block then this function returns a NULL pointer.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   525   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   526   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   527   * ID of the block for which the pointer to the configured permanent RAM block will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   528   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   529   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   530   * Pointer to the configured permanent RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   531   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   532  LOCAL_INLINE void * NvM_Prv_GetPRamBlockAddress(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   533  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   534      void * PRamBlockAddress_pv = NULL_PTR;
	mov.a	a2,#0
.L423:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   535      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
	jge.u	d0,#14,.L47
.L603:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   535      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   536          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv))
	mul	d15,d0,#48
.L604:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L605:
	addsc.a	a15,a15,d15,#0
.L606:
	ld.a	a15,[a15]12
.L607:
	mov.a	a5,#0
.L608:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   536          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv))      (inlined)
	jeq.a	a5,a15,.L48
.L609:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   537      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   538          PRamBlockAddress_pv = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv;
	ld.a	a2,[a15]

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   535      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
.L48:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   536          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv))      (inlined)
.L47:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   541      return PRamBlockAddress_pv;      (inlined)
	j	.L49

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   542  }      (inlined)
.L49:
	ld.a	a15,[a4]8
.L364:
	jne.a	a15,a2,.L50
.L365:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   382          {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   383              NvM_Prv_Block_SetState(JobData_pcst->idBlock_uo, NVM_BLOCK_STATE_RAM_MASK, NVM_BLOCK_STATE_RAM_VALID);
	mov	d1,#3
.L610:
	mov	d15,#1
.L367:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   169  LOCAL_INLINE boolean NvM_Prv_Block_IsRequestPending(NvM_BlockIdType idBlock_uo, uint16 maskService_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   170  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   172  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   173  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   174  LOCAL_INLINE boolean NvM_Prv_Block_IsPending(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   175  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   176      return (NvM_Prv_Block_IsNvmEnqueuingForMulti(idBlock_uo) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   177              ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != 0)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   178  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   179                && (NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != (1u << NvM_Prv_ServiceBit_Maintain_e))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   180  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   181              )
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   182             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   183  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   184  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   185  LOCAL_INLINE void NvM_Prv_Block_SetIdxData(NvM_BlockIdType idBlock_uo, uint8 idxData_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   186  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   187      NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] = idxData_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   188  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   189  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   190  LOCAL_INLINE void NvM_Prv_Block_SetRequestResult(NvM_BlockIdType idBlock_uo, NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   191  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   192      NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo] = Result_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   193  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   194  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   195  LOCAL_INLINE void NvM_Prv_Block_SetRequest(NvM_BlockIdType idBlock_uo, NvM_Prv_ServiceBit_tuo ServiceBit_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   196  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   197      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= (1u << ServiceBit_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   198  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   199  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   200  LOCAL_INLINE void NvM_Prv_Block_SetRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   201  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   202      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= maskRequests_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   203  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   204  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   205  LOCAL_INLINE void NvM_Prv_Block_ClearRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   206  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   207      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] &= (~maskRequests_u16);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   208  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   209  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   210  LOCAL_INLINE void NvM_Prv_Block_SetState(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   211                                           uint8 maskBitsToChange_u8,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   212                                           uint8 maskBitsNewValue_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   213  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   214      NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] = ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & (~maskBitsToChange_u8)) |
	movh.a	a15,#@his(NvM_Prv_stBlock_rAwAM_au8)
	lea	a15,[a15]@los(NvM_Prv_stBlock_rAwAM_au8)
.L611:
	addsc.a	a15,a15,d0,#0
	ld.bu	d0,[a15]
.L612:
	xor	d1,d1,#255
.L613:
	and	d0,d1
.L614:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   215                                               (maskBitsNewValue_u8 & maskBitsToChange_u8));
	and	d15,#3
.L615:
	or	d0,d15
.L616:
	st.b	[a15],d0
.L50:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   384          }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   385          if (NvM_Prv_IsBlockSelected(JobData_pcst->idBlock_uo, NVM_PRV_BLOCK_FLAG_WRITE_ONCE))
	ld.hu	d0,[a4]4
.L617:
	mov	d15,#32
.L372:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
	mov	d1,#0
.L618:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
	jge.u	d0,#14,.L51
.L619:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
	mul	d2,d0,#48
.L620:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L621:
	addsc.a	a15,a15,d2,#0
.L622:
	ld.hu	d2,[a15]46
.L623:
	and	d2,d15
.L624:
	seln	d1,d2,d1,#1

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
.L52:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));      (inlined)
.L51:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
	j	.L53

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }      (inlined)
.L53:
	jeq	d1,#0,.L54
.L373:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   386          {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   387              NvM_Prv_Block_SetState(JobData_pcst->idBlock_uo, NVM_BLOCK_STATE_WRITE_PROT, NVM_BLOCK_STATE_WRITE_PROT);
	mov	d1,#8
.L625:
	mov	d15,#8
.L379:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   169  LOCAL_INLINE boolean NvM_Prv_Block_IsRequestPending(NvM_BlockIdType idBlock_uo, uint16 maskService_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   170  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   172  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   173  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   174  LOCAL_INLINE boolean NvM_Prv_Block_IsPending(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   175  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   176      return (NvM_Prv_Block_IsNvmEnqueuingForMulti(idBlock_uo) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   177              ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != 0)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   178  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   179                && (NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != (1u << NvM_Prv_ServiceBit_Maintain_e))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   180  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   181              )
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   182             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   183  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   184  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   185  LOCAL_INLINE void NvM_Prv_Block_SetIdxData(NvM_BlockIdType idBlock_uo, uint8 idxData_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   186  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   187      NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] = idxData_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   188  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   189  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   190  LOCAL_INLINE void NvM_Prv_Block_SetRequestResult(NvM_BlockIdType idBlock_uo, NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   191  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   192      NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo] = Result_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   193  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   194  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   195  LOCAL_INLINE void NvM_Prv_Block_SetRequest(NvM_BlockIdType idBlock_uo, NvM_Prv_ServiceBit_tuo ServiceBit_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   196  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   197      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= (1u << ServiceBit_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   198  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   199  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   200  LOCAL_INLINE void NvM_Prv_Block_SetRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   201  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   202      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= maskRequests_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   203  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   204  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   205  LOCAL_INLINE void NvM_Prv_Block_ClearRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   206  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   207      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] &= (~maskRequests_u16);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   208  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   209  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   210  LOCAL_INLINE void NvM_Prv_Block_SetState(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   211                                           uint8 maskBitsToChange_u8,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   212                                           uint8 maskBitsNewValue_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   213  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   214      NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] = ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & (~maskBitsToChange_u8)) |
	movh.a	a15,#@his(NvM_Prv_stBlock_rAwAM_au8)
	lea	a15,[a15]@los(NvM_Prv_stBlock_rAwAM_au8)
.L626:
	addsc.a	a15,a15,d0,#0
	ld.bu	d0,[a15]
.L627:
	xor	d1,d1,#255
.L628:
	and	d0,d1
.L629:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   215                                               (maskBitsNewValue_u8 & maskBitsToChange_u8));
	and	d15,#8
.L630:
	or	d0,d15
.L631:
	st.b	[a15],d0
.L54:
.L46:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   388          }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   389      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   390  }
	ret
.L359:
	
__NvM_Prv_UpdateBlockStatus_ReadWrite_function_end:
	.size	NvM_Prv_UpdateBlockStatus_ReadWrite,__NvM_Prv_UpdateBlockStatus_ReadWrite_function_end-NvM_Prv_UpdateBlockStatus_ReadWrite
.L176:
	; End of function
	
	.sdecl	'.text.NvM_MainFunctionResultEval.NvM_Prv_UpdateBlockStatusJobValidate',code,cluster('NvM_Prv_UpdateBlockStatusJobValidate')
	.sect	'.text.NvM_MainFunctionResultEval.NvM_Prv_UpdateBlockStatusJobValidate'
	.align	2
	

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   392  static void NvM_Prv_UpdateBlockStatusJobValidate(NvM_Prv_JobData_tst const* JobData_pcst)
; Function NvM_Prv_UpdateBlockStatusJobValidate
.L107:
NvM_Prv_UpdateBlockStatusJobValidate:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   393  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   394      if (MEMIF_JOB_OK == JobData_pcst->Result_en)
	ld.w	d15,[a4]16
.L636:
	jne	d15,#0,.L55
.L637:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   395      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   396          NvM_Prv_Block_SetState(JobData_pcst->idBlock_uo, NVM_BLOCK_STATE_RAM_CHANGED, NVM_BLOCK_STATE_RAM_CHANGED);
	ld.hu	d15,[a4]4
.L638:
	mov	d0,#2
.L639:
	mov	d1,#2
.L382:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   169  LOCAL_INLINE boolean NvM_Prv_Block_IsRequestPending(NvM_BlockIdType idBlock_uo, uint16 maskService_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   170  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   172  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   173  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   174  LOCAL_INLINE boolean NvM_Prv_Block_IsPending(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   175  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   176      return (NvM_Prv_Block_IsNvmEnqueuingForMulti(idBlock_uo) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   177              ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != 0)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   178  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   179                && (NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != (1u << NvM_Prv_ServiceBit_Maintain_e))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   180  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   181              )
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   182             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   183  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   184  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   185  LOCAL_INLINE void NvM_Prv_Block_SetIdxData(NvM_BlockIdType idBlock_uo, uint8 idxData_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   186  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   187      NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] = idxData_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   188  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   189  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   190  LOCAL_INLINE void NvM_Prv_Block_SetRequestResult(NvM_BlockIdType idBlock_uo, NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   191  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   192      NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo] = Result_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   193  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   194  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   195  LOCAL_INLINE void NvM_Prv_Block_SetRequest(NvM_BlockIdType idBlock_uo, NvM_Prv_ServiceBit_tuo ServiceBit_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   196  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   197      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= (1u << ServiceBit_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   198  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   199  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   200  LOCAL_INLINE void NvM_Prv_Block_SetRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   201  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   202      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= maskRequests_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   203  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   204  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   205  LOCAL_INLINE void NvM_Prv_Block_ClearRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   206  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   207      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] &= (~maskRequests_u16);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   208  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   209  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   210  LOCAL_INLINE void NvM_Prv_Block_SetState(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   211                                           uint8 maskBitsToChange_u8,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   212                                           uint8 maskBitsNewValue_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   213  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   214      NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] = ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & (~maskBitsToChange_u8)) |
	movh.a	a15,#@his(NvM_Prv_stBlock_rAwAM_au8)
	lea	a15,[a15]@los(NvM_Prv_stBlock_rAwAM_au8)
.L640:
	addsc.a	a15,a15,d15,#0
	ld.bu	d2,[a15]
.L641:
	xor	d15,d0,#255
.L642:
	and	d2,d15
.L643:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   215                                               (maskBitsNewValue_u8 & maskBitsToChange_u8));
	and	d15,d1,#2
.L644:
	or	d2,d15
.L645:
	st.b	[a15],d2
.L55:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   397      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   398  }
	ret
.L380:
	
__NvM_Prv_UpdateBlockStatusJobValidate_function_end:
	.size	NvM_Prv_UpdateBlockStatusJobValidate,__NvM_Prv_UpdateBlockStatusJobValidate_function_end-NvM_Prv_UpdateBlockStatusJobValidate
.L181:
	; End of function
	
	.sdecl	'.text.NvM_MainFunctionResultEval.NvM_Prv_UpdateBlockStatusIdConfigForReadAll',code,cluster('NvM_Prv_UpdateBlockStatusIdConfigForReadAll')
	.sect	'.text.NvM_MainFunctionResultEval.NvM_Prv_UpdateBlockStatusIdConfigForReadAll'
	.align	2
	

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   399  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   400  static void NvM_Prv_UpdateBlockStatusIdConfigForReadAll(NvM_Prv_JobData_tst const* JobData_pcst)
; Function NvM_Prv_UpdateBlockStatusIdConfigForReadAll
.L109:
NvM_Prv_UpdateBlockStatusIdConfigForReadAll:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   169  LOCAL_INLINE boolean NvM_Prv_Block_IsRequestPending(NvM_BlockIdType idBlock_uo, uint16 maskService_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   170  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   172  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   173  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   174  LOCAL_INLINE boolean NvM_Prv_Block_IsPending(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   175  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   176      return (NvM_Prv_Block_IsNvmEnqueuingForMulti(idBlock_uo) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   177              ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != 0)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   178  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   179                && (NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != (1u << NvM_Prv_ServiceBit_Maintain_e))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   180  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   181              )
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   182             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   183  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   184  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   185  LOCAL_INLINE void NvM_Prv_Block_SetIdxData(NvM_BlockIdType idBlock_uo, uint8 idxData_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   186  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   187      NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] = idxData_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   188  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   189  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   190  LOCAL_INLINE void NvM_Prv_Block_SetRequestResult(NvM_BlockIdType idBlock_uo, NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   191  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   192      NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo] = Result_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   193  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   194  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   195  LOCAL_INLINE void NvM_Prv_Block_SetRequest(NvM_BlockIdType idBlock_uo, NvM_Prv_ServiceBit_tuo ServiceBit_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   196  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   197      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= (1u << ServiceBit_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   198  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   199  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   200  LOCAL_INLINE void NvM_Prv_Block_SetRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   201  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   202      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= maskRequests_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   203  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   204  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   205  LOCAL_INLINE void NvM_Prv_Block_ClearRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   206  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   207      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] &= (~maskRequests_u16);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   208  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   209  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   210  LOCAL_INLINE void NvM_Prv_Block_SetState(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   211                                           uint8 maskBitsToChange_u8,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   212                                           uint8 maskBitsNewValue_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   213  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   214      NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] = ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & (~maskBitsToChange_u8)) |
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   215                                               (maskBitsNewValue_u8 & maskBitsToChange_u8));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   216  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   217  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   218  LOCAL_INLINE boolean NvM_Prv_Block_HasIdConfigChanged(void)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   219  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   220      return (NVM_COMPILED_CONFIG_ID != NvM_Prv_idConfigStored_rMwM_u16);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   221  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   222  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   223  LOCAL_INLINE void NvM_Prv_Block_SetIdConfig(uint16 idConfigNew_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   224  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   225      NvM_Prv_idConfigStored_rMwM_u16 = idConfigNew_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   226  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   227  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   228  LOCAL_INLINE boolean NvM_Prv_Block_InitIdConfigDuringWriteAll(void)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   229  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   230      boolean InitIdConfigDuringWriteAll_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   231  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   232  #if ((NVM_DYNAMIC_CONFIGURATION == STD_ON) && (NVM_RB_REMOVE_NON_RESISTANT_BLOCKS == STD_OFF))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   233      // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2901] Signal the writing of the Config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   234      //                                               in WriteAll when dynamic conf is active and
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   235      //                                               extended dynamic conf is inactive
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   236      InitIdConfigDuringWriteAll_b = NvM_Prv_Block_HasIdConfigChanged();
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   237  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   238      return InitIdConfigDuringWriteAll_b;
	mov	d15,#0

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   238      return InitIdConfigDuringWriteAll_b;      (inlined)
	j	.L56

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   239  }      (inlined)
.L56:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   401  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   402      if (NvM_Prv_Block_InitIdConfigDuringWriteAll())
	jeq	d15,#0,.L57
.L650:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   403      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   404          // TRACE[NVM310] Mark the config ID block as VALID/CHANGED to enable its writing during WriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   405          // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2901] Signal the writing of the config ID block in WriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   406          //                                               when dynamic conf is active and extended dynamic conf is inactive
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   407          NvM_Prv_Block_SetState(JobData_pcst->idBlock_uo, NVM_BLOCK_STATE_RAM_MASK, NVM_BLOCK_STATE_RAM_VALID_CHANGED);
	ld.hu	d15,[a4]4
.L651:
	mov	d0,#3
.L652:
	mov	d1,#3
.L391:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   169  LOCAL_INLINE boolean NvM_Prv_Block_IsRequestPending(NvM_BlockIdType idBlock_uo, uint16 maskService_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   170  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   172  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   173  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   174  LOCAL_INLINE boolean NvM_Prv_Block_IsPending(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   175  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   176      return (NvM_Prv_Block_IsNvmEnqueuingForMulti(idBlock_uo) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   177              ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != 0)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   178  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   179                && (NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != (1u << NvM_Prv_ServiceBit_Maintain_e))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   180  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   181              )
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   182             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   183  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   184  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   185  LOCAL_INLINE void NvM_Prv_Block_SetIdxData(NvM_BlockIdType idBlock_uo, uint8 idxData_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   186  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   187      NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] = idxData_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   188  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   189  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   190  LOCAL_INLINE void NvM_Prv_Block_SetRequestResult(NvM_BlockIdType idBlock_uo, NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   191  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   192      NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo] = Result_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   193  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   194  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   195  LOCAL_INLINE void NvM_Prv_Block_SetRequest(NvM_BlockIdType idBlock_uo, NvM_Prv_ServiceBit_tuo ServiceBit_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   196  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   197      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= (1u << ServiceBit_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   198  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   199  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   200  LOCAL_INLINE void NvM_Prv_Block_SetRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   201  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   202      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= maskRequests_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   203  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   204  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   205  LOCAL_INLINE void NvM_Prv_Block_ClearRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   206  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   207      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] &= (~maskRequests_u16);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   208  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   209  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   210  LOCAL_INLINE void NvM_Prv_Block_SetState(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   211                                           uint8 maskBitsToChange_u8,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   212                                           uint8 maskBitsNewValue_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   213  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   214      NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] = ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & (~maskBitsToChange_u8)) |
	movh.a	a15,#@his(NvM_Prv_stBlock_rAwAM_au8)
	lea	a15,[a15]@los(NvM_Prv_stBlock_rAwAM_au8)
.L653:
	addsc.a	a15,a15,d15,#0
	ld.bu	d2,[a15]
.L654:
	xor	d15,d0,#255
.L655:
	and	d2,d15
.L656:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   215                                               (maskBitsNewValue_u8 & maskBitsToChange_u8));
	and	d15,d1,#3
.L657:
	or	d2,d15
.L658:
	st.b	[a15],d2
.L57:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   408      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   409  }
	ret
.L386:
	
__NvM_Prv_UpdateBlockStatusIdConfigForReadAll_function_end:
	.size	NvM_Prv_UpdateBlockStatusIdConfigForReadAll,__NvM_Prv_UpdateBlockStatusIdConfigForReadAll_function_end-NvM_Prv_UpdateBlockStatusIdConfigForReadAll
.L186:
	; End of function
	
	.sdecl	'.text.NvM_MainFunctionResultEval.NvM_Prv_GetFctJobEvalReqResult',code,cluster('NvM_Prv_GetFctJobEvalReqResult')
	.sect	'.text.NvM_MainFunctionResultEval.NvM_Prv_GetFctJobEvalReqResult'
	.align	2
	

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   410  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   411  static NvM_Prv_JobEvalReqResult_tpfct NvM_Prv_GetFctJobEvalReqResult(NvM_Prv_idJob_ten idJob_en)
; Function NvM_Prv_GetFctJobEvalReqResult
.L111:
NvM_Prv_GetFctJobEvalReqResult:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   412  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   413      if (idJob_en >= NvM_Prv_idJob_Count_e)
	mov	d15,#13
.L663:
	lt	d15,d4,d15
.L664:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   414      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   415          idJob_en = NvM_Prv_idJob_Invalid_e;
	sel	d4,d15,d4,#12
.L58:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   416      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   417      return NvM_Prv_JobEvalReqResultFcts_capfct[idJob_en];
	movh.a	a15,#@his(NvM_Prv_JobEvalReqResultFcts_capfct)
	lea	a15,[a15]@los(NvM_Prv_JobEvalReqResultFcts_capfct)
.L665:
	addsc.a	a15,a15,d4,#2
	ld.a	a2,[a15]
.L666:
	j	.L59

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   418  }
.L59:
	ret
.L395:
	
__NvM_Prv_GetFctJobEvalReqResult_function_end:
	.size	NvM_Prv_GetFctJobEvalReqResult,__NvM_Prv_GetFctJobEvalReqResult_function_end-NvM_Prv_GetFctJobEvalReqResult
.L191:
	; End of function
	
	.sdecl	'.text.NvM_MainFunctionResultEval.NvM_Prv_GetFctJobEvalProductionErrors',code,cluster('NvM_Prv_GetFctJobEvalProductionErrors')
	.sect	'.text.NvM_MainFunctionResultEval.NvM_Prv_GetFctJobEvalProductionErrors'
	.align	2
	

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   419  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   420  static NvM_Prv_JobEvalProductionErrors_tpfct NvM_Prv_GetFctJobEvalProductionErrors(NvM_Prv_idJob_ten idJob_en)
; Function NvM_Prv_GetFctJobEvalProductionErrors
.L113:
NvM_Prv_GetFctJobEvalProductionErrors:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   421  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   422      if (idJob_en >= NvM_Prv_idJob_Count_e)
	mov	d15,#13
.L671:
	lt	d15,d4,d15
.L672:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   423      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   424          idJob_en = NvM_Prv_idJob_Invalid_e;
	sel	d4,d15,d4,#12
.L60:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   425      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   426      return NvM_Prv_JobEvalProductionErrorsFcts_capfct[idJob_en];
	movh.a	a15,#@his(NvM_Prv_JobEvalProductionErrorsFcts_capfct)
	lea	a15,[a15]@los(NvM_Prv_JobEvalProductionErrorsFcts_capfct)
.L673:
	addsc.a	a15,a15,d4,#2
	ld.a	a2,[a15]
.L674:
	j	.L61

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   427  }
.L61:
	ret
.L398:
	
__NvM_Prv_GetFctJobEvalProductionErrors_function_end:
	.size	NvM_Prv_GetFctJobEvalProductionErrors,__NvM_Prv_GetFctJobEvalProductionErrors_function_end-NvM_Prv_GetFctJobEvalProductionErrors
.L196:
	; End of function
	
	.sdecl	'.text.NvM_MainFunctionResultEval.NvM_Prv_GetFctJobUpdateBlockStatus',code,cluster('NvM_Prv_GetFctJobUpdateBlockStatus')
	.sect	'.text.NvM_MainFunctionResultEval.NvM_Prv_GetFctJobUpdateBlockStatus'
	.align	2
	

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   428  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   429  static NvM_Prv_JobUpdateBlockStatus_tpfct NvM_Prv_GetFctJobUpdateBlockStatus(NvM_Prv_idJob_ten idJob_en)
; Function NvM_Prv_GetFctJobUpdateBlockStatus
.L115:
NvM_Prv_GetFctJobUpdateBlockStatus:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   430  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   431      if (idJob_en >= NvM_Prv_idJob_Count_e)
	mov	d15,#13
.L679:
	lt	d15,d4,d15
.L680:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   432      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   433          idJob_en = NvM_Prv_idJob_Invalid_e;
	sel	d4,d15,d4,#12
.L62:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   434      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   435      return NvM_Prv_JobUpdateBlockStatusFcts_capfct[idJob_en];
	movh.a	a15,#@his(NvM_Prv_JobUpdateBlockStatusFcts_capfct)
	lea	a15,[a15]@los(NvM_Prv_JobUpdateBlockStatusFcts_capfct)
.L681:
	addsc.a	a15,a15,d4,#2
	ld.a	a2,[a15]
.L682:
	j	.L63

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   436  }
.L63:
	ret
.L400:
	
__NvM_Prv_GetFctJobUpdateBlockStatus_function_end:
	.size	NvM_Prv_GetFctJobUpdateBlockStatus,__NvM_Prv_GetFctJobUpdateBlockStatus_function_end-NvM_Prv_GetFctJobUpdateBlockStatus
.L201:
	; End of function
	
	.sdecl	'.text.NvM_MainFunctionResultEval.NvM_Prv_MainFunctionResultEval',code,cluster('NvM_Prv_MainFunctionResultEval')
	.sect	'.text.NvM_MainFunctionResultEval.NvM_Prv_MainFunctionResultEval'
	.align	2
	
	.global	NvM_Prv_MainFunctionResultEval

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   437  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   438  void NvM_Prv_MainFunctionResultEval(void)
; Function NvM_Prv_MainFunctionResultEval
.L117:
NvM_Prv_MainFunctionResultEval:	.type	func
	sub.a	a10,#16
.L424:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   439  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   440      // Evaluate the result of the job identified by idActiveJob_rMwM_en
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   441  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   442      boolean isRequestResultEvaluated_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   443      NvM_RequestResultType stRequestResult_uo = NVM_REQ_NOT_OK;
	mov	d15,#1
.L454:
	st.b	[a10],d15
.L455:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   444      uint8 stProductionErrors_u8 = 0;
	mov	d15,#0
.L456:
	st.b	[a10]1,d15
.L457:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   445  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   446      NvM_Prv_idService_tuo idActiveService_uo = NvM_Prv_GetActiveService();
	call	NvM_Prv_GetActiveService
.L425:
	mov	d9,d2
.L427:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   447      NvM_Prv_idQueue_tuo idActiveQueue_en = NvM_Prv_Main_st.idQueueActive_uo;
	movh.a	a12,#@his(NvM_Prv_Main_st)
	lea	a12,[a12]@los(NvM_Prv_Main_st)
.L458:
	mov.aa	a15,a12
	add.a	a15,#4
	st.a	[a10]12,a15
	ld.bu	d10,[a15]
.L428:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   448      NvM_BlockIdType idBlock_uo = NvM_Prv_Main_st.QueueEntry_pst->idBlock_uo;
	lea	a15,[a12]8
	st.a	[a10]8,a15
	ld.a	a2,[a12]8
.L459:
	ld.hu	d11,[a2]2
.L429:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   449  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   450      if (NvM_Prv_IsAuxServiceActive())
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   451      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   452          idBlock_uo = NVM_PRV_AUX_ADMIN_BLOCK;
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   453      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   454  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   455      // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Set migration result for auxiliary read
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   456      NvM_Prv_SetAuxMigrationResult(idActiveService_uo, NvM_Prv_Main_st.QueueEntry_pst->idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   457  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   458  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   459      isRequestResultEvaluated_b = NvM_Prv_EvalCommonResults(&NvM_Prv_Main_st.JobData_st,
	lea	a13,[a12]12
.L218:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   460                                                             &stRequestResult_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   461                                                             &stProductionErrors_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   462  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   463      // Set scheduling lock
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   464      SchM_Enter_NvM_Main();
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   465  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   466      // Part to be done after result evaluation WITHIN scheduling lock
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   467      if (isRequestResultEvaluated_b)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   468      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   469          // Set global variables from local copies to update results/states for the user
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   470          // TRACE[NVM175] Indicate the request result to the user
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   471          NvM_Prv_Block_SetRequestResult(idBlock_uo, stRequestResult_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   472          NvM_Prv_ErrorDetection_SetProductionError(NvM_Prv_Main_st.QueueEntry_pst->idBlock_uo, stProductionErrors_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   473      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   474  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   475      // Reset the states of NvM's main state machine because the current job is now completely finished
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   476      NvM_Prv_MainFunctionResultEval_ResetMainStates(idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   477                                                     idActiveQueue_en,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   478                                                     idActiveService_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   479                                                     NvM_Prv_Main_st.QueueEntry_pst->ServiceBit_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   480                                                     stRequestResult_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   481  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   482      // Reset scheduling lock
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   483      SchM_Exit_NvM_Main();
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   484  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   485      // Part to be done after result evaluation WITHOUT scheduling lock
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   486      if (isRequestResultEvaluated_b)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   487      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   488          // Invoke observer and singleblock callbacks if applicable
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   489          NvM_Prv_MainFunctionResultEval_FinalBlockCallbacks(stRequestResult_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   490                                                             idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   491                                                             idActiveService_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   492      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   493  }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   494  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   495  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   496  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   497  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   498  /*
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   499   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   500   * Inline code
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   501   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   502   */
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   503  // ====================================================================================================================
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   504  LOCAL_INLINE boolean NvM_Prv_EvalCommonResults(NvM_Prv_JobData_tst const* JobData_pcst,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   505                                                 NvM_RequestResultType* stReqResult_puo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   506                                                 uint8* stProductionErrors_pu8)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   507  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   508      boolean isReqResultEvaluated_b = FALSE;
	mov	d12,#0
.L430:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   509  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   510  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   511      // We rely heavily on the fact that we know really all possible job results
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   512      // -> check this assumption and report DET error if development error detection is enabled
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   513      if (NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible(NVM_SERVICE_ID_MAIN_FUNCTION,
	mov	d4,#14
.L460:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   514                                                           JobData_pcst->idBlock_uo,
	ld.hu	d5,[a13]4
.L461:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   515                                                           JobData_pcst->Result_en))
	ld.w	d6,[a13]16
	call	NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible
.L426:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   513      if (NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible(NVM_SERVICE_ID_MAIN_FUNCTION,      (inlined)
	jeq	d2,#0,.L64
.L237:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   516      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   517          // Pointer to the function to evaluate request results of the currently active job
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   518          NvM_Prv_JobEvalReqResult_tpfct JobEvalReqResult_pfct = NvM_Prv_GetFctJobEvalReqResult(JobData_pcst->idJob_en);
	ld.w	d8,[a13]
	mov	d4,d8
	call	NvM_Prv_GetFctJobEvalReqResult
.L431:
	mov.aa	a15,a2
.L433:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   519          // Pointer to the function to evaluate production errors occured during the currently active job
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   520          NvM_Prv_JobEvalProductionErrors_tpfct JobEvalProductionErrors_pfct =
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   521                  NvM_Prv_GetFctJobEvalProductionErrors(JobData_pcst->idJob_en);
	mov	d4,d8
	call	NvM_Prv_GetFctJobEvalProductionErrors
.L432:
	mov.aa	a14,a2
.L435:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   522          // Pointer to the function to update the status of the block handled during the currently active job
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   523          NvM_Prv_JobUpdateBlockStatus_tpfct JobUpdateBlockStatus_pfct =
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   524                  NvM_Prv_GetFctJobUpdateBlockStatus(JobData_pcst->idJob_en);
	mov	d4,d8
	call	NvM_Prv_GetFctJobUpdateBlockStatus
.L434:
	st.a	[a10]4,a2
.L437:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   525  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   526          if (NULL_PTR != JobEvalReqResult_pfct)
	mov.a	a2,#0
.L436:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   526          if (NULL_PTR != JobEvalReqResult_pfct)      (inlined)
	jeq.a	a2,a15,.L65
.L462:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   527          {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   528              *stReqResult_puo = JobEvalReqResult_pfct(JobData_pcst);
	mov.aa	a4,a13
	calli	a15
.L219:
	lea	a15,[a10]0
.L228:
	st.b	[a15],d2
.L463:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   529              isReqResultEvaluated_b = TRUE;
	mov	d12,#1
.L464:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   530  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   531              // TRACE[NVM395] Maintain overall result of the multiblock operation
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   532              if (NvM_Prv_IsMultiActive() &&
	call	NvM_Prv_IsMultiActive
.L465:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   532              if (NvM_Prv_IsMultiActive() &&      (inlined)
	jeq	d2,#0,.L66
.L466:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   533                  ((MEMIF_BLOCK_INCONSISTENT == JobData_pcst->Result_en) || (MEMIF_JOB_FAILED == JobData_pcst->Result_en)))
	ld.w	d15,[a13]16
.L467:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   533                  ((MEMIF_BLOCK_INCONSISTENT == JobData_pcst->Result_en) || (MEMIF_JOB_FAILED == JobData_pcst->Result_en)))      (inlined)
	jeq	d15,#4,.L67
.L468:
	jne	d15,#1,.L68
.L67:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   534              {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   535                  // TRACE[NVM301] Set final multiblock result to NVM_REQ_NOT_OK (applies to NvM_ReadAll)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   536                  // TRACE[NVM318] Same as NVM301, applied to NvM_WriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   537                  // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2836] NVM_REQ_NOT_OK is one
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   538                  //                                               of the two possible request results of first init
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   539                  NvM_Prv_Multi_SetResult(NVM_REQ_NOT_OK);
	mov	d4,#1
	call	NvM_Prv_Multi_SetResult

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   532              if (NvM_Prv_IsMultiActive() &&      (inlined)
.L68:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   533                  ((MEMIF_BLOCK_INCONSISTENT == JobData_pcst->Result_en) || (MEMIF_JOB_FAILED == JobData_pcst->Result_en)))      (inlined)
.L66:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   526          if (NULL_PTR != JobEvalReqResult_pfct)      (inlined)
.L65:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   540              }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   541          }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   542          if (NULL_PTR != JobEvalProductionErrors_pfct)
	mov.a	a15,#0
.L469:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   542          if (NULL_PTR != JobEvalProductionErrors_pfct)      (inlined)
	jeq.a	a15,a14,.L69
.L470:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   543          {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   544              *stProductionErrors_pu8 = JobEvalProductionErrors_pfct(JobData_pcst);
	mov.aa	a4,a13
	calli	a14
.L229:
	lea	a15,[a10]1
.L230:
	st.b	[a15],d2

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   542          if (NULL_PTR != JobEvalProductionErrors_pfct)      (inlined)
.L69:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   545          }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   546          if (NULL_PTR != JobUpdateBlockStatus_pfct)
	mov.a	a2,#0
.L471:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   546          if (NULL_PTR != JobUpdateBlockStatus_pfct)      (inlined)
	ld.a	a15,[a10]4
.L438:
	jeq.a	a2,a15,.L70
.L472:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   547          {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   548              JobUpdateBlockStatus_pfct(JobData_pcst);
	mov.aa	a4,a13
	calli	a15

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   546          if (NULL_PTR != JobUpdateBlockStatus_pfct)      (inlined)
.L70:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   513      if (NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible(NVM_SERVICE_ID_MAIN_FUNCTION,      (inlined)
.L64:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   551      return isReqResultEvaluated_b;      (inlined)
	j	.L71

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   552  }      (inlined)
.L71:
	jeq	d12,#0,.L72
.L231:
	ld.bu	d0,[a10]
.L245:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   169  LOCAL_INLINE boolean NvM_Prv_Block_IsRequestPending(NvM_BlockIdType idBlock_uo, uint16 maskService_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   170  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   172  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   173  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   174  LOCAL_INLINE boolean NvM_Prv_Block_IsPending(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   175  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   176      return (NvM_Prv_Block_IsNvmEnqueuingForMulti(idBlock_uo) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   177              ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != 0)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   178  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   179                && (NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != (1u << NvM_Prv_ServiceBit_Maintain_e))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   180  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   181              )
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   182             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   183  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   184  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   185  LOCAL_INLINE void NvM_Prv_Block_SetIdxData(NvM_BlockIdType idBlock_uo, uint8 idxData_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   186  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   187      NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] = idxData_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   188  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   189  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   190  LOCAL_INLINE void NvM_Prv_Block_SetRequestResult(NvM_BlockIdType idBlock_uo, NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   191  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   192      NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo] = Result_uo;
	movh.a	a15,#@his(NvM_Prv_stRequestResult_rAwAM_au8)
	lea	a15,[a15]@los(NvM_Prv_stRequestResult_rAwAM_au8)
.L473:
	addsc.a	a15,a15,d11,#0
.L474:
	st.b	[a15],d0
.L246:
	ld.a	a15,[a10]8
	ld.a	a15,[a15]
.L475:
	ld.hu	d4,[a15]2
.L476:
	ld.bu	d5,[a10]1
	call	NvM_Prv_ErrorDetection_SetProductionError
.L72:
	ld.a	a15,[a10]8
	ld.a	a15,[a15]
.L477:
	ld.hu	d0,[a15]4
.L478:
	ld.bu	d1,[a10]
.L253:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   589      if (NvM_Prv_idQueue_Multi_e == idQueue_uo)      (inlined)
	jne	d10,#0,.L73
.L479:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   549          }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   550      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   551      return isReqResultEvaluated_b;
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   552  }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   553  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   554  // ====================================================================================================================
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   555  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   556  LOCAL_INLINE void NvM_Prv_MainFunctionResultEval_FinalBlockCallbacks(NvM_RequestResultType stRequestResult_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   557                                                                       NvM_BlockIdType idActiveBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   558                                                                       NvM_Prv_idService_tuo idActiveService_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   559  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   560      // Invoke observer and singleblock callbacks if applicable
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   561      // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842] Invoke the observer callback if this callback routine is configured
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   562      // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2844] Invoke the observer callback before the singleblock callback
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   563      NvM_Prv_InvokeObserverCallback(idActiveBlock_uo, idActiveService_uo, stRequestResult_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   564  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   565      // TRACE[NVM347] Invoke singleblock callback if callback routine is configured
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   566      // TRACE[NVM281] Processing of this block finished -> invoke callback function (applies to NvM_ReadAll)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   567      // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2839] Same as NVM281, but applied to first init
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   568      // TRACE[NVM740] The callback is invoked upon termination of the block operation
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   569      // TRACE[NVM742] The caller is only actively notified if a callback has been configured
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   570      // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2930]
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   571      // Don't invoke the singleblock callback if the current service is triggered by an auxiliary user
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   572      if (!NvM_Prv_IsAuxServiceActive())
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   573      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   574          // TRACE[NVM741] Supply the ID of the just finished block operation to the callback owner
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   575          NvM_Prv_InvokeSingleBlockCallback(idActiveBlock_uo, idActiveService_uo, stRequestResult_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   576      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   577  }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   578  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   579  // ====================================================================================================================
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   580  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   581  LOCAL_INLINE void NvM_Prv_MainFunctionResultEval_ResetMainStates(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   582                                                                   NvM_Prv_idQueue_tuo idQueue_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   583                                                                   NvM_Prv_idService_tuo idService_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   584                                                                   NvM_Prv_ServiceBit_tuo ServiceBit_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   585                                                                   NvM_RequestResultType stRequestResult_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   586  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   587      uint16 ServiceBitMask_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   588  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   589      if (NvM_Prv_idQueue_Multi_e == idQueue_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   590      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   591          if (NVM_SERVICE_ID_RB_INIT_AFTER_READ_ALL == idService_uo)
	mov	d15,#254
.L480:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   591          if (NVM_SERVICE_ID_RB_INIT_AFTER_READ_ALL == idService_uo)      (inlined)
	jne	d15,d9,.L74
.L481:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   592          {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   593              ServiceBitMask_uo = (1u << NvM_Prv_ServiceBit_InitAtLayoutChange_e) |
	mov	d15,#34
.L439:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   594                                  (1u << NvM_Prv_ServiceBit_RemoveNonResistant_e);      (inlined)
	j	.L75

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   591          if (NVM_SERVICE_ID_RB_INIT_AFTER_READ_ALL == idService_uo)      (inlined)
.L74:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   594                                  (1u << NvM_Prv_ServiceBit_RemoveNonResistant_e);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   595          }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   596          else if ((NVM_SERVICE_ID_READ_ALL == idService_uo) &&
	mov	d15,#12
.L482:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   596          else if ((NVM_SERVICE_ID_READ_ALL == idService_uo) &&      (inlined)
	jne	d15,d9,.L76
.L483:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   597                   (NVM_RB_CONFIG_ID_BLOCK != idBlock_uo) &&      (inlined)
	jeq	d11,#1,.L77
.L484:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   597                   (NVM_RB_CONFIG_ID_BLOCK != idBlock_uo) &&
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   598                   (NVM_REQ_RESTORED_FROM_ROM != stRequestResult_uo))
	mov	d15,#8
.L485:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   598                   (NVM_REQ_RESTORED_FROM_ROM != stRequestResult_uo))      (inlined)
	jeq	d15,d1,.L78
.L486:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   599          {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   600              ServiceBitMask_uo = (1u << NvM_Prv_ServiceBit_ReadAll_e) |
	mov	d15,#33
.L440:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   601                                  (1u << NvM_Prv_ServiceBit_InitAtLayoutChange_e);      (inlined)
	j	.L79

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   596          else if ((NVM_SERVICE_ID_READ_ALL == idService_uo) &&      (inlined)
.L78:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   598                   (NVM_REQ_RESTORED_FROM_ROM != stRequestResult_uo))      (inlined)
.L77:
.L76:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   601                                  (1u << NvM_Prv_ServiceBit_InitAtLayoutChange_e);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   602          }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   603          else
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   604          {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   605              ServiceBitMask_uo = (1u << ServiceBit_uo);
	mov	d15,#1
.L487:
	sh	d15,d15,d0
	extr.u	d15,d15,#0,#16

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   603          else      (inlined)
.L79:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   596          else if ((NVM_SERVICE_ID_READ_ALL == idService_uo) &&      (inlined)
.L75:
	j	.L80

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   589      if (NvM_Prv_idQueue_Multi_e == idQueue_uo)      (inlined)
.L73:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   606          }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   607      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   608      else
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   609      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   610          ServiceBitMask_uo = (1u << ServiceBit_uo);
	mov	d15,#1
.L488:
	sh	d15,d15,d0
	extr.u	d15,d15,#0,#16
.L441:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   611  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   612          NvM_Prv_Queue_DequeueRequest(idQueue_uo);
	mov	d4,d10
.L443:
	call	NvM_Prv_Queue_DequeueRequest
.L444:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   613          NvM_Prv_Main_st.QueueEntry_pst = NULL_PTR;
	mov.a	a2,#0
.L489:
	ld.a	a15,[a10]8
	st.a	[a15],a2
.L490:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   614          NvM_Prv_Main_st.idQueueActive_uo = NvM_Prv_idQueue_nrQueues_e;
	mov	d0,#2
.L491:
	ld.a	a15,[a10]12
	st.b	[a15],d0

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   608      else      (inlined)
.L80:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   169  LOCAL_INLINE boolean NvM_Prv_Block_IsRequestPending(NvM_BlockIdType idBlock_uo, uint16 maskService_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   170  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   172  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   173  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   174  LOCAL_INLINE boolean NvM_Prv_Block_IsPending(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   175  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   176      return (NvM_Prv_Block_IsNvmEnqueuingForMulti(idBlock_uo) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   177              ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != 0)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   178  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   179                && (NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != (1u << NvM_Prv_ServiceBit_Maintain_e))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   180  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   181              )
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   182             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   183  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   184  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   185  LOCAL_INLINE void NvM_Prv_Block_SetIdxData(NvM_BlockIdType idBlock_uo, uint8 idxData_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   186  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   187      NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] = idxData_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   188  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   189  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   190  LOCAL_INLINE void NvM_Prv_Block_SetRequestResult(NvM_BlockIdType idBlock_uo, NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   191  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   192      NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo] = Result_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   193  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   194  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   195  LOCAL_INLINE void NvM_Prv_Block_SetRequest(NvM_BlockIdType idBlock_uo, NvM_Prv_ServiceBit_tuo ServiceBit_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   196  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   197      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= (1u << ServiceBit_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   198  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   199  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   200  LOCAL_INLINE void NvM_Prv_Block_SetRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   201  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   202      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= maskRequests_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   203  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   204  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   205  LOCAL_INLINE void NvM_Prv_Block_ClearRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   206  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   207      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] &= (~maskRequests_u16);
	movh.a	a15,#@his(NvM_Prv_stRequests_rAMwAM_au16)
	lea	a15,[a15]@los(NvM_Prv_stRequests_rAMwAM_au16)
.L492:
	addsc.a	a15,a15,d11,#1
	ld.hu	d0,[a15]0
.L493:
	mov.u	d1,#65535
	xor	d15,d1
.L442:
	and	d0,d15
	st.h	[a15],d0
.L267:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   615      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   616  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   617      NvM_Prv_Block_ClearRequests(idBlock_uo, ServiceBitMask_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   618  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   619      NvM_Prv_Main_st.JobData_st.idJob_en = NvM_Prv_idJob_Idle_e;
	mov	d15,#0
.L494:
	st.w	[a13],d15
.L495:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   620      NvM_Prv_Main_st.JobData_st.idBlock_uo = 0;
	mov	d15,#0
.L496:
	st.h	[a12]16,d15
.L497:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   621      NvM_Prv_Main_st.JobData_st.idxDataset_u8 = 0;
	mov	d15,#0
.L498:
	st.b	[a12]24,d15
.L499:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   622      NvM_Prv_Main_st.JobData_st.RamBlock_pu8 = NULL_PTR;
	mov.a	a15,#0
.L500:
	st.a	[a12]20,a15
.L501:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   623      NvM_Prv_Main_st.JobData_st.Result_en = MEMIF_JOB_OK;
	mov	d15,#0
.L502:
	st.w	[a12]28,d15
.L503:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   624  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   625      NvM_Prv_Main_st.Activity_rAMwM_en = NVM_PRV_ACTIVITY_ARBITRATE;
	mov	d15,#2
.L504:
	st.w	[a12],d15
.L232:
	jeq	d12,#0,.L81
.L233:
	ld.bu	d8,[a10]
.L274:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   392  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   393   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   394   * This NvM private function checks for the given block whether the configured block length is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   395   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   396   * \param idBlock
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   397   * ID of the block for which the block length will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   398   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   399   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   400   * - TRUE = block length is valid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   401   * - FALSE = block length is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   402   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   403  LOCAL_INLINE boolean NvM_Prv_IsBlockLengthValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   404  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   405      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   406              (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   407              (0u != *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   408  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   409  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   410  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   411   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   412   * This NvM private function checks whether the given block is configured with immediate priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   413   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   414   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   415   * ID of the block for which the priority will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   416   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   417   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   418   * - TRUE = block is configured with immediate priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   419   * - FALSE = block is configured with standard priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   420   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   421  LOCAL_INLINE boolean NvM_Prv_HasBlockImmediateJobPriority(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   423      boolean HasBlockImmediateJobPriority_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   425  #if (NVM_JOB_PRIORITIZATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   426      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   427          (NVM_PRV_JOB_PRIORITY_IMMEDIATE == NvM_Prv_BlockDescriptors_acst[idBlock_uo].JobPriority_u8))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   428      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   429          HasBlockImmediateJobPriority_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   430      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   431  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   433  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   434  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   435  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   436   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   437   * This NvM private function returns the configured block size for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   438   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   439   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   440   * ID of the block for which the configured block size will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   441   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   442   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   443   * Configured block size
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   444   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   445  LOCAL_INLINE uint16 NvM_Prv_GetBlockSize(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   446  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   447      uint16 BlockSize_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   448  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   451      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   452          BlockSize_u16 = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   453      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   454  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   455      return BlockSize_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   456  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   457  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   458  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   459   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   460   * This NvM private function returns the configured block management type for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   461   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   462   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   463   * ID of the block for which the configured block management type will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   464   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   465   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   466   * Configured block management type
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   467   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   468  LOCAL_INLINE NvM_BlockManagementType NvM_Prv_GetBlockType(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   469  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   470      NvM_BlockManagementType BlockType = NVM_BLOCK_NATIVE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   472      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   473          BlockType = NvM_Prv_BlockDescriptors_acst[idBlock_uo].BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   474      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   475      return BlockType;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   476  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   477  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   478  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   479   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   480   * This NvM private function returns the configured number of non-volatile data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   481   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   482   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   483   * ID of the block for which the configured number of non-volatile data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   484   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   485   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   486   * Configured number of non-volatile data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   487   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   488  LOCAL_INLINE uint8 NvM_Prv_GetNrNonVolatileBlocks(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   489  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   490      uint8 nrNvBlocks_u8 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   491      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   492      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   493          nrNvBlocks_u8 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   494      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   495      return nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   496  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   497  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   498  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   499   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   500   * This NvM private function returns the configured overall number of data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   501   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   502   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   503   * ID of the block for which the configured overall number of data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   504   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   505   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   506   * Configured number of data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   507   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   508  LOCAL_INLINE uint16 NvM_Prv_GetNrDataIndexes(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   509  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   510      uint8 nrDataIndexes = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   511      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   512      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   513          nrDataIndexes = (NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8 +
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   514                           NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrRomBlocks_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   515      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   516      return nrDataIndexes;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   517  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   518  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   519  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   520   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   521   * This NvM private function returns the pointer to the configured permanent RAM block for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   522   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   523   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   524   * If no permanent RAM block is configured for a block then this function returns a NULL pointer.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   525   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   526   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   527   * ID of the block for which the pointer to the configured permanent RAM block will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   528   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   529   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   530   * Pointer to the configured permanent RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   531   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   532  LOCAL_INLINE void * NvM_Prv_GetPRamBlockAddress(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   533  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   534      void * PRamBlockAddress_pv = NULL_PTR;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   535      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   536          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   537      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   538          PRamBlockAddress_pv = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   539      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   540  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   541      return PRamBlockAddress_pv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   542  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   543  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   544  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   545   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   546   * This NvM private function returns the pointer to the configured ROM block for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   547   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   548   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   549   * If no ROM block is configured for a block then this function returns a NULL pointer.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   550   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   551   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   552   * ID of the block for which the pointer to the configured ROM block will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   553   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   554   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   555   * Pointer to the configured ROM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   556   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   557  LOCAL_INLINE void const* NvM_Prv_GetRomBlockAddress(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   558  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   559      void const* adrRomBlock_pcv = NULL_PTR;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   560      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   561      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   562          adrRomBlock_pcv = NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   563      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   564      return adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   565  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   566  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   567  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   568   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   569   * This NvM private function returns the configured block ID used by the mem interface for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   570   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   571   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   572   * ID of the block for which the block ID used by the mem interface will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   573   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   574   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   575   * Configured block ID used by the mem interface
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   576   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   577  LOCAL_INLINE uint16 NvM_Prv_GetIdBlockMemIf(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   578  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   579      uint16 idBlockMemIf_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   580      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   581      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   582          idBlockMemIf_u16 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   583      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   584      return idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   585  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   586  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   587  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   588   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   589   * This NvM private function returns the configured device index where the given block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   590   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   591   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   592   * ID of the block for which the configured device index will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   593   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   594   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   595   * Configured device index where the given block is located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   596   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   597  LOCAL_INLINE uint8 NvM_Prv_GetIdxDevice(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   598  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   599      uint8 idxDevice_u8 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   600      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   601      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   602          idxDevice_u8 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   603      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   604      return idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   605  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   606  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   607  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   608   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   609   * This NvM private function returns the configured persistent ID of a block identified by index for persistent IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   610   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   611   * \param idxPersistentId_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   612   * Index of the required persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   613   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   614   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   615   * Configured persistent ID of a block identified by index for persistent IDs
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   616   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   617  LOCAL_INLINE uint16 NvM_Prv_GetIdPersistent(uint16 idxPersistentId_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   618  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   619      uint16 PersistentId_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   620      if (idxPersistentId_u16 < NVM_PRV_NR_PERSISTENT_IDS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   621      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   622          PersistentId_u16 = NvM_Prv_PersId_BlockId_acst[idxPersistentId_u16].PersistentId_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   623      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   624      return PersistentId_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   625  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   626  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   627  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   628   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   629   * This NvM private function returns the configured NvM ID of a block identified by index for persistent IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   630   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   631   * \param idxPersistentId_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   632   * Index of the required persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   633   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   634   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   635   * Configured NvM ID of a block identified by index for persistent IDs
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   636   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   637  LOCAL_INLINE NvM_BlockIdType NvM_Prv_GetIdBlock(uint16 idxPersistentId_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   638  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   639      uint16 BlockId_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   640      if (idxPersistentId_u16 < NVM_PRV_NR_PERSISTENT_IDS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   641      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   642          BlockId_u16 = NvM_Prv_PersId_BlockId_acst[idxPersistentId_u16].BlockId_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   643      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   644      return BlockId_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   645  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   646  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   647  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   648   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   649   * This NvM private function returns the configured pointer to the block specific callback function
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   650   * to copy data from the NvM mirror to the application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   651   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   652   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   653   * ID of the block for which the configured copy function will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   654   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   655   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   656   * Configured pointer to the copy function
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   657   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   658  LOCAL_INLINE NvM_Prv_ExplicitSync_Copy_tpfct NvM_Prv_GetCopyFctForRead(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   659  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   660      NvM_Prv_ExplicitSync_Copy_tpfct ReadRamBlockFromNvm_pfct = NULL_PTR;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   661      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   662      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   663          ReadRamBlockFromNvm_pfct = NvM_Prv_BlockDescriptors_acst[idBlock_uo].ReadRamBlockFromNvm_pfct;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   664      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   665      return ReadRamBlockFromNvm_pfct;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   666  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   667  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   668  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   669   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   670   * This NvM private function returns the configured pointer to the block specific callback function
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   671   * to copy data from the application's RAM block to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   672   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   673   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   674   * ID of the block for which the configured copy function will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   675   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   676   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   677   * Configured pointer to the copy function
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   678   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   679  LOCAL_INLINE NvM_Prv_ExplicitSync_Copy_tpfct NvM_Prv_GetCopyFctForWrite(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   680  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   681      NvM_Prv_ExplicitSync_Copy_tpfct WriteRamBlockToNvm_pfct = NULL_PTR;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   682      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   683      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   684          WriteRamBlockToNvm_pfct = NvM_Prv_BlockDescriptors_acst[idBlock_uo].WriteRamBlockToNvm_pfct;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   685      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   686      return WriteRamBlockToNvm_pfct;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   687  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   688  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   689  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   690   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   691   * This NvM private function returns the configured block specific initializaton callback function.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   692   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   693   * If no initializaton callback function is configured for the passed block then this function does nothing and
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   694   * returns E_NOT_OK.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   695   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   696   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   697   * ID of the block for which the configured initialization callback function will be invoked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   698   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   699   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   700   * E_OK = initialization callback function is configured and has returned E_OK
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   701   * E_NOT_OK = no initialization callback function is configured or has returned E_NOT_OK
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   702   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   703  LOCAL_INLINE Std_ReturnType NvM_Prv_InvokeInitBlockCallback(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   704  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   705      Std_ReturnType RetValue = E_NOT_OK;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   706      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   707          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   708      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   709          RetValue = NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct();
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   710      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   711      return RetValue;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   712  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   713  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   714  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   715   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   716   * This NvM private function invokes the configured block specific single request start callback function.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   717   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   718   * If no single request start callback function is configured for the passed block then this function does nothing.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   719   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   720   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   721   * ID of the block for which the configured single request start callback function will be invoked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   722   * \param idService_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   723   * Id of the request for which the start callback function will be invoked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   724   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   725  LOCAL_INLINE void NvM_Prv_InvokeSingleBlockStartCallback(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   726                                                           NvM_Prv_idService_tuo idService_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   727  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   728      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   729          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].SingleBlockStartCallback_pfct))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   730      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   731          // Start callback function returns allways E_OK so return value can be dropped safely
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   732          (void)(NvM_Prv_BlockDescriptors_acst[idBlock_uo].SingleBlockStartCallback_pfct)(idService_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   733      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   734  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   735  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   736  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   737   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   738   * This NvM private function invokes the configured block specific single request termination callback function.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   739   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   740   * If no single request termination callback function is configured for the passed block then this function does nothing.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   741   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   742   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   743   * ID of the block for which the configured termination callback function will be invoked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   744   * \param idService_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   745   * Id of the request for which the termination callback function will be invoked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   746   * \param Result_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   747   * Result of the terminated request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   748   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   749  LOCAL_INLINE void NvM_Prv_InvokeSingleBlockCallback(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   750                                                      NvM_Prv_idService_tuo idService_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   751                                                      NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   752  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   753      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   754          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].SingleBlockCallback_pfct))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   755      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   756          // Termination callback function returns allways E_OK so return value can be dropped safely
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   757          (void)(NvM_Prv_BlockDescriptors_acst[idBlock_uo].SingleBlockCallback_pfct)(idService_uo, Result_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   758      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   759  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   760  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   761  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   762   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   763   * This NvM private function invokes the configured observer callback function.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   764   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   765   * If no observer callback function is configured for the NvM then this function does nothing.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   766   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   767   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   768   * ID of the block to be passed to the configured observer callback function.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   769   * \param idService_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   770   * Id of the request to be passed to the configured observer callback function.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   771   * \param Result_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   772   * Result of the request to be passed to the configured observer callback function.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   773   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   774  LOCAL_INLINE void NvM_Prv_InvokeObserverCallback(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   775                                                   NvM_Prv_idService_tuo idService_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   776                                                   NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   777  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   778      if (NULL_PTR != NvM_Prv_Common_cst.ObserverCallback_pfct)
	movh.a	a15,#@his(NvM_Prv_Common_cst)
	lea	a15,[a15]@los(NvM_Prv_Common_cst)
.L505:
	ld.a	a15,[a15]8
.L506:
	mov.a	a2,#0
.L507:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   778      if (NULL_PTR != NvM_Prv_Common_cst.ObserverCallback_pfct)      (inlined)
	jeq.a	a2,a15,.L82
.L508:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   779      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   780          // Observer callback function returns allways E_OK so return value can be dropped safely
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   781          (void)(NvM_Prv_Common_cst.ObserverCallback_pfct)(idBlock_uo, idService_uo, Result_uo);
	mov	e4,d9,d11
	mov	d6,d8
	calli	a15

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   778      if (NULL_PTR != NvM_Prv_Common_cst.ObserverCallback_pfct)      (inlined)
.L82:
	call	NvM_Prv_IsAuxServiceActive
.L509:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   572      if (!NvM_Prv_IsAuxServiceActive())      (inlined)
	jne	d2,#0,.L83
.L291:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   753      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
	jge.u	d11,#14,.L84
.L510:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   392  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   393   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   394   * This NvM private function checks for the given block whether the configured block length is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   395   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   396   * \param idBlock
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   397   * ID of the block for which the block length will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   398   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   399   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   400   * - TRUE = block length is valid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   401   * - FALSE = block length is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   402   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   403  LOCAL_INLINE boolean NvM_Prv_IsBlockLengthValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   404  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   405      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   406              (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   407              (0u != *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   408  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   409  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   410  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   411   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   412   * This NvM private function checks whether the given block is configured with immediate priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   413   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   414   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   415   * ID of the block for which the priority will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   416   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   417   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   418   * - TRUE = block is configured with immediate priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   419   * - FALSE = block is configured with standard priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   420   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   421  LOCAL_INLINE boolean NvM_Prv_HasBlockImmediateJobPriority(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   423      boolean HasBlockImmediateJobPriority_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   425  #if (NVM_JOB_PRIORITIZATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   426      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   427          (NVM_PRV_JOB_PRIORITY_IMMEDIATE == NvM_Prv_BlockDescriptors_acst[idBlock_uo].JobPriority_u8))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   428      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   429          HasBlockImmediateJobPriority_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   430      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   431  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   433  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   434  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   435  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   436   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   437   * This NvM private function returns the configured block size for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   438   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   439   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   440   * ID of the block for which the configured block size will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   441   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   442   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   443   * Configured block size
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   444   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   445  LOCAL_INLINE uint16 NvM_Prv_GetBlockSize(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   446  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   447      uint16 BlockSize_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   448  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   451      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   452          BlockSize_u16 = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   453      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   454  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   455      return BlockSize_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   456  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   457  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   458  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   459   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   460   * This NvM private function returns the configured block management type for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   461   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   462   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   463   * ID of the block for which the configured block management type will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   464   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   465   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   466   * Configured block management type
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   467   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   468  LOCAL_INLINE NvM_BlockManagementType NvM_Prv_GetBlockType(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   469  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   470      NvM_BlockManagementType BlockType = NVM_BLOCK_NATIVE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   472      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   473          BlockType = NvM_Prv_BlockDescriptors_acst[idBlock_uo].BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   474      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   475      return BlockType;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   476  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   477  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   478  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   479   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   480   * This NvM private function returns the configured number of non-volatile data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   481   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   482   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   483   * ID of the block for which the configured number of non-volatile data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   484   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   485   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   486   * Configured number of non-volatile data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   487   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   488  LOCAL_INLINE uint8 NvM_Prv_GetNrNonVolatileBlocks(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   489  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   490      uint8 nrNvBlocks_u8 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   491      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   492      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   493          nrNvBlocks_u8 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   494      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   495      return nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   496  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   497  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   498  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   499   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   500   * This NvM private function returns the configured overall number of data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   501   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   502   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   503   * ID of the block for which the configured overall number of data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   504   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   505   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   506   * Configured number of data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   507   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   508  LOCAL_INLINE uint16 NvM_Prv_GetNrDataIndexes(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   509  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   510      uint8 nrDataIndexes = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   511      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   512      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   513          nrDataIndexes = (NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8 +
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   514                           NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrRomBlocks_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   515      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   516      return nrDataIndexes;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   517  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   518  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   519  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   520   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   521   * This NvM private function returns the pointer to the configured permanent RAM block for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   522   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   523   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   524   * If no permanent RAM block is configured for a block then this function returns a NULL pointer.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   525   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   526   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   527   * ID of the block for which the pointer to the configured permanent RAM block will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   528   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   529   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   530   * Pointer to the configured permanent RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   531   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   532  LOCAL_INLINE void * NvM_Prv_GetPRamBlockAddress(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   533  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   534      void * PRamBlockAddress_pv = NULL_PTR;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   535      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   536          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   537      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   538          PRamBlockAddress_pv = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   539      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   540  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   541      return PRamBlockAddress_pv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   542  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   543  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   544  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   545   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   546   * This NvM private function returns the pointer to the configured ROM block for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   547   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   548   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   549   * If no ROM block is configured for a block then this function returns a NULL pointer.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   550   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   551   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   552   * ID of the block for which the pointer to the configured ROM block will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   553   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   554   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   555   * Pointer to the configured ROM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   556   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   557  LOCAL_INLINE void const* NvM_Prv_GetRomBlockAddress(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   558  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   559      void const* adrRomBlock_pcv = NULL_PTR;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   560      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   561      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   562          adrRomBlock_pcv = NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   563      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   564      return adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   565  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   566  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   567  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   568   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   569   * This NvM private function returns the configured block ID used by the mem interface for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   570   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   571   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   572   * ID of the block for which the block ID used by the mem interface will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   573   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   574   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   575   * Configured block ID used by the mem interface
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   576   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   577  LOCAL_INLINE uint16 NvM_Prv_GetIdBlockMemIf(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   578  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   579      uint16 idBlockMemIf_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   580      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   581      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   582          idBlockMemIf_u16 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   583      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   584      return idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   585  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   586  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   587  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   588   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   589   * This NvM private function returns the configured device index where the given block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   590   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   591   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   592   * ID of the block for which the configured device index will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   593   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   594   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   595   * Configured device index where the given block is located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   596   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   597  LOCAL_INLINE uint8 NvM_Prv_GetIdxDevice(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   598  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   599      uint8 idxDevice_u8 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   600      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   601      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   602          idxDevice_u8 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   603      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   604      return idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   605  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   606  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   607  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   608   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   609   * This NvM private function returns the configured persistent ID of a block identified by index for persistent IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   610   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   611   * \param idxPersistentId_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   612   * Index of the required persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   613   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   614   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   615   * Configured persistent ID of a block identified by index for persistent IDs
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   616   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   617  LOCAL_INLINE uint16 NvM_Prv_GetIdPersistent(uint16 idxPersistentId_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   618  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   619      uint16 PersistentId_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   620      if (idxPersistentId_u16 < NVM_PRV_NR_PERSISTENT_IDS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   621      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   622          PersistentId_u16 = NvM_Prv_PersId_BlockId_acst[idxPersistentId_u16].PersistentId_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   623      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   624      return PersistentId_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   625  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   626  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   627  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   628   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   629   * This NvM private function returns the configured NvM ID of a block identified by index for persistent IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   630   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   631   * \param idxPersistentId_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   632   * Index of the required persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   633   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   634   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   635   * Configured NvM ID of a block identified by index for persistent IDs
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   636   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   637  LOCAL_INLINE NvM_BlockIdType NvM_Prv_GetIdBlock(uint16 idxPersistentId_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   638  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   639      uint16 BlockId_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   640      if (idxPersistentId_u16 < NVM_PRV_NR_PERSISTENT_IDS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   641      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   642          BlockId_u16 = NvM_Prv_PersId_BlockId_acst[idxPersistentId_u16].BlockId_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   643      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   644      return BlockId_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   645  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   646  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   647  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   648   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   649   * This NvM private function returns the configured pointer to the block specific callback function
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   650   * to copy data from the NvM mirror to the application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   651   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   652   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   653   * ID of the block for which the configured copy function will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   654   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   655   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   656   * Configured pointer to the copy function
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   657   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   658  LOCAL_INLINE NvM_Prv_ExplicitSync_Copy_tpfct NvM_Prv_GetCopyFctForRead(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   659  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   660      NvM_Prv_ExplicitSync_Copy_tpfct ReadRamBlockFromNvm_pfct = NULL_PTR;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   661      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   662      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   663          ReadRamBlockFromNvm_pfct = NvM_Prv_BlockDescriptors_acst[idBlock_uo].ReadRamBlockFromNvm_pfct;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   664      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   665      return ReadRamBlockFromNvm_pfct;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   666  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   667  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   668  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   669   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   670   * This NvM private function returns the configured pointer to the block specific callback function
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   671   * to copy data from the application's RAM block to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   672   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   673   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   674   * ID of the block for which the configured copy function will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   675   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   676   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   677   * Configured pointer to the copy function
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   678   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   679  LOCAL_INLINE NvM_Prv_ExplicitSync_Copy_tpfct NvM_Prv_GetCopyFctForWrite(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   680  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   681      NvM_Prv_ExplicitSync_Copy_tpfct WriteRamBlockToNvm_pfct = NULL_PTR;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   682      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   683      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   684          WriteRamBlockToNvm_pfct = NvM_Prv_BlockDescriptors_acst[idBlock_uo].WriteRamBlockToNvm_pfct;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   685      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   686      return WriteRamBlockToNvm_pfct;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   687  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   688  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   689  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   690   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   691   * This NvM private function returns the configured block specific initializaton callback function.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   692   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   693   * If no initializaton callback function is configured for the passed block then this function does nothing and
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   694   * returns E_NOT_OK.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   695   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   696   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   697   * ID of the block for which the configured initialization callback function will be invoked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   698   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   699   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   700   * E_OK = initialization callback function is configured and has returned E_OK
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   701   * E_NOT_OK = no initialization callback function is configured or has returned E_NOT_OK
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   702   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   703  LOCAL_INLINE Std_ReturnType NvM_Prv_InvokeInitBlockCallback(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   704  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   705      Std_ReturnType RetValue = E_NOT_OK;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   706      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   707          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   708      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   709          RetValue = NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct();
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   710      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   711      return RetValue;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   712  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   713  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   714  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   715   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   716   * This NvM private function invokes the configured block specific single request start callback function.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   717   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   718   * If no single request start callback function is configured for the passed block then this function does nothing.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   719   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   720   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   721   * ID of the block for which the configured single request start callback function will be invoked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   722   * \param idService_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   723   * Id of the request for which the start callback function will be invoked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   724   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   725  LOCAL_INLINE void NvM_Prv_InvokeSingleBlockStartCallback(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   726                                                           NvM_Prv_idService_tuo idService_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   727  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   728      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   729          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].SingleBlockStartCallback_pfct))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   730      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   731          // Start callback function returns allways E_OK so return value can be dropped safely
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   732          (void)(NvM_Prv_BlockDescriptors_acst[idBlock_uo].SingleBlockStartCallback_pfct)(idService_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   733      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   734  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   735  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   736  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   737   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   738   * This NvM private function invokes the configured block specific single request termination callback function.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   739   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   740   * If no single request termination callback function is configured for the passed block then this function does nothing.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   741   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   742   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   743   * ID of the block for which the configured termination callback function will be invoked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   744   * \param idService_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   745   * Id of the request for which the termination callback function will be invoked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   746   * \param Result_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   747   * Result of the terminated request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   748   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   749  LOCAL_INLINE void NvM_Prv_InvokeSingleBlockCallback(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   750                                                      NvM_Prv_idService_tuo idService_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   751                                                      NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   752  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   753      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   754          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].SingleBlockCallback_pfct))
	mul	d15,d11,#48
.L511:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L512:
	addsc.a	a15,a15,d15,#0
.L513:
	ld.a	a15,[a15]20
.L514:
	mov.a	a2,#0
.L515:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   754          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].SingleBlockCallback_pfct))      (inlined)
	jeq.a	a2,a15,.L85
.L516:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   755      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   756          // Termination callback function returns allways E_OK so return value can be dropped safely
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   757          (void)(NvM_Prv_BlockDescriptors_acst[idBlock_uo].SingleBlockCallback_pfct)(idService_uo, Result_uo);
	mov	e4,d8,d9
	calli	a15

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   753      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
.L85:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   754          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].SingleBlockCallback_pfct))      (inlined)
.L84:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   572      if (!NvM_Prv_IsAuxServiceActive())      (inlined)
.L83:
.L81:
	ret
.L208:
	
__NvM_Prv_MainFunctionResultEval_function_end:
	.size	NvM_Prv_MainFunctionResultEval,__NvM_Prv_MainFunctionResultEval_function_end-NvM_Prv_MainFunctionResultEval
.L126:
	; End of function
	
	.sdecl	'.rodata.NvM_MainFunctionResultEval.NvM_Prv_JobEvalReqResultFcts_capfct',data,rom,cluster('NvM_Prv_JobEvalReqResultFcts_capfct')
	.sect	'.rodata.NvM_MainFunctionResultEval.NvM_Prv_JobEvalReqResultFcts_capfct'
	.align	4
NvM_Prv_JobEvalReqResultFcts_capfct:	.type	object
	.size	NvM_Prv_JobEvalReqResultFcts_capfct,52
	.space	4
	.word	NvM_Prv_EvalReqResult_Read,NvM_Prv_EvalReqResult,NvM_Prv_EvalReqResult,NvM_Prv_EvalReqResult
	.space	4
	.word	NvM_Prv_EvalReqResult,NvM_Prv_EvalReqResult,NvM_Prv_EvalReqResult_ReadIdConfigForReadAll,NvM_Prv_EvalReqResult
	.word	NvM_Prv_EvalReqResult_RestoreForImplicitRecovery,NvM_Prv_EvalReqResult_InvalidateForRemoveNonResistant
	.space	4
	.sdecl	'.rodata.NvM_MainFunctionResultEval.NvM_Prv_JobEvalProductionErrorsFcts_capfct',data,rom,cluster('NvM_Prv_JobEvalProductionErrorsFcts_capfct')
	.sect	'.rodata.NvM_MainFunctionResultEval.NvM_Prv_JobEvalProductionErrorsFcts_capfct'
	.align	4
NvM_Prv_JobEvalProductionErrorsFcts_capfct:	.type	object
	.size	NvM_Prv_JobEvalProductionErrorsFcts_capfct,52
	.space	4
	.word	NvM_Prv_EvalProductionErrors_Read,NvM_Prv_EvalProductionErrors,NvM_Prv_EvalProductionErrors,NvM_Prv_EvalProductionErrors
	.space	4
	.word	NvM_Prv_EvalProductionErrors,NvM_Prv_EvalProductionErrors,NvM_Prv_EvalProductionErrors_ReadIdConfigForReadAll,NvM_Prv_EvalProductionErrors
	.word	NvM_Prv_EvalProductionErrors,NvM_Prv_EvalProductionErrors
	.space	4
	.sdecl	'.rodata.NvM_MainFunctionResultEval.NvM_Prv_JobUpdateBlockStatusFcts_capfct',data,rom,cluster('NvM_Prv_JobUpdateBlockStatusFcts_capfct')
	.sect	'.rodata.NvM_MainFunctionResultEval.NvM_Prv_JobUpdateBlockStatusFcts_capfct'
	.align	4
NvM_Prv_JobUpdateBlockStatusFcts_capfct:	.type	object
	.size	NvM_Prv_JobUpdateBlockStatusFcts_capfct,52
	.space	4
	.word	NvM_Prv_UpdateBlockStatus_ReadWrite,NvM_Prv_UpdateBlockStatus_ReadWrite
	.space	4
	.word	NvM_Prv_UpdateBlockStatus_Restore
	.space	4
	.word	NvM_Prv_UpdateBlockStatusJobValidate
	.space	4
	.word	NvM_Prv_UpdateBlockStatusIdConfigForReadAll
	.space	4
	.word	NvM_Prv_UpdateBlockStatus_Restore
	.space	8
	.calls	'__INDIRECT__','NvM_Prv_EvalReqResult'
	.calls	'__INDIRECT__','NvM_Prv_EvalReqResult_Read'
	.calls	'__INDIRECT__','NvM_Prv_EvalReqResult_InvalidateForRemoveNonResistant'
	.calls	'__INDIRECT__','NvM_Prv_EvalReqResult_RestoreForImplicitRecovery'
	.calls	'__INDIRECT__','NvM_Prv_EvalReqResult_ReadIdConfigForReadAll'
	.calls	'__INDIRECT__','NvM_Prv_EvalProductionErrors'
	.calls	'__INDIRECT__','NvM_Prv_EvalProductionErrors_Read'
	.calls	'__INDIRECT__','NvM_Prv_EvalProductionErrors_ReadIdConfigForReadAll'
	.calls	'__INDIRECT__','NvM_Prv_UpdateBlockStatus_Restore'
	.calls	'__INDIRECT__','NvM_Prv_UpdateBlockStatus_ReadWrite'
	.calls	'__INDIRECT__','NvM_Prv_UpdateBlockStatusJobValidate'
	.calls	'__INDIRECT__','NvM_Prv_UpdateBlockStatusIdConfigForReadAll'
	.calls	'NvM_Prv_MainFunctionResultEval','NvM_Prv_GetActiveService'
	.calls	'NvM_Prv_MainFunctionResultEval','NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible'
	.calls	'NvM_Prv_MainFunctionResultEval','NvM_Prv_GetFctJobEvalReqResult'
	.calls	'NvM_Prv_MainFunctionResultEval','NvM_Prv_GetFctJobEvalProductionErrors'
	.calls	'NvM_Prv_MainFunctionResultEval','NvM_Prv_GetFctJobUpdateBlockStatus'
	.calls	'NvM_Prv_MainFunctionResultEval','__INDIRECT__'
	.calls	'NvM_Prv_MainFunctionResultEval','NvM_Prv_IsMultiActive'
	.calls	'NvM_Prv_MainFunctionResultEval','NvM_Prv_Multi_SetResult'
	.calls	'NvM_Prv_MainFunctionResultEval','NvM_Prv_ErrorDetection_SetProductionError'
	.calls	'NvM_Prv_MainFunctionResultEval','NvM_Prv_Queue_DequeueRequest'
	.calls	'NvM_Prv_MainFunctionResultEval','NvM_Prv_IsAuxServiceActive'
	.calls	'NvM_Prv_EvalReqResult','',0
	.calls	'NvM_Prv_EvalReqResult_Read','',0
	.calls	'NvM_Prv_EvalReqResult_InvalidateForRemoveNonResistant','',0
	.calls	'NvM_Prv_EvalReqResult_RestoreForImplicitRecovery','',0
	.calls	'NvM_Prv_EvalReqResult_ReadIdConfigForReadAll','',0
	.calls	'NvM_Prv_EvalProductionErrors','',0
	.calls	'NvM_Prv_EvalProductionErrors_Read','',0
	.calls	'NvM_Prv_EvalProductionErrors_ReadIdConfigForReadAll','',0
	.calls	'NvM_Prv_UpdateBlockStatus_Restore','',0
	.calls	'NvM_Prv_UpdateBlockStatus_ReadWrite','',0
	.calls	'NvM_Prv_UpdateBlockStatusJobValidate','',0
	.calls	'NvM_Prv_UpdateBlockStatusIdConfigForReadAll','',0
	.calls	'NvM_Prv_GetFctJobEvalReqResult','',0
	.calls	'NvM_Prv_GetFctJobEvalProductionErrors','',0
	.calls	'NvM_Prv_GetFctJobUpdateBlockStatus','',0
	.extern	NvM_Prv_Main_st
	.extern	NvM_Prv_GetActiveService
	.extern	NvM_Prv_IsMultiActive
	.extern	NvM_Prv_IsAuxServiceActive
	.extern	NvM_Prv_Queue_DequeueRequest
	.extern	NvM_Prv_Common_cst
	.extern	NvM_Prv_BlockDescriptors_acst
	.extern	NvM_Prv_stBlock_rAwAM_au8
	.extern	NvM_Prv_stRequests_rAMwAM_au16
	.extern	NvM_Prv_stRequestResult_rAwAM_au8
	.extern	NvM_Prv_idConfigStored_rMwM_u16
	.extern	NvM_Prv_ErrorDetection_SetProductionError
	.extern	NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible
	.extern	NvM_Prv_Multi_SetResult
	.extern	__INDIRECT__
	.calls	'NvM_Prv_MainFunctionResultEval','',16
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L119:
	.word	15614
	.half	3
	.word	.L120
	.byte	4
.L118:
	.byte	1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L121
.L209:
	.byte	2
	.byte	'unsigned char',0,1,8
.L215:
	.byte	2
	.byte	'unsigned short int',0,2,7,3,1,34,9,4,4
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL',0,1,4
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL',0,2,4
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL',0,4,4
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE',0,8,4
	.byte	'NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED',0,16,4
	.byte	'NVM_PRV_BLOCK_FLAG_WRITE_ONCE',0,32,4
	.byte	'NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW',0,192,0,4
	.byte	'NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM',0,128,1,4
	.byte	'NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION',0,128,2,4
	.byte	'NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH',0,128,4,4
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION',0,128,8,4
	.byte	'NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL',0,128,16,0
.L371:
	.byte	5
	.byte	'NvM_Prv_IsBlockSelected',0,3,1,239,2,22
	.word	152
	.byte	1,1
.L374:
	.byte	6
	.byte	'idBlock_uo',0,1,239,2,62
	.word	169
.L376:
	.byte	6
	.byte	'SelectionMask_en',0,1,240,2,77
	.word	191
.L378:
	.byte	7,0,3,2,40,9,4,4
	.byte	'NVM_BLOCK_NATIVE',0,0,4
	.byte	'NVM_BLOCK_REDUNDANT',0,1,4
	.byte	'NVM_BLOCK_DATASET',0,2,0,5
	.byte	'NvM_Prv_GetBlockType',0,3,1,212,3,38
	.word	799
	.byte	1,1,6
	.byte	'idBlock_uo',0,1,212,3,75
	.word	169
	.byte	7,0,5
	.byte	'NvM_Prv_GetNrNonVolatileBlocks',0,3,1,232,3,20
	.word	152
	.byte	1,1,6
	.byte	'idBlock_uo',0,1,232,3,67
	.word	169
	.byte	7,0,8
	.byte	'void',0
.L348:
	.byte	9
	.word	986
.L340:
	.byte	5
	.byte	'NvM_Prv_GetPRamBlockAddress',0,3,1,148,4,21
	.word	992
	.byte	1,1
.L342:
	.byte	6
	.byte	'idBlock_uo',0,1,148,4,65
	.word	169
.L344:
	.byte	7,0,10
	.word	986
	.byte	9
	.word	1059
	.byte	5
	.byte	'NvM_Prv_GetRomBlockAddress',0,3,1,173,4,26
	.word	1064
	.byte	1,1,6
	.byte	'idBlock_uo',0,1,173,4,69
	.word	169
	.byte	7,0
.L290:
	.byte	11
	.byte	'NvM_Prv_InvokeSingleBlockCallback',0,3,1,237,5,19,1,1
.L292:
	.byte	6
	.byte	'idBlock_uo',0,1,237,5,69
	.word	169
.L294:
	.byte	6
	.byte	'idService_uo',0,1,238,5,75
	.word	152
.L296:
	.byte	6
	.byte	'Result_uo',0,1,239,5,75
	.word	152
.L298:
	.byte	7,0
.L282:
	.byte	11
	.byte	'NvM_Prv_InvokeObserverCallback',0,3,1,134,6,19,1,1
.L283:
	.byte	6
	.byte	'idBlock_uo',0,1,134,6,66
	.word	169
.L285:
	.byte	6
	.byte	'idService_uo',0,1,135,6,72
	.word	152
.L287:
	.byte	6
	.byte	'Result_uo',0,1,136,6,72
	.word	152
.L289:
	.byte	7,0,5
	.byte	'NvM_Prv_Block_IsInRom',0,3,3,142,1,22
	.word	152
	.byte	1,1,6
	.byte	'idBlock_uo',0,3,142,1,60
	.word	169
	.byte	6
	.byte	'idxDataset_u8',0,3,142,1,78
	.word	152
	.byte	12,7,7,0,0,5
	.byte	'NvM_Prv_Block_IsWriteProtected',0,3,3,148,1,22
	.word	152
	.byte	1,1,6
	.byte	'idBlock_uo',0,3,148,1,69
	.word	169
	.byte	7,0
.L244:
	.byte	11
	.byte	'NvM_Prv_Block_SetRequestResult',0,3,3,190,1,19,1,1
.L247:
	.byte	6
	.byte	'idBlock_uo',0,3,190,1,66
	.word	169
.L249:
	.byte	6
	.byte	'Result_uo',0,3,190,1,100
	.word	152
.L251:
	.byte	7,0
.L266:
	.byte	11
	.byte	'NvM_Prv_Block_ClearRequests',0,3,3,205,1,19,1,1
.L268:
	.byte	6
	.byte	'idBlock_uo',0,3,205,1,63
	.word	169
.L270:
	.byte	6
	.byte	'maskRequests_u16',0,3,205,1,82
	.word	169
.L272:
	.byte	7,0
.L350:
	.byte	11
	.byte	'NvM_Prv_Block_SetState',0,3,3,210,1,19,1,1
.L352:
	.byte	6
	.byte	'idBlock_uo',0,3,210,1,58
	.word	169
.L354:
	.byte	6
	.byte	'maskBitsToChange_u8',0,3,211,1,48
	.word	152
.L356:
	.byte	6
	.byte	'maskBitsNewValue_u8',0,3,212,1,48
	.word	152
.L358:
	.byte	7,0
.L315:
	.byte	5
	.byte	'NvM_Prv_Block_HasIdConfigChanged',0,3,3,218,1,22
	.word	152
	.byte	1,1
.L317:
	.byte	7,0
.L318:
	.byte	11
	.byte	'NvM_Prv_Block_SetIdConfig',0,3,3,223,1,19,1,1
.L321:
	.byte	6
	.byte	'idConfigNew_u16',0,3,223,1,52
	.word	169
.L323:
	.byte	7,0
.L388:
	.byte	5
	.byte	'NvM_Prv_Block_InitIdConfigDuringWriteAll',0,3,3,228,1,22
	.word	152
	.byte	1,1
.L389:
	.byte	7,0
.L396:
	.byte	3,2,104,9,4,4
	.byte	'NvM_Prv_idJob_Idle_e',0,0,4
	.byte	'NvM_Prv_idJob_Read_e',0,1,4
	.byte	'NvM_Prv_idJob_Write_e',0,2,4
	.byte	'NvM_Prv_idJob_Erase_e',0,3,4
	.byte	'NvM_Prv_idJob_Restore_e',0,4,4
	.byte	'NvM_Prv_idJob_Maintain_e',0,5,4
	.byte	'NvM_Prv_idJob_Validate_e',0,6,4
	.byte	'NvM_Prv_idJob_Invalidate_e',0,7,4
	.byte	'NvM_Prv_idJob_ReadIdConfigForReadAll_e',0,8,4
	.byte	'NvM_Prv_idJob_InvalidateForFirstInitAll_e',0,9,4
	.byte	'NvM_Prv_idJob_RestoreForImplicitRecovery_e',0,10,4
	.byte	'NvM_Prv_idJob_InvalidateForRemoveNonResistant_e',0,11,4
	.byte	'NvM_Prv_idJob_Invalid_e',0,12,4
	.byte	'NvM_Prv_idJob_Count_e',0,13,0,9
	.word	152
	.byte	3,5,31,9,4,4
	.byte	'MEMIF_JOB_OK',0,0,4
	.byte	'MEMIF_JOB_FAILED',0,1,4
	.byte	'MEMIF_JOB_PENDING',0,2,4
	.byte	'MEMIF_JOB_CANCELED',0,3,4
	.byte	'MEMIF_BLOCK_INCONSISTENT',0,4,4
	.byte	'MEMIF_BLOCK_INVALID',0,5,0,13,2,227,1,9,20,14
	.byte	'idJob_en',0
	.word	1922
	.byte	4,2,35,0,14
	.byte	'idBlock_uo',0
	.word	169
	.byte	2,2,35,4,14
	.byte	'RamBlock_pu8',0
	.word	2361
	.byte	4,2,35,8,14
	.byte	'idxDataset_u8',0
	.word	152
	.byte	1,2,35,12,14
	.byte	'Result_en',0
	.word	2366
	.byte	4,2,35,16,0,10
	.word	2496
.L300:
	.byte	9
	.word	2605
	.byte	9
	.word	152
.L217:
	.byte	5
	.byte	'NvM_Prv_EvalCommonResults',0,3,4,248,3,22
	.word	152
	.byte	1,1
.L220:
	.byte	6
	.byte	'JobData_pcst',0,4,248,3,75
	.word	2610
.L222:
	.byte	6
	.byte	'stReqResult_puo',0,4,249,3,71
	.word	2615
.L224:
	.byte	6
	.byte	'stProductionErrors_pu8',0,4,250,3,55
	.word	2361
.L226:
	.byte	12
.L235:
	.byte	7,0,0
.L273:
	.byte	11
	.byte	'NvM_Prv_MainFunctionResultEval_FinalBlockCallbacks',0,3,4,172,4,19,1,1
.L275:
	.byte	6
	.byte	'stRequestResult_uo',0,4,172,4,92
	.word	152
.L277:
	.byte	6
	.byte	'idActiveBlock_uo',0,4,173,4,86
	.word	169
.L279:
	.byte	6
	.byte	'idActiveService_uo',0,4,174,4,92
	.word	152
.L281:
	.byte	12,7,7,0,0
.L252:
	.byte	11
	.byte	'NvM_Prv_MainFunctionResultEval_ResetMainStates',0,3,4,197,4,19,1,1
.L254:
	.byte	6
	.byte	'idBlock_uo',0,4,197,4,82
	.word	169
.L256:
	.byte	6
	.byte	'idQueue_uo',0,4,198,4,86
	.word	152
.L258:
	.byte	6
	.byte	'idService_uo',0,4,199,4,88
	.word	152
.L260:
	.byte	6
	.byte	'ServiceBit_uo',0,4,200,4,89
	.word	169
.L262:
	.byte	6
	.byte	'stRequestResult_uo',0,4,201,4,88
	.word	152
.L264:
	.byte	12,7,0,0,15
	.byte	'NvM_Prv_GetActiveService',0,6,101,30
	.word	152
	.byte	1,1,1,1,15
	.byte	'NvM_Prv_IsMultiActive',0,6,103,16
	.word	152
	.byte	1,1,1,1,15
	.byte	'NvM_Prv_IsAuxServiceActive',0,6,104,16
	.word	152
	.byte	1,1,1,1,10
	.word	2496
	.byte	9
	.word	3169
	.byte	16
	.word	152
	.byte	1,1,17
	.word	3174
	.byte	0,9
	.word	3179
	.byte	9
	.word	3179
.L238:
	.byte	18
	.byte	'NvM_Prv_JobEvalReqResult_tpfct',0,4,22,33
	.word	3197
	.byte	9
	.word	3179
	.byte	9
	.word	3179
.L240:
	.byte	18
	.byte	'NvM_Prv_JobEvalProductionErrors_tpfct',0,4,23,17
	.word	3246
	.byte	19,1,1,17
	.word	3174
	.byte	0,9
	.word	3297
	.byte	9
	.word	3297
.L242:
	.byte	18
	.byte	'NvM_Prv_JobUpdateBlockStatus_tpfct',0,4,24,16
	.word	3311
	.byte	20
	.byte	'NvM_Prv_Queue_DequeueRequest',0,7,42,13,1,1,1,1,6
	.byte	'idQueue_uo',0,7,42,62
	.word	152
	.byte	0,21
	.word	715
	.byte	22
	.word	751
	.byte	22
	.word	771
	.byte	7,0,21
	.word	866
	.byte	22
	.word	899
	.byte	7,0,21
	.word	921
	.byte	22
	.word	964
	.byte	7,0,21
	.word	997
	.byte	22
	.word	1037
	.byte	7,0,21
	.word	1069
	.byte	22
	.word	1108
	.byte	7,0,21
	.word	1130
	.byte	22
	.word	1172
	.byte	22
	.word	1192
	.byte	22
	.word	1214
	.byte	7,0,21
	.word	1235
	.byte	22
	.word	1274
	.byte	22
	.word	1294
	.byte	22
	.word	1316
	.byte	7,0,21
	.word	1337
	.byte	22
	.word	1371
	.byte	22
	.word	1391
	.byte	12,23
	.word	866
	.byte	22
	.word	899
	.byte	24
	.word	919
	.byte	0,7,23
	.word	921
	.byte	22
	.word	964
	.byte	24
	.word	984
	.byte	0,7,0,0,21
	.word	1419
	.byte	22
	.word	1462
	.byte	7,0,21
	.word	1484
	.byte	22
	.word	1523
	.byte	22
	.word	1543
	.byte	7,0,21
	.word	1564
	.byte	22
	.word	1600
	.byte	22
	.word	1620
	.byte	7,0,21
	.word	1648
	.byte	22
	.word	1679
	.byte	22
	.word	1699
	.byte	22
	.word	1728
	.byte	7,0,21
	.word	1759
	.byte	7,0,21
	.word	1806
	.byte	22
	.word	1840
	.byte	7,0,21
	.word	1867
	.byte	7,0,20
	.byte	'NvM_Prv_ErrorDetection_SetProductionError',0,8,53,13,1,1,1,1,6
	.byte	'idBlock_uo',0,8,53,71
	.word	169
	.byte	6
	.byte	'MaskErrorBit_u8',0,8,53,89
	.word	152
	.byte	0,25
	.byte	'NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible',0,8,63,16
	.word	152
	.byte	1,1,1,1,6
	.byte	'idService_uo',0,8,63,87
	.word	152
	.byte	6
	.byte	'idBlock_uo',0,8,64,81
	.word	169
	.byte	6
	.byte	'JobResult_en',0,8,65,85
	.word	2366
	.byte	0,20
	.byte	'NvM_Prv_Multi_SetResult',0,9,22,13,1,1,1,1,6
	.byte	'Result_uo',0,9,22,59
	.word	152
	.byte	0,21
	.word	2620
	.byte	22
	.word	2658
	.byte	22
	.word	2680
	.byte	22
	.word	2705
	.byte	12,7,0,0,21
	.word	2741
	.byte	22
	.word	2800
	.byte	22
	.word	2828
	.byte	22
	.word	2854
	.byte	12,23
	.word	1235
	.byte	22
	.word	1274
	.byte	22
	.word	1294
	.byte	22
	.word	1316
	.byte	24
	.word	1335
	.byte	0,7,23
	.word	1130
	.byte	22
	.word	1172
	.byte	22
	.word	1192
	.byte	22
	.word	1214
	.byte	24
	.word	1233
	.byte	0,7,0,0,21
	.word	2887
	.byte	22
	.word	2942
	.byte	22
	.word	2962
	.byte	22
	.word	2982
	.byte	22
	.word	3004
	.byte	22
	.word	3027
	.byte	12,23
	.word	1564
	.byte	22
	.word	1600
	.byte	22
	.word	1620
	.byte	24
	.word	1646
	.byte	0,7,0,0,26
	.byte	'__INDIRECT__',0,4,1,1,1,1,1,27,1,9
	.word	4115
	.byte	18
	.byte	'__codeptr',0,4,1,1
	.word	4117
	.byte	2
	.byte	'char',0,1,6,18
	.byte	'sint8',0,10,76,25
	.word	4140
	.byte	18
	.byte	'uint8',0,10,81,25
	.word	152
	.byte	18
	.byte	'uint16',0,10,91,25
	.word	169
	.byte	2
	.byte	'unsigned int',0,4,7,18
	.byte	'uint32',0,10,106,24
	.word	4191
	.byte	2
	.byte	'unsigned long long int',0,8,7,18
	.byte	'uint64',0,10,111,30
	.word	4222
	.byte	18
	.byte	'boolean',0,10,127,25
	.word	152
	.byte	18
	.byte	'StatusType',0,11,191,1,27
	.word	152
	.byte	18
	.byte	'Std_ReturnType',0,11,199,1,15
	.word	152
	.byte	13,11,206,1,9,8,14
	.byte	'vendorID',0
	.word	169
	.byte	2,2,35,0,14
	.byte	'moduleID',0
	.word	169
	.byte	2,2,35,2,14
	.byte	'sw_major_version',0
	.word	152
	.byte	1,2,35,4,14
	.byte	'sw_minor_version',0
	.word	152
	.byte	1,2,35,5,14
	.byte	'sw_patch_version',0
	.word	152
	.byte	1,2,35,6,0,18
	.byte	'Std_VersionInfoType',0,11,213,1,3
	.word	4323
	.byte	18
	.byte	'PduIdType',0,12,22,19
	.word	169
	.byte	18
	.byte	'PduLengthType',0,12,26,19
	.word	169
	.byte	3,13,113,9,4,4
	.byte	'TP_DATACONF',0,0,4
	.byte	'TP_DATARETRY',0,1,4
	.byte	'TP_CONFPENDING',0,2,0,18
	.byte	'TpDataStateType',0,13,118,3
	.word	4513
	.byte	18
	.byte	'Can_IdType',0,14,32,16
	.word	4191
	.byte	18
	.byte	'Can_HwHandleType',0,14,43,16
	.word	169
	.byte	13,15,93,9,8,14
	.byte	'Class',0
	.word	152
	.byte	1,2,35,0,14
	.byte	'TIN',0
	.word	152
	.byte	1,2,35,1,14
	.byte	'ReturnAddress',0
	.word	4191
	.byte	4,2,35,4,0,18
	.byte	'OsTrapInfoType',0,15,97,3
	.word	4633
	.byte	28,68
	.word	4191
	.byte	29,16,0,13,15,154,1,9,68,14
	.byte	'store',0
	.word	4713
	.byte	68,2,35,0,0,28,68
	.word	4722
	.byte	29,0,0,18
	.byte	'Os_JumpBufType',0,15,156,1,3
	.word	4744
	.byte	18
	.byte	'Os_StackTraceType',0,15,174,1,18
	.word	4191
	.byte	13,15,175,1,9,8,14
	.byte	'sp',0
	.word	4191
	.byte	4,2,35,0,14
	.byte	'ctx',0
	.word	4191
	.byte	4,2,35,4,0,18
	.byte	'Os_StackValueType',0,15,175,1,63
	.word	4804
	.byte	18
	.byte	'Os_StackSizeType',0,15,176,1,27
	.word	4804
	.byte	30,1,1,9
	.word	4889
	.byte	18
	.byte	'Os_VoidVoidFunctionType',0,15,179,1,16
	.word	4892
	.byte	18
	.byte	'ApplicationType',0,15,193,1,23
	.word	152
	.byte	31
	.byte	'Os_ApplicationConfigurationType_s',0,15,198,1,16,2,14
	.byte	'app_id',0
	.word	152
	.byte	1,2,35,0,14
	.byte	'access',0
	.word	152
	.byte	1,2,35,1,0,18
	.byte	'Os_ApplicationConfigurationType',0,15,201,1,3
	.word	4955
	.byte	18
	.byte	'Os_CoreStateType',0,15,203,1,16
	.word	4191
	.byte	18
	.byte	'AreaIdType',0,15,204,1,16
	.word	169
	.byte	18
	.byte	'Os_PeripheralAddressType',0,15,212,1,22
	.word	4191
	.byte	18
	.byte	'TickType',0,15,221,1,22
	.word	4191
	.byte	18
	.byte	'Os_StopwatchTickType',0,15,225,1,22
	.word	4191
	.byte	9
	.word	4191
	.byte	18
	.byte	'Os_Lockable',0,15,234,1,18
	.word	5197
	.byte	18
	.byte	'CoreIdType',0,15,236,1,16
	.word	169
	.byte	18
	.byte	'SpinlockIdType',0,15,237,1,16
	.word	169
	.byte	3,15,239,1,9,4,4
	.byte	'TRYTOGETSPINLOCK_SUCCESS',0,0,4
	.byte	'TRYTOGETSPINLOCK_NOSUCCESS',0,1,0,18
	.byte	'TryToGetSpinlockType',0,15,239,1,74
	.word	5267
	.byte	3,15,174,2,9,4,4
	.byte	'APPLICATION_ACCESSIBLE',0,0,4
	.byte	'APPLICATION_RESTARTING',0,1,4
	.byte	'APPLICATION_TERMINATED',0,2,0,18
	.byte	'ApplicationStateType',0,15,174,2,92
	.word	5360
	.byte	19,1,1,17
	.word	152
	.byte	17
	.word	992
	.byte	0,9
	.word	5472
	.byte	18
	.byte	'Os_FunctionEntryType',0,15,183,2,16
	.word	5486
	.byte	31
	.byte	'Os_MeterInfoType_s',0,15,193,2,16,48,14
	.byte	'elapsed',0
	.word	4191
	.byte	4,2,35,0,14
	.byte	'previous',0
	.word	4191
	.byte	4,2,35,4,14
	.byte	'max',0
	.word	4191
	.byte	4,2,35,8,14
	.byte	'cumulative',0
	.word	4191
	.byte	4,2,35,12,14
	.byte	'stackbase',0
	.word	4804
	.byte	8,2,35,16,14
	.byte	'stackusage',0
	.word	4804
	.byte	8,2,35,24,14
	.byte	'stackmax',0
	.word	4804
	.byte	8,2,35,32,14
	.byte	'stackbudget',0
	.word	4804
	.byte	8,2,35,40,0,18
	.byte	'Os_MeterInfoType',0,15,202,2,3
	.word	5521
	.byte	9
	.word	5521
	.byte	18
	.byte	'Os_MeterInfoRefType',0,15,203,2,50
	.word	5719
	.byte	18
	.byte	'EventMaskType',0,15,206,2,15
	.word	152
	.byte	18
	.byte	'Os_imaskType',0,15,211,2,16
	.word	4191
	.byte	31
	.byte	'Os_ISRDynType_s',0,15,213,2,16,48,14
	.byte	'meter',0
	.word	5521
	.byte	48,2,35,0,0,18
	.byte	'Os_ISRDynType',0,15,215,2,3
	.word	5798
	.byte	9
	.word	5798
	.byte	10
	.word	5859
	.byte	31
	.byte	'Os_ISRType_s',0,15,216,2,16,24,14
	.byte	'entry_function',0
	.word	4897
	.byte	4,2,35,0,14
	.byte	'dynamic',0
	.word	5864
	.byte	4,2,35,4,14
	.byte	'imask',0
	.word	4191
	.byte	4,2,35,8,14
	.byte	'stackbudget',0
	.word	4804
	.byte	8,2,35,12,14
	.byte	'access',0
	.word	152
	.byte	1,2,35,20,14
	.byte	'application',0
	.word	152
	.byte	1,2,35,21,0,18
	.byte	'Os_ISRType',0,15,223,2,3
	.word	5869
	.byte	9
	.word	4889
	.byte	10
	.word	5869
	.byte	9
	.word	6028
	.byte	18
	.byte	'ISRType',0,15,224,2,46
	.word	6033
	.byte	18
	.byte	'Os_bitmask',0,15,239,2,22
	.word	4191
	.byte	18
	.byte	'Os_pset0Type',0,15,240,2,20
	.word	4191
	.byte	18
	.byte	'Os_pset1Type',0,15,241,2,20
	.word	4191
	.byte	18
	.byte	'Os_pset2Type',0,15,242,2,20
	.word	4191
	.byte	32,15,243,2,9,4,14
	.byte	'p0',0
	.word	4191
	.byte	4,2,35,0,14
	.byte	'p1',0
	.word	4191
	.byte	4,2,35,0,14
	.byte	'p2',0
	.word	4191
	.byte	4,2,35,0,0,18
	.byte	'Os_psetType',0,15,247,2,3
	.word	6141
	.byte	32,15,249,2,9,4,14
	.byte	't0',0
	.word	4191
	.byte	4,2,35,0,14
	.byte	't1',0
	.word	4191
	.byte	4,2,35,0,14
	.byte	't2',0
	.word	4191
	.byte	4,2,35,0,0,18
	.byte	'Os_tpmaskType',0,15,253,2,3
	.word	6205
	.byte	18
	.byte	'Os_ActivationCountType',0,15,254,2,23
	.word	152
	.byte	31
	.byte	'Os_TaskDynType_s',0,15,128,3,16,120,14
	.byte	'terminate_jump_buf',0
	.word	4753
	.byte	68,2,35,0,14
	.byte	'meter',0
	.word	5521
	.byte	48,2,35,68,14
	.byte	'activation_count',0
	.word	152
	.byte	1,2,35,116,0,18
	.byte	'Os_TaskDynType',0,15,132,3,3
	.word	6303
	.byte	28,68
	.word	4722
	.byte	29,0,0,9
	.word	6303
	.byte	10
	.word	6429
	.byte	31
	.byte	'Os_TaskType_s',0,15,134,3,16,40,14
	.byte	'dynamic',0
	.word	6434
	.byte	4,2,35,0,14
	.byte	'entry_function',0
	.word	4897
	.byte	4,2,35,4,14
	.byte	'pset',0
	.word	6141
	.byte	4,2,35,8,14
	.byte	'base_tpmask',0
	.word	6205
	.byte	4,2,35,12,14
	.byte	'tpmask',0
	.word	6205
	.byte	4,2,35,16,14
	.byte	'core_id',0
	.word	169
	.byte	2,2,35,20,14
	.byte	'index',0
	.word	4191
	.byte	4,2,35,24,14
	.byte	'stackbudget',0
	.word	4804
	.byte	8,2,35,28,14
	.byte	'activation_count',0
	.word	152
	.byte	1,2,35,36,14
	.byte	'access',0
	.word	152
	.byte	1,2,35,37,14
	.byte	'application',0
	.word	152
	.byte	1,2,35,38,0,18
	.byte	'Os_TaskType',0,15,146,3,3
	.word	6439
	.byte	10
	.word	6439
	.byte	9
	.word	6689
	.byte	18
	.byte	'TaskType',0,15,147,3,47
	.word	6694
	.byte	33
	.byte	'Os_TaskStateType',0,15,155,3,6,4,4
	.byte	'SUSPENDED',0,0,4
	.byte	'READY',0,1,4
	.byte	'WAITING',0,2,4
	.byte	'RUNNING',0,3,0,18
	.byte	'TaskStateType',0,15,156,3,31
	.word	6717
	.byte	32,15,167,3,3,4,14
	.byte	'tpmask',0
	.word	6205
	.byte	4,2,35,0,0,31
	.byte	'Os_ResourceDynType_s',0,15,166,3,16,4,14
	.byte	'saved_priority',0
	.word	6804
	.byte	4,2,35,0,0,18
	.byte	'Os_ResourceDynType',0,15,170,3,3
	.word	6827
	.byte	9
	.word	6827
	.byte	10
	.word	6907
	.byte	31
	.byte	'Os_ResourceType_s',0,15,171,3,16,12,14
	.byte	'dynamic',0
	.word	6912
	.byte	4,2,35,0,14
	.byte	'tpmask',0
	.word	6205
	.byte	4,2,35,4,14
	.byte	'access',0
	.word	152
	.byte	1,2,35,8,0,18
	.byte	'Os_ResourceType',0,15,175,3,3
	.word	6917
	.byte	13,15,181,3,9,12,14
	.byte	'maxallowedvalue',0
	.word	4191
	.byte	4,2,35,0,14
	.byte	'ticksperbase',0
	.word	4191
	.byte	4,2,35,4,14
	.byte	'mincycle',0
	.word	4191
	.byte	4,2,35,8,0,18
	.byte	'AlarmBaseType',0,15,185,3,3
	.word	7016
	.byte	13,15,206,3,9,8,14
	.byte	'Running',0
	.word	152
	.byte	1,2,35,0,14
	.byte	'Pending',0
	.word	152
	.byte	1,2,35,1,14
	.byte	'Delay',0
	.word	4191
	.byte	4,2,35,4,0,18
	.byte	'Os_CounterStatusType',0,15,210,3,3
	.word	7111
	.byte	34
	.word	152
	.byte	1,1,9
	.word	7197
	.byte	18
	.byte	'Os_CounterIncrAdvType',0,15,217,3,22
	.word	7204
	.byte	31
	.byte	's_swd',0,15,222,3,12,4,14
	.byte	'count',0
	.word	4191
	.byte	4,2,35,0,0,32,15,221,3,3,4,14
	.byte	'sw',0
	.word	7240
	.byte	4,2,35,0,0,31
	.byte	'Os_CounterDynType_s',0,15,220,3,16,4,14
	.byte	'type_dependent',0
	.word	7268
	.byte	4,2,35,0,0,18
	.byte	'Os_CounterDynType',0,15,226,3,3
	.word	7287
	.byte	9
	.word	7287
	.byte	10
	.word	7365
	.byte	31
	.byte	'Os_CounterType_s',0,15,227,3,16,28,14
	.byte	'dynamic',0
	.word	7370
	.byte	4,2,35,0,14
	.byte	'advincr',0
	.word	7209
	.byte	4,2,35,4,14
	.byte	'base',0
	.word	7016
	.byte	12,2,35,8,14
	.byte	'core',0
	.word	992
	.byte	4,2,35,20,14
	.byte	'access',0
	.word	152
	.byte	1,2,35,24,14
	.byte	'application',0
	.word	152
	.byte	1,2,35,25,0,18
	.byte	'Os_CounterType',0,15,234,3,3
	.word	7375
	.byte	9
	.word	7197
	.byte	10
	.word	7375
	.byte	9
	.word	7527
	.byte	18
	.byte	'CounterType',0,15,235,3,52
	.word	7532
	.byte	33
	.byte	'Os_ScheduleTableStatusType',0,15,240,3,6,4,4
	.byte	'SCHEDULETABLE_STOPPED',0,0,4
	.byte	'SCHEDULETABLE_NEXT',0,1,4
	.byte	'SCHEDULETABLE_WAITING',0,2,4
	.byte	'SCHEDULETABLE_RUNNING',0,3,4
	.byte	'SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS',0,4,0,18
	.byte	'ScheduleTableStatusType',0,15,241,3,41
	.word	7558
	.byte	10
	.word	.L445-.L119
	.byte	9
	.word	7758
	.byte	18
	.byte	'ScheduleTableType',0,15,128,4,58
	.word	7763
	.byte	31
	.byte	'Os_ScheduleTableDynType_s',0,15,130,4,16,16,14
	.byte	'match',0
	.word	4191
	.byte	4,2,35,0,14
	.byte	'next',0
	.word	7768
	.byte	4,2,35,4,14
	.byte	'state',0
	.word	7558
	.byte	4,2,35,8,14
	.byte	'config',0
	.word	169
	.byte	2,2,35,12,0,9
	.word	7795
	.byte	10
	.word	7888
.L445:
	.byte	31
	.byte	'Os_ScheduleTableType_s',0,15,247,3,16,16,14
	.byte	'dynamic',0
	.word	7893
	.byte	4,2,35,0,14
	.byte	'counter',0
	.word	7537
	.byte	4,2,35,4,14
	.byte	'repeat',0
	.word	152
	.byte	1,2,35,8,14
	.byte	'config',0
	.word	169
	.byte	2,2,35,10,14
	.byte	'initial',0
	.word	152
	.byte	1,2,35,12,14
	.byte	'access',0
	.word	152
	.byte	1,2,35,13,14
	.byte	'application',0
	.word	152
	.byte	1,2,35,14,0,18
	.byte	'Os_ScheduleTableType',0,15,255,3,3
	.word	7898
	.byte	10
	.word	7898
	.byte	9
	.word	8078
	.byte	10
	.word	7375
	.byte	9
	.word	8088
	.byte	35
	.word	5202
	.byte	35
	.word	6141
	.byte	35
	.word	6038
	.byte	35
	.word	6699
	.byte	35
	.word	6205
	.byte	35
	.word	152
	.byte	35
	.word	6699
	.byte	31
	.byte	'Os_ControlledCoreType_s',0,15,251,6,16,112,14
	.byte	'TrapInfo',0
	.word	4633
	.byte	8,2,35,0,14
	.byte	'lock_taskaccess',0
	.word	8098
	.byte	4,2,35,8,14
	.byte	'ReadyTasks',0
	.word	8103
	.byte	4,2,35,12,14
	.byte	'RunningISR',0
	.word	8108
	.byte	4,2,35,16,14
	.byte	'RunningTask',0
	.word	8113
	.byte	4,2,35,20,14
	.byte	'RunningTPMask',0
	.word	8118
	.byte	4,2,35,24,14
	.byte	'CurrentMeteredObject',0
	.word	5724
	.byte	4,2,35,28,14
	.byte	'IdleMeter',0
	.word	5521
	.byte	48,2,35,32,14
	.byte	'AppAccess',0
	.word	152
	.byte	1,2,35,80,14
	.byte	'AppOverride',0
	.word	8123
	.byte	1,2,35,81,14
	.byte	'GetStackValueAdjust',0
	.word	4804
	.byte	8,2,35,84,14
	.byte	'InErrorHook',0
	.word	152
	.byte	1,2,35,92,14
	.byte	'ChainTaskRef',0
	.word	8128
	.byte	4,2,35,96,14
	.byte	'GetStackUsageAdjust',0
	.word	4804
	.byte	8,2,35,100,14
	.byte	'InProtectionHook',0
	.word	152
	.byte	1,2,35,108,14
	.byte	'CoreIsActive',0
	.word	152
	.byte	1,2,35,109,14
	.byte	'InShutdownHook',0
	.word	152
	.byte	1,2,35,110,0,18
	.byte	'Os_ControlledCoreType',0,15,141,7,3
	.word	8133
	.byte	9
	.word	4191
	.byte	10
	.word	5869
	.byte	9
	.word	8589
	.byte	10
	.word	6439
	.byte	9
	.word	8599
	.byte	9
	.word	5521
	.byte	31
	.byte	'Os_AnyCoreType_s',0,15,151,7,16,96,14
	.byte	'DisableAllImask',0
	.word	4191
	.byte	4,2,35,0,14
	.byte	'SuspendAllImask',0
	.word	4191
	.byte	4,2,35,4,14
	.byte	'SuspendOSImask',0
	.word	4191
	.byte	4,2,35,8,14
	.byte	'DisableAllCount',0
	.word	4191
	.byte	4,2,35,12,14
	.byte	'SuspendAllCount',0
	.word	4191
	.byte	4,2,35,16,14
	.byte	'SuspendOSCount',0
	.word	4191
	.byte	4,2,35,20,14
	.byte	'RestartJumpBuf',0
	.word	4753
	.byte	68,2,35,24,14
	.byte	'Restartable',0
	.word	152
	.byte	1,2,35,92,0,18
	.byte	'Os_AnyCoreType',0,15,160,7,3
	.word	8614
	.byte	18
	.byte	'Can_TxObjPriorityClassType',0,16,219,3,16
	.word	4191
	.byte	31
	.byte	'Can_TxHwObjectConfigType',0,16,231,3,16,8,14
	.byte	'MsgObjId',0
	.word	152
	.byte	1,2,35,0,14
	.byte	'HwControllerId',0
	.word	152
	.byte	1,2,35,1,14
	.byte	'TxObjPriorityClass',0
	.word	4191
	.byte	4,2,35,4,0,18
	.byte	'Can_TxHwObjectConfigType',0,16,252,3,3
	.word	8891
	.byte	31
	.byte	'Can_RxHwObjectConfigType',0,16,129,4,16,12,14
	.byte	'MaskRef',0
	.word	4191
	.byte	4,2,35,0,14
	.byte	'MsgId',0
	.word	4191
	.byte	4,2,35,4,14
	.byte	'MsgObjId',0
	.word	152
	.byte	1,2,35,8,14
	.byte	'HwControllerId',0
	.word	152
	.byte	1,2,35,9,0,18
	.byte	'Can_RxHwObjectConfigType',0,16,147,4,3
	.word	9027
	.byte	28,4
	.word	152
	.byte	29,3,0,31
	.byte	'Can_ControllerMOMapConfigType',0,16,181,4,16,4,14
	.byte	'ControllerMOMap',0
	.word	9167
	.byte	4,2,35,0,0,18
	.byte	'Can_ControllerMOMapConfigType',0,16,184,4,3
	.word	9176
	.byte	31
	.byte	'Can_NPCRValueType',0,16,188,4,16,2,14
	.byte	'Can_NPCRValue',0
	.word	169
	.byte	2,2,35,0,0,18
	.byte	'Can_NPCRValueType',0,16,191,4,3
	.word	9277
	.byte	31
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,16,194,4,16,8,14
	.byte	'CanControllerBaudrate',0
	.word	4191
	.byte	4,2,35,0,14
	.byte	'CanControllerBaudrateCfg',0
	.word	169
	.byte	2,2,35,4,0,18
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,16,198,4,3
	.word	9352
	.byte	10
	.word	9352
	.byte	9
	.word	9517
	.byte	31
	.byte	'Can_BaudrateConfigPtrType',0,16,201,4,16,4,14
	.byte	'Can_kBaudrateConfigPtr',0
	.word	9522
	.byte	4,2,35,0,0,18
	.byte	'Can_BaudrateConfigPtrType',0,16,204,4,3
	.word	9527
	.byte	31
	.byte	'Can_EventHandlingType',0,16,226,4,16,4,14
	.byte	'CanEventType',0
	.word	9167
	.byte	4,2,35,0,0,18
	.byte	'Can_EventHandlingType',0,16,229,4,3
	.word	9627
	.byte	18
	.byte	'Rte_TransformerErrorCode',0,17,130,1,15
	.word	152
	.byte	18
	.byte	'Rte_TransformerClass',0,17,131,1,15
	.word	152
	.byte	13,17,168,1,9,12,14
	.byte	'in',0
	.word	992
	.byte	4,2,35,0,14
	.byte	'out',0
	.word	992
	.byte	4,2,35,4,14
	.byte	'used',0
	.word	169
	.byte	2,2,35,8,14
	.byte	'lost_data',0
	.word	152
	.byte	1,2,35,10,0,18
	.byte	'Rte_QDynType',0,17,173,1,3
	.word	9773
	.byte	3,17,175,1,9,4,4
	.byte	'RTE_DRA',0,0,4
	.byte	'RTE_WOWP',0,1,4
	.byte	'RTE_TASK',0,2,4
	.byte	'RTE_ARE',0,3,4
	.byte	'RTE_EV',0,4,4
	.byte	'RTE_MSI',0,5,0,18
	.byte	'Rte_NotificationType',0,17,182,1,3
	.word	9860
	.byte	9
	.word	9773
	.byte	31
	.byte	'Rte_QCmnType',0,17,184,1,16,24,14
	.byte	'dynamic',0
	.word	9958
	.byte	4,2,35,0,14
	.byte	'copy',0
	.word	152
	.byte	1,2,35,4,14
	.byte	'queue_size',0
	.word	169
	.byte	2,2,35,6,14
	.byte	'element_size',0
	.word	169
	.byte	2,2,35,8,14
	.byte	'buffer_start',0
	.word	992
	.byte	4,2,35,12,14
	.byte	'buffer_end',0
	.word	992
	.byte	4,2,35,16,14
	.byte	'notification_type',0
	.word	9860
	.byte	4,2,35,20,0,18
	.byte	'Rte_QCmnType',0,17,192,1,3
	.word	9963
	.byte	18
	.byte	'Rte_AlarmRefType',0,17,224,1,32
	.word	4191
	.byte	18
	.byte	'Rte_AlarmIndexType',0,17,226,1,32
	.word	169
	.byte	28,128,8
	.word	152
	.byte	29,255,7,0,18
	.byte	'Impl_NVM_DstPtrType_1024',0,18,50,15
	.word	10201
	.byte	18
	.byte	'CanIf_u32_impl',0,18,69,16
	.word	4191
	.byte	18
	.byte	'CanIf_u16_impl',0,18,71,16
	.word	169
	.byte	18
	.byte	'CanIf_u8_impl',0,18,73,15
	.word	152
	.byte	18
	.byte	'CanIf_ControllerModeType_Enum_impl',0,18,88,15
	.word	152
	.byte	18
	.byte	'CanIf_PduModeType_Enum_impl',0,18,90,15
	.word	152
	.byte	13,18,92,9,2,14
	.byte	'DeviceMode',0
	.word	152
	.byte	1,2,35,0,14
	.byte	'ChannelMode',0
	.word	152
	.byte	1,2,35,1,0,18
	.byte	'CanIf_ControllerStateType_struct_impl',0,18,95,3
	.word	10392
	.byte	18
	.byte	'CanIf_NotifStatusType_Enum_impl',0,18,100,15
	.word	152
	.byte	18
	.byte	'CanSM_boolean_Impl',0,18,120,15
	.word	152
	.byte	18
	.byte	'CanSM_u8_Impl',0,18,123,15
	.word	152
	.byte	18
	.byte	'CanSM_BusOffRecoveryStateType_Enum_impl',0,18,128,1,15
	.word	152
	.byte	18
	.byte	'CanSM_NetworkModeStateType_Enum_impl',0,18,132,1,15
	.word	152
	.byte	18
	.byte	'CanSM_u16_Impl',0,18,136,1,16
	.word	169
	.byte	18
	.byte	'CanSM_TimerStateType_Enum_impl',0,18,138,1,15
	.word	152
	.byte	13,18,140,1,9,4,14
	.byte	'cntTick_u16',0
	.word	169
	.byte	2,2,35,0,14
	.byte	'stTimer',0
	.word	152
	.byte	1,2,35,2,0,18
	.byte	'CanSM_TimerConfig_tst_struct_impl',0,18,143,1,3
	.word	10733
	.byte	18
	.byte	'Com_impl_u16',0,18,154,1,16
	.word	169
	.byte	18
	.byte	'Com_impl_u8',0,18,157,1,15
	.word	152
	.byte	18
	.byte	'ComM_uint32_Impl',0,18,173,1,16
	.word	4191
	.byte	18
	.byte	'ComM_uint16_Impl',0,18,175,1,16
	.word	169
	.byte	18
	.byte	'ComM_uint8_Impl',0,18,177,1,15
	.word	152
	.byte	18
	.byte	'ComM_bool_Impl',0,18,179,1,15
	.word	152
	.byte	13,18,181,1,9,24,14
	.byte	'ChannelState_e',0
	.word	4191
	.byte	4,2,35,0,14
	.byte	'LightTimeoutCtr_u32',0
	.word	4191
	.byte	4,2,35,4,14
	.byte	'MinFullComTimeoutCtr_u16',0
	.word	169
	.byte	2,2,35,8,14
	.byte	'ChannelMode_u8',0
	.word	152
	.byte	1,2,35,10,14
	.byte	'BusSmMode_u8',0
	.word	152
	.byte	1,2,35,11,14
	.byte	'UserRequestCtr_u8',0
	.word	152
	.byte	1,2,35,12,14
	.byte	'PassiveRequestState_u8',0
	.word	152
	.byte	1,2,35,13,14
	.byte	'PncRequestCtr_u8',0
	.word	152
	.byte	1,2,35,14,14
	.byte	'InhibitionReqStatus_u8',0
	.word	152
	.byte	1,2,35,15,14
	.byte	'NmNetworkRequestStatus_b',0
	.word	152
	.byte	1,2,35,16,14
	.byte	'DiagnosticRequestState_b',0
	.word	152
	.byte	1,2,35,17,14
	.byte	'CommunicationAllowed_b',0
	.word	152
	.byte	1,2,35,18,14
	.byte	'NmBusSleepIndicationStatus_b',0
	.word	152
	.byte	1,2,35,19,14
	.byte	'NmPrepareBusSleepIndicationStatus_b',0
	.word	152
	.byte	1,2,35,20,14
	.byte	'NmNetworkModeStatus_b',0
	.word	152
	.byte	1,2,35,21,0,18
	.byte	'ComM_ChannelStruct_Impl',0,18,197,1,3
	.word	10965
	.byte	13,18,206,1,9,10,14
	.byte	'WakeUpInhibitionCtr_u16',0
	.word	169
	.byte	2,2,35,0,14
	.byte	'LimitToNoComCtr_u16',0
	.word	169
	.byte	2,2,35,2,14
	.byte	'RequestedUserMode_t',0
	.word	152
	.byte	1,2,35,4,14
	.byte	'IndicatedUserMode_t',0
	.word	152
	.byte	1,2,35,5,14
	.byte	'numChannelsInFullCom_u8',0
	.word	152
	.byte	1,2,35,6,14
	.byte	'numChannelsInSilentCom_u8',0
	.word	152
	.byte	1,2,35,7,14
	.byte	'numChannelsInNoCom_u8',0
	.word	152
	.byte	1,2,35,8,0,18
	.byte	'ComM_UserStruct_Impl',0,18,214,1,3
	.word	11469
	.byte	18
	.byte	'Dcm_IOOperationResponseType',0,18,252,1,15
	.word	152
	.byte	18
	.byte	'Dcm_RequestDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspRequestRoutineResultsOutSignal_0PrimitivType',0
	.byte	18,138,2,15
	.word	152
	.byte	18
	.byte	'Dcm_StartDataIn_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineInSignalPrimitivType',0,18,146,2,15
	.word	152
	.byte	18
	.byte	'Dcm_StartDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineOutSignalPrimitivType',0,18,150,2,15
	.word	152
	.byte	18
	.byte	'Dcm_StopDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStopRoutineOutSignalPrimitivType',0,18,154,2,15
	.word	152
	.byte	18
	.byte	'NvM_BlockIdType',0,18,215,2,16
	.word	169
	.byte	18
	.byte	'NvM_RequestResultType',0,18,225,2,15
	.word	152
	.byte	18
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockNative_1024_Type',0,18,243,3,34
	.word	10212
	.byte	28,128,8
	.word	152
	.byte	29,255,7,0,18
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockRedundant_1024_Type',0,18,246,3,34
	.word	10212
	.byte	18
	.byte	'MemIf_JobResultType',0,5,39,2
	.word	2366
	.byte	18
	.byte	'NvM_BlockManagementType',0,2,45,3
	.word	799
	.byte	3,2,49,9,4,4
	.byte	'NVM_PRV_ACTIVITY_NOT_INIT',0,0,4
	.byte	'NVM_PRV_ACTIVITY_IDLE',0,1,4
	.byte	'NVM_PRV_ACTIVITY_ARBITRATE',0,2,4
	.byte	'NVM_PRV_ACTIVITY_JOB_START',0,3,4
	.byte	'NVM_PRV_ACTIVITY_POLL_RESULT',0,4,4
	.byte	'NVM_PRV_ACTIVITY_JOB_COMPLETE',0,5,4
	.byte	'NVM_PRV_ACTIVITY_RESULT_EVAL',0,6,0,18
	.byte	'NvM_Prv_Activities_ten',0,2,58,3
	.word	12403
	.byte	18
	.byte	'NvM_Prv_idJob_ten',0,2,115,3
	.word	1922
	.byte	18
	.byte	'NvM_Prv_ServiceBit_tuo',0,2,168,1,16
	.word	169
	.byte	18
	.byte	'NvM_Prv_idService_tuo',0,2,173,1,15
	.word	152
	.byte	18
	.byte	'NvM_Prv_idQueue_tuo',0,2,206,1,15
	.word	152
	.byte	13,2,210,1,9,12,14
	.byte	'idService_uo',0
	.word	152
	.byte	1,2,35,0,14
	.byte	'idBlock_uo',0
	.word	169
	.byte	2,2,35,2,14
	.byte	'ServiceBit_uo',0
	.word	169
	.byte	2,2,35,4,14
	.byte	'BlockData_pv',0
	.word	992
	.byte	4,2,35,8,0,18
	.byte	'NvM_Prv_QueueEntry_tst',0,2,225,1,3
	.word	12762
	.byte	18
	.byte	'NvM_Prv_JobData_tst',0,2,240,1,3
	.word	2496
	.byte	9
	.word	12762
	.byte	13,2,245,1,9,32,14
	.byte	'Activity_rAMwM_en',0
	.word	12403
	.byte	4,2,35,0,14
	.byte	'idQueueActive_uo',0
	.word	152
	.byte	1,2,35,4,14
	.byte	'QueueEntry_pst',0
	.word	12917
	.byte	4,2,35,8,14
	.byte	'JobData_st',0
	.word	2496
	.byte	20,2,35,12,0,18
	.byte	'NvM_Prv_MainStates_tst',0,2,132,2,3
	.word	12922
	.byte	18
	.byte	'rba_BswSrv_uint64',0,19,66,28
	.word	4222
	.byte	18
	.byte	'Rte_TaskRefType',0,20,184,1,32
	.word	6699
	.byte	18
	.byte	'Rte_EventRefType',0,20,185,1,32
	.word	152
	.byte	18
	.byte	'Rte_EventType',0,20,186,1,32
	.word	4191
	.byte	18
	.byte	'Rte_REActCounterType',0,20,252,1,15
	.word	152
	.byte	9
	.word	152
	.byte	18
	.byte	'Rte_REActCounterRefType',0,20,253,1,58
	.word	13188
	.byte	13,20,255,1,9,8,14
	.byte	'task',0
	.word	13084
	.byte	4,2,35,0,14
	.byte	'acnt',0
	.word	13193
	.byte	4,2,35,4,0,18
	.byte	'Rte_REContainerType',0,20,130,2,3
	.word	13226
	.byte	10
	.word	6439
	.byte	9
	.word	13290
	.byte	9
	.word	152
	.byte	10
	.word	13226
	.byte	9
	.word	13305
	.byte	18
	.byte	'Rte_REContainerRefType',0,20,132,2,60
	.word	13310
	.byte	18
	.byte	'Rte_MSICounterType',0,20,149,2,16
	.word	169
	.byte	9
	.word	169
	.byte	18
	.byte	'Rte_MSICounterRefType',0,20,150,2,56
	.word	13375
	.byte	18
	.byte	'Rte_MSIPendingFlagType',0,20,152,2,17
	.word	152
	.byte	9
	.word	152
	.byte	18
	.byte	'Rte_MSIPendingFlagRefType',0,20,153,2,60
	.word	13443
	.byte	13,20,163,2,9,24,14
	.byte	'counter',0
	.word	13380
	.byte	4,2,35,0,14
	.byte	'incCounter',0
	.word	152
	.byte	1,2,35,4,14
	.byte	'pending',0
	.word	13448
	.byte	4,2,35,8,14
	.byte	'osTask',0
	.word	13084
	.byte	4,2,35,12,14
	.byte	'acnt',0
	.word	13193
	.byte	4,2,35,16,14
	.byte	'osEvent',0
	.word	152
	.byte	1,2,35,20,14
	.byte	'MSIInit',0
	.word	169
	.byte	2,2,35,22,0,18
	.byte	'Rte_MSITableEntry',0,20,172,2,3
	.word	13483
	.byte	9
	.word	169
	.byte	9
	.word	152
	.byte	18
	.byte	'Rte_TaskArrayIndex',0,20,179,2,16
	.word	152
	.byte	18
	.byte	'Rte_NrWaitingTasks',0,20,180,2,16
	.word	152
	.byte	13,20,182,2,9,4,14
	.byte	'pending',0
	.word	152
	.byte	1,2,35,0,14
	.byte	'count',0
	.word	152
	.byte	1,2,35,1,14
	.byte	'firstWaitingTask',0
	.word	152
	.byte	1,2,35,2,0,18
	.byte	'Rte_WaitableDatum',0,20,186,2,3
	.word	13701
	.byte	9
	.word	13701
	.byte	13,20,226,2,9,12,14
	.byte	'event_id',0
	.word	4191
	.byte	4,2,35,0,14
	.byte	'wd',0
	.word	13793
	.byte	4,2,35,4,14
	.byte	'timeout',0
	.word	4191
	.byte	4,2,35,8,0,18
	.byte	'Rte_WOWP_NotificationType',0,20,230,2,3
	.word	13798
	.byte	10
	.word	13798
	.byte	9
	.word	13887
	.byte	18
	.byte	'Rte_WOWP_NotificationRefType',0,20,232,2,66
	.word	13892
	.byte	18
	.byte	'Rte_ARE_NotificationType',0,20,234,2,29
	.word	13226
	.byte	31
	.byte	'Rte_QTaskType',0,20,243,2,16,28,14
	.byte	'cmn',0
	.word	9963
	.byte	24,2,35,0,14
	.byte	'task',0
	.word	13084
	.byte	4,2,35,24,0,18
	.byte	'Rte_QTaskType',0,20,246,2,3
	.word	13969
	.byte	31
	.byte	'Rte_QREType',0,20,250,2,16,28,14
	.byte	'cmn',0
	.word	9963
	.byte	24,2,35,0,14
	.byte	're',0
	.word	13315
	.byte	4,2,35,24,0,18
	.byte	'Rte_QREType',0,20,253,2,3
	.word	14040
	.byte	10
	.word	13226
	.byte	9
	.word	14105
	.byte	31
	.byte	'Rte_QWWPType',0,20,129,3,16,28,14
	.byte	'cmn',0
	.word	9963
	.byte	24,2,35,0,14
	.byte	'wwp',0
	.word	13897
	.byte	4,2,35,24,0,18
	.byte	'Rte_QWWPType',0,20,132,3,3
	.word	14115
	.byte	10
	.word	13798
	.byte	9
	.word	14183
	.byte	31
	.byte	'Rte_QEvType',0,20,136,3,16,36,14
	.byte	'cmn',0
	.word	9963
	.byte	24,2,35,0,14
	.byte	'task',0
	.word	13084
	.byte	4,2,35,24,14
	.byte	'mask',0
	.word	152
	.byte	1,2,35,28,14
	.byte	'acnt',0
	.word	13193
	.byte	4,2,35,32,0,18
	.byte	'Rte_QEvType',0,20,141,3,3
	.word	14193
	.byte	31
	.byte	'Rte_QMSIType',0,20,145,3,16,48,14
	.byte	'cmn',0
	.word	9963
	.byte	24,2,35,0,14
	.byte	'task',0
	.word	13084
	.byte	4,2,35,24,14
	.byte	'mask',0
	.word	152
	.byte	1,2,35,28,14
	.byte	'acnt',0
	.word	13193
	.byte	4,2,35,32,14
	.byte	'msiCounter',0
	.word	13380
	.byte	4,2,35,36,14
	.byte	'msiPending',0
	.word	13448
	.byte	4,2,35,40,14
	.byte	'msiLimit',0
	.word	169
	.byte	2,2,35,44,0,18
	.byte	'Rte_QMSIType',0,20,153,3,3
	.word	14288
	.byte	36
	.byte	'NvM_Prv_Main_st',0,6,59,31
	.word	12922
	.byte	1,1,16
	.word	152
	.byte	1,1,17
	.word	992
	.byte	0,9
	.word	14469
	.byte	18
	.byte	'NvM_Prv_ExplicitSync_Copy_tpfct',0,1,29,26
	.word	14482
	.byte	18
	.byte	'NvM_Prv_BlockConfiguration_ten',0,1,85,3
	.word	191
	.byte	19,1,1,17
	.word	152
	.byte	17
	.word	152
	.byte	0,9
	.word	14566
	.byte	19,1,1,17
	.word	152
	.byte	0,9
	.word	14585
	.byte	16
	.word	152
	.byte	1,1,17
	.word	169
	.byte	17
	.word	152
	.byte	17
	.word	152
	.byte	0,9
	.word	14599
	.byte	13,1,91,9,12,14
	.byte	'MultiBlockCallback_pfct',0
	.word	14580
	.byte	4,2,35,0,14
	.byte	'RbMultiBlockStartCallback_pfct',0
	.word	14594
	.byte	4,2,35,4,14
	.byte	'ObserverCallback_pfct',0
	.word	14622
	.byte	4,2,35,8,0,18
	.byte	'NvM_Prv_Common_tst',0,1,113,3
	.word	14627
	.byte	10
	.word	169
	.byte	9
	.word	14764
	.byte	10
	.word	992
	.byte	9
	.word	14774
	.byte	16
	.word	152
	.byte	1,1,17
	.word	152
	.byte	17
	.word	152
	.byte	0,9
	.word	14784
	.byte	16
	.word	152
	.byte	1,1,17
	.word	152
	.byte	0,9
	.word	14807
	.byte	9
	.word	7197
	.byte	13,1,121,9,48,14
	.byte	'idBlockMemIf_u16',0
	.word	169
	.byte	2,2,35,0,14
	.byte	'nrBlockBytes_pu16',0
	.word	14769
	.byte	4,2,35,4,14
	.byte	'idxDevice_u8',0
	.word	152
	.byte	1,2,35,8,14
	.byte	'nrNvBlocks_u8',0
	.word	152
	.byte	1,2,35,9,14
	.byte	'nrRomBlocks_u8',0
	.word	152
	.byte	1,2,35,10,14
	.byte	'adrRamBlock_ppv',0
	.word	14779
	.byte	4,2,35,12,14
	.byte	'adrRomBlock_pcv',0
	.word	1064
	.byte	4,2,35,16,14
	.byte	'SingleBlockCallback_pfct',0
	.word	14802
	.byte	4,2,35,20,14
	.byte	'SingleBlockStartCallback_pfct',0
	.word	14820
	.byte	4,2,35,24,14
	.byte	'InitBlockCallback_pfct',0
	.word	14825
	.byte	4,2,35,28,14
	.byte	'ReadRamBlockFromNvm_pfct',0
	.word	14482
	.byte	4,2,35,32,14
	.byte	'WriteRamBlockToNvm_pfct',0
	.word	14482
	.byte	4,2,35,36,14
	.byte	'BlockManagementType_en',0
	.word	799
	.byte	4,2,35,40,14
	.byte	'JobPriority_u8',0
	.word	152
	.byte	1,2,35,44,14
	.byte	'stFlags_u16',0
	.word	169
	.byte	2,2,35,46,0,18
	.byte	'NvM_Prv_BlockDescriptor_tst',0,1,138,2,3
	.word	14830
	.byte	10
	.word	14627
	.byte	36
	.byte	'NvM_Prv_Common_cst',0,1,164,2,45
	.word	15294
	.byte	1,1,28,160,5
	.word	14830
	.byte	29,13,0,10
	.word	15329
	.byte	36
	.byte	'NvM_Prv_BlockDescriptors_acst',0,1,169,2,45
	.word	15339
	.byte	1,1,28,14
	.word	152
	.byte	29,13,0,36
	.byte	'NvM_Prv_stBlock_rAwAM_au8',0,3,59,14
	.word	15385
	.byte	1,1,28,28
	.word	169
	.byte	29,13,0,36
	.byte	'NvM_Prv_stRequests_rAMwAM_au16',0,3,68,15
	.word	15430
	.byte	1,1,28,14
	.word	152
	.byte	29,13,0,36
	.byte	'NvM_Prv_stRequestResult_rAwAM_au8',0,3,77,30
	.word	15480
	.byte	1,1,36
	.byte	'NvM_Prv_idConfigStored_rMwM_u16',0,3,87,15
	.word	169
	.byte	1,1,28,52
	.word	3202
	.byte	29,12,0
.L402:
	.byte	10
	.word	15575
	.byte	28,52
	.word	3251
	.byte	29,12,0
.L403:
	.byte	10
	.word	15589
	.byte	28,52
	.word	3316
	.byte	29,12,0
.L404:
	.byte	10
	.word	15603
	.byte	0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L120:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,36,0,3,8,11,15,62,15,0,0,3,4,1,58,15,59,15,57,15,11,15
	.byte	0,0,4,40,0,3,8,28,13,0,0,5,46,1,3,8,32,13,58,15,59,15,57,15,73,19,54,15,39,12,0,0,6,5,0,3,8,58,15,59,15
	.byte	57,15,73,19,0,0,7,11,0,0,0,8,59,0,3,8,0,0,9,15,0,73,19,0,0,10,38,0,73,19,0,0,11,46,1,3,8,32,13,58,15,59
	.byte	15,57,15,54,15,39,12,0,0,12,11,1,0,0,13,19,1,58,15,59,15,57,15,11,15,0,0,14,13,0,3,8,73,19,11,15,56,9
	.byte	0,0,15,46,0,3,8,58,15,59,15,57,15,73,19,54,15,39,12,63,12,60,12,0,0,16,21,1,73,19,54,15,39,12,0,0,17,5
	.byte	0,73,19,0,0,18,22,0,3,8,58,15,59,15,57,15,73,19,0,0,19,21,1,54,15,39,12,0,0,20,46,1,3,8,58,15,59,15,57
	.byte	15,54,15,39,12,63,12,60,12,0,0,21,46,1,49,19,0,0,22,5,0,49,19,0,0,23,29,1,49,19,0,0,24,11,0,49,19,0,0
	.byte	25,46,1,3,8,58,15,59,15,57,15,73,19,54,15,39,12,63,12,60,12,0,0,26,46,0,3,8,58,15,59,15,57,15,54,15,63
	.byte	12,60,12,0,0,27,21,0,54,15,0,0,28,1,1,11,15,73,19,0,0,29,33,0,47,15,0,0,30,21,0,54,15,39,12,0,0,31,19
	.byte	1,3,8,58,15,59,15,57,15,11,15,0,0,32,23,1,58,15,59,15,57,15,11,15,0,0,33,4,1,3,8,58,15,59,15,57,15,11
	.byte	15,0,0,34,21,0,73,19,54,15,39,12,0,0,35,53,0,73,19,0,0,36,52,0,3,8,58,15,59,15,57,15,73,19,63,12,60,12
	.byte	0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L121:
	.word	.L447-.L446
.L446:
	.half	3
	.word	.L449-.L448
.L448:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockDescriptor.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\NvM\\api\\NvM_Types.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockData.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\MemIf\\api\\MemIf_Types.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_Queue.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_ErrorDetection.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_ProcessMultiBlock.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Platform\\Platform_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Std_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Can_GeneralTypes.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\RTOS_T\\Gen\\inc\\Os.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Can_17_MCanP\\inc\\Can_17_MCanP.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Type.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\rba_BswSrv.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Intl.h',0,0,0,0,0
.L449:
.L447:
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_MainFunctionResultEval')
	.sect	'.debug_info'
.L122:
	.word	1106
	.half	3
	.word	.L123
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L125,.L124
	.byte	2
	.word	.L118
	.byte	3
	.byte	'NvM_Prv_MainFunctionResultEval',0,1,182,3,6,1,1,1
	.word	.L117,.L208,.L116
	.byte	4
	.word	.L117,.L208
	.byte	5
	.byte	'isRequestResultEvaluated_b',0,1,186,3,13
	.word	.L209,.L210
	.byte	5
	.byte	'stRequestResult_uo',0,1,187,3,27
	.word	.L209,.L211
	.byte	5
	.byte	'stProductionErrors_u8',0,1,188,3,11
	.word	.L209,.L212
	.byte	5
	.byte	'idActiveService_uo',0,1,190,3,27
	.word	.L209,.L213
	.byte	5
	.byte	'idActiveQueue_en',0,1,191,3,25
	.word	.L209,.L214
	.byte	5
	.byte	'idBlock_uo',0,1,192,3,21
	.word	.L215,.L216
	.byte	6
	.word	.L217,.L218,.L219
	.byte	7
	.word	.L220,.L221
	.byte	7
	.word	.L222,.L223
	.byte	7
	.word	.L224,.L225
	.byte	8
	.word	.L226,.L227
	.byte	5
	.byte	'isReqResultEvaluated_b',0,1,252,3,13
	.word	.L209,.L234
	.byte	8
	.word	.L235,.L236
	.byte	5
	.byte	'JobEvalReqResult_pfct',0,1,134,4,40
	.word	.L238,.L239
	.byte	5
	.byte	'JobEvalProductionErrors_pfct',0,1,136,4,47
	.word	.L240,.L241
	.byte	5
	.byte	'JobUpdateBlockStatus_pfct',0,1,139,4,44
	.word	.L242,.L243
	.byte	0,0,0,6
	.word	.L217,.L228,.L229
	.byte	7
	.word	.L220,.L221
	.byte	7
	.word	.L222,.L223
	.byte	7
	.word	.L224,.L225
	.byte	0,6
	.word	.L217,.L230,.L231
	.byte	7
	.word	.L220,.L221
	.byte	7
	.word	.L222,.L223
	.byte	7
	.word	.L224,.L225
	.byte	0,6
	.word	.L244,.L245,.L246
	.byte	7
	.word	.L247,.L248
	.byte	7
	.word	.L249,.L250
	.byte	9
	.word	.L251,.L245,.L246
	.byte	0,6
	.word	.L252,.L253,.L232
	.byte	7
	.word	.L254,.L255
	.byte	7
	.word	.L256,.L257
	.byte	7
	.word	.L258,.L259
	.byte	7
	.word	.L260,.L261
	.byte	7
	.word	.L262,.L263
	.byte	10
	.word	.L264,.L253,.L232
	.byte	5
	.byte	'ServiceBitMask_uo',0,1,203,4,12
	.word	.L215,.L265
	.byte	6
	.word	.L266,.L80,.L267
	.byte	7
	.word	.L268,.L269
	.byte	7
	.word	.L270,.L271
	.byte	9
	.word	.L272,.L80,.L267
	.byte	0,0,0,6
	.word	.L217,.L232,.L233
	.byte	7
	.word	.L220,.L221
	.byte	7
	.word	.L222,.L223
	.byte	7
	.word	.L224,.L225
	.byte	0,6
	.word	.L273,.L274,.L81
	.byte	7
	.word	.L275,.L276
	.byte	7
	.word	.L277,.L278
	.byte	7
	.word	.L279,.L280
	.byte	10
	.word	.L281,.L274,.L81
	.byte	6
	.word	.L282,.L274,.L82
	.byte	7
	.word	.L283,.L284
	.byte	7
	.word	.L285,.L286
	.byte	7
	.word	.L287,.L288
	.byte	9
	.word	.L289,.L274,.L82
	.byte	0,6
	.word	.L290,.L291,.L81
	.byte	7
	.word	.L292,.L293
	.byte	7
	.word	.L294,.L295
	.byte	7
	.word	.L296,.L297
	.byte	9
	.word	.L298,.L291,.L81
	.byte	0,0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_MainFunctionResultEval')
	.sect	'.debug_abbrev'
.L123:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,11,1,17,1,18,1,0,0,5,52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,6,29,1
	.byte	49,16,17,1,18,1,0,0,7,5,0,49,16,2,6,0,0,8,11,1,49,16,85,6,0,0,9,11,0,49,16,17,1,18,1,0,0,10,11,1,49,16
	.byte	17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_MainFunctionResultEval')
	.sect	'.debug_line'
.L124:
	.word	.L451-.L450
.L450:
	.half	3
	.word	.L453-.L452
.L452:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockData.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockDescriptor.h',0,0,0,0,0
.L453:
	.byte	5,6,7,0,5,2
	.word	.L117
	.byte	3,181,3,1,5,48,9
	.half	.L424-.L117
	.byte	3,5,1,5,46,9
	.half	.L454-.L424
	.byte	1,5,35,9
	.half	.L455-.L454
	.byte	3,1,1,5,33,9
	.half	.L456-.L455
	.byte	1,5,72,9
	.half	.L457-.L456
	.byte	3,2,1,5,46,9
	.half	.L425-.L457
	.byte	1,5,44,9
	.half	.L427-.L425
	.byte	3,1,1,5,59,9
	.half	.L458-.L427
	.byte	1,5,49,9
	.half	.L428-.L458
	.byte	3,1,1,5,64,9
	.half	.L459-.L428
	.byte	1,5,76,9
	.half	.L429-.L459
	.byte	3,11,1,5,36,9
	.half	.L218-.L429
	.byte	3,49,1,5,58,9
	.half	.L430-.L218
	.byte	3,5,1,5,70,9
	.half	.L460-.L430
	.byte	3,1,1,9
	.half	.L461-.L460
	.byte	3,1,1,5,5,9
	.half	.L426-.L461
	.byte	3,126,1,5,107,7,9
	.half	.L237-.L426
	.byte	3,5,1,5,62,9
	.half	.L431-.L237
	.byte	1,5,67,9
	.half	.L433-.L431
	.byte	3,3,1,5,76,9
	.half	.L432-.L433
	.byte	3,127,1,5,64,9
	.half	.L435-.L432
	.byte	3,4,1,5,70,9
	.half	.L434-.L435
	.byte	3,127,1,5,13,9
	.half	.L437-.L434
	.byte	3,3,1,5,9,9
	.half	.L436-.L437
	.byte	1,5,54,7,9
	.half	.L462-.L436
	.byte	3,2,1,5,61,9
	.half	.L219-.L462
	.byte	3,188,127,1,5,30,9
	.half	.L228-.L219
	.byte	3,196,0,1,5,36,9
	.half	.L463-.L228
	.byte	3,1,1,5,38,9
	.half	.L464-.L463
	.byte	3,3,1,5,17,9
	.half	.L465-.L464
	.byte	1,5,59,7,9
	.half	.L466-.L465
	.byte	3,1,1,5,18,9
	.half	.L467-.L466
	.byte	1,5,93,7,9
	.half	.L468-.L467
	.byte	1,5,41,7,9
	.half	.L67-.L468
	.byte	3,6,1,5,13,9
	.half	.L65-.L67
	.byte	3,3,1,5,9,9
	.half	.L469-.L65
	.byte	1,5,68,7,9
	.half	.L470-.L469
	.byte	3,2,1,5,61,9
	.half	.L229-.L470
	.byte	3,173,127,1,5,37,9
	.half	.L230-.L229
	.byte	3,211,0,1,5,13,9
	.half	.L69-.L230
	.byte	3,2,1,5,9,9
	.half	.L471-.L69
	.byte	1,5,39,9
	.half	.L472-.L471
	.byte	3,2,1,5,5,9
	.half	.L64-.L472
	.byte	3,3,1,9
	.half	.L71-.L64
	.byte	3,172,127,1,5,52,7,9
	.half	.L231-.L71
	.byte	3,4,1,4,2,5,5,9
	.half	.L245-.L231
	.byte	3,233,125,1,5,38,9
	.half	.L473-.L245
	.byte	1,5,51,9
	.half	.L474-.L473
	.byte	1,4,1,5,66,9
	.half	.L246-.L474
	.byte	3,152,2,1,5,81,9
	.half	.L475-.L246
	.byte	1,5,95,9
	.half	.L476-.L475
	.byte	1,5,67,9
	.half	.L72-.L476
	.byte	3,7,1,5,82,9
	.half	.L477-.L72
	.byte	1,5,52,9
	.half	.L478-.L477
	.byte	3,1,1,5,5,9
	.half	.L253-.L478
	.byte	3,237,0,1,5,13,7,9
	.half	.L479-.L253
	.byte	3,2,1,5,9,9
	.half	.L480-.L479
	.byte	1,5,31,7,9
	.half	.L481-.L480
	.byte	3,2,1,5,80,9
	.half	.L439-.L481
	.byte	3,1,1,5,19,9
	.half	.L74-.L439
	.byte	3,2,1,5,18,9
	.half	.L482-.L74
	.byte	1,5,42,7,9
	.half	.L483-.L482
	.byte	3,1,1,5,19,7,9
	.half	.L484-.L483
	.byte	3,1,1,5,45,9
	.half	.L485-.L484
	.byte	1,5,31,7,9
	.half	.L486-.L485
	.byte	3,2,1,5,80,9
	.half	.L440-.L486
	.byte	3,1,1,5,34,9
	.half	.L76-.L440
	.byte	3,4,1,5,37,9
	.half	.L487-.L76
	.byte	1,5,9,9
	.half	.L75-.L487
	.byte	3,119,1,5,30,9
	.half	.L73-.L75
	.byte	3,14,1,5,33,9
	.half	.L488-.L73
	.byte	1,5,38,9
	.half	.L441-.L488
	.byte	3,2,1,5,42,9
	.half	.L444-.L441
	.byte	3,1,1,5,40,9
	.half	.L489-.L444
	.byte	1,5,44,9
	.half	.L490-.L489
	.byte	3,1,1,5,42,9
	.half	.L491-.L490
	.byte	1,4,2,5,5,9
	.half	.L80-.L491
	.byte	3,233,124,1,5,35,9
	.half	.L492-.L80
	.byte	1,5,52,9
	.half	.L493-.L492
	.byte	1,5,48,9
	.half	.L442-.L493
	.byte	1,4,1,5,43,9
	.half	.L267-.L442
	.byte	3,156,3,1,5,41,9
	.half	.L494-.L267
	.byte	1,5,45,9
	.half	.L495-.L494
	.byte	3,1,1,5,43,9
	.half	.L496-.L495
	.byte	1,5,48,9
	.half	.L497-.L496
	.byte	3,1,1,5,46,9
	.half	.L498-.L497
	.byte	1,5,47,9
	.half	.L499-.L498
	.byte	3,1,1,5,45,9
	.half	.L500-.L499
	.byte	1,5,44,9
	.half	.L501-.L500
	.byte	3,1,1,5,42,9
	.half	.L502-.L501
	.byte	1,5,41,9
	.half	.L503-.L502
	.byte	3,2,1,5,39,9
	.half	.L504-.L503
	.byte	1,5,5,9
	.half	.L232-.L504
	.byte	3,245,126,1,5,60,7,9
	.half	.L233-.L232
	.byte	3,3,1,4,3,5,21,9
	.half	.L274-.L233
	.byte	3,161,2,1,5,39,9
	.half	.L505-.L274
	.byte	1,5,9,9
	.half	.L506-.L505
	.byte	1,5,5,9
	.half	.L507-.L506
	.byte	1,5,84,7,9
	.half	.L508-.L507
	.byte	3,3,1,4,1,5,36,9
	.half	.L82-.L508
	.byte	3,175,126,1,5,10,9
	.half	.L509-.L82
	.byte	1,4,3,5,9,7,9
	.half	.L291-.L509
	.byte	3,181,1,1,5,51,7,9
	.half	.L510-.L291
	.byte	3,1,1,5,22,9
	.half	.L511-.L510
	.byte	1,5,51,9
	.half	.L512-.L511
	.byte	1,5,63,9
	.half	.L513-.L512
	.byte	1,5,10,9
	.half	.L514-.L513
	.byte	1,5,19,9
	.half	.L515-.L514
	.byte	1,5,98,7,9
	.half	.L516-.L515
	.byte	3,3,1,4,1,5,1,9
	.half	.L81-.L516
	.byte	3,248,125,1,7,9
	.half	.L126-.L81
	.byte	0,1,1
.L451:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_MainFunctionResultEval')
	.sect	'.debug_ranges'
.L125:
	.word	-1,.L117,0,.L126-.L117,0,0
.L227:
	.word	-1,.L117,.L218-.L117,.L219-.L117,.L228-.L117,.L229-.L117,.L230-.L117,.L231-.L117,.L232-.L117,.L233-.L117
	.word	0,0
.L236:
	.word	-1,.L117,.L237-.L117,.L219-.L117,.L228-.L117,.L229-.L117,.L230-.L117,.L64-.L117,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_EvalReqResult')
	.sect	'.debug_info'
.L127:
	.word	272
	.half	3
	.word	.L128
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L130,.L129
	.byte	2
	.word	.L118
	.byte	3
	.byte	'NvM_Prv_EvalReqResult',0,1,178,1,30
	.word	.L209
	.byte	1,1
	.word	.L87,.L299,.L86
	.byte	4
	.byte	'JobData_pcst',0,1,178,1,79
	.word	.L300,.L301
	.byte	5
	.word	.L87,.L299
	.byte	6
	.byte	'stRequestResult_uo',0,1,180,1,27
	.word	.L209,.L302
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_EvalReqResult')
	.sect	'.debug_abbrev'
.L128:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,52,0,3
	.byte	8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_EvalReqResult')
	.sect	'.debug_line'
.L129:
	.word	.L518-.L517
.L517:
	.half	3
	.word	.L520-.L519
.L519:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0,0,0,0,0
.L520:
	.byte	5,37,7,0,5,2
	.word	.L87
	.byte	3,181,1,1,5,5,9
	.half	.L521-.L87
	.byte	1,5,40,9
	.half	.L405-.L521
	.byte	3,2,1,5,28,9
	.half	.L2-.L405
	.byte	3,4,1,5,5,9
	.half	.L3-.L2
	.byte	3,2,1,5,1,9
	.half	.L4-.L3
	.byte	3,1,1,7,9
	.half	.L131-.L4
	.byte	0,1,1
.L518:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_EvalReqResult')
	.sect	'.debug_ranges'
.L130:
	.word	-1,.L87,0,.L131-.L87,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_EvalReqResult_Read')
	.sect	'.debug_info'
.L132:
	.word	277
	.half	3
	.word	.L133
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L135,.L134
	.byte	2
	.word	.L118
	.byte	3
	.byte	'NvM_Prv_EvalReqResult_Read',0,1,193,1,30
	.word	.L209
	.byte	1,1
	.word	.L89,.L303,.L88
	.byte	4
	.byte	'JobData_pcst',0,1,193,1,84
	.word	.L300,.L304
	.byte	5
	.word	.L89,.L303
	.byte	6
	.byte	'stRequestResult_uo',0,1,195,1,27
	.word	.L209,.L305
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_EvalReqResult_Read')
	.sect	'.debug_abbrev'
.L133:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,52,0,3
	.byte	8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_EvalReqResult_Read')
	.sect	'.debug_line'
.L134:
	.word	.L523-.L522
.L522:
	.half	3
	.word	.L525-.L524
.L524:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0,0,0,0,0
.L525:
	.byte	5,37,7,0,5,2
	.word	.L89
	.byte	3,195,1,1,5,5,9
	.half	.L526-.L89
	.byte	1,5,28,7,9
	.half	.L527-.L526
	.byte	3,2,1,5,40,9
	.half	.L406-.L527
	.byte	1,5,10,9
	.half	.L5-.L406
	.byte	3,2,1,5,28,7,9
	.half	.L528-.L5
	.byte	3,2,1,5,52,9
	.half	.L407-.L528
	.byte	1,5,10,9
	.half	.L7-.L407
	.byte	3,2,1,5,28,7,9
	.half	.L529-.L7
	.byte	3,2,1,5,54,9
	.half	.L408-.L529
	.byte	1,5,10,9
	.half	.L9-.L408
	.byte	3,2,1,5,28,9
	.half	.L530-.L9
	.byte	3,2,1,5,44,9
	.half	.L531-.L530
	.byte	1,5,28,9
	.half	.L11-.L531
	.byte	3,4,1,5,5,9
	.half	.L6-.L11
	.byte	3,2,1,5,1,9
	.half	.L13-.L6
	.byte	3,1,1,7,9
	.half	.L136-.L13
	.byte	0,1,1
.L523:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_EvalReqResult_Read')
	.sect	'.debug_ranges'
.L135:
	.word	-1,.L89,0,.L136-.L89,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_EvalReqResult_InvalidateForRemoveNonResistant')
	.sect	'.debug_info'
.L137:
	.word	304
	.half	3
	.word	.L138
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L140,.L139
	.byte	2
	.word	.L118
	.byte	3
	.byte	'NvM_Prv_EvalReqResult_InvalidateForRemoveNonResistant',0,1,219,1,30
	.word	.L209
	.byte	1,1
	.word	.L91,.L306,.L90
	.byte	4
	.byte	'JobData_pcst',0,1,219,1,111
	.word	.L300,.L307
	.byte	5
	.word	.L91,.L306
	.byte	6
	.byte	'stRequestResult_uo',0,1,221,1,27
	.word	.L209,.L308
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_EvalReqResult_InvalidateForRemoveNonResistant')
	.sect	'.debug_abbrev'
.L138:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,52,0,3
	.byte	8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_EvalReqResult_InvalidateForRemoveNonResistant')
	.sect	'.debug_line'
.L139:
	.word	.L533-.L532
.L532:
	.half	3
	.word	.L535-.L534
.L534:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0,0,0,0,0
.L535:
	.byte	5,37,7,0,5,2
	.word	.L91
	.byte	3,221,1,1,5,28,9
	.half	.L536-.L91
	.byte	3,2,1,5,52,9
	.half	.L537-.L536
	.byte	1,5,28,9
	.half	.L14-.L537
	.byte	3,4,1,5,5,9
	.half	.L15-.L14
	.byte	3,2,1,5,1,9
	.half	.L16-.L15
	.byte	3,1,1,7,9
	.half	.L141-.L16
	.byte	0,1,1
.L533:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_EvalReqResult_InvalidateForRemoveNonResistant')
	.sect	'.debug_ranges'
.L140:
	.word	-1,.L91,0,.L141-.L91,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_EvalReqResult_RestoreForImplicitRecovery')
	.sect	'.debug_info'
.L142:
	.word	299
	.half	3
	.word	.L143
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L145,.L144
	.byte	2
	.word	.L118
	.byte	3
	.byte	'NvM_Prv_EvalReqResult_RestoreForImplicitRecovery',0,1,233,1,30
	.word	.L209
	.byte	1,1
	.word	.L93,.L309,.L92
	.byte	4
	.byte	'JobData_pcst',0,1,233,1,106
	.word	.L300,.L310
	.byte	5
	.word	.L93,.L309
	.byte	6
	.byte	'stRequestResult_uo',0,1,235,1,27
	.word	.L209,.L311
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_EvalReqResult_RestoreForImplicitRecovery')
	.sect	'.debug_abbrev'
.L143:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,52,0,3
	.byte	8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_EvalReqResult_RestoreForImplicitRecovery')
	.sect	'.debug_line'
.L144:
	.word	.L539-.L538
.L538:
	.half	3
	.word	.L541-.L540
.L540:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0,0,0,0,0
.L541:
	.byte	5,37,7,0,5,2
	.word	.L93
	.byte	3,235,1,1,5,28,9
	.half	.L542-.L93
	.byte	3,2,1,5,55,9
	.half	.L543-.L542
	.byte	1,5,28,9
	.half	.L17-.L543
	.byte	3,4,1,5,5,9
	.half	.L18-.L17
	.byte	3,2,1,5,1,9
	.half	.L19-.L18
	.byte	3,1,1,7,9
	.half	.L146-.L19
	.byte	0,1,1
.L539:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_EvalReqResult_RestoreForImplicitRecovery')
	.sect	'.debug_ranges'
.L145:
	.word	-1,.L93,0,.L146-.L93,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_EvalReqResult_ReadIdConfigForReadAll')
	.sect	'.debug_info'
.L147:
	.word	466
	.half	3
	.word	.L148
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L150,.L149
	.byte	2
	.word	.L118
	.byte	3
	.byte	'NvM_Prv_EvalReqResult_ReadIdConfigForReadAll',0,1,247,1,30
	.word	.L209
	.byte	1,1
	.word	.L95,.L312,.L94
	.byte	4
	.byte	'JobData_pcst',0,1,247,1,102
	.word	.L300,.L313
	.byte	5
	.word	.L95,.L312
	.byte	6
	.byte	'stRequestResult_uo',0,1,249,1,27
	.word	.L209,.L314
	.byte	7
	.word	.L315,.L316,.L21
	.byte	8
	.word	.L317,.L316,.L21
	.byte	0,7
	.word	.L318,.L319,.L320
	.byte	9
	.word	.L321,.L322
	.byte	8
	.word	.L323,.L319,.L320
	.byte	0,7
	.word	.L318,.L324,.L325
	.byte	9
	.word	.L321,.L322
	.byte	8
	.word	.L323,.L324,.L325
	.byte	0,7
	.word	.L318,.L326,.L327
	.byte	9
	.word	.L321,.L322
	.byte	8
	.word	.L323,.L326,.L327
	.byte	0,7
	.word	.L318,.L328,.L24
	.byte	9
	.word	.L321,.L322
	.byte	8
	.word	.L323,.L328,.L24
	.byte	0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_EvalReqResult_ReadIdConfigForReadAll')
	.sect	'.debug_abbrev'
.L148:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,52,0,3
	.byte	8,58,15,59,15,57,15,73,16,2,6,0,0,7,29,1,49,16,17,1,18,1,0,0,8,11,0,49,16,17,1,18,1,0,0,9,5,0,49,16,2
	.byte	6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_EvalReqResult_ReadIdConfigForReadAll')
	.sect	'.debug_line'
.L149:
	.word	.L545-.L544
.L544:
	.half	3
	.word	.L547-.L546
.L546:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockData.h',0,0,0,0,0
.L547:
	.byte	5,37,7,0,5,2
	.word	.L95
	.byte	3,255,1,1,5,5,9
	.half	.L548-.L95
	.byte	1,4,2,5,39,7,9
	.half	.L316-.L548
	.byte	3,92,1,5,36,9
	.half	.L549-.L316
	.byte	1,5,5,9
	.half	.L550-.L549
	.byte	1,4,1,5,9,9
	.half	.L21-.L550
	.byte	3,38,1,5,48,9
	.half	.L412-.L21
	.byte	3,2,1,5,32,9
	.half	.L22-.L412
	.byte	3,10,1,5,9,9
	.half	.L23-.L22
	.byte	3,126,1,5,10,9
	.half	.L20-.L23
	.byte	3,5,1,5,28,7,9
	.half	.L551-.L20
	.byte	3,2,1,5,35,9
	.half	.L413-.L551
	.byte	3,2,1,4,2,5,5,9
	.half	.L319-.L413
	.byte	3,76,1,5,37,9
	.half	.L552-.L319
	.byte	1,4,1,5,52,9
	.half	.L320-.L552
	.byte	3,50,1,5,10,9
	.half	.L25-.L320
	.byte	3,11,1,5,28,7,9
	.half	.L553-.L25
	.byte	3,2,1,5,35,9
	.half	.L414-.L553
	.byte	3,2,1,4,2,5,5,9
	.half	.L324-.L414
	.byte	3,191,127,1,5,37,9
	.half	.L554-.L324
	.byte	1,4,1,5,52,9
	.half	.L325-.L554
	.byte	3,63,1,5,10,9
	.half	.L27-.L325
	.byte	3,11,1,5,28,7,9
	.half	.L555-.L27
	.byte	3,2,1,5,35,9
	.half	.L415-.L555
	.byte	3,2,1,4,2,5,5,9
	.half	.L326-.L415
	.byte	3,178,127,1,5,37,9
	.half	.L556-.L326
	.byte	1,4,1,5,54,9
	.half	.L327-.L556
	.byte	3,204,0,1,5,28,9
	.half	.L29-.L327
	.byte	3,13,1,5,35,9
	.half	.L416-.L29
	.byte	3,2,1,4,2,5,5,9
	.half	.L328-.L416
	.byte	3,165,127,1,5,37,9
	.half	.L557-.L328
	.byte	1,4,1,5,5,9
	.half	.L24-.L557
	.byte	3,227,0,1,5,1,9
	.half	.L31-.L24
	.byte	3,1,1,7,9
	.half	.L151-.L31
	.byte	0,1,1
.L545:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_EvalReqResult_ReadIdConfigForReadAll')
	.sect	'.debug_ranges'
.L150:
	.word	-1,.L95,0,.L151-.L95,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_EvalProductionErrors')
	.sect	'.debug_info'
.L152:
	.word	282
	.half	3
	.word	.L153
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L155,.L154
	.byte	2
	.word	.L118
	.byte	3
	.byte	'NvM_Prv_EvalProductionErrors',0,1,199,2,14
	.word	.L209
	.byte	1,1
	.word	.L97,.L329,.L96
	.byte	4
	.byte	'JobData_pcst',0,1,199,2,70
	.word	.L300,.L330
	.byte	5
	.word	.L97,.L329
	.byte	6
	.byte	'stProductionErrors_u8',0,1,201,2,11
	.word	.L209,.L331
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_EvalProductionErrors')
	.sect	'.debug_abbrev'
.L153:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,52,0,3
	.byte	8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_EvalProductionErrors')
	.sect	'.debug_line'
.L154:
	.word	.L559-.L558
.L558:
	.half	3
	.word	.L561-.L560
.L560:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0,0,0,0,0
.L561:
	.byte	5,33,7,0,5,2
	.word	.L97
	.byte	3,200,2,1,5,37,9
	.half	.L417-.L97
	.byte	3,1,1,5,5,9
	.half	.L562-.L417
	.byte	1,5,31,7,9
	.half	.L563-.L562
	.byte	3,2,1,5,5,9
	.half	.L32-.L563
	.byte	3,2,1,5,1,9
	.half	.L33-.L32
	.byte	3,1,1,7,9
	.half	.L156-.L33
	.byte	0,1,1
.L559:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_EvalProductionErrors')
	.sect	'.debug_ranges'
.L155:
	.word	-1,.L97,0,.L156-.L97,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_EvalProductionErrors_Read')
	.sect	'.debug_info'
.L157:
	.word	287
	.half	3
	.word	.L158
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L160,.L159
	.byte	2
	.word	.L118
	.byte	3
	.byte	'NvM_Prv_EvalProductionErrors_Read',0,1,209,2,14
	.word	.L209
	.byte	1,1
	.word	.L99,.L332,.L98
	.byte	4
	.byte	'JobData_pcst',0,1,209,2,75
	.word	.L300,.L333
	.byte	5
	.word	.L99,.L332
	.byte	6
	.byte	'stProductionErrors_u8',0,1,211,2,11
	.word	.L209,.L334
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_EvalProductionErrors_Read')
	.sect	'.debug_abbrev'
.L158:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,52,0,3
	.byte	8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_EvalProductionErrors_Read')
	.sect	'.debug_line'
.L159:
	.word	.L565-.L564
.L564:
	.half	3
	.word	.L567-.L566
.L566:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0,0,0,0,0
.L567:
	.byte	5,33,7,0,5,2
	.word	.L99
	.byte	3,210,2,1,5,49,9
	.half	.L418-.L99
	.byte	3,1,1,5,5,9
	.half	.L568-.L418
	.byte	1,5,31,7,9
	.half	.L569-.L568
	.byte	3,2,1,5,56,9
	.half	.L419-.L569
	.byte	1,5,10,9
	.half	.L34-.L419
	.byte	3,2,1,5,31,7,9
	.half	.L570-.L34
	.byte	3,2,1,5,50,9
	.half	.L420-.L570
	.byte	1,5,31,9
	.half	.L36-.L420
	.byte	3,5,1,5,5,9
	.half	.L35-.L36
	.byte	3,2,1,5,1,9
	.half	.L38-.L35
	.byte	3,1,1,7,9
	.half	.L161-.L38
	.byte	0,1,1
.L565:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_EvalProductionErrors_Read')
	.sect	'.debug_ranges'
.L160:
	.word	-1,.L99,0,.L161-.L99,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_EvalProductionErrors_ReadIdConfigForReadAll')
	.sect	'.debug_info'
.L162:
	.word	305
	.half	3
	.word	.L163
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L165,.L164
	.byte	2
	.word	.L118
	.byte	3
	.byte	'NvM_Prv_EvalProductionErrors_ReadIdConfigForReadAll',0,1,228,2,14
	.word	.L209
	.byte	1,1
	.word	.L101,.L335,.L100
	.byte	4
	.byte	'JobData_pcst',0,1,228,2,93
	.word	.L300,.L336
	.byte	5
	.word	.L101,.L335
	.byte	6
	.byte	'stProductionErrors_u8',0,1,230,2,11
	.word	.L209,.L337
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_EvalProductionErrors_ReadIdConfigForReadAll')
	.sect	'.debug_abbrev'
.L163:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,52,0,3
	.byte	8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_EvalProductionErrors_ReadIdConfigForReadAll')
	.sect	'.debug_line'
.L164:
	.word	.L572-.L571
.L571:
	.half	3
	.word	.L574-.L573
.L573:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0,0,0,0,0
.L574:
	.byte	5,33,7,0,5,2
	.word	.L101
	.byte	3,229,2,1,5,41,9
	.half	.L421-.L101
	.byte	3,1,1,5,5,9
	.half	.L575-.L421
	.byte	1,5,31,7,9
	.half	.L576-.L575
	.byte	3,2,1,5,5,9
	.half	.L39-.L576
	.byte	3,2,1,5,1,9
	.half	.L40-.L39
	.byte	3,1,1,7,9
	.half	.L166-.L40
	.byte	0,1,1
.L572:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_EvalProductionErrors_ReadIdConfigForReadAll')
	.sect	'.debug_ranges'
.L165:
	.word	-1,.L101,0,.L166-.L101,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_UpdateBlockStatus_Restore')
	.sect	'.debug_info'
.L167:
	.word	391
	.half	3
	.word	.L168
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L170,.L169
	.byte	2
	.word	.L118
	.byte	3
	.byte	'NvM_Prv_UpdateBlockStatus_Restore',0,1,238,2,13,1,1
	.word	.L103,.L338,.L102
	.byte	4
	.byte	'JobData_pcst',0,1,238,2,74
	.word	.L300,.L339
	.byte	5
	.word	.L103,.L338
	.byte	6
	.word	.L340,.L341,.L44
	.byte	7
	.word	.L342,.L343
	.byte	8
	.word	.L344,.L345
	.byte	9
	.byte	'PRamBlockAddress_pv',0,2,150,4,12
	.word	.L348,.L349
	.byte	0,0,6
	.word	.L340,.L346,.L347
	.byte	7
	.word	.L342,.L343
	.byte	0,6
	.word	.L350,.L351,.L41
	.byte	7
	.word	.L352,.L353
	.byte	7
	.word	.L354,.L355
	.byte	7
	.word	.L356,.L357
	.byte	10
	.word	.L358,.L351,.L41
	.byte	0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_UpdateBlockStatus_Restore')
	.sect	'.debug_abbrev'
.L168:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,29,1,49,16,17
	.byte	1,18,1,0,0,7,5,0,49,16,2,6,0,0,8,11,1,49,16,85,6,0,0,9,52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,10,11
	.byte	0,49,16,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_UpdateBlockStatus_Restore')
	.sect	'.debug_line'
.L169:
	.word	.L578-.L577
.L577:
	.half	3
	.word	.L580-.L579
.L579:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockDescriptor.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockData.h',0,0,0,0,0
.L580:
	.byte	5,37,7,0,5,2
	.word	.L103
	.byte	3,239,2,1,5,5,9
	.half	.L581-.L103
	.byte	1,5,83,7,9
	.half	.L582-.L581
	.byte	3,2,1,4,2,5,32,9
	.half	.L341-.L582
	.byte	3,164,1,1,5,9,9
	.half	.L422-.L341
	.byte	3,1,1,5,51,7,9
	.half	.L583-.L422
	.byte	3,1,1,5,22,9
	.half	.L584-.L583
	.byte	1,5,51,9
	.half	.L585-.L584
	.byte	1,5,63,9
	.half	.L586-.L585
	.byte	1,5,10,9
	.half	.L587-.L586
	.byte	1,5,19,9
	.half	.L588-.L587
	.byte	1,5,31,7,9
	.half	.L589-.L588
	.byte	3,2,1,5,5,9
	.half	.L42-.L589
	.byte	3,3,1,4,1,5,25,9
	.half	.L44-.L42
	.byte	3,213,126,1,5,9,9
	.half	.L346-.L44
	.byte	1,5,62,7,9
	.half	.L347-.L346
	.byte	3,2,1,5,88,9
	.half	.L590-.L347
	.byte	1,4,3,5,47,9
	.half	.L351-.L590
	.byte	3,226,126,1,5,72,9
	.half	.L591-.L351
	.byte	1,5,88,9
	.half	.L592-.L591
	.byte	1,5,85,9
	.half	.L593-.L592
	.byte	1,5,67,9
	.half	.L594-.L593
	.byte	3,1,1,5,111,9
	.half	.L595-.L594
	.byte	3,127,1,5,43,9
	.half	.L596-.L595
	.byte	1,4,1,5,1,9
	.half	.L41-.L596
	.byte	3,161,1,1,7,9
	.half	.L171-.L41
	.byte	0,1,1
.L578:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_UpdateBlockStatus_Restore')
	.sect	'.debug_ranges'
.L170:
	.word	-1,.L103,0,.L171-.L103,0,0
.L345:
	.word	-1,.L103,.L341-.L103,.L44-.L103,.L346-.L103,.L347-.L103,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_UpdateBlockStatus_ReadWrite')
	.sect	'.debug_info'
.L172:
	.word	492
	.half	3
	.word	.L173
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L175,.L174
	.byte	2
	.word	.L118
	.byte	3
	.byte	'NvM_Prv_UpdateBlockStatus_ReadWrite',0,1,249,2,13,1,1
	.word	.L105,.L359,.L104
	.byte	4
	.byte	'JobData_pcst',0,1,249,2,76
	.word	.L300,.L360
	.byte	5
	.word	.L105,.L359
	.byte	6
	.word	.L340,.L361,.L49
	.byte	7
	.word	.L342,.L362
	.byte	8
	.word	.L344,.L363
	.byte	9
	.byte	'PRamBlockAddress_pv',0,2,150,4,12
	.word	.L348,.L366
	.byte	0,0,6
	.word	.L340,.L364,.L365
	.byte	7
	.word	.L342,.L362
	.byte	0,6
	.word	.L350,.L367,.L50
	.byte	7
	.word	.L352,.L368
	.byte	7
	.word	.L354,.L369
	.byte	7
	.word	.L356,.L370
	.byte	10
	.word	.L358,.L367,.L50
	.byte	0,6
	.word	.L371,.L372,.L373
	.byte	7
	.word	.L374,.L375
	.byte	7
	.word	.L376,.L377
	.byte	10
	.word	.L378,.L372,.L373
	.byte	0,6
	.word	.L350,.L379,.L46
	.byte	7
	.word	.L352,.L368
	.byte	7
	.word	.L354,.L369
	.byte	7
	.word	.L356,.L370
	.byte	10
	.word	.L358,.L379,.L46
	.byte	0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_UpdateBlockStatus_ReadWrite')
	.sect	'.debug_abbrev'
.L173:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,29,1,49,16,17
	.byte	1,18,1,0,0,7,5,0,49,16,2,6,0,0,8,11,1,49,16,85,6,0,0,9,52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,10,11
	.byte	0,49,16,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_UpdateBlockStatus_ReadWrite')
	.sect	'.debug_line'
.L174:
	.word	.L598-.L597
.L597:
	.half	3
	.word	.L600-.L599
.L599:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockDescriptor.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockData.h',0,0,0,0,0
.L600:
	.byte	5,37,7,0,5,2
	.word	.L105
	.byte	3,250,2,1,5,5,9
	.half	.L601-.L105
	.byte	1,5,83,7,9
	.half	.L602-.L601
	.byte	3,2,1,4,2,5,32,9
	.half	.L361-.L602
	.byte	3,153,1,1,5,9,9
	.half	.L423-.L361
	.byte	3,1,1,5,51,7,9
	.half	.L603-.L423
	.byte	3,1,1,5,22,9
	.half	.L604-.L603
	.byte	1,5,51,9
	.half	.L605-.L604
	.byte	1,5,63,9
	.half	.L606-.L605
	.byte	1,5,10,9
	.half	.L607-.L606
	.byte	1,5,19,9
	.half	.L608-.L607
	.byte	1,5,31,7,9
	.half	.L609-.L608
	.byte	3,2,1,5,5,9
	.half	.L47-.L609
	.byte	3,3,1,4,1,5,25,9
	.half	.L49-.L47
	.byte	3,224,126,1,5,9,9
	.half	.L364-.L49
	.byte	1,5,62,7,9
	.half	.L365-.L364
	.byte	3,2,1,5,88,9
	.half	.L610-.L365
	.byte	1,4,3,5,47,9
	.half	.L367-.L610
	.byte	3,215,126,1,5,72,9
	.half	.L611-.L367
	.byte	1,5,88,9
	.half	.L612-.L611
	.byte	1,5,85,9
	.half	.L613-.L612
	.byte	1,5,67,9
	.half	.L614-.L613
	.byte	3,1,1,5,111,9
	.half	.L615-.L614
	.byte	3,127,1,5,43,9
	.half	.L616-.L615
	.byte	1,4,1,5,49,9
	.half	.L50-.L616
	.byte	3,171,1,1,5,63,9
	.half	.L617-.L50
	.byte	1,4,2,5,46,9
	.half	.L372-.L617
	.byte	3,113,1,5,13,9
	.half	.L618-.L372
	.byte	1,5,44,7,9
	.half	.L619-.L618
	.byte	3,1,1,5,15,9
	.half	.L620-.L619
	.byte	1,5,44,9
	.half	.L621-.L620
	.byte	1,5,56,9
	.half	.L622-.L621
	.byte	1,5,69,9
	.half	.L623-.L622
	.byte	1,5,46,9
	.half	.L624-.L623
	.byte	3,127,1,5,5,9
	.half	.L51-.L624
	.byte	1,4,1,5,9,9
	.half	.L53-.L51
	.byte	3,15,1,5,62,7,9
	.half	.L373-.L53
	.byte	3,2,1,5,90,9
	.half	.L625-.L373
	.byte	1,4,3,5,47,9
	.half	.L379-.L625
	.byte	3,211,126,1,5,72,9
	.half	.L626-.L379
	.byte	1,5,88,9
	.half	.L627-.L626
	.byte	1,5,85,9
	.half	.L628-.L627
	.byte	1,5,67,9
	.half	.L629-.L628
	.byte	3,1,1,5,111,9
	.half	.L630-.L629
	.byte	3,127,1,5,43,9
	.half	.L631-.L630
	.byte	1,4,1,5,1,9
	.half	.L46-.L631
	.byte	3,176,1,1,7,9
	.half	.L176-.L46
	.byte	0,1,1
.L598:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_UpdateBlockStatus_ReadWrite')
	.sect	'.debug_ranges'
.L175:
	.word	-1,.L105,0,.L176-.L105,0,0
.L363:
	.word	-1,.L105,.L361-.L105,.L49-.L105,.L364-.L105,.L365-.L105,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_UpdateBlockStatusJobValidate')
	.sect	'.debug_info'
.L177:
	.word	305
	.half	3
	.word	.L178
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L180,.L179
	.byte	2
	.word	.L118
	.byte	3
	.byte	'NvM_Prv_UpdateBlockStatusJobValidate',0,1,136,3,13,1,1
	.word	.L107,.L380,.L106
	.byte	4
	.byte	'JobData_pcst',0,1,136,3,77
	.word	.L300,.L381
	.byte	5
	.word	.L107,.L380
	.byte	6
	.word	.L350,.L382,.L55
	.byte	7
	.word	.L352,.L383
	.byte	7
	.word	.L354,.L384
	.byte	7
	.word	.L356,.L385
	.byte	8
	.word	.L358,.L382,.L55
	.byte	0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_UpdateBlockStatusJobValidate')
	.sect	'.debug_abbrev'
.L178:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,29,1,49,16,17
	.byte	1,18,1,0,0,7,5,0,49,16,2,6,0,0,8,11,0,49,16,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_UpdateBlockStatusJobValidate')
	.sect	'.debug_line'
.L179:
	.word	.L633-.L632
.L632:
	.half	3
	.word	.L635-.L634
.L634:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockData.h',0,0,0,0,0
.L635:
	.byte	5,37,7,0,5,2
	.word	.L107
	.byte	3,137,3,1,5,5,9
	.half	.L636-.L107
	.byte	1,5,44,7,9
	.half	.L637-.L636
	.byte	3,2,1,5,58,9
	.half	.L638-.L637
	.byte	1,5,87,9
	.half	.L639-.L638
	.byte	1,4,2,5,47,9
	.half	.L382-.L639
	.byte	3,202,126,1,5,72,9
	.half	.L640-.L382
	.byte	1,5,88,9
	.half	.L641-.L640
	.byte	1,5,85,9
	.half	.L642-.L641
	.byte	1,5,67,9
	.half	.L643-.L642
	.byte	3,1,1,5,111,9
	.half	.L644-.L643
	.byte	3,127,1,5,43,9
	.half	.L645-.L644
	.byte	1,4,1,5,1,9
	.half	.L55-.L645
	.byte	3,184,1,1,7,9
	.half	.L181-.L55
	.byte	0,1,1
.L633:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_UpdateBlockStatusJobValidate')
	.sect	'.debug_ranges'
.L180:
	.word	-1,.L107,0,.L181-.L107,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_UpdateBlockStatusIdConfigForReadAll')
	.sect	'.debug_info'
.L182:
	.word	382
	.half	3
	.word	.L183
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L185,.L184
	.byte	2
	.word	.L118
	.byte	3
	.byte	'NvM_Prv_UpdateBlockStatusIdConfigForReadAll',0,1,144,3,13,1,1
	.word	.L109,.L386,.L108
	.byte	4
	.byte	'JobData_pcst',0,1,144,3,84
	.word	.L300,.L387
	.byte	5
	.word	.L109,.L386
	.byte	6
	.word	.L388,.L109,.L56
	.byte	7
	.word	.L389,.L109,.L56
	.byte	8
	.byte	'InitIdConfigDuringWriteAll_b',0,2,230,1,13
	.word	.L209,.L390
	.byte	0,0,6
	.word	.L350,.L391,.L57
	.byte	9
	.word	.L352,.L392
	.byte	9
	.word	.L354,.L393
	.byte	9
	.word	.L356,.L394
	.byte	10
	.word	.L358,.L391,.L57
	.byte	0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_UpdateBlockStatusIdConfigForReadAll')
	.sect	'.debug_abbrev'
.L183:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,29,1,49,16,17
	.byte	1,18,1,0,0,7,11,1,49,16,17,1,18,1,0,0,8,52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,9,5,0,49,16,2,6,0,0,10
	.byte	11,0,49,16,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_UpdateBlockStatusIdConfigForReadAll')
	.sect	'.debug_line'
.L184:
	.word	.L647-.L646
.L646:
	.half	3
	.word	.L649-.L648
.L648:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockData.h',0,0,0,0,0
.L649:
	.byte	4,2,5,5,7,0,5,2
	.word	.L109
	.byte	3,237,1,1,4,1,9
	.half	.L56-.L109
	.byte	3,164,1,1,5,44,7,9
	.half	.L650-.L56
	.byte	3,5,1,5,58,9
	.half	.L651-.L650
	.byte	1,5,84,9
	.half	.L652-.L651
	.byte	1,4,2,5,47,9
	.half	.L391-.L652
	.byte	3,191,126,1,5,72,9
	.half	.L653-.L391
	.byte	1,5,88,9
	.half	.L654-.L653
	.byte	1,5,85,9
	.half	.L655-.L654
	.byte	1,5,67,9
	.half	.L656-.L655
	.byte	3,1,1,5,111,9
	.half	.L657-.L656
	.byte	3,127,1,5,43,9
	.half	.L658-.L657
	.byte	1,4,1,5,1,9
	.half	.L57-.L658
	.byte	3,195,1,1,7,9
	.half	.L186-.L57
	.byte	0,1,1
.L647:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_UpdateBlockStatusIdConfigForReadAll')
	.sect	'.debug_ranges'
.L185:
	.word	-1,.L109,0,.L186-.L109,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_GetFctJobEvalReqResult')
	.sect	'.debug_info'
.L187:
	.word	244
	.half	3
	.word	.L188
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L190,.L189
	.byte	2
	.word	.L118
	.byte	3
	.byte	'NvM_Prv_GetFctJobEvalReqResult',0,1,155,3,39
	.word	.L238
	.byte	1,1
	.word	.L111,.L395,.L110
	.byte	4
	.byte	'idJob_en',0,1,155,3,88
	.word	.L396,.L397
	.byte	5
	.word	.L111,.L395
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_GetFctJobEvalReqResult')
	.sect	'.debug_abbrev'
.L188:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_GetFctJobEvalReqResult')
	.sect	'.debug_line'
.L189:
	.word	.L660-.L659
.L659:
	.half	3
	.word	.L662-.L661
.L661:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0,0,0,0,0
.L662:
	.byte	5,21,7,0,5,2
	.word	.L111
	.byte	3,156,3,1,5,5,9
	.half	.L663-.L111
	.byte	1,5,18,9
	.half	.L664-.L663
	.byte	3,2,1,5,12,9
	.half	.L58-.L664
	.byte	3,2,1,5,47,9
	.half	.L665-.L58
	.byte	1,5,5,9
	.half	.L666-.L665
	.byte	1,5,1,9
	.half	.L59-.L666
	.byte	3,1,1,7,9
	.half	.L191-.L59
	.byte	0,1,1
.L660:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_GetFctJobEvalReqResult')
	.sect	'.debug_ranges'
.L190:
	.word	-1,.L111,0,.L191-.L111,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_GetFctJobEvalProductionErrors')
	.sect	'.debug_info'
.L192:
	.word	251
	.half	3
	.word	.L193
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L195,.L194
	.byte	2
	.word	.L118
	.byte	3
	.byte	'NvM_Prv_GetFctJobEvalProductionErrors',0,1,164,3,46
	.word	.L240
	.byte	1,1
	.word	.L113,.L398,.L112
	.byte	4
	.byte	'idJob_en',0,1,164,3,102
	.word	.L396,.L399
	.byte	5
	.word	.L113,.L398
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_GetFctJobEvalProductionErrors')
	.sect	'.debug_abbrev'
.L193:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_GetFctJobEvalProductionErrors')
	.sect	'.debug_line'
.L194:
	.word	.L668-.L667
.L667:
	.half	3
	.word	.L670-.L669
.L669:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0,0,0,0,0
.L670:
	.byte	5,21,7,0,5,2
	.word	.L113
	.byte	3,165,3,1,5,5,9
	.half	.L671-.L113
	.byte	1,5,18,9
	.half	.L672-.L671
	.byte	3,2,1,5,12,9
	.half	.L60-.L672
	.byte	3,2,1,5,54,9
	.half	.L673-.L60
	.byte	1,5,5,9
	.half	.L674-.L673
	.byte	1,5,1,9
	.half	.L61-.L674
	.byte	3,1,1,7,9
	.half	.L196-.L61
	.byte	0,1,1
.L668:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_GetFctJobEvalProductionErrors')
	.sect	'.debug_ranges'
.L195:
	.word	-1,.L113,0,.L196-.L113,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_GetFctJobUpdateBlockStatus')
	.sect	'.debug_info'
.L197:
	.word	248
	.half	3
	.word	.L198
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L200,.L199
	.byte	2
	.word	.L118
	.byte	3
	.byte	'NvM_Prv_GetFctJobUpdateBlockStatus',0,1,173,3,43
	.word	.L242
	.byte	1,1
	.word	.L115,.L400,.L114
	.byte	4
	.byte	'idJob_en',0,1,173,3,96
	.word	.L396,.L401
	.byte	5
	.word	.L115,.L400
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_GetFctJobUpdateBlockStatus')
	.sect	'.debug_abbrev'
.L198:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_GetFctJobUpdateBlockStatus')
	.sect	'.debug_line'
.L199:
	.word	.L676-.L675
.L675:
	.half	3
	.word	.L678-.L677
.L677:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0,0,0,0,0
.L678:
	.byte	5,21,7,0,5,2
	.word	.L115
	.byte	3,174,3,1,5,5,9
	.half	.L679-.L115
	.byte	1,5,18,9
	.half	.L680-.L679
	.byte	3,2,1,5,12,9
	.half	.L62-.L680
	.byte	3,2,1,5,51,9
	.half	.L681-.L62
	.byte	1,5,5,9
	.half	.L682-.L681
	.byte	1,5,1,9
	.half	.L63-.L682
	.byte	3,1,1,7,9
	.half	.L201-.L63
	.byte	0,1,1
.L676:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_GetFctJobUpdateBlockStatus')
	.sect	'.debug_ranges'
.L200:
	.word	-1,.L115,0,.L201-.L115,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_JobEvalReqResultFcts_capfct')
	.sect	'.debug_info'
.L202:
	.word	200
	.half	3
	.word	.L203
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1,2
	.word	.L118
	.byte	3
	.byte	'NvM_Prv_JobEvalReqResultFcts_capfct',0,4,100,45
	.word	.L402
	.byte	5,3
	.word	NvM_Prv_JobEvalReqResultFcts_capfct
	.byte	0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_JobEvalReqResultFcts_capfct')
	.sect	'.debug_abbrev'
.L203:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,0,0,2,61,0,24,16,0,0,3,52,0,3,8,58,15,59,15,57,15,73,16,2,9,0,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_JobEvalProductionErrorsFcts_capfct')
	.sect	'.debug_info'
.L204:
	.word	208
	.half	3
	.word	.L205
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1,2
	.word	.L118
	.byte	3
	.byte	'NvM_Prv_JobEvalProductionErrorsFcts_capfct',0,4,131,1,52
	.word	.L403
	.byte	5,3
	.word	NvM_Prv_JobEvalProductionErrorsFcts_capfct
	.byte	0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_JobEvalProductionErrorsFcts_capfct')
	.sect	'.debug_abbrev'
.L205:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,0,0,2,61,0,24,16,0,0,3,52,0,3,8,58,15,59,15,57,15,73,16,2,9,0,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_JobUpdateBlockStatusFcts_capfct')
	.sect	'.debug_info'
.L206:
	.word	205
	.half	3
	.word	.L207
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionResultEval.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1,2
	.word	.L118
	.byte	3
	.byte	'NvM_Prv_JobUpdateBlockStatusFcts_capfct',0,4,162,1,49
	.word	.L404
	.byte	5,3
	.word	NvM_Prv_JobUpdateBlockStatusFcts_capfct
	.byte	0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_JobUpdateBlockStatusFcts_capfct')
	.sect	'.debug_abbrev'
.L207:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,0,0,2,61,0,24,16,0,0,3,52,0,3,8,58,15,59,15,57,15,73,16,2,9,0,0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_EvalProductionErrors')
	.sect	'.debug_loc'
.L330:
	.word	-1,.L97,0,.L329-.L97
	.half	1
	.byte	100
	.word	0,0
.L96:
	.word	-1,.L97,0,.L329-.L97
	.half	2
	.byte	138,0
	.word	0,0
.L331:
	.word	-1,.L97,.L417-.L97,.L329-.L97
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_EvalProductionErrors_Read')
	.sect	'.debug_loc'
.L333:
	.word	-1,.L99,0,.L332-.L99
	.half	1
	.byte	100
	.word	0,0
.L98:
	.word	-1,.L99,0,.L332-.L99
	.half	2
	.byte	138,0
	.word	0,0
.L334:
	.word	-1,.L99,.L418-.L99,.L419-.L99
	.half	5
	.byte	144,32,157,32,0
	.word	.L419-.L99,.L34-.L99
	.half	1
	.byte	82
	.word	.L34-.L99,.L420-.L99
	.half	5
	.byte	144,32,157,32,0
	.word	.L420-.L99,.L36-.L99
	.half	1
	.byte	82
	.word	.L36-.L99,.L35-.L99
	.half	5
	.byte	144,32,157,32,0
	.word	.L35-.L99,.L332-.L99
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_EvalProductionErrors_ReadIdConfigForReadAll')
	.sect	'.debug_loc'
.L336:
	.word	-1,.L101,0,.L335-.L101
	.half	1
	.byte	100
	.word	0,0
.L100:
	.word	-1,.L101,0,.L335-.L101
	.half	2
	.byte	138,0
	.word	0,0
.L337:
	.word	-1,.L101,.L421-.L101,.L335-.L101
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_EvalReqResult')
	.sect	'.debug_loc'
.L301:
	.word	-1,.L87,0,.L2-.L87
	.half	1
	.byte	100
	.word	.L3-.L87,.L299-.L87
	.half	1
	.byte	100
	.word	0,0
.L86:
	.word	-1,.L87,0,.L299-.L87
	.half	2
	.byte	138,0
	.word	0,0
.L302:
	.word	-1,.L87,.L405-.L87,.L2-.L87
	.half	1
	.byte	82
	.word	.L3-.L87,.L299-.L87
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_EvalReqResult_InvalidateForRemoveNonResistant')
	.sect	'.debug_loc'
.L307:
	.word	-1,.L91,0,.L14-.L91
	.half	1
	.byte	100
	.word	.L15-.L91,.L306-.L91
	.half	1
	.byte	100
	.word	0,0
.L90:
	.word	-1,.L91,0,.L306-.L91
	.half	2
	.byte	138,0
	.word	0,0
.L308:
	.word	-1,.L91,.L410-.L91,.L14-.L91
	.half	1
	.byte	82
	.word	.L15-.L91,.L306-.L91
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_EvalReqResult_Read')
	.sect	'.debug_loc'
.L304:
	.word	-1,.L89,0,.L11-.L89
	.half	1
	.byte	100
	.word	.L6-.L89,.L303-.L89
	.half	1
	.byte	100
	.word	0,0
.L88:
	.word	-1,.L89,0,.L303-.L89
	.half	2
	.byte	138,0
	.word	0,0
.L305:
	.word	-1,.L89,.L406-.L89,.L5-.L89
	.half	1
	.byte	82
	.word	.L407-.L89,.L7-.L89
	.half	1
	.byte	82
	.word	.L408-.L89,.L9-.L89
	.half	1
	.byte	82
	.word	.L409-.L89,.L11-.L89
	.half	1
	.byte	82
	.word	.L6-.L89,.L303-.L89
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_EvalReqResult_ReadIdConfigForReadAll')
	.sect	'.debug_loc'
.L313:
	.word	-1,.L95,0,.L22-.L95
	.half	1
	.byte	100
	.word	.L23-.L95,.L312-.L95
	.half	1
	.byte	100
	.word	0,0
.L94:
	.word	-1,.L95,0,.L312-.L95
	.half	2
	.byte	138,0
	.word	0,0
.L322:
	.word	0,0
.L314:
	.word	-1,.L95,.L412-.L95,.L22-.L95
	.half	1
	.byte	82
	.word	.L23-.L95,.L20-.L95
	.half	1
	.byte	82
	.word	.L413-.L95,.L25-.L95
	.half	1
	.byte	82
	.word	.L414-.L95,.L27-.L95
	.half	1
	.byte	82
	.word	.L415-.L95,.L29-.L95
	.half	1
	.byte	82
	.word	.L416-.L95,.L312-.L95
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_EvalReqResult_RestoreForImplicitRecovery')
	.sect	'.debug_loc'
.L310:
	.word	-1,.L93,0,.L17-.L93
	.half	1
	.byte	100
	.word	.L18-.L93,.L309-.L93
	.half	1
	.byte	100
	.word	0,0
.L92:
	.word	-1,.L93,0,.L309-.L93
	.half	2
	.byte	138,0
	.word	0,0
.L311:
	.word	-1,.L93,.L411-.L93,.L17-.L93
	.half	1
	.byte	82
	.word	.L18-.L93,.L309-.L93
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_GetFctJobEvalProductionErrors')
	.sect	'.debug_loc'
.L112:
	.word	-1,.L113,0,.L398-.L113
	.half	2
	.byte	138,0
	.word	0,0
.L399:
	.word	-1,.L113,0,.L398-.L113
	.half	1
	.byte	84
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_GetFctJobEvalReqResult')
	.sect	'.debug_loc'
.L110:
	.word	-1,.L111,0,.L395-.L111
	.half	2
	.byte	138,0
	.word	0,0
.L397:
	.word	-1,.L111,0,.L395-.L111
	.half	1
	.byte	84
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_GetFctJobUpdateBlockStatus')
	.sect	'.debug_loc'
.L114:
	.word	-1,.L115,0,.L400-.L115
	.half	2
	.byte	138,0
	.word	0,0
.L401:
	.word	-1,.L115,0,.L400-.L115
	.half	1
	.byte	84
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_MainFunctionResultEval')
	.sect	'.debug_loc'
.L221:
	.word	0,0
.L241:
	.word	-1,.L117,.L432-.L117,.L434-.L117
	.half	1
	.byte	98
	.word	.L435-.L117,.L64-.L117
	.half	1
	.byte	110
	.word	0,0
.L239:
	.word	-1,.L117,.L431-.L117,.L432-.L117
	.half	1
	.byte	98
	.word	.L433-.L117,.L228-.L117
	.half	1
	.byte	111
	.word	0,0
.L243:
	.word	-1,.L117,.L434-.L117,.L436-.L117
	.half	1
	.byte	98
	.word	.L437-.L117,.L64-.L117
	.half	2
	.byte	145,116
	.word	.L438-.L117,.L64-.L117
	.half	1
	.byte	111
	.word	0,0
.L116:
	.word	-1,.L117,0,.L424-.L117
	.half	2
	.byte	138,0
	.word	.L424-.L117,.L208-.L117
	.half	2
	.byte	138,16
	.word	.L208-.L117,.L208-.L117
	.half	2
	.byte	138,0
	.word	0,0
.L250:
	.word	0,0
.L297:
	.word	0,0
.L288:
	.word	0,0
.L265:
	.word	-1,.L117,.L439-.L117,.L74-.L117
	.half	1
	.byte	95
	.word	.L440-.L117,.L76-.L117
	.half	1
	.byte	95
	.word	.L75-.L117,.L73-.L117
	.half	1
	.byte	95
	.word	.L441-.L117,.L442-.L117
	.half	1
	.byte	95
	.word	0,0
.L261:
	.word	0,0
.L278:
	.word	0,0
.L214:
	.word	-1,.L117,.L428-.L117,.L208-.L117
	.half	1
	.byte	90
	.word	.L443-.L117,.L444-.L117
	.half	1
	.byte	84
	.word	0,0
.L213:
	.word	-1,.L117,.L425-.L117,.L426-.L117
	.half	1
	.byte	82
	.word	.L427-.L117,.L208-.L117
	.half	1
	.byte	89
	.word	0,0
.L280:
	.word	0,0
.L248:
	.word	0,0
.L269:
	.word	0,0
.L216:
	.word	-1,.L117,.L429-.L117,.L208-.L117
	.half	1
	.byte	91
	.word	0,0
.L255:
	.word	0,0
.L293:
	.word	0,0
.L284:
	.word	0,0
.L257:
	.word	0,0
.L259:
	.word	0,0
.L295:
	.word	0,0
.L286:
	.word	0,0
.L234:
	.word	-1,.L117,.L430-.L117,.L208-.L117
	.half	1
	.byte	92
	.word	0,0
.L210:
	.word	0,0
.L271:
	.word	0,0
.L225:
	.word	0,0
.L212:
	.word	-1,.L117,0,.L208-.L117
	.half	2
	.byte	145,113
	.word	0,0
.L223:
	.word	0,0
.L211:
	.word	-1,.L117,0,.L208-.L117
	.half	2
	.byte	145,112
	.word	0,0
.L276:
	.word	0,0
.L263:
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_UpdateBlockStatusIdConfigForReadAll')
	.sect	'.debug_loc'
.L390:
	.word	0,0
.L387:
	.word	-1,.L109,0,.L386-.L109
	.half	1
	.byte	100
	.word	0,0
.L108:
	.word	-1,.L109,0,.L386-.L109
	.half	2
	.byte	138,0
	.word	0,0
.L392:
	.word	0,0
.L394:
	.word	0,0
.L393:
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_UpdateBlockStatusJobValidate')
	.sect	'.debug_loc'
.L381:
	.word	-1,.L107,0,.L380-.L107
	.half	1
	.byte	100
	.word	0,0
.L106:
	.word	-1,.L107,0,.L380-.L107
	.half	2
	.byte	138,0
	.word	0,0
.L383:
	.word	0,0
.L385:
	.word	0,0
.L384:
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_UpdateBlockStatus_ReadWrite')
	.sect	'.debug_loc'
.L360:
	.word	-1,.L105,0,.L359-.L105
	.half	1
	.byte	100
	.word	0,0
.L104:
	.word	-1,.L105,0,.L359-.L105
	.half	2
	.byte	138,0
	.word	0,0
.L366:
	.word	-1,.L105,.L423-.L105,.L46-.L105
	.half	1
	.byte	98
	.word	0,0
.L377:
	.word	0,0
.L368:
	.word	0,0
.L375:
	.word	0,0
.L362:
	.word	0,0
.L370:
	.word	0,0
.L369:
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_UpdateBlockStatus_Restore')
	.sect	'.debug_loc'
.L339:
	.word	-1,.L103,0,.L338-.L103
	.half	1
	.byte	100
	.word	0,0
.L102:
	.word	-1,.L103,0,.L338-.L103
	.half	2
	.byte	138,0
	.word	0,0
.L349:
	.word	-1,.L103,.L422-.L103,.L41-.L103
	.half	1
	.byte	98
	.word	0,0
.L353:
	.word	0,0
.L343:
	.word	0,0
.L357:
	.word	0,0
.L355:
	.word	0,0
	.sdecl	'.debug_frame',debug
	.sect	'.debug_frame'
.L683:
	.word	48
	.word	-1
	.byte	3,0,2,1,27,12,26,0,8,27,8,26,8,28,8,29,8,30,8,31,8,34,8,35,8,32,8,33,8,16,8,17,8,24,8,25,8,36,8,37,8,38
	.byte	8,39
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_EvalReqResult')
	.sect	'.debug_frame'
	.word	24
	.word	.L683,.L87,.L299-.L87
	.byte	8,18,8,19,8,21,8,22,8,23,0,0
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_EvalReqResult_Read')
	.sect	'.debug_frame'
	.word	24
	.word	.L683,.L89,.L303-.L89
	.byte	8,18,8,19,8,21,8,22,8,23,0,0
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_EvalReqResult_InvalidateForRemoveNonResistant')
	.sect	'.debug_frame'
	.word	24
	.word	.L683,.L91,.L306-.L91
	.byte	8,18,8,19,8,21,8,22,8,23,0,0
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_EvalReqResult_RestoreForImplicitRecovery')
	.sect	'.debug_frame'
	.word	24
	.word	.L683,.L93,.L309-.L93
	.byte	8,18,8,19,8,21,8,22,8,23,0,0
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_EvalReqResult_ReadIdConfigForReadAll')
	.sect	'.debug_frame'
	.word	24
	.word	.L683,.L95,.L312-.L95
	.byte	8,18,8,19,8,21,8,22,8,23,0,0
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_EvalProductionErrors')
	.sect	'.debug_frame'
	.word	24
	.word	.L683,.L97,.L329-.L97
	.byte	8,18,8,19,8,21,8,22,8,23,0,0
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_EvalProductionErrors_Read')
	.sect	'.debug_frame'
	.word	24
	.word	.L683,.L99,.L332-.L99
	.byte	8,18,8,19,8,21,8,22,8,23,0,0
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_EvalProductionErrors_ReadIdConfigForReadAll')
	.sect	'.debug_frame'
	.word	24
	.word	.L683,.L101,.L335-.L101
	.byte	8,18,8,19,8,21,8,22,8,23,0,0
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_UpdateBlockStatus_Restore')
	.sect	'.debug_frame'
	.word	20
	.word	.L683,.L103,.L338-.L103
	.byte	8,19,8,22,8,23,0,0
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_UpdateBlockStatus_ReadWrite')
	.sect	'.debug_frame'
	.word	20
	.word	.L683,.L105,.L359-.L105
	.byte	8,19,8,22,8,23,0,0
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_UpdateBlockStatusJobValidate')
	.sect	'.debug_frame'
	.word	24
	.word	.L683,.L107,.L380-.L107
	.byte	8,18,8,19,8,21,8,22,8,23,0,0
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_UpdateBlockStatusIdConfigForReadAll')
	.sect	'.debug_frame'
	.word	24
	.word	.L683,.L109,.L386-.L109
	.byte	8,18,8,19,8,21,8,22,8,23,0,0
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_GetFctJobEvalReqResult')
	.sect	'.debug_frame'
	.word	24
	.word	.L683,.L111,.L395-.L111
	.byte	8,19,8,20,8,21,8,22,8,23,0,0
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_GetFctJobEvalProductionErrors')
	.sect	'.debug_frame'
	.word	24
	.word	.L683,.L113,.L398-.L113
	.byte	8,19,8,20,8,21,8,22,8,23,0,0
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_GetFctJobUpdateBlockStatus')
	.sect	'.debug_frame'
	.word	24
	.word	.L683,.L115,.L400-.L115
	.byte	8,19,8,20,8,21,8,22,8,23,0,0
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_MainFunctionResultEval')
	.sect	'.debug_frame'
	.word	36
	.word	.L683,.L117,.L208-.L117
	.byte	4
	.word	(.L424-.L117)/2
	.byte	19,16,22,26,3,19,138,16,4
	.word	(.L208-.L424)/2
	.byte	19,0,8,26,0,0

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionResultEval.c	   626  }

	; Module end
