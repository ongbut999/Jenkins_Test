	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 19053136 SN 09001910"
	.compiler_invocation	"ctc -f cc16900a -c99 --integer-enumeration -D__CPU__=tc27x -D__CPU_TC27X__ --core=tc1.6.x --eabi-compliant --fp-model=-float -D_TASKING_C_TRICORE_=1 -I.\\output\\inc -g2 -t4 --language=-comments,-gcc,+volatile,-strings --default-near-size=0 -O2ROPYGKLF-predict --default-a1-size=0 --default-a0-size=0 --source --switch=auto -o output\\objs\\BSW\\src\\BSW\\Gen\\NvM\\NvM_RestoreBlockDefaults.src BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_RestoreBlockDefaults.c"
	.compiler_name		"ctc"
	;source	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_RestoreBlockDefaults.c'

	
$TC16X
	
	.sdecl	'.text.NvM_RestoreBlockDefaults.NvM_RestoreBlockDefaults',code,cluster('NvM_RestoreBlockDefaults')
	.sect	'.text.NvM_RestoreBlockDefaults.NvM_RestoreBlockDefaults'
	.align	2
	
	.global	NvM_RestoreBlockDefaults

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	     2  /*
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	     3   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	     4   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	     5   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	     6  */
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	     7  #include "NvM.h"
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	     8  #include "Rte_NvM.h"
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	     9  
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    10  #include "NvM_Prv_Service.h"
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    11  #include "NvM_Prv_BlockData.h"
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    12  #include "NvM_Prv_ErrorDetection.h"
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    13  
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    14  /*
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    16   * Declarations
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    17   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    18   */
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    19  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    20  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    21  
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    22  static boolean NvM_Prv_Restore_CheckParameter(NvM_Prv_BlockData_tst const* BlockData_pcst);
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    23  static boolean NvM_Prv_Restore_CheckBlockData(NvM_Prv_BlockData_tst const* BlockData_pcst);
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    24  static void NvM_Prv_Restore_SetBlockData(NvM_Prv_BlockData_tst const* BlockData_pcst);
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    25  
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    26  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    27  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    28  
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    29  /*
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    30   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    31   * Code
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    32   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    33  */
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    34  
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    35  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    36  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    37  
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    38  #ifdef NVM_CFG_API_RESTORE_BLOCK_DEFAULTS
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    40  // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2917] Declaration of the overloading function shall be done here, not in a header file
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    41  /* MR12 RULE 8.5 VIOLATION: Not using a header file for this declaration is a customer requirement */
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    42  extern Std_ReturnType NVM_CFG_API_RESTORE_BLOCK_DEFAULTS(NvM_BlockIdType BlockId, void *NvM_DstPtr);
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    43  
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    44  /* MR12 RULE 8.3 VIOLATION: The parameter identifiers in Rte's generated declaration of this depend on Rte vendor */
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    45  Std_ReturnType NvM_RestoreBlockDefaults(NvM_BlockIdType BlockId, void *NvM_DstPtr)
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    46  {
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    47      // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2920] Call the overloading function
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    48      return NVM_CFG_API_RESTORE_BLOCK_DEFAULTS(BlockId, NvM_DstPtr);
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    49  }
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    50  
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    51  Std_ReturnType NvM_Rb_RestoreBlockDefaultsBase(NvM_BlockIdType BlockId, void *NvM_DstPtr)
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    52  
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    53  #else
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    54  
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    55  /* MR12 RULE 8.3 VIOLATION: The parameter identifiers in Rte's generated declaration of this depend on Rte vendor; typedef is generated by Rte instead of using void pointer (but is compatible) */
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    56  Std_ReturnType NvM_RestoreBlockDefaults(NvM_BlockIdType BlockId, void *NvM_DstPtr)
; Function NvM_RestoreBlockDefaults
.L22:
NvM_RestoreBlockDefaults:	.type	func
	sub.a	a10,#32
.L136:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    57  
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    58  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    59  {
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    60      // TRACE[NVM456] Service to restore the default data to its corresponding RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    61  
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    62      Std_ReturnType stReturn_uo = E_NOT_OK;
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    63      NvM_Prv_Service_Configuration_tst ServiceConfiguration_st;
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    64      NvM_Prv_BlockData_tst BlockData_st;
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    65  
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    66      // put all service parameters in a structure for new block data
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    67      BlockData_st.QueueEntry_st.idBlock_uo = BlockId;
	st.h	[a10]18,d4
.L161:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    68      BlockData_st.QueueEntry_st.BlockData_pv = NvM_DstPtr;
	st.a	[a10]24,a4
.L162:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    69      BlockData_st.QueueEntry_st.idService_uo = NVM_SERVICE_ID_RESTORE_BLOCK_DEFAULTS;
	mov	d15,#8
.L163:
	st.b	[a10]16,d15
.L164:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    70      BlockData_st.QueueEntry_st.ServiceBit_uo = NvM_Prv_ServiceBit_Restore_e;
	mov	d15,#12
.L165:
	st.h	[a10]20,d15
.L166:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    71      BlockData_st.Result_uo = NVM_REQ_PENDING;
	mov	d15,#2
.L167:
	st.b	[a10]28,d15
.L168:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    72      BlockData_st.idxDataset_u8 = 0;
	mov	d15,#0
.L169:
	st.b	[a10]29,d15
.L170:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    73      BlockData_st.maskBitsToChange_u8 = 0u;
	mov	d15,#0
.L171:
	st.b	[a10]30,d15
.L172:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    74      BlockData_st.maskBitsNewValue_u8 = 0u;
	mov	d15,#0
.L173:
	st.b	[a10]31,d15
.L174:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    75  
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    76      // determine whether permanent RAM block shall be used
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    77      if (NULL_PTR == BlockData_st.QueueEntry_st.BlockData_pv)
	mov.a	a15,#0
.L175:
	jne.a	a15,a4,.L2
.L65:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   392  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   393   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   394   * This NvM private function checks for the given block whether the configured block length is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   395   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   396   * \param idBlock
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   397   * ID of the block for which the block length will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   398   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   399   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   400   * - TRUE = block length is valid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   401   * - FALSE = block length is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   402   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   403  LOCAL_INLINE boolean NvM_Prv_IsBlockLengthValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   404  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   405      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   406              (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   407              (0u != *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   408  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   409  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   410  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   411   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   412   * This NvM private function checks whether the given block is configured with immediate priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   413   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   414   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   415   * ID of the block for which the priority will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   416   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   417   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   418   * - TRUE = block is configured with immediate priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   419   * - FALSE = block is configured with standard priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   420   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   421  LOCAL_INLINE boolean NvM_Prv_HasBlockImmediateJobPriority(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   423      boolean HasBlockImmediateJobPriority_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   425  #if (NVM_JOB_PRIORITIZATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   426      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   427          (NVM_PRV_JOB_PRIORITY_IMMEDIATE == NvM_Prv_BlockDescriptors_acst[idBlock_uo].JobPriority_u8))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   428      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   429          HasBlockImmediateJobPriority_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   430      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   431  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   433  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   434  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   435  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   436   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   437   * This NvM private function returns the configured block size for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   438   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   439   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   440   * ID of the block for which the configured block size will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   441   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   442   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   443   * Configured block size
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   444   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   445  LOCAL_INLINE uint16 NvM_Prv_GetBlockSize(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   446  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   447      uint16 BlockSize_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   448  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   451      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   452          BlockSize_u16 = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   453      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   454  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   455      return BlockSize_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   456  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   457  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   458  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   459   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   460   * This NvM private function returns the configured block management type for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   461   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   462   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   463   * ID of the block for which the configured block management type will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   464   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   465   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   466   * Configured block management type
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   467   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   468  LOCAL_INLINE NvM_BlockManagementType NvM_Prv_GetBlockType(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   469  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   470      NvM_BlockManagementType BlockType = NVM_BLOCK_NATIVE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   472      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   473          BlockType = NvM_Prv_BlockDescriptors_acst[idBlock_uo].BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   474      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   475      return BlockType;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   476  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   477  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   478  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   479   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   480   * This NvM private function returns the configured number of non-volatile data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   481   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   482   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   483   * ID of the block for which the configured number of non-volatile data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   484   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   485   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   486   * Configured number of non-volatile data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   487   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   488  LOCAL_INLINE uint8 NvM_Prv_GetNrNonVolatileBlocks(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   489  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   490      uint8 nrNvBlocks_u8 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   491      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   492      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   493          nrNvBlocks_u8 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   494      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   495      return nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   496  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   497  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   498  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   499   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   500   * This NvM private function returns the configured overall number of data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   501   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   502   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   503   * ID of the block for which the configured overall number of data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   504   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   505   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   506   * Configured number of data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   507   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   508  LOCAL_INLINE uint16 NvM_Prv_GetNrDataIndexes(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   509  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   510      uint8 nrDataIndexes = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   511      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   512      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   513          nrDataIndexes = (NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8 +
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   514                           NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrRomBlocks_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   515      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   516      return nrDataIndexes;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   517  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   518  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   519  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   520   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   521   * This NvM private function returns the pointer to the configured permanent RAM block for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   522   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   523   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   524   * If no permanent RAM block is configured for a block then this function returns a NULL pointer.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   525   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   526   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   527   * ID of the block for which the pointer to the configured permanent RAM block will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   528   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   529   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   530   * Pointer to the configured permanent RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   531   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   532  LOCAL_INLINE void * NvM_Prv_GetPRamBlockAddress(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   533  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   534      void * PRamBlockAddress_pv = NULL_PTR;
	mov.a	a2,#0
.L139:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   535      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
	jge.u	d4,#14,.L3
.L176:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   535      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   536          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv))
	mul	d15,d4,#48
.L177:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L178:
	addsc.a	a15,a15,d15,#0
.L179:
	ld.a	a15,[a15]12
.L180:
	mov.a	a4,#0
.L138:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   536          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv))      (inlined)
	jeq.a	a4,a15,.L4
.L181:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   537      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   538          PRamBlockAddress_pv = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv;
	ld.a	a2,[a15]

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   535      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
.L4:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   536          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv))      (inlined)
.L3:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   541      return PRamBlockAddress_pv;      (inlined)
	j	.L5

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   542  }      (inlined)
.L5:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    78      {
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    79          // TRACE[NVM435] Only take the permanent RAM block if no temporary RAM block has been specified
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    80          BlockData_st.QueueEntry_st.BlockData_pv = NvM_Prv_GetPRamBlockAddress(BlockId);
	st.a	[a10]24,a2
.L66:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    81          // TRACE[NVM227] Set the status of the permanent RAM block to INVALID before processing starts
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    82          BlockData_st.maskBitsToChange_u8 = NVM_BLOCK_STATE_RAM_VALID;
	mov	d15,#1
.L182:
	st.b	[a10]30,d15
.L183:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    83          BlockData_st.maskBitsNewValue_u8 = 0u;
	mov	d15,#0
.L184:
	st.b	[a10]31,d15
.L2:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    84      }
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    85  
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    86      ServiceConfiguration_st.CheckPendingBlock_b = TRUE;
	mov	d15,#1
.L185:
	st.b	[a10],d15
.L186:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    87      ServiceConfiguration_st.CheckParameter_pfct = NvM_Prv_Restore_CheckParameter;
	movh.a	a15,#@his(NvM_Prv_Restore_CheckParameter)
	lea	a15,[a15]@los(NvM_Prv_Restore_CheckParameter)
.L187:
	st.a	[a10]4,a15
.L188:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    88      ServiceConfiguration_st.CheckBlockData_pfct = NvM_Prv_Restore_CheckBlockData;
	movh.a	a15,#@his(NvM_Prv_Restore_CheckBlockData)
	lea	a15,[a15]@los(NvM_Prv_Restore_CheckBlockData)
.L189:
	st.a	[a10]8,a15
.L190:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    89      ServiceConfiguration_st.SetBlockData_pfct = NvM_Prv_Restore_SetBlockData;
	movh.a	a15,#@his(NvM_Prv_Restore_SetBlockData)
	lea	a15,[a15]@los(NvM_Prv_Restore_SetBlockData)
.L191:
	st.a	[a10]12,a15
.L192:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    91      // TRACE[NVM625] Report the DET error NVM_E_NOT_INITIALIZED when the NVM is not yet initialized
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    92      // TRACE[NVM012] Trigger a read of default data to RAM
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    93      // TRACE[NVM224] The actual restore operation is not done here, just the request for doing it is queued
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    94      stReturn_uo = NvM_Prv_Service_Initiate(NvM_Prv_idQueue_Standard_e,
	mov	d4,#1
.L137:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    95                                             &BlockData_st,
	lea	a4,[a10]16
.L193:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    96                                             &ServiceConfiguration_st);
	lea	a5,[a10]0
	call	NvM_Prv_Service_Initiate
.L140:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    97  
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    98      // Return whether this operation was successful
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	    99      return stReturn_uo;
	j	.L6

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   100  }
.L6:
	ret
.L54:
	
__NvM_RestoreBlockDefaults_function_end:
	.size	NvM_RestoreBlockDefaults,__NvM_RestoreBlockDefaults_function_end-NvM_RestoreBlockDefaults
.L37:
	; End of function
	
	.sdecl	'.text.NvM_RestoreBlockDefaults.NvM_Prv_Restore_CheckParameter',code,cluster('NvM_Prv_Restore_CheckParameter')
	.sect	'.text.NvM_RestoreBlockDefaults.NvM_Prv_Restore_CheckParameter'
	.align	2
	

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   101  
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   102  static boolean NvM_Prv_Restore_CheckParameter(NvM_Prv_BlockData_tst const* BlockData_pcst)
; Function NvM_Prv_Restore_CheckParameter
.L24:
NvM_Prv_Restore_CheckParameter:	.type	func
	mov.aa	a15,a4
.L142:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   103  {
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   104      boolean isParameterValid_b = FALSE;
	mov	d15,#0
.L143:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   105  
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   106      // TRACE[NVM435] Only take the permanent RAM block if no temporary RAM block has been specified
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   107      // TRACE[NVM629] Report the DET error NVM_E_PARAM_ADDRESS when no permanent RAM block is configured and
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   108      //               a NULL pointer is passed
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   109      if (NvM_Prv_ErrorDetection_IsRamBlockAddressValid(BlockData_pcst->QueueEntry_st.idService_uo,
	ld.bu	d4,[a15]
.L198:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   110                                                        BlockData_pcst->QueueEntry_st.idBlock_uo,
	ld.hu	d5,[a15]2
.L199:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   111                                                        BlockData_pcst->QueueEntry_st.BlockData_pv))
	ld.a	a4,[a15]8
.L141:
	call	NvM_Prv_ErrorDetection_IsRamBlockAddressValid
.L200:
	jeq	d2,#0,.L7
.L201:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   112      {
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   113          // TRACE[NVM628] Report the DET error NVM_E_BLOCK_CONFIG when default data is not available/configured
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   114          //               for the referenced NVRAM block
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   115          if (NvM_Prv_ErrorDetection_IsDefaultDataAvailable(BlockData_pcst->QueueEntry_st.idService_uo,
	ld.bu	d4,[a15]
.L202:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   116                                                            BlockData_pcst->QueueEntry_st.idBlock_uo))
	ld.hu	d5,[a15]2
	call	NvM_Prv_ErrorDetection_IsDefaultDataAvailable
.L203:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   117          {
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   118              isParameterValid_b = TRUE;
	seln	d15,d2,d15,#1
.L8:
.L7:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   119          }
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   120      }
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   121      return isParameterValid_b;
	mov	d2,d15
.L144:
	j	.L9

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   122  }
.L9:
	ret
.L71:
	
__NvM_Prv_Restore_CheckParameter_function_end:
	.size	NvM_Prv_Restore_CheckParameter,__NvM_Prv_Restore_CheckParameter_function_end-NvM_Prv_Restore_CheckParameter
.L42:
	; End of function
	
	.sdecl	'.text.NvM_RestoreBlockDefaults.NvM_Prv_Restore_CheckBlockData',code,cluster('NvM_Prv_Restore_CheckBlockData')
	.sect	'.text.NvM_RestoreBlockDefaults.NvM_Prv_Restore_CheckBlockData'
	.align	2
	

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   123  
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   124  static boolean NvM_Prv_Restore_CheckBlockData(NvM_Prv_BlockData_tst const* BlockData_pcst)
; Function NvM_Prv_Restore_CheckBlockData
.L26:
NvM_Prv_Restore_CheckBlockData:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   125  {
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   126      // TRACE[NVM266] NvM allows the queuing of a NvM_RestoreBlockDefaults request to restore a user block
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   127      //               which has only an InitBlockCallback (i.e. no ROM block).
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   128      // In case of DATASET blocks with at least one ROM block, recovery is potentially ambiguous
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   129      // because it is not clear which ROM block instance to take
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   130      // (the case of exactly one ROM block is not specially treated here for simplicity reasons)
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   131      // -> reject this request
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   132      return (!NvM_Prv_Block_IsRomDataAmbiguous(BlockData_pcst->QueueEntry_st.idBlock_uo));
	ld.hu	d0,[a4]2
.L78:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
	mov	d1,#0
.L84:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   392  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   393   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   394   * This NvM private function checks for the given block whether the configured block length is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   395   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   396   * \param idBlock
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   397   * ID of the block for which the block length will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   398   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   399   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   400   * - TRUE = block length is valid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   401   * - FALSE = block length is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   402   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   403  LOCAL_INLINE boolean NvM_Prv_IsBlockLengthValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   404  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   405      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   406              (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   407              (0u != *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   408  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   409  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   410  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   411   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   412   * This NvM private function checks whether the given block is configured with immediate priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   413   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   414   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   415   * ID of the block for which the priority will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   416   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   417   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   418   * - TRUE = block is configured with immediate priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   419   * - FALSE = block is configured with standard priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   420   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   421  LOCAL_INLINE boolean NvM_Prv_HasBlockImmediateJobPriority(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   423      boolean HasBlockImmediateJobPriority_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   425  #if (NVM_JOB_PRIORITIZATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   426      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   427          (NVM_PRV_JOB_PRIORITY_IMMEDIATE == NvM_Prv_BlockDescriptors_acst[idBlock_uo].JobPriority_u8))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   428      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   429          HasBlockImmediateJobPriority_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   430      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   431  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   433  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   434  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   435  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   436   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   437   * This NvM private function returns the configured block size for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   438   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   439   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   440   * ID of the block for which the configured block size will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   441   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   442   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   443   * Configured block size
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   444   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   445  LOCAL_INLINE uint16 NvM_Prv_GetBlockSize(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   446  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   447      uint16 BlockSize_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   448  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   451      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   452          BlockSize_u16 = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   453      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   454  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   455      return BlockSize_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   456  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   457  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   458  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   459   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   460   * This NvM private function returns the configured block management type for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   461   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   462   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   463   * ID of the block for which the configured block management type will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   464   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   465   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   466   * Configured block management type
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   467   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   468  LOCAL_INLINE NvM_BlockManagementType NvM_Prv_GetBlockType(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   469  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   470      NvM_BlockManagementType BlockType = NVM_BLOCK_NATIVE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   472      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   473          BlockType = NvM_Prv_BlockDescriptors_acst[idBlock_uo].BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   474      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   475      return BlockType;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   476  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   477  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   478  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   479   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   480   * This NvM private function returns the configured number of non-volatile data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   481   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   482   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   483   * ID of the block for which the configured number of non-volatile data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   484   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   485   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   486   * Configured number of non-volatile data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   487   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   488  LOCAL_INLINE uint8 NvM_Prv_GetNrNonVolatileBlocks(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   489  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   490      uint8 nrNvBlocks_u8 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   491      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   492      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   493          nrNvBlocks_u8 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   494      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   495      return nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   496  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   497  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   498  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   499   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   500   * This NvM private function returns the configured overall number of data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   501   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   502   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   503   * ID of the block for which the configured overall number of data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   504   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   505   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   506   * Configured number of data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   507   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   508  LOCAL_INLINE uint16 NvM_Prv_GetNrDataIndexes(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   509  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   510      uint8 nrDataIndexes = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   511      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   512      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   513          nrDataIndexes = (NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8 +
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   514                           NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrRomBlocks_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   515      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   516      return nrDataIndexes;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   517  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   518  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   519  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   520   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   521   * This NvM private function returns the pointer to the configured permanent RAM block for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   522   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   523   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   524   * If no permanent RAM block is configured for a block then this function returns a NULL pointer.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   525   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   526   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   527   * ID of the block for which the pointer to the configured permanent RAM block will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   528   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   529   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   530   * Pointer to the configured permanent RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   531   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   532  LOCAL_INLINE void * NvM_Prv_GetPRamBlockAddress(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   533  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   534      void * PRamBlockAddress_pv = NULL_PTR;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   535      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   536          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   537      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   538          PRamBlockAddress_pv = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   539      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   540  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   541      return PRamBlockAddress_pv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   542  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   543  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   544  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   545   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   546   * This NvM private function returns the pointer to the configured ROM block for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   547   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   548   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   549   * If no ROM block is configured for a block then this function returns a NULL pointer.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   550   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   551   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   552   * ID of the block for which the pointer to the configured ROM block will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   553   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   554   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   555   * Pointer to the configured ROM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   556   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   557  LOCAL_INLINE void const* NvM_Prv_GetRomBlockAddress(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   558  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   559      void const* adrRomBlock_pcv = NULL_PTR;
	mov.a	a15,#0
.L145:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   560      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
	jge.u	d0,#14,.L10
.L208:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   560      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   561      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   562          adrRomBlock_pcv = NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv;
	mul	d15,d0,#48
.L209:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
.L146:
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L210:
	addsc.a	a15,a15,d15,#0
.L211:
	ld.a	a15,[a15]16

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   560      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
.L10:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   564      return adrRomBlock_pcv;      (inlined)
	j	.L11

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   565  }      (inlined)
.L11:
	mov.a	a2,#0
.L89:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&      (inlined)
	jeq.a	a2,a15,.L12
.L90:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   392  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   393   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   394   * This NvM private function checks for the given block whether the configured block length is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   395   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   396   * \param idBlock
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   397   * ID of the block for which the block length will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   398   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   399   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   400   * - TRUE = block length is valid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   401   * - FALSE = block length is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   402   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   403  LOCAL_INLINE boolean NvM_Prv_IsBlockLengthValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   404  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   405      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   406              (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   407              (0u != *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   408  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   409  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   410  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   411   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   412   * This NvM private function checks whether the given block is configured with immediate priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   413   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   414   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   415   * ID of the block for which the priority will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   416   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   417   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   418   * - TRUE = block is configured with immediate priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   419   * - FALSE = block is configured with standard priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   420   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   421  LOCAL_INLINE boolean NvM_Prv_HasBlockImmediateJobPriority(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   423      boolean HasBlockImmediateJobPriority_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   425  #if (NVM_JOB_PRIORITIZATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   426      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   427          (NVM_PRV_JOB_PRIORITY_IMMEDIATE == NvM_Prv_BlockDescriptors_acst[idBlock_uo].JobPriority_u8))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   428      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   429          HasBlockImmediateJobPriority_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   430      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   431  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   433  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   434  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   435  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   436   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   437   * This NvM private function returns the configured block size for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   438   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   439   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   440   * ID of the block for which the configured block size will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   441   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   442   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   443   * Configured block size
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   444   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   445  LOCAL_INLINE uint16 NvM_Prv_GetBlockSize(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   446  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   447      uint16 BlockSize_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   448  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   451      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   452          BlockSize_u16 = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   453      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   454  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   455      return BlockSize_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   456  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   457  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   458  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   459   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   460   * This NvM private function returns the configured block management type for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   461   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   462   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   463   * ID of the block for which the configured block management type will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   464   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   465   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   466   * Configured block management type
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   467   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   468  LOCAL_INLINE NvM_BlockManagementType NvM_Prv_GetBlockType(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   469  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   470      NvM_BlockManagementType BlockType = NVM_BLOCK_NATIVE;
	mov	d15,#0
.L148:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
	jge.u	d0,#14,.L13
.L212:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   472      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   473          BlockType = NvM_Prv_BlockDescriptors_acst[idBlock_uo].BlockManagementType_en;
	mul	d15,d0,#48
.L149:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
.L147:
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L213:
	addsc.a	a15,a15,d15,#0
.L214:
	ld.w	d15,[a15]40

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
.L13:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   475      return BlockType;      (inlined)
	j	.L14

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   476  }      (inlined)
.L14:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&      (inlined)
	jne	d15,#2,.L15
.L94:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   474      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   475      return BlockType;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   476  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   477  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   478  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   479   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   480   * This NvM private function returns the configured number of non-volatile data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   481   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   482   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   483   * ID of the block for which the configured number of non-volatile data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   484   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   485   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   486   * Configured number of non-volatile data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   487   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   488  LOCAL_INLINE uint8 NvM_Prv_GetNrNonVolatileBlocks(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   489  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   490      uint8 nrNvBlocks_u8 = 0;
	mov	d15,#0
.L150:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   491      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
	jge.u	d0,#14,.L16
.L215:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   491      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   492      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   493          nrNvBlocks_u8 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8;
	mul	d15,d0,#48
.L151:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L216:
	addsc.a	a15,a15,d15,#0
.L217:
	ld.bu	d15,[a15]9

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   491      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
.L16:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   495      return nrNvBlocks_u8;      (inlined)
	j	.L17

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   496  }      (inlined)
.L17:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
	movh.a	a15,#@his(NvM_Prv_idxDataSet_rAMwA_au8)
	lea	a15,[a15]@los(NvM_Prv_idxDataSet_rAMwA_au8)
.L218:
	addsc.a	a15,a15,d0,#0
	ld.bu	d0,[a15]
.L105:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))      (inlined)
	ge.u	d15,d0,d15
.L106:
	cmovn	d1,d15,#1

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&      (inlined)
.L18:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );      (inlined)
.L15:
.L12:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&      (inlined)
	j	.L19

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }      (inlined)
.L19:
	eq	d2,d1,#0
.L79:
	j	.L20

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   133  }
.L20:
	ret
.L75:
	
__NvM_Prv_Restore_CheckBlockData_function_end:
	.size	NvM_Prv_Restore_CheckBlockData,__NvM_Prv_Restore_CheckBlockData_function_end-NvM_Prv_Restore_CheckBlockData
.L47:
	; End of function
	
	.sdecl	'.text.NvM_RestoreBlockDefaults.NvM_Prv_Restore_SetBlockData',code,cluster('NvM_Prv_Restore_SetBlockData')
	.sect	'.text.NvM_RestoreBlockDefaults.NvM_Prv_Restore_SetBlockData'
	.align	2
	

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   134  
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   135  static void NvM_Prv_Restore_SetBlockData(NvM_Prv_BlockData_tst const* BlockData_pcst)
; Function NvM_Prv_Restore_SetBlockData
.L28:
NvM_Prv_Restore_SetBlockData:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   136  {
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   137      // TRACE[NVM185] Set single block request result to NVM_REQ_PENDING on successful enqueuing
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   138      NvM_Prv_Block_SetRequestResult(BlockData_pcst->QueueEntry_st.idBlock_uo, BlockData_pcst->Result_uo);
	ld.hu	d15,[a4]2
.L223:
	ld.bu	d0,[a4]12
.L111:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   169  LOCAL_INLINE boolean NvM_Prv_Block_IsRequestPending(NvM_BlockIdType idBlock_uo, uint16 maskService_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   170  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   172  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   173  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   174  LOCAL_INLINE boolean NvM_Prv_Block_IsPending(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   175  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   176      return (NvM_Prv_Block_IsNvmEnqueuingForMulti(idBlock_uo) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   177              ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != 0)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   178  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   179                && (NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != (1u << NvM_Prv_ServiceBit_Maintain_e))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   180  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   181              )
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   182             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   183  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   184  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   185  LOCAL_INLINE void NvM_Prv_Block_SetIdxData(NvM_BlockIdType idBlock_uo, uint8 idxData_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   186  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   187      NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] = idxData_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   188  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   189  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   190  LOCAL_INLINE void NvM_Prv_Block_SetRequestResult(NvM_BlockIdType idBlock_uo, NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   191  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   192      NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo] = Result_uo;
	movh.a	a15,#@his(NvM_Prv_stRequestResult_rAwAM_au8)
	lea	a15,[a15]@los(NvM_Prv_stRequestResult_rAwAM_au8)
.L224:
	addsc.a	a15,a15,d15,#0
.L225:
	st.b	[a15],d0
.L112:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   139      NvM_Prv_Block_SetRequest(BlockData_pcst->QueueEntry_st.idBlock_uo, BlockData_pcst->QueueEntry_st.ServiceBit_uo);
	ld.hu	d15,[a4]2
.L226:
	ld.hu	d0,[a4]4
.L119:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   169  LOCAL_INLINE boolean NvM_Prv_Block_IsRequestPending(NvM_BlockIdType idBlock_uo, uint16 maskService_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   170  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   172  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   173  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   174  LOCAL_INLINE boolean NvM_Prv_Block_IsPending(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   175  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   176      return (NvM_Prv_Block_IsNvmEnqueuingForMulti(idBlock_uo) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   177              ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != 0)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   178  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   179                && (NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != (1u << NvM_Prv_ServiceBit_Maintain_e))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   180  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   181              )
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   182             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   183  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   184  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   185  LOCAL_INLINE void NvM_Prv_Block_SetIdxData(NvM_BlockIdType idBlock_uo, uint8 idxData_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   186  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   187      NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] = idxData_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   188  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   189  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   190  LOCAL_INLINE void NvM_Prv_Block_SetRequestResult(NvM_BlockIdType idBlock_uo, NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   191  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   192      NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo] = Result_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   193  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   194  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   195  LOCAL_INLINE void NvM_Prv_Block_SetRequest(NvM_BlockIdType idBlock_uo, NvM_Prv_ServiceBit_tuo ServiceBit_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   196  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   197      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= (1u << ServiceBit_uo);
	movh.a	a15,#@his(NvM_Prv_stRequests_rAMwAM_au16)
	lea	a15,[a15]@los(NvM_Prv_stRequests_rAMwAM_au16)
.L227:
	addsc.a	a15,a15,d15,#1
	ld.hu	d15,[a15]0
.L228:
	mov	d1,#1
.L229:
	sh	d1,d1,d0
.L230:
	or	d15,d1
	st.h	[a15],d15
.L120:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   140      NvM_Prv_Block_SetState(BlockData_pcst->QueueEntry_st.idBlock_uo,
	ld.hu	d15,[a4]2
.L231:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   141                             BlockData_pcst->maskBitsToChange_u8,
	ld.bu	d0,[a4]14
.L232:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   142                             BlockData_pcst->maskBitsNewValue_u8);
	ld.bu	d1,[a4]15
.L127:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   169  LOCAL_INLINE boolean NvM_Prv_Block_IsRequestPending(NvM_BlockIdType idBlock_uo, uint16 maskService_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   170  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   172  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   173  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   174  LOCAL_INLINE boolean NvM_Prv_Block_IsPending(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   175  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   176      return (NvM_Prv_Block_IsNvmEnqueuingForMulti(idBlock_uo) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   177              ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != 0)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   178  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   179                && (NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != (1u << NvM_Prv_ServiceBit_Maintain_e))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   180  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   181              )
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   182             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   183  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   184  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   185  LOCAL_INLINE void NvM_Prv_Block_SetIdxData(NvM_BlockIdType idBlock_uo, uint8 idxData_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   186  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   187      NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] = idxData_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   188  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   189  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   190  LOCAL_INLINE void NvM_Prv_Block_SetRequestResult(NvM_BlockIdType idBlock_uo, NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   191  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   192      NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo] = Result_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   193  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   194  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   195  LOCAL_INLINE void NvM_Prv_Block_SetRequest(NvM_BlockIdType idBlock_uo, NvM_Prv_ServiceBit_tuo ServiceBit_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   196  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   197      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= (1u << ServiceBit_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   198  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   199  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   200  LOCAL_INLINE void NvM_Prv_Block_SetRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   201  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   202      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= maskRequests_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   203  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   204  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   205  LOCAL_INLINE void NvM_Prv_Block_ClearRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   206  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   207      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] &= (~maskRequests_u16);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   208  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   209  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   210  LOCAL_INLINE void NvM_Prv_Block_SetState(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   211                                           uint8 maskBitsToChange_u8,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   212                                           uint8 maskBitsNewValue_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   213  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   214      NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] = ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & (~maskBitsToChange_u8)) |
	movh.a	a15,#@his(NvM_Prv_stBlock_rAwAM_au8)
	lea	a15,[a15]@los(NvM_Prv_stBlock_rAwAM_au8)
.L233:
	addsc.a	a15,a15,d15,#0
	ld.bu	d15,[a15]
.L234:
	xor	d2,d0,#255
.L235:
	and	d15,d2
.L236:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   215                                               (maskBitsNewValue_u8 & maskBitsToChange_u8));
	and	d0,d1
.L237:
	or	d15,d0
.L238:
	st.b	[a15],d15
.L128:

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   143  }
	ret
.L108:
	
__NvM_Prv_Restore_SetBlockData_function_end:
	.size	NvM_Prv_Restore_SetBlockData,__NvM_Prv_Restore_SetBlockData_function_end-NvM_Prv_Restore_SetBlockData
.L52:
	; End of function
	
	.calls	'__INDIRECT__','NvM_Prv_Restore_CheckParameter'
	.calls	'__INDIRECT__','NvM_Prv_Restore_CheckBlockData'
	.calls	'__INDIRECT__','NvM_Prv_Restore_SetBlockData'
	.calls	'NvM_RestoreBlockDefaults','NvM_Prv_Service_Initiate'
	.calls	'NvM_Prv_Restore_CheckParameter','NvM_Prv_ErrorDetection_IsRamBlockAddressValid'
	.calls	'NvM_Prv_Restore_CheckParameter','NvM_Prv_ErrorDetection_IsDefaultDataAvailable'
	.calls	'NvM_RestoreBlockDefaults','',32
	.calls	'NvM_Prv_Restore_CheckParameter','',0
	.calls	'NvM_Prv_Restore_CheckBlockData','',0
	.extern	NvM_Prv_Service_Initiate
	.extern	NvM_Prv_BlockDescriptors_acst
	.extern	NvM_Prv_stBlock_rAwAM_au8
	.extern	NvM_Prv_stRequests_rAMwAM_au16
	.extern	NvM_Prv_stRequestResult_rAwAM_au8
	.extern	NvM_Prv_idxDataSet_rAMwA_au8
	.extern	NvM_Prv_ErrorDetection_IsDefaultDataAvailable
	.extern	NvM_Prv_ErrorDetection_IsRamBlockAddressValid
	.extern	__INDIRECT__
	.calls	'NvM_Prv_Restore_SetBlockData','',0
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L30:
	.word	14364
	.half	3
	.word	.L31
	.byte	4
.L29:
	.byte	1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_RestoreBlockDefaults.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L32
.L98:
	.byte	2,2,40,9,4,3
	.byte	'NVM_BLOCK_NATIVE',0,0,3
	.byte	'NVM_BLOCK_REDUNDANT',0,1,3
	.byte	'NVM_BLOCK_DATASET',0,2,0
.L55:
	.byte	4
	.byte	'unsigned short int',0,2,7
.L93:
	.byte	5
	.byte	'NvM_Prv_GetBlockType',0,3,1,212,3,38
	.word	150
	.byte	1,1
.L95:
	.byte	6
	.byte	'idBlock_uo',0,1,212,3,75
	.word	217
.L97:
	.byte	7,0
.L53:
	.byte	4
	.byte	'unsigned char',0,1,8
.L100:
	.byte	5
	.byte	'NvM_Prv_GetNrNonVolatileBlocks',0,3,1,232,3,20
	.word	294
	.byte	1,1
.L101:
	.byte	6
	.byte	'idBlock_uo',0,1,232,3,67
	.word	217
.L103:
	.byte	7,0,8
	.byte	'void',0
.L57:
	.byte	9
	.word	376
.L64:
	.byte	5
	.byte	'NvM_Prv_GetPRamBlockAddress',0,3,1,148,4,21
	.word	382
	.byte	1,1
.L67:
	.byte	6
	.byte	'idBlock_uo',0,1,148,4,65
	.word	217
.L69:
	.byte	7,0,10
	.word	376
.L91:
	.byte	9
	.word	449
.L83:
	.byte	5
	.byte	'NvM_Prv_GetRomBlockAddress',0,3,1,173,4,26
	.word	454
	.byte	1,1
.L85:
	.byte	6
	.byte	'idBlock_uo',0,1,173,4,69
	.word	217
.L87:
	.byte	7,0
.L77:
	.byte	5
	.byte	'NvM_Prv_Block_IsRomDataAmbiguous',0,3,3,134,1,22
	.word	294
	.byte	1,1
.L80:
	.byte	6
	.byte	'idBlock_uo',0,3,134,1,71
	.word	217
.L82:
	.byte	11,7,7,7,0,0,5
	.byte	'NvM_Prv_Block_IsInRom',0,3,3,142,1,22
	.word	294
	.byte	1,1,6
	.byte	'idBlock_uo',0,3,142,1,60
	.word	217
	.byte	6
	.byte	'idxDataset_u8',0,3,142,1,78
	.word	294
	.byte	11,7,7,0,0,5
	.byte	'NvM_Prv_Block_IsWriteProtected',0,3,3,148,1,22
	.word	294
	.byte	1,1,6
	.byte	'idBlock_uo',0,3,148,1,69
	.word	217
	.byte	7,0
.L110:
	.byte	12
	.byte	'NvM_Prv_Block_SetRequestResult',0,3,3,190,1,19,1,1
.L113:
	.byte	6
	.byte	'idBlock_uo',0,3,190,1,66
	.word	217
.L115:
	.byte	6
	.byte	'Result_uo',0,3,190,1,100
	.word	294
.L117:
	.byte	7,0
.L118:
	.byte	12
	.byte	'NvM_Prv_Block_SetRequest',0,3,3,195,1,19,1,1
.L121:
	.byte	6
	.byte	'idBlock_uo',0,3,195,1,60
	.word	217
.L123:
	.byte	6
	.byte	'ServiceBit_uo',0,3,195,1,95
	.word	217
.L125:
	.byte	7,0
.L126:
	.byte	12
	.byte	'NvM_Prv_Block_SetState',0,3,3,210,1,19,1,1
.L129:
	.byte	6
	.byte	'idBlock_uo',0,3,210,1,58
	.word	217
.L131:
	.byte	6
	.byte	'maskBitsToChange_u8',0,3,211,1,48
	.word	294
.L133:
	.byte	6
	.byte	'maskBitsNewValue_u8',0,3,212,1,48
	.word	294
.L135:
	.byte	7,0,13,2,210,1,9,12,14
	.byte	'idService_uo',0
	.word	294
	.byte	1,2,35,0,14
	.byte	'idBlock_uo',0
	.word	217
	.byte	2,2,35,2,14
	.byte	'ServiceBit_uo',0
	.word	217
	.byte	2,2,35,4,14
	.byte	'BlockData_pv',0
	.word	382
	.byte	4,2,35,8,0
.L62:
	.byte	13,4,23,9,16,14
	.byte	'QueueEntry_st',0
	.word	1007
	.byte	12,2,35,0,14
	.byte	'Result_uo',0
	.word	294
	.byte	1,2,35,12,14
	.byte	'idxDataset_u8',0
	.word	294
	.byte	1,2,35,13,14
	.byte	'maskBitsToChange_u8',0
	.word	294
	.byte	1,2,35,14,14
	.byte	'maskBitsNewValue_u8',0
	.word	294
	.byte	1,2,35,15,0,10
	.word	1101
	.byte	9
	.word	1230
	.byte	15
	.word	294
	.byte	1,1,16
	.word	1235
	.byte	0,9
	.word	1240
	.byte	17
	.byte	'NvM_Prv_Service_CheckParameter_tpfct',0,4,38,19
	.word	1253
	.byte	17
	.byte	'NvM_Prv_Service_CheckBlockData_tpfct',0,4,39,19
	.word	1253
	.byte	18,1,1,16
	.word	1235
	.byte	0,9
	.word	1348
	.byte	17
	.byte	'NvM_Prv_Service_SetBlockData_tpfct',0,4,40,16
	.word	1357
.L60:
	.byte	13,4,42,9,16,14
	.byte	'CheckPendingBlock_b',0
	.word	294
	.byte	1,2,35,0,14
	.byte	'CheckParameter_pfct',0
	.word	1258
	.byte	4,2,35,4,14
	.byte	'CheckBlockData_pfct',0
	.word	1303
	.byte	4,2,35,8,14
	.byte	'SetBlockData_pfct',0
	.word	1362
	.byte	4,2,35,12,0,9
	.word	1240
	.byte	9
	.word	1240
	.byte	9
	.word	1348
	.byte	10
	.word	1101
.L72:
	.byte	9
	.word	1540
	.byte	10
	.word	1405
	.byte	9
	.word	1550
	.byte	19
	.byte	'NvM_Prv_Service_Initiate',0,4,71,23
	.word	294
	.byte	1,1,1,1,6
	.byte	'idQueue_uo',0,4,71,68
	.word	294
	.byte	6
	.byte	'BlockData_pcst',0,4,72,77
	.word	1545
	.byte	6
	.byte	'ServiceConfiguration_pcst',0,4,73,89
	.word	1555
	.byte	0,20
	.word	239
	.byte	21
	.word	272
	.byte	7,0,20
	.word	311
	.byte	21
	.word	354
	.byte	7,0,20
	.word	387
	.byte	21
	.word	427
	.byte	7,0,20
	.word	459
	.byte	21
	.word	498
	.byte	7,0,20
	.word	520
	.byte	21
	.word	565
	.byte	11,22
	.word	459
	.byte	21
	.word	498
	.byte	23
	.word	518
	.byte	0,7,22
	.word	239
	.byte	21
	.word	272
	.byte	23
	.word	292
	.byte	0,7,22
	.word	311
	.byte	21
	.word	354
	.byte	23
	.word	374
	.byte	0,7,0,0,20
	.word	591
	.byte	21
	.word	625
	.byte	21
	.word	645
	.byte	11,22
	.word	239
	.byte	21
	.word	272
	.byte	23
	.word	292
	.byte	0,7,22
	.word	311
	.byte	21
	.word	354
	.byte	23
	.word	374
	.byte	0,7,0,0,20
	.word	673
	.byte	21
	.word	716
	.byte	7,0,20
	.word	738
	.byte	21
	.word	777
	.byte	21
	.word	797
	.byte	7,0,20
	.word	818
	.byte	21
	.word	851
	.byte	21
	.word	871
	.byte	7,0,20
	.word	896
	.byte	21
	.word	927
	.byte	21
	.word	947
	.byte	21
	.word	976
	.byte	7,0,19
	.byte	'NvM_Prv_ErrorDetection_IsDefaultDataAvailable',0,5,94,16
	.word	294
	.byte	1,1,1,1,6
	.byte	'idService_uo',0,5,94,84
	.word	294
	.byte	6
	.byte	'idBlock_uo',0,5,95,78
	.word	217
	.byte	0,19
	.byte	'NvM_Prv_ErrorDetection_IsRamBlockAddressValid',0,5,96,16
	.word	294
	.byte	1,1,1,1,6
	.byte	'idService_uo',0,5,96,84
	.word	294
	.byte	6
	.byte	'idBlock_uo',0,5,97,78
	.word	217
	.byte	6
	.byte	'RamBlockAddress_pv',0,5,98,74
	.word	454
	.byte	0,24
	.byte	'__INDIRECT__',0,6,1,1,1,1,1,25,1,9
	.word	2151
	.byte	17
	.byte	'__codeptr',0,6,1,1
	.word	2153
	.byte	4
	.byte	'char',0,1,6,17
	.byte	'sint8',0,7,76,25
	.word	2176
	.byte	17
	.byte	'uint8',0,7,81,25
	.word	294
	.byte	17
	.byte	'uint16',0,7,91,25
	.word	217
	.byte	4
	.byte	'unsigned int',0,4,7,17
	.byte	'uint32',0,7,106,24
	.word	2227
	.byte	4
	.byte	'unsigned long long int',0,8,7,17
	.byte	'uint64',0,7,111,30
	.word	2258
	.byte	17
	.byte	'boolean',0,7,127,25
	.word	294
	.byte	17
	.byte	'StatusType',0,8,191,1,27
	.word	294
	.byte	17
	.byte	'Std_ReturnType',0,8,199,1,15
	.word	294
	.byte	13,8,206,1,9,8,14
	.byte	'vendorID',0
	.word	217
	.byte	2,2,35,0,14
	.byte	'moduleID',0
	.word	217
	.byte	2,2,35,2,14
	.byte	'sw_major_version',0
	.word	294
	.byte	1,2,35,4,14
	.byte	'sw_minor_version',0
	.word	294
	.byte	1,2,35,5,14
	.byte	'sw_patch_version',0
	.word	294
	.byte	1,2,35,6,0,17
	.byte	'Std_VersionInfoType',0,8,213,1,3
	.word	2359
	.byte	17
	.byte	'PduIdType',0,9,22,19
	.word	217
	.byte	17
	.byte	'PduLengthType',0,9,26,19
	.word	217
	.byte	2,10,113,9,4,3
	.byte	'TP_DATACONF',0,0,3
	.byte	'TP_DATARETRY',0,1,3
	.byte	'TP_CONFPENDING',0,2,0,17
	.byte	'TpDataStateType',0,10,118,3
	.word	2549
	.byte	17
	.byte	'Can_IdType',0,11,32,16
	.word	2227
	.byte	17
	.byte	'Can_HwHandleType',0,11,43,16
	.word	217
	.byte	13,12,93,9,8,14
	.byte	'Class',0
	.word	294
	.byte	1,2,35,0,14
	.byte	'TIN',0
	.word	294
	.byte	1,2,35,1,14
	.byte	'ReturnAddress',0
	.word	2227
	.byte	4,2,35,4,0,17
	.byte	'OsTrapInfoType',0,12,97,3
	.word	2669
	.byte	26,68
	.word	2227
	.byte	27,16,0,13,12,154,1,9,68,14
	.byte	'store',0
	.word	2749
	.byte	68,2,35,0,0,26,68
	.word	2758
	.byte	27,0,0,17
	.byte	'Os_JumpBufType',0,12,156,1,3
	.word	2780
	.byte	17
	.byte	'Os_StackTraceType',0,12,174,1,18
	.word	2227
	.byte	13,12,175,1,9,8,14
	.byte	'sp',0
	.word	2227
	.byte	4,2,35,0,14
	.byte	'ctx',0
	.word	2227
	.byte	4,2,35,4,0,17
	.byte	'Os_StackValueType',0,12,175,1,63
	.word	2840
	.byte	17
	.byte	'Os_StackSizeType',0,12,176,1,27
	.word	2840
	.byte	28,1,1,9
	.word	2925
	.byte	17
	.byte	'Os_VoidVoidFunctionType',0,12,179,1,16
	.word	2928
	.byte	17
	.byte	'ApplicationType',0,12,193,1,23
	.word	294
	.byte	29
	.byte	'Os_ApplicationConfigurationType_s',0,12,198,1,16,2,14
	.byte	'app_id',0
	.word	294
	.byte	1,2,35,0,14
	.byte	'access',0
	.word	294
	.byte	1,2,35,1,0,17
	.byte	'Os_ApplicationConfigurationType',0,12,201,1,3
	.word	2991
	.byte	17
	.byte	'Os_CoreStateType',0,12,203,1,16
	.word	2227
	.byte	17
	.byte	'AreaIdType',0,12,204,1,16
	.word	217
	.byte	17
	.byte	'Os_PeripheralAddressType',0,12,212,1,22
	.word	2227
	.byte	17
	.byte	'TickType',0,12,221,1,22
	.word	2227
	.byte	17
	.byte	'Os_StopwatchTickType',0,12,225,1,22
	.word	2227
	.byte	9
	.word	2227
	.byte	17
	.byte	'Os_Lockable',0,12,234,1,18
	.word	3233
	.byte	17
	.byte	'CoreIdType',0,12,236,1,16
	.word	217
	.byte	17
	.byte	'SpinlockIdType',0,12,237,1,16
	.word	217
	.byte	2,12,239,1,9,4,3
	.byte	'TRYTOGETSPINLOCK_SUCCESS',0,0,3
	.byte	'TRYTOGETSPINLOCK_NOSUCCESS',0,1,0,17
	.byte	'TryToGetSpinlockType',0,12,239,1,74
	.word	3303
	.byte	2,12,174,2,9,4,3
	.byte	'APPLICATION_ACCESSIBLE',0,0,3
	.byte	'APPLICATION_RESTARTING',0,1,3
	.byte	'APPLICATION_TERMINATED',0,2,0,17
	.byte	'ApplicationStateType',0,12,174,2,92
	.word	3396
	.byte	18,1,1,16
	.word	294
	.byte	16
	.word	382
	.byte	0,9
	.word	3508
	.byte	17
	.byte	'Os_FunctionEntryType',0,12,183,2,16
	.word	3522
	.byte	29
	.byte	'Os_MeterInfoType_s',0,12,193,2,16,48,14
	.byte	'elapsed',0
	.word	2227
	.byte	4,2,35,0,14
	.byte	'previous',0
	.word	2227
	.byte	4,2,35,4,14
	.byte	'max',0
	.word	2227
	.byte	4,2,35,8,14
	.byte	'cumulative',0
	.word	2227
	.byte	4,2,35,12,14
	.byte	'stackbase',0
	.word	2840
	.byte	8,2,35,16,14
	.byte	'stackusage',0
	.word	2840
	.byte	8,2,35,24,14
	.byte	'stackmax',0
	.word	2840
	.byte	8,2,35,32,14
	.byte	'stackbudget',0
	.word	2840
	.byte	8,2,35,40,0,17
	.byte	'Os_MeterInfoType',0,12,202,2,3
	.word	3557
	.byte	9
	.word	3557
	.byte	17
	.byte	'Os_MeterInfoRefType',0,12,203,2,50
	.word	3755
	.byte	17
	.byte	'EventMaskType',0,12,206,2,15
	.word	294
	.byte	17
	.byte	'Os_imaskType',0,12,211,2,16
	.word	2227
	.byte	29
	.byte	'Os_ISRDynType_s',0,12,213,2,16,48,14
	.byte	'meter',0
	.word	3557
	.byte	48,2,35,0,0,17
	.byte	'Os_ISRDynType',0,12,215,2,3
	.word	3834
	.byte	9
	.word	3834
	.byte	10
	.word	3895
	.byte	29
	.byte	'Os_ISRType_s',0,12,216,2,16,24,14
	.byte	'entry_function',0
	.word	2933
	.byte	4,2,35,0,14
	.byte	'dynamic',0
	.word	3900
	.byte	4,2,35,4,14
	.byte	'imask',0
	.word	2227
	.byte	4,2,35,8,14
	.byte	'stackbudget',0
	.word	2840
	.byte	8,2,35,12,14
	.byte	'access',0
	.word	294
	.byte	1,2,35,20,14
	.byte	'application',0
	.word	294
	.byte	1,2,35,21,0,17
	.byte	'Os_ISRType',0,12,223,2,3
	.word	3905
	.byte	9
	.word	2925
	.byte	10
	.word	3905
	.byte	9
	.word	4064
	.byte	17
	.byte	'ISRType',0,12,224,2,46
	.word	4069
	.byte	17
	.byte	'Os_bitmask',0,12,239,2,22
	.word	2227
	.byte	17
	.byte	'Os_pset0Type',0,12,240,2,20
	.word	2227
	.byte	17
	.byte	'Os_pset1Type',0,12,241,2,20
	.word	2227
	.byte	17
	.byte	'Os_pset2Type',0,12,242,2,20
	.word	2227
	.byte	30,12,243,2,9,4,14
	.byte	'p0',0
	.word	2227
	.byte	4,2,35,0,14
	.byte	'p1',0
	.word	2227
	.byte	4,2,35,0,14
	.byte	'p2',0
	.word	2227
	.byte	4,2,35,0,0,17
	.byte	'Os_psetType',0,12,247,2,3
	.word	4177
	.byte	30,12,249,2,9,4,14
	.byte	't0',0
	.word	2227
	.byte	4,2,35,0,14
	.byte	't1',0
	.word	2227
	.byte	4,2,35,0,14
	.byte	't2',0
	.word	2227
	.byte	4,2,35,0,0,17
	.byte	'Os_tpmaskType',0,12,253,2,3
	.word	4241
	.byte	17
	.byte	'Os_ActivationCountType',0,12,254,2,23
	.word	294
	.byte	29
	.byte	'Os_TaskDynType_s',0,12,128,3,16,120,14
	.byte	'terminate_jump_buf',0
	.word	2789
	.byte	68,2,35,0,14
	.byte	'meter',0
	.word	3557
	.byte	48,2,35,68,14
	.byte	'activation_count',0
	.word	294
	.byte	1,2,35,116,0,17
	.byte	'Os_TaskDynType',0,12,132,3,3
	.word	4339
	.byte	26,68
	.word	2758
	.byte	27,0,0,9
	.word	4339
	.byte	10
	.word	4465
	.byte	29
	.byte	'Os_TaskType_s',0,12,134,3,16,40,14
	.byte	'dynamic',0
	.word	4470
	.byte	4,2,35,0,14
	.byte	'entry_function',0
	.word	2933
	.byte	4,2,35,4,14
	.byte	'pset',0
	.word	4177
	.byte	4,2,35,8,14
	.byte	'base_tpmask',0
	.word	4241
	.byte	4,2,35,12,14
	.byte	'tpmask',0
	.word	4241
	.byte	4,2,35,16,14
	.byte	'core_id',0
	.word	217
	.byte	2,2,35,20,14
	.byte	'index',0
	.word	2227
	.byte	4,2,35,24,14
	.byte	'stackbudget',0
	.word	2840
	.byte	8,2,35,28,14
	.byte	'activation_count',0
	.word	294
	.byte	1,2,35,36,14
	.byte	'access',0
	.word	294
	.byte	1,2,35,37,14
	.byte	'application',0
	.word	294
	.byte	1,2,35,38,0,17
	.byte	'Os_TaskType',0,12,146,3,3
	.word	4475
	.byte	10
	.word	4475
	.byte	9
	.word	4725
	.byte	17
	.byte	'TaskType',0,12,147,3,47
	.word	4730
	.byte	31
	.byte	'Os_TaskStateType',0,12,155,3,6,4,3
	.byte	'SUSPENDED',0,0,3
	.byte	'READY',0,1,3
	.byte	'WAITING',0,2,3
	.byte	'RUNNING',0,3,0,17
	.byte	'TaskStateType',0,12,156,3,31
	.word	4753
	.byte	30,12,167,3,3,4,14
	.byte	'tpmask',0
	.word	4241
	.byte	4,2,35,0,0,29
	.byte	'Os_ResourceDynType_s',0,12,166,3,16,4,14
	.byte	'saved_priority',0
	.word	4840
	.byte	4,2,35,0,0,17
	.byte	'Os_ResourceDynType',0,12,170,3,3
	.word	4863
	.byte	9
	.word	4863
	.byte	10
	.word	4943
	.byte	29
	.byte	'Os_ResourceType_s',0,12,171,3,16,12,14
	.byte	'dynamic',0
	.word	4948
	.byte	4,2,35,0,14
	.byte	'tpmask',0
	.word	4241
	.byte	4,2,35,4,14
	.byte	'access',0
	.word	294
	.byte	1,2,35,8,0,17
	.byte	'Os_ResourceType',0,12,175,3,3
	.word	4953
	.byte	13,12,181,3,9,12,14
	.byte	'maxallowedvalue',0
	.word	2227
	.byte	4,2,35,0,14
	.byte	'ticksperbase',0
	.word	2227
	.byte	4,2,35,4,14
	.byte	'mincycle',0
	.word	2227
	.byte	4,2,35,8,0,17
	.byte	'AlarmBaseType',0,12,185,3,3
	.word	5052
	.byte	13,12,206,3,9,8,14
	.byte	'Running',0
	.word	294
	.byte	1,2,35,0,14
	.byte	'Pending',0
	.word	294
	.byte	1,2,35,1,14
	.byte	'Delay',0
	.word	2227
	.byte	4,2,35,4,0,17
	.byte	'Os_CounterStatusType',0,12,210,3,3
	.word	5147
	.byte	32
	.word	294
	.byte	1,1,9
	.word	5233
	.byte	17
	.byte	'Os_CounterIncrAdvType',0,12,217,3,22
	.word	5240
	.byte	29
	.byte	's_swd',0,12,222,3,12,4,14
	.byte	'count',0
	.word	2227
	.byte	4,2,35,0,0,30,12,221,3,3,4,14
	.byte	'sw',0
	.word	5276
	.byte	4,2,35,0,0,29
	.byte	'Os_CounterDynType_s',0,12,220,3,16,4,14
	.byte	'type_dependent',0
	.word	5304
	.byte	4,2,35,0,0,17
	.byte	'Os_CounterDynType',0,12,226,3,3
	.word	5323
	.byte	9
	.word	5323
	.byte	10
	.word	5401
	.byte	29
	.byte	'Os_CounterType_s',0,12,227,3,16,28,14
	.byte	'dynamic',0
	.word	5406
	.byte	4,2,35,0,14
	.byte	'advincr',0
	.word	5245
	.byte	4,2,35,4,14
	.byte	'base',0
	.word	5052
	.byte	12,2,35,8,14
	.byte	'core',0
	.word	382
	.byte	4,2,35,20,14
	.byte	'access',0
	.word	294
	.byte	1,2,35,24,14
	.byte	'application',0
	.word	294
	.byte	1,2,35,25,0,17
	.byte	'Os_CounterType',0,12,234,3,3
	.word	5411
	.byte	9
	.word	5233
	.byte	10
	.word	5411
	.byte	9
	.word	5563
	.byte	17
	.byte	'CounterType',0,12,235,3,52
	.word	5568
	.byte	31
	.byte	'Os_ScheduleTableStatusType',0,12,240,3,6,4,3
	.byte	'SCHEDULETABLE_STOPPED',0,0,3
	.byte	'SCHEDULETABLE_NEXT',0,1,3
	.byte	'SCHEDULETABLE_WAITING',0,2,3
	.byte	'SCHEDULETABLE_RUNNING',0,3,3
	.byte	'SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS',0,4,0,17
	.byte	'ScheduleTableStatusType',0,12,241,3,41
	.word	5594
	.byte	10
	.word	.L152-.L30
	.byte	9
	.word	5794
	.byte	17
	.byte	'ScheduleTableType',0,12,128,4,58
	.word	5799
	.byte	29
	.byte	'Os_ScheduleTableDynType_s',0,12,130,4,16,16,14
	.byte	'match',0
	.word	2227
	.byte	4,2,35,0,14
	.byte	'next',0
	.word	5804
	.byte	4,2,35,4,14
	.byte	'state',0
	.word	5594
	.byte	4,2,35,8,14
	.byte	'config',0
	.word	217
	.byte	2,2,35,12,0,9
	.word	5831
	.byte	10
	.word	5924
.L152:
	.byte	29
	.byte	'Os_ScheduleTableType_s',0,12,247,3,16,16,14
	.byte	'dynamic',0
	.word	5929
	.byte	4,2,35,0,14
	.byte	'counter',0
	.word	5573
	.byte	4,2,35,4,14
	.byte	'repeat',0
	.word	294
	.byte	1,2,35,8,14
	.byte	'config',0
	.word	217
	.byte	2,2,35,10,14
	.byte	'initial',0
	.word	294
	.byte	1,2,35,12,14
	.byte	'access',0
	.word	294
	.byte	1,2,35,13,14
	.byte	'application',0
	.word	294
	.byte	1,2,35,14,0,17
	.byte	'Os_ScheduleTableType',0,12,255,3,3
	.word	5934
	.byte	10
	.word	5934
	.byte	9
	.word	6114
	.byte	10
	.word	5411
	.byte	9
	.word	6124
	.byte	33
	.word	3238
	.byte	33
	.word	4177
	.byte	33
	.word	4074
	.byte	33
	.word	4735
	.byte	33
	.word	4241
	.byte	33
	.word	294
	.byte	33
	.word	4735
	.byte	29
	.byte	'Os_ControlledCoreType_s',0,12,251,6,16,112,14
	.byte	'TrapInfo',0
	.word	2669
	.byte	8,2,35,0,14
	.byte	'lock_taskaccess',0
	.word	6134
	.byte	4,2,35,8,14
	.byte	'ReadyTasks',0
	.word	6139
	.byte	4,2,35,12,14
	.byte	'RunningISR',0
	.word	6144
	.byte	4,2,35,16,14
	.byte	'RunningTask',0
	.word	6149
	.byte	4,2,35,20,14
	.byte	'RunningTPMask',0
	.word	6154
	.byte	4,2,35,24,14
	.byte	'CurrentMeteredObject',0
	.word	3760
	.byte	4,2,35,28,14
	.byte	'IdleMeter',0
	.word	3557
	.byte	48,2,35,32,14
	.byte	'AppAccess',0
	.word	294
	.byte	1,2,35,80,14
	.byte	'AppOverride',0
	.word	6159
	.byte	1,2,35,81,14
	.byte	'GetStackValueAdjust',0
	.word	2840
	.byte	8,2,35,84,14
	.byte	'InErrorHook',0
	.word	294
	.byte	1,2,35,92,14
	.byte	'ChainTaskRef',0
	.word	6164
	.byte	4,2,35,96,14
	.byte	'GetStackUsageAdjust',0
	.word	2840
	.byte	8,2,35,100,14
	.byte	'InProtectionHook',0
	.word	294
	.byte	1,2,35,108,14
	.byte	'CoreIsActive',0
	.word	294
	.byte	1,2,35,109,14
	.byte	'InShutdownHook',0
	.word	294
	.byte	1,2,35,110,0,17
	.byte	'Os_ControlledCoreType',0,12,141,7,3
	.word	6169
	.byte	9
	.word	2227
	.byte	10
	.word	3905
	.byte	9
	.word	6625
	.byte	10
	.word	4475
	.byte	9
	.word	6635
	.byte	9
	.word	3557
	.byte	29
	.byte	'Os_AnyCoreType_s',0,12,151,7,16,96,14
	.byte	'DisableAllImask',0
	.word	2227
	.byte	4,2,35,0,14
	.byte	'SuspendAllImask',0
	.word	2227
	.byte	4,2,35,4,14
	.byte	'SuspendOSImask',0
	.word	2227
	.byte	4,2,35,8,14
	.byte	'DisableAllCount',0
	.word	2227
	.byte	4,2,35,12,14
	.byte	'SuspendAllCount',0
	.word	2227
	.byte	4,2,35,16,14
	.byte	'SuspendOSCount',0
	.word	2227
	.byte	4,2,35,20,14
	.byte	'RestartJumpBuf',0
	.word	2789
	.byte	68,2,35,24,14
	.byte	'Restartable',0
	.word	294
	.byte	1,2,35,92,0,17
	.byte	'Os_AnyCoreType',0,12,160,7,3
	.word	6650
	.byte	17
	.byte	'Can_TxObjPriorityClassType',0,13,219,3,16
	.word	2227
	.byte	29
	.byte	'Can_TxHwObjectConfigType',0,13,231,3,16,8,14
	.byte	'MsgObjId',0
	.word	294
	.byte	1,2,35,0,14
	.byte	'HwControllerId',0
	.word	294
	.byte	1,2,35,1,14
	.byte	'TxObjPriorityClass',0
	.word	2227
	.byte	4,2,35,4,0,17
	.byte	'Can_TxHwObjectConfigType',0,13,252,3,3
	.word	6927
	.byte	29
	.byte	'Can_RxHwObjectConfigType',0,13,129,4,16,12,14
	.byte	'MaskRef',0
	.word	2227
	.byte	4,2,35,0,14
	.byte	'MsgId',0
	.word	2227
	.byte	4,2,35,4,14
	.byte	'MsgObjId',0
	.word	294
	.byte	1,2,35,8,14
	.byte	'HwControllerId',0
	.word	294
	.byte	1,2,35,9,0,17
	.byte	'Can_RxHwObjectConfigType',0,13,147,4,3
	.word	7063
	.byte	26,4
	.word	294
	.byte	27,3,0,29
	.byte	'Can_ControllerMOMapConfigType',0,13,181,4,16,4,14
	.byte	'ControllerMOMap',0
	.word	7203
	.byte	4,2,35,0,0,17
	.byte	'Can_ControllerMOMapConfigType',0,13,184,4,3
	.word	7212
	.byte	29
	.byte	'Can_NPCRValueType',0,13,188,4,16,2,14
	.byte	'Can_NPCRValue',0
	.word	217
	.byte	2,2,35,0,0,17
	.byte	'Can_NPCRValueType',0,13,191,4,3
	.word	7313
	.byte	29
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,13,194,4,16,8,14
	.byte	'CanControllerBaudrate',0
	.word	2227
	.byte	4,2,35,0,14
	.byte	'CanControllerBaudrateCfg',0
	.word	217
	.byte	2,2,35,4,0,17
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,13,198,4,3
	.word	7388
	.byte	10
	.word	7388
	.byte	9
	.word	7553
	.byte	29
	.byte	'Can_BaudrateConfigPtrType',0,13,201,4,16,4,14
	.byte	'Can_kBaudrateConfigPtr',0
	.word	7558
	.byte	4,2,35,0,0,17
	.byte	'Can_BaudrateConfigPtrType',0,13,204,4,3
	.word	7563
	.byte	29
	.byte	'Can_EventHandlingType',0,13,226,4,16,4,14
	.byte	'CanEventType',0
	.word	7203
	.byte	4,2,35,0,0,17
	.byte	'Can_EventHandlingType',0,13,229,4,3
	.word	7663
	.byte	17
	.byte	'Rte_TransformerErrorCode',0,14,130,1,15
	.word	294
	.byte	17
	.byte	'Rte_TransformerClass',0,14,131,1,15
	.word	294
	.byte	13,14,168,1,9,12,14
	.byte	'in',0
	.word	382
	.byte	4,2,35,0,14
	.byte	'out',0
	.word	382
	.byte	4,2,35,4,14
	.byte	'used',0
	.word	217
	.byte	2,2,35,8,14
	.byte	'lost_data',0
	.word	294
	.byte	1,2,35,10,0,17
	.byte	'Rte_QDynType',0,14,173,1,3
	.word	7809
	.byte	2,14,175,1,9,4,3
	.byte	'RTE_DRA',0,0,3
	.byte	'RTE_WOWP',0,1,3
	.byte	'RTE_TASK',0,2,3
	.byte	'RTE_ARE',0,3,3
	.byte	'RTE_EV',0,4,3
	.byte	'RTE_MSI',0,5,0,17
	.byte	'Rte_NotificationType',0,14,182,1,3
	.word	7896
	.byte	9
	.word	7809
	.byte	29
	.byte	'Rte_QCmnType',0,14,184,1,16,24,14
	.byte	'dynamic',0
	.word	7994
	.byte	4,2,35,0,14
	.byte	'copy',0
	.word	294
	.byte	1,2,35,4,14
	.byte	'queue_size',0
	.word	217
	.byte	2,2,35,6,14
	.byte	'element_size',0
	.word	217
	.byte	2,2,35,8,14
	.byte	'buffer_start',0
	.word	382
	.byte	4,2,35,12,14
	.byte	'buffer_end',0
	.word	382
	.byte	4,2,35,16,14
	.byte	'notification_type',0
	.word	7896
	.byte	4,2,35,20,0,17
	.byte	'Rte_QCmnType',0,14,192,1,3
	.word	7999
	.byte	17
	.byte	'Rte_AlarmRefType',0,14,224,1,32
	.word	2227
	.byte	17
	.byte	'Rte_AlarmIndexType',0,14,226,1,32
	.word	217
	.byte	26,128,8
	.word	294
	.byte	27,255,7,0,17
	.byte	'Impl_NVM_DstPtrType_1024',0,15,50,15
	.word	8237
	.byte	17
	.byte	'CanIf_u32_impl',0,15,69,16
	.word	2227
	.byte	17
	.byte	'CanIf_u16_impl',0,15,71,16
	.word	217
	.byte	17
	.byte	'CanIf_u8_impl',0,15,73,15
	.word	294
	.byte	17
	.byte	'CanIf_ControllerModeType_Enum_impl',0,15,88,15
	.word	294
	.byte	17
	.byte	'CanIf_PduModeType_Enum_impl',0,15,90,15
	.word	294
	.byte	13,15,92,9,2,14
	.byte	'DeviceMode',0
	.word	294
	.byte	1,2,35,0,14
	.byte	'ChannelMode',0
	.word	294
	.byte	1,2,35,1,0,17
	.byte	'CanIf_ControllerStateType_struct_impl',0,15,95,3
	.word	8428
	.byte	17
	.byte	'CanIf_NotifStatusType_Enum_impl',0,15,100,15
	.word	294
	.byte	17
	.byte	'CanSM_boolean_Impl',0,15,120,15
	.word	294
	.byte	17
	.byte	'CanSM_u8_Impl',0,15,123,15
	.word	294
	.byte	17
	.byte	'CanSM_BusOffRecoveryStateType_Enum_impl',0,15,128,1,15
	.word	294
	.byte	17
	.byte	'CanSM_NetworkModeStateType_Enum_impl',0,15,132,1,15
	.word	294
	.byte	17
	.byte	'CanSM_u16_Impl',0,15,136,1,16
	.word	217
	.byte	17
	.byte	'CanSM_TimerStateType_Enum_impl',0,15,138,1,15
	.word	294
	.byte	13,15,140,1,9,4,14
	.byte	'cntTick_u16',0
	.word	217
	.byte	2,2,35,0,14
	.byte	'stTimer',0
	.word	294
	.byte	1,2,35,2,0,17
	.byte	'CanSM_TimerConfig_tst_struct_impl',0,15,143,1,3
	.word	8769
	.byte	17
	.byte	'Com_impl_u16',0,15,154,1,16
	.word	217
	.byte	17
	.byte	'Com_impl_u8',0,15,157,1,15
	.word	294
	.byte	17
	.byte	'ComM_uint32_Impl',0,15,173,1,16
	.word	2227
	.byte	17
	.byte	'ComM_uint16_Impl',0,15,175,1,16
	.word	217
	.byte	17
	.byte	'ComM_uint8_Impl',0,15,177,1,15
	.word	294
	.byte	17
	.byte	'ComM_bool_Impl',0,15,179,1,15
	.word	294
	.byte	13,15,181,1,9,24,14
	.byte	'ChannelState_e',0
	.word	2227
	.byte	4,2,35,0,14
	.byte	'LightTimeoutCtr_u32',0
	.word	2227
	.byte	4,2,35,4,14
	.byte	'MinFullComTimeoutCtr_u16',0
	.word	217
	.byte	2,2,35,8,14
	.byte	'ChannelMode_u8',0
	.word	294
	.byte	1,2,35,10,14
	.byte	'BusSmMode_u8',0
	.word	294
	.byte	1,2,35,11,14
	.byte	'UserRequestCtr_u8',0
	.word	294
	.byte	1,2,35,12,14
	.byte	'PassiveRequestState_u8',0
	.word	294
	.byte	1,2,35,13,14
	.byte	'PncRequestCtr_u8',0
	.word	294
	.byte	1,2,35,14,14
	.byte	'InhibitionReqStatus_u8',0
	.word	294
	.byte	1,2,35,15,14
	.byte	'NmNetworkRequestStatus_b',0
	.word	294
	.byte	1,2,35,16,14
	.byte	'DiagnosticRequestState_b',0
	.word	294
	.byte	1,2,35,17,14
	.byte	'CommunicationAllowed_b',0
	.word	294
	.byte	1,2,35,18,14
	.byte	'NmBusSleepIndicationStatus_b',0
	.word	294
	.byte	1,2,35,19,14
	.byte	'NmPrepareBusSleepIndicationStatus_b',0
	.word	294
	.byte	1,2,35,20,14
	.byte	'NmNetworkModeStatus_b',0
	.word	294
	.byte	1,2,35,21,0,17
	.byte	'ComM_ChannelStruct_Impl',0,15,197,1,3
	.word	9001
	.byte	13,15,206,1,9,10,14
	.byte	'WakeUpInhibitionCtr_u16',0
	.word	217
	.byte	2,2,35,0,14
	.byte	'LimitToNoComCtr_u16',0
	.word	217
	.byte	2,2,35,2,14
	.byte	'RequestedUserMode_t',0
	.word	294
	.byte	1,2,35,4,14
	.byte	'IndicatedUserMode_t',0
	.word	294
	.byte	1,2,35,5,14
	.byte	'numChannelsInFullCom_u8',0
	.word	294
	.byte	1,2,35,6,14
	.byte	'numChannelsInSilentCom_u8',0
	.word	294
	.byte	1,2,35,7,14
	.byte	'numChannelsInNoCom_u8',0
	.word	294
	.byte	1,2,35,8,0,17
	.byte	'ComM_UserStruct_Impl',0,15,214,1,3
	.word	9505
	.byte	17
	.byte	'Dcm_IOOperationResponseType',0,15,252,1,15
	.word	294
	.byte	17
	.byte	'Dcm_RequestDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspRequestRoutineResultsOutSignal_0PrimitivType',0
	.byte	15,138,2,15
	.word	294
	.byte	17
	.byte	'Dcm_StartDataIn_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineInSignalPrimitivType',0,15,146,2,15
	.word	294
	.byte	17
	.byte	'Dcm_StartDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineOutSignalPrimitivType',0,15,150,2,15
	.word	294
	.byte	17
	.byte	'Dcm_StopDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStopRoutineOutSignalPrimitivType',0,15,154,2,15
	.word	294
	.byte	17
	.byte	'NvM_BlockIdType',0,15,215,2,16
	.word	217
	.byte	17
	.byte	'NvM_RequestResultType',0,15,225,2,15
	.word	294
	.byte	17
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockNative_1024_Type',0,15,243,3,34
	.word	8248
	.byte	26,128,8
	.word	294
	.byte	27,255,7,0,17
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockRedundant_1024_Type',0,15,246,3,34
	.word	8248
	.byte	2,16,31,9,4,3
	.byte	'MEMIF_JOB_OK',0,0,3
	.byte	'MEMIF_JOB_FAILED',0,1,3
	.byte	'MEMIF_JOB_PENDING',0,2,3
	.byte	'MEMIF_JOB_CANCELED',0,3,3
	.byte	'MEMIF_BLOCK_INCONSISTENT',0,4,3
	.byte	'MEMIF_BLOCK_INVALID',0,5,0,17
	.byte	'MemIf_JobResultType',0,16,39,2
	.word	10379
	.byte	17
	.byte	'NvM_BlockManagementType',0,2,45,3
	.word	150
	.byte	2,2,49,9,4,3
	.byte	'NVM_PRV_ACTIVITY_NOT_INIT',0,0,3
	.byte	'NVM_PRV_ACTIVITY_IDLE',0,1,3
	.byte	'NVM_PRV_ACTIVITY_ARBITRATE',0,2,3
	.byte	'NVM_PRV_ACTIVITY_JOB_START',0,3,3
	.byte	'NVM_PRV_ACTIVITY_POLL_RESULT',0,4,3
	.byte	'NVM_PRV_ACTIVITY_JOB_COMPLETE',0,5,3
	.byte	'NVM_PRV_ACTIVITY_RESULT_EVAL',0,6,0,17
	.byte	'NvM_Prv_Activities_ten',0,2,58,3
	.word	10569
	.byte	2,2,104,9,4,3
	.byte	'NvM_Prv_idJob_Idle_e',0,0,3
	.byte	'NvM_Prv_idJob_Read_e',0,1,3
	.byte	'NvM_Prv_idJob_Write_e',0,2,3
	.byte	'NvM_Prv_idJob_Erase_e',0,3,3
	.byte	'NvM_Prv_idJob_Restore_e',0,4,3
	.byte	'NvM_Prv_idJob_Maintain_e',0,5,3
	.byte	'NvM_Prv_idJob_Validate_e',0,6,3
	.byte	'NvM_Prv_idJob_Invalidate_e',0,7,3
	.byte	'NvM_Prv_idJob_ReadIdConfigForReadAll_e',0,8,3
	.byte	'NvM_Prv_idJob_InvalidateForFirstInitAll_e',0,9,3
	.byte	'NvM_Prv_idJob_RestoreForImplicitRecovery_e',0,10,3
	.byte	'NvM_Prv_idJob_InvalidateForRemoveNonResistant_e',0,11,3
	.byte	'NvM_Prv_idJob_Invalid_e',0,12,3
	.byte	'NvM_Prv_idJob_Count_e',0,13,0,17
	.byte	'NvM_Prv_idJob_ten',0,2,115,3
	.word	10810
	.byte	17
	.byte	'NvM_Prv_ServiceBit_tuo',0,2,168,1,16
	.word	217
	.byte	17
	.byte	'NvM_Prv_idService_tuo',0,2,173,1,15
	.word	294
	.byte	17
	.byte	'NvM_Prv_idQueue_tuo',0,2,206,1,15
	.word	294
	.byte	17
	.byte	'NvM_Prv_QueueEntry_tst',0,2,225,1,3
	.word	1007
	.byte	9
	.word	294
	.byte	13,2,227,1,9,20,14
	.byte	'idJob_en',0
	.word	10810
	.byte	4,2,35,0,14
	.byte	'idBlock_uo',0
	.word	217
	.byte	2,2,35,4,14
	.byte	'RamBlock_pu8',0
	.word	11399
	.byte	4,2,35,8,14
	.byte	'idxDataset_u8',0
	.word	294
	.byte	1,2,35,12,14
	.byte	'Result_en',0
	.word	10379
	.byte	4,2,35,16,0,17
	.byte	'NvM_Prv_JobData_tst',0,2,240,1,3
	.word	11404
	.byte	17
	.byte	'Rte_TaskRefType',0,17,184,1,32
	.word	4735
	.byte	17
	.byte	'Rte_EventRefType',0,17,185,1,32
	.word	294
	.byte	17
	.byte	'Rte_EventType',0,17,186,1,32
	.word	2227
	.byte	17
	.byte	'Rte_REActCounterType',0,17,252,1,15
	.word	294
	.byte	9
	.word	294
	.byte	17
	.byte	'Rte_REActCounterRefType',0,17,253,1,58
	.word	11646
	.byte	13,17,255,1,9,8,14
	.byte	'task',0
	.word	11542
	.byte	4,2,35,0,14
	.byte	'acnt',0
	.word	11651
	.byte	4,2,35,4,0,17
	.byte	'Rte_REContainerType',0,17,130,2,3
	.word	11684
	.byte	10
	.word	4475
	.byte	9
	.word	11748
	.byte	9
	.word	294
	.byte	10
	.word	11684
	.byte	9
	.word	11763
	.byte	17
	.byte	'Rte_REContainerRefType',0,17,132,2,60
	.word	11768
	.byte	17
	.byte	'Rte_MSICounterType',0,17,149,2,16
	.word	217
	.byte	9
	.word	217
	.byte	17
	.byte	'Rte_MSICounterRefType',0,17,150,2,56
	.word	11833
	.byte	17
	.byte	'Rte_MSIPendingFlagType',0,17,152,2,17
	.word	294
	.byte	9
	.word	294
	.byte	17
	.byte	'Rte_MSIPendingFlagRefType',0,17,153,2,60
	.word	11901
	.byte	13,17,163,2,9,24,14
	.byte	'counter',0
	.word	11838
	.byte	4,2,35,0,14
	.byte	'incCounter',0
	.word	294
	.byte	1,2,35,4,14
	.byte	'pending',0
	.word	11906
	.byte	4,2,35,8,14
	.byte	'osTask',0
	.word	11542
	.byte	4,2,35,12,14
	.byte	'acnt',0
	.word	11651
	.byte	4,2,35,16,14
	.byte	'osEvent',0
	.word	294
	.byte	1,2,35,20,14
	.byte	'MSIInit',0
	.word	217
	.byte	2,2,35,22,0,17
	.byte	'Rte_MSITableEntry',0,17,172,2,3
	.word	11941
	.byte	9
	.word	217
	.byte	9
	.word	294
	.byte	17
	.byte	'Rte_TaskArrayIndex',0,17,179,2,16
	.word	294
	.byte	17
	.byte	'Rte_NrWaitingTasks',0,17,180,2,16
	.word	294
	.byte	13,17,182,2,9,4,14
	.byte	'pending',0
	.word	294
	.byte	1,2,35,0,14
	.byte	'count',0
	.word	294
	.byte	1,2,35,1,14
	.byte	'firstWaitingTask',0
	.word	294
	.byte	1,2,35,2,0,17
	.byte	'Rte_WaitableDatum',0,17,186,2,3
	.word	12159
	.byte	9
	.word	12159
	.byte	13,17,226,2,9,12,14
	.byte	'event_id',0
	.word	2227
	.byte	4,2,35,0,14
	.byte	'wd',0
	.word	12251
	.byte	4,2,35,4,14
	.byte	'timeout',0
	.word	2227
	.byte	4,2,35,8,0,17
	.byte	'Rte_WOWP_NotificationType',0,17,230,2,3
	.word	12256
	.byte	10
	.word	12256
	.byte	9
	.word	12345
	.byte	17
	.byte	'Rte_WOWP_NotificationRefType',0,17,232,2,66
	.word	12350
	.byte	17
	.byte	'Rte_ARE_NotificationType',0,17,234,2,29
	.word	11684
	.byte	29
	.byte	'Rte_QTaskType',0,17,243,2,16,28,14
	.byte	'cmn',0
	.word	7999
	.byte	24,2,35,0,14
	.byte	'task',0
	.word	11542
	.byte	4,2,35,24,0,17
	.byte	'Rte_QTaskType',0,17,246,2,3
	.word	12427
	.byte	29
	.byte	'Rte_QREType',0,17,250,2,16,28,14
	.byte	'cmn',0
	.word	7999
	.byte	24,2,35,0,14
	.byte	're',0
	.word	11773
	.byte	4,2,35,24,0,17
	.byte	'Rte_QREType',0,17,253,2,3
	.word	12498
	.byte	10
	.word	11684
	.byte	9
	.word	12563
	.byte	29
	.byte	'Rte_QWWPType',0,17,129,3,16,28,14
	.byte	'cmn',0
	.word	7999
	.byte	24,2,35,0,14
	.byte	'wwp',0
	.word	12355
	.byte	4,2,35,24,0,17
	.byte	'Rte_QWWPType',0,17,132,3,3
	.word	12573
	.byte	10
	.word	12256
	.byte	9
	.word	12641
	.byte	29
	.byte	'Rte_QEvType',0,17,136,3,16,36,14
	.byte	'cmn',0
	.word	7999
	.byte	24,2,35,0,14
	.byte	'task',0
	.word	11542
	.byte	4,2,35,24,14
	.byte	'mask',0
	.word	294
	.byte	1,2,35,28,14
	.byte	'acnt',0
	.word	11651
	.byte	4,2,35,32,0,17
	.byte	'Rte_QEvType',0,17,141,3,3
	.word	12651
	.byte	29
	.byte	'Rte_QMSIType',0,17,145,3,16,48,14
	.byte	'cmn',0
	.word	7999
	.byte	24,2,35,0,14
	.byte	'task',0
	.word	11542
	.byte	4,2,35,24,14
	.byte	'mask',0
	.word	294
	.byte	1,2,35,28,14
	.byte	'acnt',0
	.word	11651
	.byte	4,2,35,32,14
	.byte	'msiCounter',0
	.word	11838
	.byte	4,2,35,36,14
	.byte	'msiPending',0
	.word	11906
	.byte	4,2,35,40,14
	.byte	'msiLimit',0
	.word	217
	.byte	2,2,35,44,0,17
	.byte	'Rte_QMSIType',0,17,153,3,3
	.word	12746
	.byte	17
	.byte	'NvM_Prv_BlockData_tst',0,4,36,3
	.word	1101
	.byte	17
	.byte	'NvM_Prv_Service_Configuration_tst',0,4,49,3
	.word	1405
	.byte	15
	.word	294
	.byte	1,1,16
	.word	382
	.byte	0,9
	.word	12973
	.byte	17
	.byte	'NvM_Prv_ExplicitSync_Copy_tpfct',0,1,29,26
	.word	12986
	.byte	2,1,34,9,4,3
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL',0,1,3
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL',0,2,3
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL',0,4,3
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE',0,8,3
	.byte	'NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED',0,16,3
	.byte	'NVM_PRV_BLOCK_FLAG_WRITE_ONCE',0,32,3
	.byte	'NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW',0,192,0,3
	.byte	'NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM',0,128,1,3
	.byte	'NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION',0,128,2,3
	.byte	'NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH',0,128,4,3
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION',0,128,8,3
	.byte	'NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL',0,128,16,0,17
	.byte	'NvM_Prv_BlockConfiguration_ten',0,1,85,3
	.word	13031
	.byte	10
	.word	217
	.byte	9
	.word	13594
	.byte	10
	.word	382
	.byte	9
	.word	13604
	.byte	15
	.word	294
	.byte	1,1,16
	.word	294
	.byte	16
	.word	294
	.byte	0,9
	.word	13614
	.byte	15
	.word	294
	.byte	1,1,16
	.word	294
	.byte	0,9
	.word	13637
	.byte	9
	.word	5233
	.byte	13,1,121,9,48,14
	.byte	'idBlockMemIf_u16',0
	.word	217
	.byte	2,2,35,0,14
	.byte	'nrBlockBytes_pu16',0
	.word	13599
	.byte	4,2,35,4,14
	.byte	'idxDevice_u8',0
	.word	294
	.byte	1,2,35,8,14
	.byte	'nrNvBlocks_u8',0
	.word	294
	.byte	1,2,35,9,14
	.byte	'nrRomBlocks_u8',0
	.word	294
	.byte	1,2,35,10,14
	.byte	'adrRamBlock_ppv',0
	.word	13609
	.byte	4,2,35,12,14
	.byte	'adrRomBlock_pcv',0
	.word	454
	.byte	4,2,35,16,14
	.byte	'SingleBlockCallback_pfct',0
	.word	13632
	.byte	4,2,35,20,14
	.byte	'SingleBlockStartCallback_pfct',0
	.word	13650
	.byte	4,2,35,24,14
	.byte	'InitBlockCallback_pfct',0
	.word	13655
	.byte	4,2,35,28,14
	.byte	'ReadRamBlockFromNvm_pfct',0
	.word	12986
	.byte	4,2,35,32,14
	.byte	'WriteRamBlockToNvm_pfct',0
	.word	12986
	.byte	4,2,35,36,14
	.byte	'BlockManagementType_en',0
	.word	150
	.byte	4,2,35,40,14
	.byte	'JobPriority_u8',0
	.word	294
	.byte	1,2,35,44,14
	.byte	'stFlags_u16',0
	.word	217
	.byte	2,2,35,46,0,17
	.byte	'NvM_Prv_BlockDescriptor_tst',0,1,138,2,3
	.word	13660
	.byte	26,160,5
	.word	13660
	.byte	27,13,0,10
	.word	14124
	.byte	34
	.byte	'NvM_Prv_BlockDescriptors_acst',0,1,169,2,45
	.word	14134
	.byte	1,1,26,14
	.word	294
	.byte	27,13,0,34
	.byte	'NvM_Prv_stBlock_rAwAM_au8',0,3,59,14
	.word	14180
	.byte	1,1,26,28
	.word	217
	.byte	27,13,0,34
	.byte	'NvM_Prv_stRequests_rAMwAM_au16',0,3,68,15
	.word	14225
	.byte	1,1,26,14
	.word	294
	.byte	27,13,0,34
	.byte	'NvM_Prv_stRequestResult_rAwAM_au8',0,3,77,30
	.word	14275
	.byte	1,1,34
	.byte	'NvM_Prv_idxDataSet_rAMwA_au8',0,3,81,14
	.word	14180
	.byte	1,1,0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L31:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,4,1,58,15,59,15,57,15,11,15,0,0,3,40,0,3,8,28,13,0,0,4
	.byte	36,0,3,8,11,15,62,15,0,0,5,46,1,3,8,32,13,58,15,59,15,57,15,73,19,54,15,39,12,0,0,6,5,0,3,8,58,15,59,15
	.byte	57,15,73,19,0,0,7,11,0,0,0,8,59,0,3,8,0,0,9,15,0,73,19,0,0,10,38,0,73,19,0,0,11,11,1,0,0,12,46,1,3,8,32
	.byte	13,58,15,59,15,57,15,54,15,39,12,0,0,13,19,1,58,15,59,15,57,15,11,15,0,0,14,13,0,3,8,73,19,11,15,56,9
	.byte	0,0,15,21,1,73,19,54,15,39,12,0,0,16,5,0,73,19,0,0,17,22,0,3,8,58,15,59,15,57,15,73,19,0,0,18,21,1,54
	.byte	15,39,12,0,0,19,46,1,3,8,58,15,59,15,57,15,73,19,54,15,39,12,63,12,60,12,0,0,20,46,1,49,19,0,0,21,5,0
	.byte	49,19,0,0,22,29,1,49,19,0,0,23,11,0,49,19,0,0,24,46,0,3,8,58,15,59,15,57,15,54,15,63,12,60,12,0,0,25,21
	.byte	0,54,15,0,0,26,1,1,11,15,73,19,0,0,27,33,0,47,15,0,0,28,21,0,54,15,39,12,0,0,29,19,1,3,8,58,15,59,15,57
	.byte	15,11,15,0,0,30,23,1,58,15,59,15,57,15,11,15,0,0,31,4,1,3,8,58,15,59,15,57,15,11,15,0,0,32,21,0,73,19
	.byte	54,15,39,12,0,0,33,53,0,73,19,0,0,34,52,0,3,8,58,15,59,15,57,15,73,19,63,12,60,12,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L32:
	.word	.L154-.L153
.L153:
	.half	3
	.word	.L156-.L155
.L155:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockDescriptor.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\NvM\\api\\NvM_Types.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockData.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_Service.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_ErrorDetection.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_RestoreBlockDefaults.c',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Platform\\Platform_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Std_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Can_GeneralTypes.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\RTOS_T\\Gen\\inc\\Os.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Can_17_MCanP\\inc\\Can_17_MCanP.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Type.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\MemIf\\api\\MemIf_Types.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Intl.h',0,0,0,0,0
.L156:
.L154:
	.sdecl	'.debug_info',debug,cluster('NvM_RestoreBlockDefaults')
	.sect	'.debug_info'
.L33:
	.word	413
	.half	3
	.word	.L34
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_RestoreBlockDefaults.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L36,.L35
	.byte	2
	.word	.L29
	.byte	3
	.byte	'NvM_RestoreBlockDefaults',0,1,56,16
	.word	.L53
	.byte	1,1,1
	.word	.L22,.L54,.L21
	.byte	4
	.byte	'BlockId',0,1,56,57
	.word	.L55,.L56
	.byte	4
	.byte	'NvM_DstPtr',0,1,56,72
	.word	.L57,.L58
	.byte	5
	.word	.L22,.L54
	.byte	6
	.byte	'stReturn_uo',0,1,62,20
	.word	.L53,.L59
	.byte	6
	.byte	'ServiceConfiguration_st',0,1,63,39
	.word	.L60,.L61
	.byte	6
	.byte	'BlockData_st',0,1,64,27
	.word	.L62,.L63
	.byte	7
	.word	.L64,.L65,.L66
	.byte	8
	.word	.L67,.L68
	.byte	9
	.word	.L69,.L65,.L66
	.byte	6
	.byte	'PRamBlockAddress_pv',0,2,150,4,12
	.word	.L57,.L70
	.byte	0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_RestoreBlockDefaults')
	.sect	'.debug_abbrev'
.L34:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,7,29,1,49,16,17,1,18,1,0,0,8,5,0,49,16,2,6,0,0,9,11,1,49,16,17
	.byte	1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_RestoreBlockDefaults')
	.sect	'.debug_line'
.L35:
	.word	.L158-.L157
.L157:
	.half	3
	.word	.L160-.L159
.L159:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_RestoreBlockDefaults.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockDescriptor.h',0,0,0,0,0
.L160:
	.byte	5,16,7,0,5,2
	.word	.L22
	.byte	3,55,1,5,43,9
	.half	.L136-.L22
	.byte	3,11,1,5,45,9
	.half	.L161-.L136
	.byte	3,1,1,5,47,9
	.half	.L162-.L161
	.byte	3,1,1,5,45,9
	.half	.L163-.L162
	.byte	1,5,48,9
	.half	.L164-.L163
	.byte	3,1,1,5,46,9
	.half	.L165-.L164
	.byte	1,5,30,9
	.half	.L166-.L165
	.byte	3,1,1,5,28,9
	.half	.L167-.L166
	.byte	1,5,34,9
	.half	.L168-.L167
	.byte	3,1,1,5,32,9
	.half	.L169-.L168
	.byte	1,5,40,9
	.half	.L170-.L169
	.byte	3,1,1,5,38,9
	.half	.L171-.L170
	.byte	1,5,40,9
	.half	.L172-.L171
	.byte	3,1,1,5,38,9
	.half	.L173-.L172
	.byte	1,5,9,9
	.half	.L174-.L173
	.byte	3,3,1,5,5,9
	.half	.L175-.L174
	.byte	1,4,2,5,32,7,9
	.half	.L65-.L175
	.byte	3,201,3,1,5,9,9
	.half	.L139-.L65
	.byte	3,1,1,5,51,7,9
	.half	.L176-.L139
	.byte	3,1,1,5,22,9
	.half	.L177-.L176
	.byte	1,5,51,9
	.half	.L178-.L177
	.byte	1,5,63,9
	.half	.L179-.L178
	.byte	1,5,10,9
	.half	.L180-.L179
	.byte	1,5,19,9
	.half	.L138-.L180
	.byte	1,5,31,7,9
	.half	.L181-.L138
	.byte	3,2,1,5,5,9
	.half	.L3-.L181
	.byte	3,3,1,4,1,5,49,9
	.half	.L5-.L3
	.byte	3,179,124,1,5,44,9
	.half	.L66-.L5
	.byte	3,2,1,5,42,9
	.half	.L182-.L66
	.byte	1,5,44,9
	.half	.L183-.L182
	.byte	3,1,1,5,42,9
	.half	.L184-.L183
	.byte	1,5,51,9
	.half	.L2-.L184
	.byte	3,3,1,5,49,9
	.half	.L185-.L2
	.byte	1,5,51,9
	.half	.L186-.L185
	.byte	3,1,1,5,49,9
	.half	.L187-.L186
	.byte	1,5,51,9
	.half	.L188-.L187
	.byte	3,1,1,5,49,9
	.half	.L189-.L188
	.byte	1,9
	.half	.L190-.L189
	.byte	3,1,1,5,47,9
	.half	.L191-.L190
	.byte	1,5,44,9
	.half	.L192-.L191
	.byte	3,5,1,5,45,9
	.half	.L137-.L192
	.byte	3,1,1,9
	.half	.L193-.L137
	.byte	3,1,1,5,5,9
	.half	.L140-.L193
	.byte	3,3,1,5,1,9
	.half	.L6-.L140
	.byte	3,1,1,7,9
	.half	.L37-.L6
	.byte	0,1,1
.L158:
	.sdecl	'.debug_ranges',debug,cluster('NvM_RestoreBlockDefaults')
	.sect	'.debug_ranges'
.L36:
	.word	-1,.L22,0,.L37-.L22,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_Restore_CheckParameter')
	.sect	'.debug_info'
.L38:
	.word	278
	.half	3
	.word	.L39
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_RestoreBlockDefaults.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L41,.L40
	.byte	2
	.word	.L29
	.byte	3
	.byte	'NvM_Prv_Restore_CheckParameter',0,1,102,16
	.word	.L53
	.byte	1,1
	.word	.L24,.L71,.L23
	.byte	4
	.byte	'BlockData_pcst',0,1,102,76
	.word	.L72,.L73
	.byte	5
	.word	.L24,.L71
	.byte	6
	.byte	'isParameterValid_b',0,1,104,13
	.word	.L53,.L74
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_Restore_CheckParameter')
	.sect	'.debug_abbrev'
.L39:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,52,0,3
	.byte	8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_Restore_CheckParameter')
	.sect	'.debug_line'
.L40:
	.word	.L195-.L194
.L194:
	.half	3
	.word	.L197-.L196
.L196:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_RestoreBlockDefaults.c',0,0,0,0,0
.L197:
	.byte	5,16,7,0,5,2
	.word	.L24
	.byte	3,229,0,1,5,32,9
	.half	.L142-.L24
	.byte	3,2,1,5,84,9
	.half	.L143-.L142
	.byte	3,5,1,9
	.half	.L198-.L143
	.byte	3,1,1,9
	.half	.L199-.L198
	.byte	3,1,1,5,5,9
	.half	.L200-.L199
	.byte	3,126,1,5,88,7,9
	.half	.L201-.L200
	.byte	3,6,1,9
	.half	.L202-.L201
	.byte	3,1,1,5,32,9
	.half	.L203-.L202
	.byte	3,2,1,5,5,9
	.half	.L7-.L203
	.byte	3,3,1,5,1,9
	.half	.L9-.L7
	.byte	3,1,1,7,9
	.half	.L42-.L9
	.byte	0,1,1
.L195:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_Restore_CheckParameter')
	.sect	'.debug_ranges'
.L41:
	.word	-1,.L24,0,.L42-.L24,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_Restore_CheckBlockData')
	.sect	'.debug_info'
.L43:
	.word	512
	.half	3
	.word	.L44
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_RestoreBlockDefaults.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L46,.L45
	.byte	2
	.word	.L29
	.byte	3
	.byte	'NvM_Prv_Restore_CheckBlockData',0,1,124,16
	.word	.L53
	.byte	1,1
	.word	.L26,.L75,.L25
	.byte	4
	.byte	'BlockData_pcst',0,1,124,76
	.word	.L72,.L76
	.byte	5
	.word	.L26,.L75
	.byte	6
	.word	.L77,.L78,.L79
	.byte	7
	.word	.L80,.L81
	.byte	8
	.word	.L82,.L78,.L79
	.byte	6
	.word	.L83,.L84,.L11
	.byte	7
	.word	.L85,.L86
	.byte	9
	.word	.L87,.L88
	.byte	10
	.byte	'adrRomBlock_pcv',0,2,175,4,17
	.word	.L91,.L92
	.byte	0,0,6
	.word	.L83,.L89,.L90
	.byte	7
	.word	.L85,.L86
	.byte	0,6
	.word	.L93,.L90,.L94
	.byte	7
	.word	.L95,.L96
	.byte	8
	.word	.L97,.L90,.L94
	.byte	10
	.byte	'BlockType',0,2,214,3,29
	.word	.L98,.L99
	.byte	0,0,6
	.word	.L100,.L94,.L17
	.byte	7
	.word	.L101,.L102
	.byte	9
	.word	.L103,.L104
	.byte	10
	.byte	'nrNvBlocks_u8',0,2,234,3,11
	.word	.L53,.L107
	.byte	0,0,6
	.word	.L100,.L105,.L106
	.byte	7
	.word	.L101,.L102
	.byte	0,0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_Restore_CheckBlockData')
	.sect	'.debug_abbrev'
.L44:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,29,1,49
	.byte	16,17,1,18,1,0,0,7,5,0,49,16,2,6,0,0,8,11,1,49,16,17,1,18,1,0,0,9,11,1,49,16,85,6,0,0,10,52,0,3,8,58,15
	.byte	59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_Restore_CheckBlockData')
	.sect	'.debug_line'
.L45:
	.word	.L205-.L204
.L204:
	.half	3
	.word	.L207-.L206
.L206:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_RestoreBlockDefaults.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockDescriptor.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockData.h',0,0,0,0,0
.L207:
	.byte	5,76,7,0,5,2
	.word	.L26
	.byte	3,131,1,1,4,3,5,69,9
	.half	.L78-.L26
	.byte	3,5,1,4,2,5,33,9
	.half	.L84-.L78
	.byte	3,166,3,1,5,5,9
	.half	.L145-.L84
	.byte	3,1,1,5,56,7,9
	.half	.L208-.L145
	.byte	3,2,1,5,27,9
	.half	.L209-.L208
	.byte	1,5,56,9
	.half	.L210-.L209
	.byte	1,5,68,9
	.half	.L211-.L210
	.byte	1,5,5,9
	.half	.L10-.L211
	.byte	3,2,1,4,3,5,14,9
	.half	.L11-.L10
	.byte	3,212,124,1,5,13,9
	.half	.L89-.L11
	.byte	1,4,2,5,39,7,9
	.half	.L90-.L89
	.byte	3,206,2,1,5,5,9
	.half	.L148-.L90
	.byte	3,1,1,5,50,7,9
	.half	.L212-.L148
	.byte	3,2,1,5,21,9
	.half	.L149-.L212
	.byte	1,5,50,9
	.half	.L213-.L149
	.byte	1,5,62,9
	.half	.L214-.L213
	.byte	1,5,5,9
	.half	.L13-.L214
	.byte	3,2,1,4,3,5,32,9
	.half	.L14-.L13
	.byte	3,174,125,1,4,2,5,25,7,9
	.half	.L94-.L14
	.byte	3,225,2,1,5,5,9
	.half	.L150-.L94
	.byte	3,1,1,5,54,7,9
	.half	.L215-.L150
	.byte	3,2,1,5,25,9
	.half	.L151-.L215
	.byte	1,5,54,9
	.half	.L216-.L151
	.byte	1,5,66,9
	.half	.L217-.L216
	.byte	1,5,5,9
	.half	.L16-.L217
	.byte	3,2,1,4,3,5,14,9
	.half	.L17-.L16
	.byte	3,155,125,1,5,42,9
	.half	.L218-.L17
	.byte	1,5,55,9
	.half	.L105-.L218
	.byte	1,5,69,9
	.half	.L106-.L105
	.byte	3,127,1,5,5,9
	.half	.L12-.L106
	.byte	3,127,1,4,1,5,13,9
	.half	.L19-.L12
	.byte	3,124,1,5,5,9
	.half	.L79-.L19
	.byte	1,5,1,9
	.half	.L20-.L79
	.byte	3,1,1,7,9
	.half	.L47-.L20
	.byte	0,1,1
.L205:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_Restore_CheckBlockData')
	.sect	'.debug_ranges'
.L46:
	.word	-1,.L26,0,.L47-.L26,0,0
.L88:
	.word	-1,.L26,.L84-.L26,.L11-.L26,.L89-.L26,.L90-.L26,0,0
.L104:
	.word	-1,.L26,.L94-.L26,.L17-.L26,.L105-.L26,.L106-.L26,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_Restore_SetBlockData')
	.sect	'.debug_info'
.L48:
	.word	387
	.half	3
	.word	.L49
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_RestoreBlockDefaults.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L51,.L50
	.byte	2
	.word	.L29
	.byte	3
	.byte	'NvM_Prv_Restore_SetBlockData',0,1,135,1,13,1,1
	.word	.L28,.L108,.L27
	.byte	4
	.byte	'BlockData_pcst',0,1,135,1,71
	.word	.L72,.L109
	.byte	5
	.word	.L28,.L108
	.byte	6
	.word	.L110,.L111,.L112
	.byte	7
	.word	.L113,.L114
	.byte	7
	.word	.L115,.L116
	.byte	8
	.word	.L117,.L111,.L112
	.byte	0,6
	.word	.L118,.L119,.L120
	.byte	7
	.word	.L121,.L122
	.byte	7
	.word	.L123,.L124
	.byte	8
	.word	.L125,.L119,.L120
	.byte	0,6
	.word	.L126,.L127,.L128
	.byte	7
	.word	.L129,.L130
	.byte	7
	.word	.L131,.L132
	.byte	7
	.word	.L133,.L134
	.byte	8
	.word	.L135,.L127,.L128
	.byte	0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_Restore_SetBlockData')
	.sect	'.debug_abbrev'
.L49:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,29,1,49,16,17
	.byte	1,18,1,0,0,7,5,0,49,16,2,6,0,0,8,11,0,49,16,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_Restore_SetBlockData')
	.sect	'.debug_line'
.L50:
	.word	.L220-.L219
.L219:
	.half	3
	.word	.L222-.L221
.L221:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_RestoreBlockDefaults.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockData.h',0,0,0,0,0
.L222:
	.byte	5,65,7,0,5,2
	.word	.L28
	.byte	3,137,1,1,5,92,9
	.half	.L223-.L28
	.byte	1,4,2,5,5,9
	.half	.L111-.L223
	.byte	3,54,1,5,38,9
	.half	.L224-.L111
	.byte	1,5,51,9
	.half	.L225-.L224
	.byte	1,4,1,5,59,9
	.half	.L112-.L225
	.byte	3,75,1,5,101,9
	.half	.L226-.L112
	.byte	1,4,2,5,5,9
	.half	.L119-.L226
	.byte	3,58,1,5,35,9
	.half	.L227-.L119
	.byte	1,5,52,9
	.half	.L228-.L227
	.byte	1,5,55,9
	.half	.L229-.L228
	.byte	1,5,48,9
	.half	.L230-.L229
	.byte	1,4,1,5,57,9
	.half	.L120-.L230
	.byte	3,71,1,5,42,9
	.half	.L231-.L120
	.byte	3,1,1,9
	.half	.L232-.L231
	.byte	3,1,1,4,2,5,47,9
	.half	.L127-.L232
	.byte	3,200,0,1,5,72,9
	.half	.L233-.L127
	.byte	1,5,88,9
	.half	.L234-.L233
	.byte	1,5,85,9
	.half	.L235-.L234
	.byte	1,5,67,9
	.half	.L236-.L235
	.byte	3,1,1,5,111,9
	.half	.L237-.L236
	.byte	3,127,1,5,43,9
	.half	.L238-.L237
	.byte	1,4,1,5,1,9
	.half	.L128-.L238
	.byte	3,185,127,1,7,9
	.half	.L52-.L128
	.byte	0,1,1
.L220:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_Restore_SetBlockData')
	.sect	'.debug_ranges'
.L51:
	.word	-1,.L28,0,.L52-.L28,0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_Restore_CheckBlockData')
	.sect	'.debug_loc'
.L76:
	.word	-1,.L26,0,.L75-.L26
	.half	1
	.byte	100
	.word	0,0
.L99:
	.word	-1,.L26,.L148-.L26,.L149-.L26
	.half	1
	.byte	95
	.word	.L13-.L26,.L150-.L26
	.half	1
	.byte	95
	.word	0,0
.L25:
	.word	-1,.L26,0,.L75-.L26
	.half	2
	.byte	138,0
	.word	0,0
.L92:
	.word	-1,.L26,.L145-.L26,.L146-.L26
	.half	1
	.byte	111
	.word	.L10-.L26,.L147-.L26
	.half	1
	.byte	111
	.word	0,0
.L81:
	.word	0,0
.L96:
	.word	0,0
.L102:
	.word	0,0
.L86:
	.word	0,0
.L107:
	.word	-1,.L26,.L150-.L26,.L151-.L26
	.half	1
	.byte	95
	.word	.L16-.L26,.L106-.L26
	.half	1
	.byte	95
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_Restore_CheckParameter')
	.sect	'.debug_loc'
.L73:
	.word	-1,.L24,0,.L141-.L24
	.half	1
	.byte	100
	.word	.L142-.L24,.L71-.L24
	.half	1
	.byte	111
	.word	0,0
.L23:
	.word	-1,.L24,0,.L71-.L24
	.half	2
	.byte	138,0
	.word	0,0
.L74:
	.word	-1,.L24,.L143-.L24,.L71-.L24
	.half	1
	.byte	95
	.word	.L144-.L24,.L71-.L24
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_Restore_SetBlockData')
	.sect	'.debug_loc'
.L109:
	.word	-1,.L28,0,.L108-.L28
	.half	1
	.byte	100
	.word	0,0
.L27:
	.word	-1,.L28,0,.L108-.L28
	.half	2
	.byte	138,0
	.word	0,0
.L116:
	.word	0,0
.L124:
	.word	0,0
.L114:
	.word	0,0
.L122:
	.word	0,0
.L130:
	.word	0,0
.L134:
	.word	0,0
.L132:
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_RestoreBlockDefaults')
	.sect	'.debug_loc'
.L63:
	.word	-1,.L22,0,.L54-.L22
	.half	2
	.byte	145,112
	.word	0,0
.L56:
	.word	-1,.L22,0,.L137-.L22
	.half	1
	.byte	84
	.word	0,0
.L58:
	.word	-1,.L22,0,.L138-.L22
	.half	1
	.byte	100
	.word	0,0
.L21:
	.word	-1,.L22,0,.L136-.L22
	.half	2
	.byte	138,0
	.word	.L136-.L22,.L54-.L22
	.half	2
	.byte	138,32
	.word	.L54-.L22,.L54-.L22
	.half	2
	.byte	138,0
	.word	0,0
.L70:
	.word	-1,.L22,.L139-.L22,.L2-.L22
	.half	1
	.byte	98
	.word	0,0
.L61:
	.word	-1,.L22,0,.L54-.L22
	.half	2
	.byte	145,96
	.word	0,0
.L68:
	.word	0,0
.L59:
	.word	-1,.L22,.L140-.L22,.L54-.L22
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_frame',debug
	.sect	'.debug_frame'
.L239:
	.word	48
	.word	-1
	.byte	3,0,2,1,27,12,26,0,8,27,8,26,8,28,8,29,8,30,8,31,8,34,8,35,8,32,8,33,8,16,8,17,8,24,8,25,8,36,8,37,8,38
	.byte	8,39
	.sdecl	'.debug_frame',debug,cluster('NvM_RestoreBlockDefaults')
	.sect	'.debug_frame'
	.word	36
	.word	.L239,.L22,.L54-.L22
	.byte	4
	.word	(.L136-.L22)/2
	.byte	19,32,22,26,3,19,138,32,4
	.word	(.L54-.L136)/2
	.byte	19,0,8,26,0,0
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_Restore_CheckParameter')
	.sect	'.debug_frame'
	.word	12
	.word	.L239,.L24,.L71-.L24
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_Restore_CheckBlockData')
	.sect	'.debug_frame'
	.word	20
	.word	.L239,.L26,.L75-.L26
	.byte	8,19,8,21,8,22,8,23
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_Restore_SetBlockData')
	.sect	'.debug_frame'
	.word	24
	.word	.L239,.L28,.L108-.L28
	.byte	8,18,8,19,8,21,8,22,8,23,0,0

; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   144  
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   145  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_RestoreBlockDefaults.c	   146  #include "NvM_MemMap.h"

	; Module end
