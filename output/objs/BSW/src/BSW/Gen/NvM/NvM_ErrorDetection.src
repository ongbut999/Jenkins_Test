	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 19053136 SN 09001910"
	.compiler_invocation	"ctc -f cc15260a -c99 --integer-enumeration -D__CPU__=tc27x -D__CPU_TC27X__ --core=tc1.6.x --eabi-compliant --fp-model=-float -D_TASKING_C_TRICORE_=1 -I.\\output\\inc -g2 -t4 --language=-comments,-gcc,+volatile,-strings --default-near-size=0 -O2ROPYGKLF-predict --default-a1-size=0 --default-a0-size=0 --source --switch=auto -o output\\objs\\BSW\\src\\BSW\\Gen\\NvM\\NvM_ErrorDetection.src BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c"
	.compiler_name		"ctc"
	;source	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c'

	
$TC16X
	
	.sdecl	'.text.NvM_ErrorDetection.NvM_Rb_GetBlockIdCausingLastDetError',code,cluster('NvM_Rb_GetBlockIdCausingLastDetError')
	.sect	'.text.NvM_ErrorDetection.NvM_Rb_GetBlockIdCausingLastDetError'
	.align	2
	
	.global	NvM_Rb_GetBlockIdCausingLastDetError

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	     2  /*
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	     3   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	     4   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	     5   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	     6   */
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	     7  #include "NvM.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	     8  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	     9  #include "NvM_Prv.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    10  #include "NvM_Prv_BlockData.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    11  #include "NvM_Prv_ErrorDetection.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    13  #if (NVM_DEV_ERROR_DETECT == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    14  // TRACE[NVM556] NvM module shall include Det.h
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    15  # include "Det.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    16  // TRACE[NVM089] Check version compatibility of included header files
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    17  # if (!defined(DET_AR_RELEASE_MAJOR_VERSION) || (DET_AR_RELEASE_MAJOR_VERSION != NVM_AR_RELEASE_MAJOR_VERSION))
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    18  #  error "AUTOSAR major version undefined or mismatched"
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    19  # endif
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    20  #if (!defined(DET_AR_RELEASE_MINOR_VERSION) || ((DET_AR_RELEASE_MINOR_VERSION != 0) && (DET_AR_RELEASE_MINOR_VERSION != 2)))
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    21  #error "AUTOSAR minor version undefined or mismatched"
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    22  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    23  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    25  /*
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    26   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    27   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    28   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    30  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    31  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    33  // Variable saving blocks' errors (useful for debugging)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    34  // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2811] public block specific production error array
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    35  // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2812] public summary variable of all occured production errors (index #0)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    36  uint8 NvM_Rb_stBlockErrors_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    37  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    38  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    39  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    40  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    41  #define NVM_START_SEC_VAR_SAVED_ZONE_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    42  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    43  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    44  // ID of the most previous error reported via Det_ReportError within NvM (initialized to NVM_PRV_NO_DET_ERROR)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    45  NvM_Prv_idDetError_tuo NvM_Prv_idLastDetError_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    46  // ID of the service which triggered the last DET error (initialized to NVM_SERVICE_ID_INIT)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    47  NvM_Prv_idService_tuo NvM_Prv_idServiceLastDetError_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    48  // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3113] Private variable to store block ID used in NvM service
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    49  //                                               which has caused the last DET error
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    50  NvM_BlockIdType NvM_Prv_idBlockLastDetError_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    51  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    52  #define NVM_STOP_SEC_VAR_SAVED_ZONE_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    53  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    54  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    55  /*
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    56   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    57   * NvM-private code
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    58   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    59   */
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    60  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    62  /**
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    63   * This function returns the block ID used in NvM service which has caused the last DET error.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    64   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    65   * Typical use case for this function is to be used as callback within the DET.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    66   * If NvM service which has caused the last DET error does not use any block or no DET error has occured yet,
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    67   * then this function returns 0.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    68   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    69   * \param[global in] NvM_Prv_idBlockCausingLastDetError_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    70   * Global variable to store block ID used in NvM service which has caused the last DET error
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    71   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    72   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    73   * Block identifier used in NvM service which has caused the last DET error.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    74   */
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    75  NvM_BlockIdType NvM_Rb_GetBlockIdCausingLastDetError(void)
; Function NvM_Rb_GetBlockIdCausingLastDetError
.L78:
NvM_Rb_GetBlockIdCausingLastDetError:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    76  {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    77      // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3113] Service to get the block ID used in NvM service
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    78      //                                               which has caused the last DET error
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    79      return (NvM_Prv_idBlockLastDetError_uo);
	movh.a	a15,#@his(NvM_Prv_idBlockLastDetError_uo)
	lea	a15,[a15]@los(NvM_Prv_idBlockLastDetError_uo)
	ld.hu	d2,[a15]0
.L536:
	j	.L2

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    80  }
.L2:
	ret
.L272:
	
__NvM_Rb_GetBlockIdCausingLastDetError_function_end:
	.size	NvM_Rb_GetBlockIdCausingLastDetError,__NvM_Rb_GetBlockIdCausingLastDetError_function_end-NvM_Rb_GetBlockIdCausingLastDetError
.L137:
	; End of function
	
	.sdecl	'.text.NvM_ErrorDetection.NvM_Prv_ReportDetError',code,cluster('NvM_Prv_ReportDetError')
	.sect	'.text.NvM_ErrorDetection.NvM_Prv_ReportDetError'
	.align	2
	

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    81  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    82  /**
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    83   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    84   * This private function reports the passed error to the DET together with the NvM service which has detected
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    85   * this error.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    86   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    87   * Additionally this function stores the reported error and the NvM service to the NvM private variables.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    88   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    89   * \param[in] idService_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    90   * Id of the service which reports an error to the DET.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    91   * \param[in] idError_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    92   * Id of the error which shall be reported to the DET.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    93   */
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    94  // TRACE[NVM191]
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    95  // Development errors shall be reported to the Det_ReportError service
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    96  // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3113]
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    97  // NvM private function to set block ID used in NvM service which has caused the last DET error
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    98  static void NvM_Prv_ReportDetError(NvM_Prv_idService_tuo idService_uo,
; Function NvM_Prv_ReportDetError
.L80:
NvM_Prv_ReportDetError:	.type	func
	mov	d15,d4
.L439:
	mov	e8,d6,d5
.L730:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	    99                                     NvM_Prv_idDetError_tuo idError_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   100                                     NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   101  {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   102      // TRACE[NVM188] If the NvMDevErrorDetect switch is enabled API parameter checking is enabled
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   103  #if (NVM_DEV_ERROR_DETECT == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   104      (void)Det_ReportError(NVM_MODULE_ID, NVM_INSTANCE_ID, idService_uo, idError_uo);
	mov	d4,#20
.L438:
	mov	d5,#0
.L437:
	mov	e6,d8,d15
.L436:
	call	Det_ReportError
.L731:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   105  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   107      NvM_Prv_idServiceLastDetError_uo = idService_uo;
	movh.a	a15,#@his(NvM_Prv_idServiceLastDetError_uo)
	lea	a15,[a15]@los(NvM_Prv_idServiceLastDetError_uo)
.L732:
	st.b	[a15],d15
.L733:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   108      NvM_Prv_idLastDetError_uo = idError_uo;
	movh.a	a15,#@his(NvM_Prv_idLastDetError_uo)
	lea	a15,[a15]@los(NvM_Prv_idLastDetError_uo)
.L440:
	st.b	[a15],d8
.L441:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   109      NvM_Prv_idBlockLastDetError_uo = idBlock_uo;
	movh.a	a15,#@his(NvM_Prv_idBlockLastDetError_uo)
	lea	a15,[a15]@los(NvM_Prv_idBlockLastDetError_uo)
.L442:
	st.h	[a15],d9
.L443:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   110  }
	ret
.L431:
	
__NvM_Prv_ReportDetError_function_end:
	.size	NvM_Prv_ReportDetError,__NvM_Prv_ReportDetError_function_end-NvM_Prv_ReportDetError
.L262:
	; End of function
	
	.sdecl	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_InitializeDetError',code,cluster('NvM_Prv_ErrorDetection_InitializeDetError')
	.sect	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_InitializeDetError'
	.align	2
	
	.global	NvM_Prv_ErrorDetection_InitializeDetError

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   111  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   112  /**
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   113   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   114   * This NvM private function initializes all data which will be reported to the DET.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   115   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   116   * The reported data will be initialized only if data in the saved zone is lost.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   117   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   118   * \param[in] isSavedZoneDataLost_b
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   119   * Status information of the data in the saved zone RAM:
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   120   * - true = data in the saved zone RAM is lost after the reset
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   121   * - false = data in the saved zone RAM is unchanged after the reset
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   122   */
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   123  void NvM_Prv_ErrorDetection_InitializeDetError(boolean isSavedZoneDataLost_b)
; Function NvM_Prv_ErrorDetection_InitializeDetError
.L82:
NvM_Prv_ErrorDetection_InitializeDetError:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   124  {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   125      if (isSavedZoneDataLost_b)
	jeq	d4,#0,.L3
.L541:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   126      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   127          NvM_Prv_idServiceLastDetError_uo = NVM_SERVICE_ID_INIT;
	movh.a	a15,#@his(NvM_Prv_idServiceLastDetError_uo)
	lea	a15,[a15]@los(NvM_Prv_idServiceLastDetError_uo)
.L542:
	mov	d15,#0
.L543:
	st.b	[a15],d15
.L544:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   128          NvM_Prv_idLastDetError_uo = NVM_PRV_NO_DET_ERROR;
	movh.a	a15,#@his(NvM_Prv_idLastDetError_uo)
	lea	a15,[a15]@los(NvM_Prv_idLastDetError_uo)
.L545:
	mov	d15,#0
.L546:
	st.b	[a15],d15
.L547:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   129          NvM_Prv_idBlockLastDetError_uo = 0u;
	movh.a	a15,#@his(NvM_Prv_idBlockLastDetError_uo)
	lea	a15,[a15]@los(NvM_Prv_idBlockLastDetError_uo)
.L548:
	mov	d15,#0
.L549:
	st.h	[a15],d15
.L3:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   130      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   131  }
	ret
.L273:
	
__NvM_Prv_ErrorDetection_InitializeDetError_function_end:
	.size	NvM_Prv_ErrorDetection_InitializeDetError,__NvM_Prv_ErrorDetection_InitializeDetError_function_end-NvM_Prv_ErrorDetection_InitializeDetError
.L142:
	; End of function
	
	.sdecl	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_InitializeProductionErrors',code,cluster('NvM_Prv_ErrorDetection_InitializeProductionErrors')
	.sect	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_InitializeProductionErrors'
	.align	2
	
	.global	NvM_Prv_ErrorDetection_InitializeProductionErrors

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   132  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   133  /**
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   134   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   135   * This NvM private function initializes all block specific production errors.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   136   */
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   137  void NvM_Prv_ErrorDetection_InitializeProductionErrors(void)
; Function NvM_Prv_ErrorDetection_InitializeProductionErrors
.L84:
NvM_Prv_ErrorDetection_InitializeProductionErrors:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   138  {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   139      NvM_BlockIdType idBlock_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   140      // Variable saving blocks' errors (useful for debugging)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   141      for (idBlock_uo = 0u; idBlock_uo < NVM_CFG_NR_BLOCKS; ++idBlock_uo)
	mov	d15,#0
.L444:
	j	.L4
.L5:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   142      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   143          NvM_Rb_stBlockErrors_au8[idBlock_uo] = 0u; // No errors
	movh.a	a15,#@his(NvM_Rb_stBlockErrors_au8)
	lea	a15,[a15]@los(NvM_Rb_stBlockErrors_au8)
.L554:
	addsc.a	a15,a15,d15,#0
.L555:
	mov	d0,#0
.L556:
	st.b	[a15],d0
.L557:
	add	d15,#1
.L4:
	jlt.u	d15,#14,.L5
.L558:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   144      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   145  }
	ret
.L276:
	
__NvM_Prv_ErrorDetection_InitializeProductionErrors_function_end:
	.size	NvM_Prv_ErrorDetection_InitializeProductionErrors,__NvM_Prv_ErrorDetection_InitializeProductionErrors_function_end-NvM_Prv_ErrorDetection_InitializeProductionErrors
.L147:
	; End of function
	
	.sdecl	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_SetProductionError',code,cluster('NvM_Prv_ErrorDetection_SetProductionError')
	.sect	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_SetProductionError'
	.align	2
	
	.global	NvM_Prv_ErrorDetection_SetProductionError

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   146  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   147  /**
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   148   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   149   * This NVM private function sets a production error.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   150   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   151   * \param[in] idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   152   * ID of the block for which production error is reported.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   153   * \param[in] MaskErrorBit_u8
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   154   * Bit mask of the production error to be set.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   155   * \param[out] NvM_Rb_stBlockErrors_au8
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   156   * Global array with all block specific production error.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   157   */
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   158  void NvM_Prv_ErrorDetection_SetProductionError(NvM_BlockIdType idBlock_uo, uint8 MaskErrorBit_u8)
; Function NvM_Prv_ErrorDetection_SetProductionError
.L86:
NvM_Prv_ErrorDetection_SetProductionError:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   159  {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   160      // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2811] Report block specific production error
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   161      NvM_Rb_stBlockErrors_au8[idBlock_uo] |= MaskErrorBit_u8;
	movh.a	a15,#@his(NvM_Rb_stBlockErrors_au8)
	lea	a15,[a15]@los(NvM_Rb_stBlockErrors_au8)
.L563:
	addsc.a	a2,a15,d4,#0
	ld.bu	d15,[a2]
.L564:
	or	d15,d5
	st.b	[a2],d15
.L565:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   162      // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2812] Set reported production error in the overall summary
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   163      NvM_Rb_stBlockErrors_au8[0] |= MaskErrorBit_u8;
	ld.bu	d15,[a15]
.L566:
	or	d15,d5
	st.b	[a15],d15
.L567:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   164  }
	ret
.L278:
	
__NvM_Prv_ErrorDetection_SetProductionError_function_end:
	.size	NvM_Prv_ErrorDetection_SetProductionError,__NvM_Prv_ErrorDetection_SetProductionError_function_end-NvM_Prv_ErrorDetection_SetProductionError
.L152:
	; End of function
	
	.sdecl	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsBlockPending',code,cluster('NvM_Prv_ErrorDetection_IsBlockPending')
	.sect	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsBlockPending'
	.align	2
	
	.global	NvM_Prv_ErrorDetection_IsBlockPending

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   165  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   166  /**
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   167   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   168   * This NvM private function reports the DET error NVM_E_BLOCK_PENDING if the passed block is already queued or
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   169   * currently in progress.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   170   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   171   * \param[in] idService_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   172   * ID of the service which checks whether the block is pending. This ID will be reported together with DET error.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   173   * \param[in] idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   174   * Block ID used in NvM service causing last DET error.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   175   * \param[in] isBlockPending_b
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   176   * Information whether the passed block is pending.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   177   */
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   178  void NvM_Prv_ErrorDetection_IsBlockPending(NvM_Prv_idService_tuo idService_uo,
; Function NvM_Prv_ErrorDetection_IsBlockPending
.L88:
NvM_Prv_ErrorDetection_IsBlockPending:	.type	func
	mov	d15,d5
.L447:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   179                                             NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   180                                             boolean isBlockPending_b)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   181  {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   182      if (isBlockPending_b)
	jeq	d6,#0,.L6
.L572:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   183      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   184          // TRACE[NVM632] Report the DET error NVM_E_BLOCK_PENDING when the NVRAM block identifier is already queued or
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   185          //               currently in progress
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   186          NvM_Prv_ReportDetError(idService_uo, NVM_E_BLOCK_PENDING, idBlock_uo);
	mov	d5,#21
.L445:
	mov	d6,d15
.L446:
	call	NvM_Prv_ReportDetError
.L6:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   187      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   188  }
	ret
.L281:
	
__NvM_Prv_ErrorDetection_IsBlockPending_function_end:
	.size	NvM_Prv_ErrorDetection_IsBlockPending,__NvM_Prv_ErrorDetection_IsBlockPending_function_end-NvM_Prv_ErrorDetection_IsBlockPending
.L157:
	; End of function
	
	.sdecl	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsServiceBitValid',code,cluster('NvM_Prv_ErrorDetection_IsServiceBitValid')
	.sect	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsServiceBitValid'
	.align	2
	
	.global	NvM_Prv_ErrorDetection_IsServiceBitValid

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   189  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   190  /**
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   191   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   192   * This NvM private function checks the passed service bit and reports the DET error NVM_E_SINGLE_BLOCK_SERVICE_ID
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   193   * if this bit is invalid.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   194   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   195   * \param[in] idService_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   196   * ID of the service which checks the service bit. This service ID will be reported together with DET error.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   197   * \param[in] idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   198   * Block ID used in NvM service causing last DET error.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   199   * \param[in] ServiceBit_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   200   * Service bit to be checked for validness.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   201   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   202   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   203   * Validness of the passed block ID:
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   204   * - TRUE = service bit is valid
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   205   * - FALSE = service bit is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   206   */
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   207  boolean NvM_Prv_ErrorDetection_IsServiceBitValid(NvM_Prv_idService_tuo idService_uo,
; Function NvM_Prv_ErrorDetection_IsServiceBitValid
.L90:
NvM_Prv_ErrorDetection_IsServiceBitValid:	.type	func
	mov	d0,d5
.L450:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   208                                                   NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   209                                                   NvM_Prv_ServiceBit_tuo ServiceBit_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   210  {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   211      boolean isServiceBitValid_b = (ServiceBit_uo < NvM_Prv_ServiceBit_Unspecified_e);
	lt.u	d15,d6,#16
.L451:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   212  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   213      if (!isServiceBitValid_b)
	jne	d15,#0,.L7
.L577:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   214      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   215          NvM_Prv_ReportDetError(idService_uo, NVM_E_SINGLE_BLOCK_SERVICE_ID, idBlock_uo);
	mov	d5,#251
.L449:
	mov	d6,d0
.L448:
	call	NvM_Prv_ReportDetError
.L7:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   216      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   217      return isServiceBitValid_b;
	mov	d2,d15
.L452:
	j	.L8

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   218  }
.L8:
	ret
.L285:
	
__NvM_Prv_ErrorDetection_IsServiceBitValid_function_end:
	.size	NvM_Prv_ErrorDetection_IsServiceBitValid,__NvM_Prv_ErrorDetection_IsServiceBitValid_function_end-NvM_Prv_ErrorDetection_IsServiceBitValid
.L162:
	; End of function
	
	.sdecl	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsJobIdValid',code,cluster('NvM_Prv_ErrorDetection_IsJobIdValid')
	.sect	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsJobIdValid'
	.align	2
	
	.global	NvM_Prv_ErrorDetection_IsJobIdValid

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   219  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   220  boolean NvM_Prv_ErrorDetection_IsJobIdValid(NvM_Prv_idService_tuo idService_uo,
; Function NvM_Prv_ErrorDetection_IsJobIdValid
.L92:
NvM_Prv_ErrorDetection_IsJobIdValid:	.type	func
	mov	d0,d5
.L455:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   221                                              NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   222                                              NvM_Prv_idJob_ten idJob_en)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   223  {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   224      boolean isJobIdValid_b = (idJob_en < NvM_Prv_idJob_Invalid_e);
	lt	d15,d6,#12
.L456:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   225  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   226      if (!isJobIdValid_b)
	jne	d15,#0,.L9
.L582:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   227      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   228          NvM_Prv_ReportDetError(idService_uo, NVM_E_PRV_JOB_ID, idBlock_uo);
	mov	d5,#252
.L453:
	mov	d6,d0
.L454:
	call	NvM_Prv_ReportDetError
.L9:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   229      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   230      return isJobIdValid_b;
	mov	d2,d15
.L457:
	j	.L10

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   231  }
.L10:
	ret
.L290:
	
__NvM_Prv_ErrorDetection_IsJobIdValid_function_end:
	.size	NvM_Prv_ErrorDetection_IsJobIdValid,__NvM_Prv_ErrorDetection_IsJobIdValid_function_end-NvM_Prv_ErrorDetection_IsJobIdValid
.L167:
	; End of function
	
	.sdecl	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible',code,cluster('NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible')
	.sect	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible'
	.align	2
	
	.global	NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   232  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   233  boolean NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible(NvM_Prv_idService_tuo idService_uo,
; Function NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible
.L94:
NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible:	.type	func
	mov	d0,d5
.L460:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   234                                                           NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   235                                                           MemIf_JobResultType JobResult_en)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   236  {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   237      boolean isJobResultMemIfPlausible_b = ((JobResult_en == MEMIF_JOB_OK) ||
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   238                                             (JobResult_en == MEMIF_JOB_FAILED) ||
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   239                                             (JobResult_en == MEMIF_JOB_CANCELED) ||
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   240                                             (JobResult_en == MEMIF_BLOCK_INVALID) ||
	mov	d15,#0
.L461:
	jeq	d6,#0,.L11
.L587:
	jeq	d6,#1,.L12
.L588:
	jeq	d6,#3,.L13
.L589:
	jeq	d6,#5,.L14
.L590:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   241                                             (JobResult_en == MEMIF_BLOCK_INCONSISTENT));
	jne	d6,#4,.L15
.L14:
.L13:
.L12:
.L11:
	mov	d15,#1
.L15:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   242      if (!isJobResultMemIfPlausible_b)
	jne	d15,#0,.L16
.L591:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   243      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   244          NvM_Prv_ReportDetError(idService_uo, NVM_E_MEMIF_JOB_RESULT, idBlock_uo);
	mov	d5,#253
.L459:
	mov	d6,d0
.L458:
	call	NvM_Prv_ReportDetError
.L16:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   245      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   246      return isJobResultMemIfPlausible_b;
	mov	d2,d15
	j	.L17

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   247  }
.L17:
	ret
.L296:
	
__NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible_function_end:
	.size	NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible,__NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible_function_end-NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible
.L172:
	; End of function
	
	.sdecl	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsBlockSizeValidForExplicitSync',code,cluster('NvM_Prv_ErrorDetection_IsBlockSizeValidForExplicitSync')
	.sect	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsBlockSizeValidForExplicitSync'
	.align	2
	
	.global	NvM_Prv_ErrorDetection_IsBlockSizeValidForExplicitSync

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   248  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   249  /**
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   250   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   251   * This NvM private function checks whether the RAM mirror used for explicit synchronization is big enough
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   252   * for the passed block and reports the DET error NVM_E_RAM_MIRROR_SIZE if RAM mirror is too small.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   253   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   254   * \param[in] idService_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   255   * ID of the service which checks whether the block size is valid. This ID will be reported together with DET error.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   256   * \param[in] idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   257   * ID of the block for which the size will be validated.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   258   * \param[in] SizeRamMirror_u32
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   259   * Size of the RAM mirror used for explicit synchronization
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   260   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   261   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   262   * - TRUE = RAM mirror is big enough
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   263   * - FALSE = RAM mirror is too small
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   264   */
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   265  boolean NvM_Prv_ErrorDetection_IsBlockSizeValidForExplicitSync(NvM_Prv_idService_tuo idService_uo,
; Function NvM_Prv_ErrorDetection_IsBlockSizeValidForExplicitSync
.L96:
NvM_Prv_ErrorDetection_IsBlockSizeValidForExplicitSync:	.type	func
	mov	d0,d5
.L309:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   392  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   393   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   394   * This NvM private function checks for the given block whether the configured block length is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   395   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   396   * \param idBlock
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   397   * ID of the block for which the block length will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   398   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   399   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   400   * - TRUE = block length is valid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   401   * - FALSE = block length is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   402   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   403  LOCAL_INLINE boolean NvM_Prv_IsBlockLengthValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   404  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   405      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   406              (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   407              (0u != *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   408  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   409  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   410  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   411   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   412   * This NvM private function checks whether the given block is configured with immediate priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   413   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   414   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   415   * ID of the block for which the priority will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   416   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   417   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   418   * - TRUE = block is configured with immediate priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   419   * - FALSE = block is configured with standard priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   420   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   421  LOCAL_INLINE boolean NvM_Prv_HasBlockImmediateJobPriority(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   423      boolean HasBlockImmediateJobPriority_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   425  #if (NVM_JOB_PRIORITIZATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   426      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   427          (NVM_PRV_JOB_PRIORITY_IMMEDIATE == NvM_Prv_BlockDescriptors_acst[idBlock_uo].JobPriority_u8))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   428      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   429          HasBlockImmediateJobPriority_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   430      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   431  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   433  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   434  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   435  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   436   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   437   * This NvM private function returns the configured block size for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   438   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   439   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   440   * ID of the block for which the configured block size will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   441   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   442   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   443   * Configured block size
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   444   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   445  LOCAL_INLINE uint16 NvM_Prv_GetBlockSize(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   446  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   447      uint16 BlockSize_u16 = 0;
	mov	d1,#0
.L464:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
	jge.u	d0,#14,.L18
.L596:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   448  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))
	mul	d15,d0,#48
.L597:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L598:
	addsc.a	a15,a15,d15,#0
.L599:
	ld.a	a15,[a15]4
.L600:
	mov.a	a2,#0
.L601:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))      (inlined)
	jeq.a	a2,a15,.L19
.L602:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   451      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   452          BlockSize_u16 = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16;
	ld.hu	d1,[a15]0

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
.L19:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))      (inlined)
.L18:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   455      return BlockSize_u16;      (inlined)
	j	.L20

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   456  }      (inlined)
.L20:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   266                                                                 NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   267                                                                 uint32 SizeRamMirror_u32)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   268  {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   269      boolean isBlockSizeValid_b = (NvM_Prv_GetBlockSize(idBlock_uo) <= SizeRamMirror_u32);
	ge.u	d15,d6,d1
.L310:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   270  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   271      if (!isBlockSizeValid_b)
	jne	d15,#0,.L21
.L603:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   272      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   273          // block size greater than size of the RAM mirror used for explicit synchronization
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   274          NvM_Prv_ReportDetError(idService_uo, NVM_E_RAM_MIRROR_SIZE, idBlock_uo);
	mov	d5,#254
.L463:
	mov	d6,d0
.L462:
	call	NvM_Prv_ReportDetError
.L21:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   275      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   277      return isBlockSizeValid_b;
	mov	d2,d15
.L465:
	j	.L22

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   278  }
.L22:
	ret
.L302:
	
__NvM_Prv_ErrorDetection_IsBlockSizeValidForExplicitSync_function_end:
	.size	NvM_Prv_ErrorDetection_IsBlockSizeValidForExplicitSync,__NvM_Prv_ErrorDetection_IsBlockSizeValidForExplicitSync_function_end-NvM_Prv_ErrorDetection_IsBlockSizeValidForExplicitSync
.L177:
	; End of function
	
	.sdecl	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsPtrValidForDataIdx',code,cluster('NvM_Prv_ErrorDetection_IsPtrValidForDataIdx')
	.sect	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsPtrValidForDataIdx'
	.align	2
	
	.global	NvM_Prv_ErrorDetection_IsPtrValidForDataIdx

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   279  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   280  /**
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   281   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   282   * This NvM private function checks whether the passed data index pointer is valid and reports the DET error
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   283   * NVM_E_PARAM_DATA if NULL pointer is passed.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   284   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   285   * \param[in] idService_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   286   * ID of the service which checks whether the data index pointer is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   287   * This ID will be reported together with DET error.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   288   * \param[in] idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   289   * ID of the block for which the data index pointer will be validated.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   290   * \param[in] ptrDataIdx_pcu8
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   291   * Data index pointer to be validated.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   292   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   293   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   294   * - TRUE = data index pointer is valid
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   295   * - FALSE = data index pointer is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   297  boolean NvM_Prv_ErrorDetection_IsPtrValidForDataIdx(NvM_Prv_idService_tuo idService_uo,
; Function NvM_Prv_ErrorDetection_IsPtrValidForDataIdx
.L98:
NvM_Prv_ErrorDetection_IsPtrValidForDataIdx:	.type	func
	mov	d6,d5
.L467:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   298                                                      NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   299                                                      uint8 const* ptrDataIdx_pcu8)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   300  {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   301      boolean isPtrValid_b = (NULL_PTR != ptrDataIdx_pcu8);
	mov.a	a15,#0
.L608:
	ne.a	d15,a15,a4
.L468:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   302  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   303      if (!isPtrValid_b)
	jne	d15,#0,.L23
.L609:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   304      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   305          NvM_Prv_ReportDetError(idService_uo, NVM_E_PARAM_DATA, idBlock_uo);
	mov	d5,#14
.L466:
	call	NvM_Prv_ReportDetError
.L23:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   306      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   307  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   308      return isPtrValid_b;
	mov	d2,d15
.L469:
	j	.L24

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   309  }
.L24:
	ret
.L315:
	
__NvM_Prv_ErrorDetection_IsPtrValidForDataIdx_function_end:
	.size	NvM_Prv_ErrorDetection_IsPtrValidForDataIdx,__NvM_Prv_ErrorDetection_IsPtrValidForDataIdx_function_end-NvM_Prv_ErrorDetection_IsPtrValidForDataIdx
.L182:
	; End of function
	
	.sdecl	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsPtrValidForRequestResult',code,cluster('NvM_Prv_ErrorDetection_IsPtrValidForRequestResult')
	.sect	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsPtrValidForRequestResult'
	.align	2
	
	.global	NvM_Prv_ErrorDetection_IsPtrValidForRequestResult

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   310  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   311  /**
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   312   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   313   * This NvM private function checks whether the passed request result pointer is valid and reports the DET error
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   314   * NVM_E_PARAM_DATA if NULL pointer is passed.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   315   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   316   * \param[in] idService_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   317   * ID of the service which checks whether the request result pointer is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   318   * This ID will be reported together with DET error.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   319   * \param[in] idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   320   * ID of the block for which the request result pointer will be validated.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   321   * \param[in] ptrReqResult_pcuo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   322   * Request result pointer to be validated.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   323   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   324   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   325   * - TRUE = request result pointer is valid
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   326   * - FALSE = request result pointer is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   327   */
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   328  boolean NvM_Prv_ErrorDetection_IsPtrValidForRequestResult(NvM_Prv_idService_tuo idService_uo,
; Function NvM_Prv_ErrorDetection_IsPtrValidForRequestResult
.L100:
NvM_Prv_ErrorDetection_IsPtrValidForRequestResult:	.type	func
	mov	d6,d5
.L471:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   329                                                            NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   330                                                            NvM_RequestResultType const* ptrReqResult_pcuo)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   331  {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   332      boolean isPtrValid_b = (NULL_PTR != ptrReqResult_pcuo);
	mov.a	a15,#0
.L614:
	ne.a	d15,a15,a4
.L472:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   333  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   334      if (!isPtrValid_b)
	jne	d15,#0,.L25
.L615:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   335      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   336          NvM_Prv_ReportDetError(idService_uo, NVM_E_PARAM_DATA, idBlock_uo);
	mov	d5,#14
.L470:
	call	NvM_Prv_ReportDetError
.L25:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   337      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   338  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   339      return isPtrValid_b;
	mov	d2,d15
.L473:
	j	.L26

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   340  }
.L26:
	ret
.L321:
	
__NvM_Prv_ErrorDetection_IsPtrValidForRequestResult_function_end:
	.size	NvM_Prv_ErrorDetection_IsPtrValidForRequestResult,__NvM_Prv_ErrorDetection_IsPtrValidForRequestResult_function_end-NvM_Prv_ErrorDetection_IsPtrValidForRequestResult
.L187:
	; End of function
	
	.sdecl	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsPtrValidForMigrationResult',code,cluster('NvM_Prv_ErrorDetection_IsPtrValidForMigrationResult')
	.sect	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsPtrValidForMigrationResult'
	.align	2
	
	.global	NvM_Prv_ErrorDetection_IsPtrValidForMigrationResult

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   341  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   342  /**
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   343   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   344   * This NvM private function checks whether the passed migration result pointer is valid and reports the DET error
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   345   * NVM_E_PARAM_DATA if NULL pointer is passed.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   346   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   347   * \param[in] idService_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   348   * ID of the service which checks whether the migration result pointer is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   349   * This ID will be reported together with DET error.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   350   * \param[in] idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   351   * ID of the block for which the migration result pointer will be validated.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   352   * \param[in] ptrReqResult_pcuo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   353   * Migration result pointer to be validated.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   354   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   355   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   356   * - TRUE = migration result pointer is valid
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   357   * - FALSE = migration result pointer is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   358   */
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   359  boolean NvM_Prv_ErrorDetection_IsPtrValidForMigrationResult(NvM_Prv_idService_tuo idService_uo,
; Function NvM_Prv_ErrorDetection_IsPtrValidForMigrationResult
.L102:
NvM_Prv_ErrorDetection_IsPtrValidForMigrationResult:	.type	func
	mov	d6,d5
.L475:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   360                                                              NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   361                                                              NvM_Rb_MigrationResult_ten const* ptrMigrationResult_pcen)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   362  {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   363      boolean isPtrValid_b = (NULL_PTR != ptrMigrationResult_pcen);
	mov.a	a15,#0
.L620:
	ne.a	d15,a15,a4
.L476:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   364  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   365      if (!isPtrValid_b)
	jne	d15,#0,.L27
.L621:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   366      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   367          NvM_Prv_ReportDetError(idService_uo, NVM_E_PARAM_DATA, idBlock_uo);
	mov	d5,#14
.L474:
	call	NvM_Prv_ReportDetError
.L27:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   368      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   369  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   370      return isPtrValid_b;
	mov	d2,d15
.L477:
	j	.L28

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   371  }
.L28:
	ret
.L327:
	
__NvM_Prv_ErrorDetection_IsPtrValidForMigrationResult_function_end:
	.size	NvM_Prv_ErrorDetection_IsPtrValidForMigrationResult,__NvM_Prv_ErrorDetection_IsPtrValidForMigrationResult_function_end-NvM_Prv_ErrorDetection_IsPtrValidForMigrationResult
.L192:
	; End of function
	
	.sdecl	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsPtrValidForNvmStatus',code,cluster('NvM_Prv_ErrorDetection_IsPtrValidForNvmStatus')
	.sect	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsPtrValidForNvmStatus'
	.align	2
	
	.global	NvM_Prv_ErrorDetection_IsPtrValidForNvmStatus

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   372  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   373  /**
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   374   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   375   * This NvM private function checks whether the passed NvM status pointer is valid and reports the DET error
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   376   * NVM_E_PARAM_DATA if NULL pointer is passed.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   378   * \param[in] idService_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   379   * ID of the service which checks whether the NvM status pointer is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   380   * This ID will be reported together with DET error.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   381   * \param[in] ptrReqResult_pcuo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   382   * NvM status pointer to be validated.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   383   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   384   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   385   * - TRUE = NvM status pointer is valid
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   386   * - FALSE = NvM status pointer is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   387   */
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   388  boolean NvM_Prv_ErrorDetection_IsPtrValidForNvmStatus(NvM_Prv_idService_tuo idService_uo,
; Function NvM_Prv_ErrorDetection_IsPtrValidForNvmStatus
.L104:
NvM_Prv_ErrorDetection_IsPtrValidForNvmStatus:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   389                                                        NvM_Rb_StatusType const* ptrNvmStatus_pcen)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   390  {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   391      boolean isPtrValid_b = (NULL_PTR != ptrNvmStatus_pcen);
	mov.a	a15,#0
.L626:
	ne.a	d15,a15,a4
.L478:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   392  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   393      if (!isPtrValid_b)
	jne	d15,#0,.L29
.L627:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   394      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   395          // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3114] Set block ID to 0 if NvM service does not use any block ID
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   396          NvM_Prv_ReportDetError(idService_uo, NVM_E_PARAM_DATA, 0);
	mov	d5,#14
.L628:
	mov	d6,#0
	call	NvM_Prv_ReportDetError
.L29:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   397      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   398  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   399      return isPtrValid_b;
	mov	d2,d15
.L479:
	j	.L30

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   400  }
.L30:
	ret
.L333:
	
__NvM_Prv_ErrorDetection_IsPtrValidForNvmStatus_function_end:
	.size	NvM_Prv_ErrorDetection_IsPtrValidForNvmStatus,__NvM_Prv_ErrorDetection_IsPtrValidForNvmStatus_function_end-NvM_Prv_ErrorDetection_IsPtrValidForNvmStatus
.L197:
	; End of function
	
	.sdecl	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsPtrValidForBlockLength',code,cluster('NvM_Prv_ErrorDetection_IsPtrValidForBlockLength')
	.sect	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsPtrValidForBlockLength'
	.align	2
	
	.global	NvM_Prv_ErrorDetection_IsPtrValidForBlockLength

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   401  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   402  /**
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   403   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   404   * This NvM private function checks whether the passed block length pointer is valid and reports the DET error
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   405   * NVM_E_PARAM_DATA if NULL pointer is passed.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   406   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   407   * \param[in] idService_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   408   * ID of the service which checks whether the block length pointer is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   409   * This ID will be reported together with DET error.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   410   * \param[in] idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   411   * ID of the block for which the block length pointer will be validated.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   412   * \param[in] ptrReqResult_pcuo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   413   * Block length pointer to be validated.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   414   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   415   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   416   * - TRUE = block length pointer is valid
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   417   * - FALSE = block length pointer is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   418   */
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   419  boolean NvM_Prv_ErrorDetection_IsPtrValidForBlockLength(NvM_Prv_idService_tuo idService_uo,
; Function NvM_Prv_ErrorDetection_IsPtrValidForBlockLength
.L106:
NvM_Prv_ErrorDetection_IsPtrValidForBlockLength:	.type	func
	mov	d6,d5
.L481:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   420                                                          NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   421                                                          uint16 const* ptrBlockLength_pcu16)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   423      boolean isPtrValid_b = (NULL_PTR != ptrBlockLength_pcu16);
	mov.a	a15,#0
.L633:
	ne.a	d15,a15,a4
.L482:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   425      if (!isPtrValid_b)
	jne	d15,#0,.L31
.L634:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   426      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   427          NvM_Prv_ReportDetError(idService_uo, NVM_E_PARAM_DATA, idBlock_uo);
	mov	d5,#14
.L480:
	call	NvM_Prv_ReportDetError
.L31:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   428      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   429  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   430      return isPtrValid_b;
	mov	d2,d15
.L483:
	j	.L32

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   431  }
.L32:
	ret
.L338:
	
__NvM_Prv_ErrorDetection_IsPtrValidForBlockLength_function_end:
	.size	NvM_Prv_ErrorDetection_IsPtrValidForBlockLength,__NvM_Prv_ErrorDetection_IsPtrValidForBlockLength_function_end-NvM_Prv_ErrorDetection_IsPtrValidForBlockLength
.L202:
	; End of function
	
	.sdecl	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsPtrValidForServiceId',code,cluster('NvM_Prv_ErrorDetection_IsPtrValidForServiceId')
	.sect	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsPtrValidForServiceId'
	.align	2
	
	.global	NvM_Prv_ErrorDetection_IsPtrValidForServiceId

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   432  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   433  /**
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   434   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   435   * This NvM private function checks whether the passed service ID pointer is valid and reports the DET error
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   436   * NVM_E_PARAM_DATA if NULL pointer is passed.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   437   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   438   * \param[in] idService_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   439   * ID of the service which checks whether the service ID pointer is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   440   * This ID will be reported together with DET error.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   441   * \param[in] ptrReqResult_pcuo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   442   * Service ID pointer to be validated.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   443   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   444   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   445   * - TRUE = service ID pointer is valid
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   446   * - FALSE = service ID pointer is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   447   */
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   448  boolean NvM_Prv_ErrorDetection_IsPtrValidForServiceId(NvM_Prv_idService_tuo idService_uo,
; Function NvM_Prv_ErrorDetection_IsPtrValidForServiceId
.L108:
NvM_Prv_ErrorDetection_IsPtrValidForServiceId:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   449                                                        NvM_Prv_idService_tuo const* ptrIdService_pcuo)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   450  {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   451      boolean isPtrValid_b = (NULL_PTR != ptrIdService_pcuo);
	mov.a	a15,#0
.L639:
	ne.a	d15,a15,a4
.L484:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   452  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   453      if (!isPtrValid_b)
	jne	d15,#0,.L33
.L640:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   454      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   455          // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3114] Set block ID to 0 if NvM service does not use any block ID
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   456          NvM_Prv_ReportDetError(idService_uo, NVM_E_PARAM_DATA, 0);
	mov	d5,#14
.L641:
	mov	d6,#0
	call	NvM_Prv_ReportDetError
.L33:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   457      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   458  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   459      return isPtrValid_b;
	mov	d2,d15
.L485:
	j	.L34

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   460  }
.L34:
	ret
.L344:
	
__NvM_Prv_ErrorDetection_IsPtrValidForServiceId_function_end:
	.size	NvM_Prv_ErrorDetection_IsPtrValidForServiceId,__NvM_Prv_ErrorDetection_IsPtrValidForServiceId_function_end-NvM_Prv_ErrorDetection_IsPtrValidForServiceId
.L207:
	; End of function
	
	.sdecl	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsPtrValidForBlockId',code,cluster('NvM_Prv_ErrorDetection_IsPtrValidForBlockId')
	.sect	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsPtrValidForBlockId'
	.align	2
	
	.global	NvM_Prv_ErrorDetection_IsPtrValidForBlockId

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   461  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   462  /**
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   463   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   464   * This NvM private function checks whether the passed block ID pointer is valid and reports the DET error
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   465   * NVM_E_PARAM_DATA if NULL pointer is passed.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   466   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   467   * \param[in] idService_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   468   * ID of the service which checks whether the block ID pointer is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   469   * This ID will be reported together with DET error.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   470   * \param[in] ptrIdBlock_pcuo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   471   * Block ID pointer to be validated.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   472   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   473   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   474   * - TRUE = block ID pointer is valid
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   475   * - FALSE = block ID pointer is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   476   */
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   477  boolean NvM_Prv_ErrorDetection_IsPtrValidForBlockId(NvM_Prv_idService_tuo idService_uo,
; Function NvM_Prv_ErrorDetection_IsPtrValidForBlockId
.L110:
NvM_Prv_ErrorDetection_IsPtrValidForBlockId:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   478                                                      NvM_BlockIdType const* ptrIdBlock_pcuo)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   479  {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   480      boolean isPtrValid_b = (NULL_PTR != ptrIdBlock_pcuo);
	mov.a	a15,#0
.L646:
	ne.a	d15,a15,a4
.L486:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   481  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   482      if (!isPtrValid_b)
	jne	d15,#0,.L35
.L647:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   483      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   484          // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3114] Set block ID to 0 if NvM service does not use any block ID
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   485          NvM_Prv_ReportDetError(idService_uo, NVM_E_PARAM_DATA, 0);
	mov	d5,#14
.L648:
	mov	d6,#0
	call	NvM_Prv_ReportDetError
.L35:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   486      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   487  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   488      return isPtrValid_b;
	mov	d2,d15
.L487:
	j	.L36

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   489  }
.L36:
	ret
.L349:
	
__NvM_Prv_ErrorDetection_IsPtrValidForBlockId_function_end:
	.size	NvM_Prv_ErrorDetection_IsPtrValidForBlockId,__NvM_Prv_ErrorDetection_IsPtrValidForBlockId_function_end-NvM_Prv_ErrorDetection_IsPtrValidForBlockId
.L212:
	; End of function
	
	.sdecl	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsPtrValidForVersionInfo',code,cluster('NvM_Prv_ErrorDetection_IsPtrValidForVersionInfo')
	.sect	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsPtrValidForVersionInfo'
	.align	2
	
	.global	NvM_Prv_ErrorDetection_IsPtrValidForVersionInfo

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   490  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   491  /**
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   492   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   493   * This NvM private function checks whether the passed version info pointer is valid and reports the DET error
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   494   * NVM_E_PARAM_POINTER if NULL pointer is passed.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   495   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   496   * \param[in] idService_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   497   * ID of the service which checks whether the version info pointer is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   498   * This ID will be reported together with DET error.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   499   * \param[in] idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   500   * ID of the block for which the version info pointer will be validated.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   501   * \param[in] ptrVersionInfo_pcst
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   502   * Version info pointer to be validated.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   503   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   504   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   505   * - TRUE = version info pointer is valid
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   506   * - FALSE = version info pointer is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   507   */
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   508  boolean NvM_Prv_ErrorDetection_IsPtrValidForVersionInfo(NvM_Prv_idService_tuo idService_uo,
; Function NvM_Prv_ErrorDetection_IsPtrValidForVersionInfo
.L112:
NvM_Prv_ErrorDetection_IsPtrValidForVersionInfo:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   509                                                          Std_VersionInfoType const* ptrVersionInfo_pcst)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   510  {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   511      boolean isPtrValid_b = (NULL_PTR != ptrVersionInfo_pcst);
	mov.a	a15,#0
.L653:
	ne.a	d15,a15,a4
.L488:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   512  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   513      if (!isPtrValid_b)
	jne	d15,#0,.L37
.L654:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   514      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   515          // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3114] Set block ID to 0 if NvM service does not use any block ID
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   516          NvM_Prv_ReportDetError(idService_uo, NVM_E_PARAM_POINTER, 0);
	mov	d5,#15
.L655:
	mov	d6,#0
	call	NvM_Prv_ReportDetError
.L37:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   517      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   518  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   519      return isPtrValid_b;
	mov	d2,d15
.L489:
	j	.L38

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   520  }
.L38:
	ret
.L354:
	
__NvM_Prv_ErrorDetection_IsPtrValidForVersionInfo_function_end:
	.size	NvM_Prv_ErrorDetection_IsPtrValidForVersionInfo,__NvM_Prv_ErrorDetection_IsPtrValidForVersionInfo_function_end-NvM_Prv_ErrorDetection_IsPtrValidForVersionInfo
.L217:
	; End of function
	
	.sdecl	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsNvmInitialized',code,cluster('NvM_Prv_ErrorDetection_IsNvmInitialized')
	.sect	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsNvmInitialized'
	.align	2
	
	.global	NvM_Prv_ErrorDetection_IsNvmInitialized

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   521  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   522  /**
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   523   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   524   * This private function checks the initialization of the NvM and reports the DET error NVM_E_NOT_INITIALIZED
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   525   * when the NvM is not yet initialized.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   526   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   527   * \param[in] idService_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   528   * ID of the service which checks the NvM initialization. This ID will be reported together with DET error.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   529   * \param[in] idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   530   * Block ID used in NvM service causing last DET error.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   531   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   532   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   533   * Initialization status of the NvM:
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   534   * - TRUE = NvM initialized
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   535   * - FALSE = NvM not initialized
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   536   */
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   537  boolean NvM_Prv_ErrorDetection_IsNvmInitialized(NvM_Prv_idService_tuo idService_uo,
; Function NvM_Prv_ErrorDetection_IsNvmInitialized
.L114:
NvM_Prv_ErrorDetection_IsNvmInitialized:	.type	func
	mov	e8,d5,d4
.L660:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   538                                                  NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   539  {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   540      boolean isNvmInitialized_b = NvM_Prv_IsNvmInitialized();
	call	NvM_Prv_IsNvmInitialized
.L490:
	mov	d15,d2
.L491:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   541  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   542      if (!isNvmInitialized_b)
	jne	d15,#0,.L39
.L661:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   543      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   544          NvM_Prv_ReportDetError(idService_uo, NVM_E_NOT_INITIALIZED, idBlock_uo);
	mov	d5,#20
.L492:
	mov	d4,d8
.L493:
	mov	d6,d9
.L494:
	call	NvM_Prv_ReportDetError
.L39:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   545      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   546  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   547      return (isNvmInitialized_b);
	mov	d2,d15
.L495:
	j	.L40

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   548  }
.L40:
	ret
.L359:
	
__NvM_Prv_ErrorDetection_IsNvmInitialized_function_end:
	.size	NvM_Prv_ErrorDetection_IsNvmInitialized,__NvM_Prv_ErrorDetection_IsNvmInitialized_function_end-NvM_Prv_ErrorDetection_IsNvmInitialized
.L222:
	; End of function
	
	.sdecl	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsBlockIdValid',code,cluster('NvM_Prv_ErrorDetection_IsBlockIdValid')
	.sect	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsBlockIdValid'
	.align	2
	
	.global	NvM_Prv_ErrorDetection_IsBlockIdValid

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   549  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   550  /**
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   551   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   552   * This NvM private function checks the passed block ID and reports the DET error NVM_E_PARAM_BLOCK_ID
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   553   * if this ID is invalid.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   554   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   555   * \param[in] idService_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   556   * ID of the service which checks the block ID. This service ID will be reported together with DET error.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   557   * \param[in] idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   558   * Block ID to be checked for validness.
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   559   * \param[in] isMultiBlockAllowed_b
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   560   * Flag to define whether the multi-block ID is valid ID or not
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   561   *
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   562   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   563   * Validness of the passed block ID:
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   564   * - TRUE = block ID is valid
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   565   * - FALSE = block ID is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   566   */
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   567  boolean NvM_Prv_ErrorDetection_IsBlockIdValid(NvM_Prv_idService_tuo idService_uo,
; Function NvM_Prv_ErrorDetection_IsBlockIdValid
.L116:
NvM_Prv_ErrorDetection_IsBlockIdValid:	.type	func
	mov	d0,d5
.L496:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   568                                                NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   569                                                boolean isMultiBlockAllowed_b)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   570  {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   571      boolean isBlockIdValid_b;
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   572      NvM_BlockIdType idBlockLowest_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   573  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   574      if (isMultiBlockAllowed_b)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   575      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   576          idBlockLowest_uo = NVM_PRV_MULTI_BLOCK;
	mov	d15,#0
	sel	d1,d6,d15,#2
.L497:
	j	.L42
.L41:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   577      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   578      else
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   579      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   580          // TRACE[NVM311] Allow applications to send requests for block ID 1
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   581          idBlockLowest_uo = NVM_CFG_FIRST_USED_BLOCK;
	mov	d1,#2
.L42:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   582      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   583  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   584      isBlockIdValid_b = (idBlock_uo >= idBlockLowest_uo) && (idBlock_uo < NVM_CFG_NR_BLOCKS);
	mov	d8,#0
.L500:
	jlt.u	d0,d1,.L43
.L666:
	ge.u	d15,d0,#14
.L667:
	cmovn	d8,d15,#1
.L44:
.L43:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   585  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   586      if (!isBlockIdValid_b)
	jne	d8,#0,.L45
.L668:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   587      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   588          // TRACE[NVM188] If the NvMDevErrorDetect switch is enabled API parameter checking is enabled
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   589          // TRACE[NVM023] Report DET errors when NvM is called with wrong parameters
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   590          NvM_Prv_ReportDetError(idService_uo, NVM_E_PARAM_BLOCK_ID, idBlock_uo);
	mov	d5,#10
.L498:
	mov	d6,d0
.L499:
	call	NvM_Prv_ReportDetError
.L45:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   591      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   592  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   593      return isBlockIdValid_b;
	mov	d2,d8
	j	.L46

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   594  }
.L46:
	ret
.L363:
	
__NvM_Prv_ErrorDetection_IsBlockIdValid_function_end:
	.size	NvM_Prv_ErrorDetection_IsBlockIdValid,__NvM_Prv_ErrorDetection_IsBlockIdValid_function_end-NvM_Prv_ErrorDetection_IsBlockIdValid
.L227:
	; End of function
	
	.sdecl	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsDefaultDataAvailable',code,cluster('NvM_Prv_ErrorDetection_IsDefaultDataAvailable')
	.sect	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsDefaultDataAvailable'
	.align	2
	
	.global	NvM_Prv_ErrorDetection_IsDefaultDataAvailable

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   595  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   596  boolean NvM_Prv_ErrorDetection_IsDefaultDataAvailable(NvM_Prv_idService_tuo idService_uo,
; Function NvM_Prv_ErrorDetection_IsDefaultDataAvailable
.L118:
NvM_Prv_ErrorDetection_IsDefaultDataAvailable:	.type	func
	mov	d6,d5
.L502:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   597                                                        NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   598  {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   599      boolean isDefaultDataAvailable_b = FALSE;
	mov	d8,#0
.L374:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
	mov	d15,#0
.L673:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
	jge.u	d6,#14,.L47
.L674:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
	mul	d0,d6,#48
.L675:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L676:
	addsc.a	a15,a15,d0,#0
.L677:
	mov.a	a2,#0
.L678:
	ld.a	a4,[a15]16
.L679:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||      (inlined)
	jne.a	a2,a4,.L48
.L680:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
	mov.a	a2,#0
.L681:
	ld.a	a15,[a15]28
.L682:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));      (inlined)
	jeq.a	a2,a15,.L49

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||      (inlined)
.L48:
	mov	d15,#1

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
.L49:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));      (inlined)
.L47:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
	j	.L50

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }      (inlined)
.L50:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   600      if (NvM_Prv_IsDefaultDataAvailable(idBlock_uo))
	jeq	d15,#0,.L51
.L375:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   601      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   602          isDefaultDataAvailable_b = TRUE;
	mov	d8,#1
.L683:
	j	.L52
.L51:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   603      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   604      else
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   605      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   606          NvM_Prv_ReportDetError(idService_uo, NVM_E_BLOCK_CONFIG, idBlock_uo);
	mov	d5,#24
.L501:
	call	NvM_Prv_ReportDetError
.L52:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   607      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   608      return isDefaultDataAvailable_b;
	mov	d2,d8
.L503:
	j	.L53

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   609  }
.L53:
	ret
.L369:
	
__NvM_Prv_ErrorDetection_IsDefaultDataAvailable_function_end:
	.size	NvM_Prv_ErrorDetection_IsDefaultDataAvailable,__NvM_Prv_ErrorDetection_IsDefaultDataAvailable_function_end-NvM_Prv_ErrorDetection_IsDefaultDataAvailable
.L232:
	; End of function
	
	.sdecl	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsRamBlockAddressValid',code,cluster('NvM_Prv_ErrorDetection_IsRamBlockAddressValid')
	.sect	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsRamBlockAddressValid'
	.align	2
	
	.global	NvM_Prv_ErrorDetection_IsRamBlockAddressValid

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   610  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   611  boolean NvM_Prv_ErrorDetection_IsRamBlockAddressValid(NvM_Prv_idService_tuo idService_uo,
; Function NvM_Prv_ErrorDetection_IsRamBlockAddressValid
.L120:
NvM_Prv_ErrorDetection_IsRamBlockAddressValid:	.type	func
	mov	d6,d5
.L506:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   612                                                        NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   613                                                        void const* RamBlockAddress_pv)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   614  {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   615      boolean isRamBlockAddressValid_b = FALSE;
	mov	d15,#0
.L507:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   616      // check whether RAM block address is valid
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   617      if (NULL_PTR == RamBlockAddress_pv)
	mov.a	a15,#0
.L688:
	jne.a	a15,a4,.L54
.L689:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   618      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   619          NvM_Prv_ReportDetError(idService_uo, NVM_E_PARAM_ADDRESS, idBlock_uo);
	mov	d5,#13
.L505:
	call	NvM_Prv_ReportDetError
.L504:
	j	.L55
.L54:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   620      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   621      else
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   622      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   623          isRamBlockAddressValid_b = TRUE;
	mov	d15,#1
.L55:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   624      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   625      return isRamBlockAddressValid_b;
	mov	d2,d15
.L508:
	j	.L56

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   626  }
.L56:
	ret
.L379:
	
__NvM_Prv_ErrorDetection_IsRamBlockAddressValid_function_end:
	.size	NvM_Prv_ErrorDetection_IsRamBlockAddressValid,__NvM_Prv_ErrorDetection_IsRamBlockAddressValid_function_end-NvM_Prv_ErrorDetection_IsRamBlockAddressValid
.L237:
	; End of function
	
	.sdecl	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsBlockTypeDataset',code,cluster('NvM_Prv_ErrorDetection_IsBlockTypeDataset')
	.sect	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsBlockTypeDataset'
	.align	2
	
	.global	NvM_Prv_ErrorDetection_IsBlockTypeDataset

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   627  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   628  boolean NvM_Prv_ErrorDetection_IsBlockTypeDataset(NvM_Prv_idService_tuo idService_uo,
; Function NvM_Prv_ErrorDetection_IsBlockTypeDataset
.L122:
NvM_Prv_ErrorDetection_IsBlockTypeDataset:	.type	func
	mov	d6,d5
.L510:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   629                                                    NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   630  {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   631      boolean isBlockTypeDataset_b = FALSE;
	mov	d8,#0
.L390:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   392  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   393   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   394   * This NvM private function checks for the given block whether the configured block length is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   395   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   396   * \param idBlock
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   397   * ID of the block for which the block length will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   398   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   399   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   400   * - TRUE = block length is valid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   401   * - FALSE = block length is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   402   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   403  LOCAL_INLINE boolean NvM_Prv_IsBlockLengthValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   404  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   405      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   406              (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   407              (0u != *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   408  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   409  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   410  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   411   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   412   * This NvM private function checks whether the given block is configured with immediate priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   413   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   414   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   415   * ID of the block for which the priority will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   416   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   417   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   418   * - TRUE = block is configured with immediate priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   419   * - FALSE = block is configured with standard priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   420   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   421  LOCAL_INLINE boolean NvM_Prv_HasBlockImmediateJobPriority(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   423      boolean HasBlockImmediateJobPriority_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   425  #if (NVM_JOB_PRIORITIZATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   426      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   427          (NVM_PRV_JOB_PRIORITY_IMMEDIATE == NvM_Prv_BlockDescriptors_acst[idBlock_uo].JobPriority_u8))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   428      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   429          HasBlockImmediateJobPriority_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   430      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   431  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   433  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   434  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   435  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   436   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   437   * This NvM private function returns the configured block size for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   438   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   439   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   440   * ID of the block for which the configured block size will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   441   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   442   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   443   * Configured block size
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   444   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   445  LOCAL_INLINE uint16 NvM_Prv_GetBlockSize(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   446  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   447      uint16 BlockSize_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   448  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   451      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   452          BlockSize_u16 = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   453      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   454  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   455      return BlockSize_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   456  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   457  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   458  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   459   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   460   * This NvM private function returns the configured block management type for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   461   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   462   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   463   * ID of the block for which the configured block management type will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   464   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   465   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   466   * Configured block management type
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   467   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   468  LOCAL_INLINE NvM_BlockManagementType NvM_Prv_GetBlockType(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   469  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   470      NvM_BlockManagementType BlockType = NVM_BLOCK_NATIVE;
	mov	d15,#0
.L511:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
	jge.u	d6,#14,.L57
.L694:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   472      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   473          BlockType = NvM_Prv_BlockDescriptors_acst[idBlock_uo].BlockManagementType_en;
	mul	d15,d6,#48
.L512:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L695:
	addsc.a	a15,a15,d15,#0
.L696:
	ld.w	d15,[a15]40

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
.L57:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   475      return BlockType;      (inlined)
	j	.L58

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   476  }      (inlined)
.L58:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   632      if (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo))
	jne	d15,#2,.L59
.L391:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   633      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   634          isBlockTypeDataset_b = TRUE;
	mov	d8,#1
.L697:
	j	.L60
.L59:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   635      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   636      else
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   637      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   638          NvM_Prv_ReportDetError(idService_uo, NVM_E_PARAM_BLOCK_TYPE, idBlock_uo);
	mov	d5,#11
.L509:
	call	NvM_Prv_ReportDetError
.L60:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   639      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   640      return isBlockTypeDataset_b;
	mov	d2,d8
.L513:
	j	.L61

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   641  }
.L61:
	ret
.L385:
	
__NvM_Prv_ErrorDetection_IsBlockTypeDataset_function_end:
	.size	NvM_Prv_ErrorDetection_IsBlockTypeDataset,__NvM_Prv_ErrorDetection_IsBlockTypeDataset_function_end-NvM_Prv_ErrorDetection_IsBlockTypeDataset
.L242:
	; End of function
	
	.sdecl	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsBlockIdxValid',code,cluster('NvM_Prv_ErrorDetection_IsBlockIdxValid')
	.sect	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsBlockIdxValid'
	.align	2
	
	.global	NvM_Prv_ErrorDetection_IsBlockIdxValid

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   642  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   643  boolean NvM_Prv_ErrorDetection_IsBlockIdxValid(NvM_Prv_idService_tuo idService_uo,
; Function NvM_Prv_ErrorDetection_IsBlockIdxValid
.L124:
NvM_Prv_ErrorDetection_IsBlockIdxValid:	.type	func
	mov	d0,d5
.L516:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   644                                                 NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   645                                                 uint8 idxData_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   646  {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   647      boolean isBlockIdxValid_b = FALSE;
	mov	d8,#0
.L403:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   392  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   393   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   394   * This NvM private function checks for the given block whether the configured block length is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   395   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   396   * \param idBlock
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   397   * ID of the block for which the block length will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   398   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   399   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   400   * - TRUE = block length is valid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   401   * - FALSE = block length is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   402   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   403  LOCAL_INLINE boolean NvM_Prv_IsBlockLengthValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   404  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   405      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   406              (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   407              (0u != *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   408  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   409  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   410  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   411   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   412   * This NvM private function checks whether the given block is configured with immediate priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   413   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   414   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   415   * ID of the block for which the priority will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   416   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   417   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   418   * - TRUE = block is configured with immediate priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   419   * - FALSE = block is configured with standard priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   420   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   421  LOCAL_INLINE boolean NvM_Prv_HasBlockImmediateJobPriority(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   423      boolean HasBlockImmediateJobPriority_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   425  #if (NVM_JOB_PRIORITIZATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   426      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   427          (NVM_PRV_JOB_PRIORITY_IMMEDIATE == NvM_Prv_BlockDescriptors_acst[idBlock_uo].JobPriority_u8))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   428      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   429          HasBlockImmediateJobPriority_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   430      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   431  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   433  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   434  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   435  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   436   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   437   * This NvM private function returns the configured block size for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   438   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   439   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   440   * ID of the block for which the configured block size will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   441   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   442   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   443   * Configured block size
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   444   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   445  LOCAL_INLINE uint16 NvM_Prv_GetBlockSize(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   446  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   447      uint16 BlockSize_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   448  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   451      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   452          BlockSize_u16 = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   453      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   454  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   455      return BlockSize_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   456  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   457  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   458  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   459   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   460   * This NvM private function returns the configured block management type for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   461   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   462   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   463   * ID of the block for which the configured block management type will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   464   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   465   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   466   * Configured block management type
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   467   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   468  LOCAL_INLINE NvM_BlockManagementType NvM_Prv_GetBlockType(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   469  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   470      NvM_BlockManagementType BlockType = NVM_BLOCK_NATIVE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   472      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   473          BlockType = NvM_Prv_BlockDescriptors_acst[idBlock_uo].BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   474      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   475      return BlockType;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   476  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   477  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   478  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   479   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   480   * This NvM private function returns the configured number of non-volatile data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   481   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   482   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   483   * ID of the block for which the configured number of non-volatile data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   484   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   485   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   486   * Configured number of non-volatile data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   487   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   488  LOCAL_INLINE uint8 NvM_Prv_GetNrNonVolatileBlocks(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   489  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   490      uint8 nrNvBlocks_u8 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   491      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   492      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   493          nrNvBlocks_u8 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   494      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   495      return nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   496  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   497  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   498  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   499   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   500   * This NvM private function returns the configured overall number of data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   501   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   502   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   503   * ID of the block for which the configured overall number of data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   504   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   505   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   506   * Configured number of data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   507   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   508  LOCAL_INLINE uint16 NvM_Prv_GetNrDataIndexes(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   509  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   510      uint8 nrDataIndexes = 0;
	mov	d15,#0
.L517:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   511      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
	jge.u	d0,#14,.L62
.L702:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   511      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   512      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   513          nrDataIndexes = (NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8 +
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   514                           NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrRomBlocks_u8);
	mul	d15,d0,#48
.L518:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L703:
	addsc.a	a15,a15,d15,#0
.L704:
	ld.bu	d15,[a15]9
.L705:
	ld.bu	d1,[a15]10
.L706:
	add	d15,d1
	extr.u	d15,d15,#0,#8

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   511      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
.L62:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   516      return nrDataIndexes;      (inlined)
	j	.L63

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   517  }      (inlined)
.L63:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   648      if (idxData_u8 < NvM_Prv_GetNrDataIndexes(idBlock_uo))
	jge.u	d6,d15,.L64
.L404:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   649      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   650          isBlockIdxValid_b = TRUE;
	mov	d8,#1
.L707:
	j	.L65
.L64:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   651      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   652      else
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   653      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   654          NvM_Prv_ReportDetError(idService_uo, NVM_E_PARAM_BLOCK_DATA_IDX, idBlock_uo);
	mov	d5,#12
.L514:
	mov	d6,d0
.L515:
	call	NvM_Prv_ReportDetError
.L65:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   655      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   656      return isBlockIdxValid_b;
	mov	d2,d8
.L519:
	j	.L66

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   657  }
.L66:
	ret
.L397:
	
__NvM_Prv_ErrorDetection_IsBlockIdxValid_function_end:
	.size	NvM_Prv_ErrorDetection_IsBlockIdxValid,__NvM_Prv_ErrorDetection_IsBlockIdxValid_function_end-NvM_Prv_ErrorDetection_IsBlockIdxValid
.L247:
	; End of function
	
	.sdecl	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsBlockPriorityImmediate',code,cluster('NvM_Prv_ErrorDetection_IsBlockPriorityImmediate')
	.sect	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsBlockPriorityImmediate'
	.align	2
	
	.global	NvM_Prv_ErrorDetection_IsBlockPriorityImmediate

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   658  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   659  boolean NvM_Prv_ErrorDetection_IsBlockPriorityImmediate(NvM_Prv_idService_tuo idService_uo,
; Function NvM_Prv_ErrorDetection_IsBlockPriorityImmediate
.L126:
NvM_Prv_ErrorDetection_IsBlockPriorityImmediate:	.type	func
	mov	d6,d5
.L521:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   660                                                          NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   661  {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   662      boolean isBlockPriorityImmediate_b = FALSE;
	mov	d8,#0
.L414:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   392  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   393   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   394   * This NvM private function checks for the given block whether the configured block length is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   395   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   396   * \param idBlock
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   397   * ID of the block for which the block length will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   398   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   399   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   400   * - TRUE = block length is valid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   401   * - FALSE = block length is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   402   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   403  LOCAL_INLINE boolean NvM_Prv_IsBlockLengthValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   404  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   405      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   406              (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   407              (0u != *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   408  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   409  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   410  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   411   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   412   * This NvM private function checks whether the given block is configured with immediate priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   413   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   414   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   415   * ID of the block for which the priority will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   416   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   417   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   418   * - TRUE = block is configured with immediate priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   419   * - FALSE = block is configured with standard priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   420   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   421  LOCAL_INLINE boolean NvM_Prv_HasBlockImmediateJobPriority(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   423      boolean HasBlockImmediateJobPriority_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   425  #if (NVM_JOB_PRIORITIZATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   426      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   427          (NVM_PRV_JOB_PRIORITY_IMMEDIATE == NvM_Prv_BlockDescriptors_acst[idBlock_uo].JobPriority_u8))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   428      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   429          HasBlockImmediateJobPriority_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   430      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   431  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;
	mov	d15,#0

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;      (inlined)
	j	.L67

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   433  }      (inlined)
.L67:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   663      if (NvM_Prv_HasBlockImmediateJobPriority(idBlock_uo))
	jeq	d15,#0,.L68
.L712:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   664      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   665          isBlockPriorityImmediate_b = TRUE;
	mov	d8,#1
.L713:
	j	.L69
.L68:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   666      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   667      else
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   668      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   669          NvM_Prv_ReportDetError(idService_uo, NVM_E_BLOCK_CONFIG, idBlock_uo);
	mov	d5,#24
.L520:
	call	NvM_Prv_ReportDetError
.L69:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   670      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   671      return isBlockPriorityImmediate_b;
	mov	d2,d8
.L522:
	j	.L70

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   672  }
.L70:
	ret
.L409:
	
__NvM_Prv_ErrorDetection_IsBlockPriorityImmediate_function_end:
	.size	NvM_Prv_ErrorDetection_IsBlockPriorityImmediate,__NvM_Prv_ErrorDetection_IsBlockPriorityImmediate_function_end-NvM_Prv_ErrorDetection_IsBlockPriorityImmediate
.L252:
	; End of function
	
	.sdecl	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsBlockWriteProtectionChangeable',code,cluster('NvM_Prv_ErrorDetection_IsBlockWriteProtectionChangeable')
	.sect	'.text.NvM_ErrorDetection.NvM_Prv_ErrorDetection_IsBlockWriteProtectionChangeable'
	.align	2
	
	.global	NvM_Prv_ErrorDetection_IsBlockWriteProtectionChangeable

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   673  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   674  boolean NvM_Prv_ErrorDetection_IsBlockWriteProtectionChangeable(NvM_Prv_idService_tuo idService_uo,
; Function NvM_Prv_ErrorDetection_IsBlockWriteProtectionChangeable
.L128:
NvM_Prv_ErrorDetection_IsBlockWriteProtectionChangeable:	.type	func
	mov	d6,d5
.L524:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   675                                                                  NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   676  {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   677      boolean isBlockWriteProtectionChangeable_b = FALSE;
	mov	d8,#0
.L525:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   678      if (!NvM_Prv_IsBlockSelected(idBlock_uo, NVM_PRV_BLOCK_FLAG_WRITE_ONCE))
	mov	d15,#32
.L424:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
	mov	d0,#0
.L718:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
	jge.u	d6,#14,.L71
.L719:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
	mul	d1,d6,#48
.L720:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L721:
	addsc.a	a15,a15,d1,#0
.L722:
	ld.hu	d1,[a15]46
.L723:
	and	d1,d15
.L724:
	seln	d0,d1,d0,#1

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
.L72:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));      (inlined)
.L71:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
	j	.L73

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }      (inlined)
.L73:
	jne	d0,#0,.L74
.L425:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   679      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   680          isBlockWriteProtectionChangeable_b = TRUE;
	mov	d8,#1
.L725:
	j	.L75
.L74:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   681      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   682      else
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   683      {
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   684          NvM_Prv_ReportDetError(idService_uo, NVM_E_BLOCK_CONFIG, idBlock_uo);
	mov	d5,#24
.L523:
	call	NvM_Prv_ReportDetError
.L75:

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   685      }
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   686      return isBlockWriteProtectionChangeable_b;
	mov	d2,d8
.L526:
	j	.L76

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   687  }
.L76:
	ret
.L419:
	
__NvM_Prv_ErrorDetection_IsBlockWriteProtectionChangeable_function_end:
	.size	NvM_Prv_ErrorDetection_IsBlockWriteProtectionChangeable,__NvM_Prv_ErrorDetection_IsBlockWriteProtectionChangeable_function_end-NvM_Prv_ErrorDetection_IsBlockWriteProtectionChangeable
.L257:
	; End of function
	
	.sdecl	'.bss.NvM_ErrorDetection.NvM_Rb_stBlockErrors_au8',data,cluster('NvM_Rb_stBlockErrors_au8')
	.sect	'.bss.NvM_ErrorDetection.NvM_Rb_stBlockErrors_au8'
	.global	NvM_Rb_stBlockErrors_au8
NvM_Rb_stBlockErrors_au8:	.type	object
	.size	NvM_Rb_stBlockErrors_au8,14
	.space	14
	.sdecl	'.bss.NvM_ErrorDetection.NvM_Prv_idLastDetError_uo',data,cluster('NvM_Prv_idLastDetError_uo')
	.sect	'.bss.NvM_ErrorDetection.NvM_Prv_idLastDetError_uo'
	.global	NvM_Prv_idLastDetError_uo
NvM_Prv_idLastDetError_uo:	.type	object
	.size	NvM_Prv_idLastDetError_uo,1
	.space	1
	.sdecl	'.bss.NvM_ErrorDetection.NvM_Prv_idServiceLastDetError_uo',data,cluster('NvM_Prv_idServiceLastDetError_uo')
	.sect	'.bss.NvM_ErrorDetection.NvM_Prv_idServiceLastDetError_uo'
	.global	NvM_Prv_idServiceLastDetError_uo
NvM_Prv_idServiceLastDetError_uo:	.type	object
	.size	NvM_Prv_idServiceLastDetError_uo,1
	.space	1
	.sdecl	'.bss.NvM_ErrorDetection.NvM_Prv_idBlockLastDetError_uo',data,cluster('NvM_Prv_idBlockLastDetError_uo')
	.sect	'.bss.NvM_ErrorDetection.NvM_Prv_idBlockLastDetError_uo'
	.global	NvM_Prv_idBlockLastDetError_uo
	.align	2
NvM_Prv_idBlockLastDetError_uo:	.type	object
	.size	NvM_Prv_idBlockLastDetError_uo,2
	.space	2
	.calls	'NvM_Prv_ReportDetError','Det_ReportError'
	.calls	'NvM_Prv_ErrorDetection_IsBlockPending','NvM_Prv_ReportDetError'
	.calls	'NvM_Prv_ErrorDetection_IsServiceBitValid','NvM_Prv_ReportDetError'
	.calls	'NvM_Prv_ErrorDetection_IsJobIdValid','NvM_Prv_ReportDetError'
	.calls	'NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible','NvM_Prv_ReportDetError'
	.calls	'NvM_Prv_ErrorDetection_IsBlockSizeValidForExplicitSync','NvM_Prv_ReportDetError'
	.calls	'NvM_Prv_ErrorDetection_IsPtrValidForDataIdx','NvM_Prv_ReportDetError'
	.calls	'NvM_Prv_ErrorDetection_IsPtrValidForRequestResult','NvM_Prv_ReportDetError'
	.calls	'NvM_Prv_ErrorDetection_IsPtrValidForMigrationResult','NvM_Prv_ReportDetError'
	.calls	'NvM_Prv_ErrorDetection_IsPtrValidForNvmStatus','NvM_Prv_ReportDetError'
	.calls	'NvM_Prv_ErrorDetection_IsPtrValidForBlockLength','NvM_Prv_ReportDetError'
	.calls	'NvM_Prv_ErrorDetection_IsPtrValidForServiceId','NvM_Prv_ReportDetError'
	.calls	'NvM_Prv_ErrorDetection_IsPtrValidForBlockId','NvM_Prv_ReportDetError'
	.calls	'NvM_Prv_ErrorDetection_IsPtrValidForVersionInfo','NvM_Prv_ReportDetError'
	.calls	'NvM_Prv_ErrorDetection_IsNvmInitialized','NvM_Prv_IsNvmInitialized'
	.calls	'NvM_Prv_ErrorDetection_IsNvmInitialized','NvM_Prv_ReportDetError'
	.calls	'NvM_Prv_ErrorDetection_IsBlockIdValid','NvM_Prv_ReportDetError'
	.calls	'NvM_Prv_ErrorDetection_IsDefaultDataAvailable','NvM_Prv_ReportDetError'
	.calls	'NvM_Prv_ErrorDetection_IsRamBlockAddressValid','NvM_Prv_ReportDetError'
	.calls	'NvM_Prv_ErrorDetection_IsBlockTypeDataset','NvM_Prv_ReportDetError'
	.calls	'NvM_Prv_ErrorDetection_IsBlockIdxValid','NvM_Prv_ReportDetError'
	.calls	'NvM_Prv_ErrorDetection_IsBlockPriorityImmediate','NvM_Prv_ReportDetError'
	.calls	'NvM_Prv_ErrorDetection_IsBlockWriteProtectionChangeable','NvM_Prv_ReportDetError'
	.calls	'NvM_Rb_GetBlockIdCausingLastDetError','',0
	.calls	'NvM_Prv_ReportDetError','',0
	.calls	'NvM_Prv_ErrorDetection_InitializeDetError','',0
	.calls	'NvM_Prv_ErrorDetection_InitializeProductionErrors','',0
	.calls	'NvM_Prv_ErrorDetection_SetProductionError','',0
	.calls	'NvM_Prv_ErrorDetection_IsBlockPending','',0
	.calls	'NvM_Prv_ErrorDetection_IsServiceBitValid','',0
	.calls	'NvM_Prv_ErrorDetection_IsJobIdValid','',0
	.calls	'NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible','',0
	.calls	'NvM_Prv_ErrorDetection_IsBlockSizeValidForExplicitSync','',0
	.calls	'NvM_Prv_ErrorDetection_IsPtrValidForDataIdx','',0
	.calls	'NvM_Prv_ErrorDetection_IsPtrValidForRequestResult','',0
	.calls	'NvM_Prv_ErrorDetection_IsPtrValidForMigrationResult','',0
	.calls	'NvM_Prv_ErrorDetection_IsPtrValidForNvmStatus','',0
	.calls	'NvM_Prv_ErrorDetection_IsPtrValidForBlockLength','',0
	.calls	'NvM_Prv_ErrorDetection_IsPtrValidForServiceId','',0
	.calls	'NvM_Prv_ErrorDetection_IsPtrValidForBlockId','',0
	.calls	'NvM_Prv_ErrorDetection_IsPtrValidForVersionInfo','',0
	.calls	'NvM_Prv_ErrorDetection_IsNvmInitialized','',0
	.calls	'NvM_Prv_ErrorDetection_IsBlockIdValid','',0
	.calls	'NvM_Prv_ErrorDetection_IsDefaultDataAvailable','',0
	.calls	'NvM_Prv_ErrorDetection_IsRamBlockAddressValid','',0
	.calls	'NvM_Prv_ErrorDetection_IsBlockTypeDataset','',0
	.calls	'NvM_Prv_ErrorDetection_IsBlockIdxValid','',0
	.calls	'NvM_Prv_ErrorDetection_IsBlockPriorityImmediate','',0
	.extern	NvM_Prv_IsNvmInitialized
	.extern	NvM_Prv_BlockDescriptors_acst
	.extern	Det_ReportError
	.calls	'NvM_Prv_ErrorDetection_IsBlockWriteProtectionChangeable','',0
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L130:
	.word	12164
	.half	3
	.word	.L131
	.byte	4
.L129:
	.byte	1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L132
.L274:
	.byte	2
	.byte	'unsigned char',0,1,8
.L271:
	.byte	2
	.byte	'unsigned short int',0,2,7,3,1,34,9,4,4
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL',0,1,4
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL',0,2,4
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL',0,4,4
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE',0,8,4
	.byte	'NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED',0,16,4
	.byte	'NVM_PRV_BLOCK_FLAG_WRITE_ONCE',0,32,4
	.byte	'NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW',0,192,0,4
	.byte	'NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM',0,128,1,4
	.byte	'NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION',0,128,2,4
	.byte	'NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH',0,128,4,4
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION',0,128,8,4
	.byte	'NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL',0,128,16,0
.L423:
	.byte	5
	.byte	'NvM_Prv_IsBlockSelected',0,3,1,239,2,22
	.word	144
	.byte	1,1
.L426:
	.byte	6
	.byte	'idBlock_uo',0,1,239,2,62
	.word	161
.L428:
	.byte	6
	.byte	'SelectionMask_en',0,1,240,2,77
	.word	183
.L430:
	.byte	7,0
.L373:
	.byte	5
	.byte	'NvM_Prv_IsDefaultDataAvailable',0,3,1,129,3,22
	.word	144
	.byte	1,1
.L376:
	.byte	6
	.byte	'idBlock_uo',0,1,129,3,69
	.word	161
.L378:
	.byte	7,0
.L413:
	.byte	5
	.byte	'NvM_Prv_HasBlockImmediateJobPriority',0,3,1,165,3,22
	.word	144
	.byte	1,1
.L415:
	.byte	6
	.byte	'idBlock_uo',0,1,165,3,75
	.word	161
.L417:
	.byte	7,0
.L308:
	.byte	5
	.byte	'NvM_Prv_GetBlockSize',0,3,1,189,3,21
	.word	161
	.byte	1,1
.L311:
	.byte	6
	.byte	'idBlock_uo',0,1,189,3,58
	.word	161
.L313:
	.byte	7,0
.L395:
	.byte	3,2,40,9,4,4
	.byte	'NVM_BLOCK_NATIVE',0,0,4
	.byte	'NVM_BLOCK_REDUNDANT',0,1,4
	.byte	'NVM_BLOCK_DATASET',0,2,0
.L389:
	.byte	5
	.byte	'NvM_Prv_GetBlockType',0,3,1,212,3,38
	.word	982
	.byte	1,1
.L392:
	.byte	6
	.byte	'idBlock_uo',0,1,212,3,75
	.word	161
.L394:
	.byte	7,0,5
	.byte	'NvM_Prv_GetNrNonVolatileBlocks',0,3,1,232,3,20
	.word	144
	.byte	1,1,6
	.byte	'idBlock_uo',0,1,232,3,67
	.word	161
	.byte	7,0
.L402:
	.byte	5
	.byte	'NvM_Prv_GetNrDataIndexes',0,3,1,252,3,21
	.word	161
	.byte	1,1
.L405:
	.byte	6
	.byte	'idBlock_uo',0,1,252,3,62
	.word	161
.L407:
	.byte	7,0,8
	.byte	'void',0,9
	.word	1228
.L382:
	.byte	10
	.word	1234
	.byte	5
	.byte	'NvM_Prv_GetRomBlockAddress',0,3,1,173,4,26
	.word	1239
	.byte	1,1,6
	.byte	'idBlock_uo',0,1,173,4,69
	.word	161
	.byte	7,0,5
	.byte	'NvM_Prv_Block_IsInRom',0,3,3,142,1,22
	.word	144
	.byte	1,1,6
	.byte	'idBlock_uo',0,3,142,1,60
	.word	161
	.byte	6
	.byte	'idxDataset_u8',0,3,142,1,78
	.word	144
	.byte	11,7,7,0,0,5
	.byte	'NvM_Prv_Block_IsWriteProtected',0,3,3,148,1,22
	.word	144
	.byte	1,1,6
	.byte	'idBlock_uo',0,3,148,1,69
	.word	161
	.byte	7,0,12
	.byte	'NvM_Prv_IsNvmInitialized',0,4,99,16
	.word	144
	.byte	1,1,1,1,13
	.word	707
	.byte	14
	.word	743
	.byte	14
	.word	763
	.byte	7,0,13
	.word	791
	.byte	14
	.word	834
	.byte	7,0,13
	.word	856
	.byte	14
	.word	905
	.byte	7,0,13
	.word	927
	.byte	14
	.word	960
	.byte	7,0,13
	.word	1049
	.byte	14
	.word	1082
	.byte	7,0,13
	.word	1104
	.byte	14
	.word	1147
	.byte	7,0,13
	.word	1169
	.byte	14
	.word	1206
	.byte	7,0,13
	.word	1244
	.byte	14
	.word	1283
	.byte	7,0,13
	.word	1305
	.byte	14
	.word	1339
	.byte	14
	.word	1359
	.byte	11,15
	.word	1049
	.byte	14
	.word	1082
	.byte	16
	.word	1102
	.byte	0,7,15
	.word	1104
	.byte	14
	.word	1147
	.byte	16
	.word	1167
	.byte	0,7,0,0,13
	.word	1387
	.byte	14
	.word	1430
	.byte	7,0
.L293:
	.byte	3,2,104,9,4,4
	.byte	'NvM_Prv_idJob_Idle_e',0,0,4
	.byte	'NvM_Prv_idJob_Read_e',0,1,4
	.byte	'NvM_Prv_idJob_Write_e',0,2,4
	.byte	'NvM_Prv_idJob_Erase_e',0,3,4
	.byte	'NvM_Prv_idJob_Restore_e',0,4,4
	.byte	'NvM_Prv_idJob_Maintain_e',0,5,4
	.byte	'NvM_Prv_idJob_Validate_e',0,6,4
	.byte	'NvM_Prv_idJob_Invalidate_e',0,7,4
	.byte	'NvM_Prv_idJob_ReadIdConfigForReadAll_e',0,8,4
	.byte	'NvM_Prv_idJob_InvalidateForFirstInitAll_e',0,9,4
	.byte	'NvM_Prv_idJob_RestoreForImplicitRecovery_e',0,10,4
	.byte	'NvM_Prv_idJob_InvalidateForRemoveNonResistant_e',0,11,4
	.byte	'NvM_Prv_idJob_Invalid_e',0,12,4
	.byte	'NvM_Prv_idJob_Count_e',0,13,0
.L299:
	.byte	3,5,31,9,4,4
	.byte	'MEMIF_JOB_OK',0,0,4
	.byte	'MEMIF_JOB_FAILED',0,1,4
	.byte	'MEMIF_JOB_PENDING',0,2,4
	.byte	'MEMIF_JOB_CANCELED',0,3,4
	.byte	'MEMIF_BLOCK_INCONSISTENT',0,4,4
	.byte	'MEMIF_BLOCK_INVALID',0,5,0
.L305:
	.byte	2
	.byte	'unsigned int',0,4,7,9
	.word	144
.L318:
	.byte	10
	.word	2239
	.byte	9
	.word	144
.L324:
	.byte	10
	.word	2249
	.byte	3,2,21,9,4,4
	.byte	'NVM_RB_MIGRATION_RESULT_INIT_E',0,0,4
	.byte	'NVM_RB_MIGRATION_RESULT_NOT_NECESSARY_E',0,1,4
	.byte	'NVM_RB_MIGRATION_RESULT_TO_SMALLER_SIZE_E',0,2,4
	.byte	'NVM_RB_MIGRATION_RESULT_TO_BIGGER_SIZE_E',0,3,4
	.byte	'NVM_RB_MIGRATION_RESULT_NOT_DONE_E',0,4,4
	.byte	'NVM_RB_MIGRATION_RESULT_DEACTIVATED_E',0,5,0,9
	.word	2259
.L330:
	.byte	10
	.word	2504
	.byte	3,2,32,9,4,4
	.byte	'NVM_RB_STATUS_UNINIT',0,0,4
	.byte	'NVM_RB_STATUS_IDLE',0,1,4
	.byte	'NVM_RB_STATUS_BUSY',0,2,0,9
	.word	2514
.L335:
	.byte	10
	.word	2585
	.byte	9
	.word	161
.L341:
	.byte	10
	.word	2595
	.byte	9
	.word	144
.L346:
	.byte	10
	.word	2605
	.byte	9
	.word	161
.L351:
	.byte	10
	.word	2615
	.byte	17,6,206,1,9,8,18
	.byte	'vendorID',0
	.word	161
	.byte	2,2,35,0,18
	.byte	'moduleID',0
	.word	161
	.byte	2,2,35,2,18
	.byte	'sw_major_version',0
	.word	144
	.byte	1,2,35,4,18
	.byte	'sw_minor_version',0
	.word	144
	.byte	1,2,35,5,18
	.byte	'sw_patch_version',0
	.word	144
	.byte	1,2,35,6,0,9
	.word	2625
.L356:
	.byte	10
	.word	2746
	.byte	19
	.byte	'Det_ReportError',0,7,112,16
	.word	144
	.byte	1,1,1,1,6
	.byte	'ModuleId',0,7,112,39
	.word	161
	.byte	6
	.byte	'InstanceId',0,7,112,55
	.word	144
	.byte	6
	.byte	'ApiId',0,7,112,73
	.word	144
	.byte	6
	.byte	'ErrorId',0,7,112,86
	.word	144
	.byte	0,20,1,10
	.word	2851
	.byte	21
	.byte	'__codeptr',0,8,1,1
	.word	2853
	.byte	2
	.byte	'char',0,1,6,21
	.byte	'sint8',0,9,76,25
	.word	2876
	.byte	21
	.byte	'uint8',0,9,81,25
	.word	144
	.byte	21
	.byte	'uint16',0,9,91,25
	.word	161
	.byte	21
	.byte	'uint32',0,9,106,24
	.word	2223
	.byte	2
	.byte	'unsigned long long int',0,8,7,21
	.byte	'uint64',0,9,111,30
	.word	2942
	.byte	21
	.byte	'boolean',0,9,127,25
	.word	144
	.byte	21
	.byte	'StatusType',0,6,191,1,27
	.word	144
	.byte	21
	.byte	'Std_ReturnType',0,6,199,1,15
	.word	144
	.byte	21
	.byte	'Std_VersionInfoType',0,6,213,1,3
	.word	2625
	.byte	21
	.byte	'PduIdType',0,10,22,19
	.word	161
	.byte	21
	.byte	'PduLengthType',0,10,26,19
	.word	161
	.byte	3,11,113,9,4,4
	.byte	'TP_DATACONF',0,0,4
	.byte	'TP_DATARETRY',0,1,4
	.byte	'TP_CONFPENDING',0,2,0,21
	.byte	'TpDataStateType',0,11,118,3
	.word	3112
	.byte	21
	.byte	'Can_IdType',0,12,32,16
	.word	2223
	.byte	21
	.byte	'Can_HwHandleType',0,12,43,16
	.word	161
	.byte	17,13,93,9,8,18
	.byte	'Class',0
	.word	144
	.byte	1,2,35,0,18
	.byte	'TIN',0
	.word	144
	.byte	1,2,35,1,18
	.byte	'ReturnAddress',0
	.word	2223
	.byte	4,2,35,4,0,21
	.byte	'OsTrapInfoType',0,13,97,3
	.word	3232
	.byte	22,68
	.word	2223
	.byte	23,16,0,17,13,154,1,9,68,18
	.byte	'store',0
	.word	3312
	.byte	68,2,35,0,0,22,68
	.word	3321
	.byte	23,0,0,21
	.byte	'Os_JumpBufType',0,13,156,1,3
	.word	3343
	.byte	21
	.byte	'Os_StackTraceType',0,13,174,1,18
	.word	2223
	.byte	17,13,175,1,9,8,18
	.byte	'sp',0
	.word	2223
	.byte	4,2,35,0,18
	.byte	'ctx',0
	.word	2223
	.byte	4,2,35,4,0,21
	.byte	'Os_StackValueType',0,13,175,1,63
	.word	3403
	.byte	21
	.byte	'Os_StackSizeType',0,13,176,1,27
	.word	3403
	.byte	24,1,1,10
	.word	3488
	.byte	21
	.byte	'Os_VoidVoidFunctionType',0,13,179,1,16
	.word	3491
	.byte	21
	.byte	'ApplicationType',0,13,193,1,23
	.word	144
	.byte	25
	.byte	'Os_ApplicationConfigurationType_s',0,13,198,1,16,2,18
	.byte	'app_id',0
	.word	144
	.byte	1,2,35,0,18
	.byte	'access',0
	.word	144
	.byte	1,2,35,1,0,21
	.byte	'Os_ApplicationConfigurationType',0,13,201,1,3
	.word	3554
	.byte	21
	.byte	'Os_CoreStateType',0,13,203,1,16
	.word	2223
	.byte	21
	.byte	'AreaIdType',0,13,204,1,16
	.word	161
	.byte	21
	.byte	'Os_PeripheralAddressType',0,13,212,1,22
	.word	2223
	.byte	21
	.byte	'TickType',0,13,221,1,22
	.word	2223
	.byte	21
	.byte	'Os_StopwatchTickType',0,13,225,1,22
	.word	2223
	.byte	10
	.word	2223
	.byte	21
	.byte	'Os_Lockable',0,13,234,1,18
	.word	3796
	.byte	21
	.byte	'CoreIdType',0,13,236,1,16
	.word	161
	.byte	21
	.byte	'SpinlockIdType',0,13,237,1,16
	.word	161
	.byte	3,13,239,1,9,4,4
	.byte	'TRYTOGETSPINLOCK_SUCCESS',0,0,4
	.byte	'TRYTOGETSPINLOCK_NOSUCCESS',0,1,0,21
	.byte	'TryToGetSpinlockType',0,13,239,1,74
	.word	3866
	.byte	3,13,174,2,9,4,4
	.byte	'APPLICATION_ACCESSIBLE',0,0,4
	.byte	'APPLICATION_RESTARTING',0,1,4
	.byte	'APPLICATION_TERMINATED',0,2,0,21
	.byte	'ApplicationStateType',0,13,174,2,92
	.word	3959
	.byte	10
	.word	1228
	.byte	26,1,1,27
	.word	144
	.byte	27
	.word	4071
	.byte	0,10
	.word	4076
	.byte	21
	.byte	'Os_FunctionEntryType',0,13,183,2,16
	.word	4090
	.byte	25
	.byte	'Os_MeterInfoType_s',0,13,193,2,16,48,18
	.byte	'elapsed',0
	.word	2223
	.byte	4,2,35,0,18
	.byte	'previous',0
	.word	2223
	.byte	4,2,35,4,18
	.byte	'max',0
	.word	2223
	.byte	4,2,35,8,18
	.byte	'cumulative',0
	.word	2223
	.byte	4,2,35,12,18
	.byte	'stackbase',0
	.word	3403
	.byte	8,2,35,16,18
	.byte	'stackusage',0
	.word	3403
	.byte	8,2,35,24,18
	.byte	'stackmax',0
	.word	3403
	.byte	8,2,35,32,18
	.byte	'stackbudget',0
	.word	3403
	.byte	8,2,35,40,0,21
	.byte	'Os_MeterInfoType',0,13,202,2,3
	.word	4125
	.byte	10
	.word	4125
	.byte	21
	.byte	'Os_MeterInfoRefType',0,13,203,2,50
	.word	4323
	.byte	21
	.byte	'EventMaskType',0,13,206,2,15
	.word	144
	.byte	21
	.byte	'Os_imaskType',0,13,211,2,16
	.word	2223
	.byte	25
	.byte	'Os_ISRDynType_s',0,13,213,2,16,48,18
	.byte	'meter',0
	.word	4125
	.byte	48,2,35,0,0,21
	.byte	'Os_ISRDynType',0,13,215,2,3
	.word	4402
	.byte	10
	.word	4402
	.byte	9
	.word	4463
	.byte	25
	.byte	'Os_ISRType_s',0,13,216,2,16,24,18
	.byte	'entry_function',0
	.word	3496
	.byte	4,2,35,0,18
	.byte	'dynamic',0
	.word	4468
	.byte	4,2,35,4,18
	.byte	'imask',0
	.word	2223
	.byte	4,2,35,8,18
	.byte	'stackbudget',0
	.word	3403
	.byte	8,2,35,12,18
	.byte	'access',0
	.word	144
	.byte	1,2,35,20,18
	.byte	'application',0
	.word	144
	.byte	1,2,35,21,0,21
	.byte	'Os_ISRType',0,13,223,2,3
	.word	4473
	.byte	10
	.word	3488
	.byte	9
	.word	4473
	.byte	10
	.word	4632
	.byte	21
	.byte	'ISRType',0,13,224,2,46
	.word	4637
	.byte	21
	.byte	'Os_bitmask',0,13,239,2,22
	.word	2223
	.byte	21
	.byte	'Os_pset0Type',0,13,240,2,20
	.word	2223
	.byte	21
	.byte	'Os_pset1Type',0,13,241,2,20
	.word	2223
	.byte	21
	.byte	'Os_pset2Type',0,13,242,2,20
	.word	2223
	.byte	28,13,243,2,9,4,18
	.byte	'p0',0
	.word	2223
	.byte	4,2,35,0,18
	.byte	'p1',0
	.word	2223
	.byte	4,2,35,0,18
	.byte	'p2',0
	.word	2223
	.byte	4,2,35,0,0,21
	.byte	'Os_psetType',0,13,247,2,3
	.word	4745
	.byte	28,13,249,2,9,4,18
	.byte	't0',0
	.word	2223
	.byte	4,2,35,0,18
	.byte	't1',0
	.word	2223
	.byte	4,2,35,0,18
	.byte	't2',0
	.word	2223
	.byte	4,2,35,0,0,21
	.byte	'Os_tpmaskType',0,13,253,2,3
	.word	4809
	.byte	21
	.byte	'Os_ActivationCountType',0,13,254,2,23
	.word	144
	.byte	25
	.byte	'Os_TaskDynType_s',0,13,128,3,16,120,18
	.byte	'terminate_jump_buf',0
	.word	3352
	.byte	68,2,35,0,18
	.byte	'meter',0
	.word	4125
	.byte	48,2,35,68,18
	.byte	'activation_count',0
	.word	144
	.byte	1,2,35,116,0,21
	.byte	'Os_TaskDynType',0,13,132,3,3
	.word	4907
	.byte	22,68
	.word	3321
	.byte	23,0,0,10
	.word	4907
	.byte	9
	.word	5033
	.byte	25
	.byte	'Os_TaskType_s',0,13,134,3,16,40,18
	.byte	'dynamic',0
	.word	5038
	.byte	4,2,35,0,18
	.byte	'entry_function',0
	.word	3496
	.byte	4,2,35,4,18
	.byte	'pset',0
	.word	4745
	.byte	4,2,35,8,18
	.byte	'base_tpmask',0
	.word	4809
	.byte	4,2,35,12,18
	.byte	'tpmask',0
	.word	4809
	.byte	4,2,35,16,18
	.byte	'core_id',0
	.word	161
	.byte	2,2,35,20,18
	.byte	'index',0
	.word	2223
	.byte	4,2,35,24,18
	.byte	'stackbudget',0
	.word	3403
	.byte	8,2,35,28,18
	.byte	'activation_count',0
	.word	144
	.byte	1,2,35,36,18
	.byte	'access',0
	.word	144
	.byte	1,2,35,37,18
	.byte	'application',0
	.word	144
	.byte	1,2,35,38,0,21
	.byte	'Os_TaskType',0,13,146,3,3
	.word	5043
	.byte	9
	.word	5043
	.byte	10
	.word	5293
	.byte	21
	.byte	'TaskType',0,13,147,3,47
	.word	5298
	.byte	29
	.byte	'Os_TaskStateType',0,13,155,3,6,4,4
	.byte	'SUSPENDED',0,0,4
	.byte	'READY',0,1,4
	.byte	'WAITING',0,2,4
	.byte	'RUNNING',0,3,0,21
	.byte	'TaskStateType',0,13,156,3,31
	.word	5321
	.byte	28,13,167,3,3,4,18
	.byte	'tpmask',0
	.word	4809
	.byte	4,2,35,0,0,25
	.byte	'Os_ResourceDynType_s',0,13,166,3,16,4,18
	.byte	'saved_priority',0
	.word	5408
	.byte	4,2,35,0,0,21
	.byte	'Os_ResourceDynType',0,13,170,3,3
	.word	5431
	.byte	10
	.word	5431
	.byte	9
	.word	5511
	.byte	25
	.byte	'Os_ResourceType_s',0,13,171,3,16,12,18
	.byte	'dynamic',0
	.word	5516
	.byte	4,2,35,0,18
	.byte	'tpmask',0
	.word	4809
	.byte	4,2,35,4,18
	.byte	'access',0
	.word	144
	.byte	1,2,35,8,0,21
	.byte	'Os_ResourceType',0,13,175,3,3
	.word	5521
	.byte	17,13,181,3,9,12,18
	.byte	'maxallowedvalue',0
	.word	2223
	.byte	4,2,35,0,18
	.byte	'ticksperbase',0
	.word	2223
	.byte	4,2,35,4,18
	.byte	'mincycle',0
	.word	2223
	.byte	4,2,35,8,0,21
	.byte	'AlarmBaseType',0,13,185,3,3
	.word	5620
	.byte	17,13,206,3,9,8,18
	.byte	'Running',0
	.word	144
	.byte	1,2,35,0,18
	.byte	'Pending',0
	.word	144
	.byte	1,2,35,1,18
	.byte	'Delay',0
	.word	2223
	.byte	4,2,35,4,0,21
	.byte	'Os_CounterStatusType',0,13,210,3,3
	.word	5715
	.byte	30
	.word	144
	.byte	1,1,10
	.word	5801
	.byte	21
	.byte	'Os_CounterIncrAdvType',0,13,217,3,22
	.word	5808
	.byte	25
	.byte	's_swd',0,13,222,3,12,4,18
	.byte	'count',0
	.word	2223
	.byte	4,2,35,0,0,28,13,221,3,3,4,18
	.byte	'sw',0
	.word	5844
	.byte	4,2,35,0,0,25
	.byte	'Os_CounterDynType_s',0,13,220,3,16,4,18
	.byte	'type_dependent',0
	.word	5872
	.byte	4,2,35,0,0,21
	.byte	'Os_CounterDynType',0,13,226,3,3
	.word	5891
	.byte	10
	.word	5891
	.byte	9
	.word	5969
	.byte	25
	.byte	'Os_CounterType_s',0,13,227,3,16,28,18
	.byte	'dynamic',0
	.word	5974
	.byte	4,2,35,0,18
	.byte	'advincr',0
	.word	5813
	.byte	4,2,35,4,18
	.byte	'base',0
	.word	5620
	.byte	12,2,35,8,18
	.byte	'core',0
	.word	4071
	.byte	4,2,35,20,18
	.byte	'access',0
	.word	144
	.byte	1,2,35,24,18
	.byte	'application',0
	.word	144
	.byte	1,2,35,25,0,21
	.byte	'Os_CounterType',0,13,234,3,3
	.word	5979
	.byte	10
	.word	5801
	.byte	9
	.word	5979
	.byte	10
	.word	6131
	.byte	21
	.byte	'CounterType',0,13,235,3,52
	.word	6136
	.byte	29
	.byte	'Os_ScheduleTableStatusType',0,13,240,3,6,4,4
	.byte	'SCHEDULETABLE_STOPPED',0,0,4
	.byte	'SCHEDULETABLE_NEXT',0,1,4
	.byte	'SCHEDULETABLE_WAITING',0,2,4
	.byte	'SCHEDULETABLE_RUNNING',0,3,4
	.byte	'SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS',0,4,0,21
	.byte	'ScheduleTableStatusType',0,13,241,3,41
	.word	6162
	.byte	9
	.word	.L527-.L130
	.byte	10
	.word	6362
	.byte	21
	.byte	'ScheduleTableType',0,13,128,4,58
	.word	6367
	.byte	25
	.byte	'Os_ScheduleTableDynType_s',0,13,130,4,16,16,18
	.byte	'match',0
	.word	2223
	.byte	4,2,35,0,18
	.byte	'next',0
	.word	6372
	.byte	4,2,35,4,18
	.byte	'state',0
	.word	6162
	.byte	4,2,35,8,18
	.byte	'config',0
	.word	161
	.byte	2,2,35,12,0,10
	.word	6399
	.byte	9
	.word	6492
.L527:
	.byte	25
	.byte	'Os_ScheduleTableType_s',0,13,247,3,16,16,18
	.byte	'dynamic',0
	.word	6497
	.byte	4,2,35,0,18
	.byte	'counter',0
	.word	6141
	.byte	4,2,35,4,18
	.byte	'repeat',0
	.word	144
	.byte	1,2,35,8,18
	.byte	'config',0
	.word	161
	.byte	2,2,35,10,18
	.byte	'initial',0
	.word	144
	.byte	1,2,35,12,18
	.byte	'access',0
	.word	144
	.byte	1,2,35,13,18
	.byte	'application',0
	.word	144
	.byte	1,2,35,14,0,21
	.byte	'Os_ScheduleTableType',0,13,255,3,3
	.word	6502
	.byte	9
	.word	6502
	.byte	10
	.word	6682
	.byte	9
	.word	5979
	.byte	10
	.word	6692
	.byte	31
	.word	3801
	.byte	31
	.word	4745
	.byte	31
	.word	4642
	.byte	31
	.word	5303
	.byte	31
	.word	4809
	.byte	31
	.word	144
	.byte	31
	.word	5303
	.byte	25
	.byte	'Os_ControlledCoreType_s',0,13,251,6,16,112,18
	.byte	'TrapInfo',0
	.word	3232
	.byte	8,2,35,0,18
	.byte	'lock_taskaccess',0
	.word	6702
	.byte	4,2,35,8,18
	.byte	'ReadyTasks',0
	.word	6707
	.byte	4,2,35,12,18
	.byte	'RunningISR',0
	.word	6712
	.byte	4,2,35,16,18
	.byte	'RunningTask',0
	.word	6717
	.byte	4,2,35,20,18
	.byte	'RunningTPMask',0
	.word	6722
	.byte	4,2,35,24,18
	.byte	'CurrentMeteredObject',0
	.word	4328
	.byte	4,2,35,28,18
	.byte	'IdleMeter',0
	.word	4125
	.byte	48,2,35,32,18
	.byte	'AppAccess',0
	.word	144
	.byte	1,2,35,80,18
	.byte	'AppOverride',0
	.word	6727
	.byte	1,2,35,81,18
	.byte	'GetStackValueAdjust',0
	.word	3403
	.byte	8,2,35,84,18
	.byte	'InErrorHook',0
	.word	144
	.byte	1,2,35,92,18
	.byte	'ChainTaskRef',0
	.word	6732
	.byte	4,2,35,96,18
	.byte	'GetStackUsageAdjust',0
	.word	3403
	.byte	8,2,35,100,18
	.byte	'InProtectionHook',0
	.word	144
	.byte	1,2,35,108,18
	.byte	'CoreIsActive',0
	.word	144
	.byte	1,2,35,109,18
	.byte	'InShutdownHook',0
	.word	144
	.byte	1,2,35,110,0,21
	.byte	'Os_ControlledCoreType',0,13,141,7,3
	.word	6737
	.byte	10
	.word	2223
	.byte	9
	.word	4473
	.byte	10
	.word	7193
	.byte	9
	.word	5043
	.byte	10
	.word	7203
	.byte	10
	.word	4125
	.byte	25
	.byte	'Os_AnyCoreType_s',0,13,151,7,16,96,18
	.byte	'DisableAllImask',0
	.word	2223
	.byte	4,2,35,0,18
	.byte	'SuspendAllImask',0
	.word	2223
	.byte	4,2,35,4,18
	.byte	'SuspendOSImask',0
	.word	2223
	.byte	4,2,35,8,18
	.byte	'DisableAllCount',0
	.word	2223
	.byte	4,2,35,12,18
	.byte	'SuspendAllCount',0
	.word	2223
	.byte	4,2,35,16,18
	.byte	'SuspendOSCount',0
	.word	2223
	.byte	4,2,35,20,18
	.byte	'RestartJumpBuf',0
	.word	3352
	.byte	68,2,35,24,18
	.byte	'Restartable',0
	.word	144
	.byte	1,2,35,92,0,21
	.byte	'Os_AnyCoreType',0,13,160,7,3
	.word	7218
	.byte	21
	.byte	'Can_TxObjPriorityClassType',0,14,219,3,16
	.word	2223
	.byte	25
	.byte	'Can_TxHwObjectConfigType',0,14,231,3,16,8,18
	.byte	'MsgObjId',0
	.word	144
	.byte	1,2,35,0,18
	.byte	'HwControllerId',0
	.word	144
	.byte	1,2,35,1,18
	.byte	'TxObjPriorityClass',0
	.word	2223
	.byte	4,2,35,4,0,21
	.byte	'Can_TxHwObjectConfigType',0,14,252,3,3
	.word	7495
	.byte	25
	.byte	'Can_RxHwObjectConfigType',0,14,129,4,16,12,18
	.byte	'MaskRef',0
	.word	2223
	.byte	4,2,35,0,18
	.byte	'MsgId',0
	.word	2223
	.byte	4,2,35,4,18
	.byte	'MsgObjId',0
	.word	144
	.byte	1,2,35,8,18
	.byte	'HwControllerId',0
	.word	144
	.byte	1,2,35,9,0,21
	.byte	'Can_RxHwObjectConfigType',0,14,147,4,3
	.word	7631
	.byte	22,4
	.word	144
	.byte	23,3,0,25
	.byte	'Can_ControllerMOMapConfigType',0,14,181,4,16,4,18
	.byte	'ControllerMOMap',0
	.word	7771
	.byte	4,2,35,0,0,21
	.byte	'Can_ControllerMOMapConfigType',0,14,184,4,3
	.word	7780
	.byte	25
	.byte	'Can_NPCRValueType',0,14,188,4,16,2,18
	.byte	'Can_NPCRValue',0
	.word	161
	.byte	2,2,35,0,0,21
	.byte	'Can_NPCRValueType',0,14,191,4,3
	.word	7881
	.byte	25
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,14,194,4,16,8,18
	.byte	'CanControllerBaudrate',0
	.word	2223
	.byte	4,2,35,0,18
	.byte	'CanControllerBaudrateCfg',0
	.word	161
	.byte	2,2,35,4,0,21
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,14,198,4,3
	.word	7956
	.byte	9
	.word	7956
	.byte	10
	.word	8121
	.byte	25
	.byte	'Can_BaudrateConfigPtrType',0,14,201,4,16,4,18
	.byte	'Can_kBaudrateConfigPtr',0
	.word	8126
	.byte	4,2,35,0,0,21
	.byte	'Can_BaudrateConfigPtrType',0,14,204,4,3
	.word	8131
	.byte	25
	.byte	'Can_EventHandlingType',0,14,226,4,16,4,18
	.byte	'CanEventType',0
	.word	7771
	.byte	4,2,35,0,0,21
	.byte	'Can_EventHandlingType',0,14,229,4,3
	.word	8231
	.byte	21
	.byte	'Rte_TransformerErrorCode',0,15,130,1,15
	.word	144
	.byte	21
	.byte	'Rte_TransformerClass',0,15,131,1,15
	.word	144
	.byte	17,15,168,1,9,12,18
	.byte	'in',0
	.word	4071
	.byte	4,2,35,0,18
	.byte	'out',0
	.word	4071
	.byte	4,2,35,4,18
	.byte	'used',0
	.word	161
	.byte	2,2,35,8,18
	.byte	'lost_data',0
	.word	144
	.byte	1,2,35,10,0,21
	.byte	'Rte_QDynType',0,15,173,1,3
	.word	8377
	.byte	3,15,175,1,9,4,4
	.byte	'RTE_DRA',0,0,4
	.byte	'RTE_WOWP',0,1,4
	.byte	'RTE_TASK',0,2,4
	.byte	'RTE_ARE',0,3,4
	.byte	'RTE_EV',0,4,4
	.byte	'RTE_MSI',0,5,0,21
	.byte	'Rte_NotificationType',0,15,182,1,3
	.word	8464
	.byte	22,128,8
	.word	144
	.byte	23,255,7,0,21
	.byte	'Impl_NVM_DstPtrType_1024',0,16,50,15
	.word	8562
	.byte	21
	.byte	'CanIf_u32_impl',0,16,69,16
	.word	2223
	.byte	21
	.byte	'CanIf_u16_impl',0,16,71,16
	.word	161
	.byte	21
	.byte	'CanIf_u8_impl',0,16,73,15
	.word	144
	.byte	21
	.byte	'CanIf_ControllerModeType_Enum_impl',0,16,88,15
	.word	144
	.byte	21
	.byte	'CanIf_PduModeType_Enum_impl',0,16,90,15
	.word	144
	.byte	17,16,92,9,2,18
	.byte	'DeviceMode',0
	.word	144
	.byte	1,2,35,0,18
	.byte	'ChannelMode',0
	.word	144
	.byte	1,2,35,1,0,21
	.byte	'CanIf_ControllerStateType_struct_impl',0,16,95,3
	.word	8753
	.byte	21
	.byte	'CanIf_NotifStatusType_Enum_impl',0,16,100,15
	.word	144
	.byte	21
	.byte	'CanSM_boolean_Impl',0,16,120,15
	.word	144
	.byte	21
	.byte	'CanSM_u8_Impl',0,16,123,15
	.word	144
	.byte	21
	.byte	'CanSM_BusOffRecoveryStateType_Enum_impl',0,16,128,1,15
	.word	144
	.byte	21
	.byte	'CanSM_NetworkModeStateType_Enum_impl',0,16,132,1,15
	.word	144
	.byte	21
	.byte	'CanSM_u16_Impl',0,16,136,1,16
	.word	161
	.byte	21
	.byte	'CanSM_TimerStateType_Enum_impl',0,16,138,1,15
	.word	144
	.byte	17,16,140,1,9,4,18
	.byte	'cntTick_u16',0
	.word	161
	.byte	2,2,35,0,18
	.byte	'stTimer',0
	.word	144
	.byte	1,2,35,2,0,21
	.byte	'CanSM_TimerConfig_tst_struct_impl',0,16,143,1,3
	.word	9094
	.byte	21
	.byte	'Com_impl_u16',0,16,154,1,16
	.word	161
	.byte	21
	.byte	'Com_impl_u8',0,16,157,1,15
	.word	144
	.byte	21
	.byte	'ComM_uint32_Impl',0,16,173,1,16
	.word	2223
	.byte	21
	.byte	'ComM_uint16_Impl',0,16,175,1,16
	.word	161
	.byte	21
	.byte	'ComM_uint8_Impl',0,16,177,1,15
	.word	144
	.byte	21
	.byte	'ComM_bool_Impl',0,16,179,1,15
	.word	144
	.byte	17,16,181,1,9,24,18
	.byte	'ChannelState_e',0
	.word	2223
	.byte	4,2,35,0,18
	.byte	'LightTimeoutCtr_u32',0
	.word	2223
	.byte	4,2,35,4,18
	.byte	'MinFullComTimeoutCtr_u16',0
	.word	161
	.byte	2,2,35,8,18
	.byte	'ChannelMode_u8',0
	.word	144
	.byte	1,2,35,10,18
	.byte	'BusSmMode_u8',0
	.word	144
	.byte	1,2,35,11,18
	.byte	'UserRequestCtr_u8',0
	.word	144
	.byte	1,2,35,12,18
	.byte	'PassiveRequestState_u8',0
	.word	144
	.byte	1,2,35,13,18
	.byte	'PncRequestCtr_u8',0
	.word	144
	.byte	1,2,35,14,18
	.byte	'InhibitionReqStatus_u8',0
	.word	144
	.byte	1,2,35,15,18
	.byte	'NmNetworkRequestStatus_b',0
	.word	144
	.byte	1,2,35,16,18
	.byte	'DiagnosticRequestState_b',0
	.word	144
	.byte	1,2,35,17,18
	.byte	'CommunicationAllowed_b',0
	.word	144
	.byte	1,2,35,18,18
	.byte	'NmBusSleepIndicationStatus_b',0
	.word	144
	.byte	1,2,35,19,18
	.byte	'NmPrepareBusSleepIndicationStatus_b',0
	.word	144
	.byte	1,2,35,20,18
	.byte	'NmNetworkModeStatus_b',0
	.word	144
	.byte	1,2,35,21,0,21
	.byte	'ComM_ChannelStruct_Impl',0,16,197,1,3
	.word	9326
	.byte	17,16,206,1,9,10,18
	.byte	'WakeUpInhibitionCtr_u16',0
	.word	161
	.byte	2,2,35,0,18
	.byte	'LimitToNoComCtr_u16',0
	.word	161
	.byte	2,2,35,2,18
	.byte	'RequestedUserMode_t',0
	.word	144
	.byte	1,2,35,4,18
	.byte	'IndicatedUserMode_t',0
	.word	144
	.byte	1,2,35,5,18
	.byte	'numChannelsInFullCom_u8',0
	.word	144
	.byte	1,2,35,6,18
	.byte	'numChannelsInSilentCom_u8',0
	.word	144
	.byte	1,2,35,7,18
	.byte	'numChannelsInNoCom_u8',0
	.word	144
	.byte	1,2,35,8,0,21
	.byte	'ComM_UserStruct_Impl',0,16,214,1,3
	.word	9830
	.byte	21
	.byte	'Dcm_IOOperationResponseType',0,16,252,1,15
	.word	144
	.byte	21
	.byte	'Dcm_RequestDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspRequestRoutineResultsOutSignal_0PrimitivType',0
	.byte	16,138,2,15
	.word	144
	.byte	21
	.byte	'Dcm_StartDataIn_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineInSignalPrimitivType',0,16,146,2,15
	.word	144
	.byte	21
	.byte	'Dcm_StartDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineOutSignalPrimitivType',0,16,150,2,15
	.word	144
	.byte	21
	.byte	'Dcm_StopDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStopRoutineOutSignalPrimitivType',0,16,154,2,15
	.word	144
	.byte	21
	.byte	'NvM_BlockIdType',0,16,215,2,16
	.word	161
	.byte	21
	.byte	'NvM_RequestResultType',0,16,225,2,15
	.word	144
	.byte	21
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockNative_1024_Type',0,16,243,3,34
	.word	8573
	.byte	22,128,8
	.word	144
	.byte	23,255,7,0,21
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockRedundant_1024_Type',0,16,246,3,34
	.word	8573
	.byte	21
	.byte	'MemIf_JobResultType',0,5,39,2
	.word	2093
	.byte	21
	.byte	'NvM_Rb_MigrationResult_ten',0,2,29,2
	.word	2259
	.byte	21
	.byte	'NvM_Rb_StatusType',0,2,37,3
	.word	2514
	.byte	21
	.byte	'NvM_BlockManagementType',0,2,45,3
	.word	982
	.byte	3,2,49,9,4,4
	.byte	'NVM_PRV_ACTIVITY_NOT_INIT',0,0,4
	.byte	'NVM_PRV_ACTIVITY_IDLE',0,1,4
	.byte	'NVM_PRV_ACTIVITY_ARBITRATE',0,2,4
	.byte	'NVM_PRV_ACTIVITY_JOB_START',0,3,4
	.byte	'NVM_PRV_ACTIVITY_POLL_RESULT',0,4,4
	.byte	'NVM_PRV_ACTIVITY_JOB_COMPLETE',0,5,4
	.byte	'NVM_PRV_ACTIVITY_RESULT_EVAL',0,6,0,21
	.byte	'NvM_Prv_Activities_ten',0,2,58,3
	.word	10825
	.byte	21
	.byte	'NvM_Prv_idJob_ten',0,2,115,3
	.word	1654
	.byte	21
	.byte	'NvM_Prv_ServiceBit_tuo',0,2,168,1,16
	.word	161
	.byte	21
	.byte	'NvM_Prv_idService_tuo',0,2,173,1,15
	.word	144
	.byte	21
	.byte	'NvM_Prv_idDetError_tuo',0,2,177,1,15
	.word	144
	.byte	21
	.byte	'NvM_Prv_idQueue_tuo',0,2,206,1,15
	.word	144
	.byte	17,2,210,1,9,12,18
	.byte	'idService_uo',0
	.word	144
	.byte	1,2,35,0,18
	.byte	'idBlock_uo',0
	.word	161
	.byte	2,2,35,2,18
	.byte	'ServiceBit_uo',0
	.word	161
	.byte	2,2,35,4,18
	.byte	'BlockData_pv',0
	.word	4071
	.byte	4,2,35,8,0,21
	.byte	'NvM_Prv_QueueEntry_tst',0,2,225,1,3
	.word	11216
	.byte	10
	.word	144
	.byte	17,2,227,1,9,20,18
	.byte	'idJob_en',0
	.word	1654
	.byte	4,2,35,0,18
	.byte	'idBlock_uo',0
	.word	161
	.byte	2,2,35,4,18
	.byte	'RamBlock_pu8',0
	.word	11342
	.byte	4,2,35,8,18
	.byte	'idxDataset_u8',0
	.word	144
	.byte	1,2,35,12,18
	.byte	'Result_en',0
	.word	2093
	.byte	4,2,35,16,0,21
	.byte	'NvM_Prv_JobData_tst',0,2,240,1,3
	.word	11347
.L435:
	.byte	22,14
	.word	144
	.byte	23,13,0,32
	.word	144
	.byte	1,1,27
	.word	4071
	.byte	0,10
	.word	11494
	.byte	21
	.byte	'NvM_Prv_ExplicitSync_Copy_tpfct',0,1,29,26
	.word	11507
	.byte	21
	.byte	'NvM_Prv_BlockConfiguration_ten',0,1,85,3
	.word	183
	.byte	9
	.word	4071
	.byte	10
	.word	11591
	.byte	32
	.word	144
	.byte	1,1,27
	.word	144
	.byte	27
	.word	144
	.byte	0,10
	.word	11601
	.byte	32
	.word	144
	.byte	1,1,27
	.word	144
	.byte	0,10
	.word	11624
	.byte	10
	.word	5801
	.byte	17,1,121,9,48,18
	.byte	'idBlockMemIf_u16',0
	.word	161
	.byte	2,2,35,0,18
	.byte	'nrBlockBytes_pu16',0
	.word	2600
	.byte	4,2,35,4,18
	.byte	'idxDevice_u8',0
	.word	144
	.byte	1,2,35,8,18
	.byte	'nrNvBlocks_u8',0
	.word	144
	.byte	1,2,35,9,18
	.byte	'nrRomBlocks_u8',0
	.word	144
	.byte	1,2,35,10,18
	.byte	'adrRamBlock_ppv',0
	.word	11596
	.byte	4,2,35,12,18
	.byte	'adrRomBlock_pcv',0
	.word	1239
	.byte	4,2,35,16,18
	.byte	'SingleBlockCallback_pfct',0
	.word	11619
	.byte	4,2,35,20,18
	.byte	'SingleBlockStartCallback_pfct',0
	.word	11637
	.byte	4,2,35,24,18
	.byte	'InitBlockCallback_pfct',0
	.word	11642
	.byte	4,2,35,28,18
	.byte	'ReadRamBlockFromNvm_pfct',0
	.word	11507
	.byte	4,2,35,32,18
	.byte	'WriteRamBlockToNvm_pfct',0
	.word	11507
	.byte	4,2,35,36,18
	.byte	'BlockManagementType_en',0
	.word	982
	.byte	4,2,35,40,18
	.byte	'JobPriority_u8',0
	.word	144
	.byte	1,2,35,44,18
	.byte	'stFlags_u16',0
	.word	161
	.byte	2,2,35,46,0,21
	.byte	'NvM_Prv_BlockDescriptor_tst',0,1,138,2,3
	.word	11647
	.byte	22,160,5
	.word	11647
	.byte	23,13,0,9
	.word	12111
	.byte	33
	.byte	'NvM_Prv_BlockDescriptors_acst',0,1,169,2,45
	.word	12121
	.byte	1,1,0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L131:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,36,0,3,8,11,15,62,15,0,0,3,4,1,58,15,59,15,57,15,11,15
	.byte	0,0,4,40,0,3,8,28,13,0,0,5,46,1,3,8,32,13,58,15,59,15,57,15,73,19,54,15,39,12,0,0,6,5,0,3,8,58,15,59,15
	.byte	57,15,73,19,0,0,7,11,0,0,0,8,59,0,3,8,0,0,9,38,0,73,19,0,0,10,15,0,73,19,0,0,11,11,1,0,0,12,46,0,3,8,58
	.byte	15,59,15,57,15,73,19,54,15,39,12,63,12,60,12,0,0,13,46,1,49,19,0,0,14,5,0,49,19,0,0,15,29,1,49,19,0,0
	.byte	16,11,0,49,19,0,0,17,19,1,58,15,59,15,57,15,11,15,0,0,18,13,0,3,8,73,19,11,15,56,9,0,0,19,46,1,3,8,58
	.byte	15,59,15,57,15,73,19,54,15,39,12,63,12,60,12,0,0,20,21,0,54,15,0,0,21,22,0,3,8,58,15,59,15,57,15,73,19
	.byte	0,0,22,1,1,11,15,73,19,0,0,23,33,0,47,15,0,0,24,21,0,54,15,39,12,0,0,25,19,1,3,8,58,15,59,15,57,15,11
	.byte	15,0,0,26,21,1,54,15,39,12,0,0,27,5,0,73,19,0,0,28,23,1,58,15,59,15,57,15,11,15,0,0,29,4,1,3,8,58,15,59
	.byte	15,57,15,11,15,0,0,30,21,0,73,19,54,15,39,12,0,0,31,53,0,73,19,0,0,32,21,1,73,19,54,15,39,12,0,0,33,52
	.byte	0,3,8,58,15,59,15,57,15,73,19,63,12,60,12,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L132:
	.word	.L529-.L528
.L528:
	.half	3
	.word	.L531-.L530
.L530:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockDescriptor.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\NvM\\api\\NvM_Types.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockData.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\MemIf\\api\\MemIf_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Std_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Det\\api\\Det.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Platform\\Platform_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Can_GeneralTypes.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\RTOS_T\\Gen\\inc\\Os.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Can_17_MCanP\\inc\\Can_17_MCanP.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Type.h',0,0,0,0,0
.L531:
.L529:
	.sdecl	'.debug_info',debug,cluster('NvM_Rb_GetBlockIdCausingLastDetError')
	.sect	'.debug_info'
.L133:
	.word	220
	.half	3
	.word	.L134
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L136,.L135
	.byte	2
	.word	.L129
	.byte	3
	.byte	'NvM_Rb_GetBlockIdCausingLastDetError',0,1,75,17
	.word	.L271
	.byte	1,1,1
	.word	.L78,.L272,.L77
	.byte	4
	.word	.L78,.L272
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Rb_GetBlockIdCausingLastDetError')
	.sect	'.debug_abbrev'
.L134:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Rb_GetBlockIdCausingLastDetError')
	.sect	'.debug_line'
.L135:
	.word	.L533-.L532
.L532:
	.half	3
	.word	.L535-.L534
.L534:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0,0
.L535:
	.byte	5,13,7,0,5,2
	.word	.L78
	.byte	3,206,0,1,5,5,9
	.half	.L536-.L78
	.byte	1,5,1,9
	.half	.L2-.L536
	.byte	3,1,1,7,9
	.half	.L137-.L2
	.byte	0,1,1
.L533:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Rb_GetBlockIdCausingLastDetError')
	.sect	'.debug_ranges'
.L136:
	.word	-1,.L78,0,.L137-.L78,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ErrorDetection_InitializeDetError')
	.sect	'.debug_info'
.L138:
	.word	255
	.half	3
	.word	.L139
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L141,.L140
	.byte	2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_ErrorDetection_InitializeDetError',0,1,123,6,1,1,1
	.word	.L82,.L273,.L81
	.byte	4
	.byte	'isSavedZoneDataLost_b',0,1,123,56
	.word	.L274,.L275
	.byte	5
	.word	.L82,.L273
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ErrorDetection_InitializeDetError')
	.sect	'.debug_abbrev'
.L139:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ErrorDetection_InitializeDetError')
	.sect	'.debug_line'
.L140:
	.word	.L538-.L537
.L537:
	.half	3
	.word	.L540-.L539
.L539:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0,0
.L540:
	.byte	5,5,7,0,5,2
	.word	.L82
	.byte	3,252,0,1,5,9,7,9
	.half	.L541-.L82
	.byte	3,2,1,5,44,9
	.half	.L542-.L541
	.byte	1,5,42,9
	.half	.L543-.L542
	.byte	1,5,9,9
	.half	.L544-.L543
	.byte	3,1,1,5,37,9
	.half	.L545-.L544
	.byte	1,5,35,9
	.half	.L546-.L545
	.byte	1,5,9,9
	.half	.L547-.L546
	.byte	3,1,1,5,42,9
	.half	.L548-.L547
	.byte	1,5,40,9
	.half	.L549-.L548
	.byte	1,5,1,9
	.half	.L3-.L549
	.byte	3,2,1,7,9
	.half	.L142-.L3
	.byte	0,1,1
.L538:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ErrorDetection_InitializeDetError')
	.sect	'.debug_ranges'
.L141:
	.word	-1,.L82,0,.L142-.L82,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ErrorDetection_InitializeProductionErrors')
	.sect	'.debug_info'
.L143:
	.word	255
	.half	3
	.word	.L144
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L146,.L145
	.byte	2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_ErrorDetection_InitializeProductionErrors',0,1,137,1,6,1,1,1
	.word	.L84,.L276,.L83
	.byte	4
	.word	.L84,.L276
	.byte	5
	.byte	'idBlock_uo',0,1,139,1,21
	.word	.L271,.L277
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ErrorDetection_InitializeProductionErrors')
	.sect	'.debug_abbrev'
.L144:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,11,1,17,1,18,1,0,0,5,52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ErrorDetection_InitializeProductionErrors')
	.sect	'.debug_line'
.L145:
	.word	.L551-.L550
.L550:
	.half	3
	.word	.L553-.L552
.L552:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0,0
.L553:
	.byte	5,21,7,0,5,2
	.word	.L84
	.byte	3,140,1,1,5,57,9
	.half	.L444-.L84
	.byte	1,5,9,9
	.half	.L5-.L444
	.byte	3,2,1,5,33,9
	.half	.L554-.L5
	.byte	1,5,48,9
	.half	.L555-.L554
	.byte	1,5,46,9
	.half	.L556-.L555
	.byte	1,5,59,9
	.half	.L557-.L556
	.byte	3,126,1,5,57,9
	.half	.L4-.L557
	.byte	1,5,1,7,9
	.half	.L558-.L4
	.byte	3,4,1,7,9
	.half	.L147-.L558
	.byte	0,1,1
.L551:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ErrorDetection_InitializeProductionErrors')
	.sect	'.debug_ranges'
.L146:
	.word	-1,.L84,0,.L147-.L84,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ErrorDetection_SetProductionError')
	.sect	'.debug_info'
.L148:
	.word	275
	.half	3
	.word	.L149
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L151,.L150
	.byte	2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_ErrorDetection_SetProductionError',0,1,158,1,6,1,1,1
	.word	.L86,.L278,.L85
	.byte	4
	.byte	'idBlock_uo',0,1,158,1,64
	.word	.L271,.L279
	.byte	4
	.byte	'MaskErrorBit_u8',0,1,158,1,82
	.word	.L274,.L280
	.byte	5
	.word	.L86,.L278
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ErrorDetection_SetProductionError')
	.sect	'.debug_abbrev'
.L149:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ErrorDetection_SetProductionError')
	.sect	'.debug_line'
.L150:
	.word	.L560-.L559
.L559:
	.half	3
	.word	.L562-.L561
.L561:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0,0
.L562:
	.byte	5,5,7,0,5,2
	.word	.L86
	.byte	3,160,1,1,5,29,9
	.half	.L563-.L86
	.byte	1,5,42,9
	.half	.L564-.L563
	.byte	1,5,29,9
	.half	.L565-.L564
	.byte	3,2,1,5,33,9
	.half	.L566-.L565
	.byte	1,5,1,9
	.half	.L567-.L566
	.byte	3,1,1,7,9
	.half	.L152-.L567
	.byte	0,1,1
.L560:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ErrorDetection_SetProductionError')
	.sect	'.debug_ranges'
.L151:
	.word	-1,.L86,0,.L152-.L86,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ErrorDetection_IsBlockPending')
	.sect	'.debug_info'
.L153:
	.word	298
	.half	3
	.word	.L154
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L156,.L155
	.byte	2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_ErrorDetection_IsBlockPending',0,1,178,1,6,1,1,1
	.word	.L88,.L281,.L87
	.byte	4
	.byte	'idService_uo',0,1,178,1,66
	.word	.L274,.L282
	.byte	4
	.byte	'idBlock_uo',0,1,179,1,60
	.word	.L271,.L283
	.byte	4
	.byte	'isBlockPending_b',0,1,180,1,52
	.word	.L274,.L284
	.byte	5
	.word	.L88,.L281
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ErrorDetection_IsBlockPending')
	.sect	'.debug_abbrev'
.L154:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ErrorDetection_IsBlockPending')
	.sect	'.debug_line'
.L155:
	.word	.L569-.L568
.L568:
	.half	3
	.word	.L571-.L570
.L570:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0,0
.L571:
	.byte	5,6,7,0,5,2
	.word	.L88
	.byte	3,177,1,1,5,5,9
	.half	.L447-.L88
	.byte	3,4,1,5,46,7,9
	.half	.L572-.L447
	.byte	3,4,1,5,67,9
	.half	.L445-.L572
	.byte	1,5,1,9
	.half	.L6-.L445
	.byte	3,2,1,7,9
	.half	.L157-.L6
	.byte	0,1,1
.L569:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ErrorDetection_IsBlockPending')
	.sect	'.debug_ranges'
.L156:
	.word	-1,.L88,0,.L157-.L88,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ErrorDetection_IsServiceBitValid')
	.sect	'.debug_info'
.L158:
	.word	336
	.half	3
	.word	.L159
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L161,.L160
	.byte	2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_ErrorDetection_IsServiceBitValid',0,1,207,1,9
	.word	.L274
	.byte	1,1,1
	.word	.L90,.L285,.L89
	.byte	4
	.byte	'idService_uo',0,1,207,1,72
	.word	.L274,.L286
	.byte	4
	.byte	'idBlock_uo',0,1,208,1,66
	.word	.L271,.L287
	.byte	4
	.byte	'ServiceBit_uo',0,1,209,1,73
	.word	.L271,.L288
	.byte	5
	.word	.L90,.L285
	.byte	6
	.byte	'isServiceBitValid_b',0,1,211,1,13
	.word	.L274,.L289
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ErrorDetection_IsServiceBitValid')
	.sect	'.debug_abbrev'
.L159:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ErrorDetection_IsServiceBitValid')
	.sect	'.debug_line'
.L160:
	.word	.L574-.L573
.L573:
	.half	3
	.word	.L576-.L575
.L575:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0,0
.L576:
	.byte	5,9,7,0,5,2
	.word	.L90
	.byte	3,206,1,1,5,50,9
	.half	.L450-.L90
	.byte	3,4,1,5,10,9
	.half	.L451-.L450
	.byte	3,2,1,5,46,7,9
	.half	.L577-.L451
	.byte	3,2,1,5,77,9
	.half	.L449-.L577
	.byte	1,5,5,9
	.half	.L7-.L449
	.byte	3,2,1,5,1,9
	.half	.L8-.L7
	.byte	3,1,1,7,9
	.half	.L162-.L8
	.byte	0,1,1
.L574:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ErrorDetection_IsServiceBitValid')
	.sect	'.debug_ranges'
.L161:
	.word	-1,.L90,0,.L162-.L90,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ErrorDetection_IsJobIdValid')
	.sect	'.debug_info'
.L163:
	.word	321
	.half	3
	.word	.L164
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L166,.L165
	.byte	2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_ErrorDetection_IsJobIdValid',0,1,220,1,9
	.word	.L274
	.byte	1,1,1
	.word	.L92,.L290,.L91
	.byte	4
	.byte	'idService_uo',0,1,220,1,67
	.word	.L274,.L291
	.byte	4
	.byte	'idBlock_uo',0,1,221,1,61
	.word	.L271,.L292
	.byte	4
	.byte	'idJob_en',0,1,222,1,63
	.word	.L293,.L294
	.byte	5
	.word	.L92,.L290
	.byte	6
	.byte	'isJobIdValid_b',0,1,224,1,13
	.word	.L274,.L295
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ErrorDetection_IsJobIdValid')
	.sect	'.debug_abbrev'
.L164:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ErrorDetection_IsJobIdValid')
	.sect	'.debug_line'
.L165:
	.word	.L579-.L578
.L578:
	.half	3
	.word	.L581-.L580
.L580:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0,0
.L581:
	.byte	5,9,7,0,5,2
	.word	.L92
	.byte	3,219,1,1,5,40,9
	.half	.L455-.L92
	.byte	3,4,1,5,10,9
	.half	.L456-.L455
	.byte	3,2,1,5,46,7,9
	.half	.L582-.L456
	.byte	3,2,1,5,64,9
	.half	.L453-.L582
	.byte	1,5,5,9
	.half	.L9-.L453
	.byte	3,2,1,5,1,9
	.half	.L10-.L9
	.byte	3,1,1,7,9
	.half	.L167-.L10
	.byte	0,1,1
.L579:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ErrorDetection_IsJobIdValid')
	.sect	'.debug_ranges'
.L166:
	.word	-1,.L92,0,.L167-.L92,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible')
	.sect	'.debug_info'
.L168:
	.word	351
	.half	3
	.word	.L169
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L171,.L170
	.byte	2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible',0,1,233,1,9
	.word	.L274
	.byte	1,1,1
	.word	.L94,.L296,.L93
	.byte	4
	.byte	'idService_uo',0,1,233,1,80
	.word	.L274,.L297
	.byte	4
	.byte	'idBlock_uo',0,1,234,1,74
	.word	.L271,.L298
	.byte	4
	.byte	'JobResult_en',0,1,235,1,78
	.word	.L299,.L300
	.byte	5
	.word	.L94,.L296
	.byte	6
	.byte	'isJobResultMemIfPlausible_b',0,1,237,1,13
	.word	.L274,.L301
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible')
	.sect	'.debug_abbrev'
.L169:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible')
	.sect	'.debug_line'
.L170:
	.word	.L584-.L583
.L583:
	.half	3
	.word	.L586-.L585
.L585:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0,0
.L586:
	.byte	5,9,7,0,5,2
	.word	.L94
	.byte	3,232,1,1,5,82,9
	.half	.L460-.L94
	.byte	3,7,1,5,44,9
	.half	.L461-.L460
	.byte	3,125,1,5,58,7,9
	.half	.L587-.L461
	.byte	3,1,1,7,9
	.half	.L588-.L587
	.byte	3,1,1,7,9
	.half	.L589-.L588
	.byte	3,1,1,7,9
	.half	.L590-.L589
	.byte	3,1,1,5,82,7,9
	.half	.L11-.L590
	.byte	3,127,1,5,10,9
	.half	.L15-.L11
	.byte	3,2,1,5,46,7,9
	.half	.L591-.L15
	.byte	3,2,1,5,70,9
	.half	.L459-.L591
	.byte	1,5,5,9
	.half	.L16-.L459
	.byte	3,2,1,5,1,9
	.half	.L17-.L16
	.byte	3,1,1,7,9
	.half	.L172-.L17
	.byte	0,1,1
.L584:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible')
	.sect	'.debug_ranges'
.L171:
	.word	-1,.L94,0,.L172-.L94,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ErrorDetection_IsBlockSizeValidForExplicitSync')
	.sect	'.debug_info'
.L173:
	.word	417
	.half	3
	.word	.L174
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L176,.L175
	.byte	2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_ErrorDetection_IsBlockSizeValidForExplicitSync',0,1,137,2,9
	.word	.L274
	.byte	1,1,1
	.word	.L96,.L302,.L95
	.byte	4
	.byte	'idService_uo',0,1,137,2,86
	.word	.L274,.L303
	.byte	4
	.byte	'idBlock_uo',0,1,138,2,80
	.word	.L271,.L304
	.byte	4
	.byte	'SizeRamMirror_u32',0,1,139,2,71
	.word	.L305,.L306
	.byte	5
	.word	.L96,.L302
	.byte	6
	.byte	'isBlockSizeValid_b',0,1,141,2,13
	.word	.L274,.L307
	.byte	7
	.word	.L308,.L309,.L310
	.byte	8
	.word	.L311,.L312
	.byte	9
	.word	.L313,.L309,.L310
	.byte	6
	.byte	'BlockSize_u16',0,2,191,3,12
	.word	.L271,.L314
	.byte	0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ErrorDetection_IsBlockSizeValidForExplicitSync')
	.sect	'.debug_abbrev'
.L174:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,7,29,1,49,16,17,1,18,1,0,0,8,5,0,49,16,2,6,0,0,9,11,1,49,16,17
	.byte	1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ErrorDetection_IsBlockSizeValidForExplicitSync')
	.sect	'.debug_line'
.L175:
	.word	.L593-.L592
.L592:
	.half	3
	.word	.L595-.L594
.L594:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockDescriptor.h',0,0,0,0,0
.L595:
	.byte	5,9,7,0,5,2
	.word	.L96
	.byte	3,136,2,1,4,2,5,26,9
	.half	.L309-.L96
	.byte	3,182,1,1,5,9,9
	.half	.L464-.L309
	.byte	3,2,1,5,51,7,9
	.half	.L596-.L464
	.byte	3,1,1,5,22,9
	.half	.L597-.L596
	.byte	1,5,51,9
	.half	.L598-.L597
	.byte	1,5,63,9
	.half	.L599-.L598
	.byte	1,5,10,9
	.half	.L600-.L599
	.byte	1,5,19,9
	.half	.L601-.L600
	.byte	1,5,25,7,9
	.half	.L602-.L601
	.byte	3,2,1,5,5,9
	.half	.L18-.L602
	.byte	3,3,1,4,1,5,68,9
	.half	.L20-.L18
	.byte	3,198,126,1,5,10,9
	.half	.L310-.L20
	.byte	3,2,1,5,46,7,9
	.half	.L603-.L310
	.byte	3,3,1,5,69,9
	.half	.L463-.L603
	.byte	1,5,5,9
	.half	.L21-.L463
	.byte	3,3,1,5,1,9
	.half	.L22-.L21
	.byte	3,1,1,7,9
	.half	.L177-.L22
	.byte	0,1,1
.L593:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ErrorDetection_IsBlockSizeValidForExplicitSync')
	.sect	'.debug_ranges'
.L176:
	.word	-1,.L96,0,.L177-.L96,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForDataIdx')
	.sect	'.debug_info'
.L178:
	.word	334
	.half	3
	.word	.L179
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L181,.L180
	.byte	2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_ErrorDetection_IsPtrValidForDataIdx',0,1,169,2,9
	.word	.L274
	.byte	1,1,1
	.word	.L98,.L315,.L97
	.byte	4
	.byte	'idService_uo',0,1,169,2,75
	.word	.L274,.L316
	.byte	4
	.byte	'idBlock_uo',0,1,170,2,69
	.word	.L271,.L317
	.byte	4
	.byte	'ptrDataIdx_pcu8',0,1,171,2,66
	.word	.L318,.L319
	.byte	5
	.word	.L98,.L315
	.byte	6
	.byte	'isPtrValid_b',0,1,173,2,13
	.word	.L274,.L320
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForDataIdx')
	.sect	'.debug_abbrev'
.L179:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForDataIdx')
	.sect	'.debug_line'
.L180:
	.word	.L605-.L604
.L604:
	.half	3
	.word	.L607-.L606
.L606:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0,0
.L607:
	.byte	5,9,7,0,5,2
	.word	.L98
	.byte	3,168,2,1,5,29,9
	.half	.L467-.L98
	.byte	3,4,1,5,38,9
	.half	.L608-.L467
	.byte	1,5,10,9
	.half	.L468-.L608
	.byte	3,2,1,5,46,7,9
	.half	.L609-.L468
	.byte	3,2,1,5,64,9
	.half	.L466-.L609
	.byte	1,5,5,9
	.half	.L23-.L466
	.byte	3,3,1,5,1,9
	.half	.L24-.L23
	.byte	3,1,1,7,9
	.half	.L182-.L24
	.byte	0,1,1
.L605:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForDataIdx')
	.sect	'.debug_ranges'
.L181:
	.word	-1,.L98,0,.L182-.L98,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForRequestResult')
	.sect	'.debug_info'
.L183:
	.word	342
	.half	3
	.word	.L184
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L186,.L185
	.byte	2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_ErrorDetection_IsPtrValidForRequestResult',0,1,200,2,9
	.word	.L274
	.byte	1,1,1
	.word	.L100,.L321,.L99
	.byte	4
	.byte	'idService_uo',0,1,200,2,81
	.word	.L274,.L322
	.byte	4
	.byte	'idBlock_uo',0,1,201,2,75
	.word	.L271,.L323
	.byte	4
	.byte	'ptrReqResult_pcuo',0,1,202,2,88
	.word	.L324,.L325
	.byte	5
	.word	.L100,.L321
	.byte	6
	.byte	'isPtrValid_b',0,1,204,2,13
	.word	.L274,.L326
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForRequestResult')
	.sect	'.debug_abbrev'
.L184:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForRequestResult')
	.sect	'.debug_line'
.L185:
	.word	.L611-.L610
.L610:
	.half	3
	.word	.L613-.L612
.L612:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0,0
.L613:
	.byte	5,9,7,0,5,2
	.word	.L100
	.byte	3,199,2,1,5,29,9
	.half	.L471-.L100
	.byte	3,4,1,5,38,9
	.half	.L614-.L471
	.byte	1,5,10,9
	.half	.L472-.L614
	.byte	3,2,1,5,46,7,9
	.half	.L615-.L472
	.byte	3,2,1,5,64,9
	.half	.L470-.L615
	.byte	1,5,5,9
	.half	.L25-.L470
	.byte	3,3,1,5,1,9
	.half	.L26-.L25
	.byte	3,1,1,7,9
	.half	.L187-.L26
	.byte	0,1,1
.L611:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForRequestResult')
	.sect	'.debug_ranges'
.L186:
	.word	-1,.L100,0,.L187-.L100,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForMigrationResult')
	.sect	'.debug_info'
.L188:
	.word	350
	.half	3
	.word	.L189
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L191,.L190
	.byte	2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_ErrorDetection_IsPtrValidForMigrationResult',0,1,231,2,9
	.word	.L274
	.byte	1,1,1
	.word	.L102,.L327,.L101
	.byte	4
	.byte	'idService_uo',0,1,231,2,83
	.word	.L274,.L328
	.byte	4
	.byte	'idBlock_uo',0,1,232,2,77
	.word	.L271,.L329
	.byte	4
	.byte	'ptrMigrationResult_pcen',0,1,233,2,95
	.word	.L330,.L331
	.byte	5
	.word	.L102,.L327
	.byte	6
	.byte	'isPtrValid_b',0,1,235,2,13
	.word	.L274,.L332
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForMigrationResult')
	.sect	'.debug_abbrev'
.L189:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForMigrationResult')
	.sect	'.debug_line'
.L190:
	.word	.L617-.L616
.L616:
	.half	3
	.word	.L619-.L618
.L618:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0,0
.L619:
	.byte	5,9,7,0,5,2
	.word	.L102
	.byte	3,230,2,1,5,29,9
	.half	.L475-.L102
	.byte	3,4,1,5,38,9
	.half	.L620-.L475
	.byte	1,5,10,9
	.half	.L476-.L620
	.byte	3,2,1,5,46,7,9
	.half	.L621-.L476
	.byte	3,2,1,5,64,9
	.half	.L474-.L621
	.byte	1,5,5,9
	.half	.L27-.L474
	.byte	3,3,1,5,1,9
	.half	.L28-.L27
	.byte	3,1,1,7,9
	.half	.L192-.L28
	.byte	0,1,1
.L617:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForMigrationResult')
	.sect	'.debug_ranges'
.L191:
	.word	-1,.L102,0,.L192-.L102,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForNvmStatus')
	.sect	'.debug_info'
.L193:
	.word	314
	.half	3
	.word	.L194
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L196,.L195
	.byte	2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_ErrorDetection_IsPtrValidForNvmStatus',0,1,132,3,9
	.word	.L274
	.byte	1,1,1
	.word	.L104,.L333,.L103
	.byte	4
	.byte	'idService_uo',0,1,132,3,77
	.word	.L274,.L334
	.byte	4
	.byte	'ptrNvmStatus_pcen',0,1,133,3,80
	.word	.L335,.L336
	.byte	5
	.word	.L104,.L333
	.byte	6
	.byte	'isPtrValid_b',0,1,135,3,13
	.word	.L274,.L337
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForNvmStatus')
	.sect	'.debug_abbrev'
.L194:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForNvmStatus')
	.sect	'.debug_line'
.L195:
	.word	.L623-.L622
.L622:
	.half	3
	.word	.L625-.L624
.L624:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0,0
.L625:
	.byte	5,29,7,0,5,2
	.word	.L104
	.byte	3,134,3,1,5,38,9
	.half	.L626-.L104
	.byte	1,5,10,9
	.half	.L478-.L626
	.byte	3,2,1,5,46,7,9
	.half	.L627-.L478
	.byte	3,3,1,5,64,9
	.half	.L628-.L627
	.byte	1,5,5,9
	.half	.L29-.L628
	.byte	3,3,1,5,1,9
	.half	.L30-.L29
	.byte	3,1,1,7,9
	.half	.L197-.L30
	.byte	0,1,1
.L623:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForNvmStatus')
	.sect	'.debug_ranges'
.L196:
	.word	-1,.L104,0,.L197-.L104,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForBlockLength')
	.sect	'.debug_info'
.L198:
	.word	343
	.half	3
	.word	.L199
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L201,.L200
	.byte	2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_ErrorDetection_IsPtrValidForBlockLength',0,1,163,3,9
	.word	.L274
	.byte	1,1,1
	.word	.L106,.L338,.L105
	.byte	4
	.byte	'idService_uo',0,1,163,3,79
	.word	.L274,.L339
	.byte	4
	.byte	'idBlock_uo',0,1,164,3,73
	.word	.L271,.L340
	.byte	4
	.byte	'ptrBlockLength_pcu16',0,1,165,3,71
	.word	.L341,.L342
	.byte	5
	.word	.L106,.L338
	.byte	6
	.byte	'isPtrValid_b',0,1,167,3,13
	.word	.L274,.L343
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForBlockLength')
	.sect	'.debug_abbrev'
.L199:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForBlockLength')
	.sect	'.debug_line'
.L200:
	.word	.L630-.L629
.L629:
	.half	3
	.word	.L632-.L631
.L631:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0,0
.L632:
	.byte	5,9,7,0,5,2
	.word	.L106
	.byte	3,162,3,1,5,29,9
	.half	.L481-.L106
	.byte	3,4,1,5,38,9
	.half	.L633-.L481
	.byte	1,5,10,9
	.half	.L482-.L633
	.byte	3,2,1,5,46,7,9
	.half	.L634-.L482
	.byte	3,2,1,5,64,9
	.half	.L480-.L634
	.byte	1,5,5,9
	.half	.L31-.L480
	.byte	3,3,1,5,1,9
	.half	.L32-.L31
	.byte	3,1,1,7,9
	.half	.L202-.L32
	.byte	0,1,1
.L630:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForBlockLength')
	.sect	'.debug_ranges'
.L201:
	.word	-1,.L106,0,.L202-.L106,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForServiceId')
	.sect	'.debug_info'
.L203:
	.word	314
	.half	3
	.word	.L204
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L206,.L205
	.byte	2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_ErrorDetection_IsPtrValidForServiceId',0,1,192,3,9
	.word	.L274
	.byte	1,1,1
	.word	.L108,.L344,.L107
	.byte	4
	.byte	'idService_uo',0,1,192,3,77
	.word	.L274,.L345
	.byte	4
	.byte	'ptrIdService_pcuo',0,1,193,3,84
	.word	.L346,.L347
	.byte	5
	.word	.L108,.L344
	.byte	6
	.byte	'isPtrValid_b',0,1,195,3,13
	.word	.L274,.L348
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForServiceId')
	.sect	'.debug_abbrev'
.L204:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForServiceId')
	.sect	'.debug_line'
.L205:
	.word	.L636-.L635
.L635:
	.half	3
	.word	.L638-.L637
.L637:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0,0
.L638:
	.byte	5,29,7,0,5,2
	.word	.L108
	.byte	3,194,3,1,5,38,9
	.half	.L639-.L108
	.byte	1,5,10,9
	.half	.L484-.L639
	.byte	3,2,1,5,46,7,9
	.half	.L640-.L484
	.byte	3,3,1,5,64,9
	.half	.L641-.L640
	.byte	1,5,5,9
	.half	.L33-.L641
	.byte	3,3,1,5,1,9
	.half	.L34-.L33
	.byte	3,1,1,7,9
	.half	.L207-.L34
	.byte	0,1,1
.L636:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForServiceId')
	.sect	'.debug_ranges'
.L206:
	.word	-1,.L108,0,.L207-.L108,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForBlockId')
	.sect	'.debug_info'
.L208:
	.word	310
	.half	3
	.word	.L209
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L211,.L210
	.byte	2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_ErrorDetection_IsPtrValidForBlockId',0,1,221,3,9
	.word	.L274
	.byte	1,1,1
	.word	.L110,.L349,.L109
	.byte	4
	.byte	'idService_uo',0,1,221,3,75
	.word	.L274,.L350
	.byte	4
	.byte	'ptrIdBlock_pcuo',0,1,222,3,76
	.word	.L351,.L352
	.byte	5
	.word	.L110,.L349
	.byte	6
	.byte	'isPtrValid_b',0,1,224,3,13
	.word	.L274,.L353
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForBlockId')
	.sect	'.debug_abbrev'
.L209:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForBlockId')
	.sect	'.debug_line'
.L210:
	.word	.L643-.L642
.L642:
	.half	3
	.word	.L645-.L644
.L644:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0,0
.L645:
	.byte	5,29,7,0,5,2
	.word	.L110
	.byte	3,223,3,1,5,38,9
	.half	.L646-.L110
	.byte	1,5,10,9
	.half	.L486-.L646
	.byte	3,2,1,5,46,7,9
	.half	.L647-.L486
	.byte	3,3,1,5,64,9
	.half	.L648-.L647
	.byte	1,5,5,9
	.half	.L35-.L648
	.byte	3,3,1,5,1,9
	.half	.L36-.L35
	.byte	3,1,1,7,9
	.half	.L212-.L36
	.byte	0,1,1
.L643:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForBlockId')
	.sect	'.debug_ranges'
.L211:
	.word	-1,.L110,0,.L212-.L110,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForVersionInfo')
	.sect	'.debug_info'
.L213:
	.word	318
	.half	3
	.word	.L214
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L216,.L215
	.byte	2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_ErrorDetection_IsPtrValidForVersionInfo',0,1,252,3,9
	.word	.L274
	.byte	1,1,1
	.word	.L112,.L354,.L111
	.byte	4
	.byte	'idService_uo',0,1,252,3,79
	.word	.L274,.L355
	.byte	4
	.byte	'ptrVersionInfo_pcst',0,1,253,3,84
	.word	.L356,.L357
	.byte	5
	.word	.L112,.L354
	.byte	6
	.byte	'isPtrValid_b',0,1,255,3,13
	.word	.L274,.L358
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForVersionInfo')
	.sect	'.debug_abbrev'
.L214:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForVersionInfo')
	.sect	'.debug_line'
.L215:
	.word	.L650-.L649
.L649:
	.half	3
	.word	.L652-.L651
.L651:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0,0
.L652:
	.byte	5,29,7,0,5,2
	.word	.L112
	.byte	3,254,3,1,5,38,9
	.half	.L653-.L112
	.byte	1,5,10,9
	.half	.L488-.L653
	.byte	3,2,1,5,46,7,9
	.half	.L654-.L488
	.byte	3,3,1,5,67,9
	.half	.L655-.L654
	.byte	1,5,5,9
	.half	.L37-.L655
	.byte	3,3,1,5,1,9
	.half	.L38-.L37
	.byte	3,1,1,7,9
	.half	.L217-.L38
	.byte	0,1,1
.L650:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForVersionInfo')
	.sect	'.debug_ranges'
.L216:
	.word	-1,.L112,0,.L217-.L112,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ErrorDetection_IsNvmInitialized')
	.sect	'.debug_info'
.L218:
	.word	307
	.half	3
	.word	.L219
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L221,.L220
	.byte	2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_ErrorDetection_IsNvmInitialized',0,1,153,4,9
	.word	.L274
	.byte	1,1,1
	.word	.L114,.L359,.L113
	.byte	4
	.byte	'idService_uo',0,1,153,4,71
	.word	.L274,.L360
	.byte	4
	.byte	'idBlock_uo',0,1,154,4,65
	.word	.L271,.L361
	.byte	5
	.word	.L114,.L359
	.byte	6
	.byte	'isNvmInitialized_b',0,1,156,4,13
	.word	.L274,.L362
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ErrorDetection_IsNvmInitialized')
	.sect	'.debug_abbrev'
.L219:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ErrorDetection_IsNvmInitialized')
	.sect	'.debug_line'
.L220:
	.word	.L657-.L656
.L656:
	.half	3
	.word	.L659-.L658
.L658:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0,0
.L659:
	.byte	5,9,7,0,5,2
	.word	.L114
	.byte	3,152,4,1,5,58,9
	.half	.L660-.L114
	.byte	3,3,1,5,32,9
	.half	.L490-.L660
	.byte	1,5,10,9
	.half	.L491-.L490
	.byte	3,2,1,5,46,7,9
	.half	.L661-.L491
	.byte	3,2,1,5,69,9
	.half	.L492-.L661
	.byte	1,5,5,9
	.half	.L39-.L492
	.byte	3,3,1,5,1,9
	.half	.L40-.L39
	.byte	3,1,1,7,9
	.half	.L222-.L40
	.byte	0,1,1
.L657:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ErrorDetection_IsNvmInitialized')
	.sect	'.debug_ranges'
.L221:
	.word	-1,.L114,0,.L222-.L114,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ErrorDetection_IsBlockIdValid')
	.sect	'.debug_info'
.L223:
	.word	368
	.half	3
	.word	.L224
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L226,.L225
	.byte	2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_ErrorDetection_IsBlockIdValid',0,1,183,4,9
	.word	.L274
	.byte	1,1,1
	.word	.L116,.L363,.L115
	.byte	4
	.byte	'idService_uo',0,1,183,4,69
	.word	.L274,.L364
	.byte	4
	.byte	'idBlock_uo',0,1,184,4,63
	.word	.L271,.L365
	.byte	4
	.byte	'isMultiBlockAllowed_b',0,1,185,4,55
	.word	.L274,.L366
	.byte	5
	.word	.L116,.L363
	.byte	6
	.byte	'isBlockIdValid_b',0,1,187,4,13
	.word	.L274,.L367
	.byte	6
	.byte	'idBlockLowest_uo',0,1,188,4,21
	.word	.L271,.L368
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ErrorDetection_IsBlockIdValid')
	.sect	'.debug_abbrev'
.L224:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ErrorDetection_IsBlockIdValid')
	.sect	'.debug_line'
.L225:
	.word	.L663-.L662
.L662:
	.half	3
	.word	.L665-.L664
.L664:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0,0
.L665:
	.byte	5,9,7,0,5,2
	.word	.L116
	.byte	3,182,4,1,5,26,9
	.half	.L496-.L116
	.byte	3,9,1,5,47,9
	.half	.L497-.L496
	.byte	1,5,26,9
	.half	.L41-.L497
	.byte	3,5,1,5,57,9
	.half	.L42-.L41
	.byte	3,3,1,5,24,9
	.half	.L500-.L42
	.byte	1,5,72,7,9
	.half	.L666-.L500
	.byte	1,5,57,9
	.half	.L667-.L666
	.byte	1,5,10,9
	.half	.L43-.L667
	.byte	3,2,1,5,46,7,9
	.half	.L668-.L43
	.byte	3,4,1,5,68,9
	.half	.L498-.L668
	.byte	1,5,5,9
	.half	.L45-.L498
	.byte	3,3,1,5,1,9
	.half	.L46-.L45
	.byte	3,1,1,7,9
	.half	.L227-.L46
	.byte	0,1,1
.L663:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ErrorDetection_IsBlockIdValid')
	.sect	'.debug_ranges'
.L226:
	.word	-1,.L116,0,.L227-.L116,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ErrorDetection_IsDefaultDataAvailable')
	.sect	'.debug_info'
.L228:
	.word	355
	.half	3
	.word	.L229
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L231,.L230
	.byte	2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_ErrorDetection_IsDefaultDataAvailable',0,1,212,4,9
	.word	.L274
	.byte	1,1,1
	.word	.L118,.L369,.L117
	.byte	4
	.byte	'idService_uo',0,1,212,4,77
	.word	.L274,.L370
	.byte	4
	.byte	'idBlock_uo',0,1,213,4,71
	.word	.L271,.L371
	.byte	5
	.word	.L118,.L369
	.byte	6
	.byte	'isDefaultDataAvailable_b',0,1,215,4,13
	.word	.L274,.L372
	.byte	7
	.word	.L373,.L374,.L375
	.byte	8
	.word	.L376,.L377
	.byte	9
	.word	.L378,.L374,.L375
	.byte	0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ErrorDetection_IsDefaultDataAvailable')
	.sect	'.debug_abbrev'
.L229:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,7,29,1,49,16,17,1,18,1,0,0,8,5,0,49,16,2,6,0,0,9,11,0,49,16,17
	.byte	1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ErrorDetection_IsDefaultDataAvailable')
	.sect	'.debug_line'
.L230:
	.word	.L670-.L669
.L669:
	.half	3
	.word	.L672-.L671
.L671:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockDescriptor.h',0,0,0,0,0
.L672:
	.byte	5,9,7,0,5,2
	.word	.L118
	.byte	3,211,4,1,5,38,9
	.half	.L502-.L118
	.byte	3,3,1,4,2,5,46,9
	.half	.L374-.L502
	.byte	3,172,126,1,5,13,9
	.half	.L673-.L374
	.byte	1,5,56,7,9
	.half	.L674-.L673
	.byte	3,1,1,5,27,9
	.half	.L675-.L674
	.byte	1,5,56,9
	.half	.L676-.L675
	.byte	1,5,15,9
	.half	.L677-.L676
	.byte	1,5,68,9
	.half	.L678-.L677
	.byte	1,5,14,9
	.half	.L679-.L678
	.byte	1,5,15,7,9
	.half	.L680-.L679
	.byte	3,1,1,5,68,9
	.half	.L681-.L680
	.byte	1,5,24,9
	.half	.L682-.L681
	.byte	1,5,46,7,9
	.half	.L48-.L682
	.byte	3,126,1,5,5,9
	.half	.L47-.L48
	.byte	1,4,1,9
	.half	.L50-.L47
	.byte	3,213,1,1,5,34,7,9
	.half	.L375-.L50
	.byte	3,2,1,5,40,9
	.half	.L683-.L375
	.byte	1,5,46,9
	.half	.L51-.L683
	.byte	3,4,1,5,66,9
	.half	.L501-.L51
	.byte	1,5,5,9
	.half	.L52-.L501
	.byte	3,2,1,5,1,9
	.half	.L53-.L52
	.byte	3,1,1,7,9
	.half	.L232-.L53
	.byte	0,1,1
.L670:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ErrorDetection_IsDefaultDataAvailable')
	.sect	'.debug_ranges'
.L231:
	.word	-1,.L118,0,.L232-.L118,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ErrorDetection_IsRamBlockAddressValid')
	.sect	'.debug_info'
.L233:
	.word	351
	.half	3
	.word	.L234
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L236,.L235
	.byte	2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_ErrorDetection_IsRamBlockAddressValid',0,1,227,4,9
	.word	.L274
	.byte	1,1,1
	.word	.L120,.L379,.L119
	.byte	4
	.byte	'idService_uo',0,1,227,4,77
	.word	.L274,.L380
	.byte	4
	.byte	'idBlock_uo',0,1,228,4,71
	.word	.L271,.L381
	.byte	4
	.byte	'RamBlockAddress_pv',0,1,229,4,67
	.word	.L382,.L383
	.byte	5
	.word	.L120,.L379
	.byte	6
	.byte	'isRamBlockAddressValid_b',0,1,231,4,13
	.word	.L274,.L384
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ErrorDetection_IsRamBlockAddressValid')
	.sect	'.debug_abbrev'
.L234:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ErrorDetection_IsRamBlockAddressValid')
	.sect	'.debug_line'
.L235:
	.word	.L685-.L684
.L684:
	.half	3
	.word	.L687-.L686
.L686:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0,0
.L687:
	.byte	5,9,7,0,5,2
	.word	.L120
	.byte	3,226,4,1,5,38,9
	.half	.L506-.L120
	.byte	3,4,1,5,9,9
	.half	.L507-.L506
	.byte	3,2,1,5,5,9
	.half	.L688-.L507
	.byte	1,5,46,7,9
	.half	.L689-.L688
	.byte	3,2,1,5,67,9
	.half	.L505-.L689
	.byte	1,5,78,9
	.half	.L504-.L505
	.byte	1,5,34,9
	.half	.L54-.L504
	.byte	3,4,1,5,5,9
	.half	.L55-.L54
	.byte	3,2,1,5,1,9
	.half	.L56-.L55
	.byte	3,1,1,7,9
	.half	.L237-.L56
	.byte	0,1,1
.L685:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ErrorDetection_IsRamBlockAddressValid')
	.sect	'.debug_ranges'
.L236:
	.word	-1,.L120,0,.L237-.L120,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ErrorDetection_IsBlockTypeDataset')
	.sect	'.debug_info'
.L238:
	.word	371
	.half	3
	.word	.L239
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L241,.L240
	.byte	2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_ErrorDetection_IsBlockTypeDataset',0,1,244,4,9
	.word	.L274
	.byte	1,1,1
	.word	.L122,.L385,.L121
	.byte	4
	.byte	'idService_uo',0,1,244,4,73
	.word	.L274,.L386
	.byte	4
	.byte	'idBlock_uo',0,1,245,4,67
	.word	.L271,.L387
	.byte	5
	.word	.L122,.L385
	.byte	6
	.byte	'isBlockTypeDataset_b',0,1,247,4,13
	.word	.L274,.L388
	.byte	7
	.word	.L389,.L390,.L391
	.byte	8
	.word	.L392,.L393
	.byte	9
	.word	.L394,.L390,.L391
	.byte	6
	.byte	'BlockType',0,2,214,3,29
	.word	.L395,.L396
	.byte	0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ErrorDetection_IsBlockTypeDataset')
	.sect	'.debug_abbrev'
.L239:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,7,29,1,49,16,17,1,18,1,0,0,8,5,0,49,16,2,6,0,0,9,11,1,49,16,17
	.byte	1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ErrorDetection_IsBlockTypeDataset')
	.sect	'.debug_line'
.L240:
	.word	.L691-.L690
.L690:
	.half	3
	.word	.L693-.L692
.L692:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockDescriptor.h',0,0,0,0,0
.L693:
	.byte	5,9,7,0,5,2
	.word	.L122
	.byte	3,243,4,1,5,34,9
	.half	.L510-.L122
	.byte	3,3,1,4,2,5,39,9
	.half	.L390-.L510
	.byte	3,223,126,1,5,5,9
	.half	.L511-.L390
	.byte	3,1,1,5,50,7,9
	.half	.L694-.L511
	.byte	3,2,1,5,21,9
	.half	.L512-.L694
	.byte	1,5,50,9
	.half	.L695-.L512
	.byte	1,5,62,9
	.half	.L696-.L695
	.byte	1,5,5,9
	.half	.L57-.L696
	.byte	3,2,1,4,1,9
	.half	.L58-.L57
	.byte	3,157,1,1,5,30,7,9
	.half	.L391-.L58
	.byte	3,2,1,5,36,9
	.half	.L697-.L391
	.byte	1,5,46,9
	.half	.L59-.L697
	.byte	3,4,1,5,70,9
	.half	.L509-.L59
	.byte	1,5,5,9
	.half	.L60-.L509
	.byte	3,2,1,5,1,9
	.half	.L61-.L60
	.byte	3,1,1,7,9
	.half	.L242-.L61
	.byte	0,1,1
.L691:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ErrorDetection_IsBlockTypeDataset')
	.sect	'.debug_ranges'
.L241:
	.word	-1,.L122,0,.L242-.L122,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ErrorDetection_IsBlockIdxValid')
	.sect	'.debug_info'
.L243:
	.word	393
	.half	3
	.word	.L244
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L246,.L245
	.byte	2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_ErrorDetection_IsBlockIdxValid',0,1,131,5,9
	.word	.L274
	.byte	1,1,1
	.word	.L124,.L397,.L123
	.byte	4
	.byte	'idService_uo',0,1,131,5,70
	.word	.L274,.L398
	.byte	4
	.byte	'idBlock_uo',0,1,132,5,64
	.word	.L271,.L399
	.byte	4
	.byte	'idxData_u8',0,1,133,5,54
	.word	.L274,.L400
	.byte	5
	.word	.L124,.L397
	.byte	6
	.byte	'isBlockIdxValid_b',0,1,135,5,13
	.word	.L274,.L401
	.byte	7
	.word	.L402,.L403,.L404
	.byte	8
	.word	.L405,.L406
	.byte	9
	.word	.L407,.L403,.L404
	.byte	6
	.byte	'nrDataIndexes',0,2,254,3,11
	.word	.L274,.L408
	.byte	0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ErrorDetection_IsBlockIdxValid')
	.sect	'.debug_abbrev'
.L244:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,7,29,1,49,16,17,1,18,1,0,0,8,5,0,49,16,2,6,0,0,9,11,1,49,16,17
	.byte	1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ErrorDetection_IsBlockIdxValid')
	.sect	'.debug_line'
.L245:
	.word	.L699-.L698
.L698:
	.half	3
	.word	.L701-.L700
.L700:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockDescriptor.h',0,0,0,0,0
.L701:
	.byte	5,9,7,0,5,2
	.word	.L124
	.byte	3,130,5,1,5,31,9
	.half	.L516-.L124
	.byte	3,4,1,4,2,5,25,9
	.half	.L403-.L516
	.byte	3,247,126,1,5,5,9
	.half	.L517-.L403
	.byte	3,1,1,5,55,7,9
	.half	.L702-.L517
	.byte	3,3,1,5,26,9
	.half	.L518-.L702
	.byte	1,5,55,9
	.half	.L703-.L518
	.byte	1,5,67,9
	.half	.L704-.L703
	.byte	3,127,1,9
	.half	.L705-.L704
	.byte	3,1,1,5,82,9
	.half	.L706-.L705
	.byte	3,127,1,5,5,9
	.half	.L62-.L706
	.byte	3,3,1,4,1,9
	.half	.L63-.L62
	.byte	3,132,1,1,5,27,7,9
	.half	.L404-.L63
	.byte	3,2,1,5,33,9
	.half	.L707-.L404
	.byte	1,5,46,9
	.half	.L64-.L707
	.byte	3,4,1,5,74,9
	.half	.L514-.L64
	.byte	1,5,5,9
	.half	.L65-.L514
	.byte	3,2,1,5,1,9
	.half	.L66-.L65
	.byte	3,1,1,7,9
	.half	.L247-.L66
	.byte	0,1,1
.L699:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ErrorDetection_IsBlockIdxValid')
	.sect	'.debug_ranges'
.L246:
	.word	-1,.L124,0,.L247-.L124,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ErrorDetection_IsBlockPriorityImmediate')
	.sect	'.debug_info'
.L248:
	.word	404
	.half	3
	.word	.L249
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L251,.L250
	.byte	2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_ErrorDetection_IsBlockPriorityImmediate',0,1,147,5,9
	.word	.L274
	.byte	1,1,1
	.word	.L126,.L409,.L125
	.byte	4
	.byte	'idService_uo',0,1,147,5,79
	.word	.L274,.L410
	.byte	4
	.byte	'idBlock_uo',0,1,148,5,73
	.word	.L271,.L411
	.byte	5
	.word	.L126,.L409
	.byte	6
	.byte	'isBlockPriorityImmediate_b',0,1,150,5,13
	.word	.L274,.L412
	.byte	7
	.word	.L413,.L414,.L67
	.byte	8
	.word	.L415,.L416
	.byte	9
	.word	.L417,.L414,.L67
	.byte	6
	.byte	'HasBlockImmediateJobPriority_b',0,2,167,3,13
	.word	.L274,.L418
	.byte	0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ErrorDetection_IsBlockPriorityImmediate')
	.sect	'.debug_abbrev'
.L249:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,7,29,1,49,16,17,1,18,1,0,0,8,5,0,49,16,2,6,0,0,9,11,1,49,16,17
	.byte	1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ErrorDetection_IsBlockPriorityImmediate')
	.sect	'.debug_line'
.L250:
	.word	.L709-.L708
.L708:
	.half	3
	.word	.L711-.L710
.L710:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockDescriptor.h',0,0,0,0,0
.L711:
	.byte	5,9,7,0,5,2
	.word	.L126
	.byte	3,146,5,1,5,40,9
	.half	.L521-.L126
	.byte	3,3,1,4,2,5,5,9
	.half	.L414-.L521
	.byte	3,154,126,1,4,1,9
	.half	.L67-.L414
	.byte	3,231,1,1,5,36,7,9
	.half	.L712-.L67
	.byte	3,2,1,5,42,9
	.half	.L713-.L712
	.byte	1,5,46,9
	.half	.L68-.L713
	.byte	3,4,1,5,66,9
	.half	.L520-.L68
	.byte	1,5,5,9
	.half	.L69-.L520
	.byte	3,2,1,5,1,9
	.half	.L70-.L69
	.byte	3,1,1,7,9
	.half	.L252-.L70
	.byte	0,1,1
.L709:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ErrorDetection_IsBlockPriorityImmediate')
	.sect	'.debug_ranges'
.L251:
	.word	-1,.L126,0,.L252-.L126,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ErrorDetection_IsBlockWriteProtectionChangeable')
	.sect	'.debug_info'
.L253:
	.word	384
	.half	3
	.word	.L254
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L256,.L255
	.byte	2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_ErrorDetection_IsBlockWriteProtectionChangeable',0,1,162,5,9
	.word	.L274
	.byte	1,1,1
	.word	.L128,.L419,.L127
	.byte	4
	.byte	'idService_uo',0,1,162,5,87
	.word	.L274,.L420
	.byte	4
	.byte	'idBlock_uo',0,1,163,5,81
	.word	.L271,.L421
	.byte	5
	.word	.L128,.L419
	.byte	6
	.byte	'isBlockWriteProtectionChangeable_b',0,1,165,5,13
	.word	.L274,.L422
	.byte	7
	.word	.L423,.L424,.L425
	.byte	8
	.word	.L426,.L427
	.byte	8
	.word	.L428,.L429
	.byte	9
	.word	.L430,.L424,.L425
	.byte	0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ErrorDetection_IsBlockWriteProtectionChangeable')
	.sect	'.debug_abbrev'
.L254:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,7,29,1,49,16,17,1,18,1,0,0,8,5,0,49,16,2,6,0,0,9,11,0,49,16,17
	.byte	1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ErrorDetection_IsBlockWriteProtectionChangeable')
	.sect	'.debug_line'
.L255:
	.word	.L715-.L714
.L714:
	.half	3
	.word	.L717-.L716
.L716:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockDescriptor.h',0,0,0,0,0
.L717:
	.byte	5,9,7,0,5,2
	.word	.L128
	.byte	3,161,5,1,5,48,9
	.half	.L524-.L128
	.byte	3,3,1,5,46,9
	.half	.L525-.L524
	.byte	3,1,1,4,2,9
	.half	.L424-.L525
	.byte	3,204,125,1,5,13,9
	.half	.L718-.L424
	.byte	1,5,44,7,9
	.half	.L719-.L718
	.byte	3,1,1,5,15,9
	.half	.L720-.L719
	.byte	1,5,44,9
	.half	.L721-.L720
	.byte	1,5,56,9
	.half	.L722-.L721
	.byte	1,5,69,9
	.half	.L723-.L722
	.byte	1,5,46,9
	.half	.L724-.L723
	.byte	3,127,1,5,5,9
	.half	.L71-.L724
	.byte	1,4,1,5,10,9
	.half	.L73-.L71
	.byte	3,180,2,1,5,44,7,9
	.half	.L425-.L73
	.byte	3,2,1,5,50,9
	.half	.L725-.L425
	.byte	1,5,46,9
	.half	.L74-.L725
	.byte	3,4,1,5,66,9
	.half	.L523-.L74
	.byte	1,5,5,9
	.half	.L75-.L523
	.byte	3,2,1,5,1,9
	.half	.L76-.L75
	.byte	3,1,1,7,9
	.half	.L257-.L76
	.byte	0,1,1
.L715:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ErrorDetection_IsBlockWriteProtectionChangeable')
	.sect	'.debug_ranges'
.L256:
	.word	-1,.L128,0,.L257-.L128,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ReportDetError')
	.sect	'.debug_info'
.L258:
	.word	272
	.half	3
	.word	.L259
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L261,.L260
	.byte	2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_ReportDetError',0,1,98,13,1,1
	.word	.L80,.L431,.L79
	.byte	4
	.byte	'idService_uo',0,1,98,58
	.word	.L274,.L432
	.byte	4
	.byte	'idError_uo',0,1,99,59
	.word	.L274,.L433
	.byte	4
	.byte	'idBlock_uo',0,1,100,52
	.word	.L271,.L434
	.byte	5
	.word	.L80,.L431
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ReportDetError')
	.sect	'.debug_abbrev'
.L259:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ReportDetError')
	.sect	'.debug_line'
.L260:
	.word	.L727-.L726
.L726:
	.half	3
	.word	.L729-.L728
.L728:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0,0,0,0,0
.L729:
	.byte	5,13,7,0,5,2
	.word	.L80
	.byte	3,225,0,1,5,27,9
	.half	.L730-.L80
	.byte	3,6,1,5,42,9
	.half	.L438-.L730
	.byte	1,5,73,9
	.half	.L437-.L438
	.byte	1,5,5,9
	.half	.L731-.L437
	.byte	3,3,1,5,38,9
	.half	.L732-.L731
	.byte	1,5,5,9
	.half	.L733-.L732
	.byte	3,1,1,5,31,9
	.half	.L440-.L733
	.byte	1,5,5,9
	.half	.L441-.L440
	.byte	3,1,1,5,36,9
	.half	.L442-.L441
	.byte	1,5,1,9
	.half	.L443-.L442
	.byte	3,1,1,7,9
	.half	.L262-.L443
	.byte	0,1,1
.L727:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ReportDetError')
	.sect	'.debug_ranges'
.L261:
	.word	-1,.L80,0,.L262-.L80,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Rb_stBlockErrors_au8')
	.sect	'.debug_info'
.L263:
	.word	182
	.half	3
	.word	.L264
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1,2
	.word	.L129
	.byte	3
	.byte	'NvM_Rb_stBlockErrors_au8',0,8,36,7
	.word	.L435
	.byte	1,5,3
	.word	NvM_Rb_stBlockErrors_au8
	.byte	0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Rb_stBlockErrors_au8')
	.sect	'.debug_abbrev'
.L264:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,0,0,2,61,0,24,16,0,0,3,52,0,3,8,58,15,59,15,57,15,73,16,63,12,2,9
	.byte	0,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_idLastDetError_uo')
	.sect	'.debug_info'
.L265:
	.word	183
	.half	3
	.word	.L266
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1,2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_idLastDetError_uo',0,8,45,24
	.word	.L274
	.byte	1,5,3
	.word	NvM_Prv_idLastDetError_uo
	.byte	0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_idLastDetError_uo')
	.sect	'.debug_abbrev'
.L266:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,0,0,2,61,0,24,16,0,0,3,52,0,3,8,58,15,59,15,57,15,73,16,63,12,2,9
	.byte	0,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_idServiceLastDetError_uo')
	.sect	'.debug_info'
.L267:
	.word	190
	.half	3
	.word	.L268
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1,2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_idServiceLastDetError_uo',0,8,47,23
	.word	.L274
	.byte	1,5,3
	.word	NvM_Prv_idServiceLastDetError_uo
	.byte	0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_idServiceLastDetError_uo')
	.sect	'.debug_abbrev'
.L268:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,0,0,2,61,0,24,16,0,0,3,52,0,3,8,58,15,59,15,57,15,73,16,63,12,2,9
	.byte	0,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_idBlockLastDetError_uo')
	.sect	'.debug_info'
.L269:
	.word	188
	.half	3
	.word	.L270
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ErrorDetection.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1,2
	.word	.L129
	.byte	3
	.byte	'NvM_Prv_idBlockLastDetError_uo',0,8,50,17
	.word	.L271
	.byte	1,5,3
	.word	NvM_Prv_idBlockLastDetError_uo
	.byte	0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_idBlockLastDetError_uo')
	.sect	'.debug_abbrev'
.L270:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,0,0,2,61,0,24,16,0,0,3,52,0,3,8,58,15,59,15,57,15,73,16,63,12,2,9
	.byte	0,0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ErrorDetection_InitializeDetError')
	.sect	'.debug_loc'
.L81:
	.word	-1,.L82,0,.L273-.L82
	.half	2
	.byte	138,0
	.word	0,0
.L275:
	.word	-1,.L82,0,.L273-.L82
	.half	1
	.byte	84
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ErrorDetection_InitializeProductionErrors')
	.sect	'.debug_loc'
.L83:
	.word	-1,.L84,0,.L276-.L84
	.half	2
	.byte	138,0
	.word	0,0
.L277:
	.word	-1,.L84,.L444-.L84,.L276-.L84
	.half	1
	.byte	95
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ErrorDetection_IsBlockIdValid')
	.sect	'.debug_loc'
.L115:
	.word	-1,.L116,0,.L363-.L116
	.half	2
	.byte	138,0
	.word	0,0
.L368:
	.word	-1,.L116,.L497-.L116,.L41-.L116
	.half	1
	.byte	81
	.word	.L42-.L116,.L45-.L116
	.half	1
	.byte	81
	.word	0,0
.L365:
	.word	-1,.L116,0,.L41-.L116
	.half	1
	.byte	85
	.word	.L496-.L116,.L41-.L116
	.half	5
	.byte	144,32,157,32,0
	.word	.L42-.L116,.L45-.L116
	.half	5
	.byte	144,32,157,32,0
	.word	.L42-.L116,.L498-.L116
	.half	1
	.byte	85
	.word	.L499-.L116,.L45-.L116
	.half	1
	.byte	86
	.word	0,0
.L364:
	.word	-1,.L116,0,.L41-.L116
	.half	1
	.byte	84
	.word	.L42-.L116,.L45-.L116
	.half	1
	.byte	84
	.word	0,0
.L367:
	.word	-1,.L116,.L500-.L116,.L363-.L116
	.half	1
	.byte	88
	.word	0,0
.L366:
	.word	-1,.L116,0,.L41-.L116
	.half	1
	.byte	86
	.word	.L42-.L116,.L499-.L116
	.half	1
	.byte	86
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ErrorDetection_IsBlockIdxValid')
	.sect	'.debug_loc'
.L123:
	.word	-1,.L124,0,.L397-.L124
	.half	2
	.byte	138,0
	.word	0,0
.L406:
	.word	0,0
.L399:
	.word	-1,.L124,0,.L514-.L124
	.half	1
	.byte	85
	.word	.L516-.L124,.L65-.L124
	.half	5
	.byte	144,32,157,32,0
	.word	.L515-.L124,.L65-.L124
	.half	1
	.byte	86
	.word	0,0
.L398:
	.word	-1,.L124,0,.L65-.L124
	.half	1
	.byte	84
	.word	0,0
.L400:
	.word	-1,.L124,0,.L515-.L124
	.half	1
	.byte	86
	.word	0,0
.L401:
	.word	-1,.L124,.L403-.L124,.L397-.L124
	.half	1
	.byte	88
	.word	.L519-.L124,.L397-.L124
	.half	1
	.byte	82
	.word	0,0
.L408:
	.word	-1,.L124,.L517-.L124,.L518-.L124
	.half	1
	.byte	95
	.word	.L62-.L124,.L397-.L124
	.half	1
	.byte	95
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ErrorDetection_IsBlockPending')
	.sect	'.debug_loc'
.L87:
	.word	-1,.L88,0,.L281-.L88
	.half	2
	.byte	138,0
	.word	0,0
.L283:
	.word	-1,.L88,0,.L445-.L88
	.half	1
	.byte	85
	.word	.L447-.L88,.L281-.L88
	.half	1
	.byte	95
	.word	.L446-.L88,.L6-.L88
	.half	1
	.byte	86
	.word	0,0
.L282:
	.word	-1,.L88,0,.L6-.L88
	.half	1
	.byte	84
	.word	0,0
.L284:
	.word	-1,.L88,0,.L446-.L88
	.half	1
	.byte	86
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ErrorDetection_IsBlockPriorityImmediate')
	.sect	'.debug_loc'
.L418:
	.word	0,0
.L125:
	.word	-1,.L126,0,.L409-.L126
	.half	2
	.byte	138,0
	.word	0,0
.L416:
	.word	0,0
.L411:
	.word	-1,.L126,0,.L520-.L126
	.half	1
	.byte	85
	.word	.L521-.L126,.L69-.L126
	.half	1
	.byte	86
	.word	0,0
.L410:
	.word	-1,.L126,0,.L69-.L126
	.half	1
	.byte	84
	.word	0,0
.L412:
	.word	-1,.L126,.L414-.L126,.L409-.L126
	.half	1
	.byte	88
	.word	.L522-.L126,.L409-.L126
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ErrorDetection_IsBlockSizeValidForExplicitSync')
	.sect	'.debug_loc'
.L314:
	.word	-1,.L96,.L464-.L96,.L21-.L96
	.half	1
	.byte	81
	.word	0,0
.L95:
	.word	-1,.L96,0,.L302-.L96
	.half	2
	.byte	138,0
	.word	0,0
.L306:
	.word	-1,.L96,0,.L462-.L96
	.half	1
	.byte	86
	.word	0,0
.L304:
	.word	-1,.L96,0,.L463-.L96
	.half	1
	.byte	85
	.word	.L309-.L96,.L21-.L96
	.half	5
	.byte	144,32,157,32,0
	.word	.L462-.L96,.L21-.L96
	.half	1
	.byte	86
	.word	0,0
.L312:
	.word	0,0
.L303:
	.word	-1,.L96,0,.L21-.L96
	.half	1
	.byte	84
	.word	0,0
.L307:
	.word	-1,.L96,.L310-.L96,.L302-.L96
	.half	1
	.byte	95
	.word	.L465-.L96,.L302-.L96
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ErrorDetection_IsBlockTypeDataset')
	.sect	'.debug_loc'
.L396:
	.word	-1,.L122,.L511-.L122,.L512-.L122
	.half	1
	.byte	95
	.word	.L57-.L122,.L385-.L122
	.half	1
	.byte	95
	.word	0,0
.L121:
	.word	-1,.L122,0,.L385-.L122
	.half	2
	.byte	138,0
	.word	0,0
.L393:
	.word	0,0
.L387:
	.word	-1,.L122,0,.L509-.L122
	.half	1
	.byte	85
	.word	.L510-.L122,.L60-.L122
	.half	1
	.byte	86
	.word	0,0
.L386:
	.word	-1,.L122,0,.L60-.L122
	.half	1
	.byte	84
	.word	0,0
.L388:
	.word	-1,.L122,.L390-.L122,.L385-.L122
	.half	1
	.byte	88
	.word	.L513-.L122,.L385-.L122
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ErrorDetection_IsBlockWriteProtectionChangeable')
	.sect	'.debug_loc'
.L127:
	.word	-1,.L128,0,.L419-.L128
	.half	2
	.byte	138,0
	.word	0,0
.L429:
	.word	0,0
.L427:
	.word	0,0
.L421:
	.word	-1,.L128,0,.L523-.L128
	.half	1
	.byte	85
	.word	.L524-.L128,.L75-.L128
	.half	1
	.byte	86
	.word	0,0
.L420:
	.word	-1,.L128,0,.L75-.L128
	.half	1
	.byte	84
	.word	0,0
.L422:
	.word	-1,.L128,.L525-.L128,.L419-.L128
	.half	1
	.byte	88
	.word	.L526-.L128,.L419-.L128
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ErrorDetection_IsDefaultDataAvailable')
	.sect	'.debug_loc'
.L117:
	.word	-1,.L118,0,.L369-.L118
	.half	2
	.byte	138,0
	.word	0,0
.L377:
	.word	0,0
.L371:
	.word	-1,.L118,0,.L501-.L118
	.half	1
	.byte	85
	.word	.L502-.L118,.L52-.L118
	.half	1
	.byte	86
	.word	0,0
.L370:
	.word	-1,.L118,0,.L52-.L118
	.half	1
	.byte	84
	.word	0,0
.L372:
	.word	-1,.L118,.L374-.L118,.L369-.L118
	.half	1
	.byte	88
	.word	.L503-.L118,.L369-.L118
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ErrorDetection_IsJobIdValid')
	.sect	'.debug_loc'
.L91:
	.word	-1,.L92,0,.L290-.L92
	.half	2
	.byte	138,0
	.word	0,0
.L292:
	.word	-1,.L92,0,.L453-.L92
	.half	1
	.byte	85
	.word	.L455-.L92,.L9-.L92
	.half	5
	.byte	144,32,157,32,0
	.word	.L454-.L92,.L9-.L92
	.half	1
	.byte	86
	.word	0,0
.L294:
	.word	-1,.L92,0,.L454-.L92
	.half	1
	.byte	86
	.word	0,0
.L291:
	.word	-1,.L92,0,.L9-.L92
	.half	1
	.byte	84
	.word	0,0
.L295:
	.word	-1,.L92,.L456-.L92,.L290-.L92
	.half	1
	.byte	95
	.word	.L457-.L92,.L290-.L92
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible')
	.sect	'.debug_loc'
.L300:
	.word	-1,.L94,0,.L458-.L94
	.half	1
	.byte	86
	.word	0,0
.L93:
	.word	-1,.L94,0,.L296-.L94
	.half	2
	.byte	138,0
	.word	0,0
.L298:
	.word	-1,.L94,0,.L459-.L94
	.half	1
	.byte	85
	.word	.L460-.L94,.L16-.L94
	.half	5
	.byte	144,32,157,32,0
	.word	.L458-.L94,.L16-.L94
	.half	1
	.byte	86
	.word	0,0
.L297:
	.word	-1,.L94,0,.L16-.L94
	.half	1
	.byte	84
	.word	0,0
.L301:
	.word	-1,.L94,.L461-.L94,.L296-.L94
	.half	1
	.byte	95
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ErrorDetection_IsNvmInitialized')
	.sect	'.debug_loc'
.L113:
	.word	-1,.L114,0,.L359-.L114
	.half	2
	.byte	138,0
	.word	0,0
.L361:
	.word	-1,.L114,0,.L490-.L114
	.half	1
	.byte	85
	.word	.L493-.L114,.L494-.L114
	.half	1
	.byte	89
	.word	.L494-.L114,.L39-.L114
	.half	1
	.byte	86
	.word	0,0
.L360:
	.word	-1,.L114,0,.L490-.L114
	.half	1
	.byte	84
	.word	.L492-.L114,.L493-.L114
	.half	1
	.byte	88
	.word	.L493-.L114,.L39-.L114
	.half	1
	.byte	84
	.word	0,0
.L362:
	.word	-1,.L114,.L490-.L114,.L39-.L114
	.half	1
	.byte	82
	.word	.L491-.L114,.L359-.L114
	.half	1
	.byte	95
	.word	.L495-.L114,.L359-.L114
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForBlockId')
	.sect	'.debug_loc'
.L109:
	.word	-1,.L110,0,.L349-.L110
	.half	2
	.byte	138,0
	.word	0,0
.L350:
	.word	-1,.L110,0,.L35-.L110
	.half	1
	.byte	84
	.word	0,0
.L353:
	.word	-1,.L110,.L486-.L110,.L349-.L110
	.half	1
	.byte	95
	.word	.L487-.L110,.L349-.L110
	.half	1
	.byte	82
	.word	0,0
.L352:
	.word	-1,.L110,0,.L35-.L110
	.half	1
	.byte	100
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForBlockLength')
	.sect	'.debug_loc'
.L105:
	.word	-1,.L106,0,.L338-.L106
	.half	2
	.byte	138,0
	.word	0,0
.L340:
	.word	-1,.L106,0,.L480-.L106
	.half	1
	.byte	85
	.word	.L481-.L106,.L31-.L106
	.half	1
	.byte	86
	.word	0,0
.L339:
	.word	-1,.L106,0,.L31-.L106
	.half	1
	.byte	84
	.word	0,0
.L343:
	.word	-1,.L106,.L482-.L106,.L338-.L106
	.half	1
	.byte	95
	.word	.L483-.L106,.L338-.L106
	.half	1
	.byte	82
	.word	0,0
.L342:
	.word	-1,.L106,0,.L31-.L106
	.half	1
	.byte	100
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForDataIdx')
	.sect	'.debug_loc'
.L97:
	.word	-1,.L98,0,.L315-.L98
	.half	2
	.byte	138,0
	.word	0,0
.L317:
	.word	-1,.L98,0,.L466-.L98
	.half	1
	.byte	85
	.word	.L467-.L98,.L23-.L98
	.half	1
	.byte	86
	.word	0,0
.L316:
	.word	-1,.L98,0,.L23-.L98
	.half	1
	.byte	84
	.word	0,0
.L320:
	.word	-1,.L98,.L468-.L98,.L315-.L98
	.half	1
	.byte	95
	.word	.L469-.L98,.L315-.L98
	.half	1
	.byte	82
	.word	0,0
.L319:
	.word	-1,.L98,0,.L23-.L98
	.half	1
	.byte	100
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForMigrationResult')
	.sect	'.debug_loc'
.L101:
	.word	-1,.L102,0,.L327-.L102
	.half	2
	.byte	138,0
	.word	0,0
.L329:
	.word	-1,.L102,0,.L474-.L102
	.half	1
	.byte	85
	.word	.L475-.L102,.L27-.L102
	.half	1
	.byte	86
	.word	0,0
.L328:
	.word	-1,.L102,0,.L27-.L102
	.half	1
	.byte	84
	.word	0,0
.L332:
	.word	-1,.L102,.L476-.L102,.L327-.L102
	.half	1
	.byte	95
	.word	.L477-.L102,.L327-.L102
	.half	1
	.byte	82
	.word	0,0
.L331:
	.word	-1,.L102,0,.L27-.L102
	.half	1
	.byte	100
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForNvmStatus')
	.sect	'.debug_loc'
.L103:
	.word	-1,.L104,0,.L333-.L104
	.half	2
	.byte	138,0
	.word	0,0
.L334:
	.word	-1,.L104,0,.L29-.L104
	.half	1
	.byte	84
	.word	0,0
.L337:
	.word	-1,.L104,.L478-.L104,.L333-.L104
	.half	1
	.byte	95
	.word	.L479-.L104,.L333-.L104
	.half	1
	.byte	82
	.word	0,0
.L336:
	.word	-1,.L104,0,.L29-.L104
	.half	1
	.byte	100
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForRequestResult')
	.sect	'.debug_loc'
.L99:
	.word	-1,.L100,0,.L321-.L100
	.half	2
	.byte	138,0
	.word	0,0
.L323:
	.word	-1,.L100,0,.L470-.L100
	.half	1
	.byte	85
	.word	.L471-.L100,.L25-.L100
	.half	1
	.byte	86
	.word	0,0
.L322:
	.word	-1,.L100,0,.L25-.L100
	.half	1
	.byte	84
	.word	0,0
.L326:
	.word	-1,.L100,.L472-.L100,.L321-.L100
	.half	1
	.byte	95
	.word	.L473-.L100,.L321-.L100
	.half	1
	.byte	82
	.word	0,0
.L325:
	.word	-1,.L100,0,.L25-.L100
	.half	1
	.byte	100
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForServiceId')
	.sect	'.debug_loc'
.L107:
	.word	-1,.L108,0,.L344-.L108
	.half	2
	.byte	138,0
	.word	0,0
.L345:
	.word	-1,.L108,0,.L33-.L108
	.half	1
	.byte	84
	.word	0,0
.L348:
	.word	-1,.L108,.L484-.L108,.L344-.L108
	.half	1
	.byte	95
	.word	.L485-.L108,.L344-.L108
	.half	1
	.byte	82
	.word	0,0
.L347:
	.word	-1,.L108,0,.L33-.L108
	.half	1
	.byte	100
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForVersionInfo')
	.sect	'.debug_loc'
.L111:
	.word	-1,.L112,0,.L354-.L112
	.half	2
	.byte	138,0
	.word	0,0
.L355:
	.word	-1,.L112,0,.L37-.L112
	.half	1
	.byte	84
	.word	0,0
.L358:
	.word	-1,.L112,.L488-.L112,.L354-.L112
	.half	1
	.byte	95
	.word	.L489-.L112,.L354-.L112
	.half	1
	.byte	82
	.word	0,0
.L357:
	.word	-1,.L112,0,.L37-.L112
	.half	1
	.byte	100
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ErrorDetection_IsRamBlockAddressValid')
	.sect	'.debug_loc'
.L119:
	.word	-1,.L120,0,.L379-.L120
	.half	2
	.byte	138,0
	.word	0,0
.L383:
	.word	-1,.L120,0,.L504-.L120
	.half	1
	.byte	100
	.word	.L54-.L120,.L55-.L120
	.half	1
	.byte	100
	.word	0,0
.L381:
	.word	-1,.L120,0,.L505-.L120
	.half	1
	.byte	85
	.word	.L506-.L120,.L504-.L120
	.half	1
	.byte	86
	.word	.L54-.L120,.L55-.L120
	.half	1
	.byte	85
	.word	.L54-.L120,.L55-.L120
	.half	1
	.byte	86
	.word	0,0
.L380:
	.word	-1,.L120,0,.L504-.L120
	.half	1
	.byte	84
	.word	.L54-.L120,.L55-.L120
	.half	1
	.byte	84
	.word	0,0
.L384:
	.word	-1,.L120,.L507-.L120,.L379-.L120
	.half	1
	.byte	95
	.word	.L508-.L120,.L379-.L120
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ErrorDetection_IsServiceBitValid')
	.sect	'.debug_loc'
.L89:
	.word	-1,.L90,0,.L285-.L90
	.half	2
	.byte	138,0
	.word	0,0
.L288:
	.word	-1,.L90,0,.L448-.L90
	.half	1
	.byte	86
	.word	0,0
.L287:
	.word	-1,.L90,0,.L449-.L90
	.half	1
	.byte	85
	.word	.L450-.L90,.L7-.L90
	.half	5
	.byte	144,32,157,32,0
	.word	.L448-.L90,.L7-.L90
	.half	1
	.byte	86
	.word	0,0
.L286:
	.word	-1,.L90,0,.L7-.L90
	.half	1
	.byte	84
	.word	0,0
.L289:
	.word	-1,.L90,.L451-.L90,.L285-.L90
	.half	1
	.byte	95
	.word	.L452-.L90,.L285-.L90
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ErrorDetection_SetProductionError')
	.sect	'.debug_loc'
.L280:
	.word	-1,.L86,0,.L278-.L86
	.half	1
	.byte	85
	.word	0,0
.L85:
	.word	-1,.L86,0,.L278-.L86
	.half	2
	.byte	138,0
	.word	0,0
.L279:
	.word	-1,.L86,0,.L278-.L86
	.half	1
	.byte	84
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ReportDetError')
	.sect	'.debug_loc'
.L79:
	.word	-1,.L80,0,.L431-.L80
	.half	2
	.byte	138,0
	.word	0,0
.L434:
	.word	-1,.L80,0,.L436-.L80
	.half	1
	.byte	86
	.word	.L442-.L80,.L443-.L80
	.half	1
	.byte	89
	.word	0,0
.L433:
	.word	-1,.L80,0,.L437-.L80
	.half	1
	.byte	85
	.word	.L437-.L80,.L436-.L80
	.half	1
	.byte	88
	.word	.L440-.L80,.L441-.L80
	.half	1
	.byte	88
	.word	0,0
.L432:
	.word	-1,.L80,0,.L438-.L80
	.half	1
	.byte	84
	.word	.L439-.L80,.L431-.L80
	.half	1
	.byte	95
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Rb_GetBlockIdCausingLastDetError')
	.sect	'.debug_loc'
.L77:
	.word	-1,.L78,0,.L272-.L78
	.half	2
	.byte	138,0
	.word	0,0
	.sdecl	'.debug_frame',debug
	.sect	'.debug_frame'
.L734:
	.word	48
	.word	-1
	.byte	3,0,2,1,27,12,26,0,8,27,8,26,8,28,8,29,8,30,8,31,8,34,8,35,8,32,8,33,8,16,8,17,8,24,8,25,8,36,8,37,8,38
	.byte	8,39
	.sdecl	'.debug_frame',debug,cluster('NvM_Rb_GetBlockIdCausingLastDetError')
	.sect	'.debug_frame'
	.word	24
	.word	.L734,.L78,.L272-.L78
	.byte	8,18,8,19,8,20,8,21,8,22,8,23
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ReportDetError')
	.sect	'.debug_frame'
	.word	12
	.word	.L734,.L80,.L431-.L80
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ErrorDetection_InitializeDetError')
	.sect	'.debug_frame'
	.word	24
	.word	.L734,.L82,.L273-.L82
	.byte	8,18,8,19,8,20,8,21,8,22,8,23
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ErrorDetection_InitializeProductionErrors')
	.sect	'.debug_frame'
	.word	24
	.word	.L734,.L84,.L276-.L84
	.byte	8,18,8,19,8,20,8,21,8,22,8,23
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ErrorDetection_SetProductionError')
	.sect	'.debug_frame'
	.word	24
	.word	.L734,.L86,.L278-.L86
	.byte	8,19,8,20,8,21,8,22,8,23,0,0
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ErrorDetection_IsBlockPending')
	.sect	'.debug_frame'
	.word	12
	.word	.L734,.L88,.L281-.L88
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ErrorDetection_IsServiceBitValid')
	.sect	'.debug_frame'
	.word	12
	.word	.L734,.L90,.L285-.L90
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ErrorDetection_IsJobIdValid')
	.sect	'.debug_frame'
	.word	12
	.word	.L734,.L92,.L290-.L92
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ErrorDetection_IsJobResultMemIfPlausible')
	.sect	'.debug_frame'
	.word	12
	.word	.L734,.L94,.L296-.L94
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ErrorDetection_IsBlockSizeValidForExplicitSync')
	.sect	'.debug_frame'
	.word	12
	.word	.L734,.L96,.L302-.L96
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForDataIdx')
	.sect	'.debug_frame'
	.word	12
	.word	.L734,.L98,.L315-.L98
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForRequestResult')
	.sect	'.debug_frame'
	.word	12
	.word	.L734,.L100,.L321-.L100
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForMigrationResult')
	.sect	'.debug_frame'
	.word	12
	.word	.L734,.L102,.L327-.L102
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForNvmStatus')
	.sect	'.debug_frame'
	.word	12
	.word	.L734,.L104,.L333-.L104
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForBlockLength')
	.sect	'.debug_frame'
	.word	12
	.word	.L734,.L106,.L338-.L106
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForServiceId')
	.sect	'.debug_frame'
	.word	12
	.word	.L734,.L108,.L344-.L108
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForBlockId')
	.sect	'.debug_frame'
	.word	12
	.word	.L734,.L110,.L349-.L110
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ErrorDetection_IsPtrValidForVersionInfo')
	.sect	'.debug_frame'
	.word	12
	.word	.L734,.L112,.L354-.L112
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ErrorDetection_IsNvmInitialized')
	.sect	'.debug_frame'
	.word	12
	.word	.L734,.L114,.L359-.L114
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ErrorDetection_IsBlockIdValid')
	.sect	'.debug_frame'
	.word	12
	.word	.L734,.L116,.L363-.L116
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ErrorDetection_IsDefaultDataAvailable')
	.sect	'.debug_frame'
	.word	12
	.word	.L734,.L118,.L369-.L118
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ErrorDetection_IsRamBlockAddressValid')
	.sect	'.debug_frame'
	.word	12
	.word	.L734,.L120,.L379-.L120
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ErrorDetection_IsBlockTypeDataset')
	.sect	'.debug_frame'
	.word	12
	.word	.L734,.L122,.L385-.L122
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ErrorDetection_IsBlockIdxValid')
	.sect	'.debug_frame'
	.word	12
	.word	.L734,.L124,.L397-.L124
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ErrorDetection_IsBlockPriorityImmediate')
	.sect	'.debug_frame'
	.word	12
	.word	.L734,.L126,.L409-.L126
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ErrorDetection_IsBlockWriteProtectionChangeable')
	.sect	'.debug_frame'
	.word	12
	.word	.L734,.L128,.L419-.L128

; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   688  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   689  
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   690  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_ErrorDetection.c	   691  #include "NvM_MemMap.h"

	; Module end
