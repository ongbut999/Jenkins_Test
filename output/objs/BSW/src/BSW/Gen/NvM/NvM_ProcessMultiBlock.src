	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 19053136 SN 09001910"
	.compiler_invocation	"ctc -f cc16076a -c99 --integer-enumeration -D__CPU__=tc27x -D__CPU_TC27X__ --core=tc1.6.x --eabi-compliant --fp-model=-float -D_TASKING_C_TRICORE_=1 -I.\\output\\inc -g2 -t4 --language=-comments,-gcc,+volatile,-strings --default-near-size=0 -O2ROPYGKLF-predict --default-a1-size=0 --default-a0-size=0 --source --switch=auto -o output\\objs\\BSW\\src\\BSW\\Gen\\NvM\\NvM_ProcessMultiBlock.src BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c"
	.compiler_name		"ctc"
	;source	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c'

	
$TC16X
	
	.sdecl	'.text.NvM_ProcessMultiBlock.NvM_Prv_Multi_Initialize',code,cluster('NvM_Prv_Multi_Initialize')
	.sect	'.text.NvM_ProcessMultiBlock.NvM_Prv_Multi_Initialize'
	.align	2
	
	.global	NvM_Prv_Multi_Initialize

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	     2  /*
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	     3   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	     4   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	     5   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	     6  */
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	     7  #include "NvM.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	     8  #include "Rte_NvM.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	     9  #include "NvM_Cfg_SchM.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    10  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    11  #include "NvM_Prv.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    12  #include "NvM_Prv_Queue.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    13  #include "NvM_Prv_BlockData.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    14  #include "NvM_Prv_ProcessMultiBlock.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    15  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    16  #if (NVM_BSWM_MULTI_BLOCK_JOB_STATUS_INFORMATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    17  # include "BswM_NvM.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    18  // TRACE[NVM089] Check version compatibility of included header files
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    19  # if (!defined(BSWM_AR_RELEASE_MAJOR_VERSION) || (BSWM_AR_RELEASE_MAJOR_VERSION != NVM_AR_RELEASE_MAJOR_VERSION))
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    20  #  error "AUTOSAR major version undefined or mismatched"
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    21  # endif
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    22  # if (!defined(BSWM_AR_RELEASE_MINOR_VERSION) || ((BSWM_AR_RELEASE_MINOR_VERSION != 0) && \ 
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    23                                                    (BSWM_AR_RELEASE_MINOR_VERSION != 2)))
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    24  #  error "AUTOSAR minor version undefined or mismatched"
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    25  # endif
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    26  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    27  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    28  /*
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    29   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    30   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    31   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    32   */
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    33  typedef NvM_Prv_idJob_ten (*NvM_Prv_ProcessMulti_tpfct)(NvM_Prv_QueueEntry_tst* QueueEntry_pst);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    34  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    35  /*
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    37   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    38   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    39   */
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    40  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    41  /*
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    42   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    43   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    44   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    45   */
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    46  #define NVM_START_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    47  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    48  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    49  static NvM_Prv_ProcessMulti_tpfct NvM_Prv_ProcessMulti_pfct = NULL_PTR;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    50  static NvM_Prv_Multi_Cancel_tpfct NvM_Prv_Multi_Cancel_pfct = NULL_PTR;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    51  // TRACE[NVM393] Separate variable for the final result of asynchronous multiblock requests
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    52  static NvM_RequestResultType NvM_Prv_Multi_Result_uo = NVM_REQ_OK;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    53  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    54  #define NVM_STOP_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    56  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    57  /*
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    58   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    59   * Inline declarations
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    60   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    61   */
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    62  LOCAL_INLINE NvM_Prv_idJob_ten NvM_Prv_ProcessConfigId(NvM_Prv_QueueEntry_tst* QueueEntry_pst);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    63  LOCAL_INLINE NvM_Prv_idJob_ten NvM_Prv_ProcessUserBlocks(NvM_Prv_QueueEntry_tst* QueueEntry_pst);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    64  LOCAL_INLINE NvM_Prv_idJob_ten NvM_Prv_ProcessCancel(NvM_Prv_QueueEntry_tst* QueueEntry_pst);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    65  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    66  #if (NVM_DYNAMIC_CONFIGURATION || NVM_RB_INIT_AT_LAYOUT_CHANGE)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    67  LOCAL_INLINE NvM_Prv_idJob_ten NvM_Prv_WriteConfigId(NvM_Prv_QueueEntry_tst* QueueEntry_pst);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    68  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    69  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    70  LOCAL_INLINE NvM_Prv_idJob_ten NvM_Prv_FinishMulti(NvM_Prv_QueueEntry_tst* QueueEntry_pst);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    71  LOCAL_INLINE void NvM_Prv_NotifyMultiStart(NvM_Prv_idService_tuo idService_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    72  LOCAL_INLINE void NvM_Prv_NotifyMultiEnd(NvM_Prv_idService_tuo idService_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    73  LOCAL_INLINE boolean NvM_Prv_CheckIsFinalCallbackRequired(NvM_Prv_idService_tuo idService_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    74  LOCAL_INLINE boolean NvM_Prv_StartSecondaryMulti(NvM_Prv_QueueEntry_tst* QueueEntry_pst);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    75  LOCAL_INLINE NvM_BlockIdType NvM_Prv_FindNextBlock(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    76                                                     NvM_Prv_idService_tuo idService_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    77                                                     NvM_Prv_ServiceBit_tuo ServiceBit_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    78  LOCAL_INLINE NvM_Prv_idJob_ten NvM_Prv_GetJobIdForMulti(NvM_Prv_idService_tuo idService_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    79                                                          NvM_Prv_ServiceBit_tuo ServiceBit_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    80                                                          NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    81  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    82  #if (NVM_RB_REMOVE_NON_RESISTANT_BLOCKS || NVM_RB_INIT_AT_LAYOUT_CHANGE)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    83  LOCAL_INLINE boolean NvM_Prv_InitiateInitAfterReadAll(NvM_Prv_QueueEntry_tst* QueueEntry_pst);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    84  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    85  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    86  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    87  LOCAL_INLINE boolean NvM_Prv_InitiateMaintenance(NvM_Prv_QueueEntry_tst* QueueEntry_pst);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    88  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    89  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    90  /*
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    91   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    92   * Code
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    93   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    94  */
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    95  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    96  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    97  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    98  void NvM_Prv_Multi_Initialize(void)
; Function NvM_Prv_Multi_Initialize
.L78:
NvM_Prv_Multi_Initialize:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	    99  {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   100      NvM_Prv_ProcessMulti_pfct = NULL_PTR;
	movh.a	a15,#@his(NvM_Prv_ProcessMulti_pfct)
	lea	a15,[a15]@los(NvM_Prv_ProcessMulti_pfct)
.L322:
	mov.a	a2,#0
.L323:
	st.a	[a15],a2
.L324:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   101      NvM_Prv_Multi_Cancel_pfct = NULL_PTR;
	movh.a	a15,#@his(NvM_Prv_Multi_Cancel_pfct)
	lea	a15,[a15]@los(NvM_Prv_Multi_Cancel_pfct)
.L325:
	mov.a	a2,#0
.L326:
	st.a	[a15],a2
.L327:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   102      NvM_Prv_Multi_Result_uo = NVM_REQ_OK;
	movh.a	a15,#@his(NvM_Prv_Multi_Result_uo)
	lea	a15,[a15]@los(NvM_Prv_Multi_Result_uo)
.L328:
	mov	d15,#0
.L329:
	st.b	[a15],d15
.L330:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   103  }
	ret
.L157:
	
__NvM_Prv_Multi_Initialize_function_end:
	.size	NvM_Prv_Multi_Initialize,__NvM_Prv_Multi_Initialize_function_end-NvM_Prv_Multi_Initialize
.L105:
	; End of function
	
	.sdecl	'.text.NvM_ProcessMultiBlock.NvM_Prv_Multi_IsInProgress',code,cluster('NvM_Prv_Multi_IsInProgress')
	.sect	'.text.NvM_ProcessMultiBlock.NvM_Prv_Multi_IsInProgress'
	.align	2
	
	.global	NvM_Prv_Multi_IsInProgress

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   104  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   105  boolean NvM_Prv_Multi_IsInProgress(void)
; Function NvM_Prv_Multi_IsInProgress
.L80:
NvM_Prv_Multi_IsInProgress:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   106  {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   107      return (NULL_PTR != NvM_Prv_ProcessMulti_pfct);
	mov.a	a15,#0
.L335:
	movh.a	a2,#@his(NvM_Prv_ProcessMulti_pfct)
	lea	a2,[a2]@los(NvM_Prv_ProcessMulti_pfct)
	ld.a	a2,[a2]
.L336:
	ne.a	d2,a15,a2
.L337:
	j	.L2

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   108  }
.L2:
	ret
.L159:
	
__NvM_Prv_Multi_IsInProgress_function_end:
	.size	NvM_Prv_Multi_IsInProgress,__NvM_Prv_Multi_IsInProgress_function_end-NvM_Prv_Multi_IsInProgress
.L110:
	; End of function
	
	.sdecl	'.text.NvM_ProcessMultiBlock.NvM_Prv_Multi_SetResult',code,cluster('NvM_Prv_Multi_SetResult')
	.sect	'.text.NvM_ProcessMultiBlock.NvM_Prv_Multi_SetResult'
	.align	2
	
	.global	NvM_Prv_Multi_SetResult

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   110  void NvM_Prv_Multi_SetResult(NvM_RequestResultType Result_uo)
; Function NvM_Prv_Multi_SetResult
.L82:
NvM_Prv_Multi_SetResult:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   111  {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   112      NvM_Prv_Multi_Result_uo = Result_uo;
	movh.a	a15,#@his(NvM_Prv_Multi_Result_uo)
	lea	a15,[a15]@los(NvM_Prv_Multi_Result_uo)
.L342:
	st.b	[a15],d4
.L343:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   113  }
	ret
.L160:
	
__NvM_Prv_Multi_SetResult_function_end:
	.size	NvM_Prv_Multi_SetResult,__NvM_Prv_Multi_SetResult_function_end-NvM_Prv_Multi_SetResult
.L115:
	; End of function
	
	.sdecl	'.text.NvM_ProcessMultiBlock.NvM_Prv_Multi_GetResult',code,cluster('NvM_Prv_Multi_GetResult')
	.sect	'.text.NvM_ProcessMultiBlock.NvM_Prv_Multi_GetResult'
	.align	2
	
	.global	NvM_Prv_Multi_GetResult

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   115  NvM_RequestResultType NvM_Prv_Multi_GetResult(void)
; Function NvM_Prv_Multi_GetResult
.L84:
NvM_Prv_Multi_GetResult:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   117      return NvM_Prv_Multi_Result_uo;
	movh.a	a15,#@his(NvM_Prv_Multi_Result_uo)
	lea	a15,[a15]@los(NvM_Prv_Multi_Result_uo)
	ld.bu	d2,[a15]
.L348:
	j	.L3

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   118  }
.L3:
	ret
.L162:
	
__NvM_Prv_Multi_GetResult_function_end:
	.size	NvM_Prv_Multi_GetResult,__NvM_Prv_Multi_GetResult_function_end-NvM_Prv_Multi_GetResult
.L120:
	; End of function
	
	.sdecl	'.text.NvM_ProcessMultiBlock.NvM_Prv_Multi_Cancel',code,cluster('NvM_Prv_Multi_Cancel')
	.sect	'.text.NvM_ProcessMultiBlock.NvM_Prv_Multi_Cancel'
	.align	2
	
	.global	NvM_Prv_Multi_Cancel

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   120  void NvM_Prv_Multi_Cancel(NvM_Prv_Multi_Cancel_tpfct Cancel_pfct)
; Function NvM_Prv_Multi_Cancel
.L86:
NvM_Prv_Multi_Cancel:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   122      // Cancel requested multi-block service only if NvM is not already cancelling another multi-block service
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   123      if (NULL_PTR == NvM_Prv_Multi_Cancel_pfct)
	movh.a	a15,#@his(NvM_Prv_Multi_Cancel_pfct)
	lea	a15,[a15]@los(NvM_Prv_Multi_Cancel_pfct)
.L353:
	mov.a	a2,#0
.L354:
	ld.a	a5,[a15]
.L355:
	jne.a	a2,a5,.L4
.L356:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   124      {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   125          NvM_Prv_Multi_Cancel_pfct = Cancel_pfct;
	st.a	[a15],a4
.L4:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   126      }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   127  }
	ret
.L163:
	
__NvM_Prv_Multi_Cancel_function_end:
	.size	NvM_Prv_Multi_Cancel,__NvM_Prv_Multi_Cancel_function_end-NvM_Prv_Multi_Cancel
.L125:
	; End of function
	
	.sdecl	'.text.NvM_ProcessMultiBlock.NvM_Prv_Multi_Process',code,cluster('NvM_Prv_Multi_Process')
	.sect	'.text.NvM_ProcessMultiBlock.NvM_Prv_Multi_Process'
	.align	2
	
	.global	NvM_Prv_Multi_Process

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   128  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   129  NvM_Prv_idJob_ten NvM_Prv_Multi_Process(NvM_Prv_QueueEntry_tst* QueueEntry_pst)
; Function NvM_Prv_Multi_Process
.L88:
NvM_Prv_Multi_Process:	.type	func
	mov.aa	a12,a4
.L284:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   130  {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   131      NvM_Prv_idJob_ten idJob_en = NvM_Prv_idJob_Idle_e;
	mov	d2,#0
.L285:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   132  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   133      // start multi block service if not yet started
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   134      if (NULL_PTR == NvM_Prv_ProcessMulti_pfct)
	movh.a	a13,#@his(NvM_Prv_ProcessMulti_pfct)
	lea	a13,[a13]@los(NvM_Prv_ProcessMulti_pfct)
.L361:
	mov.a	a15,#0
.L362:
	ld.a	a2,[a13]
.L363:
	jne.a	a15,a2,.L5
.L364:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   135      {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   136          if (NVM_RB_CONFIG_ID_BLOCK == QueueEntry_pst->idBlock_uo)
	ld.hu	d15,[a12]2
.L365:
	jne	d15,#1,.L6
.L366:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   137          {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   138              NvM_Prv_ProcessMulti_pfct = NvM_Prv_ProcessConfigId;
	movh.a	a15,#@his(NvM_Prv_ProcessConfigId)
	lea	a15,[a15]@los(NvM_Prv_ProcessConfigId)
.L367:
	st.a	[a13],a15
.L368:
	j	.L7
.L6:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   139          }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   140          else
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   141          {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   142              NvM_Prv_ProcessMulti_pfct = NvM_Prv_ProcessUserBlocks;
	movh.a	a15,#@his(NvM_Prv_ProcessUserBlocks)
	lea	a15,[a15]@los(NvM_Prv_ProcessUserBlocks)
.L369:
	st.a	[a13],a15
.L7:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   143          }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   144  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   145          // TRACE[NVM395] Maintain overall result of the multiblock operation
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   146          NvM_Prv_Multi_Result_uo = NVM_REQ_OK;
	movh.a	a15,#@his(NvM_Prv_Multi_Result_uo)
	lea	a15,[a15]@los(NvM_Prv_Multi_Result_uo)
.L370:
	mov	d15,#0
.L371:
	st.b	[a15],d15
.L5:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   148          // Multiblock request acknowledged
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   149          // -> notify the user that the multiblock operation is being started
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   150          NvM_Prv_NotifyMultiStart(QueueEntry_pst->idService_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   151      }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   153      // cancel multi-block service if requested by user
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   154      if (NULL_PTR != NvM_Prv_Multi_Cancel_pfct)
	mov.a	a15,#0
.L372:
	movh.a	a2,#@his(NvM_Prv_Multi_Cancel_pfct)
	lea	a2,[a2]@los(NvM_Prv_Multi_Cancel_pfct)
	ld.a	a2,[a2]
.L373:
	jeq.a	a15,a2,.L8
.L374:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   155      {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   156          NvM_Prv_ProcessMulti_pfct = NvM_Prv_ProcessCancel;
	movh.a	a15,#@his(NvM_Prv_ProcessCancel)
	lea	a15,[a15]@los(NvM_Prv_ProcessCancel)
.L375:
	st.a	[a13],a15
.L8:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   157      }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   159      // process multi block service
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   160      while ((NULL_PTR != NvM_Prv_ProcessMulti_pfct) && (NvM_Prv_idJob_Idle_e == idJob_en))
	j	.L9
.L10:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   161      {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   162          idJob_en = NvM_Prv_ProcessMulti_pfct(QueueEntry_pst);
	ld.a	a15,[a13]
.L376:
	mov.aa	a4,a12
.L286:
	calli	a15
.L9:
	mov.a	a15,#0
.L377:
	ld.a	a2,[a13]
.L378:
	jeq.a	a15,a2,.L11
.L379:
	jeq	d2,#0,.L10
.L11:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   163      }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   164  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   165      return idJob_en;
	j	.L12

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   166  }
.L12:
	ret
.L167:
	
__NvM_Prv_Multi_Process_function_end:
	.size	NvM_Prv_Multi_Process,__NvM_Prv_Multi_Process_function_end-NvM_Prv_Multi_Process
.L130:
	; End of function
	
	.sdecl	'.text.NvM_ProcessMultiBlock.NvM_Prv_ProcessConfigId',code,cluster('NvM_Prv_ProcessConfigId')
	.sect	'.text.NvM_ProcessMultiBlock.NvM_Prv_ProcessConfigId'
	.align	2
	

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   167  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   169  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   170  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   171  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   172  /*
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   173   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   174   * Inline code
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   175   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   176   */
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   177  // ====================================================================================================================
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   178  LOCAL_INLINE NvM_Prv_idJob_ten NvM_Prv_ProcessConfigId(NvM_Prv_QueueEntry_tst* QueueEntry_pst)
; Function NvM_Prv_ProcessConfigId
.L90:
NvM_Prv_ProcessConfigId:	.type	func
	mov.aa	a12,a4
.L287:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   179  {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   180      NvM_Prv_idJob_ten idJob_en = NvM_Prv_idJob_Idle_e;
	mov	d2,#0
.L288:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   181  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   182      if (NvM_Prv_Block_IsRequestPending(NVM_RB_CONFIG_ID_BLOCK, (1u << QueueEntry_pst->ServiceBit_uo)))
	mov	d15,#1
.L384:
	ld.hu	d4,[a12]4
.L385:
	mov	d0,#1
.L386:
	sh	d0,d0,d4
	extr.u	d0,d0,#0,#16
.L175:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   169  LOCAL_INLINE boolean NvM_Prv_Block_IsRequestPending(NvM_BlockIdType idBlock_uo, uint16 maskService_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   170  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);
	movh.a	a2,#@his(NvM_Prv_stRequests_rAMwAM_au16)
	lea	a2,[a2]@los(NvM_Prv_stRequests_rAMwAM_au16)
.L387:
	addsc.a	a2,a2,d15,#1
	ld.hu	d15,[a2]0
.L388:
	and	d0,d15
.L389:
	ne	d15,d0,#0
.L390:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);      (inlined)
	j	.L13

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   172  }      (inlined)
.L13:
	jeq	d15,#0,.L14
.L391:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   183      {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   184          idJob_en = NvM_Prv_GetJobIdForMulti(QueueEntry_pst->idService_uo,
	ld.bu	d0,[a12]
.L392:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   185                                              QueueEntry_pst->ServiceBit_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   186                                              NVM_RB_CONFIG_ID_BLOCK);
	mov	d1,#1
.L182:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   187          QueueEntry_pst->BlockData_pv = NvM_Prv_GetPRamBlockAddress(QueueEntry_pst->idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   188      }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   189      else
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   190      {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   191          NvM_Prv_ProcessMulti_pfct = NvM_Prv_ProcessUserBlocks;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   192      }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   193  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   194      return idJob_en;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   195  }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   196  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   197  // ====================================================================================================================
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   198  LOCAL_INLINE NvM_Prv_idJob_ten NvM_Prv_ProcessUserBlocks(NvM_Prv_QueueEntry_tst* QueueEntry_pst)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   199  {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   200      NvM_Prv_idJob_ten idJob_en = NvM_Prv_idJob_Idle_e;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   201  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   202      QueueEntry_pst->idBlock_uo = NvM_Prv_FindNextBlock(QueueEntry_pst->idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   203                                                         QueueEntry_pst->idService_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   204                                                         QueueEntry_pst->ServiceBit_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   205  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   206      if (QueueEntry_pst->idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   207      {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   208          idJob_en = NvM_Prv_GetJobIdForMulti(QueueEntry_pst->idService_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   209                                              QueueEntry_pst->ServiceBit_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   210                                              QueueEntry_pst->idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   211          QueueEntry_pst->BlockData_pv = NvM_Prv_GetPRamBlockAddress(QueueEntry_pst->idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   212      }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   213      else
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   214      {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   215  #if (NVM_DYNAMIC_CONFIGURATION || NVM_RB_INIT_AT_LAYOUT_CHANGE)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   216          NvM_Prv_ProcessMulti_pfct = NvM_Prv_WriteConfigId;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   217  #else
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   218          NvM_Prv_ProcessMulti_pfct = NvM_Prv_FinishMulti;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   219  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   220      }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   221  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   222      return idJob_en;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   223  }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   224  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   225  // ====================================================================================================================
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   226  LOCAL_INLINE NvM_Prv_idJob_ten NvM_Prv_ProcessCancel(NvM_Prv_QueueEntry_tst* QueueEntry_pst)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   227  {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   228      NvM_Prv_idJob_ten idJob_en = NvM_Prv_idJob_Idle_e;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   229  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   230  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   231      if (NVM_SERVICE_ID_WRITE_ALL == QueueEntry_pst->idService_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   232      {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   233          NvM_Prv_Block_ClearRequests(NVM_PRV_MULTI_BLOCK, (1u << NvM_Prv_ServiceBit_Maintain_e));
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   234      }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   235  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   236  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   237      if (NvM_Prv_Multi_Cancel_pfct())
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   238      {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   239          NvM_Prv_Multi_Result_uo = NVM_REQ_CANCELED;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   240      }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   241  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   242      QueueEntry_pst->idBlock_uo = NVM_CFG_NR_BLOCKS;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   243      NvM_Prv_Multi_Cancel_pfct = NULL_PTR;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   244      NvM_Prv_ProcessMulti_pfct = NvM_Prv_FinishMulti;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   245  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   246      return idJob_en;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   247  }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   248  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   249  // ====================================================================================================================
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   250  #if (NVM_DYNAMIC_CONFIGURATION || NVM_RB_INIT_AT_LAYOUT_CHANGE)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   251  LOCAL_INLINE NvM_Prv_idJob_ten NvM_Prv_WriteConfigId(NvM_Prv_QueueEntry_tst* QueueEntry_pst)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   252  {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   253      NvM_Prv_idJob_ten idJob_en = NvM_Prv_idJob_Idle_e;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   254      uint16 maskRequest_u16 = ((1u << NvM_Prv_ServiceBit_WriteAll_e)           |
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   255                                (1u << NvM_Prv_ServiceBit_RemoveNonResistant_e) |
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   256                                (1u << NvM_Prv_ServiceBit_InitAtLayoutChange_e));
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   257  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   258      NvM_Prv_ProcessMulti_pfct = NvM_Prv_FinishMulti;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   259  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   260      if (((NVM_SERVICE_ID_WRITE_ALL == QueueEntry_pst->idService_uo) ||
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   261           (NVM_SERVICE_ID_RB_INIT_AFTER_READ_ALL == QueueEntry_pst->idService_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   262                  &&
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   263          NvM_Prv_Block_IsRequestPending(NVM_RB_CONFIG_ID_BLOCK, maskRequest_u16))
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   264      {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   265          NvM_Prv_Block_SetIdConfig(NVM_COMPILED_CONFIG_ID);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   266          idJob_en = NvM_Prv_idJob_Write_e;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   267          QueueEntry_pst->idBlock_uo = (NVM_COMPILED_CONFIG_ID);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   268          QueueEntry_pst->BlockData_pv = NvM_Prv_GetPRamBlockAddress(NVM_RB_CONFIG_ID_BLOCK);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   269      }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   270  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   271      return idJob_en;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   272  }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   273  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   274  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   275  // ====================================================================================================================
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   276  LOCAL_INLINE NvM_Prv_idJob_ten NvM_Prv_FinishMulti(NvM_Prv_QueueEntry_tst* QueueEntry_pst)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   277  {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   278      uint16 ServiceBitMask_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   279      NvM_Prv_idJob_ten idJob_en = NvM_Prv_idJob_Idle_e;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   280  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   281      if (NVM_SERVICE_ID_RB_INIT_AFTER_READ_ALL == QueueEntry_pst->idService_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   282      {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   283          ServiceBitMask_uo = (1u << NvM_Prv_ServiceBit_InitAtLayoutChange_e) |
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   284                              (1u << NvM_Prv_ServiceBit_RemoveNonResistant_e);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   285      }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   286      else
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   287      {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   288          ServiceBitMask_uo = (1u << QueueEntry_pst->ServiceBit_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   289      }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   290  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   291      NvM_Prv_Block_ClearRequests(NVM_PRV_MULTI_BLOCK, ServiceBitMask_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   292  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   293      NvM_Prv_NotifyMultiEnd(QueueEntry_pst->idService_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   294  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   295      if (NvM_Prv_StartSecondaryMulti(QueueEntry_pst))
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   296      {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   297          NvM_Prv_ProcessMulti_pfct = NvM_Prv_ProcessUserBlocks;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   298      }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   299      else
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   300      {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   301          // processing multiblock requests is idle
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   302          NvM_Prv_ProcessMulti_pfct = NULL_PTR;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   303          NvM_Prv_Main_st.QueueEntry_pst = NULL_PTR;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   304  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   305          SchM_Enter_NvM_Main();
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   306          NvM_Prv_Queue_DequeueRequest(NvM_Prv_idQueue_Multi_e);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   307          SchM_Exit_NvM_Main();
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   308      }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   310      return idJob_en;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   311  }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   312  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   313  // ====================================================================================================================
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   314  LOCAL_INLINE void NvM_Prv_NotifyMultiStart(NvM_Prv_idService_tuo idService_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   315  {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   316  #if (NVM_BSWM_MULTI_BLOCK_JOB_STATUS_INFORMATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   317      //If BswMMultiBlockJobStatusInformation is enabled, the multiblock start callback is not invoked
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   318  #else
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   319      // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2771] Invoke multiblock start callback (if configured).
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   320      NvM_Prv_InvokeMultiStartCallback(idService_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   321  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   322  }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   323  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   324  // ====================================================================================================================
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   325  LOCAL_INLINE void NvM_Prv_NotifyMultiEnd(NvM_Prv_idService_tuo idService_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   326  {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   327      if (NvM_Prv_CheckIsFinalCallbackRequired(idService_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   328      {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   329          // Determine the active service as indicated to the notification receiver
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   330          uint8 idActiveService_uo = idService_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   331  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   332  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   333          if (idActiveService_uo == NVM_PRV_SERVICE_ID_MAINTAIN_BLOCK)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   334          {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   335              // Maintenance shall be an "invisible" operation after WriteAll,
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   336              // so we indicate WriteAll to the notification receiver
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   337              idActiveService_uo = NVM_SERVICE_ID_WRITE_ALL;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   338          }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   339  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   340          NvM_Prv_Block_SetRequestResult(NVM_PRV_MULTI_BLOCK, NvM_Prv_Multi_Result_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   341  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   342          // Now trigger the actual (BswM or multiblock callback) notification
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   343          // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2804]
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   344          // If BswMMultiBlockJobStatusInformation is enabled, provide the muliblock request result to BswM
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   345          // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2810]
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   346          // If BswMMultiBlockJobStatusInformation is enabled, the multiblock callback if configured is not invoked
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   347  #if (NVM_BSWM_MULTI_BLOCK_JOB_STATUS_INFORMATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   348          BswM_NvM_CurrentJobMode(idActiveService_uo, NvM_Prv_Multi_Result_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   349  #else
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   350          // TRACE[NVM347] Invoke multiblock callback if callback routine is configured
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   351          // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2839] This also applies to the first init case
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   352          // TRACE[NVM686] Supply the ID of the just finished multiblock operation to the callback owner
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   353          NvM_Prv_InvokeMultiCallback(idActiveService_uo, NvM_Prv_Multi_Result_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   354  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   355      }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   356  }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   357  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   358  // ====================================================================================================================
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   359  LOCAL_INLINE boolean NvM_Prv_CheckIsFinalCallbackRequired(NvM_Prv_idService_tuo idService_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   360  {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   361      boolean isFinalCallbackRequired_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   362  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   363      // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2857]
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   364      // The maintenance operation is performed as part of the execution of the NvM_WriteAll job
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   365      // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2867]
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   366      // WriteAll operation finishes when the writing of the suitable blocks and
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   367      // the maintenance of the redundant blocks are done
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   368      // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2873]
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   369      // In case of WriteAll, the multiblock callback is called after that the subsequent maintenance phase is finished
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   370      // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2875]
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   371      // In case of WriteAll, the BswM-notification is done after that the subsequent maintenance phase is finished
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   372  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   373      if ((NVM_SERVICE_ID_WRITE_ALL == idService_uo) &&
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   374          NvM_Prv_Block_IsRequestPending(NVM_PRV_MULTI_BLOCK, (1u << NvM_Prv_ServiceBit_Maintain_e)))
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   375      {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   376          // The multiblock callback is called after the overall WriteAll operation
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   377          // including the maintenance phase hasfinished;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   378          // the same applies to the BswM notification
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   379          // -> we have to skip any notification here in this case
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   380          // -> we come back once also maintenance is finished
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   381          // (then with NVM_PRV_SERVICE_ID_MAINTAIN_BLOCK as the active service)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   382          isFinalCallbackRequired_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   383      }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   384  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   385      return isFinalCallbackRequired_b;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   386  }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   387  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   388  // ====================================================================================================================
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   389  LOCAL_INLINE boolean NvM_Prv_StartSecondaryMulti(NvM_Prv_QueueEntry_tst* QueueEntry_pst)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   390  {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   391      boolean isSecondaryMultiReqStarted;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   392  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   393  #if (NVM_RB_REMOVE_NON_RESISTANT_BLOCKS || NVM_RB_INIT_AT_LAYOUT_CHANGE)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   394      if (NVM_SERVICE_ID_READ_ALL == QueueEntry_pst->idService_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   395      {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   396          isSecondaryMultiReqStarted = NvM_Prv_InitiateInitAfterReadAll(QueueEntry_pst);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   397      }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   398      else // CAUTION: This is an "else if" case separated by the NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS switch
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   399  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   400  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   401  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   402      if (NVM_SERVICE_ID_WRITE_ALL == QueueEntry_pst->idService_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   403      {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   404          isSecondaryMultiReqStarted = NvM_Prv_InitiateMaintenance(QueueEntry_pst);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   405      }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   406      else
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   407  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   408      {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   409          isSecondaryMultiReqStarted = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   410      }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   411  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   412      return isSecondaryMultiReqStarted;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   413  }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   414  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   415  // ====================================================================================================================
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   416  LOCAL_INLINE NvM_BlockIdType NvM_Prv_FindNextBlock(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   417                                                     NvM_Prv_idService_tuo idService_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   418                                                     NvM_Prv_ServiceBit_tuo ServiceBit_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   419  {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   420      uint16 RequestMask_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   421  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   422  #if (NVM_RB_REMOVE_NON_RESISTANT_BLOCKS || NVM_RB_INIT_AT_LAYOUT_CHANGE)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   423      if (NVM_SERVICE_ID_RB_INIT_AFTER_READ_ALL == idService_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   424      {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   425          RequestMask_u16 = (1u << NvM_Prv_ServiceBit_RemoveNonResistant_e) |
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   426                            (1u << NvM_Prv_ServiceBit_InitAtLayoutChange_e);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   427      }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   428      else
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   429  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   430      {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   431          RequestMask_u16 = (1u << ServiceBit_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   432      }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   433  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   434      while ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   435             !NvM_Prv_Block_IsRequestPending(idBlock_uo, RequestMask_u16))
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   436      {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   437          ++idBlock_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   438      }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   439      return idBlock_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   440  }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   441  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   442  // ====================================================================================================================
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   443  LOCAL_INLINE NvM_Prv_idJob_ten NvM_Prv_GetJobIdForMulti(NvM_Prv_idService_tuo idService_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   444                                                          NvM_Prv_ServiceBit_tuo ServiceBit_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   445                                                          NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   446  {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   447      NvM_Prv_idJob_ten idJob_en = NvM_Prv_idJob_Idle_e;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   448      switch (idService_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   449      {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   450          case NVM_SERVICE_ID_READ_ALL:
	mov	d15,#12
	jeq	d15,d0,.L15
.L393:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   451          {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   452              if (NVM_RB_CONFIG_ID_BLOCK == idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   453              {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   454                  idJob_en = NvM_Prv_idJob_ReadIdConfigForReadAll_e;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   455              }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   456              else
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   457              {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   458                  idJob_en = NvM_Prv_idJob_Read_e;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   459              }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   460          }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   461          break;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   462          case NVM_SERVICE_ID_RB_FIRST_INIT_ALL:
	mov	d15,#251
	jeq	d15,d0,.L16
	j	.L17

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   450          case NVM_SERVICE_ID_READ_ALL:      (inlined)
.L15:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   452              if (NVM_RB_CONFIG_ID_BLOCK == idBlock_uo)      (inlined)
	eq	d15,d1,#1
.L394:
	mov	d2,#8
	cmovn	d2,d15,#1
.L395:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   454                  idJob_en = NvM_Prv_idJob_ReadIdConfigForReadAll_e;      (inlined)
	j	.L19

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   452              if (NVM_RB_CONFIG_ID_BLOCK == idBlock_uo)      (inlined)
.L18:
	mov	d2,#1

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   456              else      (inlined)
.L19:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   461          break;      (inlined)
	j	.L20

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   462          case NVM_SERVICE_ID_RB_FIRST_INIT_ALL:      (inlined)
.L16:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   392  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   393   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   394   * This NvM private function checks for the given block whether the configured block length is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   395   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   396   * \param idBlock
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   397   * ID of the block for which the block length will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   398   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   399   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   400   * - TRUE = block length is valid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   401   * - FALSE = block length is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   402   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   403  LOCAL_INLINE boolean NvM_Prv_IsBlockLengthValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   404  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   405      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   406              (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   407              (0u != *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   408  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   409  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   410  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   411   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   412   * This NvM private function checks whether the given block is configured with immediate priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   413   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   414   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   415   * ID of the block for which the priority will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   416   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   417   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   418   * - TRUE = block is configured with immediate priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   419   * - FALSE = block is configured with standard priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   420   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   421  LOCAL_INLINE boolean NvM_Prv_HasBlockImmediateJobPriority(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   423      boolean HasBlockImmediateJobPriority_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   425  #if (NVM_JOB_PRIORITIZATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   426      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   427          (NVM_PRV_JOB_PRIORITY_IMMEDIATE == NvM_Prv_BlockDescriptors_acst[idBlock_uo].JobPriority_u8))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   428      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   429          HasBlockImmediateJobPriority_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   430      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   431  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   433  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   434  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   435  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   436   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   437   * This NvM private function returns the configured block size for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   438   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   439   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   440   * ID of the block for which the configured block size will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   441   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   442   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   443   * Configured block size
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   444   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   445  LOCAL_INLINE uint16 NvM_Prv_GetBlockSize(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   446  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   447      uint16 BlockSize_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   448  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   451      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   452          BlockSize_u16 = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   453      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   454  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   455      return BlockSize_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   456  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   457  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   458  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   459   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   460   * This NvM private function returns the configured block management type for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   461   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   462   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   463   * ID of the block for which the configured block management type will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   464   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   465   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   466   * Configured block management type
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   467   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   468  LOCAL_INLINE NvM_BlockManagementType NvM_Prv_GetBlockType(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   469  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   470      NvM_BlockManagementType BlockType = NVM_BLOCK_NATIVE;
	mov	d15,#0
.L290:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
	jge.u	d1,#14,.L21
.L396:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   472      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   473          BlockType = NvM_Prv_BlockDescriptors_acst[idBlock_uo].BlockManagementType_en;
	movh.a	a2,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a2,[a2]@los(NvM_Prv_BlockDescriptors_acst)
.L397:
	mul	d15,d1,#48
.L291:
	addsc.a	a15,a2,d15,#0
.L398:
	ld.w	d15,[a15]40

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
.L21:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   475      return BlockType;      (inlined)
	j	.L22

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   476  }      (inlined)
.L22:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   464              if ((NVM_BLOCK_DATASET != NvM_Prv_GetBlockType(idBlock_uo)) &&      (inlined)
	jeq	d15,#2,.L23
.L192:
	mov	d0,#0
.L399:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
	jge.u	d1,#14,.L24
.L400:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L401:
	mul	d15,d1,#48
.L292:
	addsc.a	a15,a15,d15,#0
.L402:
	mov.a	a2,#0
.L403:
	ld.a	a4,[a15]16
.L289:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||      (inlined)
	jne.a	a2,a4,.L25
.L404:
	mov.a	a2,#0
.L405:
	ld.a	a15,[a15]28
.L406:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));      (inlined)
	jeq.a	a2,a15,.L26

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||      (inlined)
.L25:
	mov	d0,#1

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
.L26:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));      (inlined)
.L24:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
	j	.L27

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }      (inlined)
.L27:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   465                  NvM_Prv_IsDefaultDataAvailable(idBlock_uo))      (inlined)
	jeq	d0,#0,.L28
.L199:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   463          {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   464              if ((NVM_BLOCK_DATASET != NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   465                  NvM_Prv_IsDefaultDataAvailable(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   466              {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   467                  idJob_en = NvM_Prv_idJob_Restore_e;
	mov	d2,#4
.L407:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   467                  idJob_en = NvM_Prv_idJob_Restore_e;      (inlined)
	j	.L29

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   464              if ((NVM_BLOCK_DATASET != NvM_Prv_GetBlockType(idBlock_uo)) &&      (inlined)
.L28:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   465                  NvM_Prv_IsDefaultDataAvailable(idBlock_uo))      (inlined)
.L23:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   468              }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   469              else
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   470              {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   471                  idJob_en = NvM_Prv_idJob_InvalidateForFirstInitAll_e;
	mov	d2,#9

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   469              else      (inlined)
.L29:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   474          break;      (inlined)
	j	.L30

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   493          default:      (inlined)
.L17:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   472              }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   473          }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   474          break;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   475  #if (NVM_RB_REMOVE_NON_RESISTANT_BLOCKS || NVM_RB_INIT_AT_LAYOUT_CHANGE)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   476          case NVM_SERVICE_ID_RB_INIT_AFTER_READ_ALL:
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   477          {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   478              if (NvM_Prv_Block_IsRequestPending(idBlock_uo, (1u << NvM_Prv_ServiceBit_RemoveNonResistant_e)))
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   479              {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   480                  idJob_en = NvM_Prv_idJob_InvalidateForRemoveNonResistant_e;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   481              }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   482              else if (NvM_Prv_Block_IsRequestPending(idBlock_uo, (1u << NvM_Prv_ServiceBit_InitAtLayoutChange_e)))
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   483              {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   484                  idJob_en = NvM_Prv_idJob_Write_e;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   485              }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   486              else
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   487              {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   488                  // should not happen
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   489              }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   490          }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   491          break;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   492  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   493          default:
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   494              idJob_en = NvM_Prv_GetJobId(ServiceBit_uo);
	call	NvM_Prv_GetJobId
.L293:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   495          break;      (inlined)
	j	.L31

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   498      return idJob_en;      (inlined)
.L31:
.L30:
.L20:
	j	.L32

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   499  }      (inlined)
.L32:
	ld.hu	d15,[a12]2
.L204:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   392  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   393   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   394   * This NvM private function checks for the given block whether the configured block length is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   395   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   396   * \param idBlock
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   397   * ID of the block for which the block length will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   398   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   399   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   400   * - TRUE = block length is valid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   401   * - FALSE = block length is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   402   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   403  LOCAL_INLINE boolean NvM_Prv_IsBlockLengthValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   404  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   405      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   406              (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   407              (0u != *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   408  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   409  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   410  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   411   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   412   * This NvM private function checks whether the given block is configured with immediate priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   413   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   414   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   415   * ID of the block for which the priority will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   416   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   417   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   418   * - TRUE = block is configured with immediate priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   419   * - FALSE = block is configured with standard priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   420   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   421  LOCAL_INLINE boolean NvM_Prv_HasBlockImmediateJobPriority(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   423      boolean HasBlockImmediateJobPriority_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   425  #if (NVM_JOB_PRIORITIZATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   426      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   427          (NVM_PRV_JOB_PRIORITY_IMMEDIATE == NvM_Prv_BlockDescriptors_acst[idBlock_uo].JobPriority_u8))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   428      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   429          HasBlockImmediateJobPriority_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   430      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   431  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   433  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   434  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   435  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   436   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   437   * This NvM private function returns the configured block size for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   438   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   439   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   440   * ID of the block for which the configured block size will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   441   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   442   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   443   * Configured block size
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   444   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   445  LOCAL_INLINE uint16 NvM_Prv_GetBlockSize(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   446  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   447      uint16 BlockSize_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   448  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   451      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   452          BlockSize_u16 = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   453      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   454  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   455      return BlockSize_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   456  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   457  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   458  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   459   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   460   * This NvM private function returns the configured block management type for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   461   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   462   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   463   * ID of the block for which the configured block management type will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   464   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   465   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   466   * Configured block management type
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   467   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   468  LOCAL_INLINE NvM_BlockManagementType NvM_Prv_GetBlockType(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   469  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   470      NvM_BlockManagementType BlockType = NVM_BLOCK_NATIVE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   472      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   473          BlockType = NvM_Prv_BlockDescriptors_acst[idBlock_uo].BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   474      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   475      return BlockType;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   476  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   477  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   478  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   479   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   480   * This NvM private function returns the configured number of non-volatile data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   481   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   482   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   483   * ID of the block for which the configured number of non-volatile data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   484   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   485   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   486   * Configured number of non-volatile data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   487   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   488  LOCAL_INLINE uint8 NvM_Prv_GetNrNonVolatileBlocks(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   489  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   490      uint8 nrNvBlocks_u8 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   491      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   492      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   493          nrNvBlocks_u8 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   494      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   495      return nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   496  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   497  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   498  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   499   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   500   * This NvM private function returns the configured overall number of data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   501   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   502   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   503   * ID of the block for which the configured overall number of data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   504   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   505   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   506   * Configured number of data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   507   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   508  LOCAL_INLINE uint16 NvM_Prv_GetNrDataIndexes(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   509  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   510      uint8 nrDataIndexes = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   511      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   512      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   513          nrDataIndexes = (NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8 +
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   514                           NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrRomBlocks_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   515      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   516      return nrDataIndexes;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   517  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   518  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   519  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   520   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   521   * This NvM private function returns the pointer to the configured permanent RAM block for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   522   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   523   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   524   * If no permanent RAM block is configured for a block then this function returns a NULL pointer.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   525   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   526   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   527   * ID of the block for which the pointer to the configured permanent RAM block will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   528   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   529   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   530   * Pointer to the configured permanent RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   531   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   532  LOCAL_INLINE void * NvM_Prv_GetPRamBlockAddress(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   533  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   534      void * PRamBlockAddress_pv = NULL_PTR;
	mov.a	a2,#0
.L294:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   535      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
	jge.u	d15,#14,.L33
.L408:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   535      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   536          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv))
	mul	d15,d15,#48
.L409:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L410:
	addsc.a	a15,a15,d15,#0
.L411:
	ld.a	a15,[a15]12
.L412:
	mov.a	a4,#0
.L413:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   536          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv))      (inlined)
	jeq.a	a4,a15,.L34
.L414:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   537      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   538          PRamBlockAddress_pv = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv;
	ld.a	a2,[a15]

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   535      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
.L34:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   536          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv))      (inlined)
.L33:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   541      return PRamBlockAddress_pv;      (inlined)
	j	.L35

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   542  }      (inlined)
.L35:
	st.a	[a12]8,a2
.L205:
	j	.L36
.L14:
	movh.a	a15,#@his(NvM_Prv_ProcessMulti_pfct)
	lea	a15,[a15]@los(NvM_Prv_ProcessMulti_pfct)
.L415:
	movh.a	a2,#@his(NvM_Prv_ProcessUserBlocks)
	lea	a2,[a2]@los(NvM_Prv_ProcessUserBlocks)
.L416:
	st.a	[a15],a2
.L36:
	j	.L37
.L37:
	ret
.L171:
	
__NvM_Prv_ProcessConfigId_function_end:
	.size	NvM_Prv_ProcessConfigId,__NvM_Prv_ProcessConfigId_function_end-NvM_Prv_ProcessConfigId
.L135:
	; End of function
	
	.sdecl	'.text.NvM_ProcessMultiBlock.NvM_Prv_ProcessUserBlocks',code,cluster('NvM_Prv_ProcessUserBlocks')
	.sect	'.text.NvM_ProcessMultiBlock.NvM_Prv_ProcessUserBlocks'
	.align	2
	
; Function NvM_Prv_ProcessUserBlocks
.L92:
NvM_Prv_ProcessUserBlocks:	.type	func
	mov.aa	a12,a4
.L295:
	mov	d2,#0
.L296:
	ld.hu	d0,[a12]2
.L421:
	ld.bu	d1,[a12]
.L422:
	ld.hu	d4,[a12]4
.L215:
	mov	d15,#1
.L423:
	sh	d15,d15,d4
	extr.u	d3,d15,#0,#16
.L297:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   435             !NvM_Prv_Block_IsRequestPending(idBlock_uo, RequestMask_u16))      (inlined)
	j	.L38
.L39:
	add	d0,#1

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   435             !NvM_Prv_Block_IsRequestPending(idBlock_uo, RequestMask_u16))      (inlined)
.L38:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   434      while ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
	jge.u	d0,#14,.L40
.L225:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   169  LOCAL_INLINE boolean NvM_Prv_Block_IsRequestPending(NvM_BlockIdType idBlock_uo, uint16 maskService_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   170  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);
	movh.a	a2,#@his(NvM_Prv_stRequests_rAMwAM_au16)
	lea	a2,[a2]@los(NvM_Prv_stRequests_rAMwAM_au16)
.L424:
	addsc.a	a2,a2,d0,#1
	ld.hu	d15,[a2]0
.L425:
	and	d15,d3
.L426:
	ne	d15,d15,#0
.L427:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);      (inlined)
	j	.L41

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   172  }      (inlined)
.L41:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   435             !NvM_Prv_Block_IsRequestPending(idBlock_uo, RequestMask_u16))      (inlined)
	jeq	d15,#0,.L39

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   434      while ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
.L40:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   439      return idBlock_uo;      (inlined)
	j	.L42

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   440  }      (inlined)
.L42:
	st.h	[a12]2,d0
.L428:
	jge.u	d0,#14,.L43
.L228:
	mov	d15,#12
	jeq	d15,d1,.L44
.L429:
	mov	d15,#251
	jeq	d15,d1,.L45
	j	.L46

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   450          case NVM_SERVICE_ID_READ_ALL:      (inlined)
.L44:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   452              if (NVM_RB_CONFIG_ID_BLOCK == idBlock_uo)      (inlined)
	eq	d15,d0,#1
.L430:
	mov	d2,#8
	cmovn	d2,d15,#1
.L431:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   454                  idJob_en = NvM_Prv_idJob_ReadIdConfigForReadAll_e;      (inlined)
	j	.L48

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   452              if (NVM_RB_CONFIG_ID_BLOCK == idBlock_uo)      (inlined)
.L47:
	mov	d2,#1

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   456              else      (inlined)
.L48:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   461          break;      (inlined)
	j	.L49

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   462          case NVM_SERVICE_ID_RB_FIRST_INIT_ALL:      (inlined)
.L45:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   392  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   393   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   394   * This NvM private function checks for the given block whether the configured block length is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   395   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   396   * \param idBlock
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   397   * ID of the block for which the block length will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   398   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   399   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   400   * - TRUE = block length is valid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   401   * - FALSE = block length is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   402   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   403  LOCAL_INLINE boolean NvM_Prv_IsBlockLengthValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   404  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   405      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   406              (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   407              (0u != *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   408  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   409  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   410  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   411   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   412   * This NvM private function checks whether the given block is configured with immediate priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   413   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   414   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   415   * ID of the block for which the priority will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   416   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   417   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   418   * - TRUE = block is configured with immediate priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   419   * - FALSE = block is configured with standard priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   420   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   421  LOCAL_INLINE boolean NvM_Prv_HasBlockImmediateJobPriority(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   423      boolean HasBlockImmediateJobPriority_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   425  #if (NVM_JOB_PRIORITIZATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   426      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   427          (NVM_PRV_JOB_PRIORITY_IMMEDIATE == NvM_Prv_BlockDescriptors_acst[idBlock_uo].JobPriority_u8))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   428      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   429          HasBlockImmediateJobPriority_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   430      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   431  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   433  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   434  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   435  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   436   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   437   * This NvM private function returns the configured block size for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   438   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   439   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   440   * ID of the block for which the configured block size will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   441   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   442   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   443   * Configured block size
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   444   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   445  LOCAL_INLINE uint16 NvM_Prv_GetBlockSize(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   446  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   447      uint16 BlockSize_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   448  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   451      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   452          BlockSize_u16 = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   453      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   454  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   455      return BlockSize_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   456  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   457  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   458  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   459   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   460   * This NvM private function returns the configured block management type for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   461   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   462   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   463   * ID of the block for which the configured block management type will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   464   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   465   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   466   * Configured block management type
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   467   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   468  LOCAL_INLINE NvM_BlockManagementType NvM_Prv_GetBlockType(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   469  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   470      NvM_BlockManagementType BlockType = NVM_BLOCK_NATIVE;
	mov	d15,#0
.L300:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
	jge.u	d0,#14,.L50
.L432:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   472      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   473          BlockType = NvM_Prv_BlockDescriptors_acst[idBlock_uo].BlockManagementType_en;
	mul	d15,d0,#48
.L301:
	movh.a	a2,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a2,[a2]@los(NvM_Prv_BlockDescriptors_acst)
.L433:
	addsc.a	a15,a2,d15,#0
.L434:
	ld.w	d15,[a15]40

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
.L50:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   475      return BlockType;      (inlined)
	j	.L51

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   476  }      (inlined)
.L51:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   464              if ((NVM_BLOCK_DATASET != NvM_Prv_GetBlockType(idBlock_uo)) &&      (inlined)
	jeq	d15,#2,.L52
.L233:
	mov	d1,#0
.L435:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
	jge.u	d0,#14,.L53
.L436:
	mul	d15,d0,#48
.L302:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L437:
	addsc.a	a15,a15,d15,#0
.L438:
	mov.a	a2,#0
.L439:
	ld.a	a4,[a15]16
.L298:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||      (inlined)
	jne.a	a2,a4,.L54
.L440:
	mov.a	a2,#0
.L441:
	ld.a	a15,[a15]28
.L442:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));      (inlined)
	jeq.a	a2,a15,.L55

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||      (inlined)
.L54:
	mov	d1,#1

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
.L55:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));      (inlined)
.L53:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
	j	.L56

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }      (inlined)
.L56:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   465                  NvM_Prv_IsDefaultDataAvailable(idBlock_uo))      (inlined)
	jeq	d1,#0,.L57
.L236:
	mov	d2,#4
.L443:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   467                  idJob_en = NvM_Prv_idJob_Restore_e;      (inlined)
	j	.L58

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   464              if ((NVM_BLOCK_DATASET != NvM_Prv_GetBlockType(idBlock_uo)) &&      (inlined)
.L57:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   465                  NvM_Prv_IsDefaultDataAvailable(idBlock_uo))      (inlined)
.L52:
	mov	d2,#9

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   469              else      (inlined)
.L58:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   474          break;      (inlined)
	j	.L59

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   493          default:      (inlined)
.L46:
	call	NvM_Prv_GetJobId
.L299:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   495          break;      (inlined)
	j	.L60

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   498      return idJob_en;      (inlined)
.L60:
.L59:
.L49:
	j	.L61

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   499  }      (inlined)
.L61:
	ld.hu	d15,[a12]2
.L238:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   392  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   393   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   394   * This NvM private function checks for the given block whether the configured block length is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   395   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   396   * \param idBlock
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   397   * ID of the block for which the block length will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   398   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   399   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   400   * - TRUE = block length is valid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   401   * - FALSE = block length is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   402   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   403  LOCAL_INLINE boolean NvM_Prv_IsBlockLengthValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   404  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   405      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   406              (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   407              (0u != *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   408  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   409  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   410  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   411   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   412   * This NvM private function checks whether the given block is configured with immediate priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   413   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   414   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   415   * ID of the block for which the priority will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   416   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   417   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   418   * - TRUE = block is configured with immediate priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   419   * - FALSE = block is configured with standard priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   420   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   421  LOCAL_INLINE boolean NvM_Prv_HasBlockImmediateJobPriority(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   423      boolean HasBlockImmediateJobPriority_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   425  #if (NVM_JOB_PRIORITIZATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   426      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   427          (NVM_PRV_JOB_PRIORITY_IMMEDIATE == NvM_Prv_BlockDescriptors_acst[idBlock_uo].JobPriority_u8))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   428      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   429          HasBlockImmediateJobPriority_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   430      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   431  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   433  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   434  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   435  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   436   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   437   * This NvM private function returns the configured block size for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   438   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   439   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   440   * ID of the block for which the configured block size will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   441   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   442   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   443   * Configured block size
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   444   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   445  LOCAL_INLINE uint16 NvM_Prv_GetBlockSize(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   446  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   447      uint16 BlockSize_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   448  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   451      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   452          BlockSize_u16 = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   453      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   454  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   455      return BlockSize_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   456  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   457  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   458  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   459   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   460   * This NvM private function returns the configured block management type for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   461   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   462   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   463   * ID of the block for which the configured block management type will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   464   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   465   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   466   * Configured block management type
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   467   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   468  LOCAL_INLINE NvM_BlockManagementType NvM_Prv_GetBlockType(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   469  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   470      NvM_BlockManagementType BlockType = NVM_BLOCK_NATIVE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   472      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   473          BlockType = NvM_Prv_BlockDescriptors_acst[idBlock_uo].BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   474      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   475      return BlockType;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   476  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   477  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   478  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   479   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   480   * This NvM private function returns the configured number of non-volatile data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   481   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   482   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   483   * ID of the block for which the configured number of non-volatile data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   484   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   485   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   486   * Configured number of non-volatile data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   487   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   488  LOCAL_INLINE uint8 NvM_Prv_GetNrNonVolatileBlocks(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   489  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   490      uint8 nrNvBlocks_u8 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   491      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   492      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   493          nrNvBlocks_u8 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   494      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   495      return nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   496  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   497  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   498  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   499   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   500   * This NvM private function returns the configured overall number of data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   501   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   502   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   503   * ID of the block for which the configured overall number of data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   504   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   505   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   506   * Configured number of data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   507   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   508  LOCAL_INLINE uint16 NvM_Prv_GetNrDataIndexes(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   509  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   510      uint8 nrDataIndexes = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   511      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   512      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   513          nrDataIndexes = (NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8 +
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   514                           NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrRomBlocks_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   515      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   516      return nrDataIndexes;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   517  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   518  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   519  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   520   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   521   * This NvM private function returns the pointer to the configured permanent RAM block for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   522   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   523   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   524   * If no permanent RAM block is configured for a block then this function returns a NULL pointer.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   525   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   526   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   527   * ID of the block for which the pointer to the configured permanent RAM block will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   528   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   529   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   530   * Pointer to the configured permanent RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   531   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   532  LOCAL_INLINE void * NvM_Prv_GetPRamBlockAddress(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   533  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   534      void * PRamBlockAddress_pv = NULL_PTR;
	mov.a	a2,#0
.L303:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   535      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
	jge.u	d15,#14,.L62
.L444:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   535      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   536          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv))
	mul	d15,d15,#48
.L445:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L446:
	addsc.a	a15,a15,d15,#0
.L447:
	ld.a	a15,[a15]12
.L448:
	mov.a	a4,#0
.L449:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   536          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv))      (inlined)
	jeq.a	a4,a15,.L63
.L450:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   537      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   538          PRamBlockAddress_pv = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv;
	ld.a	a2,[a15]

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   535      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
.L63:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   536          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv))      (inlined)
.L62:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   541      return PRamBlockAddress_pv;      (inlined)
	j	.L64

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   542  }      (inlined)
.L64:
	st.a	[a12]8,a2
.L239:
	j	.L65
.L43:
	movh.a	a15,#@his(NvM_Prv_ProcessMulti_pfct)
	lea	a15,[a15]@los(NvM_Prv_ProcessMulti_pfct)
.L451:
	movh.a	a2,#@his(NvM_Prv_FinishMulti)
	lea	a2,[a2]@los(NvM_Prv_FinishMulti)
.L452:
	st.a	[a15],a2
.L65:
	j	.L66
.L66:
	ret
.L211:
	
__NvM_Prv_ProcessUserBlocks_function_end:
	.size	NvM_Prv_ProcessUserBlocks,__NvM_Prv_ProcessUserBlocks_function_end-NvM_Prv_ProcessUserBlocks
.L140:
	; End of function
	
	.sdecl	'.text.NvM_ProcessMultiBlock.NvM_Prv_ProcessCancel',code,cluster('NvM_Prv_ProcessCancel')
	.sect	'.text.NvM_ProcessMultiBlock.NvM_Prv_ProcessCancel'
	.align	2
	
; Function NvM_Prv_ProcessCancel
.L94:
NvM_Prv_ProcessCancel:	.type	func
	mov.aa	a15,a4
.L305:
	mov	d8,#0
.L307:
	movh.a	a12,#@his(NvM_Prv_Multi_Cancel_pfct)
	lea	a12,[a12]@los(NvM_Prv_Multi_Cancel_pfct)
	ld.a	a2,[a12]
.L457:
	calli	a2
.L304:
	jeq	d2,#0,.L67
.L458:
	movh.a	a2,#@his(NvM_Prv_Multi_Result_uo)
	lea	a2,[a2]@los(NvM_Prv_Multi_Result_uo)
.L459:
	mov	d15,#6
.L460:
	st.b	[a2],d15
.L67:
	mov	d15,#14
.L461:
	st.h	[a15]2,d15
.L462:
	mov.a	a15,#0
.L306:
	st.a	[a12],a15
.L463:
	movh.a	a15,#@his(NvM_Prv_ProcessMulti_pfct)
	lea	a15,[a15]@los(NvM_Prv_ProcessMulti_pfct)
.L464:
	movh.a	a2,#@his(NvM_Prv_FinishMulti)
	lea	a2,[a2]@los(NvM_Prv_FinishMulti)
.L465:
	st.a	[a15],a2
.L466:
	mov	d2,d8
.L308:
	j	.L68
.L68:
	ret
.L242:
	
__NvM_Prv_ProcessCancel_function_end:
	.size	NvM_Prv_ProcessCancel,__NvM_Prv_ProcessCancel_function_end-NvM_Prv_ProcessCancel
.L145:
	; End of function
	
	.sdecl	'.text.NvM_ProcessMultiBlock.NvM_Prv_FinishMulti',code,cluster('NvM_Prv_FinishMulti')
	.sect	'.text.NvM_ProcessMultiBlock.NvM_Prv_FinishMulti'
	.align	2
	
; Function NvM_Prv_FinishMulti
.L96:
NvM_Prv_FinishMulti:	.type	func
	mov	d8,#0
.L309:
	ld.bu	d0,[a4]
.L471:
	mov	d15,#254
.L472:
	jne	d15,d0,.L69
.L473:
	mov	d0,#34
.L310:
	j	.L70
.L69:
	mov	d15,#1
.L474:
	ld.hu	d0,[a4]4
.L475:
	sh	d15,d15,d0
	extr.u	d0,d15,#0,#16
.L70:
	mov	d15,#0
.L250:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   169  LOCAL_INLINE boolean NvM_Prv_Block_IsRequestPending(NvM_BlockIdType idBlock_uo, uint16 maskService_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   170  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   172  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   173  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   174  LOCAL_INLINE boolean NvM_Prv_Block_IsPending(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   175  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   176      return (NvM_Prv_Block_IsNvmEnqueuingForMulti(idBlock_uo) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   177              ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != 0)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   178  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   179                && (NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != (1u << NvM_Prv_ServiceBit_Maintain_e))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   180  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   181              )
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   182             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   183  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   184  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   185  LOCAL_INLINE void NvM_Prv_Block_SetIdxData(NvM_BlockIdType idBlock_uo, uint8 idxData_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   186  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   187      NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] = idxData_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   188  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   189  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   190  LOCAL_INLINE void NvM_Prv_Block_SetRequestResult(NvM_BlockIdType idBlock_uo, NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   191  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   192      NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo] = Result_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   193  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   194  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   195  LOCAL_INLINE void NvM_Prv_Block_SetRequest(NvM_BlockIdType idBlock_uo, NvM_Prv_ServiceBit_tuo ServiceBit_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   196  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   197      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= (1u << ServiceBit_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   198  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   199  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   200  LOCAL_INLINE void NvM_Prv_Block_SetRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   201  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   202      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= maskRequests_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   203  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   204  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   205  LOCAL_INLINE void NvM_Prv_Block_ClearRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   206  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   207      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] &= (~maskRequests_u16);
	movh.a	a15,#@his(NvM_Prv_stRequests_rAMwAM_au16)
	lea	a15,[a15]@los(NvM_Prv_stRequests_rAMwAM_au16)
.L476:
	addsc.a	a15,a15,d15,#1
	ld.hu	d15,[a15]0
.L477:
	mov.u	d1,#65535
	xor	d0,d1
.L311:
	and	d15,d0
	st.h	[a15],d15
.L251:
	ld.bu	d4,[a4]
.L258:
	mov	d15,#1

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   385      return isFinalCallbackRequired_b;      (inlined)
	j	.L71

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   386  }      (inlined)
.L71:

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   327      if (NvM_Prv_CheckIsFinalCallbackRequired(idService_uo))      (inlined)
	jeq	d15,#0,.L72
.L268:
	movh.a	a15,#@his(NvM_Prv_Multi_Result_uo)
	lea	a15,[a15]@los(NvM_Prv_Multi_Result_uo)
	ld.bu	d5,[a15]
.L271:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   169  LOCAL_INLINE boolean NvM_Prv_Block_IsRequestPending(NvM_BlockIdType idBlock_uo, uint16 maskService_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   170  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   172  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   173  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   174  LOCAL_INLINE boolean NvM_Prv_Block_IsPending(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   175  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   176      return (NvM_Prv_Block_IsNvmEnqueuingForMulti(idBlock_uo) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   177              ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != 0)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   178  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   179                && (NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != (1u << NvM_Prv_ServiceBit_Maintain_e))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   180  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   181              )
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   182             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   183  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   184  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   185  LOCAL_INLINE void NvM_Prv_Block_SetIdxData(NvM_BlockIdType idBlock_uo, uint8 idxData_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   186  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   187      NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] = idxData_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   188  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   189  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   190  LOCAL_INLINE void NvM_Prv_Block_SetRequestResult(NvM_BlockIdType idBlock_uo, NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   191  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   192      NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo] = Result_uo;
	movh.a	a15,#@his(NvM_Prv_stRequestResult_rAwAM_au8)
	lea	a15,[a15]@los(NvM_Prv_stRequestResult_rAwAM_au8)
.L478:
	add.a	a15,#0
.L479:
	st.b	[a15],d5
.L272:
	call	BswM_NvM_CurrentJobMode

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   327      if (NvM_Prv_CheckIsFinalCallbackRequired(idService_uo))      (inlined)
.L72:
	mov	d15,#0

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   412      return isSecondaryMultiReqStarted;      (inlined)
	j	.L73

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   413  }      (inlined)
.L73:
	movh.a	a15,#@his(NvM_Prv_ProcessMulti_pfct)
	lea	a15,[a15]@los(NvM_Prv_ProcessMulti_pfct)
.L480:
	jeq	d15,#0,.L74
.L481:
	movh.a	a2,#@his(NvM_Prv_ProcessUserBlocks)
	lea	a2,[a2]@los(NvM_Prv_ProcessUserBlocks)
.L482:
	st.a	[a15],a2
.L483:
	j	.L75
.L74:
	mov.a	a2,#0
.L484:
	st.a	[a15],a2
.L485:
	movh.a	a15,#@his(NvM_Prv_Main_st)
	lea	a15,[a15]@los(NvM_Prv_Main_st)
.L486:
	mov.a	a2,#0
.L487:
	st.a	[a15]8,a2
.L488:
	mov	d4,#0
	call	NvM_Prv_Queue_DequeueRequest
.L75:
	mov	d2,d8
.L312:
	j	.L76
.L76:
	ret
.L245:
	
__NvM_Prv_FinishMulti_function_end:
	.size	NvM_Prv_FinishMulti,__NvM_Prv_FinishMulti_function_end-NvM_Prv_FinishMulti
.L150:
	; End of function
	
	.sdecl	'.data.NvM_ProcessMultiBlock.NvM_Prv_ProcessMulti_pfct',data,cluster('NvM_Prv_ProcessMulti_pfct')
	.sect	'.data.NvM_ProcessMultiBlock.NvM_Prv_ProcessMulti_pfct'
	.align	4
NvM_Prv_ProcessMulti_pfct:	.type	object
	.size	NvM_Prv_ProcessMulti_pfct,4
	.space	4
	.sdecl	'.data.NvM_ProcessMultiBlock.NvM_Prv_Multi_Cancel_pfct',data,cluster('NvM_Prv_Multi_Cancel_pfct')
	.sect	'.data.NvM_ProcessMultiBlock.NvM_Prv_Multi_Cancel_pfct'
	.align	4
NvM_Prv_Multi_Cancel_pfct:	.type	object
	.size	NvM_Prv_Multi_Cancel_pfct,4
	.space	4
	.sdecl	'.data.NvM_ProcessMultiBlock.NvM_Prv_Multi_Result_uo',data,cluster('NvM_Prv_Multi_Result_uo')
	.sect	'.data.NvM_ProcessMultiBlock.NvM_Prv_Multi_Result_uo'
NvM_Prv_Multi_Result_uo:	.type	object
	.size	NvM_Prv_Multi_Result_uo,1
	.space	1
	.calls	'__INDIRECT__','NvM_Prv_ProcessConfigId'
	.calls	'__INDIRECT__','NvM_Prv_ProcessUserBlocks'
	.calls	'__INDIRECT__','NvM_Prv_ProcessCancel'
	.calls	'__INDIRECT__','NvM_Prv_FinishMulti'
	.calls	'NvM_Prv_Multi_Process','__INDIRECT__'
	.calls	'NvM_Prv_ProcessConfigId','NvM_Prv_GetJobId'
	.calls	'NvM_Prv_ProcessUserBlocks','NvM_Prv_GetJobId'
	.calls	'NvM_Prv_ProcessCancel','__INDIRECT__'
	.calls	'NvM_Prv_FinishMulti','BswM_NvM_CurrentJobMode'
	.calls	'NvM_Prv_FinishMulti','NvM_Prv_Queue_DequeueRequest'
	.calls	'NvM_Prv_Multi_Initialize','',0
	.calls	'NvM_Prv_Multi_IsInProgress','',0
	.calls	'NvM_Prv_Multi_SetResult','',0
	.calls	'NvM_Prv_Multi_GetResult','',0
	.calls	'NvM_Prv_Multi_Cancel','',0
	.calls	'NvM_Prv_Multi_Process','',0
	.calls	'NvM_Prv_ProcessConfigId','',0
	.calls	'NvM_Prv_ProcessUserBlocks','',0
	.calls	'NvM_Prv_ProcessCancel','',0
	.extern	NvM_Prv_Main_st
	.extern	NvM_Prv_GetJobId
	.extern	NvM_Prv_Queue_DequeueRequest
	.extern	NvM_Prv_BlockDescriptors_acst
	.extern	NvM_Prv_stRequests_rAMwAM_au16
	.extern	NvM_Prv_stRequestResult_rAwAM_au8
	.extern	BswM_NvM_CurrentJobMode
	.extern	__INDIRECT__
	.calls	'NvM_Prv_FinishMulti','',0
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L98:
	.word	14401
	.half	3
	.word	.L99
	.byte	4
.L97:
	.byte	1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L100
.L158:
	.byte	2
	.byte	'unsigned char',0,1,8
.L223:
	.byte	2
	.byte	'unsigned short int',0,2,7
.L198:
	.byte	3
	.byte	'NvM_Prv_IsDefaultDataAvailable',0,3,1,129,3,22
	.word	147
	.byte	1,1
.L200:
	.byte	4
	.byte	'idBlock_uo',0,1,129,3,69
	.word	164
.L202:
	.byte	5,0
.L196:
	.byte	6,2,40,9,4,7
	.byte	'NVM_BLOCK_NATIVE',0,0,7
	.byte	'NVM_BLOCK_REDUNDANT',0,1,7
	.byte	'NVM_BLOCK_DATASET',0,2,0
.L191:
	.byte	3
	.byte	'NvM_Prv_GetBlockType',0,3,1,212,3,38
	.word	251
	.byte	1,1
.L193:
	.byte	4
	.byte	'idBlock_uo',0,1,212,3,75
	.word	164
.L195:
	.byte	5,0,3
	.byte	'NvM_Prv_GetNrNonVolatileBlocks',0,3,1,232,3,20
	.word	147
	.byte	1,1,4
	.byte	'idBlock_uo',0,1,232,3,67
	.word	164
	.byte	5,0,8
	.byte	'void',0
.L209:
	.byte	9
	.word	438
.L203:
	.byte	3
	.byte	'NvM_Prv_GetPRamBlockAddress',0,3,1,148,4,21
	.word	444
	.byte	1,1
.L206:
	.byte	4
	.byte	'idBlock_uo',0,1,148,4,65
	.word	164
.L208:
	.byte	5,0,10
	.word	438
	.byte	9
	.word	511
	.byte	3
	.byte	'NvM_Prv_GetRomBlockAddress',0,3,1,173,4,26
	.word	516
	.byte	1,1,4
	.byte	'idBlock_uo',0,1,173,4,69
	.word	164
	.byte	5,0,3
	.byte	'NvM_Prv_Block_IsInRom',0,3,3,142,1,22
	.word	147
	.byte	1,1,4
	.byte	'idBlock_uo',0,3,142,1,60
	.word	164
	.byte	4
	.byte	'idxDataset_u8',0,3,142,1,78
	.word	147
	.byte	11,5,5,0,0,3
	.byte	'NvM_Prv_Block_IsWriteProtected',0,3,3,148,1,22
	.word	147
	.byte	1,1,4
	.byte	'idBlock_uo',0,3,148,1,69
	.word	164
	.byte	5,0
.L174:
	.byte	3
	.byte	'NvM_Prv_Block_IsRequestPending',0,3,3,169,1,22
	.word	147
	.byte	1,1
.L176:
	.byte	4
	.byte	'idBlock_uo',0,3,169,1,69
	.word	164
.L178:
	.byte	4
	.byte	'maskService_u16',0,3,169,1,88
	.word	164
.L180:
	.byte	5,0
.L270:
	.byte	12
	.byte	'NvM_Prv_Block_SetRequestResult',0,3,3,190,1,19,1,1
.L273:
	.byte	4
	.byte	'idBlock_uo',0,3,190,1,66
	.word	164
.L275:
	.byte	4
	.byte	'Result_uo',0,3,190,1,100
	.word	147
.L277:
	.byte	5,0
.L249:
	.byte	12
	.byte	'NvM_Prv_Block_ClearRequests',0,3,3,205,1,19,1,1
.L252:
	.byte	4
	.byte	'idBlock_uo',0,3,205,1,63
	.word	164
.L254:
	.byte	4
	.byte	'maskRequests_u16',0,3,205,1,82
	.word	164
.L256:
	.byte	5,0
.L257:
	.byte	12
	.byte	'NvM_Prv_NotifyMultiEnd',0,3,4,197,2,19,1,1
.L259:
	.byte	4
	.byte	'idService_uo',0,4,197,2,64
	.word	147
.L261:
	.byte	11
.L267:
	.byte	5,5,5,0,0
.L262:
	.byte	3
	.byte	'NvM_Prv_CheckIsFinalCallbackRequired',0,3,4,231,2,22
	.word	147
	.byte	1,1
.L263:
	.byte	4
	.byte	'idService_uo',0,4,231,2,81
	.word	147
.L265:
	.byte	5,0,13,2,210,1,9,12,14
	.byte	'idService_uo',0
	.word	147
	.byte	1,2,35,0,14
	.byte	'idBlock_uo',0
	.word	164
	.byte	2,2,35,2,14
	.byte	'ServiceBit_uo',0
	.word	164
	.byte	2,2,35,4,14
	.byte	'BlockData_pv',0
	.word	444
	.byte	4,2,35,8,0
.L168:
	.byte	9
	.word	1115
.L278:
	.byte	3
	.byte	'NvM_Prv_StartSecondaryMulti',0,3,4,133,3,22
	.word	147
	.byte	1,1
.L279:
	.byte	4
	.byte	'QueueEntry_pst',0,4,133,3,74
	.word	1209
.L281:
	.byte	5,0
.L214:
	.byte	3
	.byte	'NvM_Prv_FindNextBlock',0,3,4,160,3,30
	.word	164
	.byte	1,1
.L216:
	.byte	4
	.byte	'idBlock_uo',0,4,160,3,68
	.word	164
.L218:
	.byte	4
	.byte	'idService_uo',0,4,161,3,74
	.word	147
.L220:
	.byte	4
	.byte	'ServiceBit_uo',0,4,162,3,75
	.word	164
.L222:
	.byte	11,5,0,0
.L166:
	.byte	6,2,104,9,4,7
	.byte	'NvM_Prv_idJob_Idle_e',0,0,7
	.byte	'NvM_Prv_idJob_Read_e',0,1,7
	.byte	'NvM_Prv_idJob_Write_e',0,2,7
	.byte	'NvM_Prv_idJob_Erase_e',0,3,7
	.byte	'NvM_Prv_idJob_Restore_e',0,4,7
	.byte	'NvM_Prv_idJob_Maintain_e',0,5,7
	.byte	'NvM_Prv_idJob_Validate_e',0,6,7
	.byte	'NvM_Prv_idJob_Invalidate_e',0,7,7
	.byte	'NvM_Prv_idJob_ReadIdConfigForReadAll_e',0,8,7
	.byte	'NvM_Prv_idJob_InvalidateForFirstInitAll_e',0,9,7
	.byte	'NvM_Prv_idJob_RestoreForImplicitRecovery_e',0,10,7
	.byte	'NvM_Prv_idJob_InvalidateForRemoveNonResistant_e',0,11,7
	.byte	'NvM_Prv_idJob_Invalid_e',0,12,7
	.byte	'NvM_Prv_idJob_Count_e',0,13,0
.L181:
	.byte	3
	.byte	'NvM_Prv_GetJobIdForMulti',0,3,4,187,3,32
	.word	1383
	.byte	1,1
.L183:
	.byte	4
	.byte	'idService_uo',0,4,187,3,79
	.word	147
.L185:
	.byte	4
	.byte	'ServiceBit_uo',0,4,188,3,80
	.word	164
.L187:
	.byte	4
	.byte	'idBlock_uo',0,4,189,3,73
	.word	164
.L189:
	.byte	11,5,5,0,0,15
	.byte	'NvM_Prv_GetJobId',0,5,105,26
	.word	1383
	.byte	1,1,1,1,4
	.byte	'ServiceBit_uo',0,5,105,66
	.word	164
	.byte	0,16
	.byte	'NvM_Prv_Queue_DequeueRequest',0,6,42,13,1,1,1,1,4
	.byte	'idQueue_uo',0,6,42,62
	.word	147
	.byte	0,17
	.word	186
	.byte	18
	.word	229
	.byte	5,0,17
	.word	318
	.byte	18
	.word	351
	.byte	5,0,17
	.word	373
	.byte	18
	.word	416
	.byte	5,0,17
	.word	449
	.byte	18
	.word	489
	.byte	5,0,17
	.word	521
	.byte	18
	.word	560
	.byte	5,0,17
	.word	582
	.byte	18
	.word	616
	.byte	18
	.word	636
	.byte	11,19
	.word	318
	.byte	18
	.word	351
	.byte	20
	.word	371
	.byte	0,5,19
	.word	373
	.byte	18
	.word	416
	.byte	20
	.word	436
	.byte	0,5,0,0,17
	.word	664
	.byte	18
	.word	707
	.byte	5,0,17
	.word	729
	.byte	18
	.word	772
	.byte	18
	.word	792
	.byte	5,0,17
	.word	819
	.byte	18
	.word	858
	.byte	18
	.word	878
	.byte	5,0,17
	.word	899
	.byte	18
	.word	935
	.byte	18
	.word	955
	.byte	5,0,21
	.word	147
	.byte	1,1,9
	.word	2213
	.byte	9
	.word	2213
.L164:
	.byte	22
	.byte	'NvM_Prv_Multi_Cancel_tpfct',0,7,10,19
	.word	2225
	.byte	16
	.byte	'BswM_NvM_CurrentJobMode',0,8,33,30,1,1,1,1,4
	.byte	'ServiceId',0,8,33,76
	.word	147
	.byte	4
	.byte	'CurrentJobMode',0,8,33,125
	.word	147
	.byte	0,17
	.word	983
	.byte	18
	.word	1014
	.byte	11,11,19
	.word	819
	.byte	18
	.word	858
	.byte	18
	.word	878
	.byte	20
	.word	897
	.byte	0,0,19
	.word	1042
	.byte	18
	.word	1091
	.byte	20
	.word	1113
	.byte	0,5,5,0,0,17
	.word	1042
	.byte	18
	.word	1091
	.byte	5,0,17
	.word	1214
	.byte	18
	.word	1254
	.byte	5,0,17
	.word	1280
	.byte	18
	.word	1314
	.byte	18
	.word	1334
	.byte	18
	.word	1356
	.byte	11,19
	.word	729
	.byte	18
	.word	772
	.byte	18
	.word	792
	.byte	20
	.word	817
	.byte	0,5,0,0,17
	.word	1822
	.byte	18
	.word	1859
	.byte	18
	.word	1881
	.byte	18
	.word	1904
	.byte	11,19
	.word	318
	.byte	18
	.word	351
	.byte	20
	.word	371
	.byte	0,5,19
	.word	186
	.byte	18
	.word	229
	.byte	20
	.word	249
	.byte	0,5,0,0,23
	.byte	'__INDIRECT__',0,4,1,1,1,1,1,24,1,9
	.word	2539
	.byte	22
	.byte	'__codeptr',0,4,1,1
	.word	2541
	.byte	2
	.byte	'char',0,1,6,22
	.byte	'sint8',0,9,76,25
	.word	2564
	.byte	22
	.byte	'uint8',0,9,81,25
	.word	147
	.byte	22
	.byte	'uint16',0,9,91,25
	.word	164
	.byte	2
	.byte	'unsigned int',0,4,7,22
	.byte	'uint32',0,9,106,24
	.word	2615
	.byte	2
	.byte	'unsigned long long int',0,8,7,22
	.byte	'uint64',0,9,111,30
	.word	2646
	.byte	22
	.byte	'boolean',0,9,127,25
	.word	147
	.byte	22
	.byte	'StatusType',0,10,191,1,27
	.word	147
	.byte	22
	.byte	'Std_ReturnType',0,10,199,1,15
	.word	147
	.byte	13,10,206,1,9,8,14
	.byte	'vendorID',0
	.word	164
	.byte	2,2,35,0,14
	.byte	'moduleID',0
	.word	164
	.byte	2,2,35,2,14
	.byte	'sw_major_version',0
	.word	147
	.byte	1,2,35,4,14
	.byte	'sw_minor_version',0
	.word	147
	.byte	1,2,35,5,14
	.byte	'sw_patch_version',0
	.word	147
	.byte	1,2,35,6,0,22
	.byte	'Std_VersionInfoType',0,10,213,1,3
	.word	2747
	.byte	22
	.byte	'PduIdType',0,11,22,19
	.word	164
	.byte	22
	.byte	'PduLengthType',0,11,26,19
	.word	164
	.byte	6,12,113,9,4,7
	.byte	'TP_DATACONF',0,0,7
	.byte	'TP_DATARETRY',0,1,7
	.byte	'TP_CONFPENDING',0,2,0,22
	.byte	'TpDataStateType',0,12,118,3
	.word	2937
	.byte	22
	.byte	'Can_IdType',0,13,32,16
	.word	2615
	.byte	22
	.byte	'Can_HwHandleType',0,13,43,16
	.word	164
	.byte	13,14,93,9,8,14
	.byte	'Class',0
	.word	147
	.byte	1,2,35,0,14
	.byte	'TIN',0
	.word	147
	.byte	1,2,35,1,14
	.byte	'ReturnAddress',0
	.word	2615
	.byte	4,2,35,4,0,22
	.byte	'OsTrapInfoType',0,14,97,3
	.word	3057
	.byte	25,68
	.word	2615
	.byte	26,16,0,13,14,154,1,9,68,14
	.byte	'store',0
	.word	3137
	.byte	68,2,35,0,0,25,68
	.word	3146
	.byte	26,0,0,22
	.byte	'Os_JumpBufType',0,14,156,1,3
	.word	3168
	.byte	22
	.byte	'Os_StackTraceType',0,14,174,1,18
	.word	2615
	.byte	13,14,175,1,9,8,14
	.byte	'sp',0
	.word	2615
	.byte	4,2,35,0,14
	.byte	'ctx',0
	.word	2615
	.byte	4,2,35,4,0,22
	.byte	'Os_StackValueType',0,14,175,1,63
	.word	3228
	.byte	22
	.byte	'Os_StackSizeType',0,14,176,1,27
	.word	3228
	.byte	27,1,1,9
	.word	3313
	.byte	22
	.byte	'Os_VoidVoidFunctionType',0,14,179,1,16
	.word	3316
	.byte	22
	.byte	'ApplicationType',0,14,193,1,23
	.word	147
	.byte	28
	.byte	'Os_ApplicationConfigurationType_s',0,14,198,1,16,2,14
	.byte	'app_id',0
	.word	147
	.byte	1,2,35,0,14
	.byte	'access',0
	.word	147
	.byte	1,2,35,1,0,22
	.byte	'Os_ApplicationConfigurationType',0,14,201,1,3
	.word	3379
	.byte	22
	.byte	'Os_CoreStateType',0,14,203,1,16
	.word	2615
	.byte	22
	.byte	'AreaIdType',0,14,204,1,16
	.word	164
	.byte	22
	.byte	'Os_PeripheralAddressType',0,14,212,1,22
	.word	2615
	.byte	22
	.byte	'TickType',0,14,221,1,22
	.word	2615
	.byte	22
	.byte	'Os_StopwatchTickType',0,14,225,1,22
	.word	2615
	.byte	9
	.word	2615
	.byte	22
	.byte	'Os_Lockable',0,14,234,1,18
	.word	3621
	.byte	22
	.byte	'CoreIdType',0,14,236,1,16
	.word	164
	.byte	22
	.byte	'SpinlockIdType',0,14,237,1,16
	.word	164
	.byte	6,14,239,1,9,4,7
	.byte	'TRYTOGETSPINLOCK_SUCCESS',0,0,7
	.byte	'TRYTOGETSPINLOCK_NOSUCCESS',0,1,0,22
	.byte	'TryToGetSpinlockType',0,14,239,1,74
	.word	3691
	.byte	6,14,174,2,9,4,7
	.byte	'APPLICATION_ACCESSIBLE',0,0,7
	.byte	'APPLICATION_RESTARTING',0,1,7
	.byte	'APPLICATION_TERMINATED',0,2,0,22
	.byte	'ApplicationStateType',0,14,174,2,92
	.word	3784
	.byte	29,1,1,30
	.word	147
	.byte	30
	.word	444
	.byte	0,9
	.word	3896
	.byte	22
	.byte	'Os_FunctionEntryType',0,14,183,2,16
	.word	3910
	.byte	28
	.byte	'Os_MeterInfoType_s',0,14,193,2,16,48,14
	.byte	'elapsed',0
	.word	2615
	.byte	4,2,35,0,14
	.byte	'previous',0
	.word	2615
	.byte	4,2,35,4,14
	.byte	'max',0
	.word	2615
	.byte	4,2,35,8,14
	.byte	'cumulative',0
	.word	2615
	.byte	4,2,35,12,14
	.byte	'stackbase',0
	.word	3228
	.byte	8,2,35,16,14
	.byte	'stackusage',0
	.word	3228
	.byte	8,2,35,24,14
	.byte	'stackmax',0
	.word	3228
	.byte	8,2,35,32,14
	.byte	'stackbudget',0
	.word	3228
	.byte	8,2,35,40,0,22
	.byte	'Os_MeterInfoType',0,14,202,2,3
	.word	3945
	.byte	9
	.word	3945
	.byte	22
	.byte	'Os_MeterInfoRefType',0,14,203,2,50
	.word	4143
	.byte	22
	.byte	'EventMaskType',0,14,206,2,15
	.word	147
	.byte	22
	.byte	'Os_imaskType',0,14,211,2,16
	.word	2615
	.byte	28
	.byte	'Os_ISRDynType_s',0,14,213,2,16,48,14
	.byte	'meter',0
	.word	3945
	.byte	48,2,35,0,0,22
	.byte	'Os_ISRDynType',0,14,215,2,3
	.word	4222
	.byte	9
	.word	4222
	.byte	10
	.word	4283
	.byte	28
	.byte	'Os_ISRType_s',0,14,216,2,16,24,14
	.byte	'entry_function',0
	.word	3321
	.byte	4,2,35,0,14
	.byte	'dynamic',0
	.word	4288
	.byte	4,2,35,4,14
	.byte	'imask',0
	.word	2615
	.byte	4,2,35,8,14
	.byte	'stackbudget',0
	.word	3228
	.byte	8,2,35,12,14
	.byte	'access',0
	.word	147
	.byte	1,2,35,20,14
	.byte	'application',0
	.word	147
	.byte	1,2,35,21,0,22
	.byte	'Os_ISRType',0,14,223,2,3
	.word	4293
	.byte	9
	.word	3313
	.byte	10
	.word	4293
	.byte	9
	.word	4452
	.byte	22
	.byte	'ISRType',0,14,224,2,46
	.word	4457
	.byte	22
	.byte	'Os_bitmask',0,14,239,2,22
	.word	2615
	.byte	22
	.byte	'Os_pset0Type',0,14,240,2,20
	.word	2615
	.byte	22
	.byte	'Os_pset1Type',0,14,241,2,20
	.word	2615
	.byte	22
	.byte	'Os_pset2Type',0,14,242,2,20
	.word	2615
	.byte	31,14,243,2,9,4,14
	.byte	'p0',0
	.word	2615
	.byte	4,2,35,0,14
	.byte	'p1',0
	.word	2615
	.byte	4,2,35,0,14
	.byte	'p2',0
	.word	2615
	.byte	4,2,35,0,0,22
	.byte	'Os_psetType',0,14,247,2,3
	.word	4565
	.byte	31,14,249,2,9,4,14
	.byte	't0',0
	.word	2615
	.byte	4,2,35,0,14
	.byte	't1',0
	.word	2615
	.byte	4,2,35,0,14
	.byte	't2',0
	.word	2615
	.byte	4,2,35,0,0,22
	.byte	'Os_tpmaskType',0,14,253,2,3
	.word	4629
	.byte	22
	.byte	'Os_ActivationCountType',0,14,254,2,23
	.word	147
	.byte	28
	.byte	'Os_TaskDynType_s',0,14,128,3,16,120,14
	.byte	'terminate_jump_buf',0
	.word	3177
	.byte	68,2,35,0,14
	.byte	'meter',0
	.word	3945
	.byte	48,2,35,68,14
	.byte	'activation_count',0
	.word	147
	.byte	1,2,35,116,0,22
	.byte	'Os_TaskDynType',0,14,132,3,3
	.word	4727
	.byte	25,68
	.word	3146
	.byte	26,0,0,9
	.word	4727
	.byte	10
	.word	4853
	.byte	28
	.byte	'Os_TaskType_s',0,14,134,3,16,40,14
	.byte	'dynamic',0
	.word	4858
	.byte	4,2,35,0,14
	.byte	'entry_function',0
	.word	3321
	.byte	4,2,35,4,14
	.byte	'pset',0
	.word	4565
	.byte	4,2,35,8,14
	.byte	'base_tpmask',0
	.word	4629
	.byte	4,2,35,12,14
	.byte	'tpmask',0
	.word	4629
	.byte	4,2,35,16,14
	.byte	'core_id',0
	.word	164
	.byte	2,2,35,20,14
	.byte	'index',0
	.word	2615
	.byte	4,2,35,24,14
	.byte	'stackbudget',0
	.word	3228
	.byte	8,2,35,28,14
	.byte	'activation_count',0
	.word	147
	.byte	1,2,35,36,14
	.byte	'access',0
	.word	147
	.byte	1,2,35,37,14
	.byte	'application',0
	.word	147
	.byte	1,2,35,38,0,22
	.byte	'Os_TaskType',0,14,146,3,3
	.word	4863
	.byte	10
	.word	4863
	.byte	9
	.word	5113
	.byte	22
	.byte	'TaskType',0,14,147,3,47
	.word	5118
	.byte	32
	.byte	'Os_TaskStateType',0,14,155,3,6,4,7
	.byte	'SUSPENDED',0,0,7
	.byte	'READY',0,1,7
	.byte	'WAITING',0,2,7
	.byte	'RUNNING',0,3,0,22
	.byte	'TaskStateType',0,14,156,3,31
	.word	5141
	.byte	31,14,167,3,3,4,14
	.byte	'tpmask',0
	.word	4629
	.byte	4,2,35,0,0,28
	.byte	'Os_ResourceDynType_s',0,14,166,3,16,4,14
	.byte	'saved_priority',0
	.word	5228
	.byte	4,2,35,0,0,22
	.byte	'Os_ResourceDynType',0,14,170,3,3
	.word	5251
	.byte	9
	.word	5251
	.byte	10
	.word	5331
	.byte	28
	.byte	'Os_ResourceType_s',0,14,171,3,16,12,14
	.byte	'dynamic',0
	.word	5336
	.byte	4,2,35,0,14
	.byte	'tpmask',0
	.word	4629
	.byte	4,2,35,4,14
	.byte	'access',0
	.word	147
	.byte	1,2,35,8,0,22
	.byte	'Os_ResourceType',0,14,175,3,3
	.word	5341
	.byte	13,14,181,3,9,12,14
	.byte	'maxallowedvalue',0
	.word	2615
	.byte	4,2,35,0,14
	.byte	'ticksperbase',0
	.word	2615
	.byte	4,2,35,4,14
	.byte	'mincycle',0
	.word	2615
	.byte	4,2,35,8,0,22
	.byte	'AlarmBaseType',0,14,185,3,3
	.word	5440
	.byte	13,14,206,3,9,8,14
	.byte	'Running',0
	.word	147
	.byte	1,2,35,0,14
	.byte	'Pending',0
	.word	147
	.byte	1,2,35,1,14
	.byte	'Delay',0
	.word	2615
	.byte	4,2,35,4,0,22
	.byte	'Os_CounterStatusType',0,14,210,3,3
	.word	5535
	.byte	9
	.word	2213
	.byte	22
	.byte	'Os_CounterIncrAdvType',0,14,217,3,22
	.word	5621
	.byte	28
	.byte	's_swd',0,14,222,3,12,4,14
	.byte	'count',0
	.word	2615
	.byte	4,2,35,0,0,31,14,221,3,3,4,14
	.byte	'sw',0
	.word	5657
	.byte	4,2,35,0,0,28
	.byte	'Os_CounterDynType_s',0,14,220,3,16,4,14
	.byte	'type_dependent',0
	.word	5685
	.byte	4,2,35,0,0,22
	.byte	'Os_CounterDynType',0,14,226,3,3
	.word	5704
	.byte	9
	.word	5704
	.byte	10
	.word	5782
	.byte	28
	.byte	'Os_CounterType_s',0,14,227,3,16,28,14
	.byte	'dynamic',0
	.word	5787
	.byte	4,2,35,0,14
	.byte	'advincr',0
	.word	5626
	.byte	4,2,35,4,14
	.byte	'base',0
	.word	5440
	.byte	12,2,35,8,14
	.byte	'core',0
	.word	444
	.byte	4,2,35,20,14
	.byte	'access',0
	.word	147
	.byte	1,2,35,24,14
	.byte	'application',0
	.word	147
	.byte	1,2,35,25,0,22
	.byte	'Os_CounterType',0,14,234,3,3
	.word	5792
	.byte	9
	.word	2213
	.byte	10
	.word	5792
	.byte	9
	.word	5944
	.byte	22
	.byte	'CounterType',0,14,235,3,52
	.word	5949
	.byte	32
	.byte	'Os_ScheduleTableStatusType',0,14,240,3,6,4,7
	.byte	'SCHEDULETABLE_STOPPED',0,0,7
	.byte	'SCHEDULETABLE_NEXT',0,1,7
	.byte	'SCHEDULETABLE_WAITING',0,2,7
	.byte	'SCHEDULETABLE_RUNNING',0,3,7
	.byte	'SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS',0,4,0,22
	.byte	'ScheduleTableStatusType',0,14,241,3,41
	.word	5975
	.byte	10
	.word	.L313-.L98
	.byte	9
	.word	6175
	.byte	22
	.byte	'ScheduleTableType',0,14,128,4,58
	.word	6180
	.byte	28
	.byte	'Os_ScheduleTableDynType_s',0,14,130,4,16,16,14
	.byte	'match',0
	.word	2615
	.byte	4,2,35,0,14
	.byte	'next',0
	.word	6185
	.byte	4,2,35,4,14
	.byte	'state',0
	.word	5975
	.byte	4,2,35,8,14
	.byte	'config',0
	.word	164
	.byte	2,2,35,12,0,9
	.word	6212
	.byte	10
	.word	6305
.L313:
	.byte	28
	.byte	'Os_ScheduleTableType_s',0,14,247,3,16,16,14
	.byte	'dynamic',0
	.word	6310
	.byte	4,2,35,0,14
	.byte	'counter',0
	.word	5954
	.byte	4,2,35,4,14
	.byte	'repeat',0
	.word	147
	.byte	1,2,35,8,14
	.byte	'config',0
	.word	164
	.byte	2,2,35,10,14
	.byte	'initial',0
	.word	147
	.byte	1,2,35,12,14
	.byte	'access',0
	.word	147
	.byte	1,2,35,13,14
	.byte	'application',0
	.word	147
	.byte	1,2,35,14,0,22
	.byte	'Os_ScheduleTableType',0,14,255,3,3
	.word	6315
	.byte	10
	.word	6315
	.byte	9
	.word	6495
	.byte	10
	.word	5792
	.byte	9
	.word	6505
	.byte	33
	.word	3626
	.byte	33
	.word	4565
	.byte	33
	.word	4462
	.byte	33
	.word	5123
	.byte	33
	.word	4629
	.byte	33
	.word	147
	.byte	33
	.word	5123
	.byte	28
	.byte	'Os_ControlledCoreType_s',0,14,251,6,16,112,14
	.byte	'TrapInfo',0
	.word	3057
	.byte	8,2,35,0,14
	.byte	'lock_taskaccess',0
	.word	6515
	.byte	4,2,35,8,14
	.byte	'ReadyTasks',0
	.word	6520
	.byte	4,2,35,12,14
	.byte	'RunningISR',0
	.word	6525
	.byte	4,2,35,16,14
	.byte	'RunningTask',0
	.word	6530
	.byte	4,2,35,20,14
	.byte	'RunningTPMask',0
	.word	6535
	.byte	4,2,35,24,14
	.byte	'CurrentMeteredObject',0
	.word	4148
	.byte	4,2,35,28,14
	.byte	'IdleMeter',0
	.word	3945
	.byte	48,2,35,32,14
	.byte	'AppAccess',0
	.word	147
	.byte	1,2,35,80,14
	.byte	'AppOverride',0
	.word	6540
	.byte	1,2,35,81,14
	.byte	'GetStackValueAdjust',0
	.word	3228
	.byte	8,2,35,84,14
	.byte	'InErrorHook',0
	.word	147
	.byte	1,2,35,92,14
	.byte	'ChainTaskRef',0
	.word	6545
	.byte	4,2,35,96,14
	.byte	'GetStackUsageAdjust',0
	.word	3228
	.byte	8,2,35,100,14
	.byte	'InProtectionHook',0
	.word	147
	.byte	1,2,35,108,14
	.byte	'CoreIsActive',0
	.word	147
	.byte	1,2,35,109,14
	.byte	'InShutdownHook',0
	.word	147
	.byte	1,2,35,110,0,22
	.byte	'Os_ControlledCoreType',0,14,141,7,3
	.word	6550
	.byte	9
	.word	2615
	.byte	10
	.word	4293
	.byte	9
	.word	7006
	.byte	10
	.word	4863
	.byte	9
	.word	7016
	.byte	9
	.word	3945
	.byte	28
	.byte	'Os_AnyCoreType_s',0,14,151,7,16,96,14
	.byte	'DisableAllImask',0
	.word	2615
	.byte	4,2,35,0,14
	.byte	'SuspendAllImask',0
	.word	2615
	.byte	4,2,35,4,14
	.byte	'SuspendOSImask',0
	.word	2615
	.byte	4,2,35,8,14
	.byte	'DisableAllCount',0
	.word	2615
	.byte	4,2,35,12,14
	.byte	'SuspendAllCount',0
	.word	2615
	.byte	4,2,35,16,14
	.byte	'SuspendOSCount',0
	.word	2615
	.byte	4,2,35,20,14
	.byte	'RestartJumpBuf',0
	.word	3177
	.byte	68,2,35,24,14
	.byte	'Restartable',0
	.word	147
	.byte	1,2,35,92,0,22
	.byte	'Os_AnyCoreType',0,14,160,7,3
	.word	7031
	.byte	22
	.byte	'Can_TxObjPriorityClassType',0,15,219,3,16
	.word	2615
	.byte	28
	.byte	'Can_TxHwObjectConfigType',0,15,231,3,16,8,14
	.byte	'MsgObjId',0
	.word	147
	.byte	1,2,35,0,14
	.byte	'HwControllerId',0
	.word	147
	.byte	1,2,35,1,14
	.byte	'TxObjPriorityClass',0
	.word	2615
	.byte	4,2,35,4,0,22
	.byte	'Can_TxHwObjectConfigType',0,15,252,3,3
	.word	7308
	.byte	28
	.byte	'Can_RxHwObjectConfigType',0,15,129,4,16,12,14
	.byte	'MaskRef',0
	.word	2615
	.byte	4,2,35,0,14
	.byte	'MsgId',0
	.word	2615
	.byte	4,2,35,4,14
	.byte	'MsgObjId',0
	.word	147
	.byte	1,2,35,8,14
	.byte	'HwControllerId',0
	.word	147
	.byte	1,2,35,9,0,22
	.byte	'Can_RxHwObjectConfigType',0,15,147,4,3
	.word	7444
	.byte	25,4
	.word	147
	.byte	26,3,0,28
	.byte	'Can_ControllerMOMapConfigType',0,15,181,4,16,4,14
	.byte	'ControllerMOMap',0
	.word	7584
	.byte	4,2,35,0,0,22
	.byte	'Can_ControllerMOMapConfigType',0,15,184,4,3
	.word	7593
	.byte	28
	.byte	'Can_NPCRValueType',0,15,188,4,16,2,14
	.byte	'Can_NPCRValue',0
	.word	164
	.byte	2,2,35,0,0,22
	.byte	'Can_NPCRValueType',0,15,191,4,3
	.word	7694
	.byte	28
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,15,194,4,16,8,14
	.byte	'CanControllerBaudrate',0
	.word	2615
	.byte	4,2,35,0,14
	.byte	'CanControllerBaudrateCfg',0
	.word	164
	.byte	2,2,35,4,0,22
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,15,198,4,3
	.word	7769
	.byte	10
	.word	7769
	.byte	9
	.word	7934
	.byte	28
	.byte	'Can_BaudrateConfigPtrType',0,15,201,4,16,4,14
	.byte	'Can_kBaudrateConfigPtr',0
	.word	7939
	.byte	4,2,35,0,0,22
	.byte	'Can_BaudrateConfigPtrType',0,15,204,4,3
	.word	7944
	.byte	28
	.byte	'Can_EventHandlingType',0,15,226,4,16,4,14
	.byte	'CanEventType',0
	.word	7584
	.byte	4,2,35,0,0,22
	.byte	'Can_EventHandlingType',0,15,229,4,3
	.word	8044
	.byte	22
	.byte	'Rte_TransformerErrorCode',0,16,130,1,15
	.word	147
	.byte	22
	.byte	'Rte_TransformerClass',0,16,131,1,15
	.word	147
	.byte	13,16,168,1,9,12,14
	.byte	'in',0
	.word	444
	.byte	4,2,35,0,14
	.byte	'out',0
	.word	444
	.byte	4,2,35,4,14
	.byte	'used',0
	.word	164
	.byte	2,2,35,8,14
	.byte	'lost_data',0
	.word	147
	.byte	1,2,35,10,0,22
	.byte	'Rte_QDynType',0,16,173,1,3
	.word	8190
	.byte	6,16,175,1,9,4,7
	.byte	'RTE_DRA',0,0,7
	.byte	'RTE_WOWP',0,1,7
	.byte	'RTE_TASK',0,2,7
	.byte	'RTE_ARE',0,3,7
	.byte	'RTE_EV',0,4,7
	.byte	'RTE_MSI',0,5,0,22
	.byte	'Rte_NotificationType',0,16,182,1,3
	.word	8277
	.byte	9
	.word	8190
	.byte	28
	.byte	'Rte_QCmnType',0,16,184,1,16,24,14
	.byte	'dynamic',0
	.word	8375
	.byte	4,2,35,0,14
	.byte	'copy',0
	.word	147
	.byte	1,2,35,4,14
	.byte	'queue_size',0
	.word	164
	.byte	2,2,35,6,14
	.byte	'element_size',0
	.word	164
	.byte	2,2,35,8,14
	.byte	'buffer_start',0
	.word	444
	.byte	4,2,35,12,14
	.byte	'buffer_end',0
	.word	444
	.byte	4,2,35,16,14
	.byte	'notification_type',0
	.word	8277
	.byte	4,2,35,20,0,22
	.byte	'Rte_QCmnType',0,16,192,1,3
	.word	8380
	.byte	22
	.byte	'Rte_AlarmRefType',0,16,224,1,32
	.word	2615
	.byte	22
	.byte	'Rte_AlarmIndexType',0,16,226,1,32
	.word	164
	.byte	25,128,8
	.word	147
	.byte	26,255,7,0,22
	.byte	'Impl_NVM_DstPtrType_1024',0,17,50,15
	.word	8618
	.byte	22
	.byte	'CanIf_u32_impl',0,17,69,16
	.word	2615
	.byte	22
	.byte	'CanIf_u16_impl',0,17,71,16
	.word	164
	.byte	22
	.byte	'CanIf_u8_impl',0,17,73,15
	.word	147
	.byte	22
	.byte	'CanIf_ControllerModeType_Enum_impl',0,17,88,15
	.word	147
	.byte	22
	.byte	'CanIf_PduModeType_Enum_impl',0,17,90,15
	.word	147
	.byte	13,17,92,9,2,14
	.byte	'DeviceMode',0
	.word	147
	.byte	1,2,35,0,14
	.byte	'ChannelMode',0
	.word	147
	.byte	1,2,35,1,0,22
	.byte	'CanIf_ControllerStateType_struct_impl',0,17,95,3
	.word	8809
	.byte	22
	.byte	'CanIf_NotifStatusType_Enum_impl',0,17,100,15
	.word	147
	.byte	22
	.byte	'CanSM_boolean_Impl',0,17,120,15
	.word	147
	.byte	22
	.byte	'CanSM_u8_Impl',0,17,123,15
	.word	147
	.byte	22
	.byte	'CanSM_BusOffRecoveryStateType_Enum_impl',0,17,128,1,15
	.word	147
	.byte	22
	.byte	'CanSM_NetworkModeStateType_Enum_impl',0,17,132,1,15
	.word	147
	.byte	22
	.byte	'CanSM_u16_Impl',0,17,136,1,16
	.word	164
	.byte	22
	.byte	'CanSM_TimerStateType_Enum_impl',0,17,138,1,15
	.word	147
	.byte	13,17,140,1,9,4,14
	.byte	'cntTick_u16',0
	.word	164
	.byte	2,2,35,0,14
	.byte	'stTimer',0
	.word	147
	.byte	1,2,35,2,0,22
	.byte	'CanSM_TimerConfig_tst_struct_impl',0,17,143,1,3
	.word	9150
	.byte	22
	.byte	'Com_impl_u16',0,17,154,1,16
	.word	164
	.byte	22
	.byte	'Com_impl_u8',0,17,157,1,15
	.word	147
	.byte	22
	.byte	'ComM_uint32_Impl',0,17,173,1,16
	.word	2615
	.byte	22
	.byte	'ComM_uint16_Impl',0,17,175,1,16
	.word	164
	.byte	22
	.byte	'ComM_uint8_Impl',0,17,177,1,15
	.word	147
	.byte	22
	.byte	'ComM_bool_Impl',0,17,179,1,15
	.word	147
	.byte	13,17,181,1,9,24,14
	.byte	'ChannelState_e',0
	.word	2615
	.byte	4,2,35,0,14
	.byte	'LightTimeoutCtr_u32',0
	.word	2615
	.byte	4,2,35,4,14
	.byte	'MinFullComTimeoutCtr_u16',0
	.word	164
	.byte	2,2,35,8,14
	.byte	'ChannelMode_u8',0
	.word	147
	.byte	1,2,35,10,14
	.byte	'BusSmMode_u8',0
	.word	147
	.byte	1,2,35,11,14
	.byte	'UserRequestCtr_u8',0
	.word	147
	.byte	1,2,35,12,14
	.byte	'PassiveRequestState_u8',0
	.word	147
	.byte	1,2,35,13,14
	.byte	'PncRequestCtr_u8',0
	.word	147
	.byte	1,2,35,14,14
	.byte	'InhibitionReqStatus_u8',0
	.word	147
	.byte	1,2,35,15,14
	.byte	'NmNetworkRequestStatus_b',0
	.word	147
	.byte	1,2,35,16,14
	.byte	'DiagnosticRequestState_b',0
	.word	147
	.byte	1,2,35,17,14
	.byte	'CommunicationAllowed_b',0
	.word	147
	.byte	1,2,35,18,14
	.byte	'NmBusSleepIndicationStatus_b',0
	.word	147
	.byte	1,2,35,19,14
	.byte	'NmPrepareBusSleepIndicationStatus_b',0
	.word	147
	.byte	1,2,35,20,14
	.byte	'NmNetworkModeStatus_b',0
	.word	147
	.byte	1,2,35,21,0,22
	.byte	'ComM_ChannelStruct_Impl',0,17,197,1,3
	.word	9382
	.byte	13,17,206,1,9,10,14
	.byte	'WakeUpInhibitionCtr_u16',0
	.word	164
	.byte	2,2,35,0,14
	.byte	'LimitToNoComCtr_u16',0
	.word	164
	.byte	2,2,35,2,14
	.byte	'RequestedUserMode_t',0
	.word	147
	.byte	1,2,35,4,14
	.byte	'IndicatedUserMode_t',0
	.word	147
	.byte	1,2,35,5,14
	.byte	'numChannelsInFullCom_u8',0
	.word	147
	.byte	1,2,35,6,14
	.byte	'numChannelsInSilentCom_u8',0
	.word	147
	.byte	1,2,35,7,14
	.byte	'numChannelsInNoCom_u8',0
	.word	147
	.byte	1,2,35,8,0,22
	.byte	'ComM_UserStruct_Impl',0,17,214,1,3
	.word	9886
	.byte	22
	.byte	'Dcm_IOOperationResponseType',0,17,252,1,15
	.word	147
	.byte	22
	.byte	'Dcm_RequestDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspRequestRoutineResultsOutSignal_0PrimitivType',0
	.byte	17,138,2,15
	.word	147
	.byte	22
	.byte	'Dcm_StartDataIn_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineInSignalPrimitivType',0,17,146,2,15
	.word	147
	.byte	22
	.byte	'Dcm_StartDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineOutSignalPrimitivType',0,17,150,2,15
	.word	147
	.byte	22
	.byte	'Dcm_StopDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStopRoutineOutSignalPrimitivType',0,17,154,2,15
	.word	147
	.byte	22
	.byte	'NvM_BlockIdType',0,17,215,2,16
	.word	164
	.byte	22
	.byte	'NvM_RequestResultType',0,17,225,2,15
	.word	147
	.byte	22
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockNative_1024_Type',0,17,243,3,34
	.word	8629
	.byte	25,128,8
	.word	147
	.byte	26,255,7,0,22
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockRedundant_1024_Type',0,17,246,3,34
	.word	8629
	.byte	6,18,31,9,4,7
	.byte	'MEMIF_JOB_OK',0,0,7
	.byte	'MEMIF_JOB_FAILED',0,1,7
	.byte	'MEMIF_JOB_PENDING',0,2,7
	.byte	'MEMIF_JOB_CANCELED',0,3,7
	.byte	'MEMIF_BLOCK_INCONSISTENT',0,4,7
	.byte	'MEMIF_BLOCK_INVALID',0,5,0,22
	.byte	'MemIf_JobResultType',0,18,39,2
	.word	10760
	.byte	22
	.byte	'NvM_BlockManagementType',0,2,45,3
	.word	251
	.byte	6,2,49,9,4,7
	.byte	'NVM_PRV_ACTIVITY_NOT_INIT',0,0,7
	.byte	'NVM_PRV_ACTIVITY_IDLE',0,1,7
	.byte	'NVM_PRV_ACTIVITY_ARBITRATE',0,2,7
	.byte	'NVM_PRV_ACTIVITY_JOB_START',0,3,7
	.byte	'NVM_PRV_ACTIVITY_POLL_RESULT',0,4,7
	.byte	'NVM_PRV_ACTIVITY_JOB_COMPLETE',0,5,7
	.byte	'NVM_PRV_ACTIVITY_RESULT_EVAL',0,6,0,22
	.byte	'NvM_Prv_Activities_ten',0,2,58,3
	.word	10950
	.byte	22
	.byte	'NvM_Prv_idJob_ten',0,2,115,3
	.word	1383
	.byte	22
	.byte	'NvM_Prv_ServiceBit_tuo',0,2,168,1,16
	.word	164
	.byte	22
	.byte	'NvM_Prv_idService_tuo',0,2,173,1,15
	.word	147
	.byte	22
	.byte	'NvM_Prv_idQueue_tuo',0,2,206,1,15
	.word	147
	.byte	22
	.byte	'NvM_Prv_QueueEntry_tst',0,2,225,1,3
	.word	1115
	.byte	9
	.word	147
	.byte	13,2,227,1,9,20,14
	.byte	'idJob_en',0
	.word	1383
	.byte	4,2,35,0,14
	.byte	'idBlock_uo',0
	.word	164
	.byte	2,2,35,4,14
	.byte	'RamBlock_pu8',0
	.word	11341
	.byte	4,2,35,8,14
	.byte	'idxDataset_u8',0
	.word	147
	.byte	1,2,35,12,14
	.byte	'Result_en',0
	.word	10760
	.byte	4,2,35,16,0,22
	.byte	'NvM_Prv_JobData_tst',0,2,240,1,3
	.word	11346
	.byte	13,2,245,1,9,32,14
	.byte	'Activity_rAMwM_en',0
	.word	10950
	.byte	4,2,35,0,14
	.byte	'idQueueActive_uo',0
	.word	147
	.byte	1,2,35,4,14
	.byte	'QueueEntry_pst',0
	.word	1209
	.byte	4,2,35,8,14
	.byte	'JobData_st',0
	.word	11346
	.byte	20,2,35,12,0,22
	.byte	'NvM_Prv_MainStates_tst',0,2,132,2,3
	.word	11484
	.byte	22
	.byte	'Rte_TaskRefType',0,19,184,1,32
	.word	5123
	.byte	22
	.byte	'Rte_EventRefType',0,19,185,1,32
	.word	147
	.byte	22
	.byte	'Rte_EventType',0,19,186,1,32
	.word	2615
	.byte	22
	.byte	'Rte_REActCounterType',0,19,252,1,15
	.word	147
	.byte	9
	.word	147
	.byte	22
	.byte	'Rte_REActCounterRefType',0,19,253,1,58
	.word	11724
	.byte	13,19,255,1,9,8,14
	.byte	'task',0
	.word	11620
	.byte	4,2,35,0,14
	.byte	'acnt',0
	.word	11729
	.byte	4,2,35,4,0,22
	.byte	'Rte_REContainerType',0,19,130,2,3
	.word	11762
	.byte	10
	.word	4863
	.byte	9
	.word	11826
	.byte	9
	.word	147
	.byte	10
	.word	11762
	.byte	9
	.word	11841
	.byte	22
	.byte	'Rte_REContainerRefType',0,19,132,2,60
	.word	11846
	.byte	22
	.byte	'Rte_MSICounterType',0,19,149,2,16
	.word	164
	.byte	9
	.word	164
	.byte	22
	.byte	'Rte_MSICounterRefType',0,19,150,2,56
	.word	11911
	.byte	22
	.byte	'Rte_MSIPendingFlagType',0,19,152,2,17
	.word	147
	.byte	9
	.word	147
	.byte	22
	.byte	'Rte_MSIPendingFlagRefType',0,19,153,2,60
	.word	11979
	.byte	13,19,163,2,9,24,14
	.byte	'counter',0
	.word	11916
	.byte	4,2,35,0,14
	.byte	'incCounter',0
	.word	147
	.byte	1,2,35,4,14
	.byte	'pending',0
	.word	11984
	.byte	4,2,35,8,14
	.byte	'osTask',0
	.word	11620
	.byte	4,2,35,12,14
	.byte	'acnt',0
	.word	11729
	.byte	4,2,35,16,14
	.byte	'osEvent',0
	.word	147
	.byte	1,2,35,20,14
	.byte	'MSIInit',0
	.word	164
	.byte	2,2,35,22,0,22
	.byte	'Rte_MSITableEntry',0,19,172,2,3
	.word	12019
	.byte	9
	.word	164
	.byte	9
	.word	147
	.byte	22
	.byte	'Rte_TaskArrayIndex',0,19,179,2,16
	.word	147
	.byte	22
	.byte	'Rte_NrWaitingTasks',0,19,180,2,16
	.word	147
	.byte	13,19,182,2,9,4,14
	.byte	'pending',0
	.word	147
	.byte	1,2,35,0,14
	.byte	'count',0
	.word	147
	.byte	1,2,35,1,14
	.byte	'firstWaitingTask',0
	.word	147
	.byte	1,2,35,2,0,22
	.byte	'Rte_WaitableDatum',0,19,186,2,3
	.word	12237
	.byte	9
	.word	12237
	.byte	13,19,226,2,9,12,14
	.byte	'event_id',0
	.word	2615
	.byte	4,2,35,0,14
	.byte	'wd',0
	.word	12329
	.byte	4,2,35,4,14
	.byte	'timeout',0
	.word	2615
	.byte	4,2,35,8,0,22
	.byte	'Rte_WOWP_NotificationType',0,19,230,2,3
	.word	12334
	.byte	10
	.word	12334
	.byte	9
	.word	12423
	.byte	22
	.byte	'Rte_WOWP_NotificationRefType',0,19,232,2,66
	.word	12428
	.byte	22
	.byte	'Rte_ARE_NotificationType',0,19,234,2,29
	.word	11762
	.byte	28
	.byte	'Rte_QTaskType',0,19,243,2,16,28,14
	.byte	'cmn',0
	.word	8380
	.byte	24,2,35,0,14
	.byte	'task',0
	.word	11620
	.byte	4,2,35,24,0,22
	.byte	'Rte_QTaskType',0,19,246,2,3
	.word	12505
	.byte	28
	.byte	'Rte_QREType',0,19,250,2,16,28,14
	.byte	'cmn',0
	.word	8380
	.byte	24,2,35,0,14
	.byte	're',0
	.word	11851
	.byte	4,2,35,24,0,22
	.byte	'Rte_QREType',0,19,253,2,3
	.word	12576
	.byte	10
	.word	11762
	.byte	9
	.word	12641
	.byte	28
	.byte	'Rte_QWWPType',0,19,129,3,16,28,14
	.byte	'cmn',0
	.word	8380
	.byte	24,2,35,0,14
	.byte	'wwp',0
	.word	12433
	.byte	4,2,35,24,0,22
	.byte	'Rte_QWWPType',0,19,132,3,3
	.word	12651
	.byte	10
	.word	12334
	.byte	9
	.word	12719
	.byte	28
	.byte	'Rte_QEvType',0,19,136,3,16,36,14
	.byte	'cmn',0
	.word	8380
	.byte	24,2,35,0,14
	.byte	'task',0
	.word	11620
	.byte	4,2,35,24,14
	.byte	'mask',0
	.word	147
	.byte	1,2,35,28,14
	.byte	'acnt',0
	.word	11729
	.byte	4,2,35,32,0,22
	.byte	'Rte_QEvType',0,19,141,3,3
	.word	12729
	.byte	28
	.byte	'Rte_QMSIType',0,19,145,3,16,48,14
	.byte	'cmn',0
	.word	8380
	.byte	24,2,35,0,14
	.byte	'task',0
	.word	11620
	.byte	4,2,35,24,14
	.byte	'mask',0
	.word	147
	.byte	1,2,35,28,14
	.byte	'acnt',0
	.word	11729
	.byte	4,2,35,32,14
	.byte	'msiCounter',0
	.word	11916
	.byte	4,2,35,36,14
	.byte	'msiPending',0
	.word	11984
	.byte	4,2,35,40,14
	.byte	'msiLimit',0
	.word	164
	.byte	2,2,35,44,0,22
	.byte	'Rte_QMSIType',0,19,153,3,3
	.word	12824
	.byte	22
	.byte	'rba_BswSrv_uint64',0,20,66,28
	.word	2646
	.byte	34
	.byte	'NvM_Prv_Main_st',0,5,59,31
	.word	11484
	.byte	1,1,35
	.word	147
	.byte	1,1,30
	.word	444
	.byte	0,9
	.word	13031
	.byte	22
	.byte	'NvM_Prv_ExplicitSync_Copy_tpfct',0,1,29,26
	.word	13044
	.byte	6,1,34,9,4,7
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL',0,1,7
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL',0,2,7
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL',0,4,7
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE',0,8,7
	.byte	'NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED',0,16,7
	.byte	'NVM_PRV_BLOCK_FLAG_WRITE_ONCE',0,32,7
	.byte	'NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW',0,192,0,7
	.byte	'NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM',0,128,1,7
	.byte	'NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION',0,128,2,7
	.byte	'NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH',0,128,4,7
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION',0,128,8,7
	.byte	'NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL',0,128,16,0,22
	.byte	'NvM_Prv_BlockConfiguration_ten',0,1,85,3
	.word	13089
	.byte	10
	.word	164
	.byte	9
	.word	13652
	.byte	10
	.word	444
	.byte	9
	.word	13662
	.byte	35
	.word	147
	.byte	1,1,30
	.word	147
	.byte	30
	.word	147
	.byte	0,9
	.word	13672
	.byte	35
	.word	147
	.byte	1,1,30
	.word	147
	.byte	0,9
	.word	13695
	.byte	9
	.word	2213
	.byte	13,1,121,9,48,14
	.byte	'idBlockMemIf_u16',0
	.word	164
	.byte	2,2,35,0,14
	.byte	'nrBlockBytes_pu16',0
	.word	13657
	.byte	4,2,35,4,14
	.byte	'idxDevice_u8',0
	.word	147
	.byte	1,2,35,8,14
	.byte	'nrNvBlocks_u8',0
	.word	147
	.byte	1,2,35,9,14
	.byte	'nrRomBlocks_u8',0
	.word	147
	.byte	1,2,35,10,14
	.byte	'adrRamBlock_ppv',0
	.word	13667
	.byte	4,2,35,12,14
	.byte	'adrRomBlock_pcv',0
	.word	516
	.byte	4,2,35,16,14
	.byte	'SingleBlockCallback_pfct',0
	.word	13690
	.byte	4,2,35,20,14
	.byte	'SingleBlockStartCallback_pfct',0
	.word	13708
	.byte	4,2,35,24,14
	.byte	'InitBlockCallback_pfct',0
	.word	13713
	.byte	4,2,35,28,14
	.byte	'ReadRamBlockFromNvm_pfct',0
	.word	13044
	.byte	4,2,35,32,14
	.byte	'WriteRamBlockToNvm_pfct',0
	.word	13044
	.byte	4,2,35,36,14
	.byte	'BlockManagementType_en',0
	.word	251
	.byte	4,2,35,40,14
	.byte	'JobPriority_u8',0
	.word	147
	.byte	1,2,35,44,14
	.byte	'stFlags_u16',0
	.word	164
	.byte	2,2,35,46,0,22
	.byte	'NvM_Prv_BlockDescriptor_tst',0,1,138,2,3
	.word	13718
	.byte	25,160,5
	.word	13718
	.byte	26,13,0,10
	.word	14182
	.byte	34
	.byte	'NvM_Prv_BlockDescriptors_acst',0,1,169,2,45
	.word	14192
	.byte	1,1,25,28
	.word	164
	.byte	26,13,0,34
	.byte	'NvM_Prv_stRequests_rAMwAM_au16',0,3,68,15
	.word	14238
	.byte	1,1,25,14
	.word	147
	.byte	26,13,0,34
	.byte	'NvM_Prv_stRequestResult_rAwAM_au8',0,3,77,30
	.word	14288
	.byte	1,1,9
	.word	1115
	.byte	35
	.word	1383
	.byte	1,1,30
	.word	14341
	.byte	0,9
	.word	14346
.L283:
	.byte	22
	.byte	'NvM_Prv_ProcessMulti_tpfct',0,4,33,29
	.word	14359
	.byte	9
	.word	14346
	.byte	0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L99:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,36,0,3,8,11,15,62,15,0,0,3,46,1,3,8,32,13,58,15,59,15
	.byte	57,15,73,19,54,15,39,12,0,0,4,5,0,3,8,58,15,59,15,57,15,73,19,0,0,5,11,0,0,0,6,4,1,58,15,59,15,57,15,11
	.byte	15,0,0,7,40,0,3,8,28,13,0,0,8,59,0,3,8,0,0,9,15,0,73,19,0,0,10,38,0,73,19,0,0,11,11,1,0,0,12,46,1,3,8
	.byte	32,13,58,15,59,15,57,15,54,15,39,12,0,0,13,19,1,58,15,59,15,57,15,11,15,0,0,14,13,0,3,8,73,19,11,15,56
	.byte	9,0,0,15,46,1,3,8,58,15,59,15,57,15,73,19,54,15,39,12,63,12,60,12,0,0,16,46,1,3,8,58,15,59,15,57,15,54
	.byte	15,39,12,63,12,60,12,0,0,17,46,1,49,19,0,0,18,5,0,49,19,0,0,19,29,1,49,19,0,0,20,11,0,49,19,0,0,21,21
	.byte	0,73,19,54,15,39,12,0,0,22,22,0,3,8,58,15,59,15,57,15,73,19,0,0,23,46,0,3,8,58,15,59,15,57,15,54,15,63
	.byte	12,60,12,0,0,24,21,0,54,15,0,0,25,1,1,11,15,73,19,0,0,26,33,0,47,15,0,0,27,21,0,54,15,39,12,0,0,28,19
	.byte	1,3,8,58,15,59,15,57,15,11,15,0,0,29,21,1,54,15,39,12,0,0,30,5,0,73,19,0,0,31,23,1,58,15,59,15,57,15,11
	.byte	15,0,0,32,4,1,3,8,58,15,59,15,57,15,11,15,0,0,33,53,0,73,19,0,0,34,52,0,3,8,58,15,59,15,57,15,73,19,63
	.byte	12,60,12,0,0,35,21,1,73,19,54,15,39,12,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L100:
	.word	.L315-.L314
.L314:
	.half	3
	.word	.L317-.L316
.L316:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockDescriptor.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\NvM\\api\\NvM_Types.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockData.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_Queue.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_ProcessMultiBlock.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\BswM\\api\\BswM_NvM.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Platform\\Platform_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Std_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Can_GeneralTypes.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\RTOS_T\\Gen\\inc\\Os.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Can_17_MCanP\\inc\\Can_17_MCanP.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Type.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\MemIf\\api\\MemIf_Types.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Intl.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\rba_BswSrv.h',0,0,0,0,0
.L317:
.L315:
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_Multi_Initialize')
	.sect	'.debug_info'
.L101:
	.word	207
	.half	3
	.word	.L102
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L104,.L103
	.byte	2
	.word	.L97
	.byte	3
	.byte	'NvM_Prv_Multi_Initialize',0,1,98,6,1,1,1
	.word	.L78,.L157,.L77
	.byte	4
	.word	.L78,.L157
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_Multi_Initialize')
	.sect	'.debug_abbrev'
.L102:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_Multi_Initialize')
	.sect	'.debug_line'
.L103:
	.word	.L319-.L318
.L318:
	.half	3
	.word	.L321-.L320
.L320:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c',0,0,0,0,0
.L321:
	.byte	5,5,7,0,5,2
	.word	.L78
	.byte	3,227,0,1,5,33,9
	.half	.L322-.L78
	.byte	1,5,31,9
	.half	.L323-.L322
	.byte	1,5,5,9
	.half	.L324-.L323
	.byte	3,1,1,5,33,9
	.half	.L325-.L324
	.byte	1,5,31,9
	.half	.L326-.L325
	.byte	1,5,5,9
	.half	.L327-.L326
	.byte	3,1,1,5,31,9
	.half	.L328-.L327
	.byte	1,5,29,9
	.half	.L329-.L328
	.byte	1,5,1,9
	.half	.L330-.L329
	.byte	3,1,1,7,9
	.half	.L105-.L330
	.byte	0,1,1
.L319:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_Multi_Initialize')
	.sect	'.debug_ranges'
.L104:
	.word	-1,.L78,0,.L105-.L78,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_Multi_IsInProgress')
	.sect	'.debug_info'
.L106:
	.word	213
	.half	3
	.word	.L107
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L109,.L108
	.byte	2
	.word	.L97
	.byte	3
	.byte	'NvM_Prv_Multi_IsInProgress',0,1,105,9
	.word	.L158
	.byte	1,1,1
	.word	.L80,.L159,.L79
	.byte	4
	.word	.L80,.L159
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_Multi_IsInProgress')
	.sect	'.debug_abbrev'
.L107:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_Multi_IsInProgress')
	.sect	'.debug_line'
.L108:
	.word	.L332-.L331
.L331:
	.half	3
	.word	.L334-.L333
.L333:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c',0,0,0,0,0
.L334:
	.byte	5,13,7,0,5,2
	.word	.L80
	.byte	3,234,0,1,5,25,9
	.half	.L335-.L80
	.byte	1,5,22,9
	.half	.L336-.L335
	.byte	1,5,5,9
	.half	.L337-.L336
	.byte	1,5,1,9
	.half	.L2-.L337
	.byte	3,1,1,7,9
	.half	.L110-.L2
	.byte	0,1,1
.L332:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_Multi_IsInProgress')
	.sect	'.debug_ranges'
.L109:
	.word	-1,.L80,0,.L110-.L80,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_Multi_SetResult')
	.sect	'.debug_info'
.L111:
	.word	228
	.half	3
	.word	.L112
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L114,.L113
	.byte	2
	.word	.L97
	.byte	3
	.byte	'NvM_Prv_Multi_SetResult',0,1,110,6,1,1,1
	.word	.L82,.L160,.L81
	.byte	4
	.byte	'Result_uo',0,1,110,52
	.word	.L158,.L161
	.byte	5
	.word	.L82,.L160
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_Multi_SetResult')
	.sect	'.debug_abbrev'
.L112:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_Multi_SetResult')
	.sect	'.debug_line'
.L113:
	.word	.L339-.L338
.L338:
	.half	3
	.word	.L341-.L340
.L340:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c',0,0,0,0,0
.L341:
	.byte	5,5,7,0,5,2
	.word	.L82
	.byte	3,239,0,1,5,29,9
	.half	.L342-.L82
	.byte	1,5,1,9
	.half	.L343-.L342
	.byte	3,1,1,7,9
	.half	.L115-.L343
	.byte	0,1,1
.L339:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_Multi_SetResult')
	.sect	'.debug_ranges'
.L114:
	.word	-1,.L82,0,.L115-.L82,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_Multi_GetResult')
	.sect	'.debug_info'
.L116:
	.word	210
	.half	3
	.word	.L117
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L119,.L118
	.byte	2
	.word	.L97
	.byte	3
	.byte	'NvM_Prv_Multi_GetResult',0,1,115,23
	.word	.L158
	.byte	1,1,1
	.word	.L84,.L162,.L83
	.byte	4
	.word	.L84,.L162
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_Multi_GetResult')
	.sect	'.debug_abbrev'
.L117:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_Multi_GetResult')
	.sect	'.debug_line'
.L118:
	.word	.L345-.L344
.L344:
	.half	3
	.word	.L347-.L346
.L346:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c',0,0,0,0,0
.L347:
	.byte	5,12,7,0,5,2
	.word	.L84
	.byte	3,244,0,1,5,5,9
	.half	.L348-.L84
	.byte	1,5,1,9
	.half	.L3-.L348
	.byte	3,1,1,7,9
	.half	.L120-.L3
	.byte	0,1,1
.L345:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_Multi_GetResult')
	.sect	'.debug_ranges'
.L119:
	.word	-1,.L84,0,.L120-.L84,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_Multi_Cancel')
	.sect	'.debug_info'
.L121:
	.word	227
	.half	3
	.word	.L122
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L124,.L123
	.byte	2
	.word	.L97
	.byte	3
	.byte	'NvM_Prv_Multi_Cancel',0,1,120,6,1,1,1
	.word	.L86,.L163,.L85
	.byte	4
	.byte	'Cancel_pfct',0,1,120,54
	.word	.L164,.L165
	.byte	5
	.word	.L86,.L163
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_Multi_Cancel')
	.sect	'.debug_abbrev'
.L122:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_Multi_Cancel')
	.sect	'.debug_line'
.L123:
	.word	.L350-.L349
.L349:
	.half	3
	.word	.L352-.L351
.L351:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c',0,0,0,0,0
.L352:
	.byte	5,21,7,0,5,2
	.word	.L86
	.byte	3,250,0,1,5,9,9
	.half	.L353-.L86
	.byte	1,5,21,9
	.half	.L354-.L353
	.byte	1,5,5,9
	.half	.L355-.L354
	.byte	1,5,35,7,9
	.half	.L356-.L355
	.byte	3,2,1,5,1,9
	.half	.L4-.L356
	.byte	3,2,1,7,9
	.half	.L125-.L4
	.byte	0,1,1
.L350:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_Multi_Cancel')
	.sect	'.debug_ranges'
.L124:
	.word	-1,.L86,0,.L125-.L86,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_Multi_Process')
	.sect	'.debug_info'
.L126:
	.word	260
	.half	3
	.word	.L127
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L129,.L128
	.byte	2
	.word	.L97
	.byte	3
	.byte	'NvM_Prv_Multi_Process',0,1,129,1,19
	.word	.L166
	.byte	1,1,1
	.word	.L88,.L167,.L87
	.byte	4
	.byte	'QueueEntry_pst',0,1,129,1,65
	.word	.L168,.L169
	.byte	5
	.word	.L88,.L167
	.byte	6
	.byte	'idJob_en',0,1,131,1,23
	.word	.L166,.L170
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_Multi_Process')
	.sect	'.debug_abbrev'
.L127:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_Multi_Process')
	.sect	'.debug_line'
.L128:
	.word	.L358-.L357
.L357:
	.half	3
	.word	.L360-.L359
.L359:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c',0,0,0,0,0
.L360:
	.byte	5,19,7,0,5,2
	.word	.L88
	.byte	3,128,1,1,5,32,9
	.half	.L284-.L88
	.byte	3,2,1,5,21,9
	.half	.L285-.L284
	.byte	3,3,1,5,9,9
	.half	.L361-.L285
	.byte	1,5,21,9
	.half	.L362-.L361
	.byte	1,5,5,9
	.half	.L363-.L362
	.byte	1,5,53,7,9
	.half	.L364-.L363
	.byte	3,2,1,5,9,9
	.half	.L365-.L364
	.byte	1,5,41,7,9
	.half	.L366-.L365
	.byte	3,2,1,5,39,9
	.half	.L367-.L366
	.byte	1,5,64,9
	.half	.L368-.L367
	.byte	1,5,41,9
	.half	.L6-.L368
	.byte	3,4,1,5,39,9
	.half	.L369-.L6
	.byte	1,5,9,9
	.half	.L7-.L369
	.byte	3,4,1,5,35,9
	.half	.L370-.L7
	.byte	1,5,33,9
	.half	.L371-.L370
	.byte	1,5,9,9
	.half	.L5-.L371
	.byte	3,8,1,5,21,9
	.half	.L372-.L5
	.byte	1,5,5,9
	.half	.L373-.L372
	.byte	1,5,37,7,9
	.half	.L374-.L373
	.byte	3,2,1,5,35,9
	.half	.L375-.L374
	.byte	1,5,89,9
	.half	.L8-.L375
	.byte	3,4,1,5,20,9
	.half	.L10-.L8
	.byte	3,2,1,5,46,9
	.half	.L376-.L10
	.byte	1,5,13,9
	.half	.L9-.L376
	.byte	3,126,1,5,25,9
	.half	.L377-.L9
	.byte	1,5,12,9
	.half	.L378-.L377
	.byte	1,5,77,7,9
	.half	.L379-.L378
	.byte	1,5,5,7,9
	.half	.L11-.L379
	.byte	3,5,1,5,1,9
	.half	.L12-.L11
	.byte	3,1,1,7,9
	.half	.L130-.L12
	.byte	0,1,1
.L358:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_Multi_Process')
	.sect	'.debug_ranges'
.L129:
	.word	-1,.L88,0,.L130-.L88,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ProcessConfigId')
	.sect	'.debug_info'
.L131:
	.word	550
	.half	3
	.word	.L132
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L134,.L133
	.byte	2
	.word	.L97
	.byte	3
	.byte	'NvM_Prv_ProcessConfigId',0,2,1,178,1,32
	.word	.L166
	.byte	1,1
	.word	.L90,.L171,.L89
	.byte	4
	.byte	'QueueEntry_pst',0,1,178,1,80
	.word	.L168,.L172
	.byte	5
	.word	.L90,.L171
	.byte	6
	.byte	'idJob_en',0,1,180,1,23
	.word	.L166,.L173
	.byte	7
	.word	.L174,.L175,.L13
	.byte	8
	.word	.L176,.L177
	.byte	8
	.word	.L178,.L179
	.byte	9
	.word	.L180,.L175,.L13
	.byte	0,7
	.word	.L181,.L182,.L32
	.byte	8
	.word	.L183,.L184
	.byte	8
	.word	.L185,.L186
	.byte	8
	.word	.L187,.L188
	.byte	10
	.word	.L189,.L182,.L32
	.byte	6
	.byte	'idJob_en',0,1,191,3,23
	.word	.L166,.L190
	.byte	7
	.word	.L191,.L16,.L192
	.byte	8
	.word	.L193,.L194
	.byte	10
	.word	.L195,.L16,.L192
	.byte	6
	.byte	'BlockType',0,2,214,3,29
	.word	.L196,.L197
	.byte	0,0,7
	.word	.L198,.L192,.L199
	.byte	8
	.word	.L200,.L201
	.byte	9
	.word	.L202,.L192,.L199
	.byte	0,0,0,7
	.word	.L203,.L204,.L205
	.byte	8
	.word	.L206,.L207
	.byte	10
	.word	.L208,.L204,.L205
	.byte	6
	.byte	'PRamBlockAddress_pv',0,2,150,4,12
	.word	.L209,.L210
	.byte	0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ProcessConfigId')
	.sect	'.debug_abbrev'
.L132:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,32,13,58,15,59,15,57,15
	.byte	73,16,54,15,39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,7,29,1,49,16,17,1,18,1,0,0,8,5,0,49,16,2,6,0,0,9,11,0,49,16,17
	.byte	1,18,1,0,0,10,11,1,49,16,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ProcessConfigId')
	.sect	'.debug_line'
.L133:
	.word	.L381-.L380
.L380:
	.half	3
	.word	.L383-.L382
.L382:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockDescriptor.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockData.h',0,0,0,0,0
.L383:
	.byte	5,32,7,0,5,2
	.word	.L90
	.byte	3,177,1,1,9
	.half	.L287-.L90
	.byte	3,2,1,5,40,9
	.half	.L288-.L287
	.byte	3,2,1,5,85,9
	.half	.L384-.L288
	.byte	1,5,65,9
	.half	.L385-.L384
	.byte	1,5,68,9
	.half	.L386-.L385
	.byte	1,4,3,5,14,9
	.half	.L175-.L386
	.byte	3,117,1,5,44,9
	.half	.L387-.L175
	.byte	1,5,57,9
	.half	.L388-.L387
	.byte	1,5,76,9
	.half	.L389-.L388
	.byte	1,5,5,9
	.half	.L390-.L389
	.byte	1,4,1,9
	.half	.L13-.L390
	.byte	3,11,1,5,59,7,9
	.half	.L391-.L13
	.byte	3,2,1,5,45,9
	.half	.L392-.L391
	.byte	3,2,1,5,14,9
	.half	.L182-.L392
	.byte	3,136,2,1,9
	.half	.L393-.L182
	.byte	3,12,1,5,13,9
	.half	.L15-.L393
	.byte	3,118,1,5,26,9
	.half	.L394-.L15
	.byte	3,2,1,5,66,9
	.half	.L395-.L394
	.byte	1,5,26,9
	.half	.L18-.L395
	.byte	3,4,1,5,9,9
	.half	.L19-.L18
	.byte	3,3,1,4,2,5,39,9
	.half	.L16-.L19
	.byte	3,9,1,5,5,9
	.half	.L290-.L16
	.byte	3,1,1,5,21,7,9
	.half	.L396-.L290
	.byte	3,2,1,5,50,9
	.half	.L397-.L396
	.byte	1,5,62,9
	.half	.L398-.L397
	.byte	1,5,5,9
	.half	.L21-.L398
	.byte	3,2,1,4,1,5,17,9
	.half	.L22-.L21
	.byte	3,117,1,4,2,5,46,7,9
	.half	.L192-.L22
	.byte	3,179,127,1,5,13,9
	.half	.L399-.L192
	.byte	1,5,27,7,9
	.half	.L400-.L399
	.byte	3,1,1,5,56,9
	.half	.L401-.L400
	.byte	1,5,15,9
	.half	.L402-.L401
	.byte	1,5,68,9
	.half	.L403-.L402
	.byte	1,5,14,9
	.half	.L289-.L403
	.byte	1,5,15,7,9
	.half	.L404-.L289
	.byte	3,1,1,5,68,9
	.half	.L405-.L404
	.byte	1,5,24,9
	.half	.L406-.L405
	.byte	1,5,46,7,9
	.half	.L25-.L406
	.byte	3,126,1,5,5,9
	.half	.L24-.L25
	.byte	1,4,1,5,47,9
	.half	.L27-.L24
	.byte	3,206,0,1,5,26,7,9
	.half	.L199-.L27
	.byte	3,2,1,5,51,9
	.half	.L407-.L199
	.byte	1,5,26,9
	.half	.L23-.L407
	.byte	3,4,1,5,9,9
	.half	.L29-.L23
	.byte	3,3,1,5,41,9
	.half	.L17-.L29
	.byte	3,20,1,5,9,9
	.half	.L293-.L17
	.byte	3,1,1,5,5,9
	.half	.L20-.L293
	.byte	3,3,1,5,82,9
	.half	.L32-.L20
	.byte	3,201,125,1,4,2,5,32,9
	.half	.L204-.L32
	.byte	3,219,2,1,5,9,9
	.half	.L294-.L204
	.byte	3,1,1,5,51,7,9
	.half	.L408-.L294
	.byte	3,1,1,5,22,9
	.half	.L409-.L408
	.byte	1,5,51,9
	.half	.L410-.L409
	.byte	1,5,63,9
	.half	.L411-.L410
	.byte	1,5,10,9
	.half	.L412-.L411
	.byte	1,5,19,9
	.half	.L413-.L412
	.byte	1,5,31,7,9
	.half	.L414-.L413
	.byte	3,2,1,5,5,9
	.half	.L33-.L414
	.byte	3,3,1,4,1,5,38,9
	.half	.L35-.L33
	.byte	3,158,125,1,5,68,9
	.half	.L205-.L35
	.byte	3,127,1,5,9,9
	.half	.L14-.L205
	.byte	3,5,1,5,37,9
	.half	.L415-.L14
	.byte	1,5,35,9
	.half	.L416-.L415
	.byte	1,5,5,9
	.half	.L36-.L416
	.byte	3,3,1,5,1,9
	.half	.L37-.L36
	.byte	3,1,1,7,9
	.half	.L135-.L37
	.byte	0,1,1
.L381:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ProcessConfigId')
	.sect	'.debug_ranges'
.L134:
	.word	-1,.L90,0,.L135-.L90,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ProcessUserBlocks')
	.sect	'.debug_info'
.L136:
	.word	636
	.half	3
	.word	.L137
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L139,.L138
	.byte	2
	.word	.L97
	.byte	3
	.byte	'NvM_Prv_ProcessUserBlocks',0,2,1,198,1,32
	.word	.L166
	.byte	1,1
	.word	.L92,.L211,.L91
	.byte	4
	.byte	'QueueEntry_pst',0,1,198,1,82
	.word	.L168,.L212
	.byte	5
	.word	.L92,.L211
	.byte	6
	.byte	'idJob_en',0,1,200,1,23
	.word	.L166,.L213
	.byte	7
	.word	.L214,.L215,.L42
	.byte	8
	.word	.L216,.L217
	.byte	8
	.word	.L218,.L219
	.byte	8
	.word	.L220,.L221
	.byte	9
	.word	.L222,.L215,.L42
	.byte	6
	.byte	'RequestMask_u16',0,1,164,3,12
	.word	.L223,.L224
	.byte	7
	.word	.L174,.L225,.L41
	.byte	8
	.word	.L176,.L226
	.byte	8
	.word	.L178,.L227
	.byte	10
	.word	.L180,.L225,.L41
	.byte	0,0,0,7
	.word	.L181,.L228,.L61
	.byte	8
	.word	.L183,.L229
	.byte	8
	.word	.L185,.L230
	.byte	8
	.word	.L187,.L231
	.byte	9
	.word	.L189,.L228,.L61
	.byte	6
	.byte	'idJob_en',0,1,191,3,23
	.word	.L166,.L232
	.byte	7
	.word	.L191,.L45,.L233
	.byte	8
	.word	.L193,.L234
	.byte	9
	.word	.L195,.L45,.L233
	.byte	6
	.byte	'BlockType',0,2,214,3,29
	.word	.L196,.L235
	.byte	0,0,7
	.word	.L198,.L233,.L236
	.byte	8
	.word	.L200,.L237
	.byte	10
	.word	.L202,.L233,.L236
	.byte	0,0,0,7
	.word	.L203,.L238,.L239
	.byte	8
	.word	.L206,.L240
	.byte	9
	.word	.L208,.L238,.L239
	.byte	6
	.byte	'PRamBlockAddress_pv',0,2,150,4,12
	.word	.L209,.L241
	.byte	0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ProcessUserBlocks')
	.sect	'.debug_abbrev'
.L137:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,32,13,58,15,59,15,57,15
	.byte	73,16,54,15,39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,7,29,1,49,16,17,1,18,1,0,0,8,5,0,49,16,2,6,0,0,9,11,1,49,16,17
	.byte	1,18,1,0,0,10,11,0,49,16,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ProcessUserBlocks')
	.sect	'.debug_line'
.L138:
	.word	.L418-.L417
.L417:
	.half	3
	.word	.L420-.L419
.L419:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockDescriptor.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockData.h',0,0,0,0,0
.L420:
	.byte	5,32,7,0,5,2
	.word	.L92
	.byte	3,197,1,1,9
	.half	.L295-.L92
	.byte	3,2,1,5,70,9
	.half	.L296-.L295
	.byte	3,2,1,9
	.half	.L421-.L296
	.byte	3,1,1,9
	.half	.L422-.L421
	.byte	3,1,1,5,28,9
	.half	.L215-.L422
	.byte	3,227,1,1,5,31,9
	.half	.L423-.L215
	.byte	1,5,72,9
	.half	.L297-.L423
	.byte	3,4,1,5,9,9
	.half	.L39-.L297
	.byte	3,2,1,5,12,9
	.half	.L38-.L39
	.byte	3,125,1,4,3,5,14,7,9
	.half	.L225-.L38
	.byte	3,249,125,1,5,44,9
	.half	.L424-.L225
	.byte	1,5,57,9
	.half	.L425-.L424
	.byte	1,5,76,9
	.half	.L426-.L425
	.byte	1,5,5,9
	.half	.L427-.L426
	.byte	1,4,1,5,13,9
	.half	.L41-.L427
	.byte	3,136,2,1,5,5,7,9
	.half	.L40-.L41
	.byte	3,4,1,5,32,9
	.half	.L42-.L40
	.byte	3,147,126,1,5,5,9
	.half	.L428-.L42
	.byte	3,4,1,5,14,7,9
	.half	.L228-.L428
	.byte	3,244,1,1,9
	.half	.L429-.L228
	.byte	3,12,1,5,13,9
	.half	.L44-.L429
	.byte	3,118,1,5,26,9
	.half	.L430-.L44
	.byte	3,2,1,5,66,9
	.half	.L431-.L430
	.byte	1,5,26,9
	.half	.L47-.L431
	.byte	3,4,1,5,9,9
	.half	.L48-.L47
	.byte	3,3,1,4,2,5,39,9
	.half	.L45-.L48
	.byte	3,9,1,5,5,9
	.half	.L300-.L45
	.byte	3,1,1,5,50,7,9
	.half	.L432-.L300
	.byte	3,2,1,5,21,9
	.half	.L301-.L432
	.byte	1,5,50,9
	.half	.L433-.L301
	.byte	1,5,62,9
	.half	.L434-.L433
	.byte	1,5,5,9
	.half	.L50-.L434
	.byte	3,2,1,4,1,5,17,9
	.half	.L51-.L50
	.byte	3,117,1,4,2,5,46,7,9
	.half	.L233-.L51
	.byte	3,179,127,1,5,13,9
	.half	.L435-.L233
	.byte	1,5,56,7,9
	.half	.L436-.L435
	.byte	3,1,1,5,27,9
	.half	.L302-.L436
	.byte	1,5,56,9
	.half	.L437-.L302
	.byte	1,5,15,9
	.half	.L438-.L437
	.byte	1,5,68,9
	.half	.L439-.L438
	.byte	1,5,14,9
	.half	.L298-.L439
	.byte	1,5,15,7,9
	.half	.L440-.L298
	.byte	3,1,1,5,68,9
	.half	.L441-.L440
	.byte	1,5,24,9
	.half	.L442-.L441
	.byte	1,5,46,7,9
	.half	.L54-.L442
	.byte	3,126,1,5,5,9
	.half	.L53-.L54
	.byte	1,4,1,5,47,9
	.half	.L56-.L53
	.byte	3,206,0,1,5,26,7,9
	.half	.L236-.L56
	.byte	3,2,1,5,51,9
	.half	.L443-.L236
	.byte	1,5,26,9
	.half	.L52-.L443
	.byte	3,4,1,5,9,9
	.half	.L58-.L52
	.byte	3,3,1,5,41,9
	.half	.L46-.L58
	.byte	3,20,1,5,9,9
	.half	.L299-.L46
	.byte	3,1,1,5,5,9
	.half	.L49-.L299
	.byte	3,3,1,5,82,9
	.half	.L61-.L49
	.byte	3,225,125,1,4,2,5,32,9
	.half	.L238-.L61
	.byte	3,195,2,1,5,9,9
	.half	.L303-.L238
	.byte	3,1,1,5,51,7,9
	.half	.L444-.L303
	.byte	3,1,1,5,22,9
	.half	.L445-.L444
	.byte	1,5,51,9
	.half	.L446-.L445
	.byte	1,5,63,9
	.half	.L447-.L446
	.byte	1,5,10,9
	.half	.L448-.L447
	.byte	1,5,19,9
	.half	.L449-.L448
	.byte	1,5,31,7,9
	.half	.L450-.L449
	.byte	3,2,1,5,5,9
	.half	.L62-.L450
	.byte	3,3,1,4,1,5,38,9
	.half	.L64-.L62
	.byte	3,182,125,1,5,72,9
	.half	.L239-.L64
	.byte	3,127,1,5,9,9
	.half	.L43-.L239
	.byte	3,8,1,5,37,9
	.half	.L451-.L43
	.byte	1,5,35,9
	.half	.L452-.L451
	.byte	1,5,5,9
	.half	.L65-.L452
	.byte	3,4,1,5,1,9
	.half	.L66-.L65
	.byte	3,1,1,7,9
	.half	.L140-.L66
	.byte	0,1,1
.L418:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ProcessUserBlocks')
	.sect	'.debug_ranges'
.L139:
	.word	-1,.L92,0,.L140-.L92,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ProcessCancel')
	.sect	'.debug_info'
.L141:
	.word	260
	.half	3
	.word	.L142
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L144,.L143
	.byte	2
	.word	.L97
	.byte	3
	.byte	'NvM_Prv_ProcessCancel',0,2,1,226,1,32
	.word	.L166
	.byte	1,1
	.word	.L94,.L242,.L93
	.byte	4
	.byte	'QueueEntry_pst',0,1,226,1,78
	.word	.L168,.L243
	.byte	5
	.word	.L94,.L242
	.byte	6
	.byte	'idJob_en',0,1,228,1,23
	.word	.L166,.L244
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ProcessCancel')
	.sect	'.debug_abbrev'
.L142:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,32,13,58,15,59,15,57,15
	.byte	73,16,54,15,39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_ProcessCancel')
	.sect	'.debug_line'
.L143:
	.word	.L454-.L453
.L453:
	.half	3
	.word	.L456-.L455
.L455:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c',0,0,0,0,0
.L456:
	.byte	5,32,7,0,5,2
	.word	.L94
	.byte	3,225,1,1,9
	.half	.L305-.L94
	.byte	3,2,1,5,9,9
	.half	.L307-.L305
	.byte	3,9,1,5,34,9
	.half	.L457-.L307
	.byte	1,5,5,9
	.half	.L304-.L457
	.byte	1,5,9,7,9
	.half	.L458-.L304
	.byte	3,2,1,5,35,9
	.half	.L459-.L458
	.byte	1,5,33,9
	.half	.L460-.L459
	.byte	1,5,34,9
	.half	.L67-.L460
	.byte	3,3,1,5,32,9
	.half	.L461-.L67
	.byte	1,5,33,9
	.half	.L462-.L461
	.byte	3,1,1,5,31,9
	.half	.L306-.L462
	.byte	1,5,5,9
	.half	.L463-.L306
	.byte	3,1,1,5,33,9
	.half	.L464-.L463
	.byte	1,5,31,9
	.half	.L465-.L464
	.byte	1,5,5,9
	.half	.L466-.L465
	.byte	3,2,1,5,1,9
	.half	.L68-.L466
	.byte	3,1,1,7,9
	.half	.L145-.L68
	.byte	0,1,1
.L454:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_ProcessCancel')
	.sect	'.debug_ranges'
.L144:
	.word	-1,.L94,0,.L145-.L94,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_FinishMulti')
	.sect	'.debug_info'
.L146:
	.word	615
	.half	3
	.word	.L147
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L149,.L148
	.byte	2
	.word	.L97
	.byte	3
	.byte	'NvM_Prv_FinishMulti',0,2,1,148,2,32
	.word	.L166
	.byte	1,1
	.word	.L96,.L245,.L95
	.byte	4
	.byte	'QueueEntry_pst',0,1,148,2,76
	.word	.L168,.L246
	.byte	5
	.word	.L96,.L245
	.byte	6
	.byte	'ServiceBitMask_uo',0,1,150,2,12
	.word	.L223,.L247
	.byte	6
	.byte	'idJob_en',0,1,151,2,23
	.word	.L166,.L248
	.byte	7
	.word	.L249,.L250,.L251
	.byte	8
	.word	.L252,.L253
	.byte	8
	.word	.L254,.L255
	.byte	9
	.word	.L256,.L250,.L251
	.byte	0,7
	.word	.L257,.L258,.L72
	.byte	8
	.word	.L259,.L260
	.byte	10
	.word	.L261,.L258,.L72
	.byte	7
	.word	.L262,.L258,.L71
	.byte	8
	.word	.L263,.L264
	.byte	10
	.word	.L265,.L258,.L71
	.byte	6
	.byte	'isFinalCallbackRequired_b',0,1,233,2,13
	.word	.L158,.L266
	.byte	0,0,10
	.word	.L267,.L268,.L72
	.byte	6
	.byte	'idActiveService_uo',0,1,202,2,15
	.word	.L158,.L269
	.byte	7
	.word	.L270,.L271,.L272
	.byte	8
	.word	.L273,.L274
	.byte	8
	.word	.L275,.L276
	.byte	9
	.word	.L277,.L271,.L272
	.byte	0,0,0,0,7
	.word	.L278,.L72,.L73
	.byte	8
	.word	.L279,.L280
	.byte	10
	.word	.L281,.L72,.L73
	.byte	6
	.byte	'isSecondaryMultiReqStarted',0,1,135,3,13
	.word	.L158,.L282
	.byte	0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_FinishMulti')
	.sect	'.debug_abbrev'
.L147:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,32,13,58,15,59,15,57,15
	.byte	73,16,54,15,39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,7,29,1,49,16,17,1,18,1,0,0,8,5,0,49,16,2,6,0,0,9,11,0,49,16,17
	.byte	1,18,1,0,0,10,11,1,49,16,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_FinishMulti')
	.sect	'.debug_line'
.L148:
	.word	.L468-.L467
.L467:
	.half	3
	.word	.L470-.L469
.L469:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockData.h',0,0,0,0,0
.L470:
	.byte	5,32,7,0,5,2
	.word	.L96
	.byte	3,150,2,1,5,64,9
	.half	.L309-.L96
	.byte	3,2,1,5,9,9
	.half	.L471-.L309
	.byte	1,5,5,9
	.half	.L472-.L471
	.byte	1,5,27,7,9
	.half	.L473-.L472
	.byte	3,2,1,5,76,9
	.half	.L310-.L473
	.byte	3,1,1,5,30,9
	.half	.L69-.L310
	.byte	3,4,1,5,50,9
	.half	.L474-.L69
	.byte	1,5,33,9
	.half	.L475-.L474
	.byte	1,9
	.half	.L70-.L475
	.byte	3,3,1,4,2,5,5,9
	.half	.L250-.L70
	.byte	3,172,127,1,5,35,9
	.half	.L476-.L250
	.byte	1,5,52,9
	.half	.L477-.L476
	.byte	1,5,48,9
	.half	.L311-.L477
	.byte	1,4,1,5,42,9
	.half	.L251-.L311
	.byte	3,214,0,1,5,5,9
	.half	.L258-.L251
	.byte	3,220,0,1,9
	.half	.L71-.L258
	.byte	3,70,1,5,61,7,9
	.half	.L268-.L71
	.byte	3,13,1,4,2,5,5,9
	.half	.L271-.L268
	.byte	3,236,126,1,5,38,9
	.half	.L478-.L271
	.byte	1,5,51,9
	.half	.L479-.L478
	.byte	1,4,1,5,53,9
	.half	.L272-.L479
	.byte	3,156,1,1,5,5,9
	.half	.L72-.L272
	.byte	3,192,0,1,5,9,9
	.half	.L73-.L72
	.byte	3,141,127,1,5,5,9
	.half	.L480-.L73
	.byte	3,126,1,5,37,7,9
	.half	.L481-.L480
	.byte	3,2,1,5,35,9
	.half	.L482-.L481
	.byte	1,5,62,9
	.half	.L483-.L482
	.byte	1,5,37,9
	.half	.L74-.L483
	.byte	3,5,1,5,35,9
	.half	.L484-.L74
	.byte	1,5,9,9
	.half	.L485-.L484
	.byte	3,1,1,5,42,9
	.half	.L486-.L485
	.byte	1,5,40,9
	.half	.L487-.L486
	.byte	1,5,38,9
	.half	.L488-.L487
	.byte	3,3,1,5,5,9
	.half	.L75-.L488
	.byte	3,4,1,5,1,9
	.half	.L76-.L75
	.byte	3,1,1,7,9
	.half	.L150-.L76
	.byte	0,1,1
.L468:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_FinishMulti')
	.sect	'.debug_ranges'
.L149:
	.word	-1,.L96,0,.L150-.L96,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_ProcessMulti_pfct')
	.sect	'.debug_info'
.L151:
	.word	185
	.half	3
	.word	.L152
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1,2
	.word	.L97
	.byte	3
	.byte	'NvM_Prv_ProcessMulti_pfct',0,4,49,35
	.word	.L283
	.byte	5,3
	.word	NvM_Prv_ProcessMulti_pfct
	.byte	0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_ProcessMulti_pfct')
	.sect	'.debug_abbrev'
.L152:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,0,0,2,61,0,24,16,0,0,3,52,0,3,8,58,15,59,15,57,15,73,16,2,9,0,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_Multi_Cancel_pfct')
	.sect	'.debug_info'
.L153:
	.word	185
	.half	3
	.word	.L154
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1,2
	.word	.L97
	.byte	3
	.byte	'NvM_Prv_Multi_Cancel_pfct',0,4,50,35
	.word	.L164
	.byte	5,3
	.word	NvM_Prv_Multi_Cancel_pfct
	.byte	0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_Multi_Cancel_pfct')
	.sect	'.debug_abbrev'
.L154:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,0,0,2,61,0,24,16,0,0,3,52,0,3,8,58,15,59,15,57,15,73,16,2,9,0,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_Multi_Result_uo')
	.sect	'.debug_info'
.L155:
	.word	183
	.half	3
	.word	.L156
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ProcessMultiBlock.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1,2
	.word	.L97
	.byte	3
	.byte	'NvM_Prv_Multi_Result_uo',0,4,52,30
	.word	.L158
	.byte	5,3
	.word	NvM_Prv_Multi_Result_uo
	.byte	0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_Multi_Result_uo')
	.sect	'.debug_abbrev'
.L156:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,0,0,2,61,0,24,16,0,0,3,52,0,3,8,58,15,59,15,57,15,73,16,2,9,0,0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_FinishMulti')
	.sect	'.debug_loc'
.L95:
	.word	-1,.L96,0,.L245-.L96
	.half	2
	.byte	138,0
	.word	0,0
.L246:
	.word	-1,.L96,0,.L72-.L96
	.half	1
	.byte	100
	.word	0,0
.L280:
	.word	0,0
.L276:
	.word	0,0
.L247:
	.word	-1,.L96,.L310-.L96,.L69-.L96
	.half	5
	.byte	144,32,157,32,0
	.word	.L70-.L96,.L311-.L96
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L269:
	.word	0,0
.L274:
	.word	0,0
.L253:
	.word	0,0
.L248:
	.word	-1,.L96,.L309-.L96,.L245-.L96
	.half	1
	.byte	88
	.word	.L312-.L96,.L245-.L96
	.half	1
	.byte	82
	.word	0,0
.L260:
	.word	0,0
.L264:
	.word	0,0
.L266:
	.word	0,0
.L282:
	.word	0,0
.L255:
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_Multi_Cancel')
	.sect	'.debug_loc'
.L165:
	.word	-1,.L86,0,.L163-.L86
	.half	1
	.byte	100
	.word	0,0
.L85:
	.word	-1,.L86,0,.L163-.L86
	.half	2
	.byte	138,0
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_Multi_GetResult')
	.sect	'.debug_loc'
.L83:
	.word	-1,.L84,0,.L162-.L84
	.half	2
	.byte	138,0
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_Multi_Initialize')
	.sect	'.debug_loc'
.L77:
	.word	-1,.L78,0,.L157-.L78
	.half	2
	.byte	138,0
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_Multi_IsInProgress')
	.sect	'.debug_loc'
.L79:
	.word	-1,.L80,0,.L159-.L80
	.half	2
	.byte	138,0
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_Multi_Process')
	.sect	'.debug_loc'
.L87:
	.word	-1,.L88,0,.L167-.L88
	.half	2
	.byte	138,0
	.word	0,0
.L169:
	.word	-1,.L88,0,.L10-.L88
	.half	1
	.byte	100
	.word	.L284-.L88,.L167-.L88
	.half	1
	.byte	108
	.word	.L286-.L88,.L9-.L88
	.half	1
	.byte	100
	.word	0,0
.L170:
	.word	-1,.L88,.L285-.L88,.L167-.L88
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_Multi_SetResult')
	.sect	'.debug_loc'
.L81:
	.word	-1,.L82,0,.L160-.L82
	.half	2
	.byte	138,0
	.word	0,0
.L161:
	.word	-1,.L82,0,.L160-.L82
	.half	1
	.byte	84
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ProcessCancel')
	.sect	'.debug_loc'
.L93:
	.word	-1,.L94,0,.L242-.L94
	.half	2
	.byte	138,0
	.word	0,0
.L243:
	.word	-1,.L94,0,.L304-.L94
	.half	1
	.byte	100
	.word	.L305-.L94,.L306-.L94
	.half	1
	.byte	111
	.word	0,0
.L244:
	.word	-1,.L94,.L307-.L94,.L242-.L94
	.half	1
	.byte	88
	.word	.L308-.L94,.L242-.L94
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ProcessConfigId')
	.sect	'.debug_loc'
.L197:
	.word	-1,.L90,.L290-.L90,.L291-.L90
	.half	1
	.byte	95
	.word	.L21-.L90,.L292-.L90
	.half	1
	.byte	95
	.word	0,0
.L89:
	.word	-1,.L90,0,.L171-.L90
	.half	2
	.byte	138,0
	.word	0,0
.L210:
	.word	-1,.L90,.L294-.L90,.L14-.L90
	.half	1
	.byte	98
	.word	0,0
.L172:
	.word	-1,.L90,0,.L18-.L90
	.half	1
	.byte	100
	.word	.L287-.L90,.L18-.L90
	.half	1
	.byte	108
	.word	.L19-.L90,.L171-.L90
	.half	1
	.byte	108
	.word	.L19-.L90,.L289-.L90
	.half	1
	.byte	100
	.word	.L17-.L90,.L293-.L90
	.half	1
	.byte	100
	.word	.L14-.L90,.L36-.L90
	.half	1
	.byte	100
	.word	0,0
.L186:
	.word	0,0
.L177:
	.word	0,0
.L201:
	.word	0,0
.L188:
	.word	0,0
.L194:
	.word	0,0
.L207:
	.word	0,0
.L173:
	.word	-1,.L90,.L288-.L90,.L18-.L90
	.half	1
	.byte	82
	.word	.L19-.L90,.L171-.L90
	.half	1
	.byte	82
	.word	0,0
.L190:
	.word	-1,.L90,.L288-.L90,.L18-.L90
	.half	1
	.byte	82
	.word	.L19-.L90,.L171-.L90
	.half	1
	.byte	82
	.word	0,0
.L184:
	.word	0,0
.L179:
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_ProcessUserBlocks')
	.sect	'.debug_loc'
.L235:
	.word	-1,.L92,.L300-.L92,.L301-.L92
	.half	1
	.byte	95
	.word	.L50-.L92,.L302-.L92
	.half	1
	.byte	95
	.word	0,0
.L91:
	.word	-1,.L92,0,.L211-.L92
	.half	2
	.byte	138,0
	.word	0,0
.L241:
	.word	-1,.L92,.L303-.L92,.L43-.L92
	.half	1
	.byte	98
	.word	0,0
.L212:
	.word	-1,.L92,0,.L47-.L92
	.half	1
	.byte	100
	.word	.L295-.L92,.L47-.L92
	.half	1
	.byte	108
	.word	.L48-.L92,.L298-.L92
	.half	1
	.byte	100
	.word	.L48-.L92,.L211-.L92
	.half	1
	.byte	108
	.word	.L46-.L92,.L299-.L92
	.half	1
	.byte	100
	.word	.L43-.L92,.L65-.L92
	.half	1
	.byte	100
	.word	0,0
.L224:
	.word	-1,.L92,.L297-.L92,.L47-.L92
	.half	1
	.byte	83
	.word	.L48-.L92,.L299-.L92
	.half	1
	.byte	83
	.word	.L43-.L92,.L65-.L92
	.half	1
	.byte	83
	.word	0,0
.L221:
	.word	0,0
.L230:
	.word	0,0
.L226:
	.word	0,0
.L237:
	.word	0,0
.L217:
	.word	0,0
.L231:
	.word	0,0
.L234:
	.word	0,0
.L240:
	.word	0,0
.L213:
	.word	-1,.L92,.L296-.L92,.L47-.L92
	.half	1
	.byte	82
	.word	.L48-.L92,.L211-.L92
	.half	1
	.byte	82
	.word	0,0
.L232:
	.word	-1,.L92,.L296-.L92,.L47-.L92
	.half	1
	.byte	82
	.word	.L48-.L92,.L211-.L92
	.half	1
	.byte	82
	.word	0,0
.L219:
	.word	0,0
.L229:
	.word	0,0
.L227:
	.word	0,0
	.sdecl	'.debug_frame',debug
	.sect	'.debug_frame'
.L489:
	.word	48
	.word	-1
	.byte	3,0,2,1,27,12,26,0,8,27,8,26,8,28,8,29,8,30,8,31,8,34,8,35,8,32,8,33,8,16,8,17,8,24,8,25,8,36,8,37,8,38
	.byte	8,39
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_Multi_Initialize')
	.sect	'.debug_frame'
	.word	24
	.word	.L489,.L78,.L157-.L78
	.byte	8,19,8,20,8,21,8,22,8,23,0,0
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_Multi_IsInProgress')
	.sect	'.debug_frame'
	.word	24
	.word	.L489,.L80,.L159-.L80
	.byte	8,19,8,20,8,21,8,22,8,23,0,0
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_Multi_SetResult')
	.sect	'.debug_frame'
	.word	24
	.word	.L489,.L82,.L160-.L82
	.byte	8,18,8,19,8,20,8,21,8,22,8,23
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_Multi_GetResult')
	.sect	'.debug_frame'
	.word	24
	.word	.L489,.L84,.L162-.L84
	.byte	8,18,8,19,8,20,8,21,8,22,8,23
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_Multi_Cancel')
	.sect	'.debug_frame'
	.word	20
	.word	.L489,.L86,.L163-.L86
	.byte	8,19,8,22,8,23,0,0
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_Multi_Process')
	.sect	'.debug_frame'
	.word	12
	.word	.L489,.L88,.L167-.L88
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ProcessConfigId')
	.sect	'.debug_frame'
	.word	12
	.word	.L489,.L90,.L171-.L90
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ProcessUserBlocks')
	.sect	'.debug_frame'
	.word	12
	.word	.L489,.L92,.L211-.L92
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_ProcessCancel')
	.sect	'.debug_frame'
	.word	12
	.word	.L489,.L94,.L242-.L94
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_FinishMulti')
	.sect	'.debug_frame'
	.word	12
	.word	.L489,.L96,.L245-.L96

; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   495          break;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   496      }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   497  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   498      return idJob_en;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   499  }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   500  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   501  // ====================================================================================================================
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   502  #if (NVM_RB_REMOVE_NON_RESISTANT_BLOCKS || NVM_RB_INIT_AT_LAYOUT_CHANGE)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   503  LOCAL_INLINE boolean NvM_Prv_InitiateInitAfterReadAll(NvM_Prv_QueueEntry_tst* QueueEntry_pst)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   504  {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   505      boolean isInitAfterReadAllStarted = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   506      uint16 maskService_u16 = (1u << NvM_Prv_ServiceBit_RemoveNonResistant_e) |
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   507                               (1u << NvM_Prv_ServiceBit_InitAtLayoutChange_e);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   508      // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2787] If at least one block has been found during the current
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   509      //   multiblock operation (this search is only done during ReadAll) which is not resistant to changed SW
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   510      //   and a SW change has been detected, then start the multiblock removal sequence here
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   511      // Initialization and removal are done in the same phase after ReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   512      if (NvM_Prv_Block_IsRequestPending(NVM_PRV_MULTI_BLOCK, maskService_u16))
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   513      {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   514          // Multiblock removal request pending
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   515          // Concurrency note: NvM_Prv_Main_st.QueueEntryMulti_st is still set so
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   516          //                   NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_MULTI_BLOCK] cannot be written concurrently
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   517          //                   by a multiblock API
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   518          //                -> no locking necessary here
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   519          NvM_Prv_Block_SetRequestResult(NVM_PRV_MULTI_BLOCK, NVM_REQ_PENDING);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   520          NvM_Prv_Multi_Result_uo = NVM_REQ_OK;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   521  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   522          QueueEntry_pst->idService_uo = NVM_SERVICE_ID_RB_INIT_AFTER_READ_ALL;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   523          // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2787] Start initialization/removal with block 2
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   524          QueueEntry_pst->idBlock_uo = NVM_RB_FIRST_USER_BLOCK;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   525          // BitServiceAck_uo will be set later
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   526          QueueEntry_pst->BlockData_pv = NULL_PTR;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   527  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   528          // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2804]
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   529          // If BswMMultiBlockJobStatusInformation is enabled, notify BswM
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   530          // about the state change of the multiblock operation
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   531  # if (NVM_BSWM_MULTI_BLOCK_JOB_STATUS_INFORMATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   532          BswM_NvM_CurrentJobMode(NVM_SERVICE_ID_RB_INIT_AFTER_READ_ALL, NVM_REQ_PENDING);
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   533  # endif
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   534  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   535          isInitAfterReadAllStarted = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   536      }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   537  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   538      return isInitAfterReadAllStarted;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   539  }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   540  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   541  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   542  // ====================================================================================================================
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   543  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   544  LOCAL_INLINE boolean NvM_Prv_InitiateMaintenance(NvM_Prv_QueueEntry_tst* QueueEntry_pst)
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   545  {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   546      boolean isMaintenanceStarted = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   547      // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2858] Start the maintenance operation
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   548      //     for all redundant blocks after that the writing of the blocks in WriteAll finished
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   549      if (NvM_Prv_Block_IsRequestPending(NVM_PRV_MULTI_BLOCK, (1u << NvM_Prv_ServiceBit_Maintain_e)))
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   550      {
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   551          // Multiblock maintenance request pending
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   552          // The request result of block #0 is already set to PENDING when the maintenance operations starts
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   553          // NvM_Prv_Multi_Result_uo is not used for the maintenance operation
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   554          QueueEntry_pst->idService_uo = NVM_PRV_SERVICE_ID_MAINTAIN_BLOCK;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   555          // Start the maintenance with block #1/#2 if dynamic config is enabled/disabled
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   556          QueueEntry_pst->idBlock_uo = NVM_CFG_FIRST_USED_BLOCK;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   557          QueueEntry_pst->ServiceBit_uo = NvM_Prv_ServiceBit_Maintain_e;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   558          QueueEntry_pst->BlockData_pv = NULL_PTR;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   559  
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   560          isMaintenanceStarted = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   561      }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   562      return isMaintenanceStarted;
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   563  }
; BSW\src\BSW\Gen\NvM\src\NvM_ProcessMultiBlock.c	   564  #endif

	; Module end
