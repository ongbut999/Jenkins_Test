	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 19053136 SN 09001910"
	.compiler_invocation	"ctc -f cc16636a -c99 --integer-enumeration -D__CPU__=tc27x -D__CPU_TC27X__ --core=tc1.6.x --eabi-compliant --fp-model=-float -D_TASKING_C_TRICORE_=1 -I.\\output\\inc -g2 -t4 --language=-comments,-gcc,+volatile,-strings --default-near-size=0 -O2ROPYGKLF-predict --default-a1-size=0 --default-a0-size=0 --source --switch=auto -o output\\objs\\BSW\\src\\BSW\\Gen\\NvM\\NvM_ReadAll.src BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ReadAll.c"
	.compiler_name		"ctc"
	;source	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ReadAll.c'

	
$TC16X
	
	.sdecl	'.text.NvM_ReadAll.NvM_ReadAll',code,cluster('NvM_ReadAll')
	.sect	'.text.NvM_ReadAll.NvM_ReadAll'
	.align	2
	
	.global	NvM_ReadAll

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	     2  /*
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	     3   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	     4   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	     5   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	     6  */
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	     7  #include "NvM.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	     8  #include "NvM_Cfg_SchM.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	     9  #include "Rte_NvM.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    10  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    11  #if (NVM_BSWM_MULTI_BLOCK_JOB_STATUS_INFORMATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    12  # include "BswM_NvM.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    13  // TRACE[NVM089] Check version compatibility of included header files
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    14  # if (!defined(BSWM_AR_RELEASE_MAJOR_VERSION) || (BSWM_AR_RELEASE_MAJOR_VERSION != NVM_AR_RELEASE_MAJOR_VERSION))
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    15  #  error "AUTOSAR major version undefined or mismatched"
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    16  # endif
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    17  # if (!defined(BSWM_AR_RELEASE_MINOR_VERSION) || ((BSWM_AR_RELEASE_MINOR_VERSION != 0) && \ 
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    18                                                    (BSWM_AR_RELEASE_MINOR_VERSION != 2)))
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    19  #  error "AUTOSAR minor version undefined or mismatched"
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    20  # endif
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    21  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    22  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    23  #include "NvM_Prv.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    24  #include "NvM_Prv_Queue.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    25  #include "NvM_Prv_BlockData.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    26  #include "NvM_Prv_ErrorDetection.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    27  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    28  /*
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    29   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    30   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    31   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    32   */
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    33  #if ((NVM_DYNAMIC_CONFIGURATION == STD_ON) && (NVM_RB_REMOVE_NON_RESISTANT_BLOCKS == STD_ON))
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    34  #define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    35  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    36  //TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2999] the potentially incompatible blocks after layout changes should be
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    37  //                                              sanitized by ReadAll at first
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    38  static boolean NvM_Prv_isReadAllInitiated_b;
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    39  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    40  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    41  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    42  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    43  /*
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    44   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    45   * Inline declarations
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    46   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    47   */
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    48  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    49  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    50  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    51  static boolean NvM_Prv_IsBlockPartOfReadAll(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    52  static void NvM_Prv_FindBlocksForReadAll(void);
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    53  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    54  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    56  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    57  /*
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    58   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    59   * Code
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    60   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    61  */
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    62  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    63  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    64  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    65  #ifdef NVM_CFG_API_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    66  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    67  // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2917] Declaration of the overloading function shall be done here,
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    68  //                                               not in a header file
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    69  /* MR12 RULE 8.5 VIOLATION: Not using a header file for this declaration is a customer requirement */
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    70  extern void NVM_CFG_API_READ_ALL(void);
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    72  void NvM_ReadAll(void)
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    73  {
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    74      // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2920] Call the overloading function
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    75      NVM_CFG_API_READ_ALL();
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    76  }
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    77  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    78  void NvM_Rb_ReadAllBase(void)
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    79  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    80  #else
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    81  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    82  void NvM_ReadAll(void)
; Function NvM_ReadAll
.L24:
NvM_ReadAll:	.type	func
	sub.a	a10,#16
.L116:

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    83  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    84  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    85  {
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    86      // TRACE[NVM460] Initiates a multi block read request
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    87      // TRACE[NVM356] This service reads the contents of all applicable permanent RAM blocks from their NV counterparts
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    88  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    89      // TRACE[NVM646] Report the DET error NVM_E_NOT_INITIALIZED when the NVM is not yet initialized
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    90      if (NvM_Prv_ErrorDetection_IsNvmInitialized(NVM_SERVICE_ID_READ_ALL, NVM_PRV_MULTI_BLOCK))
	mov	d4,#12
.L135:
	mov	d5,#0
	call	NvM_Prv_ErrorDetection_IsNvmInitialized
.L136:
	jeq	d2,#0,.L2
.L56:

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    91      {
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    92          boolean isRequestEnqueued_b;
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    93          // put all service parameters in a structure for a queue entry
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    94          NvM_Prv_QueueEntry_tst QueueEntry_st;
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    95          QueueEntry_st.idService_uo = NVM_SERVICE_ID_READ_ALL;
	mov	d15,#12
.L137:
	st.b	[a10],d15
.L138:

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    96          QueueEntry_st.idBlock_uo = NVM_CFG_FIRST_USED_BLOCK;
	mov	d15,#2
.L139:
	st.h	[a10]2,d15
.L140:

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    97          QueueEntry_st.ServiceBit_uo = NvM_Prv_ServiceBit_ReadAll_e;
	mov	d15,#0
.L141:
	st.h	[a10]4,d15
.L142:

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    98          QueueEntry_st.BlockData_pv = NULL_PTR;
	mov.a	a15,#0
.L143:
	st.a	[a10]8,a15
.L144:

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	    99  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   100          SchM_Enter_NvM_Main();
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   101          // TRACE[NVM380] The queue for multiblock requests has only one entryso if other multi-block request is active
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   102          //               then the queue is full and WriteAll will be rejected
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   103          isRequestEnqueued_b = NvM_Prv_Queue_EnqueueRequest(NvM_Prv_idQueue_Multi_e, &QueueEntry_st);
	mov	d4,#0
.L145:
	lea	a4,[a10]0
	call	NvM_Prv_Queue_EnqueueRequest
.L117:
	mov	d15,d2
.L119:

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   104  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   105          if (isRequestEnqueued_b)
	jeq	d15,#0,.L3
.L146:

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   106          {
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   107              // TRACE[NVM185] Set request result to NVM_REQ_PENDING on successful enqueuing
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   108              // TRACE[NVM667] Same as NVM185, but specific to NvM_ReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   109              NvM_Prv_Block_SetRequestResult(NVM_PRV_MULTI_BLOCK, NVM_REQ_PENDING);
	mov	d0,#2
.L62:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   169  LOCAL_INLINE boolean NvM_Prv_Block_IsRequestPending(NvM_BlockIdType idBlock_uo, uint16 maskService_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   170  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   172  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   173  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   174  LOCAL_INLINE boolean NvM_Prv_Block_IsPending(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   175  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   176      return (NvM_Prv_Block_IsNvmEnqueuingForMulti(idBlock_uo) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   177              ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != 0)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   178  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   179                && (NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != (1u << NvM_Prv_ServiceBit_Maintain_e))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   180  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   181              )
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   182             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   183  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   184  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   185  LOCAL_INLINE void NvM_Prv_Block_SetIdxData(NvM_BlockIdType idBlock_uo, uint8 idxData_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   186  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   187      NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] = idxData_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   188  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   189  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   190  LOCAL_INLINE void NvM_Prv_Block_SetRequestResult(NvM_BlockIdType idBlock_uo, NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   191  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   192      NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo] = Result_uo;
	movh.a	a15,#@his(NvM_Prv_stRequestResult_rAwAM_au8)
	lea	a15,[a15]@los(NvM_Prv_stRequestResult_rAwAM_au8)
.L147:
	add.a	a15,#0
.L148:
	st.b	[a15],d0
.L63:

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   110  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   111              // TRACE[NVM243] The actual read operation is not done here, just the request for doing it is signaled
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   112              NvM_Prv_Block_SetRequest(NVM_PRV_MULTI_BLOCK, QueueEntry_st.ServiceBit_uo);
	mov	d0,#0
.L149:
	ld.hu	d1,[a10]4
.L70:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   169  LOCAL_INLINE boolean NvM_Prv_Block_IsRequestPending(NvM_BlockIdType idBlock_uo, uint16 maskService_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   170  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   172  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   173  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   174  LOCAL_INLINE boolean NvM_Prv_Block_IsPending(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   175  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   176      return (NvM_Prv_Block_IsNvmEnqueuingForMulti(idBlock_uo) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   177              ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != 0)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   178  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   179                && (NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != (1u << NvM_Prv_ServiceBit_Maintain_e))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   180  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   181              )
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   182             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   183  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   184  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   185  LOCAL_INLINE void NvM_Prv_Block_SetIdxData(NvM_BlockIdType idBlock_uo, uint8 idxData_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   186  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   187      NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] = idxData_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   188  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   189  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   190  LOCAL_INLINE void NvM_Prv_Block_SetRequestResult(NvM_BlockIdType idBlock_uo, NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   191  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   192      NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo] = Result_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   193  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   194  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   195  LOCAL_INLINE void NvM_Prv_Block_SetRequest(NvM_BlockIdType idBlock_uo, NvM_Prv_ServiceBit_tuo ServiceBit_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   196  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   197      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= (1u << ServiceBit_uo);
	movh.a	a15,#@his(NvM_Prv_stRequests_rAMwAM_au16)
	lea	a15,[a15]@los(NvM_Prv_stRequests_rAMwAM_au16)
.L150:
	addsc.a	a15,a15,d0,#1
	ld.hu	d0,[a15]0
.L151:
	mov	d2,#1
.L118:
	sh	d2,d2,d1
.L152:
	or	d0,d2
	st.h	[a15],d0
.L71:

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   113  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   114              NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_IsBlockPartOfReadAll);
	movh.a	a4,#@his(NvM_Prv_IsBlockPartOfReadAll)
	lea	a4,[a4]@los(NvM_Prv_IsBlockPartOfReadAll)
	call	NvM_Prv_Block_SetIsNvmEnqueuingForMulti
.L3:

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   115  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   116  #if ((NVM_DYNAMIC_CONFIGURATION == STD_ON) && (NVM_RB_REMOVE_NON_RESISTANT_BLOCKS == STD_ON))
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   117              //TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2999] the "NvM_Prv_isReadAllInitiated_b" will be set to TRUE
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   118              //                                              only if ReadAll is initiated, then the blocks are free
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   119              //                                              for the other requests
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   120              NvM_Prv_isReadAllInitiated_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   121  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   122          }
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   123          SchM_Exit_NvM_Main();
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   125          if (isRequestEnqueued_b)
	jeq	d15,#0,.L4
.L153:

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   126          {
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   127              NvM_Prv_FindBlocksForReadAll();
	call	NvM_Prv_FindBlocksForReadAll
.L154:

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   128              NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NULL_PTR);
	mov.a	a4,#0
	call	NvM_Prv_Block_SetIsNvmEnqueuingForMulti
.L155:

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   129              // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2804] If BswMMultiBlockJobStatusInformation is enabled,
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   130              //                                               notify BswM about the state change of the multiblock operation.
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   131              // Calling foreign BswM function is done out of the Schm lock
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   132  #if (NVM_BSWM_MULTI_BLOCK_JOB_STATUS_INFORMATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   133              BswM_NvM_CurrentJobMode(NVM_SERVICE_ID_READ_ALL, NVM_REQ_PENDING);
	mov	d4,#12
.L156:
	mov	d5,#2
	call	BswM_NvM_CurrentJobMode
.L4:
.L2:

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   134  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   135          }
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   136      }
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   137  }
	ret
.L55:
	
__NvM_ReadAll_function_end:
	.size	NvM_ReadAll,__NvM_ReadAll_function_end-NvM_ReadAll
.L39:
	; End of function
	
	.sdecl	'.text.NvM_ReadAll.NvM_Prv_IsBlockPartOfReadAll',code,cluster('NvM_Prv_IsBlockPartOfReadAll')
	.sect	'.text.NvM_ReadAll.NvM_Prv_IsBlockPartOfReadAll'
	.align	2
	

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   138  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   139  static boolean NvM_Prv_IsBlockPartOfReadAll(NvM_BlockIdType idBlock_uo)
; Function NvM_Prv_IsBlockPartOfReadAll
.L26:
NvM_Prv_IsBlockPartOfReadAll:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
	movh.a	a15,#@his(NvM_Prv_stBlock_rAwAM_au8)
	lea	a15,[a15]@los(NvM_Prv_stBlock_rAwAM_au8)
.L165:
	addsc.a	a15,a15,d4,#0
	ld.bu	d15,[a15]
.L166:
	and	d15,#1
.L167:
	ne	d15,d15,#0
.L168:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);      (inlined)
	j	.L5

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }      (inlined)
.L5:

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   140  {
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   141      boolean isPRamBlockValid_b = NvM_Prv_Block_IsPRamBlockValid(idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   142      // The following conditions must be fulfilled for reading a block during ReadAll:
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   143      return (
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   144              // TRACE[NVM118] Only read blocks which are selected for ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   145              //               Only read blocks configured with a permanent RAM block or with explicit sync.
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   146              //               This is already checked in configuration scripts.
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   147              NvM_Prv_IsBlockSelected(idBlock_uo, NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL) &&
	mov	d2,#0
.L169:
	mov	d0,#1
.L89:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
	mov	d1,#0
.L170:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
	jge.u	d4,#14,.L6
.L171:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
	mul	d3,d4,#48
.L172:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L173:
	addsc.a	a15,a15,d3,#0
.L174:
	ld.hu	d3,[a15]46
.L175:
	and	d0,d3
.L176:
	seln	d1,d0,d1,#1

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
.L7:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));      (inlined)
.L6:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
	j	.L8

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }      (inlined)
.L8:
	jeq	d1,#0,.L9
.L90:
	cmovn	d2,d15,#1
.L10:

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   148              // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2802] Request the reading of the block
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   149              //                                               only if the NvM RAM block status bit is not set to VALID.
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   150              // CAUTION: After successfull Read, Write or Restore jobs, if NvM_ReadAll is invoked,
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   151              //          the block will be skipped. This is the same if NvM_SetRAMBlockStatus
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   152              //          was successfully invoked before NvM_ReadAll invocation.
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   153              !isPRamBlockValid_b
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   154             );
.L9:
	j	.L11

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   155  }
.L11:
	ret
.L81:
	
__NvM_Prv_IsBlockPartOfReadAll_function_end:
	.size	NvM_Prv_IsBlockPartOfReadAll,__NvM_Prv_IsBlockPartOfReadAll_function_end-NvM_Prv_IsBlockPartOfReadAll
.L49:
	; End of function
	
	.sdecl	'.text.NvM_ReadAll.NvM_Prv_FindBlocksForReadAll',code,cluster('NvM_Prv_FindBlocksForReadAll')
	.sect	'.text.NvM_ReadAll.NvM_Prv_FindBlocksForReadAll'
	.align	2
	

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   156  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   157  static void NvM_Prv_FindBlocksForReadAll(void)
; Function NvM_Prv_FindBlocksForReadAll
.L28:
NvM_Prv_FindBlocksForReadAll:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   158  {
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   159      NvM_BlockIdType idBlock_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   160  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   161      // Iterate through all used blocks to find the blocks which can and shall be read
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   162      // TRACE[NVM073] In case of dynamic configuration, start with a read operation for block 1
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   163      // TRACE[NVM248] Otherwise, block 1 is not read during NvM_ReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   164      // TRACE[NVM669] Block ID 1 is reserved for the config ID
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   165      // The auxiliary interface does not support multi-block operations at all,
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   166      // hence it is sufficient to iterate over all "regular" block IDs only
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   167      for (idBlock_uo = NVM_CFG_FIRST_USED_BLOCK; idBlock_uo < NVM_CFG_NR_BLOCKS; ++idBlock_uo)
	mov	d8,#2
.L120:
	j	.L12
.L13:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   392  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   393   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   394   * This NvM private function checks for the given block whether the configured block length is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   395   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   396   * \param idBlock
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   397   * ID of the block for which the block length will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   398   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   399   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   400   * - TRUE = block length is valid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   401   * - FALSE = block length is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   402   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   403  LOCAL_INLINE boolean NvM_Prv_IsBlockLengthValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   404  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   405      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   406              (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   407              (0u != *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   408  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   409  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   410  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   411   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   412   * This NvM private function checks whether the given block is configured with immediate priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   413   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   414   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   415   * ID of the block for which the priority will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   416   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   417   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   418   * - TRUE = block is configured with immediate priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   419   * - FALSE = block is configured with standard priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   420   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   421  LOCAL_INLINE boolean NvM_Prv_HasBlockImmediateJobPriority(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   423      boolean HasBlockImmediateJobPriority_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   425  #if (NVM_JOB_PRIORITIZATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   426      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   427          (NVM_PRV_JOB_PRIORITY_IMMEDIATE == NvM_Prv_BlockDescriptors_acst[idBlock_uo].JobPriority_u8))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   428      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   429          HasBlockImmediateJobPriority_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   430      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   431  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   433  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   434  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   435  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   436   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   437   * This NvM private function returns the configured block size for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   438   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   439   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   440   * ID of the block for which the configured block size will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   441   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   442   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   443   * Configured block size
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   444   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   445  LOCAL_INLINE uint16 NvM_Prv_GetBlockSize(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   446  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   447      uint16 BlockSize_u16 = 0;
	mov	d15,#0
.L121:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
	jge.u	d8,#14,.L14
.L181:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   448  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))
	mul	d0,d8,#48
.L182:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L183:
	addsc.a	a15,a15,d0,#0
.L184:
	ld.a	a15,[a15]4
.L185:
	mov.a	a2,#0
.L186:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))      (inlined)
	jeq.a	a2,a15,.L15
.L187:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   451      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   452          BlockSize_u16 = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16;
	ld.hu	d15,[a15]0

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
.L15:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))      (inlined)
.L14:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   455      return BlockSize_u16;      (inlined)
	j	.L16

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   456  }      (inlined)
.L16:

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   168      {
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   169          // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3033] Ignore blocks with length null
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   170          if (NvM_Prv_GetBlockSize(idBlock_uo) > 0)
	jeq	d15,#0,.L17
.L99:

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   171          {
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   172              if (NvM_Prv_IsBlockPartOfReadAll(idBlock_uo))
	mov	d4,d8
.L123:
	call	NvM_Prv_IsBlockPartOfReadAll
.L124:
	jeq	d2,#0,.L18
.L188:

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   173              {
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   174                  // TRACE[NVM185] Set single block request result to NVM_REQ_PENDING on successful enqueuing
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   175                  // This is done right away to allow an immediate NvM_GetErrorStatus call returning a meaningful result
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   176                  // Note: In case of dynamic configuration, this might be revised to NVM_REQ_BLOCK_SKIPPED depending
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   177                  // on the config ID comparison result
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   178                  NvM_Prv_Block_SetRequestResult(idBlock_uo, NVM_REQ_PENDING);
	mov	d0,#2
.L104:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   169  LOCAL_INLINE boolean NvM_Prv_Block_IsRequestPending(NvM_BlockIdType idBlock_uo, uint16 maskService_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   170  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   172  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   173  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   174  LOCAL_INLINE boolean NvM_Prv_Block_IsPending(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   175  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   176      return (NvM_Prv_Block_IsNvmEnqueuingForMulti(idBlock_uo) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   177              ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != 0)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   178  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   179                && (NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != (1u << NvM_Prv_ServiceBit_Maintain_e))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   180  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   181              )
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   182             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   183  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   184  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   185  LOCAL_INLINE void NvM_Prv_Block_SetIdxData(NvM_BlockIdType idBlock_uo, uint8 idxData_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   186  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   187      NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] = idxData_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   188  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   189  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   190  LOCAL_INLINE void NvM_Prv_Block_SetRequestResult(NvM_BlockIdType idBlock_uo, NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   191  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   192      NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo] = Result_uo;
	movh.a	a15,#@his(NvM_Prv_stRequestResult_rAwAM_au8)
	lea	a15,[a15]@los(NvM_Prv_stRequestResult_rAwAM_au8)
.L189:
	addsc.a	a15,a15,d8,#0
.L190:
	st.b	[a15],d0
.L105:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   193  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   194  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   195  LOCAL_INLINE void NvM_Prv_Block_SetRequest(NvM_BlockIdType idBlock_uo, NvM_Prv_ServiceBit_tuo ServiceBit_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   196  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   197      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= (1u << ServiceBit_uo);
	movh.a	a15,#@his(NvM_Prv_stRequests_rAMwAM_au16)
	lea	a15,[a15]@los(NvM_Prv_stRequests_rAMwAM_au16)
.L191:
	addsc.a	a15,a15,d8,#1
	ld.hu	d0,[a15]0
.L192:
	mov	d1,#1
.L193:
	sh	d1,#0
.L194:
	or	d0,d1
	st.h	[a15],d0
.L108:
	j	.L19
.L18:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
	movh.a	a15,#@his(NvM_Prv_stRequestResult_rAwAM_au8)
	lea	a15,[a15]@los(NvM_Prv_stRequestResult_rAwAM_au8)
.L195:
	addsc.a	a2,a15,d8,#0
	ld.bu	d15,[a2]
.L122:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];      (inlined)
	j	.L20

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }      (inlined)
.L20:

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   179  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   180                  // Internally signal that this block has been requested to be read
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   181                  NvM_Prv_Block_SetRequest(idBlock_uo, NvM_Prv_ServiceBit_ReadAll_e);
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   182              }
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   183              else
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   184              {
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   185                  // TRACE[NVM287] Set job result to NVM_REQ_BLOCK_SKIPPED if not read
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   186                  // This is done right away to allow an immediate NvM_GetErrorStatus call returning a meaningful result
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   187                  // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2879] If a block is currently PENDING due
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   188                  //                                               to a queued/running single block operation,
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   189                  //                                               the request result shouldn't be set to SKIPPED
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   190                  if (NVM_REQ_PENDING != NvM_Prv_Block_GetRequestResult(idBlock_uo))
	jeq	d15,#2,.L21
.L196:

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   191                  {
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   192                      NvM_Prv_Block_SetRequestResult(idBlock_uo, NVM_REQ_BLOCK_SKIPPED);
	mov	d15,#4
.L115:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   169  LOCAL_INLINE boolean NvM_Prv_Block_IsRequestPending(NvM_BlockIdType idBlock_uo, uint16 maskService_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   170  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   172  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   173  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   174  LOCAL_INLINE boolean NvM_Prv_Block_IsPending(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   175  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   176      return (NvM_Prv_Block_IsNvmEnqueuingForMulti(idBlock_uo) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   177              ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != 0)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   178  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   179                && (NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != (1u << NvM_Prv_ServiceBit_Maintain_e))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   180  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   181              )
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   182             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   183  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   184  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   185  LOCAL_INLINE void NvM_Prv_Block_SetIdxData(NvM_BlockIdType idBlock_uo, uint8 idxData_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   186  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   187      NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] = idxData_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   188  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   189  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   190  LOCAL_INLINE void NvM_Prv_Block_SetRequestResult(NvM_BlockIdType idBlock_uo, NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   191  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   192      NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo] = Result_uo;
	addsc.a	a15,a15,d8,#0
.L197:
	st.b	[a15],d15
.L21:
.L19:
.L17:
	add	d8,#1
.L12:
	jlt.u	d8,#14,.L13
.L198:

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   193                  }
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   194              }
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   195          }
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   196      }
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   197  }
	ret
.L96:
	
__NvM_Prv_FindBlocksForReadAll_function_end:
	.size	NvM_Prv_FindBlocksForReadAll,__NvM_Prv_FindBlocksForReadAll_function_end-NvM_Prv_FindBlocksForReadAll
.L54:
	; End of function
	
	.sdecl	'.text.NvM_ReadAll.NvM_Prv_IsSanitizedByReadAll',code,cluster('NvM_Prv_IsSanitizedByReadAll')
	.sect	'.text.NvM_ReadAll.NvM_Prv_IsSanitizedByReadAll'
	.align	2
	
	.global	NvM_Prv_IsSanitizedByReadAll

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   198  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   199  /**
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   200   * This function indicates whether a single block is sanitized or not by ReadAll after the layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   201   *
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   202   * If the enhanced dynamic configuration is not activated, there is no need to sanitize the blocks, so the return
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   203   * value is always TRUE.
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   204   *
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   205   * If the enhanced dynamic configuration is activated, after the layout changes, the blocks need to be sanitized
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   206   * by ReadAll at first to avoid the incompatibility caused by changed layout. Therefore, before the ReadAll is
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   207   * initiated, the single block requests which operate with Nv memory should not be accepted on the blocks, whose
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   208   * compatiblility is not sanitized by the ReadAll. In this case, all of the blocks, which are chosen for ReadAll and
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   209   * not resistant to changed software need to be sanitized by ReadAll. If they are not sanitized, the return value
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   210   * is FALSE.
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   211   *
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   212   * \param[in] idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   213   * ID of the block for which the sanitization by ReadAll will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   214   *
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   215   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   216   * - TRUE:  If the enhanced dynamic configuration is activated,
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   217   *          the current block is sanitized by ReadAll after the layout change.
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   218   *          If the enhanced dynamic configuration is not activated,
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   219   *          there is no need to sanitize the blocks in ReadAll, so the return value is always TRUE.
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   220   * - FALSE: the current block is not sanitized by ReadAll after the layout change.
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   221   */
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   222  // TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2999] the potentially incompatible blocks after layout changes should be
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   223  //                                               sanitized by ReadAll at first
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   224  boolean NvM_Prv_IsSanitizedByReadAll(NvM_BlockIdType idBlock_uo)
; Function NvM_Prv_IsSanitizedByReadAll
.L30:
NvM_Prv_IsSanitizedByReadAll:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   225  {
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   226      //if the enhanced dynamic configuration is not activated, there is no incompatible problem for single blocks
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   227      //therefore, the default return value is true
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   228      boolean isReadAllInitiated_b = TRUE;
	mov	d2,#1
.L125:

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   229  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   230  #if ((NVM_DYNAMIC_CONFIGURATION == STD_ON) && (NVM_RB_REMOVE_NON_RESISTANT_BLOCKS == STD_ON))
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   231      //if the enhanced dynamic configuration is activated, check whether the current block has incompatible potential
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   232      if (NvM_Prv_IsBlockSelected(idBlock_uo, NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL) &&
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   233          !NvM_Prv_IsBlockSelected(idBlock_uo, NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW))
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   234      {
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   235          //if the current block is chosen as a block to ReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   236          //and it is not resistant to changed software, then this block has incompatible potential,
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   237          //it will check whether ReadAll is initiated, because the incompatible blocks should be sanitized by ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   238          //if not, the single block requests(which operate on NV memory) on the current block will be blocked
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   239          isReadAllInitiated_b = NvM_Prv_isReadAllInitiated_b;
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   240      }
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   241  #else
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   242      (void)idBlock_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   243  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   244  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   245      return isReadAllInitiated_b;
	j	.L22

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   246  }
.L22:
	ret
.L77:
	
__NvM_Prv_IsSanitizedByReadAll_function_end:
	.size	NvM_Prv_IsSanitizedByReadAll,__NvM_Prv_IsSanitizedByReadAll_function_end-NvM_Prv_IsSanitizedByReadAll
.L44:
	; End of function
	
	.calls	'__INDIRECT__','NvM_Prv_IsBlockPartOfReadAll'
	.calls	'NvM_ReadAll','NvM_Prv_ErrorDetection_IsNvmInitialized'
	.calls	'NvM_ReadAll','NvM_Prv_Queue_EnqueueRequest'
	.calls	'NvM_ReadAll','NvM_Prv_Block_SetIsNvmEnqueuingForMulti'
	.calls	'NvM_ReadAll','NvM_Prv_FindBlocksForReadAll'
	.calls	'NvM_ReadAll','BswM_NvM_CurrentJobMode'
	.calls	'NvM_Prv_FindBlocksForReadAll','NvM_Prv_IsBlockPartOfReadAll'
	.calls	'NvM_ReadAll','',16
	.calls	'NvM_Prv_IsBlockPartOfReadAll','',0
	.calls	'NvM_Prv_FindBlocksForReadAll','',0
	.extern	BswM_NvM_CurrentJobMode
	.extern	NvM_Prv_Queue_EnqueueRequest
	.extern	NvM_Prv_BlockDescriptors_acst
	.extern	NvM_Prv_stBlock_rAwAM_au8
	.extern	NvM_Prv_stRequests_rAMwAM_au16
	.extern	NvM_Prv_stRequestResult_rAwAM_au8
	.extern	NvM_Prv_Block_SetIsNvmEnqueuingForMulti
	.extern	NvM_Prv_ErrorDetection_IsNvmInitialized
	.extern	__INDIRECT__
	.calls	'NvM_Prv_IsSanitizedByReadAll','',0
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L32:
	.word	13867
	.half	3
	.word	.L33
	.byte	4
.L31:
	.byte	1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ReadAll.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L34
.L57:
	.byte	2
	.byte	'unsigned char',0,1,8
.L78:
	.byte	2
	.byte	'unsigned short int',0,2,7,3,1,34,9,4,4
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL',0,1,4
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL',0,2,4
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL',0,4,4
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE',0,8,4
	.byte	'NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED',0,16,4
	.byte	'NVM_PRV_BLOCK_FLAG_WRITE_ONCE',0,32,4
	.byte	'NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW',0,192,0,4
	.byte	'NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM',0,128,1,4
	.byte	'NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION',0,128,2,4
	.byte	'NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH',0,128,4,4
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION',0,128,8,4
	.byte	'NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL',0,128,16,0
.L88:
	.byte	5
	.byte	'NvM_Prv_IsBlockSelected',0,3,1,239,2,22
	.word	137
	.byte	1,1
.L91:
	.byte	6
	.byte	'idBlock_uo',0,1,239,2,62
	.word	154
.L93:
	.byte	6
	.byte	'SelectionMask_en',0,1,240,2,77
	.word	176
.L95:
	.byte	7,0
.L98:
	.byte	5
	.byte	'NvM_Prv_GetBlockSize',0,3,1,189,3,21
	.word	154
	.byte	1,1
.L100:
	.byte	6
	.byte	'idBlock_uo',0,1,189,3,58
	.word	154
.L102:
	.byte	7,0,3,2,40,9,4,4
	.byte	'NVM_BLOCK_NATIVE',0,0,4
	.byte	'NVM_BLOCK_REDUNDANT',0,1,4
	.byte	'NVM_BLOCK_DATASET',0,2,0,5
	.byte	'NvM_Prv_GetBlockType',0,3,1,212,3,38
	.word	839
	.byte	1,1,6
	.byte	'idBlock_uo',0,1,212,3,75
	.word	154
	.byte	7,0,5
	.byte	'NvM_Prv_GetNrNonVolatileBlocks',0,3,1,232,3,20
	.word	137
	.byte	1,1,6
	.byte	'idBlock_uo',0,1,232,3,67
	.word	154
	.byte	7,0,8
	.byte	'void',0,9
	.word	1026
	.byte	10
	.word	1032
	.byte	5
	.byte	'NvM_Prv_GetRomBlockAddress',0,3,1,173,4,26
	.word	1037
	.byte	1,1,6
	.byte	'idBlock_uo',0,1,173,4,69
	.word	154
	.byte	7,0
.L84:
	.byte	5
	.byte	'NvM_Prv_Block_IsPRamBlockValid',0,3,3,115,22
	.word	137
	.byte	1,1
.L85:
	.byte	6
	.byte	'idBlock_uo',0,3,115,69
	.word	154
.L87:
	.byte	7,0,5
	.byte	'NvM_Prv_Block_IsInRom',0,3,3,142,1,22
	.word	137
	.byte	1,1,6
	.byte	'idBlock_uo',0,3,142,1,60
	.word	154
	.byte	6
	.byte	'idxDataset_u8',0,3,142,1,78
	.word	137
	.byte	11,7,7,0,0,5
	.byte	'NvM_Prv_Block_IsWriteProtected',0,3,3,148,1,22
	.word	137
	.byte	1,1,6
	.byte	'idBlock_uo',0,3,148,1,69
	.word	154
	.byte	7,0
.L111:
	.byte	5
	.byte	'NvM_Prv_Block_GetRequestResult',0,3,3,164,1,36
	.word	137
	.byte	1,1
.L112:
	.byte	6
	.byte	'idBlock_uo',0,3,164,1,83
	.word	154
.L114:
	.byte	7,0
.L61:
	.byte	12
	.byte	'NvM_Prv_Block_SetRequestResult',0,3,3,190,1,19,1,1
.L64:
	.byte	6
	.byte	'idBlock_uo',0,3,190,1,66
	.word	154
.L66:
	.byte	6
	.byte	'Result_uo',0,3,190,1,100
	.word	137
.L68:
	.byte	7,0
.L69:
	.byte	12
	.byte	'NvM_Prv_Block_SetRequest',0,3,3,195,1,19,1,1
.L72:
	.byte	6
	.byte	'idBlock_uo',0,3,195,1,60
	.word	154
.L74:
	.byte	6
	.byte	'ServiceBit_uo',0,3,195,1,95
	.word	154
.L76:
	.byte	7,0,10
	.word	1026
.L59:
	.byte	13,2,210,1,9,12,14
	.byte	'idService_uo',0
	.word	137
	.byte	1,2,35,0,14
	.byte	'idBlock_uo',0
	.word	154
	.byte	2,2,35,2,14
	.byte	'ServiceBit_uo',0
	.word	154
	.byte	2,2,35,4,14
	.byte	'BlockData_pv',0
	.word	1536
	.byte	4,2,35,8,0,15
	.byte	'BswM_NvM_CurrentJobMode',0,4,33,30,1,1,1,1,6
	.byte	'ServiceId',0,4,33,76
	.word	137
	.byte	6
	.byte	'CurrentJobMode',0,4,33,125
	.word	137
	.byte	0,9
	.word	1541
	.byte	10
	.word	1709
	.byte	16
	.byte	'NvM_Prv_Queue_EnqueueRequest',0,5,40,16
	.word	137
	.byte	1,1,1,1,6
	.byte	'idQueue_uo',0,5,40,65
	.word	137
	.byte	6
	.byte	'QueueEntry_pcst',0,5,41,75
	.word	1714
	.byte	0,17
	.word	700
	.byte	18
	.word	736
	.byte	18
	.word	756
	.byte	7,0,17
	.word	784
	.byte	18
	.word	817
	.byte	7,0,17
	.word	906
	.byte	18
	.word	939
	.byte	7,0,17
	.word	961
	.byte	18
	.word	1004
	.byte	7,0,17
	.word	1042
	.byte	18
	.word	1081
	.byte	7,0,19
	.word	137
	.byte	1,1,20
	.word	154
	.byte	0,10
	.word	1869
	.byte	21
	.byte	'NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct',0,3,38,19
	.word	1882
	.byte	15
	.byte	'NvM_Prv_Block_SetIsNvmEnqueuingForMulti',0,3,104,13,1,1,1,1,6
	.byte	'IsNvmEnqueuingForMulti_pfct',0,3,104,96
	.word	1887
	.byte	0,10
	.word	1869
	.byte	17
	.word	1103
	.byte	18
	.word	1145
	.byte	7,0,17
	.word	1166
	.byte	18
	.word	1200
	.byte	18
	.word	1220
	.byte	11,22
	.word	906
	.byte	18
	.word	939
	.byte	23
	.word	959
	.byte	0,7,22
	.word	961
	.byte	18
	.word	1004
	.byte	23
	.word	1024
	.byte	0,7,0,0,17
	.word	1248
	.byte	18
	.word	1291
	.byte	7,0,17
	.word	1313
	.byte	18
	.word	1356
	.byte	7,0,17
	.word	1378
	.byte	18
	.word	1417
	.byte	18
	.word	1437
	.byte	7,0,17
	.word	1458
	.byte	18
	.word	1491
	.byte	18
	.word	1511
	.byte	7,0,16
	.byte	'NvM_Prv_ErrorDetection_IsNvmInitialized',0,6,89,16
	.word	137
	.byte	1,1,1,1,6
	.byte	'idService_uo',0,6,89,78
	.word	137
	.byte	6
	.byte	'idBlock_uo',0,6,90,72
	.word	154
	.byte	0,24
	.byte	'__INDIRECT__',0,7,1,1,1,1,1,25,1,10
	.word	2263
	.byte	21
	.byte	'__codeptr',0,7,1,1
	.word	2265
	.byte	2
	.byte	'char',0,1,6,21
	.byte	'sint8',0,8,76,25
	.word	2288
	.byte	21
	.byte	'uint8',0,8,81,25
	.word	137
	.byte	21
	.byte	'uint16',0,8,91,25
	.word	154
	.byte	2
	.byte	'unsigned int',0,4,7,21
	.byte	'uint32',0,8,106,24
	.word	2339
	.byte	2
	.byte	'unsigned long long int',0,8,7,21
	.byte	'uint64',0,8,111,30
	.word	2370
	.byte	21
	.byte	'boolean',0,8,127,25
	.word	137
	.byte	21
	.byte	'StatusType',0,9,191,1,27
	.word	137
	.byte	21
	.byte	'Std_ReturnType',0,9,199,1,15
	.word	137
	.byte	13,9,206,1,9,8,14
	.byte	'vendorID',0
	.word	154
	.byte	2,2,35,0,14
	.byte	'moduleID',0
	.word	154
	.byte	2,2,35,2,14
	.byte	'sw_major_version',0
	.word	137
	.byte	1,2,35,4,14
	.byte	'sw_minor_version',0
	.word	137
	.byte	1,2,35,5,14
	.byte	'sw_patch_version',0
	.word	137
	.byte	1,2,35,6,0,21
	.byte	'Std_VersionInfoType',0,9,213,1,3
	.word	2471
	.byte	21
	.byte	'PduIdType',0,10,22,19
	.word	154
	.byte	21
	.byte	'PduLengthType',0,10,26,19
	.word	154
	.byte	3,11,113,9,4,4
	.byte	'TP_DATACONF',0,0,4
	.byte	'TP_DATARETRY',0,1,4
	.byte	'TP_CONFPENDING',0,2,0,21
	.byte	'TpDataStateType',0,11,118,3
	.word	2661
	.byte	21
	.byte	'Can_IdType',0,12,32,16
	.word	2339
	.byte	21
	.byte	'Can_HwHandleType',0,12,43,16
	.word	154
	.byte	13,13,93,9,8,14
	.byte	'Class',0
	.word	137
	.byte	1,2,35,0,14
	.byte	'TIN',0
	.word	137
	.byte	1,2,35,1,14
	.byte	'ReturnAddress',0
	.word	2339
	.byte	4,2,35,4,0,21
	.byte	'OsTrapInfoType',0,13,97,3
	.word	2781
	.byte	26,68
	.word	2339
	.byte	27,16,0,13,13,154,1,9,68,14
	.byte	'store',0
	.word	2861
	.byte	68,2,35,0,0,26,68
	.word	2870
	.byte	27,0,0,21
	.byte	'Os_JumpBufType',0,13,156,1,3
	.word	2892
	.byte	21
	.byte	'Os_StackTraceType',0,13,174,1,18
	.word	2339
	.byte	13,13,175,1,9,8,14
	.byte	'sp',0
	.word	2339
	.byte	4,2,35,0,14
	.byte	'ctx',0
	.word	2339
	.byte	4,2,35,4,0,21
	.byte	'Os_StackValueType',0,13,175,1,63
	.word	2952
	.byte	21
	.byte	'Os_StackSizeType',0,13,176,1,27
	.word	2952
	.byte	28,1,1,10
	.word	3037
	.byte	21
	.byte	'Os_VoidVoidFunctionType',0,13,179,1,16
	.word	3040
	.byte	21
	.byte	'ApplicationType',0,13,193,1,23
	.word	137
	.byte	29
	.byte	'Os_ApplicationConfigurationType_s',0,13,198,1,16,2,14
	.byte	'app_id',0
	.word	137
	.byte	1,2,35,0,14
	.byte	'access',0
	.word	137
	.byte	1,2,35,1,0,21
	.byte	'Os_ApplicationConfigurationType',0,13,201,1,3
	.word	3103
	.byte	21
	.byte	'Os_CoreStateType',0,13,203,1,16
	.word	2339
	.byte	21
	.byte	'AreaIdType',0,13,204,1,16
	.word	154
	.byte	21
	.byte	'Os_PeripheralAddressType',0,13,212,1,22
	.word	2339
	.byte	21
	.byte	'TickType',0,13,221,1,22
	.word	2339
	.byte	21
	.byte	'Os_StopwatchTickType',0,13,225,1,22
	.word	2339
	.byte	10
	.word	2339
	.byte	21
	.byte	'Os_Lockable',0,13,234,1,18
	.word	3345
	.byte	21
	.byte	'CoreIdType',0,13,236,1,16
	.word	154
	.byte	21
	.byte	'SpinlockIdType',0,13,237,1,16
	.word	154
	.byte	3,13,239,1,9,4,4
	.byte	'TRYTOGETSPINLOCK_SUCCESS',0,0,4
	.byte	'TRYTOGETSPINLOCK_NOSUCCESS',0,1,0,21
	.byte	'TryToGetSpinlockType',0,13,239,1,74
	.word	3415
	.byte	3,13,174,2,9,4,4
	.byte	'APPLICATION_ACCESSIBLE',0,0,4
	.byte	'APPLICATION_RESTARTING',0,1,4
	.byte	'APPLICATION_TERMINATED',0,2,0,21
	.byte	'ApplicationStateType',0,13,174,2,92
	.word	3508
	.byte	30,1,1,20
	.word	137
	.byte	20
	.word	1536
	.byte	0,10
	.word	3620
	.byte	21
	.byte	'Os_FunctionEntryType',0,13,183,2,16
	.word	3634
	.byte	29
	.byte	'Os_MeterInfoType_s',0,13,193,2,16,48,14
	.byte	'elapsed',0
	.word	2339
	.byte	4,2,35,0,14
	.byte	'previous',0
	.word	2339
	.byte	4,2,35,4,14
	.byte	'max',0
	.word	2339
	.byte	4,2,35,8,14
	.byte	'cumulative',0
	.word	2339
	.byte	4,2,35,12,14
	.byte	'stackbase',0
	.word	2952
	.byte	8,2,35,16,14
	.byte	'stackusage',0
	.word	2952
	.byte	8,2,35,24,14
	.byte	'stackmax',0
	.word	2952
	.byte	8,2,35,32,14
	.byte	'stackbudget',0
	.word	2952
	.byte	8,2,35,40,0,21
	.byte	'Os_MeterInfoType',0,13,202,2,3
	.word	3669
	.byte	10
	.word	3669
	.byte	21
	.byte	'Os_MeterInfoRefType',0,13,203,2,50
	.word	3867
	.byte	21
	.byte	'EventMaskType',0,13,206,2,15
	.word	137
	.byte	21
	.byte	'Os_imaskType',0,13,211,2,16
	.word	2339
	.byte	29
	.byte	'Os_ISRDynType_s',0,13,213,2,16,48,14
	.byte	'meter',0
	.word	3669
	.byte	48,2,35,0,0,21
	.byte	'Os_ISRDynType',0,13,215,2,3
	.word	3946
	.byte	10
	.word	3946
	.byte	9
	.word	4007
	.byte	29
	.byte	'Os_ISRType_s',0,13,216,2,16,24,14
	.byte	'entry_function',0
	.word	3045
	.byte	4,2,35,0,14
	.byte	'dynamic',0
	.word	4012
	.byte	4,2,35,4,14
	.byte	'imask',0
	.word	2339
	.byte	4,2,35,8,14
	.byte	'stackbudget',0
	.word	2952
	.byte	8,2,35,12,14
	.byte	'access',0
	.word	137
	.byte	1,2,35,20,14
	.byte	'application',0
	.word	137
	.byte	1,2,35,21,0,21
	.byte	'Os_ISRType',0,13,223,2,3
	.word	4017
	.byte	10
	.word	3037
	.byte	9
	.word	4017
	.byte	10
	.word	4176
	.byte	21
	.byte	'ISRType',0,13,224,2,46
	.word	4181
	.byte	21
	.byte	'Os_bitmask',0,13,239,2,22
	.word	2339
	.byte	21
	.byte	'Os_pset0Type',0,13,240,2,20
	.word	2339
	.byte	21
	.byte	'Os_pset1Type',0,13,241,2,20
	.word	2339
	.byte	21
	.byte	'Os_pset2Type',0,13,242,2,20
	.word	2339
	.byte	31,13,243,2,9,4,14
	.byte	'p0',0
	.word	2339
	.byte	4,2,35,0,14
	.byte	'p1',0
	.word	2339
	.byte	4,2,35,0,14
	.byte	'p2',0
	.word	2339
	.byte	4,2,35,0,0,21
	.byte	'Os_psetType',0,13,247,2,3
	.word	4289
	.byte	31,13,249,2,9,4,14
	.byte	't0',0
	.word	2339
	.byte	4,2,35,0,14
	.byte	't1',0
	.word	2339
	.byte	4,2,35,0,14
	.byte	't2',0
	.word	2339
	.byte	4,2,35,0,0,21
	.byte	'Os_tpmaskType',0,13,253,2,3
	.word	4353
	.byte	21
	.byte	'Os_ActivationCountType',0,13,254,2,23
	.word	137
	.byte	29
	.byte	'Os_TaskDynType_s',0,13,128,3,16,120,14
	.byte	'terminate_jump_buf',0
	.word	2901
	.byte	68,2,35,0,14
	.byte	'meter',0
	.word	3669
	.byte	48,2,35,68,14
	.byte	'activation_count',0
	.word	137
	.byte	1,2,35,116,0,21
	.byte	'Os_TaskDynType',0,13,132,3,3
	.word	4451
	.byte	26,68
	.word	2870
	.byte	27,0,0,10
	.word	4451
	.byte	9
	.word	4577
	.byte	29
	.byte	'Os_TaskType_s',0,13,134,3,16,40,14
	.byte	'dynamic',0
	.word	4582
	.byte	4,2,35,0,14
	.byte	'entry_function',0
	.word	3045
	.byte	4,2,35,4,14
	.byte	'pset',0
	.word	4289
	.byte	4,2,35,8,14
	.byte	'base_tpmask',0
	.word	4353
	.byte	4,2,35,12,14
	.byte	'tpmask',0
	.word	4353
	.byte	4,2,35,16,14
	.byte	'core_id',0
	.word	154
	.byte	2,2,35,20,14
	.byte	'index',0
	.word	2339
	.byte	4,2,35,24,14
	.byte	'stackbudget',0
	.word	2952
	.byte	8,2,35,28,14
	.byte	'activation_count',0
	.word	137
	.byte	1,2,35,36,14
	.byte	'access',0
	.word	137
	.byte	1,2,35,37,14
	.byte	'application',0
	.word	137
	.byte	1,2,35,38,0,21
	.byte	'Os_TaskType',0,13,146,3,3
	.word	4587
	.byte	9
	.word	4587
	.byte	10
	.word	4837
	.byte	21
	.byte	'TaskType',0,13,147,3,47
	.word	4842
	.byte	32
	.byte	'Os_TaskStateType',0,13,155,3,6,4,4
	.byte	'SUSPENDED',0,0,4
	.byte	'READY',0,1,4
	.byte	'WAITING',0,2,4
	.byte	'RUNNING',0,3,0,21
	.byte	'TaskStateType',0,13,156,3,31
	.word	4865
	.byte	31,13,167,3,3,4,14
	.byte	'tpmask',0
	.word	4353
	.byte	4,2,35,0,0,29
	.byte	'Os_ResourceDynType_s',0,13,166,3,16,4,14
	.byte	'saved_priority',0
	.word	4952
	.byte	4,2,35,0,0,21
	.byte	'Os_ResourceDynType',0,13,170,3,3
	.word	4975
	.byte	10
	.word	4975
	.byte	9
	.word	5055
	.byte	29
	.byte	'Os_ResourceType_s',0,13,171,3,16,12,14
	.byte	'dynamic',0
	.word	5060
	.byte	4,2,35,0,14
	.byte	'tpmask',0
	.word	4353
	.byte	4,2,35,4,14
	.byte	'access',0
	.word	137
	.byte	1,2,35,8,0,21
	.byte	'Os_ResourceType',0,13,175,3,3
	.word	5065
	.byte	13,13,181,3,9,12,14
	.byte	'maxallowedvalue',0
	.word	2339
	.byte	4,2,35,0,14
	.byte	'ticksperbase',0
	.word	2339
	.byte	4,2,35,4,14
	.byte	'mincycle',0
	.word	2339
	.byte	4,2,35,8,0,21
	.byte	'AlarmBaseType',0,13,185,3,3
	.word	5164
	.byte	13,13,206,3,9,8,14
	.byte	'Running',0
	.word	137
	.byte	1,2,35,0,14
	.byte	'Pending',0
	.word	137
	.byte	1,2,35,1,14
	.byte	'Delay',0
	.word	2339
	.byte	4,2,35,4,0,21
	.byte	'Os_CounterStatusType',0,13,210,3,3
	.word	5259
	.byte	33
	.word	137
	.byte	1,1,10
	.word	5345
	.byte	21
	.byte	'Os_CounterIncrAdvType',0,13,217,3,22
	.word	5352
	.byte	29
	.byte	's_swd',0,13,222,3,12,4,14
	.byte	'count',0
	.word	2339
	.byte	4,2,35,0,0,31,13,221,3,3,4,14
	.byte	'sw',0
	.word	5388
	.byte	4,2,35,0,0,29
	.byte	'Os_CounterDynType_s',0,13,220,3,16,4,14
	.byte	'type_dependent',0
	.word	5416
	.byte	4,2,35,0,0,21
	.byte	'Os_CounterDynType',0,13,226,3,3
	.word	5435
	.byte	10
	.word	5435
	.byte	9
	.word	5513
	.byte	29
	.byte	'Os_CounterType_s',0,13,227,3,16,28,14
	.byte	'dynamic',0
	.word	5518
	.byte	4,2,35,0,14
	.byte	'advincr',0
	.word	5357
	.byte	4,2,35,4,14
	.byte	'base',0
	.word	5164
	.byte	12,2,35,8,14
	.byte	'core',0
	.word	1536
	.byte	4,2,35,20,14
	.byte	'access',0
	.word	137
	.byte	1,2,35,24,14
	.byte	'application',0
	.word	137
	.byte	1,2,35,25,0,21
	.byte	'Os_CounterType',0,13,234,3,3
	.word	5523
	.byte	10
	.word	5345
	.byte	9
	.word	5523
	.byte	10
	.word	5675
	.byte	21
	.byte	'CounterType',0,13,235,3,52
	.word	5680
	.byte	32
	.byte	'Os_ScheduleTableStatusType',0,13,240,3,6,4,4
	.byte	'SCHEDULETABLE_STOPPED',0,0,4
	.byte	'SCHEDULETABLE_NEXT',0,1,4
	.byte	'SCHEDULETABLE_WAITING',0,2,4
	.byte	'SCHEDULETABLE_RUNNING',0,3,4
	.byte	'SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS',0,4,0,21
	.byte	'ScheduleTableStatusType',0,13,241,3,41
	.word	5706
	.byte	9
	.word	.L126-.L32
	.byte	10
	.word	5906
	.byte	21
	.byte	'ScheduleTableType',0,13,128,4,58
	.word	5911
	.byte	29
	.byte	'Os_ScheduleTableDynType_s',0,13,130,4,16,16,14
	.byte	'match',0
	.word	2339
	.byte	4,2,35,0,14
	.byte	'next',0
	.word	5916
	.byte	4,2,35,4,14
	.byte	'state',0
	.word	5706
	.byte	4,2,35,8,14
	.byte	'config',0
	.word	154
	.byte	2,2,35,12,0,10
	.word	5943
	.byte	9
	.word	6036
.L126:
	.byte	29
	.byte	'Os_ScheduleTableType_s',0,13,247,3,16,16,14
	.byte	'dynamic',0
	.word	6041
	.byte	4,2,35,0,14
	.byte	'counter',0
	.word	5685
	.byte	4,2,35,4,14
	.byte	'repeat',0
	.word	137
	.byte	1,2,35,8,14
	.byte	'config',0
	.word	154
	.byte	2,2,35,10,14
	.byte	'initial',0
	.word	137
	.byte	1,2,35,12,14
	.byte	'access',0
	.word	137
	.byte	1,2,35,13,14
	.byte	'application',0
	.word	137
	.byte	1,2,35,14,0,21
	.byte	'Os_ScheduleTableType',0,13,255,3,3
	.word	6046
	.byte	9
	.word	6046
	.byte	10
	.word	6226
	.byte	9
	.word	5523
	.byte	10
	.word	6236
	.byte	34
	.word	3350
	.byte	34
	.word	4289
	.byte	34
	.word	4186
	.byte	34
	.word	4847
	.byte	34
	.word	4353
	.byte	34
	.word	137
	.byte	34
	.word	4847
	.byte	29
	.byte	'Os_ControlledCoreType_s',0,13,251,6,16,112,14
	.byte	'TrapInfo',0
	.word	2781
	.byte	8,2,35,0,14
	.byte	'lock_taskaccess',0
	.word	6246
	.byte	4,2,35,8,14
	.byte	'ReadyTasks',0
	.word	6251
	.byte	4,2,35,12,14
	.byte	'RunningISR',0
	.word	6256
	.byte	4,2,35,16,14
	.byte	'RunningTask',0
	.word	6261
	.byte	4,2,35,20,14
	.byte	'RunningTPMask',0
	.word	6266
	.byte	4,2,35,24,14
	.byte	'CurrentMeteredObject',0
	.word	3872
	.byte	4,2,35,28,14
	.byte	'IdleMeter',0
	.word	3669
	.byte	48,2,35,32,14
	.byte	'AppAccess',0
	.word	137
	.byte	1,2,35,80,14
	.byte	'AppOverride',0
	.word	6271
	.byte	1,2,35,81,14
	.byte	'GetStackValueAdjust',0
	.word	2952
	.byte	8,2,35,84,14
	.byte	'InErrorHook',0
	.word	137
	.byte	1,2,35,92,14
	.byte	'ChainTaskRef',0
	.word	6276
	.byte	4,2,35,96,14
	.byte	'GetStackUsageAdjust',0
	.word	2952
	.byte	8,2,35,100,14
	.byte	'InProtectionHook',0
	.word	137
	.byte	1,2,35,108,14
	.byte	'CoreIsActive',0
	.word	137
	.byte	1,2,35,109,14
	.byte	'InShutdownHook',0
	.word	137
	.byte	1,2,35,110,0,21
	.byte	'Os_ControlledCoreType',0,13,141,7,3
	.word	6281
	.byte	10
	.word	2339
	.byte	9
	.word	4017
	.byte	10
	.word	6737
	.byte	9
	.word	4587
	.byte	10
	.word	6747
	.byte	10
	.word	3669
	.byte	29
	.byte	'Os_AnyCoreType_s',0,13,151,7,16,96,14
	.byte	'DisableAllImask',0
	.word	2339
	.byte	4,2,35,0,14
	.byte	'SuspendAllImask',0
	.word	2339
	.byte	4,2,35,4,14
	.byte	'SuspendOSImask',0
	.word	2339
	.byte	4,2,35,8,14
	.byte	'DisableAllCount',0
	.word	2339
	.byte	4,2,35,12,14
	.byte	'SuspendAllCount',0
	.word	2339
	.byte	4,2,35,16,14
	.byte	'SuspendOSCount',0
	.word	2339
	.byte	4,2,35,20,14
	.byte	'RestartJumpBuf',0
	.word	2901
	.byte	68,2,35,24,14
	.byte	'Restartable',0
	.word	137
	.byte	1,2,35,92,0,21
	.byte	'Os_AnyCoreType',0,13,160,7,3
	.word	6762
	.byte	21
	.byte	'Can_TxObjPriorityClassType',0,14,219,3,16
	.word	2339
	.byte	29
	.byte	'Can_TxHwObjectConfigType',0,14,231,3,16,8,14
	.byte	'MsgObjId',0
	.word	137
	.byte	1,2,35,0,14
	.byte	'HwControllerId',0
	.word	137
	.byte	1,2,35,1,14
	.byte	'TxObjPriorityClass',0
	.word	2339
	.byte	4,2,35,4,0,21
	.byte	'Can_TxHwObjectConfigType',0,14,252,3,3
	.word	7039
	.byte	29
	.byte	'Can_RxHwObjectConfigType',0,14,129,4,16,12,14
	.byte	'MaskRef',0
	.word	2339
	.byte	4,2,35,0,14
	.byte	'MsgId',0
	.word	2339
	.byte	4,2,35,4,14
	.byte	'MsgObjId',0
	.word	137
	.byte	1,2,35,8,14
	.byte	'HwControllerId',0
	.word	137
	.byte	1,2,35,9,0,21
	.byte	'Can_RxHwObjectConfigType',0,14,147,4,3
	.word	7175
	.byte	26,4
	.word	137
	.byte	27,3,0,29
	.byte	'Can_ControllerMOMapConfigType',0,14,181,4,16,4,14
	.byte	'ControllerMOMap',0
	.word	7315
	.byte	4,2,35,0,0,21
	.byte	'Can_ControllerMOMapConfigType',0,14,184,4,3
	.word	7324
	.byte	29
	.byte	'Can_NPCRValueType',0,14,188,4,16,2,14
	.byte	'Can_NPCRValue',0
	.word	154
	.byte	2,2,35,0,0,21
	.byte	'Can_NPCRValueType',0,14,191,4,3
	.word	7425
	.byte	29
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,14,194,4,16,8,14
	.byte	'CanControllerBaudrate',0
	.word	2339
	.byte	4,2,35,0,14
	.byte	'CanControllerBaudrateCfg',0
	.word	154
	.byte	2,2,35,4,0,21
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,14,198,4,3
	.word	7500
	.byte	9
	.word	7500
	.byte	10
	.word	7665
	.byte	29
	.byte	'Can_BaudrateConfigPtrType',0,14,201,4,16,4,14
	.byte	'Can_kBaudrateConfigPtr',0
	.word	7670
	.byte	4,2,35,0,0,21
	.byte	'Can_BaudrateConfigPtrType',0,14,204,4,3
	.word	7675
	.byte	29
	.byte	'Can_EventHandlingType',0,14,226,4,16,4,14
	.byte	'CanEventType',0
	.word	7315
	.byte	4,2,35,0,0,21
	.byte	'Can_EventHandlingType',0,14,229,4,3
	.word	7775
	.byte	21
	.byte	'Rte_TransformerErrorCode',0,15,130,1,15
	.word	137
	.byte	21
	.byte	'Rte_TransformerClass',0,15,131,1,15
	.word	137
	.byte	13,15,168,1,9,12,14
	.byte	'in',0
	.word	1536
	.byte	4,2,35,0,14
	.byte	'out',0
	.word	1536
	.byte	4,2,35,4,14
	.byte	'used',0
	.word	154
	.byte	2,2,35,8,14
	.byte	'lost_data',0
	.word	137
	.byte	1,2,35,10,0,21
	.byte	'Rte_QDynType',0,15,173,1,3
	.word	7921
	.byte	3,15,175,1,9,4,4
	.byte	'RTE_DRA',0,0,4
	.byte	'RTE_WOWP',0,1,4
	.byte	'RTE_TASK',0,2,4
	.byte	'RTE_ARE',0,3,4
	.byte	'RTE_EV',0,4,4
	.byte	'RTE_MSI',0,5,0,21
	.byte	'Rte_NotificationType',0,15,182,1,3
	.word	8008
	.byte	10
	.word	7921
	.byte	29
	.byte	'Rte_QCmnType',0,15,184,1,16,24,14
	.byte	'dynamic',0
	.word	8106
	.byte	4,2,35,0,14
	.byte	'copy',0
	.word	137
	.byte	1,2,35,4,14
	.byte	'queue_size',0
	.word	154
	.byte	2,2,35,6,14
	.byte	'element_size',0
	.word	154
	.byte	2,2,35,8,14
	.byte	'buffer_start',0
	.word	1536
	.byte	4,2,35,12,14
	.byte	'buffer_end',0
	.word	1536
	.byte	4,2,35,16,14
	.byte	'notification_type',0
	.word	8008
	.byte	4,2,35,20,0,21
	.byte	'Rte_QCmnType',0,15,192,1,3
	.word	8111
	.byte	21
	.byte	'Rte_AlarmRefType',0,15,224,1,32
	.word	2339
	.byte	21
	.byte	'Rte_AlarmIndexType',0,15,226,1,32
	.word	154
	.byte	26,128,8
	.word	137
	.byte	27,255,7,0,21
	.byte	'Impl_NVM_DstPtrType_1024',0,16,50,15
	.word	8349
	.byte	21
	.byte	'CanIf_u32_impl',0,16,69,16
	.word	2339
	.byte	21
	.byte	'CanIf_u16_impl',0,16,71,16
	.word	154
	.byte	21
	.byte	'CanIf_u8_impl',0,16,73,15
	.word	137
	.byte	21
	.byte	'CanIf_ControllerModeType_Enum_impl',0,16,88,15
	.word	137
	.byte	21
	.byte	'CanIf_PduModeType_Enum_impl',0,16,90,15
	.word	137
	.byte	13,16,92,9,2,14
	.byte	'DeviceMode',0
	.word	137
	.byte	1,2,35,0,14
	.byte	'ChannelMode',0
	.word	137
	.byte	1,2,35,1,0,21
	.byte	'CanIf_ControllerStateType_struct_impl',0,16,95,3
	.word	8540
	.byte	21
	.byte	'CanIf_NotifStatusType_Enum_impl',0,16,100,15
	.word	137
	.byte	21
	.byte	'CanSM_boolean_Impl',0,16,120,15
	.word	137
	.byte	21
	.byte	'CanSM_u8_Impl',0,16,123,15
	.word	137
	.byte	21
	.byte	'CanSM_BusOffRecoveryStateType_Enum_impl',0,16,128,1,15
	.word	137
	.byte	21
	.byte	'CanSM_NetworkModeStateType_Enum_impl',0,16,132,1,15
	.word	137
	.byte	21
	.byte	'CanSM_u16_Impl',0,16,136,1,16
	.word	154
	.byte	21
	.byte	'CanSM_TimerStateType_Enum_impl',0,16,138,1,15
	.word	137
	.byte	13,16,140,1,9,4,14
	.byte	'cntTick_u16',0
	.word	154
	.byte	2,2,35,0,14
	.byte	'stTimer',0
	.word	137
	.byte	1,2,35,2,0,21
	.byte	'CanSM_TimerConfig_tst_struct_impl',0,16,143,1,3
	.word	8881
	.byte	21
	.byte	'Com_impl_u16',0,16,154,1,16
	.word	154
	.byte	21
	.byte	'Com_impl_u8',0,16,157,1,15
	.word	137
	.byte	21
	.byte	'ComM_uint32_Impl',0,16,173,1,16
	.word	2339
	.byte	21
	.byte	'ComM_uint16_Impl',0,16,175,1,16
	.word	154
	.byte	21
	.byte	'ComM_uint8_Impl',0,16,177,1,15
	.word	137
	.byte	21
	.byte	'ComM_bool_Impl',0,16,179,1,15
	.word	137
	.byte	13,16,181,1,9,24,14
	.byte	'ChannelState_e',0
	.word	2339
	.byte	4,2,35,0,14
	.byte	'LightTimeoutCtr_u32',0
	.word	2339
	.byte	4,2,35,4,14
	.byte	'MinFullComTimeoutCtr_u16',0
	.word	154
	.byte	2,2,35,8,14
	.byte	'ChannelMode_u8',0
	.word	137
	.byte	1,2,35,10,14
	.byte	'BusSmMode_u8',0
	.word	137
	.byte	1,2,35,11,14
	.byte	'UserRequestCtr_u8',0
	.word	137
	.byte	1,2,35,12,14
	.byte	'PassiveRequestState_u8',0
	.word	137
	.byte	1,2,35,13,14
	.byte	'PncRequestCtr_u8',0
	.word	137
	.byte	1,2,35,14,14
	.byte	'InhibitionReqStatus_u8',0
	.word	137
	.byte	1,2,35,15,14
	.byte	'NmNetworkRequestStatus_b',0
	.word	137
	.byte	1,2,35,16,14
	.byte	'DiagnosticRequestState_b',0
	.word	137
	.byte	1,2,35,17,14
	.byte	'CommunicationAllowed_b',0
	.word	137
	.byte	1,2,35,18,14
	.byte	'NmBusSleepIndicationStatus_b',0
	.word	137
	.byte	1,2,35,19,14
	.byte	'NmPrepareBusSleepIndicationStatus_b',0
	.word	137
	.byte	1,2,35,20,14
	.byte	'NmNetworkModeStatus_b',0
	.word	137
	.byte	1,2,35,21,0,21
	.byte	'ComM_ChannelStruct_Impl',0,16,197,1,3
	.word	9113
	.byte	13,16,206,1,9,10,14
	.byte	'WakeUpInhibitionCtr_u16',0
	.word	154
	.byte	2,2,35,0,14
	.byte	'LimitToNoComCtr_u16',0
	.word	154
	.byte	2,2,35,2,14
	.byte	'RequestedUserMode_t',0
	.word	137
	.byte	1,2,35,4,14
	.byte	'IndicatedUserMode_t',0
	.word	137
	.byte	1,2,35,5,14
	.byte	'numChannelsInFullCom_u8',0
	.word	137
	.byte	1,2,35,6,14
	.byte	'numChannelsInSilentCom_u8',0
	.word	137
	.byte	1,2,35,7,14
	.byte	'numChannelsInNoCom_u8',0
	.word	137
	.byte	1,2,35,8,0,21
	.byte	'ComM_UserStruct_Impl',0,16,214,1,3
	.word	9617
	.byte	21
	.byte	'Dcm_IOOperationResponseType',0,16,252,1,15
	.word	137
	.byte	21
	.byte	'Dcm_RequestDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspRequestRoutineResultsOutSignal_0PrimitivType',0
	.byte	16,138,2,15
	.word	137
	.byte	21
	.byte	'Dcm_StartDataIn_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineInSignalPrimitivType',0,16,146,2,15
	.word	137
	.byte	21
	.byte	'Dcm_StartDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineOutSignalPrimitivType',0,16,150,2,15
	.word	137
	.byte	21
	.byte	'Dcm_StopDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStopRoutineOutSignalPrimitivType',0,16,154,2,15
	.word	137
	.byte	21
	.byte	'NvM_BlockIdType',0,16,215,2,16
	.word	154
	.byte	21
	.byte	'NvM_RequestResultType',0,16,225,2,15
	.word	137
	.byte	21
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockNative_1024_Type',0,16,243,3,34
	.word	8360
	.byte	26,128,8
	.word	137
	.byte	27,255,7,0,21
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockRedundant_1024_Type',0,16,246,3,34
	.word	8360
	.byte	3,17,31,9,4,4
	.byte	'MEMIF_JOB_OK',0,0,4
	.byte	'MEMIF_JOB_FAILED',0,1,4
	.byte	'MEMIF_JOB_PENDING',0,2,4
	.byte	'MEMIF_JOB_CANCELED',0,3,4
	.byte	'MEMIF_BLOCK_INCONSISTENT',0,4,4
	.byte	'MEMIF_BLOCK_INVALID',0,5,0,21
	.byte	'MemIf_JobResultType',0,17,39,2
	.word	10491
	.byte	21
	.byte	'NvM_BlockManagementType',0,2,45,3
	.word	839
	.byte	3,2,49,9,4,4
	.byte	'NVM_PRV_ACTIVITY_NOT_INIT',0,0,4
	.byte	'NVM_PRV_ACTIVITY_IDLE',0,1,4
	.byte	'NVM_PRV_ACTIVITY_ARBITRATE',0,2,4
	.byte	'NVM_PRV_ACTIVITY_JOB_START',0,3,4
	.byte	'NVM_PRV_ACTIVITY_POLL_RESULT',0,4,4
	.byte	'NVM_PRV_ACTIVITY_JOB_COMPLETE',0,5,4
	.byte	'NVM_PRV_ACTIVITY_RESULT_EVAL',0,6,0,21
	.byte	'NvM_Prv_Activities_ten',0,2,58,3
	.word	10681
	.byte	3,2,104,9,4,4
	.byte	'NvM_Prv_idJob_Idle_e',0,0,4
	.byte	'NvM_Prv_idJob_Read_e',0,1,4
	.byte	'NvM_Prv_idJob_Write_e',0,2,4
	.byte	'NvM_Prv_idJob_Erase_e',0,3,4
	.byte	'NvM_Prv_idJob_Restore_e',0,4,4
	.byte	'NvM_Prv_idJob_Maintain_e',0,5,4
	.byte	'NvM_Prv_idJob_Validate_e',0,6,4
	.byte	'NvM_Prv_idJob_Invalidate_e',0,7,4
	.byte	'NvM_Prv_idJob_ReadIdConfigForReadAll_e',0,8,4
	.byte	'NvM_Prv_idJob_InvalidateForFirstInitAll_e',0,9,4
	.byte	'NvM_Prv_idJob_RestoreForImplicitRecovery_e',0,10,4
	.byte	'NvM_Prv_idJob_InvalidateForRemoveNonResistant_e',0,11,4
	.byte	'NvM_Prv_idJob_Invalid_e',0,12,4
	.byte	'NvM_Prv_idJob_Count_e',0,13,0,21
	.byte	'NvM_Prv_idJob_ten',0,2,115,3
	.word	10922
	.byte	21
	.byte	'NvM_Prv_ServiceBit_tuo',0,2,168,1,16
	.word	154
	.byte	21
	.byte	'NvM_Prv_idService_tuo',0,2,173,1,15
	.word	137
	.byte	21
	.byte	'NvM_Prv_idQueue_tuo',0,2,206,1,15
	.word	137
	.byte	21
	.byte	'NvM_Prv_QueueEntry_tst',0,2,225,1,3
	.word	1541
	.byte	10
	.word	137
	.byte	13,2,227,1,9,20,14
	.byte	'idJob_en',0
	.word	10922
	.byte	4,2,35,0,14
	.byte	'idBlock_uo',0
	.word	154
	.byte	2,2,35,4,14
	.byte	'RamBlock_pu8',0
	.word	11511
	.byte	4,2,35,8,14
	.byte	'idxDataset_u8',0
	.word	137
	.byte	1,2,35,12,14
	.byte	'Result_en',0
	.word	10491
	.byte	4,2,35,16,0,21
	.byte	'NvM_Prv_JobData_tst',0,2,240,1,3
	.word	11516
	.byte	21
	.byte	'rba_BswSrv_uint64',0,18,66,28
	.word	2370
	.byte	21
	.byte	'Rte_TaskRefType',0,19,184,1,32
	.word	4847
	.byte	21
	.byte	'Rte_EventRefType',0,19,185,1,32
	.word	137
	.byte	21
	.byte	'Rte_EventType',0,19,186,1,32
	.word	2339
	.byte	21
	.byte	'Rte_REActCounterType',0,19,252,1,15
	.word	137
	.byte	10
	.word	137
	.byte	21
	.byte	'Rte_REActCounterRefType',0,19,253,1,58
	.word	11784
	.byte	13,19,255,1,9,8,14
	.byte	'task',0
	.word	11680
	.byte	4,2,35,0,14
	.byte	'acnt',0
	.word	11789
	.byte	4,2,35,4,0,21
	.byte	'Rte_REContainerType',0,19,130,2,3
	.word	11822
	.byte	9
	.word	4587
	.byte	10
	.word	11886
	.byte	10
	.word	137
	.byte	9
	.word	11822
	.byte	10
	.word	11901
	.byte	21
	.byte	'Rte_REContainerRefType',0,19,132,2,60
	.word	11906
	.byte	21
	.byte	'Rte_MSICounterType',0,19,149,2,16
	.word	154
	.byte	10
	.word	154
	.byte	21
	.byte	'Rte_MSICounterRefType',0,19,150,2,56
	.word	11971
	.byte	21
	.byte	'Rte_MSIPendingFlagType',0,19,152,2,17
	.word	137
	.byte	10
	.word	137
	.byte	21
	.byte	'Rte_MSIPendingFlagRefType',0,19,153,2,60
	.word	12039
	.byte	13,19,163,2,9,24,14
	.byte	'counter',0
	.word	11976
	.byte	4,2,35,0,14
	.byte	'incCounter',0
	.word	137
	.byte	1,2,35,4,14
	.byte	'pending',0
	.word	12044
	.byte	4,2,35,8,14
	.byte	'osTask',0
	.word	11680
	.byte	4,2,35,12,14
	.byte	'acnt',0
	.word	11789
	.byte	4,2,35,16,14
	.byte	'osEvent',0
	.word	137
	.byte	1,2,35,20,14
	.byte	'MSIInit',0
	.word	154
	.byte	2,2,35,22,0,21
	.byte	'Rte_MSITableEntry',0,19,172,2,3
	.word	12079
	.byte	10
	.word	154
	.byte	10
	.word	137
	.byte	21
	.byte	'Rte_TaskArrayIndex',0,19,179,2,16
	.word	137
	.byte	21
	.byte	'Rte_NrWaitingTasks',0,19,180,2,16
	.word	137
	.byte	13,19,182,2,9,4,14
	.byte	'pending',0
	.word	137
	.byte	1,2,35,0,14
	.byte	'count',0
	.word	137
	.byte	1,2,35,1,14
	.byte	'firstWaitingTask',0
	.word	137
	.byte	1,2,35,2,0,21
	.byte	'Rte_WaitableDatum',0,19,186,2,3
	.word	12297
	.byte	10
	.word	12297
	.byte	13,19,226,2,9,12,14
	.byte	'event_id',0
	.word	2339
	.byte	4,2,35,0,14
	.byte	'wd',0
	.word	12389
	.byte	4,2,35,4,14
	.byte	'timeout',0
	.word	2339
	.byte	4,2,35,8,0,21
	.byte	'Rte_WOWP_NotificationType',0,19,230,2,3
	.word	12394
	.byte	9
	.word	12394
	.byte	10
	.word	12483
	.byte	21
	.byte	'Rte_WOWP_NotificationRefType',0,19,232,2,66
	.word	12488
	.byte	21
	.byte	'Rte_ARE_NotificationType',0,19,234,2,29
	.word	11822
	.byte	29
	.byte	'Rte_QTaskType',0,19,243,2,16,28,14
	.byte	'cmn',0
	.word	8111
	.byte	24,2,35,0,14
	.byte	'task',0
	.word	11680
	.byte	4,2,35,24,0,21
	.byte	'Rte_QTaskType',0,19,246,2,3
	.word	12565
	.byte	29
	.byte	'Rte_QREType',0,19,250,2,16,28,14
	.byte	'cmn',0
	.word	8111
	.byte	24,2,35,0,14
	.byte	're',0
	.word	11911
	.byte	4,2,35,24,0,21
	.byte	'Rte_QREType',0,19,253,2,3
	.word	12636
	.byte	9
	.word	11822
	.byte	10
	.word	12701
	.byte	29
	.byte	'Rte_QWWPType',0,19,129,3,16,28,14
	.byte	'cmn',0
	.word	8111
	.byte	24,2,35,0,14
	.byte	'wwp',0
	.word	12493
	.byte	4,2,35,24,0,21
	.byte	'Rte_QWWPType',0,19,132,3,3
	.word	12711
	.byte	9
	.word	12394
	.byte	10
	.word	12779
	.byte	29
	.byte	'Rte_QEvType',0,19,136,3,16,36,14
	.byte	'cmn',0
	.word	8111
	.byte	24,2,35,0,14
	.byte	'task',0
	.word	11680
	.byte	4,2,35,24,14
	.byte	'mask',0
	.word	137
	.byte	1,2,35,28,14
	.byte	'acnt',0
	.word	11789
	.byte	4,2,35,32,0,21
	.byte	'Rte_QEvType',0,19,141,3,3
	.word	12789
	.byte	29
	.byte	'Rte_QMSIType',0,19,145,3,16,48,14
	.byte	'cmn',0
	.word	8111
	.byte	24,2,35,0,14
	.byte	'task',0
	.word	11680
	.byte	4,2,35,24,14
	.byte	'mask',0
	.word	137
	.byte	1,2,35,28,14
	.byte	'acnt',0
	.word	11789
	.byte	4,2,35,32,14
	.byte	'msiCounter',0
	.word	11976
	.byte	4,2,35,36,14
	.byte	'msiPending',0
	.word	12044
	.byte	4,2,35,40,14
	.byte	'msiLimit',0
	.word	154
	.byte	2,2,35,44,0,21
	.byte	'Rte_QMSIType',0,19,153,3,3
	.word	12884
	.byte	19
	.word	137
	.byte	1,1,20
	.word	1536
	.byte	0,10
	.word	13039
	.byte	21
	.byte	'NvM_Prv_ExplicitSync_Copy_tpfct',0,1,29,26
	.word	13052
	.byte	21
	.byte	'NvM_Prv_BlockConfiguration_ten',0,1,85,3
	.word	176
	.byte	9
	.word	154
	.byte	10
	.word	13136
	.byte	9
	.word	1536
	.byte	10
	.word	13146
	.byte	19
	.word	137
	.byte	1,1,20
	.word	137
	.byte	20
	.word	137
	.byte	0,10
	.word	13156
	.byte	19
	.word	137
	.byte	1,1,20
	.word	137
	.byte	0,10
	.word	13179
	.byte	10
	.word	5345
	.byte	13,1,121,9,48,14
	.byte	'idBlockMemIf_u16',0
	.word	154
	.byte	2,2,35,0,14
	.byte	'nrBlockBytes_pu16',0
	.word	13141
	.byte	4,2,35,4,14
	.byte	'idxDevice_u8',0
	.word	137
	.byte	1,2,35,8,14
	.byte	'nrNvBlocks_u8',0
	.word	137
	.byte	1,2,35,9,14
	.byte	'nrRomBlocks_u8',0
	.word	137
	.byte	1,2,35,10,14
	.byte	'adrRamBlock_ppv',0
	.word	13151
	.byte	4,2,35,12,14
	.byte	'adrRomBlock_pcv',0
	.word	1037
	.byte	4,2,35,16,14
	.byte	'SingleBlockCallback_pfct',0
	.word	13174
	.byte	4,2,35,20,14
	.byte	'SingleBlockStartCallback_pfct',0
	.word	13192
	.byte	4,2,35,24,14
	.byte	'InitBlockCallback_pfct',0
	.word	13197
	.byte	4,2,35,28,14
	.byte	'ReadRamBlockFromNvm_pfct',0
	.word	13052
	.byte	4,2,35,32,14
	.byte	'WriteRamBlockToNvm_pfct',0
	.word	13052
	.byte	4,2,35,36,14
	.byte	'BlockManagementType_en',0
	.word	839
	.byte	4,2,35,40,14
	.byte	'JobPriority_u8',0
	.word	137
	.byte	1,2,35,44,14
	.byte	'stFlags_u16',0
	.word	154
	.byte	2,2,35,46,0,21
	.byte	'NvM_Prv_BlockDescriptor_tst',0,1,138,2,3
	.word	13202
	.byte	26,160,5
	.word	13202
	.byte	27,13,0,9
	.word	13666
	.byte	35
	.byte	'NvM_Prv_BlockDescriptors_acst',0,1,169,2,45
	.word	13676
	.byte	1,1,26,14
	.word	137
	.byte	27,13,0,35
	.byte	'NvM_Prv_stBlock_rAwAM_au8',0,3,59,14
	.word	13722
	.byte	1,1,26,28
	.word	154
	.byte	27,13,0,35
	.byte	'NvM_Prv_stRequests_rAMwAM_au16',0,3,68,15
	.word	13767
	.byte	1,1,26,14
	.word	137
	.byte	27,13,0,35
	.byte	'NvM_Prv_stRequestResult_rAwAM_au8',0,3,77,30
	.word	13817
	.byte	1,1,0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L33:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,36,0,3,8,11,15,62,15,0,0,3,4,1,58,15,59,15,57,15,11,15
	.byte	0,0,4,40,0,3,8,28,13,0,0,5,46,1,3,8,32,13,58,15,59,15,57,15,73,19,54,15,39,12,0,0,6,5,0,3,8,58,15,59,15
	.byte	57,15,73,19,0,0,7,11,0,0,0,8,59,0,3,8,0,0,9,38,0,73,19,0,0,10,15,0,73,19,0,0,11,11,1,0,0,12,46,1,3,8,32
	.byte	13,58,15,59,15,57,15,54,15,39,12,0,0,13,19,1,58,15,59,15,57,15,11,15,0,0,14,13,0,3,8,73,19,11,15,56,9
	.byte	0,0,15,46,1,3,8,58,15,59,15,57,15,54,15,39,12,63,12,60,12,0,0,16,46,1,3,8,58,15,59,15,57,15,73,19,54,15
	.byte	39,12,63,12,60,12,0,0,17,46,1,49,19,0,0,18,5,0,49,19,0,0,19,21,1,73,19,54,15,39,12,0,0,20,5,0,73,19,0
	.byte	0,21,22,0,3,8,58,15,59,15,57,15,73,19,0,0,22,29,1,49,19,0,0,23,11,0,49,19,0,0,24,46,0,3,8,58,15,59,15
	.byte	57,15,54,15,63,12,60,12,0,0,25,21,0,54,15,0,0,26,1,1,11,15,73,19,0,0,27,33,0,47,15,0,0,28,21,0,54,15,39
	.byte	12,0,0,29,19,1,3,8,58,15,59,15,57,15,11,15,0,0,30,21,1,54,15,39,12,0,0,31,23,1,58,15,59,15,57,15,11,15
	.byte	0,0,32,4,1,3,8,58,15,59,15,57,15,11,15,0,0,33,21,0,73,19,54,15,39,12,0,0,34,53,0,73,19,0,0,35,52,0,3,8
	.byte	58,15,59,15,57,15,73,19,63,12,60,12,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L34:
	.word	.L128-.L127
.L127:
	.half	3
	.word	.L130-.L129
.L129:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockDescriptor.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\NvM\\api\\NvM_Types.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockData.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\BswM\\api\\BswM_NvM.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_Queue.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_ErrorDetection.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ReadAll.c',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Platform\\Platform_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Std_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Can_GeneralTypes.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\RTOS_T\\Gen\\inc\\Os.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Can_17_MCanP\\inc\\Can_17_MCanP.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Type.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\MemIf\\api\\MemIf_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\rba_BswSrv.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Intl.h',0,0,0,0,0
.L130:
.L128:
	.sdecl	'.debug_info',debug,cluster('NvM_ReadAll')
	.sect	'.debug_info'
.L35:
	.word	343
	.half	3
	.word	.L36
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ReadAll.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L38,.L37
	.byte	2
	.word	.L31
	.byte	3
	.byte	'NvM_ReadAll',0,1,82,6,1,1,1
	.word	.L24,.L55,.L23
	.byte	4
	.word	.L24,.L55
	.byte	4
	.word	.L56,.L2
	.byte	5
	.byte	'isRequestEnqueued_b',0,1,92,17
	.word	.L57,.L58
	.byte	5
	.byte	'QueueEntry_st',0,1,94,32
	.word	.L59,.L60
	.byte	6
	.word	.L61,.L62,.L63
	.byte	7
	.word	.L64,.L65
	.byte	7
	.word	.L66,.L67
	.byte	8
	.word	.L68,.L62,.L63
	.byte	0,6
	.word	.L69,.L70,.L71
	.byte	7
	.word	.L72,.L73
	.byte	7
	.word	.L74,.L75
	.byte	8
	.word	.L76,.L70,.L71
	.byte	0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_ReadAll')
	.sect	'.debug_abbrev'
.L36:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,11,1,17,1,18,1,0,0,5,52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,6,29,1
	.byte	49,16,17,1,18,1,0,0,7,5,0,49,16,2,6,0,0,8,11,0,49,16,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_ReadAll')
	.sect	'.debug_line'
.L37:
	.word	.L132-.L131
.L131:
	.half	3
	.word	.L134-.L133
.L133:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ReadAll.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockData.h',0,0,0,0,0
.L134:
	.byte	5,6,7,0,5,2
	.word	.L24
	.byte	3,209,0,1,5,49,9
	.half	.L116-.L24
	.byte	3,8,1,5,74,9
	.half	.L135-.L116
	.byte	1,5,5,9
	.half	.L136-.L135
	.byte	1,5,38,7,9
	.half	.L56-.L136
	.byte	3,5,1,5,36,9
	.half	.L137-.L56
	.byte	1,9
	.half	.L138-.L137
	.byte	3,1,1,5,34,9
	.half	.L139-.L138
	.byte	1,5,39,9
	.half	.L140-.L139
	.byte	3,1,1,5,37,9
	.half	.L141-.L140
	.byte	1,5,38,9
	.half	.L142-.L141
	.byte	3,1,1,5,36,9
	.half	.L143-.L142
	.byte	1,5,60,9
	.half	.L144-.L143
	.byte	3,5,1,5,86,9
	.half	.L145-.L144
	.byte	1,5,29,9
	.half	.L117-.L145
	.byte	1,5,9,9
	.half	.L119-.L117
	.byte	3,2,1,5,65,7,9
	.half	.L146-.L119
	.byte	3,4,1,4,2,5,5,9
	.half	.L62-.L146
	.byte	3,211,0,1,5,38,9
	.half	.L147-.L62
	.byte	1,5,51,9
	.half	.L148-.L147
	.byte	1,4,1,5,38,9
	.half	.L63-.L148
	.byte	3,176,127,1,5,72,9
	.half	.L149-.L63
	.byte	1,4,2,5,5,9
	.half	.L70-.L149
	.byte	3,213,0,1,5,35,9
	.half	.L150-.L70
	.byte	1,5,52,9
	.half	.L151-.L150
	.byte	1,5,55,9
	.half	.L118-.L151
	.byte	1,5,48,9
	.half	.L152-.L118
	.byte	1,4,1,5,53,9
	.half	.L71-.L152
	.byte	3,173,127,1,5,9,9
	.half	.L3-.L71
	.byte	3,11,1,5,41,7,9
	.half	.L153-.L3
	.byte	3,2,1,5,53,9
	.half	.L154-.L153
	.byte	3,1,1,5,37,9
	.half	.L155-.L154
	.byte	3,5,1,5,62,9
	.half	.L156-.L155
	.byte	1,5,1,9
	.half	.L2-.L156
	.byte	3,4,1,7,9
	.half	.L39-.L2
	.byte	0,1,1
.L132:
	.sdecl	'.debug_ranges',debug,cluster('NvM_ReadAll')
	.sect	'.debug_ranges'
.L38:
	.word	-1,.L24,0,.L39-.L24,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_IsSanitizedByReadAll')
	.sect	'.debug_info'
.L40:
	.word	265
	.half	3
	.word	.L41
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ReadAll.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L43,.L42
	.byte	2
	.word	.L31
	.byte	3
	.byte	'NvM_Prv_IsSanitizedByReadAll',0,1,224,1,9
	.word	.L57
	.byte	1,1,1
	.word	.L30,.L77,.L29
	.byte	4
	.byte	'idBlock_uo',0,1,224,1,54
	.word	.L78,.L79
	.byte	5
	.word	.L30,.L77
	.byte	6
	.byte	'isReadAllInitiated_b',0,1,228,1,13
	.word	.L57,.L80
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_IsSanitizedByReadAll')
	.sect	'.debug_abbrev'
.L41:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_IsSanitizedByReadAll')
	.sect	'.debug_line'
.L42:
	.word	.L158-.L157
.L157:
	.half	3
	.word	.L160-.L159
.L159:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ReadAll.c',0,0,0,0,0
.L160:
	.byte	5,34,7,0,5,2
	.word	.L30
	.byte	3,227,1,1,5,5,9
	.half	.L125-.L30
	.byte	3,17,1,5,1,9
	.half	.L22-.L125
	.byte	3,1,1,7,9
	.half	.L44-.L22
	.byte	0,1,1
.L158:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_IsSanitizedByReadAll')
	.sect	'.debug_ranges'
.L43:
	.word	-1,.L30,0,.L44-.L30,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_IsBlockPartOfReadAll')
	.sect	'.debug_info'
.L45:
	.word	343
	.half	3
	.word	.L46
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ReadAll.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L48,.L47
	.byte	2
	.word	.L31
	.byte	3
	.byte	'NvM_Prv_IsBlockPartOfReadAll',0,1,139,1,16
	.word	.L57
	.byte	1,1
	.word	.L26,.L81,.L25
	.byte	4
	.byte	'idBlock_uo',0,1,139,1,61
	.word	.L78,.L82
	.byte	5
	.word	.L26,.L81
	.byte	6
	.byte	'isPRamBlockValid_b',0,1,141,1,13
	.word	.L57,.L83
	.byte	7
	.word	.L84,.L26,.L5
	.byte	8
	.word	.L85,.L86
	.byte	9
	.word	.L87,.L26,.L5
	.byte	0,7
	.word	.L88,.L89,.L90
	.byte	8
	.word	.L91,.L92
	.byte	8
	.word	.L93,.L94
	.byte	9
	.word	.L95,.L89,.L90
	.byte	0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_IsBlockPartOfReadAll')
	.sect	'.debug_abbrev'
.L46:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,52,0,3
	.byte	8,58,15,59,15,57,15,73,16,2,6,0,0,7,29,1,49,16,17,1,18,1,0,0,8,5,0,49,16,2,6,0,0,9,11,0,49,16,17,1,18
	.byte	1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_IsBlockPartOfReadAll')
	.sect	'.debug_line'
.L47:
	.word	.L162-.L161
.L161:
	.half	3
	.word	.L164-.L163
.L163:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ReadAll.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockData.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockDescriptor.h',0,0,0,0,0
.L164:
	.byte	4,2,5,14,7,0,5,2
	.word	.L26
	.byte	3,244,0,1,5,39,9
	.half	.L165-.L26
	.byte	1,5,52,9
	.half	.L166-.L165
	.byte	1,5,81,9
	.half	.L167-.L166
	.byte	1,5,5,9
	.half	.L168-.L167
	.byte	1,4,1,5,89,9
	.half	.L5-.L168
	.byte	3,30,1,5,49,9
	.half	.L169-.L5
	.byte	1,4,3,5,46,9
	.half	.L89-.L169
	.byte	3,223,1,1,5,13,9
	.half	.L170-.L89
	.byte	1,5,44,7,9
	.half	.L171-.L170
	.byte	3,1,1,5,15,9
	.half	.L172-.L171
	.byte	1,5,44,9
	.half	.L173-.L172
	.byte	1,5,56,9
	.half	.L174-.L173
	.byte	1,5,69,9
	.half	.L175-.L174
	.byte	1,5,46,9
	.half	.L176-.L175
	.byte	3,127,1,5,5,9
	.half	.L6-.L176
	.byte	1,4,1,5,13,9
	.half	.L8-.L6
	.byte	3,161,126,1,5,89,7,9
	.half	.L90-.L8
	.byte	1,5,5,9
	.half	.L9-.L90
	.byte	3,124,1,5,1,9
	.half	.L11-.L9
	.byte	3,12,1,7,9
	.half	.L49-.L11
	.byte	0,1,1
.L162:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_IsBlockPartOfReadAll')
	.sect	'.debug_ranges'
.L48:
	.word	-1,.L26,0,.L49-.L26,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_FindBlocksForReadAll')
	.sect	'.debug_info'
.L50:
	.word	461
	.half	3
	.word	.L51
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ReadAll.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L53,.L52
	.byte	2
	.word	.L31
	.byte	3
	.byte	'NvM_Prv_FindBlocksForReadAll',0,1,157,1,13,1,1
	.word	.L28,.L96,.L27
	.byte	4
	.word	.L28,.L96
	.byte	5
	.byte	'idBlock_uo',0,1,159,1,21
	.word	.L78,.L97
	.byte	6
	.word	.L98,.L13,.L99
	.byte	7
	.word	.L100,.L101
	.byte	8
	.word	.L102,.L13,.L99
	.byte	5
	.byte	'BlockSize_u16',0,2,191,3,12
	.word	.L78,.L103
	.byte	0,0,6
	.word	.L61,.L104,.L105
	.byte	7
	.word	.L64,.L106
	.byte	7
	.word	.L66,.L107
	.byte	9
	.word	.L68,.L104,.L105
	.byte	0,6
	.word	.L69,.L105,.L108
	.byte	7
	.word	.L72,.L109
	.byte	7
	.word	.L74,.L110
	.byte	9
	.word	.L76,.L105,.L108
	.byte	0,6
	.word	.L111,.L18,.L20
	.byte	7
	.word	.L112,.L113
	.byte	9
	.word	.L114,.L18,.L20
	.byte	0,6
	.word	.L61,.L115,.L17
	.byte	7
	.word	.L64,.L106
	.byte	7
	.word	.L66,.L107
	.byte	9
	.word	.L68,.L115,.L17
	.byte	0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_FindBlocksForReadAll')
	.sect	'.debug_abbrev'
.L51:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,17,1,18,1,64,6,0,0,4,11,1,17,1,18,1,0,0,5,52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,6,29,1,49,16
	.byte	17,1,18,1,0,0,7,5,0,49,16,2,6,0,0,8,11,1,49,16,17,1,18,1,0,0,9,11,0,49,16,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_FindBlocksForReadAll')
	.sect	'.debug_line'
.L52:
	.word	.L178-.L177
.L177:
	.half	3
	.word	.L180-.L179
.L179:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_ReadAll.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockDescriptor.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockData.h',0,0,0,0,0
.L180:
	.byte	5,21,7,0,5,2
	.word	.L28
	.byte	3,166,1,1,5,79,9
	.half	.L120-.L28
	.byte	1,4,2,5,26,9
	.half	.L13-.L120
	.byte	3,152,2,1,5,9,9
	.half	.L121-.L13
	.byte	3,2,1,5,51,7,9
	.half	.L181-.L121
	.byte	3,1,1,5,22,9
	.half	.L182-.L181
	.byte	1,5,51,9
	.half	.L183-.L182
	.byte	1,5,63,9
	.half	.L184-.L183
	.byte	1,5,10,9
	.half	.L185-.L184
	.byte	1,5,19,9
	.half	.L186-.L185
	.byte	1,5,25,7,9
	.half	.L187-.L186
	.byte	3,2,1,5,5,9
	.half	.L14-.L187
	.byte	3,3,1,4,1,5,9,9
	.half	.L16-.L14
	.byte	3,227,125,1,5,46,7,9
	.half	.L99-.L16
	.byte	3,2,1,5,13,9
	.half	.L124-.L99
	.byte	1,5,60,7,9
	.half	.L188-.L124
	.byte	3,6,1,4,3,5,5,9
	.half	.L104-.L188
	.byte	3,14,1,5,38,9
	.half	.L189-.L104
	.byte	1,5,51,9
	.half	.L190-.L189
	.byte	1,5,5,9
	.half	.L105-.L190
	.byte	3,5,1,5,35,9
	.half	.L191-.L105
	.byte	1,5,52,9
	.half	.L192-.L191
	.byte	1,5,55,9
	.half	.L193-.L192
	.byte	1,5,48,9
	.half	.L194-.L193
	.byte	1,4,1,5,76,9
	.half	.L108-.L194
	.byte	3,109,1,4,3,5,12,9
	.half	.L18-.L108
	.byte	3,116,1,5,45,9
	.half	.L195-.L18
	.byte	1,5,5,9
	.half	.L122-.L195
	.byte	1,4,1,5,17,9
	.half	.L20-.L122
	.byte	3,24,1,5,64,7,9
	.half	.L196-.L20
	.byte	3,2,1,4,3,5,38,9
	.half	.L115-.L196
	.byte	1,5,51,9
	.half	.L197-.L115
	.byte	1,4,1,5,81,9
	.half	.L17-.L197
	.byte	3,103,1,5,79,9
	.half	.L12-.L17
	.byte	1,5,1,7,9
	.half	.L198-.L12
	.byte	3,30,1,7,9
	.half	.L54-.L198
	.byte	0,1,1
.L178:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_FindBlocksForReadAll')
	.sect	'.debug_ranges'
.L53:
	.word	-1,.L28,0,.L54-.L28,0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_FindBlocksForReadAll')
	.sect	'.debug_loc'
.L103:
	.word	-1,.L28,.L121-.L28,.L122-.L28
	.half	1
	.byte	95
	.word	0,0
.L27:
	.word	-1,.L28,0,.L96-.L28
	.half	2
	.byte	138,0
	.word	0,0
.L107:
	.word	0,0
.L110:
	.word	0,0
.L97:
	.word	-1,.L28,.L120-.L28,.L96-.L28
	.half	1
	.byte	88
	.word	.L123-.L28,.L124-.L28
	.half	1
	.byte	84
	.word	0,0
.L113:
	.word	0,0
.L106:
	.word	0,0
.L109:
	.word	0,0
.L101:
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_IsBlockPartOfReadAll')
	.sect	'.debug_loc'
.L25:
	.word	-1,.L26,0,.L81-.L26
	.half	2
	.byte	138,0
	.word	0,0
.L94:
	.word	0,0
.L86:
	.word	0,0
.L82:
	.word	-1,.L26,0,.L81-.L26
	.half	1
	.byte	84
	.word	0,0
.L92:
	.word	0,0
.L83:
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_IsSanitizedByReadAll')
	.sect	'.debug_loc'
.L29:
	.word	-1,.L30,0,.L77-.L30
	.half	2
	.byte	138,0
	.word	0,0
.L79:
	.word	-1,.L30,0,.L77-.L30
	.half	1
	.byte	84
	.word	0,0
.L80:
	.word	-1,.L30,.L125-.L30,.L77-.L30
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_ReadAll')
	.sect	'.debug_loc'
.L23:
	.word	-1,.L24,0,.L116-.L24
	.half	2
	.byte	138,0
	.word	.L116-.L24,.L55-.L24
	.half	2
	.byte	138,16
	.word	.L55-.L24,.L55-.L24
	.half	2
	.byte	138,0
	.word	0,0
.L60:
	.word	-1,.L24,0,.L55-.L24
	.half	2
	.byte	145,112
	.word	0,0
.L67:
	.word	0,0
.L75:
	.word	0,0
.L65:
	.word	0,0
.L73:
	.word	0,0
.L58:
	.word	-1,.L24,.L117-.L24,.L118-.L24
	.half	1
	.byte	82
	.word	.L119-.L24,.L2-.L24
	.half	1
	.byte	95
	.word	0,0
	.sdecl	'.debug_frame',debug
	.sect	'.debug_frame'
.L199:
	.word	48
	.word	-1
	.byte	3,0,2,1,27,12,26,0,8,27,8,26,8,28,8,29,8,30,8,31,8,34,8,35,8,32,8,33,8,16,8,17,8,24,8,25,8,36,8,37,8,38
	.byte	8,39
	.sdecl	'.debug_frame',debug,cluster('NvM_ReadAll')
	.sect	'.debug_frame'
	.word	36
	.word	.L199,.L24,.L55-.L24
	.byte	4
	.word	(.L116-.L24)/2
	.byte	19,16,22,26,3,19,138,16,4
	.word	(.L55-.L116)/2
	.byte	19,0,8,26,0,0
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_IsBlockPartOfReadAll')
	.sect	'.debug_frame'
	.word	24
	.word	.L199,.L26,.L81-.L26
	.byte	8,18,8,19,8,20,8,21,8,22,8,23
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_FindBlocksForReadAll')
	.sect	'.debug_frame'
	.word	12
	.word	.L199,.L28,.L96-.L28
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_IsSanitizedByReadAll')
	.sect	'.debug_frame'
	.word	24
	.word	.L199,.L30,.L77-.L30
	.byte	8,18,8,19,8,20,8,21,8,22,8,23

; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   247  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   248  #if ((NVM_DYNAMIC_CONFIGURATION == STD_ON) && (NVM_RB_REMOVE_NON_RESISTANT_BLOCKS == STD_ON))
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   249  /**
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   250   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   251   * This function initializes the status of the ReadAll request.
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   252   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   253   * The status of the ReadAll request will be initialized with FALSE to indicate that ReadAll request has not been
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   254   * executed yet and potentially all blocks can contain incopatible data, s. NvM_Prv_IsSanitizedByReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   255   */
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   256  void NvM_Prv_InitializeStateReadAll(void)
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   257  {
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   258      NvM_Prv_isReadAllInitiated_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   259  }
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   260  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   261  
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   262  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_ReadAll.c	   263  #include "NvM_MemMap.h"

	; Module end
