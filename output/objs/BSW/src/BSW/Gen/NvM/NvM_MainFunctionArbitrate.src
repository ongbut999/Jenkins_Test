	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 19053136 SN 09001910"
	.compiler_invocation	"ctc -f cc15672a -c99 --integer-enumeration -D__CPU__=tc27x -D__CPU_TC27X__ --core=tc1.6.x --eabi-compliant --fp-model=-float -D_TASKING_C_TRICORE_=1 -I.\\output\\inc -g2 -t4 --language=-comments,-gcc,+volatile,-strings --default-near-size=0 -O2ROPYGKLF-predict --default-a1-size=0 --default-a0-size=0 --source --switch=auto -o output\\objs\\BSW\\src\\BSW\\Gen\\NvM\\NvM_MainFunctionArbitrate.src BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionArbitrate.c"
	.compiler_name		"ctc"
	;source	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionArbitrate.c'

	
$TC16X
	
	.sdecl	'.text.NvM_MainFunctionArbitrate.NvM_Prv_StartJob',code,cluster('NvM_Prv_StartJob')
	.sect	'.text.NvM_MainFunctionArbitrate.NvM_Prv_StartJob'
	.align	2
	
	.global	NvM_Prv_StartJob

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	     2  /*
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	     3   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	     4   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	     5   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	     6   */
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	     7  #include "NvM.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	     8  #include "Rte_NvM.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	     9  #include "NvM_Cfg_SchM.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    10  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    11  #include "NvM_Prv.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    12  #include "NvM_Prv_Queue.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    13  #include "NvM_Prv_BlockData.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    14  #include "NvM_Prv_ErrorDetection.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    15  #include "NvM_Prv_ProcessMultiBlock.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    16  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    17  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    18  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    19  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    20  /*
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    21   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    22   * Inline declarations
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    23   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    24   */
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    25  LOCAL_INLINE NvM_Prv_idJob_ten NvM_Prv_GetNextJob(NvM_Prv_idQueue_tuo* idQueueActive_puo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    26                                                    NvM_Prv_QueueEntry_tst* QueueEntry_pst);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    27  LOCAL_INLINE void NvM_Prv_UpdateBlockStatus(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    28                                              NvM_Prv_idJob_ten idJob_en,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    29                                              void const* RamBlock_pcv);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    30  LOCAL_INLINE uint8 NvM_Prv_GetIdxDatasetForJob(NvM_Prv_idJob_ten idJob_en,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    31                                                 NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    35   * NvM-private code
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    38  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    39  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    40  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    41  void NvM_Prv_StartJob(NvM_Prv_idJob_ten idJob_en,
; Function NvM_Prv_StartJob
.L31:
NvM_Prv_StartJob:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    42                        NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    43                        uint8* RamBlock_pu8,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    44                        uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    45  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    46      // Initialize data of the job to be started
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    47      NvM_Prv_Main_st.JobData_st.idJob_en = idJob_en;
	movh.a	a15,#@his(NvM_Prv_Main_st)
	lea	a15,[a15]@los(NvM_Prv_Main_st)
.L137:
	st.w	[a15]12,d4
.L138:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    48      // TRACE[NVM338] The job of NvM_WriteBlock writes to the NV block which is selected by the data index
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    49      //               when the block is of type DATASET
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    50      // TRACE[NVM339] Same as NVM338, applied to NvM_WriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    51      // TRACE[NVM340] The job of NvM_ReadBlock reads only the NV block selected by the data index
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    52      //               for a block of type DATASET
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    53      // (Fee/Ea block-ID for an NV-block of an NvM-block of type DATASET) = (Fee/Ea block-ID) + (NV-index)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    54      NvM_Prv_Main_st.JobData_st.idxDataset_u8 = idxDataset_u8;
	st.b	[a15]24,d6
.L139:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    55      NvM_Prv_Main_st.JobData_st.Result_en = MEMIF_JOB_PENDING;
	mov	d15,#2
.L140:
	st.w	[a15]28,d15
.L141:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    56      NvM_Prv_Main_st.JobData_st.idBlock_uo = idBlock_uo;
	st.h	[a15]16,d5
.L142:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    57      NvM_Prv_Main_st.JobData_st.RamBlock_pu8 = RamBlock_pu8;
	st.a	[a15]20,a4
.L143:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    58  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    59      NvM_Prv_Main_st.Activity_rAMwM_en = NVM_PRV_ACTIVITY_JOB_START;
	mov	d15,#3
.L144:
	st.w	[a15],d15
.L145:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    60  }
	ret
.L48:
	
__NvM_Prv_StartJob_function_end:
	.size	NvM_Prv_StartJob,__NvM_Prv_StartJob_function_end-NvM_Prv_StartJob
.L42:
	; End of function
	
	.sdecl	'.text.NvM_MainFunctionArbitrate.NvM_Prv_MainFunctionArbitrate',code,cluster('NvM_Prv_MainFunctionArbitrate')
	.sect	'.text.NvM_MainFunctionArbitrate.NvM_Prv_MainFunctionArbitrate'
	.align	2
	
	.global	NvM_Prv_MainFunctionArbitrate

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    61  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    63  /**
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    64   * This function determines the next request to be executed by checking all queues for entries to be started.
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    65   *
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    66   * All prioritizations of requests is done here.
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    67   * This function will be invoked by NvM_Mainfunction only if no other request is currently active.
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    68   *
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    69   * \param[global in,out] NvM_Prv_Main_st
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    70   * Global structure with all state information which is not block-specific.
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    71   *
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    72   */
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    73  void NvM_Prv_MainFunctionArbitrate(void)
; Function NvM_Prv_MainFunctionArbitrate
.L33:
NvM_Prv_MainFunctionArbitrate:	.type	func

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    74  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    75      // Perform request arbitration
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    76      NvM_Prv_Main_st.idQueueActive_uo = NvM_Prv_Queue_GetEntryToProcess(&NvM_Prv_Main_st.QueueEntry_pst);
	movh.a	a15,#@his(NvM_Prv_Main_st)
	lea	a15,[a15]@los(NvM_Prv_Main_st)
.L150:
	mov.aa	a12,a15
	add.a	a12,#4
.L151:
	lea	a13,[a15]8
	mov.aa	a4,a13
	call	NvM_Prv_Queue_GetEntryToProcess
.L152:
	st.b	[a12],d2
.L153:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    77  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    78      if (NULL_PTR != NvM_Prv_Main_st.QueueEntry_pst)
	ld.a	a14,[a13]
.L154:
	mov.a	a2,#0
.L155:
	jeq.a	a2,a14,.L2
.L58:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    79      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    80          NvM_Prv_idJob_ten idJob_en = NvM_Prv_GetNextJob(&NvM_Prv_Main_st.idQueueActive_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    81                                                          NvM_Prv_Main_st.QueueEntry_pst);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    82  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    83          if (idJob_en != NvM_Prv_idJob_Idle_e)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    84          {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    85              NvM_BlockIdType idBlock_uo = NvM_Prv_Main_st.QueueEntry_pst->idBlock_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    87              NvM_Prv_UpdateBlockStatus(idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    88                                        idJob_en,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    89                                        NvM_Prv_Main_st.QueueEntry_pst->BlockData_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    90              /* MR12 RULE 11.5 VIOLATION: The actual type of the RAM block varies from block to block and
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    91                                           cast to byte pointer can always be done safely */
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    92              NvM_Prv_StartJob(idJob_en,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    93                               idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    94                               (uint8*)NvM_Prv_Main_st.QueueEntry_pst->BlockData_pv,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    95                               NvM_Prv_GetIdxDatasetForJob(idJob_en, idBlock_uo));
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    96          }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    97      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    98      else
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	    99      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   100          // No request pending -> NvM is completely idle
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   101          NvM_Prv_Main_st.Activity_rAMwM_en = NVM_PRV_ACTIVITY_IDLE;
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   102      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   103  }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   104  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   105  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   106  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   107  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   108  /*
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   109   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   110   * Inline code
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   111   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   112   */
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   113  LOCAL_INLINE NvM_Prv_idJob_ten NvM_Prv_GetNextJob(NvM_Prv_idQueue_tuo* idQueueActive_puo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   114                                                    NvM_Prv_QueueEntry_tst* QueueEntry_pst)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   115  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   116      NvM_Prv_idJob_ten idJobNext_en = NvM_Prv_idJob_Idle_e;
	mov	d2,#0
.L117:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   117  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   118      if ((NULL_PTR != idQueueActive_puo) && (NULL_PTR != QueueEntry_pst))
	mov.a	a15,#0
.L156:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   118      if ((NULL_PTR != idQueueActive_puo) && (NULL_PTR != QueueEntry_pst))      (inlined)
	jeq.a	a15,a12,.L3
.L157:
	mov.a	a15,#0
.L158:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   118      if ((NULL_PTR != idQueueActive_puo) && (NULL_PTR != QueueEntry_pst))      (inlined)
	jeq.a	a15,a14,.L4
.L159:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   119      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   120          if (NvM_Prv_idQueue_Multi_e == *idQueueActive_puo)
	ld.bu	d15,[a12]
.L160:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   120          if (NvM_Prv_idQueue_Multi_e == *idQueueActive_puo)      (inlined)
	jne	d15,#0,.L5
.L161:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   121          {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   122              // process multi block service
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   123              idJobNext_en = NvM_Prv_Multi_Process(QueueEntry_pst);
	mov.aa	a4,a14
	call	NvM_Prv_Multi_Process
.L162:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   123              idJobNext_en = NvM_Prv_Multi_Process(QueueEntry_pst);      (inlined)
	j	.L6

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   120          if (NvM_Prv_idQueue_Multi_e == *idQueueActive_puo)      (inlined)
.L5:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   124          }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   125          else
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   126          {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   127              // Check whether the service identified by the service bit is valid
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   128              if (NvM_Prv_ErrorDetection_IsServiceBitValid(NVM_SERVICE_ID_MAIN_FUNCTION,
	mov	d4,#14
.L163:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   129                                                           QueueEntry_pst->idBlock_uo,
	ld.hu	d5,[a14]2
.L164:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   130                                                           QueueEntry_pst->ServiceBit_uo))
	ld.hu	d6,[a14]4
	call	NvM_Prv_ErrorDetection_IsServiceBitValid
.L118:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   128              if (NvM_Prv_ErrorDetection_IsServiceBitValid(NVM_SERVICE_ID_MAIN_FUNCTION,      (inlined)
	jeq	d2,#0,.L7
.L165:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   131              {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   132                  // process single block service
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   133                  idJobNext_en = NvM_Prv_GetJobId(QueueEntry_pst->ServiceBit_uo);
	ld.hu	d4,[a14]4
	call	NvM_Prv_GetJobId
.L119:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   133                  idJobNext_en = NvM_Prv_GetJobId(QueueEntry_pst->ServiceBit_uo);      (inlined)
	j	.L8

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   128              if (NvM_Prv_ErrorDetection_IsServiceBitValid(NVM_SERVICE_ID_MAIN_FUNCTION,      (inlined)
.L7:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   134              }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   135              else
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   136              {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   137                  // Unknown/invalid singleblock service ID
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   138                  // (we should actually never get here; it's just there for robustness)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   139                  // -> clear current request, stay in arbitration
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   140  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   141                  // Set scheduling lock
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   142                  SchM_Enter_NvM_Main();
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   143  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   144                  NvM_Prv_Queue_DequeueRequest(*idQueueActive_puo);
	ld.bu	d4,[a12]
	call	NvM_Prv_Queue_DequeueRequest
.L166:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   145                  NvM_Prv_Main_st.QueueEntry_pst = NULL_PTR;
	mov.a	a15,#0
.L167:
	st.a	[a13],a15
.L168:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   146                  *idQueueActive_puo = NvM_Prv_idQueue_nrQueues_e;
	mov	d15,#2
.L169:
	st.b	[a12],d15
.L170:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   148                  // Reset scheduling lock
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   149                  SchM_Exit_NvM_Main();
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   150  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   151                  idJobNext_en = NvM_Prv_idJob_Idle_e;
	mov	d2,#0

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   135              else      (inlined)
.L8:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   125          else      (inlined)
.L6:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   118      if ((NULL_PTR != idQueueActive_puo) && (NULL_PTR != QueueEntry_pst))      (inlined)
.L4:
.L3:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   152              }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   153          }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   154      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   155      return idJobNext_en;
	mov	d4,d2
.L120:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   155      return idJobNext_en;      (inlined)
	j	.L9

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   156  }      (inlined)
.L9:
	jeq	d4,#0,.L10
.L67:
	ld.a	a7,[a13]
.L171:
	ld.hu	d5,[a7]2
.L121:
	ld.a	a2,[a7]8
.L70:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   392  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   393   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   394   * This NvM private function checks for the given block whether the configured block length is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   395   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   396   * \param idBlock
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   397   * ID of the block for which the block length will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   398   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   399   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   400   * - TRUE = block length is valid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   401   * - FALSE = block length is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   402   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   403  LOCAL_INLINE boolean NvM_Prv_IsBlockLengthValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   404  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   405      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   406              (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   407              (0u != *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   408  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   409  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   410  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   411   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   412   * This NvM private function checks whether the given block is configured with immediate priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   413   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   414   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   415   * ID of the block for which the priority will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   416   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   417   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   418   * - TRUE = block is configured with immediate priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   419   * - FALSE = block is configured with standard priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   420   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   421  LOCAL_INLINE boolean NvM_Prv_HasBlockImmediateJobPriority(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   423      boolean HasBlockImmediateJobPriority_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   425  #if (NVM_JOB_PRIORITIZATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   426      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   427          (NVM_PRV_JOB_PRIORITY_IMMEDIATE == NvM_Prv_BlockDescriptors_acst[idBlock_uo].JobPriority_u8))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   428      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   429          HasBlockImmediateJobPriority_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   430      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   431  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   433  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   434  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   435  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   436   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   437   * This NvM private function returns the configured block size for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   438   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   439   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   440   * ID of the block for which the configured block size will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   441   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   442   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   443   * Configured block size
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   444   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   445  LOCAL_INLINE uint16 NvM_Prv_GetBlockSize(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   446  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   447      uint16 BlockSize_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   448  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   451      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   452          BlockSize_u16 = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   453      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   454  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   455      return BlockSize_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   456  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   457  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   458  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   459   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   460   * This NvM private function returns the configured block management type for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   461   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   462   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   463   * ID of the block for which the configured block management type will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   464   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   465   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   466   * Configured block management type
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   467   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   468  LOCAL_INLINE NvM_BlockManagementType NvM_Prv_GetBlockType(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   469  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   470      NvM_BlockManagementType BlockType = NVM_BLOCK_NATIVE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   472      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   473          BlockType = NvM_Prv_BlockDescriptors_acst[idBlock_uo].BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   474      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   475      return BlockType;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   476  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   477  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   478  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   479   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   480   * This NvM private function returns the configured number of non-volatile data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   481   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   482   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   483   * ID of the block for which the configured number of non-volatile data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   484   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   485   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   486   * Configured number of non-volatile data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   487   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   488  LOCAL_INLINE uint8 NvM_Prv_GetNrNonVolatileBlocks(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   489  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   490      uint8 nrNvBlocks_u8 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   491      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   492      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   493          nrNvBlocks_u8 = NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   494      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   495      return nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   496  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   497  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   498  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   499   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   500   * This NvM private function returns the configured overall number of data sets for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   501   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   502   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   503   * ID of the block for which the configured overall number of data sets will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   504   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   505   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   506   * Configured number of data sets
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   507   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   508  LOCAL_INLINE uint16 NvM_Prv_GetNrDataIndexes(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   509  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   510      uint8 nrDataIndexes = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   511      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   512      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   513          nrDataIndexes = (NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrNvBlocks_u8 +
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   514                           NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrRomBlocks_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   515      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   516      return nrDataIndexes;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   517  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   518  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   519  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   520   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   521   * This NvM private function returns the pointer to the configured permanent RAM block for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   522   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   523   * \details
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   524   * If no permanent RAM block is configured for a block then this function returns a NULL pointer.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   525   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   526   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   527   * ID of the block for which the pointer to the configured permanent RAM block will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   528   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   529   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   530   * Pointer to the configured permanent RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   531   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   532  LOCAL_INLINE void * NvM_Prv_GetPRamBlockAddress(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   533  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   534      void * PRamBlockAddress_pv = NULL_PTR;
	mov.a	a4,#0
.L122:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   535      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
	jge.u	d5,#14,.L11
.L172:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   535      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   536          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv))
	mul	d15,d5,#48
.L173:
	movh.a	a5,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a5,[a5]@los(NvM_Prv_BlockDescriptors_acst)
.L174:
	addsc.a	a15,a5,d15,#0
.L175:
	ld.a	a5,[a15]12
.L176:
	mov.a	a6,#0
.L177:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   536          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv))      (inlined)
	jeq.a	a6,a5,.L12
.L178:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   537      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   538          PRamBlockAddress_pv = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv;
	ld.a	a4,[a5]

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   535      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&      (inlined)
.L12:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   536          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRamBlock_ppv))      (inlined)
.L11:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   541      return PRamBlockAddress_pv;      (inlined)
	j	.L13

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   542  }      (inlined)
.L13:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   162      if (RamBlock_pcv == NvM_Prv_GetPRamBlockAddress(idBlock_uo))      (inlined)
	jne.a	a2,a4,.L14
.L79:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   164          if ((NvM_Prv_idJob_Read_e == idJob_en) ||      (inlined)
	jeq	d4,#1,.L15
.L179:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   156  }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   157  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   158  LOCAL_INLINE void NvM_Prv_UpdateBlockStatus(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   159                                              NvM_Prv_idJob_ten idJob_en,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   160                                              void const* RamBlock_pcv)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   161  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   162      if (RamBlock_pcv == NvM_Prv_GetPRamBlockAddress(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   163      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   164          if ((NvM_Prv_idJob_Read_e == idJob_en) ||
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   165              (NvM_Prv_idJob_ReadIdConfigForReadAll_e == idJob_en) ||
	mov	d15,#8
.L180:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   165              (NvM_Prv_idJob_ReadIdConfigForReadAll_e == idJob_en) ||      (inlined)
	jeq	d15,d4,.L16
.L181:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   166              (NvM_Prv_idJob_Restore_e == idJob_en) ||      (inlined)
	jeq	d4,#4,.L17
.L182:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   166              (NvM_Prv_idJob_Restore_e == idJob_en) ||
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   167              (NvM_Prv_idJob_RestoreForImplicitRecovery_e == idJob_en))
	mov	d15,#10
.L183:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   167              (NvM_Prv_idJob_RestoreForImplicitRecovery_e == idJob_en))      (inlined)
	jne	d15,d4,.L18

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   166              (NvM_Prv_idJob_Restore_e == idJob_en) ||      (inlined)
.L17:
.L16:
.L15:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   168          {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   169              // set status of the permanent RAM block to INVALID
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   170              NvM_Prv_Block_SetState(idBlock_uo, NVM_BLOCK_STATE_RAM_VALID, 0x0u);
	mov	d1,#1
.L184:
	mov	d15,#0
.L86:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   169  LOCAL_INLINE boolean NvM_Prv_Block_IsRequestPending(NvM_BlockIdType idBlock_uo, uint16 maskService_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   170  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   172  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   173  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   174  LOCAL_INLINE boolean NvM_Prv_Block_IsPending(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   175  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   176      return (NvM_Prv_Block_IsNvmEnqueuingForMulti(idBlock_uo) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   177              ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != 0)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   178  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   179                && (NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != (1u << NvM_Prv_ServiceBit_Maintain_e))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   180  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   181              )
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   182             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   183  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   184  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   185  LOCAL_INLINE void NvM_Prv_Block_SetIdxData(NvM_BlockIdType idBlock_uo, uint8 idxData_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   186  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   187      NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] = idxData_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   188  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   189  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   190  LOCAL_INLINE void NvM_Prv_Block_SetRequestResult(NvM_BlockIdType idBlock_uo, NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   191  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   192      NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo] = Result_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   193  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   194  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   195  LOCAL_INLINE void NvM_Prv_Block_SetRequest(NvM_BlockIdType idBlock_uo, NvM_Prv_ServiceBit_tuo ServiceBit_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   196  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   197      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= (1u << ServiceBit_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   198  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   199  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   200  LOCAL_INLINE void NvM_Prv_Block_SetRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   201  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   202      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= maskRequests_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   203  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   204  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   205  LOCAL_INLINE void NvM_Prv_Block_ClearRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   206  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   207      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] &= (~maskRequests_u16);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   208  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   209  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   210  LOCAL_INLINE void NvM_Prv_Block_SetState(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   211                                           uint8 maskBitsToChange_u8,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   212                                           uint8 maskBitsNewValue_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   213  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   214      NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] = ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & (~maskBitsToChange_u8)) |
	movh.a	a2,#@his(NvM_Prv_stBlock_rAwAM_au8)
	lea	a2,[a2]@los(NvM_Prv_stBlock_rAwAM_au8)
.L185:
	addsc.a	a2,a2,d5,#0
	ld.bu	d0,[a2]
.L186:
	xor	d1,d1,#255
.L187:
	and	d0,d1
.L188:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   215                                               (maskBitsNewValue_u8 & maskBitsToChange_u8));
	and	d15,#1
.L189:
	or	d0,d15
.L190:
	st.b	[a2],d0
.L87:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   170              NvM_Prv_Block_SetState(idBlock_uo, NVM_BLOCK_STATE_RAM_VALID, 0x0u);      (inlined)
	j	.L19

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   164          if ((NvM_Prv_idJob_Read_e == idJob_en) ||      (inlined)
.L18:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   172          else if (NvM_Prv_idJob_Write_e == idJob_en)      (inlined)
	jne	d4,#2,.L20
.L191:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   171          }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   172          else if (NvM_Prv_idJob_Write_e == idJob_en)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   173          {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   174              // set status of the permanent RAM block to VALID
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   175              NvM_Prv_Block_SetState(idBlock_uo, NVM_BLOCK_STATE_RAM_VALID, NVM_BLOCK_STATE_RAM_VALID);
	mov	d1,#1
.L192:
	mov	d15,#1
.L95:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   163  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   164  LOCAL_INLINE NvM_RequestResultType NvM_Prv_Block_GetRequestResult(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   165  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   166      return NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   167  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   168  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   169  LOCAL_INLINE boolean NvM_Prv_Block_IsRequestPending(NvM_BlockIdType idBlock_uo, uint16 maskService_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   170  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   171      return ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] & maskService_u16) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   172  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   173  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   174  LOCAL_INLINE boolean NvM_Prv_Block_IsPending(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   175  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   176      return (NvM_Prv_Block_IsNvmEnqueuingForMulti(idBlock_uo) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   177              ((NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != 0)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   178  #if (NVM_PRV_MAINTAIN_REDUNDANT_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   179                && (NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] != (1u << NvM_Prv_ServiceBit_Maintain_e))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   180  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   181              )
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   182             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   183  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   184  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   185  LOCAL_INLINE void NvM_Prv_Block_SetIdxData(NvM_BlockIdType idBlock_uo, uint8 idxData_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   186  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   187      NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] = idxData_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   188  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   189  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   190  LOCAL_INLINE void NvM_Prv_Block_SetRequestResult(NvM_BlockIdType idBlock_uo, NvM_RequestResultType Result_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   191  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   192      NvM_Prv_stRequestResult_rAwAM_au8[idBlock_uo] = Result_uo;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   193  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   194  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   195  LOCAL_INLINE void NvM_Prv_Block_SetRequest(NvM_BlockIdType idBlock_uo, NvM_Prv_ServiceBit_tuo ServiceBit_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   196  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   197      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= (1u << ServiceBit_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   198  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   199  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   200  LOCAL_INLINE void NvM_Prv_Block_SetRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   201  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   202      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] |= maskRequests_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   203  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   204  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   205  LOCAL_INLINE void NvM_Prv_Block_ClearRequests(NvM_BlockIdType idBlock_uo, uint16 maskRequests_u16)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   206  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   207      NvM_Prv_stRequests_rAMwAM_au16[idBlock_uo] &= (~maskRequests_u16);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   208  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   209  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   210  LOCAL_INLINE void NvM_Prv_Block_SetState(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   211                                           uint8 maskBitsToChange_u8,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   212                                           uint8 maskBitsNewValue_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   213  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   214      NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] = ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & (~maskBitsToChange_u8)) |
	movh.a	a2,#@his(NvM_Prv_stBlock_rAwAM_au8)
	lea	a2,[a2]@los(NvM_Prv_stBlock_rAwAM_au8)
.L193:
	addsc.a	a15,a2,d5,#0
	ld.bu	d0,[a15]
.L194:
	xor	d1,d1,#255
.L195:
	and	d0,d1
.L196:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   215                                               (maskBitsNewValue_u8 & maskBitsToChange_u8));
	and	d15,#1
.L197:
	or	d0,d15
.L198:
	st.b	[a15],d0
.L96:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   175              NvM_Prv_Block_SetState(idBlock_uo, NVM_BLOCK_STATE_RAM_VALID, NVM_BLOCK_STATE_RAM_VALID);      (inlined)
	j	.L21

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   172          else if (NvM_Prv_idJob_Write_e == idJob_en)      (inlined)
.L20:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   177          else      (inlined)
.L21:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   172          else if (NvM_Prv_idJob_Write_e == idJob_en)      (inlined)
.L19:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   162      if (RamBlock_pcv == NvM_Prv_GetPRamBlockAddress(idBlock_uo))      (inlined)
.L14:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     2  #ifndef NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     3  #define NVM_PRV_BLOCKDESCRIPTOR_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    10  #include "Rte_NvM_Type.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    11  #include "NvM_Types.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    12  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    13  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    17   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    18  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    19   * Definition of the immediate job priority for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    20   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    21  // TRACE[ECUC_NvM_00477]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    22  #define NVM_PRV_JOB_PRIORITY_IMMEDIATE      (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    23  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    24  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    25   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    26   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    27   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    28   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    29  typedef Std_ReturnType (*NvM_Prv_ExplicitSync_Copy_tpfct)(void* NvMBuffer_pv);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    30  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    31  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    32   * Definition of different bit masks to access different configuration flags withis block descriptors
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    33   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    34  typedef enum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    35  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    36      /// Bit mask definition to get information whether a block shall be processed during NvM_ReadAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    37      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    38      /// TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    39      NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL              = 0x0001,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    40      /// Bit mask definition to get information whether the block shall be processed during NvM_WriteAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    41      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    42      /// TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    43      NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL             = 0x0002,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    44      /// Bit mask definition to get information whether the block shall be processed during NvM_Rb_FirstInitAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    45      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    46      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    47      NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL        = 0x0004,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    48      /// Bit mask definition to get information whether the block shall be initialized when a layout change is detected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    49      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    50      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    51      NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE = 0x0008,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    52      /// Bit mask definition to get information whether the block is initially write protected.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    53      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    54      /// TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    55      NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED                  = 0x0010,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    56      /// Bit mask definition to get information whether the block shall be written only once.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    57      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    58      /// TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    59      NVM_PRV_BLOCK_FLAG_WRITE_ONCE                       = 0x0020,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    60      /// Bit mask definition to get information whether the block shall be resistant to block layout changes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    61      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    62      /// TRACE[NVM483_Conf] ParameterNvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    63      NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW          = 0x0040,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    64      /// Bit mask definition to get information whether the block shall use explicit synchronization mechanism.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    65      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    66      /// TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    67      NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM               = 0x0080,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    68      /// Bit mask definition to get information whether the block shall be processed during NvM_ValidateAll.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    69      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    70      /// TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    71      NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION              = 0x0100,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    72      /// Bit mask definition to get information whether the block is using a variable block length.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    73      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    74      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    75      NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH        = 0x0200,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    76      /// Bit mask definition to get information whether the block is configured for migration.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    77      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    78      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    79      NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION             = 0x0400,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    80      /// Bit mask definition to get information whether the block shall be initialized unconditionally
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    81      /// This information is stored in the NVRAM block descriptor, see NvM_Prv_BlockDescriptor_tst.stFlags_u16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    82      /// TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3175] Parameter NvMBlockDescriptor:NvMRbRamInitUnconditional
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    83      NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL           = 0x0800
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    85  } NvM_Prv_BlockConfiguration_ten;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    86  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    87  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    88   * Definition of the structure for common configuration options of the NvM used during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    89   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    90   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    91  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    92  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    93      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    94       * Pointer to a callback function which shall be invoked on termination of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    95       * TRACE[NVM468]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    96       * TRACE[NVM331]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    97       * TRACE[NVM500_Conf] Parameter NvMCommon:NvMMultiBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    98       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	    99      void (*MultiBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   100      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   101       * Pointer to a callback function which shall be invoked on start of each asynchronous multi-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   102       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2762] Parameter NvMCommon:NvMRbMultiBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   103       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   104      void (*RbMultiBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   105      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   106       * Pointer to a callback function which shall be invoked on termination of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   107       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2842]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   108       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2843] Parameter NvMCommon:NvMRbObserverCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   109       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   110      Std_ReturnType (*ObserverCallback_pfct)(NvM_BlockIdType BlockId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   111                                              uint8 ServiceId,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   112                                              NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   113  } NvM_Prv_Common_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   114  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   115  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   116   * Definition of the structure for a NVRAM block descriptor.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   117   * A NVRAM block descriptor contains all information about a single NVRAM block needed during the runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   118   * The NVRAM block descriptors are condensed in the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   119   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   120   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   121  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   122  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   123      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   124       * Block ID to be passed to the MemIf.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   125       * Do not confuse this ID with NVRAM block ID used within NvM.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   126       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   127      uint16 idBlockMemIf_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   128      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   129       * Pointer to the block legth in bytes.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   130       * If runtime calculation of block lengths is enabled by the NvM configuration then block lengths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   131       * in RAM so pointer points to a variable with block length calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   132       * Otherwise if runtime calculation is disabled by the NvM configuration then block legths will be located
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   133       * in ROM so pointer points to a constant with block length configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   134       * TRACE[NVM479_Conf] Parameter NvMBlockDescriptor:NvMNvBlockLength
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   135       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   136       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   137       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   138  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   139      uint16* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   140  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   141      uint16 const* nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   142  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   143      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   144       * Device index where the block is located (Fee / Ea).
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   145       * TRACE[NVM035_Conf] Parameter NvMBlockDescriptor:NvMNvramDeviceId
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   146       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   147      uint8 idxDevice_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   148      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   149       * Number of non-volatile blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   150       * TRACE[NVM480_Conf] Parameter NvMBlockDescriptor:NvMNvBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   151       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   152      uint8 nrNvBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   153      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   154       * Number of multiple ROM blocks in a contiguous area according to the given block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   155       * TRACE[NVM485_Conf] Parameter NvMBlockDescriptor:NvMRomBlockNum
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   156       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   157      uint8 nrRomBlocks_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   158      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   159       * Pointer to the permanent RAM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   160       * If this pointer is NULL_PTR then no permanent RAM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   161       * If runtime calculation of RAM block data addresses is enabled by the NvM configuration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   162       * then RAM block data addresses will be located in RAM and pointer points to a void pointer
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   163       * calculated during runtime.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   164       * Otherwise if runtime calculation is disabled by the NvM configuration then RAM block data addresses
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   165       * will be located in ROM and pointer points to a constant void pointer configured during compile time.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   166       * TRACE[NVM126]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   167       * TRACE[NVM482_Conf] Parameter NvMBlockDescriptor:NvMRamBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   168       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3028] Parameter NvMCommon:NvMRbRuntimeRamBlockConfiguration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   169       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3086] Parameter NvMBlockDescriptor:NvMRbRamBlockDataAddressString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   170       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   171  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   172      void** adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   173  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   174      void* const* adrRamBlock_ppv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   175  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   176      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   177       * Pointer to the ROM block data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   178       * If this pointer is NULL_PTR then no ROM block data has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   179       * TRACE[NVM020]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   180       * TRACE[NVM484_Conf] Parameter NvMBlockDescriptor:NvMRomBlockDataAddress
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   181       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   182      void const* adrRomBlock_pcv;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   183      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   184       * Pointer to the block specific callback function which shall be invoked on termination
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   185       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   186       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   187       * TRACE[NVM113]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   188       * TRACE[NVM467]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   189       * TRACE[NVM330]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   190       * TRACE[NVM506_Conf] Parameter NvMBlockDescriptor:NvMSingleBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   191       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   192      Std_ReturnType (*SingleBlockCallback_pfct)(uint8 ServiceId, NvM_RequestResultType JobResult);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   193      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   194       * Pointer to the block specific callback function which shall be invoked on start
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   195       * of each asynchronous single-block request.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   196       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   197       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3056]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   198       * TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3062] Parameter NvMBlockDescriptor:NvMRbSingleBlockStartCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   199       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   200      Std_ReturnType (*SingleBlockStartCallback_pfct)(uint8 ServiceId);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   201      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   202       * Pointer to the block specific callback function which shall be invoked if no ROM block data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   203       * for initialization of the block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   204       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   205       * TRACE[NVM469]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   206       * TRACE[NVM352]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   207       * TRACE[NVM116_Conf] Parameter NvMBlockDescriptor:NvMInitBlockCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   208       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   209      Std_ReturnType (*InitBlockCallback_pfct)(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   210      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   211       * Pointer to the block specific callback function to let the application copy data from the NvM mirror
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   212       * to application's RAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   213       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   214       * TRACE[NVM540]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   215       * TRACE[NVM542]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   216       * TRACE[NVM521_Conf] Parameter NvMBlockDescriptor:NvMReadRamBlockFromNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   217       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   218      Std_ReturnType (*ReadRamBlockFromNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   219      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   220       * Pointer the block specific callback function to let the application copy data from the application's RAM block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   221       * to the NvM mirror.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   222       * If this pointer is NULL_PTR then no callback has been configured by the user.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   223       * TRACE[NVM539]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   224       * TRACE[NVM541]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   225       * TRACE[NVM520_Conf] Parameter NvMBlockDescriptor:NvMWriteRamBlockToNvCallback
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   226       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   227      Std_ReturnType (*WriteRamBlockToNvm_pfct)(void* NvMBuffer);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   228      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   229       * Block management type.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   230       * TRACE[NVM062_Conf] Parameter NvMBlockDescriptor:NvMBlockManagementType
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   231       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   232      NvM_BlockManagementType BlockManagementType_en;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   233      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   234       * Block job priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   235       * TRACE[NVM477_Conf] Parameter NvMBlockDescriptor:NvMBlockJobPriority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   236       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   237      uint8 JobPriority_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   238      /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   239       * Bit-field containing several configuration parameter which can be represented by a bit.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   240       * NvM provides special bit mask to access individual bits from this bit-field:
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   241       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   242       *   TRACE[NVM117_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForReadAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   243       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   244       *   TRACE[NVM549_Conf] Parameter NvMBlockDescriptor:NvMSelectBlockForWriteAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   245       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   246       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2828] Parameter NvMBlockDescriptor:NvMRbSelectBlockForFirstInitAll
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   247       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   248       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2881] Parameter NvMBlockDescriptor:NvMRbInitBlockAtLayoutChange
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   249       * - NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   250       *   TRACE[NVM033_Conf] Parameter NvMBlockDescriptor:NvMBlockWriteProt
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   251       * - NVM_PRV_BLOCK_FLAG_WRITE_ONCE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   252       *   TRACE[NVM072_Conf] Parameter NvMBlockDescriptor:NvMWriteBlockOnce
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   253       * - NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   254       *   TRACE[NVM483_Conf] Parameter NvMBlockDescriptor:NvMResistantToChangedSw
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   255       * - NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   256       *   TRACE[NVM519_Conf] Parameter NvMBlockDescriptor:NvMBlockUseSyncMechanism
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   257       * - NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   258       *   TRACE[NVM557_Conf] Parameter NvMBlockDescriptor:NvMBlockUseAutoValidation
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   259       * - NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   260       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-2996] Parameter NvMBlockDescriptor:NvMRbNvBlockLengthString
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   261       * - NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   262       *   TRACE[BSW_SWS_AR4_0_R2_NVRAMManager_Ext-3027] Parameter NvMBlockDescriptor:NvMRbFirstReadDataMigration
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   263       */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   264      uint16 stFlags_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   265  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   266  } NvM_Prv_BlockDescriptor_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   267  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   268  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   269   * Definition of the structure to assign the persistent ID to the block ID for a NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   270   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   271  typedef struct
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   272  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   273      uint16          PersistentId_u16;   // Persistent Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   274      NvM_BlockIdType BlockId_u16;        // Block Id
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   275  } NvM_Prv_PersId_BlockId_tst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   276  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   277  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   278   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   279   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   280   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   281   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   282  // Declaration of different configuration-dependent data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   283  // Definition of all this data is done in NvM_Cfg.c.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   284  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   285  #define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   286  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   287  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   288  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   289   * Declaration of the container with all common configuration data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   290   * TRACE[NVM028_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   291   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   292  extern const NvM_Prv_Common_tst             NvM_Prv_Common_cst;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   293  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   294   * Declaration of the NVRAM block descriptor table.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   295   * TRACE[NVM061_Conf]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   296   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   297  extern const NvM_Prv_BlockDescriptor_tst    NvM_Prv_BlockDescriptors_acst[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   298  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   299   * Declaratiion of the table to get the NvM block ID using the persistent ID.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   300   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   301  extern const NvM_Prv_PersId_BlockId_tst     NvM_Prv_PersId_BlockId_acst[NVM_PRV_NR_PERSISTENT_IDS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   302  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   303   * Declaration of the table with all persistant IDs.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   304   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   305  extern const uint16                         NvM_Prv_PersIds_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   306  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   307  #define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   308  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   309  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   310  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   311   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   312   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   313   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   314   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   315  #if (NVM_PRV_RUNTIME_RAM_BLOCK_CONFIG == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   316  # define NVM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   317  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   318  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   319  extern uint16 NvM_Prv_BlockLengths_au16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   320  extern void *NvM_Prv_RamBlockAdr_apv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   321  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   322  # define NVM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   323  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   324  #else
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   325  # define NVM_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   326  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   327  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   328  extern uint16 const NvM_Prv_BlockLengths_acu16[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   329  extern void * const NvM_Prv_RamBlockAdr_acpv[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   330  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   331  # define NVM_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   332  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   333  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   334  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   335  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   336   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   337   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   338   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   339   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   340  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   341  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   342  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   343  // Init-related functions (defined in NvM_Cfg.c)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   344  extern void NvM_Prv_InitRamBlockProperties(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   345  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   346  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   347  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   348  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   349  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   350  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   351  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   352  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   353  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   354  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   355   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   356   * This NvM private function provides information whether a block is configured for the given feature.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   357   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   358   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   359   * ID of the block for which the configuration information will be provided.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   360   * \param SelectionMask_en
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   361   * Bit mask for the configuration information to be provide.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   362   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   363   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   364   * - TRUE = block is configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   365   * - FALSE = block is not configured for the given feature
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   366   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   367  LOCAL_INLINE boolean NvM_Prv_IsBlockSelected(NvM_BlockIdType idBlock_uo,
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   368                                               NvM_Prv_BlockConfiguration_ten SelectionMask_en)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   369  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   370      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   371              ((NvM_Prv_BlockDescriptors_acst[idBlock_uo].stFlags_u16 & ((uint16)SelectionMask_en)) != 0u));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   372  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   373  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   374  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   375   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   376   * This NvM private function provides the information whether default data is available for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   377   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   378   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   379   * ID of the block to provide the availability of the default data.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   380   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   381   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   382   * - TRUE = default data is available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   383   * - FALSE = default data is not available
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   384   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   385  LOCAL_INLINE boolean NvM_Prv_IsDefaultDataAvailable(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   386  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   387      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   388              ((NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].adrRomBlock_pcv) ||
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   389               (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].InitBlockCallback_pfct)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   390  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   391  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   392  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   393   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   394   * This NvM private function checks for the given block whether the configured block length is valid.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   395   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   396   * \param idBlock
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   397   * ID of the block for which the block length will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   398   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   399   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   400   * - TRUE = block length is valid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   401   * - FALSE = block length is invalid
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   402   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   403  LOCAL_INLINE boolean NvM_Prv_IsBlockLengthValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   404  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   405      return ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   406              (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   407              (0u != *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   408  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   409  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   410  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   411   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   412   * This NvM private function checks whether the given block is configured with immediate priority.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   413   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   414   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   415   * ID of the block for which the priority will be checked.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   416   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   417   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   418   * - TRUE = block is configured with immediate priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   419   * - FALSE = block is configured with standard priority
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   420   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   421  LOCAL_INLINE boolean NvM_Prv_HasBlockImmediateJobPriority(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   422  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   423      boolean HasBlockImmediateJobPriority_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   424  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   425  #if (NVM_JOB_PRIORITIZATION == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   426      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   427          (NVM_PRV_JOB_PRIORITY_IMMEDIATE == NvM_Prv_BlockDescriptors_acst[idBlock_uo].JobPriority_u8))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   428      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   429          HasBlockImmediateJobPriority_b = TRUE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   430      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   431  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   432      return HasBlockImmediateJobPriority_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   433  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   434  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   435  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   436   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   437   * This NvM private function returns the configured block size for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   438   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   439   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   440   * ID of the block for which the configured block size will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   441   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   442   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   443   * Configured block size
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   444   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   445  LOCAL_INLINE uint16 NvM_Prv_GetBlockSize(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   446  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   447      uint16 BlockSize_u16 = 0;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   448  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   449      if ((idBlock_uo < NVM_CFG_NR_BLOCKS) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   450          (NULL_PTR != NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   451      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   452          BlockSize_u16 = *NvM_Prv_BlockDescriptors_acst[idBlock_uo].nrBlockBytes_pu16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   453      }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   454  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   455      return BlockSize_u16;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   456  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   457  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   458  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   459   * \brief
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   460   * This NvM private function returns the configured block management type for the given block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   461   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   462   * \param idBlock_uo
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   463   * ID of the block for which the configured block management type will be returned.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   464   *
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   465   * \return
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   466   * Configured block management type
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   467   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   468  LOCAL_INLINE NvM_BlockManagementType NvM_Prv_GetBlockType(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   469  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   470      NvM_BlockManagementType BlockType = NVM_BLOCK_NATIVE;
	mov	d15,#0
.L123:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
	jge.u	d5,#14,.L22
.L199:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   472      {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   473          BlockType = NvM_Prv_BlockDescriptors_acst[idBlock_uo].BlockManagementType_en;
	mul	d15,d5,#48
.L124:
	movh.a	a15,#@his(NvM_Prv_BlockDescriptors_acst)
	lea	a15,[a15]@los(NvM_Prv_BlockDescriptors_acst)
.L200:
	addsc.a	a15,a15,d15,#0
.L201:
	ld.w	d15,[a15]40

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   471      if (idBlock_uo < NVM_CFG_NR_BLOCKS)      (inlined)
.L22:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   475      return BlockType;      (inlined)
	j	.L23

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockDescriptor.h	   476  }      (inlined)
.L23:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   188      if ((NVM_BLOCK_DATASET != NvM_Prv_GetBlockType(idBlock_uo)) ||      (inlined)
	jne	d15,#2,.L24
.L107:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   176          }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   177          else
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   178          {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   179              // all other jobs do not work on permanent RAM block so it is not required to update the status
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   180          }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   181      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   182  }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   183  
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   184  LOCAL_INLINE uint8 NvM_Prv_GetIdxDatasetForJob(NvM_Prv_idJob_ten idJob_en,
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   185                                                 NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   186  {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   187      uint8 idxDataset_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   188      if ((NVM_BLOCK_DATASET != NvM_Prv_GetBlockType(idBlock_uo)) ||
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   189          (NvM_Prv_idJob_InvalidateForRemoveNonResistant_e == idJob_en))
	mov	d15,#11
.L125:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   189          (NvM_Prv_idJob_InvalidateForRemoveNonResistant_e == idJob_en))      (inlined)
	jne	d15,d4,.L25

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   188      if ((NVM_BLOCK_DATASET != NvM_Prv_GetBlockType(idBlock_uo)) ||      (inlined)
.L24:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   190      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   191          idxDataset_u8 = 0;
	mov	d6,#0
.L126:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   191          idxDataset_u8 = 0;      (inlined)
	j	.L26

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   188      if ((NVM_BLOCK_DATASET != NvM_Prv_GetBlockType(idBlock_uo)) ||      (inlined)
.L25:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     1  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     2  #ifndef NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     3  #define NVM_PRV_BLOCKDATA_H
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     4  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     5  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     7   * Includes
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     8   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	     9   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    10  #include "NvM_Prv_BlockDescriptor.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    11  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    12  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    13   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    14   * Defines/Macros
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    15   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    16   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    17  // Definitions for giving special block IDs some semantics
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    18  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    19  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    20   * Definition of the reserved block ID used for multi block operations.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    21   * TRACE[NVM471]
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    22   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    23  #define NVM_PRV_MULTI_BLOCK         (0u)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    24  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    25  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    26  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    27   * Definition of the block ID used for administrative information related to operations triggered by auxiliary users
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    28   * (for this use case, an additional admin block has been reserved behind all "regular" admin blocks)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    29   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    30  # define NVM_PRV_AUX_ADMIN_BLOCK    NVM_CFG_NR_BLOCKS
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    31  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    32  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    33  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    34   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    35   * Type definitions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    36   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    37   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    38  typedef boolean (*NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct)(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    39  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    40  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    41   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    42   * Constants
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    43   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    44   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    45  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    46  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    47   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    48   * Variables
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    49   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    50   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    51  // Declaration of variables containing administrative data for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    52  // ------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    53  // TRACE[NVM135] Administrative block is private
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    54  #define NVM_START_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    55  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    56  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    57   * Declaration of the array containing attribute/status information of all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    58   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    59  extern uint8 NvM_Prv_stBlock_rAwAM_au8[NVM_CFG_NR_BLOCKS];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    60  #define NVM_STOP_SEC_VAR_SAVED_ZONE_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    61  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    62  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    63  #define NVM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    64  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    65  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    66   * Declaration of the array containing all requests pending on each NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    67   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    68  extern uint16 NvM_Prv_stRequests_rAMwAM_au16[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    69  #define NVM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    70  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    71  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    72  #define NVM_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    73  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    74  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    75   * Declaration of the array containing results of the last asynchronous request for all NVRAM blocks.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    76   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    77  extern NvM_RequestResultType NvM_Prv_stRequestResult_rAwAM_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    78  /**
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    79   * Declaration of the array containing indexes for all NVRAM block.
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    80   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    81  extern uint8 NvM_Prv_idxDataSet_rAMwA_au8[NVM_PRV_NR_BLOCKS_ADMIN];
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    82  #define NVM_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    83  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    84  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    85  # define NVM_START_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    86  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    87  extern uint16 NvM_Prv_idConfigStored_rMwM_u16;   // RAM block of the config ID block
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    88  # define NVM_STOP_SEC_VAR_SAVED_ZONE_16
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    89  # include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    90  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    91  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    92   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    93   * Extern declarations
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    94   **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    95   */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    96  #define NVM_START_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    97  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    98  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	    99  extern void NvM_Prv_Block_InitializeData(boolean isSavedZoneDataLost_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   100  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   101  extern void NvM_Prv_Block_InitializeDataAux(void);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   102  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   103  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   104  extern void NvM_Prv_Block_SetIsNvmEnqueuingForMulti(NvM_Prv_Block_IsNvmEnqueuingForMulti_tpfct IsNvmEnqueuingForMulti_pfct);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   105  extern boolean NvM_Prv_Block_IsNvmEnqueuingForMulti(NvM_BlockIdType idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   106  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   107  #define NVM_STOP_SEC_CODE
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   108  #include "NvM_MemMap.h"
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   109  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   110  /*
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   111  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   112  * Inline functions
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   113  **********************************************************************************************************************
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   114  */
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   115  LOCAL_INLINE boolean NvM_Prv_Block_IsPRamBlockValid(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   116  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   117      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_VALID) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   118  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   119  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   120  LOCAL_INLINE boolean NvM_Prv_Block_IsChanged(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   121  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   122      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_RAM_CHANGED) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   123  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   124  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   125  LOCAL_INLINE boolean NvM_Prv_Block_IsTrgWriteAllActive(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   126  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   127      boolean isTrgWriteAllActive_b = FALSE;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   128  #if (NVM_RB_SET_WRITEALL_TRIGGER_API == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   129      isTrgWriteAllActive_b = (NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_RB_BLOCK_STATE_MASK_TRG_WRITEALL) != 0u;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   130  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   131      return isTrgWriteAllActive_b;
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   132  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   133  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   134  LOCAL_INLINE boolean NvM_Prv_Block_IsRomDataAmbiguous(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   135  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   136      return ((NULL_PTR != NvM_Prv_GetRomBlockAddress(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   137              (NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   138              (NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo] < NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo))
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   139             );
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   140  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   141  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   142  LOCAL_INLINE boolean NvM_Prv_Block_IsInRom(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   143  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   144      return ((NVM_BLOCK_DATASET == NvM_Prv_GetBlockType(idBlock_uo)) &&
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   145              (idxDataset_u8 >= NvM_Prv_GetNrNonVolatileBlocks(idBlock_uo)));
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   146  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   147  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   148  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteProtected(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   149  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   150      return ((NvM_Prv_stBlock_rAwAM_au8[idBlock_uo] & NVM_BLOCK_STATE_WRITE_PROT) != 0u);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   151  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   152  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   153  LOCAL_INLINE boolean NvM_Prv_Block_IsWriteable(NvM_BlockIdType idBlock_uo, uint8 idxDataset_u8)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   154  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   155      boolean IsBlockInRom_b = NvM_Prv_Block_IsInRom(idBlock_uo, idxDataset_u8);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   156      return (!NvM_Prv_Block_IsWriteProtected(idBlock_uo) && !IsBlockInRom_b);
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   157  }
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   158  
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   159  LOCAL_INLINE uint8 NvM_Prv_Block_GetIdxDataset(NvM_BlockIdType idBlock_uo)
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   160  {
; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];
	movh.a	a15,#@his(NvM_Prv_idxDataSet_rAMwA_au8)
	lea	a15,[a15]@los(NvM_Prv_idxDataSet_rAMwA_au8)
.L202:
	addsc.a	a15,a15,d5,#0
	ld.bu	d6,[a15]
.L127:

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   161      return NvM_Prv_idxDataSet_rAMwA_au8[idBlock_uo];      (inlined)
	j	.L27

; BSW\src\BSW\Gen\NvM\src\NvM_Prv_BlockData.h	   162  }      (inlined)
.L27:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   193      else      (inlined)
.L26:

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   203      return idxDataset_u8;      (inlined)
	j	.L28

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   204  }      (inlined)
.L28:
	ld.a	a4,[a7]8
.L104:
	call	NvM_Prv_StartJob
.L10:
	j	.L29
.L2:
	mov	d15,#1
.L203:
	st.w	[a15],d15
.L29:
	ret
.L57:
	
__NvM_Prv_MainFunctionArbitrate_function_end:
	.size	NvM_Prv_MainFunctionArbitrate,__NvM_Prv_MainFunctionArbitrate_function_end-NvM_Prv_MainFunctionArbitrate
.L47:
	; End of function
	
	.calls	'NvM_Prv_MainFunctionArbitrate','NvM_Prv_Queue_GetEntryToProcess'
	.calls	'NvM_Prv_MainFunctionArbitrate','NvM_Prv_Multi_Process'
	.calls	'NvM_Prv_MainFunctionArbitrate','NvM_Prv_ErrorDetection_IsServiceBitValid'
	.calls	'NvM_Prv_MainFunctionArbitrate','NvM_Prv_GetJobId'
	.calls	'NvM_Prv_MainFunctionArbitrate','NvM_Prv_Queue_DequeueRequest'
	.calls	'NvM_Prv_MainFunctionArbitrate','NvM_Prv_StartJob'
	.calls	'NvM_Prv_StartJob','',0
	.extern	NvM_Prv_Main_st
	.extern	NvM_Prv_GetJobId
	.extern	NvM_Prv_Queue_DequeueRequest
	.extern	NvM_Prv_Queue_GetEntryToProcess
	.extern	NvM_Prv_BlockDescriptors_acst
	.extern	NvM_Prv_stBlock_rAwAM_au8
	.extern	NvM_Prv_idxDataSet_rAMwA_au8
	.extern	NvM_Prv_ErrorDetection_IsServiceBitValid
	.extern	NvM_Prv_Multi_Process
	.calls	'NvM_Prv_MainFunctionArbitrate','',0
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L35:
	.word	14101
	.half	3
	.word	.L36
	.byte	4
.L34:
	.byte	1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionArbitrate.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L37
.L111:
	.byte	2,2,40,9,4,3
	.byte	'NVM_BLOCK_NATIVE',0,0,3
	.byte	'NVM_BLOCK_REDUNDANT',0,1,3
	.byte	'NVM_BLOCK_DATASET',0,2,0
.L51:
	.byte	4
	.byte	'unsigned short int',0,2,7
.L106:
	.byte	5
	.byte	'NvM_Prv_GetBlockType',0,3,1,212,3,38
	.word	151
	.byte	1,1
.L108:
	.byte	6
	.byte	'idBlock_uo',0,1,212,3,75
	.word	218
.L110:
	.byte	7,0
.L55:
	.byte	4
	.byte	'unsigned char',0,1,8,5
	.byte	'NvM_Prv_GetNrNonVolatileBlocks',0,3,1,232,3,20
	.word	295
	.byte	1,1,6
	.byte	'idBlock_uo',0,1,232,3,67
	.word	218
	.byte	7,0,8
	.byte	'void',0
.L83:
	.byte	9
	.word	377
.L78:
	.byte	5
	.byte	'NvM_Prv_GetPRamBlockAddress',0,3,1,148,4,21
	.word	383
	.byte	1,1
.L80:
	.byte	6
	.byte	'idBlock_uo',0,1,148,4,65
	.word	218
.L82:
	.byte	7,0,10
	.word	377
	.byte	9
	.word	450
	.byte	5
	.byte	'NvM_Prv_GetRomBlockAddress',0,3,1,173,4,26
	.word	455
	.byte	1,1,6
	.byte	'idBlock_uo',0,1,173,4,69
	.word	218
	.byte	7,0,5
	.byte	'NvM_Prv_Block_IsInRom',0,3,3,142,1,22
	.word	295
	.byte	1,1,6
	.byte	'idBlock_uo',0,3,142,1,60
	.word	218
	.byte	6
	.byte	'idxDataset_u8',0,3,142,1,78
	.word	295
	.byte	11,7,7,0,0,5
	.byte	'NvM_Prv_Block_IsWriteProtected',0,3,3,148,1,22
	.word	295
	.byte	1,1,6
	.byte	'idBlock_uo',0,3,148,1,69
	.word	218
	.byte	7,0
.L113:
	.byte	5
	.byte	'NvM_Prv_Block_GetIdxDataset',0,3,3,159,1,20
	.word	295
	.byte	1,1
.L114:
	.byte	6
	.byte	'idBlock_uo',0,3,159,1,64
	.word	218
.L116:
	.byte	7,0
.L85:
	.byte	12
	.byte	'NvM_Prv_Block_SetState',0,3,3,210,1,19,1,1
.L88:
	.byte	6
	.byte	'idBlock_uo',0,3,210,1,58
	.word	218
.L90:
	.byte	6
	.byte	'maskBitsToChange_u8',0,3,211,1,48
	.word	295
.L92:
	.byte	6
	.byte	'maskBitsNewValue_u8',0,3,212,1,48
	.word	295
.L94:
	.byte	7,0
.L49:
	.byte	2,2,104,9,4,3
	.byte	'NvM_Prv_idJob_Idle_e',0,0,3
	.byte	'NvM_Prv_idJob_Read_e',0,1,3
	.byte	'NvM_Prv_idJob_Write_e',0,2,3
	.byte	'NvM_Prv_idJob_Erase_e',0,3,3
	.byte	'NvM_Prv_idJob_Restore_e',0,4,3
	.byte	'NvM_Prv_idJob_Maintain_e',0,5,3
	.byte	'NvM_Prv_idJob_Validate_e',0,6,3
	.byte	'NvM_Prv_idJob_Invalidate_e',0,7,3
	.byte	'NvM_Prv_idJob_ReadIdConfigForReadAll_e',0,8,3
	.byte	'NvM_Prv_idJob_InvalidateForFirstInitAll_e',0,9,3
	.byte	'NvM_Prv_idJob_RestoreForImplicitRecovery_e',0,10,3
	.byte	'NvM_Prv_idJob_InvalidateForRemoveNonResistant_e',0,11,3
	.byte	'NvM_Prv_idJob_Invalid_e',0,12,3
	.byte	'NvM_Prv_idJob_Count_e',0,13,0,9
	.word	295
	.byte	13,2,210,1,9,12,14
	.byte	'idService_uo',0
	.word	295
	.byte	1,2,35,0,14
	.byte	'idBlock_uo',0
	.word	218
	.byte	2,2,35,2,14
	.byte	'ServiceBit_uo',0
	.word	218
	.byte	2,2,35,4,14
	.byte	'BlockData_pv',0
	.word	383
	.byte	4,2,35,8,0,9
	.word	1285
.L60:
	.byte	5
	.byte	'NvM_Prv_GetNextJob',0,3,4,113,32
	.word	841
	.byte	1,1
.L61:
	.byte	6
	.byte	'idQueueActive_puo',0,4,113,72
	.word	1280
.L63:
	.byte	6
	.byte	'QueueEntry_pst',0,4,114,75
	.word	1379
.L65:
	.byte	7,0
.L69:
	.byte	12
	.byte	'NvM_Prv_UpdateBlockStatus',0,3,4,158,1,19,1,1
.L71:
	.byte	6
	.byte	'idBlock_uo',0,4,158,1,61
	.word	218
.L73:
	.byte	6
	.byte	'idJob_en',0,4,159,1,63
	.word	841
.L75:
	.byte	6
	.byte	'RamBlock_pcv',0,4,160,1,57
	.word	455
.L77:
	.byte	11,7,7,7,0,0
.L97:
	.byte	5
	.byte	'NvM_Prv_GetIdxDatasetForJob',0,3,4,184,1,20
	.word	295
	.byte	1,1
.L98:
	.byte	6
	.byte	'idJob_en',0,4,184,1,66
	.word	841
.L100:
	.byte	6
	.byte	'idBlock_uo',0,4,185,1,64
	.word	218
.L102:
	.byte	11,7,7,0,0,15
	.byte	'NvM_Prv_GetJobId',0,5,105,26
	.word	841
	.byte	1,1,1,1,6
	.byte	'ServiceBit_uo',0,5,105,66
	.word	218
	.byte	0
.L53:
	.byte	9
	.word	295
	.byte	16
	.byte	'NvM_Prv_Queue_DequeueRequest',0,6,42,13,1,1,1,1,6
	.byte	'idQueue_uo',0,6,42,62
	.word	295
	.byte	0,9
	.word	1379
	.byte	15
	.byte	'NvM_Prv_Queue_GetEntryToProcess',0,6,43,28
	.word	295
	.byte	1,1,1,1,6
	.byte	'QueueEntry_ppst',0,6,43,85
	.word	1762
	.byte	0,17
	.word	240
	.byte	18
	.word	273
	.byte	7,0,17
	.word	312
	.byte	18
	.word	355
	.byte	7,0,17
	.word	388
	.byte	18
	.word	428
	.byte	7,0,17
	.word	460
	.byte	18
	.word	499
	.byte	7,0,17
	.word	521
	.byte	18
	.word	555
	.byte	18
	.word	575
	.byte	11,19
	.word	240
	.byte	18
	.word	273
	.byte	20
	.word	293
	.byte	0,7,19
	.word	312
	.byte	18
	.word	355
	.byte	20
	.word	375
	.byte	0,7,0,0,17
	.word	603
	.byte	18
	.word	646
	.byte	7,0,17
	.word	668
	.byte	18
	.word	708
	.byte	7,0,17
	.word	730
	.byte	18
	.word	761
	.byte	18
	.word	781
	.byte	18
	.word	810
	.byte	7,0,15
	.byte	'NvM_Prv_ErrorDetection_IsServiceBitValid',0,7,57,16
	.word	295
	.byte	1,1,1,1,6
	.byte	'idService_uo',0,7,57,79
	.word	295
	.byte	6
	.byte	'idBlock_uo',0,7,58,73
	.word	218
	.byte	6
	.byte	'ServiceBit_uo',0,7,59,80
	.word	218
	.byte	0,15
	.byte	'NvM_Prv_Multi_Process',0,8,25,26
	.word	841
	.byte	1,1,1,1,6
	.byte	'QueueEntry_pst',0,8,25,72
	.word	1379
	.byte	0,17
	.word	1384
	.byte	18
	.word	1414
	.byte	18
	.word	1440
	.byte	7,0,17
	.word	1465
	.byte	18
	.word	1499
	.byte	18
	.word	1519
	.byte	18
	.word	1537
	.byte	11,19
	.word	730
	.byte	18
	.word	761
	.byte	18
	.word	781
	.byte	18
	.word	810
	.byte	20
	.word	839
	.byte	0,7,19
	.word	730
	.byte	18
	.word	761
	.byte	18
	.word	781
	.byte	18
	.word	810
	.byte	20
	.word	839
	.byte	0,7,19
	.word	388
	.byte	18
	.word	428
	.byte	20
	.word	448
	.byte	0,7,0,0,17
	.word	1565
	.byte	18
	.word	1605
	.byte	18
	.word	1623
	.byte	11,19
	.word	668
	.byte	18
	.word	708
	.byte	20
	.word	728
	.byte	0,7,19
	.word	240
	.byte	18
	.word	273
	.byte	20
	.word	293
	.byte	0,7,0,0,21,1,9
	.word	2319
	.byte	22
	.byte	'__codeptr',0,4,1,1
	.word	2321
	.byte	4
	.byte	'char',0,1,6,22
	.byte	'sint8',0,9,76,25
	.word	2344
	.byte	22
	.byte	'uint8',0,9,81,25
	.word	295
	.byte	22
	.byte	'uint16',0,9,91,25
	.word	218
	.byte	4
	.byte	'unsigned int',0,4,7,22
	.byte	'uint32',0,9,106,24
	.word	2395
	.byte	4
	.byte	'unsigned long long int',0,8,7,22
	.byte	'uint64',0,9,111,30
	.word	2426
	.byte	22
	.byte	'boolean',0,9,127,25
	.word	295
	.byte	22
	.byte	'StatusType',0,10,191,1,27
	.word	295
	.byte	22
	.byte	'Std_ReturnType',0,10,199,1,15
	.word	295
	.byte	13,10,206,1,9,8,14
	.byte	'vendorID',0
	.word	218
	.byte	2,2,35,0,14
	.byte	'moduleID',0
	.word	218
	.byte	2,2,35,2,14
	.byte	'sw_major_version',0
	.word	295
	.byte	1,2,35,4,14
	.byte	'sw_minor_version',0
	.word	295
	.byte	1,2,35,5,14
	.byte	'sw_patch_version',0
	.word	295
	.byte	1,2,35,6,0,22
	.byte	'Std_VersionInfoType',0,10,213,1,3
	.word	2527
	.byte	22
	.byte	'PduIdType',0,11,22,19
	.word	218
	.byte	22
	.byte	'PduLengthType',0,11,26,19
	.word	218
	.byte	2,12,113,9,4,3
	.byte	'TP_DATACONF',0,0,3
	.byte	'TP_DATARETRY',0,1,3
	.byte	'TP_CONFPENDING',0,2,0,22
	.byte	'TpDataStateType',0,12,118,3
	.word	2717
	.byte	22
	.byte	'Can_IdType',0,13,32,16
	.word	2395
	.byte	22
	.byte	'Can_HwHandleType',0,13,43,16
	.word	218
	.byte	13,14,93,9,8,14
	.byte	'Class',0
	.word	295
	.byte	1,2,35,0,14
	.byte	'TIN',0
	.word	295
	.byte	1,2,35,1,14
	.byte	'ReturnAddress',0
	.word	2395
	.byte	4,2,35,4,0,22
	.byte	'OsTrapInfoType',0,14,97,3
	.word	2837
	.byte	23,68
	.word	2395
	.byte	24,16,0,13,14,154,1,9,68,14
	.byte	'store',0
	.word	2917
	.byte	68,2,35,0,0,23,68
	.word	2926
	.byte	24,0,0,22
	.byte	'Os_JumpBufType',0,14,156,1,3
	.word	2948
	.byte	22
	.byte	'Os_StackTraceType',0,14,174,1,18
	.word	2395
	.byte	13,14,175,1,9,8,14
	.byte	'sp',0
	.word	2395
	.byte	4,2,35,0,14
	.byte	'ctx',0
	.word	2395
	.byte	4,2,35,4,0,22
	.byte	'Os_StackValueType',0,14,175,1,63
	.word	3008
	.byte	22
	.byte	'Os_StackSizeType',0,14,176,1,27
	.word	3008
	.byte	25,1,1,9
	.word	3093
	.byte	22
	.byte	'Os_VoidVoidFunctionType',0,14,179,1,16
	.word	3096
	.byte	22
	.byte	'ApplicationType',0,14,193,1,23
	.word	295
	.byte	26
	.byte	'Os_ApplicationConfigurationType_s',0,14,198,1,16,2,14
	.byte	'app_id',0
	.word	295
	.byte	1,2,35,0,14
	.byte	'access',0
	.word	295
	.byte	1,2,35,1,0,22
	.byte	'Os_ApplicationConfigurationType',0,14,201,1,3
	.word	3159
	.byte	22
	.byte	'Os_CoreStateType',0,14,203,1,16
	.word	2395
	.byte	22
	.byte	'AreaIdType',0,14,204,1,16
	.word	218
	.byte	22
	.byte	'Os_PeripheralAddressType',0,14,212,1,22
	.word	2395
	.byte	22
	.byte	'TickType',0,14,221,1,22
	.word	2395
	.byte	22
	.byte	'Os_StopwatchTickType',0,14,225,1,22
	.word	2395
	.byte	9
	.word	2395
	.byte	22
	.byte	'Os_Lockable',0,14,234,1,18
	.word	3401
	.byte	22
	.byte	'CoreIdType',0,14,236,1,16
	.word	218
	.byte	22
	.byte	'SpinlockIdType',0,14,237,1,16
	.word	218
	.byte	2,14,239,1,9,4,3
	.byte	'TRYTOGETSPINLOCK_SUCCESS',0,0,3
	.byte	'TRYTOGETSPINLOCK_NOSUCCESS',0,1,0,22
	.byte	'TryToGetSpinlockType',0,14,239,1,74
	.word	3471
	.byte	2,14,174,2,9,4,3
	.byte	'APPLICATION_ACCESSIBLE',0,0,3
	.byte	'APPLICATION_RESTARTING',0,1,3
	.byte	'APPLICATION_TERMINATED',0,2,0,22
	.byte	'ApplicationStateType',0,14,174,2,92
	.word	3564
	.byte	27,1,1,28
	.word	295
	.byte	28
	.word	383
	.byte	0,9
	.word	3676
	.byte	22
	.byte	'Os_FunctionEntryType',0,14,183,2,16
	.word	3690
	.byte	26
	.byte	'Os_MeterInfoType_s',0,14,193,2,16,48,14
	.byte	'elapsed',0
	.word	2395
	.byte	4,2,35,0,14
	.byte	'previous',0
	.word	2395
	.byte	4,2,35,4,14
	.byte	'max',0
	.word	2395
	.byte	4,2,35,8,14
	.byte	'cumulative',0
	.word	2395
	.byte	4,2,35,12,14
	.byte	'stackbase',0
	.word	3008
	.byte	8,2,35,16,14
	.byte	'stackusage',0
	.word	3008
	.byte	8,2,35,24,14
	.byte	'stackmax',0
	.word	3008
	.byte	8,2,35,32,14
	.byte	'stackbudget',0
	.word	3008
	.byte	8,2,35,40,0,22
	.byte	'Os_MeterInfoType',0,14,202,2,3
	.word	3725
	.byte	9
	.word	3725
	.byte	22
	.byte	'Os_MeterInfoRefType',0,14,203,2,50
	.word	3923
	.byte	22
	.byte	'EventMaskType',0,14,206,2,15
	.word	295
	.byte	22
	.byte	'Os_imaskType',0,14,211,2,16
	.word	2395
	.byte	26
	.byte	'Os_ISRDynType_s',0,14,213,2,16,48,14
	.byte	'meter',0
	.word	3725
	.byte	48,2,35,0,0,22
	.byte	'Os_ISRDynType',0,14,215,2,3
	.word	4002
	.byte	9
	.word	4002
	.byte	10
	.word	4063
	.byte	26
	.byte	'Os_ISRType_s',0,14,216,2,16,24,14
	.byte	'entry_function',0
	.word	3101
	.byte	4,2,35,0,14
	.byte	'dynamic',0
	.word	4068
	.byte	4,2,35,4,14
	.byte	'imask',0
	.word	2395
	.byte	4,2,35,8,14
	.byte	'stackbudget',0
	.word	3008
	.byte	8,2,35,12,14
	.byte	'access',0
	.word	295
	.byte	1,2,35,20,14
	.byte	'application',0
	.word	295
	.byte	1,2,35,21,0,22
	.byte	'Os_ISRType',0,14,223,2,3
	.word	4073
	.byte	9
	.word	3093
	.byte	10
	.word	4073
	.byte	9
	.word	4232
	.byte	22
	.byte	'ISRType',0,14,224,2,46
	.word	4237
	.byte	22
	.byte	'Os_bitmask',0,14,239,2,22
	.word	2395
	.byte	22
	.byte	'Os_pset0Type',0,14,240,2,20
	.word	2395
	.byte	22
	.byte	'Os_pset1Type',0,14,241,2,20
	.word	2395
	.byte	22
	.byte	'Os_pset2Type',0,14,242,2,20
	.word	2395
	.byte	29,14,243,2,9,4,14
	.byte	'p0',0
	.word	2395
	.byte	4,2,35,0,14
	.byte	'p1',0
	.word	2395
	.byte	4,2,35,0,14
	.byte	'p2',0
	.word	2395
	.byte	4,2,35,0,0,22
	.byte	'Os_psetType',0,14,247,2,3
	.word	4345
	.byte	29,14,249,2,9,4,14
	.byte	't0',0
	.word	2395
	.byte	4,2,35,0,14
	.byte	't1',0
	.word	2395
	.byte	4,2,35,0,14
	.byte	't2',0
	.word	2395
	.byte	4,2,35,0,0,22
	.byte	'Os_tpmaskType',0,14,253,2,3
	.word	4409
	.byte	22
	.byte	'Os_ActivationCountType',0,14,254,2,23
	.word	295
	.byte	26
	.byte	'Os_TaskDynType_s',0,14,128,3,16,120,14
	.byte	'terminate_jump_buf',0
	.word	2957
	.byte	68,2,35,0,14
	.byte	'meter',0
	.word	3725
	.byte	48,2,35,68,14
	.byte	'activation_count',0
	.word	295
	.byte	1,2,35,116,0,22
	.byte	'Os_TaskDynType',0,14,132,3,3
	.word	4507
	.byte	23,68
	.word	2926
	.byte	24,0,0,9
	.word	4507
	.byte	10
	.word	4633
	.byte	26
	.byte	'Os_TaskType_s',0,14,134,3,16,40,14
	.byte	'dynamic',0
	.word	4638
	.byte	4,2,35,0,14
	.byte	'entry_function',0
	.word	3101
	.byte	4,2,35,4,14
	.byte	'pset',0
	.word	4345
	.byte	4,2,35,8,14
	.byte	'base_tpmask',0
	.word	4409
	.byte	4,2,35,12,14
	.byte	'tpmask',0
	.word	4409
	.byte	4,2,35,16,14
	.byte	'core_id',0
	.word	218
	.byte	2,2,35,20,14
	.byte	'index',0
	.word	2395
	.byte	4,2,35,24,14
	.byte	'stackbudget',0
	.word	3008
	.byte	8,2,35,28,14
	.byte	'activation_count',0
	.word	295
	.byte	1,2,35,36,14
	.byte	'access',0
	.word	295
	.byte	1,2,35,37,14
	.byte	'application',0
	.word	295
	.byte	1,2,35,38,0,22
	.byte	'Os_TaskType',0,14,146,3,3
	.word	4643
	.byte	10
	.word	4643
	.byte	9
	.word	4893
	.byte	22
	.byte	'TaskType',0,14,147,3,47
	.word	4898
	.byte	30
	.byte	'Os_TaskStateType',0,14,155,3,6,4,3
	.byte	'SUSPENDED',0,0,3
	.byte	'READY',0,1,3
	.byte	'WAITING',0,2,3
	.byte	'RUNNING',0,3,0,22
	.byte	'TaskStateType',0,14,156,3,31
	.word	4921
	.byte	29,14,167,3,3,4,14
	.byte	'tpmask',0
	.word	4409
	.byte	4,2,35,0,0,26
	.byte	'Os_ResourceDynType_s',0,14,166,3,16,4,14
	.byte	'saved_priority',0
	.word	5008
	.byte	4,2,35,0,0,22
	.byte	'Os_ResourceDynType',0,14,170,3,3
	.word	5031
	.byte	9
	.word	5031
	.byte	10
	.word	5111
	.byte	26
	.byte	'Os_ResourceType_s',0,14,171,3,16,12,14
	.byte	'dynamic',0
	.word	5116
	.byte	4,2,35,0,14
	.byte	'tpmask',0
	.word	4409
	.byte	4,2,35,4,14
	.byte	'access',0
	.word	295
	.byte	1,2,35,8,0,22
	.byte	'Os_ResourceType',0,14,175,3,3
	.word	5121
	.byte	13,14,181,3,9,12,14
	.byte	'maxallowedvalue',0
	.word	2395
	.byte	4,2,35,0,14
	.byte	'ticksperbase',0
	.word	2395
	.byte	4,2,35,4,14
	.byte	'mincycle',0
	.word	2395
	.byte	4,2,35,8,0,22
	.byte	'AlarmBaseType',0,14,185,3,3
	.word	5220
	.byte	13,14,206,3,9,8,14
	.byte	'Running',0
	.word	295
	.byte	1,2,35,0,14
	.byte	'Pending',0
	.word	295
	.byte	1,2,35,1,14
	.byte	'Delay',0
	.word	2395
	.byte	4,2,35,4,0,22
	.byte	'Os_CounterStatusType',0,14,210,3,3
	.word	5315
	.byte	31
	.word	295
	.byte	1,1,9
	.word	5401
	.byte	22
	.byte	'Os_CounterIncrAdvType',0,14,217,3,22
	.word	5408
	.byte	26
	.byte	's_swd',0,14,222,3,12,4,14
	.byte	'count',0
	.word	2395
	.byte	4,2,35,0,0,29,14,221,3,3,4,14
	.byte	'sw',0
	.word	5444
	.byte	4,2,35,0,0,26
	.byte	'Os_CounterDynType_s',0,14,220,3,16,4,14
	.byte	'type_dependent',0
	.word	5472
	.byte	4,2,35,0,0,22
	.byte	'Os_CounterDynType',0,14,226,3,3
	.word	5491
	.byte	9
	.word	5491
	.byte	10
	.word	5569
	.byte	26
	.byte	'Os_CounterType_s',0,14,227,3,16,28,14
	.byte	'dynamic',0
	.word	5574
	.byte	4,2,35,0,14
	.byte	'advincr',0
	.word	5413
	.byte	4,2,35,4,14
	.byte	'base',0
	.word	5220
	.byte	12,2,35,8,14
	.byte	'core',0
	.word	383
	.byte	4,2,35,20,14
	.byte	'access',0
	.word	295
	.byte	1,2,35,24,14
	.byte	'application',0
	.word	295
	.byte	1,2,35,25,0,22
	.byte	'Os_CounterType',0,14,234,3,3
	.word	5579
	.byte	9
	.word	5401
	.byte	10
	.word	5579
	.byte	9
	.word	5731
	.byte	22
	.byte	'CounterType',0,14,235,3,52
	.word	5736
	.byte	30
	.byte	'Os_ScheduleTableStatusType',0,14,240,3,6,4,3
	.byte	'SCHEDULETABLE_STOPPED',0,0,3
	.byte	'SCHEDULETABLE_NEXT',0,1,3
	.byte	'SCHEDULETABLE_WAITING',0,2,3
	.byte	'SCHEDULETABLE_RUNNING',0,3,3
	.byte	'SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS',0,4,0,22
	.byte	'ScheduleTableStatusType',0,14,241,3,41
	.word	5762
	.byte	10
	.word	.L128-.L35
	.byte	9
	.word	5962
	.byte	22
	.byte	'ScheduleTableType',0,14,128,4,58
	.word	5967
	.byte	26
	.byte	'Os_ScheduleTableDynType_s',0,14,130,4,16,16,14
	.byte	'match',0
	.word	2395
	.byte	4,2,35,0,14
	.byte	'next',0
	.word	5972
	.byte	4,2,35,4,14
	.byte	'state',0
	.word	5762
	.byte	4,2,35,8,14
	.byte	'config',0
	.word	218
	.byte	2,2,35,12,0,9
	.word	5999
	.byte	10
	.word	6092
.L128:
	.byte	26
	.byte	'Os_ScheduleTableType_s',0,14,247,3,16,16,14
	.byte	'dynamic',0
	.word	6097
	.byte	4,2,35,0,14
	.byte	'counter',0
	.word	5741
	.byte	4,2,35,4,14
	.byte	'repeat',0
	.word	295
	.byte	1,2,35,8,14
	.byte	'config',0
	.word	218
	.byte	2,2,35,10,14
	.byte	'initial',0
	.word	295
	.byte	1,2,35,12,14
	.byte	'access',0
	.word	295
	.byte	1,2,35,13,14
	.byte	'application',0
	.word	295
	.byte	1,2,35,14,0,22
	.byte	'Os_ScheduleTableType',0,14,255,3,3
	.word	6102
	.byte	10
	.word	6102
	.byte	9
	.word	6282
	.byte	10
	.word	5579
	.byte	9
	.word	6292
	.byte	32
	.word	3406
	.byte	32
	.word	4345
	.byte	32
	.word	4242
	.byte	32
	.word	4903
	.byte	32
	.word	4409
	.byte	32
	.word	295
	.byte	32
	.word	4903
	.byte	26
	.byte	'Os_ControlledCoreType_s',0,14,251,6,16,112,14
	.byte	'TrapInfo',0
	.word	2837
	.byte	8,2,35,0,14
	.byte	'lock_taskaccess',0
	.word	6302
	.byte	4,2,35,8,14
	.byte	'ReadyTasks',0
	.word	6307
	.byte	4,2,35,12,14
	.byte	'RunningISR',0
	.word	6312
	.byte	4,2,35,16,14
	.byte	'RunningTask',0
	.word	6317
	.byte	4,2,35,20,14
	.byte	'RunningTPMask',0
	.word	6322
	.byte	4,2,35,24,14
	.byte	'CurrentMeteredObject',0
	.word	3928
	.byte	4,2,35,28,14
	.byte	'IdleMeter',0
	.word	3725
	.byte	48,2,35,32,14
	.byte	'AppAccess',0
	.word	295
	.byte	1,2,35,80,14
	.byte	'AppOverride',0
	.word	6327
	.byte	1,2,35,81,14
	.byte	'GetStackValueAdjust',0
	.word	3008
	.byte	8,2,35,84,14
	.byte	'InErrorHook',0
	.word	295
	.byte	1,2,35,92,14
	.byte	'ChainTaskRef',0
	.word	6332
	.byte	4,2,35,96,14
	.byte	'GetStackUsageAdjust',0
	.word	3008
	.byte	8,2,35,100,14
	.byte	'InProtectionHook',0
	.word	295
	.byte	1,2,35,108,14
	.byte	'CoreIsActive',0
	.word	295
	.byte	1,2,35,109,14
	.byte	'InShutdownHook',0
	.word	295
	.byte	1,2,35,110,0,22
	.byte	'Os_ControlledCoreType',0,14,141,7,3
	.word	6337
	.byte	9
	.word	2395
	.byte	10
	.word	4073
	.byte	9
	.word	6793
	.byte	10
	.word	4643
	.byte	9
	.word	6803
	.byte	9
	.word	3725
	.byte	26
	.byte	'Os_AnyCoreType_s',0,14,151,7,16,96,14
	.byte	'DisableAllImask',0
	.word	2395
	.byte	4,2,35,0,14
	.byte	'SuspendAllImask',0
	.word	2395
	.byte	4,2,35,4,14
	.byte	'SuspendOSImask',0
	.word	2395
	.byte	4,2,35,8,14
	.byte	'DisableAllCount',0
	.word	2395
	.byte	4,2,35,12,14
	.byte	'SuspendAllCount',0
	.word	2395
	.byte	4,2,35,16,14
	.byte	'SuspendOSCount',0
	.word	2395
	.byte	4,2,35,20,14
	.byte	'RestartJumpBuf',0
	.word	2957
	.byte	68,2,35,24,14
	.byte	'Restartable',0
	.word	295
	.byte	1,2,35,92,0,22
	.byte	'Os_AnyCoreType',0,14,160,7,3
	.word	6818
	.byte	22
	.byte	'Can_TxObjPriorityClassType',0,15,219,3,16
	.word	2395
	.byte	26
	.byte	'Can_TxHwObjectConfigType',0,15,231,3,16,8,14
	.byte	'MsgObjId',0
	.word	295
	.byte	1,2,35,0,14
	.byte	'HwControllerId',0
	.word	295
	.byte	1,2,35,1,14
	.byte	'TxObjPriorityClass',0
	.word	2395
	.byte	4,2,35,4,0,22
	.byte	'Can_TxHwObjectConfigType',0,15,252,3,3
	.word	7095
	.byte	26
	.byte	'Can_RxHwObjectConfigType',0,15,129,4,16,12,14
	.byte	'MaskRef',0
	.word	2395
	.byte	4,2,35,0,14
	.byte	'MsgId',0
	.word	2395
	.byte	4,2,35,4,14
	.byte	'MsgObjId',0
	.word	295
	.byte	1,2,35,8,14
	.byte	'HwControllerId',0
	.word	295
	.byte	1,2,35,9,0,22
	.byte	'Can_RxHwObjectConfigType',0,15,147,4,3
	.word	7231
	.byte	23,4
	.word	295
	.byte	24,3,0,26
	.byte	'Can_ControllerMOMapConfigType',0,15,181,4,16,4,14
	.byte	'ControllerMOMap',0
	.word	7371
	.byte	4,2,35,0,0,22
	.byte	'Can_ControllerMOMapConfigType',0,15,184,4,3
	.word	7380
	.byte	26
	.byte	'Can_NPCRValueType',0,15,188,4,16,2,14
	.byte	'Can_NPCRValue',0
	.word	218
	.byte	2,2,35,0,0,22
	.byte	'Can_NPCRValueType',0,15,191,4,3
	.word	7481
	.byte	26
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,15,194,4,16,8,14
	.byte	'CanControllerBaudrate',0
	.word	2395
	.byte	4,2,35,0,14
	.byte	'CanControllerBaudrateCfg',0
	.word	218
	.byte	2,2,35,4,0,22
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,15,198,4,3
	.word	7556
	.byte	10
	.word	7556
	.byte	9
	.word	7721
	.byte	26
	.byte	'Can_BaudrateConfigPtrType',0,15,201,4,16,4,14
	.byte	'Can_kBaudrateConfigPtr',0
	.word	7726
	.byte	4,2,35,0,0,22
	.byte	'Can_BaudrateConfigPtrType',0,15,204,4,3
	.word	7731
	.byte	26
	.byte	'Can_EventHandlingType',0,15,226,4,16,4,14
	.byte	'CanEventType',0
	.word	7371
	.byte	4,2,35,0,0,22
	.byte	'Can_EventHandlingType',0,15,229,4,3
	.word	7831
	.byte	22
	.byte	'Rte_TransformerErrorCode',0,16,130,1,15
	.word	295
	.byte	22
	.byte	'Rte_TransformerClass',0,16,131,1,15
	.word	295
	.byte	13,16,168,1,9,12,14
	.byte	'in',0
	.word	383
	.byte	4,2,35,0,14
	.byte	'out',0
	.word	383
	.byte	4,2,35,4,14
	.byte	'used',0
	.word	218
	.byte	2,2,35,8,14
	.byte	'lost_data',0
	.word	295
	.byte	1,2,35,10,0,22
	.byte	'Rte_QDynType',0,16,173,1,3
	.word	7977
	.byte	2,16,175,1,9,4,3
	.byte	'RTE_DRA',0,0,3
	.byte	'RTE_WOWP',0,1,3
	.byte	'RTE_TASK',0,2,3
	.byte	'RTE_ARE',0,3,3
	.byte	'RTE_EV',0,4,3
	.byte	'RTE_MSI',0,5,0,22
	.byte	'Rte_NotificationType',0,16,182,1,3
	.word	8064
	.byte	9
	.word	7977
	.byte	26
	.byte	'Rte_QCmnType',0,16,184,1,16,24,14
	.byte	'dynamic',0
	.word	8162
	.byte	4,2,35,0,14
	.byte	'copy',0
	.word	295
	.byte	1,2,35,4,14
	.byte	'queue_size',0
	.word	218
	.byte	2,2,35,6,14
	.byte	'element_size',0
	.word	218
	.byte	2,2,35,8,14
	.byte	'buffer_start',0
	.word	383
	.byte	4,2,35,12,14
	.byte	'buffer_end',0
	.word	383
	.byte	4,2,35,16,14
	.byte	'notification_type',0
	.word	8064
	.byte	4,2,35,20,0,22
	.byte	'Rte_QCmnType',0,16,192,1,3
	.word	8167
	.byte	22
	.byte	'Rte_AlarmRefType',0,16,224,1,32
	.word	2395
	.byte	22
	.byte	'Rte_AlarmIndexType',0,16,226,1,32
	.word	218
	.byte	23,128,8
	.word	295
	.byte	24,255,7,0,22
	.byte	'Impl_NVM_DstPtrType_1024',0,17,50,15
	.word	8405
	.byte	22
	.byte	'CanIf_u32_impl',0,17,69,16
	.word	2395
	.byte	22
	.byte	'CanIf_u16_impl',0,17,71,16
	.word	218
	.byte	22
	.byte	'CanIf_u8_impl',0,17,73,15
	.word	295
	.byte	22
	.byte	'CanIf_ControllerModeType_Enum_impl',0,17,88,15
	.word	295
	.byte	22
	.byte	'CanIf_PduModeType_Enum_impl',0,17,90,15
	.word	295
	.byte	13,17,92,9,2,14
	.byte	'DeviceMode',0
	.word	295
	.byte	1,2,35,0,14
	.byte	'ChannelMode',0
	.word	295
	.byte	1,2,35,1,0,22
	.byte	'CanIf_ControllerStateType_struct_impl',0,17,95,3
	.word	8596
	.byte	22
	.byte	'CanIf_NotifStatusType_Enum_impl',0,17,100,15
	.word	295
	.byte	22
	.byte	'CanSM_boolean_Impl',0,17,120,15
	.word	295
	.byte	22
	.byte	'CanSM_u8_Impl',0,17,123,15
	.word	295
	.byte	22
	.byte	'CanSM_BusOffRecoveryStateType_Enum_impl',0,17,128,1,15
	.word	295
	.byte	22
	.byte	'CanSM_NetworkModeStateType_Enum_impl',0,17,132,1,15
	.word	295
	.byte	22
	.byte	'CanSM_u16_Impl',0,17,136,1,16
	.word	218
	.byte	22
	.byte	'CanSM_TimerStateType_Enum_impl',0,17,138,1,15
	.word	295
	.byte	13,17,140,1,9,4,14
	.byte	'cntTick_u16',0
	.word	218
	.byte	2,2,35,0,14
	.byte	'stTimer',0
	.word	295
	.byte	1,2,35,2,0,22
	.byte	'CanSM_TimerConfig_tst_struct_impl',0,17,143,1,3
	.word	8937
	.byte	22
	.byte	'Com_impl_u16',0,17,154,1,16
	.word	218
	.byte	22
	.byte	'Com_impl_u8',0,17,157,1,15
	.word	295
	.byte	22
	.byte	'ComM_uint32_Impl',0,17,173,1,16
	.word	2395
	.byte	22
	.byte	'ComM_uint16_Impl',0,17,175,1,16
	.word	218
	.byte	22
	.byte	'ComM_uint8_Impl',0,17,177,1,15
	.word	295
	.byte	22
	.byte	'ComM_bool_Impl',0,17,179,1,15
	.word	295
	.byte	13,17,181,1,9,24,14
	.byte	'ChannelState_e',0
	.word	2395
	.byte	4,2,35,0,14
	.byte	'LightTimeoutCtr_u32',0
	.word	2395
	.byte	4,2,35,4,14
	.byte	'MinFullComTimeoutCtr_u16',0
	.word	218
	.byte	2,2,35,8,14
	.byte	'ChannelMode_u8',0
	.word	295
	.byte	1,2,35,10,14
	.byte	'BusSmMode_u8',0
	.word	295
	.byte	1,2,35,11,14
	.byte	'UserRequestCtr_u8',0
	.word	295
	.byte	1,2,35,12,14
	.byte	'PassiveRequestState_u8',0
	.word	295
	.byte	1,2,35,13,14
	.byte	'PncRequestCtr_u8',0
	.word	295
	.byte	1,2,35,14,14
	.byte	'InhibitionReqStatus_u8',0
	.word	295
	.byte	1,2,35,15,14
	.byte	'NmNetworkRequestStatus_b',0
	.word	295
	.byte	1,2,35,16,14
	.byte	'DiagnosticRequestState_b',0
	.word	295
	.byte	1,2,35,17,14
	.byte	'CommunicationAllowed_b',0
	.word	295
	.byte	1,2,35,18,14
	.byte	'NmBusSleepIndicationStatus_b',0
	.word	295
	.byte	1,2,35,19,14
	.byte	'NmPrepareBusSleepIndicationStatus_b',0
	.word	295
	.byte	1,2,35,20,14
	.byte	'NmNetworkModeStatus_b',0
	.word	295
	.byte	1,2,35,21,0,22
	.byte	'ComM_ChannelStruct_Impl',0,17,197,1,3
	.word	9169
	.byte	13,17,206,1,9,10,14
	.byte	'WakeUpInhibitionCtr_u16',0
	.word	218
	.byte	2,2,35,0,14
	.byte	'LimitToNoComCtr_u16',0
	.word	218
	.byte	2,2,35,2,14
	.byte	'RequestedUserMode_t',0
	.word	295
	.byte	1,2,35,4,14
	.byte	'IndicatedUserMode_t',0
	.word	295
	.byte	1,2,35,5,14
	.byte	'numChannelsInFullCom_u8',0
	.word	295
	.byte	1,2,35,6,14
	.byte	'numChannelsInSilentCom_u8',0
	.word	295
	.byte	1,2,35,7,14
	.byte	'numChannelsInNoCom_u8',0
	.word	295
	.byte	1,2,35,8,0,22
	.byte	'ComM_UserStruct_Impl',0,17,214,1,3
	.word	9673
	.byte	22
	.byte	'Dcm_IOOperationResponseType',0,17,252,1,15
	.word	295
	.byte	22
	.byte	'Dcm_RequestDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspRequestRoutineResultsOutSignal_0PrimitivType',0
	.byte	17,138,2,15
	.word	295
	.byte	22
	.byte	'Dcm_StartDataIn_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineInSignalPrimitivType',0,17,146,2,15
	.word	295
	.byte	22
	.byte	'Dcm_StartDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineOutSignalPrimitivType',0,17,150,2,15
	.word	295
	.byte	22
	.byte	'Dcm_StopDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStopRoutineOutSignalPrimitivType',0,17,154,2,15
	.word	295
	.byte	22
	.byte	'NvM_BlockIdType',0,17,215,2,16
	.word	218
	.byte	22
	.byte	'NvM_RequestResultType',0,17,225,2,15
	.word	295
	.byte	22
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockNative_1024_Type',0,17,243,3,34
	.word	8416
	.byte	23,128,8
	.word	295
	.byte	24,255,7,0,22
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockRedundant_1024_Type',0,17,246,3,34
	.word	8416
	.byte	2,18,31,9,4,3
	.byte	'MEMIF_JOB_OK',0,0,3
	.byte	'MEMIF_JOB_FAILED',0,1,3
	.byte	'MEMIF_JOB_PENDING',0,2,3
	.byte	'MEMIF_JOB_CANCELED',0,3,3
	.byte	'MEMIF_BLOCK_INCONSISTENT',0,4,3
	.byte	'MEMIF_BLOCK_INVALID',0,5,0,22
	.byte	'MemIf_JobResultType',0,18,39,2
	.word	10547
	.byte	22
	.byte	'NvM_BlockManagementType',0,2,45,3
	.word	151
	.byte	2,2,49,9,4,3
	.byte	'NVM_PRV_ACTIVITY_NOT_INIT',0,0,3
	.byte	'NVM_PRV_ACTIVITY_IDLE',0,1,3
	.byte	'NVM_PRV_ACTIVITY_ARBITRATE',0,2,3
	.byte	'NVM_PRV_ACTIVITY_JOB_START',0,3,3
	.byte	'NVM_PRV_ACTIVITY_POLL_RESULT',0,4,3
	.byte	'NVM_PRV_ACTIVITY_JOB_COMPLETE',0,5,3
	.byte	'NVM_PRV_ACTIVITY_RESULT_EVAL',0,6,0,22
	.byte	'NvM_Prv_Activities_ten',0,2,58,3
	.word	10737
	.byte	22
	.byte	'NvM_Prv_idJob_ten',0,2,115,3
	.word	841
	.byte	22
	.byte	'NvM_Prv_ServiceBit_tuo',0,2,168,1,16
	.word	218
	.byte	22
	.byte	'NvM_Prv_idService_tuo',0,2,173,1,15
	.word	295
	.byte	22
	.byte	'NvM_Prv_idQueue_tuo',0,2,206,1,15
	.word	295
	.byte	22
	.byte	'NvM_Prv_QueueEntry_tst',0,2,225,1,3
	.word	1285
	.byte	13,2,227,1,9,20,14
	.byte	'idJob_en',0
	.word	841
	.byte	4,2,35,0,14
	.byte	'idBlock_uo',0
	.word	218
	.byte	2,2,35,4,14
	.byte	'RamBlock_pu8',0
	.word	1700
	.byte	4,2,35,8,14
	.byte	'idxDataset_u8',0
	.word	295
	.byte	1,2,35,12,14
	.byte	'Result_en',0
	.word	10547
	.byte	4,2,35,16,0,22
	.byte	'NvM_Prv_JobData_tst',0,2,240,1,3
	.word	11128
	.byte	13,2,245,1,9,32,14
	.byte	'Activity_rAMwM_en',0
	.word	10737
	.byte	4,2,35,0,14
	.byte	'idQueueActive_uo',0
	.word	295
	.byte	1,2,35,4,14
	.byte	'QueueEntry_pst',0
	.word	1379
	.byte	4,2,35,8,14
	.byte	'JobData_st',0
	.word	11128
	.byte	20,2,35,12,0,22
	.byte	'NvM_Prv_MainStates_tst',0,2,132,2,3
	.word	11266
	.byte	22
	.byte	'Rte_TaskRefType',0,19,184,1,32
	.word	4903
	.byte	22
	.byte	'Rte_EventRefType',0,19,185,1,32
	.word	295
	.byte	22
	.byte	'Rte_EventType',0,19,186,1,32
	.word	2395
	.byte	22
	.byte	'Rte_REActCounterType',0,19,252,1,15
	.word	295
	.byte	9
	.word	295
	.byte	22
	.byte	'Rte_REActCounterRefType',0,19,253,1,58
	.word	11506
	.byte	13,19,255,1,9,8,14
	.byte	'task',0
	.word	11402
	.byte	4,2,35,0,14
	.byte	'acnt',0
	.word	11511
	.byte	4,2,35,4,0,22
	.byte	'Rte_REContainerType',0,19,130,2,3
	.word	11544
	.byte	10
	.word	4643
	.byte	9
	.word	11608
	.byte	9
	.word	295
	.byte	10
	.word	11544
	.byte	9
	.word	11623
	.byte	22
	.byte	'Rte_REContainerRefType',0,19,132,2,60
	.word	11628
	.byte	22
	.byte	'Rte_MSICounterType',0,19,149,2,16
	.word	218
	.byte	9
	.word	218
	.byte	22
	.byte	'Rte_MSICounterRefType',0,19,150,2,56
	.word	11693
	.byte	22
	.byte	'Rte_MSIPendingFlagType',0,19,152,2,17
	.word	295
	.byte	9
	.word	295
	.byte	22
	.byte	'Rte_MSIPendingFlagRefType',0,19,153,2,60
	.word	11761
	.byte	13,19,163,2,9,24,14
	.byte	'counter',0
	.word	11698
	.byte	4,2,35,0,14
	.byte	'incCounter',0
	.word	295
	.byte	1,2,35,4,14
	.byte	'pending',0
	.word	11766
	.byte	4,2,35,8,14
	.byte	'osTask',0
	.word	11402
	.byte	4,2,35,12,14
	.byte	'acnt',0
	.word	11511
	.byte	4,2,35,16,14
	.byte	'osEvent',0
	.word	295
	.byte	1,2,35,20,14
	.byte	'MSIInit',0
	.word	218
	.byte	2,2,35,22,0,22
	.byte	'Rte_MSITableEntry',0,19,172,2,3
	.word	11801
	.byte	9
	.word	218
	.byte	9
	.word	295
	.byte	22
	.byte	'Rte_TaskArrayIndex',0,19,179,2,16
	.word	295
	.byte	22
	.byte	'Rte_NrWaitingTasks',0,19,180,2,16
	.word	295
	.byte	13,19,182,2,9,4,14
	.byte	'pending',0
	.word	295
	.byte	1,2,35,0,14
	.byte	'count',0
	.word	295
	.byte	1,2,35,1,14
	.byte	'firstWaitingTask',0
	.word	295
	.byte	1,2,35,2,0,22
	.byte	'Rte_WaitableDatum',0,19,186,2,3
	.word	12019
	.byte	9
	.word	12019
	.byte	13,19,226,2,9,12,14
	.byte	'event_id',0
	.word	2395
	.byte	4,2,35,0,14
	.byte	'wd',0
	.word	12111
	.byte	4,2,35,4,14
	.byte	'timeout',0
	.word	2395
	.byte	4,2,35,8,0,22
	.byte	'Rte_WOWP_NotificationType',0,19,230,2,3
	.word	12116
	.byte	10
	.word	12116
	.byte	9
	.word	12205
	.byte	22
	.byte	'Rte_WOWP_NotificationRefType',0,19,232,2,66
	.word	12210
	.byte	22
	.byte	'Rte_ARE_NotificationType',0,19,234,2,29
	.word	11544
	.byte	26
	.byte	'Rte_QTaskType',0,19,243,2,16,28,14
	.byte	'cmn',0
	.word	8167
	.byte	24,2,35,0,14
	.byte	'task',0
	.word	11402
	.byte	4,2,35,24,0,22
	.byte	'Rte_QTaskType',0,19,246,2,3
	.word	12287
	.byte	26
	.byte	'Rte_QREType',0,19,250,2,16,28,14
	.byte	'cmn',0
	.word	8167
	.byte	24,2,35,0,14
	.byte	're',0
	.word	11633
	.byte	4,2,35,24,0,22
	.byte	'Rte_QREType',0,19,253,2,3
	.word	12358
	.byte	10
	.word	11544
	.byte	9
	.word	12423
	.byte	26
	.byte	'Rte_QWWPType',0,19,129,3,16,28,14
	.byte	'cmn',0
	.word	8167
	.byte	24,2,35,0,14
	.byte	'wwp',0
	.word	12215
	.byte	4,2,35,24,0,22
	.byte	'Rte_QWWPType',0,19,132,3,3
	.word	12433
	.byte	10
	.word	12116
	.byte	9
	.word	12501
	.byte	26
	.byte	'Rte_QEvType',0,19,136,3,16,36,14
	.byte	'cmn',0
	.word	8167
	.byte	24,2,35,0,14
	.byte	'task',0
	.word	11402
	.byte	4,2,35,24,14
	.byte	'mask',0
	.word	295
	.byte	1,2,35,28,14
	.byte	'acnt',0
	.word	11511
	.byte	4,2,35,32,0,22
	.byte	'Rte_QEvType',0,19,141,3,3
	.word	12511
	.byte	26
	.byte	'Rte_QMSIType',0,19,145,3,16,48,14
	.byte	'cmn',0
	.word	8167
	.byte	24,2,35,0,14
	.byte	'task',0
	.word	11402
	.byte	4,2,35,24,14
	.byte	'mask',0
	.word	295
	.byte	1,2,35,28,14
	.byte	'acnt',0
	.word	11511
	.byte	4,2,35,32,14
	.byte	'msiCounter',0
	.word	11698
	.byte	4,2,35,36,14
	.byte	'msiPending',0
	.word	11766
	.byte	4,2,35,40,14
	.byte	'msiLimit',0
	.word	218
	.byte	2,2,35,44,0,22
	.byte	'Rte_QMSIType',0,19,153,3,3
	.word	12606
	.byte	22
	.byte	'rba_BswSrv_uint64',0,20,66,28
	.word	2426
	.byte	33
	.byte	'NvM_Prv_Main_st',0,5,59,31
	.word	11266
	.byte	1,1,34
	.word	295
	.byte	1,1,28
	.word	383
	.byte	0,9
	.word	12813
	.byte	22
	.byte	'NvM_Prv_ExplicitSync_Copy_tpfct',0,1,29,26
	.word	12826
	.byte	2,1,34,9,4,3
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_READ_ALL',0,1,3
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_WRITE_ALL',0,2,3
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_FIRST_INIT_ALL',0,4,3
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_INIT_AT_LAYOUT_CHANGE',0,8,3
	.byte	'NVM_PRV_BLOCK_FLAG_WRITE_PROTECTED',0,16,3
	.byte	'NVM_PRV_BLOCK_FLAG_WRITE_ONCE',0,32,3
	.byte	'NVM_PRV_BLOCK_FLAG_RESISTANT_TO_CHANGED_SW',0,192,0,3
	.byte	'NVM_PRV_BLOCK_FLAG_USE_SYNC_MECHANISM',0,128,1,3
	.byte	'NVM_PRV_BLOCK_FLAG_USE_AUTO_VALIDATION',0,128,2,3
	.byte	'NVM_PRV_BLOCK_FLAG_USE_VARIABLE_BLOCK_LENGTH',0,128,4,3
	.byte	'NVM_PRV_BLOCK_FLAG_SELECT_FOR_MIGRATION',0,128,8,3
	.byte	'NVM_PRV_BLOCK_FLAG_RAM_INIT_UNCONDITIONAL',0,128,16,0,22
	.byte	'NvM_Prv_BlockConfiguration_ten',0,1,85,3
	.word	12871
	.byte	10
	.word	218
	.byte	9
	.word	13434
	.byte	10
	.word	383
	.byte	9
	.word	13444
	.byte	34
	.word	295
	.byte	1,1,28
	.word	295
	.byte	28
	.word	295
	.byte	0,9
	.word	13454
	.byte	34
	.word	295
	.byte	1,1,28
	.word	295
	.byte	0,9
	.word	13477
	.byte	9
	.word	5401
	.byte	13,1,121,9,48,14
	.byte	'idBlockMemIf_u16',0
	.word	218
	.byte	2,2,35,0,14
	.byte	'nrBlockBytes_pu16',0
	.word	13439
	.byte	4,2,35,4,14
	.byte	'idxDevice_u8',0
	.word	295
	.byte	1,2,35,8,14
	.byte	'nrNvBlocks_u8',0
	.word	295
	.byte	1,2,35,9,14
	.byte	'nrRomBlocks_u8',0
	.word	295
	.byte	1,2,35,10,14
	.byte	'adrRamBlock_ppv',0
	.word	13449
	.byte	4,2,35,12,14
	.byte	'adrRomBlock_pcv',0
	.word	455
	.byte	4,2,35,16,14
	.byte	'SingleBlockCallback_pfct',0
	.word	13472
	.byte	4,2,35,20,14
	.byte	'SingleBlockStartCallback_pfct',0
	.word	13490
	.byte	4,2,35,24,14
	.byte	'InitBlockCallback_pfct',0
	.word	13495
	.byte	4,2,35,28,14
	.byte	'ReadRamBlockFromNvm_pfct',0
	.word	12826
	.byte	4,2,35,32,14
	.byte	'WriteRamBlockToNvm_pfct',0
	.word	12826
	.byte	4,2,35,36,14
	.byte	'BlockManagementType_en',0
	.word	151
	.byte	4,2,35,40,14
	.byte	'JobPriority_u8',0
	.word	295
	.byte	1,2,35,44,14
	.byte	'stFlags_u16',0
	.word	218
	.byte	2,2,35,46,0,22
	.byte	'NvM_Prv_BlockDescriptor_tst',0,1,138,2,3
	.word	13500
	.byte	23,160,5
	.word	13500
	.byte	24,13,0,10
	.word	13964
	.byte	33
	.byte	'NvM_Prv_BlockDescriptors_acst',0,1,169,2,45
	.word	13974
	.byte	1,1,23,14
	.word	295
	.byte	24,13,0,33
	.byte	'NvM_Prv_stBlock_rAwAM_au8',0,3,59,14
	.word	14020
	.byte	1,1,33
	.byte	'NvM_Prv_idxDataSet_rAMwA_au8',0,3,81,14
	.word	14020
	.byte	1,1,0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L36:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,4,1,58,15,59,15,57,15,11,15,0,0,3,40,0,3,8,28,13,0,0,4
	.byte	36,0,3,8,11,15,62,15,0,0,5,46,1,3,8,32,13,58,15,59,15,57,15,73,19,54,15,39,12,0,0,6,5,0,3,8,58,15,59,15
	.byte	57,15,73,19,0,0,7,11,0,0,0,8,59,0,3,8,0,0,9,15,0,73,19,0,0,10,38,0,73,19,0,0,11,11,1,0,0,12,46,1,3,8,32
	.byte	13,58,15,59,15,57,15,54,15,39,12,0,0,13,19,1,58,15,59,15,57,15,11,15,0,0,14,13,0,3,8,73,19,11,15,56,9
	.byte	0,0,15,46,1,3,8,58,15,59,15,57,15,73,19,54,15,39,12,63,12,60,12,0,0,16,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,60,12,0,0,17,46,1,49,19,0,0,18,5,0,49,19,0,0,19,29,1,49,19,0,0,20,11,0,49,19,0,0,21,21,0,54
	.byte	15,0,0,22,22,0,3,8,58,15,59,15,57,15,73,19,0,0,23,1,1,11,15,73,19,0,0,24,33,0,47,15,0,0,25,21,0,54,15
	.byte	39,12,0,0,26,19,1,3,8,58,15,59,15,57,15,11,15,0,0,27,21,1,54,15,39,12,0,0,28,5,0,73,19,0,0,29,23,1,58
	.byte	15,59,15,57,15,11,15,0,0,30,4,1,3,8,58,15,59,15,57,15,11,15,0,0,31,21,0,73,19,54,15,39,12,0,0,32,53,0
	.byte	73,19,0,0,33,52,0,3,8,58,15,59,15,57,15,73,19,63,12,60,12,0,0,34,21,1,73,19,54,15,39,12,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L37:
	.word	.L130-.L129
.L129:
	.half	3
	.word	.L132-.L131
.L131:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockDescriptor.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\NvM\\api\\NvM_Types.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockData.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionArbitrate.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_Queue.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_ErrorDetection.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_ProcessMultiBlock.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Platform\\Platform_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Std_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Can_GeneralTypes.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\RTOS_T\\Gen\\inc\\Os.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Can_17_MCanP\\inc\\Can_17_MCanP.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Type.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\MemIf\\api\\MemIf_Types.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Intl.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\rba_BswSrv.h',0,0,0,0,0
.L132:
.L130:
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_StartJob')
	.sect	'.debug_info'
.L38:
	.word	298
	.half	3
	.word	.L39
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionArbitrate.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L41,.L40
	.byte	2
	.word	.L34
	.byte	3
	.byte	'NvM_Prv_StartJob',0,1,41,6,1,1,1
	.word	.L31,.L48,.L30
	.byte	4
	.byte	'idJob_en',0,1,41,41
	.word	.L49,.L50
	.byte	4
	.byte	'idBlock_uo',0,1,42,39
	.word	.L51,.L52
	.byte	4
	.byte	'RamBlock_pu8',0,1,43,30
	.word	.L53,.L54
	.byte	4
	.byte	'idxDataset_u8',0,1,44,29
	.word	.L55,.L56
	.byte	5
	.word	.L31,.L48
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_StartJob')
	.sect	'.debug_abbrev'
.L39:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_StartJob')
	.sect	'.debug_line'
.L40:
	.word	.L134-.L133
.L133:
	.half	3
	.word	.L136-.L135
.L135:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionArbitrate.c',0,0,0,0,0
.L136:
	.byte	5,5,7,0,5,2
	.word	.L31
	.byte	3,46,1,5,41,9
	.half	.L137-.L31
	.byte	1,5,46,9
	.half	.L138-.L137
	.byte	3,7,1,5,44,9
	.half	.L139-.L138
	.byte	3,1,1,5,42,9
	.half	.L140-.L139
	.byte	1,5,43,9
	.half	.L141-.L140
	.byte	3,1,1,5,45,9
	.half	.L142-.L141
	.byte	3,1,1,5,41,9
	.half	.L143-.L142
	.byte	3,2,1,5,39,9
	.half	.L144-.L143
	.byte	1,5,1,9
	.half	.L145-.L144
	.byte	3,1,1,7,9
	.half	.L42-.L145
	.byte	0,1,1
.L134:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_StartJob')
	.sect	'.debug_ranges'
.L41:
	.word	-1,.L31,0,.L42-.L31,0,0
	.sdecl	'.debug_info',debug,cluster('NvM_Prv_MainFunctionArbitrate')
	.sect	'.debug_info'
.L43:
	.word	782
	.half	3
	.word	.L44
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionArbitrate.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L46,.L45
	.byte	2
	.word	.L34
	.byte	3
	.byte	'NvM_Prv_MainFunctionArbitrate',0,1,73,6,1,1,1
	.word	.L33,.L57,.L32
	.byte	4
	.word	.L33,.L57
	.byte	4
	.word	.L58,.L10
	.byte	5
	.byte	'idJob_en',0,1,80,27
	.word	.L49,.L59
	.byte	6
	.word	.L60,.L58,.L9
	.byte	7
	.word	.L61,.L62
	.byte	7
	.word	.L63,.L64
	.byte	8
	.word	.L65,.L58,.L9
	.byte	5
	.byte	'idJobNext_en',0,1,116,23
	.word	.L49,.L66
	.byte	0,0,4
	.word	.L67,.L10
	.byte	5
	.byte	'idBlock_uo',0,1,85,29
	.word	.L51,.L68
	.byte	6
	.word	.L69,.L70,.L14
	.byte	7
	.word	.L71,.L72
	.byte	7
	.word	.L73,.L74
	.byte	7
	.word	.L75,.L76
	.byte	8
	.word	.L77,.L70,.L14
	.byte	6
	.word	.L78,.L70,.L79
	.byte	7
	.word	.L80,.L81
	.byte	8
	.word	.L82,.L70,.L79
	.byte	5
	.byte	'PRamBlockAddress_pv',0,2,150,4,12
	.word	.L83,.L84
	.byte	0,0,6
	.word	.L85,.L86,.L87
	.byte	7
	.word	.L88,.L89
	.byte	7
	.word	.L90,.L91
	.byte	7
	.word	.L92,.L93
	.byte	9
	.word	.L94,.L86,.L87
	.byte	0,6
	.word	.L85,.L95,.L96
	.byte	7
	.word	.L88,.L89
	.byte	7
	.word	.L90,.L91
	.byte	7
	.word	.L92,.L93
	.byte	9
	.word	.L94,.L95,.L96
	.byte	0,0,0,6
	.word	.L97,.L14,.L28
	.byte	7
	.word	.L98,.L99
	.byte	7
	.word	.L100,.L101
	.byte	10
	.word	.L102,.L103
	.byte	5
	.byte	'idxDataset_u8',0,1,187,1,11
	.word	.L55,.L105
	.byte	6
	.word	.L106,.L14,.L107
	.byte	7
	.word	.L108,.L109
	.byte	8
	.word	.L110,.L14,.L107
	.byte	5
	.byte	'BlockType',0,2,214,3,29
	.word	.L111,.L112
	.byte	0,0,6
	.word	.L113,.L25,.L26
	.byte	7
	.word	.L114,.L115
	.byte	9
	.word	.L116,.L25,.L26
	.byte	0,0,0,6
	.word	.L97,.L104,.L10
	.byte	7
	.word	.L98,.L99
	.byte	7
	.word	.L100,.L101
	.byte	0,0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('NvM_Prv_MainFunctionArbitrate')
	.sect	'.debug_abbrev'
.L44:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,11,1,17,1,18,1,0,0,5,52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,6,29,1
	.byte	49,16,17,1,18,1,0,0,7,5,0,49,16,2,6,0,0,8,11,1,49,16,17,1,18,1,0,0,9,11,0,49,16,17,1,18,1,0,0,10,11,1
	.byte	49,16,85,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('NvM_Prv_MainFunctionArbitrate')
	.sect	'.debug_line'
.L45:
	.word	.L147-.L146
.L146:
	.half	3
	.word	.L149-.L148
.L148:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_MainFunctionArbitrate.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockDescriptor.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\NvM\\src\\NvM_Prv_BlockData.h',0,0,0,0,0
.L149:
	.byte	5,5,7,0,5,2
	.word	.L33
	.byte	3,203,0,1,5,20,9
	.half	.L150-.L33
	.byte	1,5,88,9
	.half	.L151-.L150
	.byte	1,5,38,9
	.half	.L152-.L151
	.byte	1,5,36,9
	.half	.L153-.L152
	.byte	3,2,1,5,9,9
	.half	.L154-.L153
	.byte	1,5,5,9
	.half	.L155-.L154
	.byte	1,5,36,7,9
	.half	.L58-.L155
	.byte	3,38,1,5,10,9
	.half	.L117-.L58
	.byte	3,2,1,5,9,9
	.half	.L156-.L117
	.byte	1,5,45,7,9
	.half	.L157-.L156
	.byte	1,5,54,9
	.half	.L158-.L157
	.byte	1,5,40,7,9
	.half	.L159-.L158
	.byte	3,2,1,5,9,9
	.half	.L160-.L159
	.byte	1,5,50,7,9
	.half	.L161-.L160
	.byte	3,3,1,5,65,9
	.half	.L162-.L161
	.byte	1,5,58,9
	.half	.L5-.L162
	.byte	3,5,1,5,72,9
	.half	.L163-.L5
	.byte	3,1,1,9
	.half	.L164-.L163
	.byte	3,1,1,5,13,9
	.half	.L118-.L164
	.byte	3,126,1,5,63,7,9
	.half	.L165-.L118
	.byte	3,5,1,5,79,9
	.half	.L119-.L165
	.byte	1,5,46,9
	.half	.L7-.L119
	.byte	3,11,1,5,50,9
	.half	.L166-.L7
	.byte	3,1,1,5,48,9
	.half	.L167-.L166
	.byte	1,5,38,9
	.half	.L168-.L167
	.byte	3,1,1,5,36,9
	.half	.L169-.L168
	.byte	1,5,30,9
	.half	.L170-.L169
	.byte	3,5,1,5,5,9
	.half	.L3-.L170
	.byte	3,4,1,5,9,9
	.half	.L9-.L3
	.byte	3,184,127,1,5,57,7,9
	.half	.L67-.L9
	.byte	3,2,1,5,72,9
	.half	.L171-.L67
	.byte	1,5,69,9
	.half	.L121-.L171
	.byte	3,4,1,4,2,5,32,9
	.half	.L70-.L121
	.byte	3,189,3,1,5,9,9
	.half	.L122-.L70
	.byte	3,1,1,5,51,7,9
	.half	.L172-.L122
	.byte	3,1,1,5,22,9
	.half	.L173-.L172
	.byte	1,5,51,9
	.half	.L174-.L173
	.byte	1,5,63,9
	.half	.L175-.L174
	.byte	1,5,10,9
	.half	.L176-.L175
	.byte	1,5,19,9
	.half	.L177-.L176
	.byte	1,5,31,7,9
	.half	.L178-.L177
	.byte	3,2,1,5,5,9
	.half	.L11-.L178
	.byte	3,3,1,4,1,9
	.half	.L13-.L11
	.byte	3,133,125,1,5,13,7,9
	.half	.L79-.L13
	.byte	3,2,1,5,14,7,9
	.half	.L179-.L79
	.byte	3,1,1,5,53,9
	.half	.L180-.L179
	.byte	1,5,38,7,9
	.half	.L181-.L180
	.byte	3,1,1,5,14,7,9
	.half	.L182-.L181
	.byte	3,1,1,5,57,9
	.half	.L183-.L182
	.byte	1,5,48,7,9
	.half	.L15-.L183
	.byte	3,3,1,5,75,9
	.half	.L184-.L15
	.byte	1,4,3,5,47,9
	.half	.L86-.L184
	.byte	3,44,1,5,72,9
	.half	.L185-.L86
	.byte	1,5,88,9
	.half	.L186-.L185
	.byte	1,5,85,9
	.half	.L187-.L186
	.byte	1,5,67,9
	.half	.L188-.L187
	.byte	3,1,1,5,111,9
	.half	.L189-.L188
	.byte	3,127,1,5,43,9
	.half	.L190-.L189
	.byte	1,4,1,5,80,9
	.half	.L87-.L190
	.byte	3,84,1,5,14,9
	.half	.L18-.L87
	.byte	3,2,1,5,48,7,9
	.half	.L191-.L18
	.byte	3,3,1,5,75,9
	.half	.L192-.L191
	.byte	1,4,3,5,47,9
	.half	.L95-.L192
	.byte	3,39,1,5,72,9
	.half	.L193-.L95
	.byte	1,5,88,9
	.half	.L194-.L193
	.byte	1,5,85,9
	.half	.L195-.L194
	.byte	1,5,67,9
	.half	.L196-.L195
	.byte	3,1,1,5,111,9
	.half	.L197-.L196
	.byte	3,127,1,5,43,9
	.half	.L198-.L197
	.byte	1,4,1,5,101,9
	.half	.L96-.L198
	.byte	3,89,1,4,2,5,39,9
	.half	.L14-.L96
	.byte	3,167,2,1,5,5,9
	.half	.L123-.L14
	.byte	3,1,1,5,50,7,9
	.half	.L199-.L123
	.byte	3,2,1,5,21,9
	.half	.L124-.L199
	.byte	1,5,50,9
	.half	.L200-.L124
	.byte	1,5,62,9
	.half	.L201-.L200
	.byte	1,5,5,9
	.half	.L22-.L201
	.byte	3,2,1,4,1,5,9,9
	.half	.L23-.L22
	.byte	3,225,125,1,5,10,7,9
	.half	.L107-.L23
	.byte	3,1,1,5,58,9
	.half	.L125-.L107
	.byte	1,5,23,7,9
	.half	.L24-.L125
	.byte	3,2,1,5,26,9
	.half	.L126-.L24
	.byte	1,4,3,5,12,9
	.half	.L25-.L126
	.byte	3,98,1,5,40,9
	.half	.L202-.L25
	.byte	1,5,5,9
	.half	.L127-.L202
	.byte	1,4,1,9
	.half	.L26-.L127
	.byte	3,42,1,5,68,9
	.half	.L28-.L26
	.byte	3,147,127,1,5,57,9
	.half	.L104-.L28
	.byte	3,1,1,5,9,9
	.half	.L10-.L104
	.byte	3,116,1,5,45,9
	.half	.L2-.L10
	.byte	3,18,1,5,43,9
	.half	.L203-.L2
	.byte	1,5,1,9
	.half	.L29-.L203
	.byte	3,2,1,7,9
	.half	.L47-.L29
	.byte	0,1,1
.L147:
	.sdecl	'.debug_ranges',debug,cluster('NvM_Prv_MainFunctionArbitrate')
	.sect	'.debug_ranges'
.L46:
	.word	-1,.L33,0,.L47-.L33,0,0
.L103:
	.word	-1,.L33,.L14-.L33,.L28-.L33,.L104-.L33,.L10-.L33,0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_MainFunctionArbitrate')
	.sect	'.debug_loc'
.L112:
	.word	-1,.L33,.L123-.L33,.L124-.L33
	.half	1
	.byte	95
	.word	.L22-.L33,.L125-.L33
	.half	1
	.byte	95
	.word	0,0
.L32:
	.word	-1,.L33,0,.L57-.L33
	.half	2
	.byte	138,0
	.word	0,0
.L84:
	.word	-1,.L33,.L122-.L33,.L104-.L33
	.half	1
	.byte	100
	.word	0,0
.L64:
	.word	0,0
.L76:
	.word	0,0
.L68:
	.word	-1,.L33,.L121-.L33,.L10-.L33
	.half	1
	.byte	85
	.word	0,0
.L72:
	.word	0,0
.L115:
	.word	0,0
.L101:
	.word	0,0
.L89:
	.word	0,0
.L109:
	.word	0,0
.L81:
	.word	0,0
.L66:
	.word	-1,.L33,.L117-.L33,.L118-.L33
	.half	1
	.byte	82
	.word	.L119-.L33,.L7-.L33
	.half	1
	.byte	82
	.word	.L3-.L33,.L10-.L33
	.half	1
	.byte	82
	.word	0,0
.L59:
	.word	-1,.L33,.L120-.L33,.L10-.L33
	.half	1
	.byte	84
	.word	0,0
.L74:
	.word	0,0
.L99:
	.word	0,0
.L62:
	.word	0,0
.L105:
	.word	-1,.L33,.L126-.L33,.L25-.L33
	.half	1
	.byte	86
	.word	.L127-.L33,.L10-.L33
	.half	1
	.byte	86
	.word	0,0
.L93:
	.word	0,0
.L91:
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('NvM_Prv_StartJob')
	.sect	'.debug_loc'
.L30:
	.word	-1,.L31,0,.L48-.L31
	.half	2
	.byte	138,0
	.word	0,0
.L54:
	.word	-1,.L31,0,.L48-.L31
	.half	1
	.byte	100
	.word	0,0
.L52:
	.word	-1,.L31,0,.L48-.L31
	.half	1
	.byte	85
	.word	0,0
.L50:
	.word	-1,.L31,0,.L48-.L31
	.half	1
	.byte	84
	.word	0,0
.L56:
	.word	-1,.L31,0,.L48-.L31
	.half	1
	.byte	86
	.word	0,0
	.sdecl	'.debug_frame',debug
	.sect	'.debug_frame'
.L204:
	.word	48
	.word	-1
	.byte	3,0,2,1,27,12,26,0,8,27,8,26,8,28,8,29,8,30,8,31,8,34,8,35,8,32,8,33,8,16,8,17,8,24,8,25,8,36,8,37,8,38
	.byte	8,39
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_StartJob')
	.sect	'.debug_frame'
	.word	24
	.word	.L204,.L31,.L48-.L31
	.byte	8,18,8,19,8,21,8,22,8,23,0,0
	.sdecl	'.debug_frame',debug,cluster('NvM_Prv_MainFunctionArbitrate')
	.sect	'.debug_frame'
	.word	12
	.word	.L204,.L33,.L57-.L33

; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   192      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   193      else
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   194      {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   195  #if (NVM_RB_AUX_INTERFACE == STD_ON)
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   196          if (NvM_Prv_IsAuxServiceActive())
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   197          {
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   198              idBlock_uo = NVM_PRV_AUX_ADMIN_BLOCK;
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   199          }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   200  #endif
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   201          idxDataset_u8 = NvM_Prv_Block_GetIdxDataset(idBlock_uo);
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   202      }
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   203      return idxDataset_u8;
; BSW\src\BSW\Gen\NvM\src\NvM_MainFunctionArbitrate.c	   204  }

	; Module end
