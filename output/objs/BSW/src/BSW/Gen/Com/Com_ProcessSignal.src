	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 19053136 SN 09001910"
	.compiler_invocation	"ctc -f cc2792a -c99 --integer-enumeration -D__CPU__=tc27x -D__CPU_TC27X__ --core=tc1.6.x --eabi-compliant --fp-model=-float -D_TASKING_C_TRICORE_=1 -I.\\output\\inc -g2 -t4 --language=-comments,-gcc,+volatile,-strings --default-near-size=0 -O2ROPYGKLF-predict --default-a1-size=0 --default-a0-size=0 --source --switch=auto -o output\\objs\\BSW\\src\\BSW\\Gen\\Com\\Com_ProcessSignal.src BSW\\src\\BSW\\Gen\\Com\\src\\Com_ProcessSignal.c"
	.compiler_name		"ctc"
	;source	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_ProcessSignal.c'

	
$TC16X
	
	.sdecl	'.text.Com_ProcessSignal.Com_Prv_ProcessSignal',code,cluster('Com_Prv_ProcessSignal')
	.sect	'.text.Com_ProcessSignal.Com_Prv_ProcessSignal'
	.align	2
	
	.global	Com_Prv_ProcessSignal

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	     1  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	     2  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	     3  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	     4   * Preprocessor includes
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	     5   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	     6  #include "Com_Prv.h"
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	     7  #include "Com_Prv_Inl.h"
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	     8  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	     9  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    10   * Local Prototypes
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    11   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    12  #ifdef COM_RxSigUpdateBit
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    13  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_ProcessSigUpdateBit(
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    14                                          VAR(Com_SignalIdType,AUTOMATIC)                 SignalId,
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    15                                          P2CONST(PduInfoType, AUTOMATIC, COM_APPL_DATA)  PduInfoPtr,
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    16                                          VAR(uint8, AUTOMATIC)                           UpdateBitStatus,
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    17                                          P2VAR(uint16_least, AUTOMATIC, COM_APPL_DATA)   Idx_SigToutPtr
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    18                                                                  );
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    19  #endif
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    20  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    21  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_CopyRxSignal(
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    22                                          VAR(Com_SignalIdType,AUTOMATIC)                 SignalId,
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    23                                          P2CONST(PduInfoType, AUTOMATIC, COM_APPL_DATA)  PduInfoPtr,
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    24                                          VAR(Com_BitsizeType, AUTOMATIC)                 Size
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    25                                                           );
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    26  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    27  #if defined(COM_RxSigInvalid) || defined (COM_RxFilters)
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    28  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_ValidateRxSignal(
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    29                                          VAR(Com_SignalIdType, AUTOMATIC)                SignalId,
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    30                                          P2VAR(Com_SigMaxType, AUTOMATIC, COM_APPL_DATA) RxNewValPtr
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    31                                                              );
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    32  #endif
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    33  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    34  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    35   * Global functions (declared in header files )
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    36   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    37  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    38   Function name    : Com_Prv_ProcessSignal
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    39   Syntax           : void Com_Prv_ProcessSignal( PduIdType RxPduId, const PduInfoType * PduInfoPtr )
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    40   Description      : Process rx-signals of the received I-PDU.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    41   Parameter        : RxPduId    - ID of the received I-PDU.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    42                    : PduInfoPtr - Contains the length (SduLength) of the received I-PDU and
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    43                                   a pointer to a buffer (SduDataPtr) containing the I-PDU.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    44   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    45   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    46  #define COM_START_SEC_CODE
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    47  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    48  FUNC(void, COM_CODE) Com_Prv_ProcessSignal(
; Function Com_Prv_ProcessSignal
.L41:
Com_Prv_ProcessSignal:	.type	func
	sub.a	a10,#8
.L138:
	mov.aa	a12,a4
.L139:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    49                                  VAR(PduIdType, AUTOMATIC)                       RxPduId,
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    50                                  P2CONST(PduInfoType, AUTOMATIC, COM_APPL_DATA)  PduInfoPtr
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    51                                            )
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    52  {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    53      Com_RxIpduConstPtrType          RxIPduConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    54      Com_RxSigConstPtrType           RxSigConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    55      Com_RxSigRamPtrType             RxSigRamPtr;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    56      VAR(uint16_least, AUTOMATIC)    Idx_Sig_ui;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    57      VAR(uint16_least, AUTOMATIC)    limit_ui;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    58  #ifdef COM_RxSigUpdateBit
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    59      VAR(uint16_least, AUTOMATIC)    Idx_SigTout;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    60      VAR(uint8, AUTOMATIC)           UpdateBitStatus;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    61  #endif
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    62      /* This variable is used to decide whether to copy the new value of the signal into signal buffer or not */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    63      VAR(boolean, AUTOMATIC)         ProcessSignal_b;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    64  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    65      RxIPduConstPtr = COM_GET_RX_IPDU_CONSTDATA(RxPduId);
	movh.a	a15,#@his(Com_Prv_xRxIpduCfg_acst)
	lea	a15,[a15]@los(Com_Prv_xRxIpduCfg_acst)
	st.a	[a10]4,a15
	mul	d15,d4,#20
	addsc.a	a15,a15,d15,#0
.L140:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    66  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    67  #ifdef COM_RxSigUpdateBit
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    68  #ifdef COM_RxSigUpdateTimeout
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    69  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    70      /* If this IPDU has signals with update-bits , initialise the pointers
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    71       * Separate deadline monitoring should be performed for signals with update-bit
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    72       * Deadline monitoring should not be done if it is disabled
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    73       */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    74      /* MR12 RULE 13.5 VIOLATION: Below conditional statement access RAM, use of intermediate variables
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    75       * to store and read here, may read obsolete value. Evaluation(or no evaluation) shall not impact the
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    76       * system behaviour. Hence suppressed. */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    77      if ((RxIPduConstPtr->SignalTimeout_Ref != NULL_PTR) && (COM_CheckRxIPduDMStatus(RxPduId)))
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    78      {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    79  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    80          /* Update the variable UpdateBitStatus with value UPDATEBIT_APPLICABLE
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    81           * ie at least one of the signal within the IPDU is configured with both update-bit and deadline monitoring.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    82           */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    83          UpdateBitStatus = UPDATEBIT_APPLICABLE;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    84      }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    85      else
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    86  #endif /* #ifdef COM_RxSigUpdateTimeout */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    87      {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    88          UpdateBitStatus = UPDATEBIT_NOT_APPLICABLE;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    89      }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    90  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    91      /* Initialize the variable to be used to refer the first signal timeout configuration */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    92      Idx_SigTout = 0u;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    93  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    94  #endif /* #ifdef COM_RxSigUpdateBit */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    95  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    96      limit_ui      = (uint16_least)RxIPduConstPtr->RxSigId_Index + (uint16_least)RxIPduConstPtr->No_Of_Sig_Ref;
	ld.bu	d9,[a15]16
.L142:
	ld.hu	d8,[a15]14
.L143:
	add	d8,d9
.L186:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    97      RxSigRamPtr   = &COM_GET_RXSIGNALFLAG(RxIPduConstPtr->RxSigId_Index);
	movh.a	a15,#@his(Com_RxSignalFlag)
.L141:
	lea	a15,[a15]@los(Com_RxSignalFlag)
	addsc.a	a13,a15,d9,#0
.L144:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    98      RxSigConstPtr = COM_GET_RXSIG_CONSTDATA(RxIPduConstPtr->RxSigId_Index);
	movh.a	a15,#@his(Com_Prv_xRxSigCfg_acst)
	lea	a15,[a15]@los(Com_Prv_xRxSigCfg_acst)
	st.a	[a10],a15
	sha	d15,d9,#4
	addsc.a	a14,a15,d15,#0
.L145:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	    99  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   100  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   101      for (Idx_Sig_ui = (uint16_least)RxIPduConstPtr->RxSigId_Index; Idx_Sig_ui < limit_ui; Idx_Sig_ui++)
	j	.L2
.L3:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   102      {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   103          /* Initialise to TRUE i.e., proceed further to process the received signal */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   104          ProcessSignal_b = COM_TRUE;
	mov	d3,#1
.L67:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   105  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   106  #ifdef COM_RxSigUpdateBit
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   107          /* Returns false if signal UpdateBit is configured and is received with reset state,
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   108           * otherwise true is returned */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   109          if (Com_Prv_ProcessSigUpdateBit( (Com_SignalIdType)Idx_Sig_ui, PduInfoPtr, UpdateBitStatus, &Idx_SigTout ))
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   110  #endif /* #ifdef COM_RxSigUpdateBit */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   111          {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   112              VAR(Com_BitsizeType, AUTOMATIC)     Size;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   113              VAR(uint8, AUTOMATIC)               ConstByteValue_u8;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   114              VAR(uint8, AUTOMATIC)               SigType;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   115              VAR(uint8, AUTOMATIC)               SigEndianess;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   116  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   117              ConstByteValue_u8  = RxSigConstPtr->General;
	ld.bu	d15,[a14]12
.L146:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   118  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   119              SigType            = Com_GetValue(GEN,_TYPE,ConstByteValue_u8);
	mov	d1,#5
.L73:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
	sha	d0,d15,#0
.L187:
	mov	d2,#255
.L188:
	rsub	d1,d1,#8
.L189:
	rsub	d1,#0
	sh	d2,d2,d1
.L190:
	and	d0,d2
.L191:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));      (inlined)
	j	.L4

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }      (inlined)
.L4:
	mov	d1,#1
.L192:
	sh	d1,#5
.L193:
	and	d15,d1
.L147:
	ne	d15,d15,#0
.L194:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);      (inlined)
	j	.L5

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }      (inlined)
.L5:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   120              SigEndianess       = Com_GetValue(GEN,_ENDIANESS,ConstByteValue_u8);
	ne	d1,d15,#0
.L148:
	j	.L7
.L6:
	mov	d1,#0
.L7:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   121  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   122  #ifdef COM_RX_DYNAMIC_SIGNAL_SUPPORT
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   123              if (SigType != COM_UINT8_DYN)
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   124  #endif
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   125              {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   126                  VAR(PduLengthType, AUTOMATIC) SigLastByteNo;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   127  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   128                  Size = RxSigConstPtr->BitSize;
	ld.bu	d10,[a14]10
.L89:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   129  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   130                  /* Calculate the last byte where the signal span in the Rx-IPdu buffer
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   131                   * COM_LITTLEENDIAN : MSB > LSB; i.e, signal last byte is same as the byte where MSB is configured.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   132                   * COM_BIGENDIAN    : LSB > MSB; i.e, signal last byte is same as the byte where LSB is configured.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   133                   */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   134                  if (SigEndianess == COM_LITTLEENDIAN)
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   135                  {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   136                      VAR(Com_BitpositionType, AUTOMATIC) lastBitPosition;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   137  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   138                      /* Currently COM_OPAQUE is same as COM_LITTLEENDIAN and
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   139                       * its SignalLength in bytes is stored in BitSize */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   140                      lastBitPosition = (RxSigConstPtr->Bit_Pos +
	ld.bu	d2,[a14]8
.L90:
	jne	d1,#0,.L8
.L91:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   141                                        ((SigType == COM_UINT8_N) ? ((Com_BitpositionType)Size * 8u) : Size));
	mov	d15,#8
.L195:
	jne	d15,d0,.L9
.L196:
	sh	d15,d10,#3
.L197:
	j	.L10
.L9:
	mov	d15,d10
.L10:
	add	d2,d15
	extr.u	d15,d2,#0,#8
.L149:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   142  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   143                      SigLastByteNo   = (PduLengthType)((lastBitPosition != 0u) ? ((lastBitPosition - 1u) >> 3u) : (0u));
	jeq	d15,#0,.L11
.L198:
	add	d15,#-1
.L150:
	sh	d15,#-3
.L199:
	j	.L12
.L11:
	mov	d15,#0
.L12:
	j	.L13
.L8:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   144                  }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   145                  else
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   146                  {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   147                      /* COM_BIGENDIAN */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   148                      SigLastByteNo   = (PduLengthType)(RxSigConstPtr->Bit_Pos >> 3u);
	sha	d15,d2,#-3
.L13:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   149                  }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   150  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   151                  /* [SWS_Com_00574] When unpacking an I-PDU, the AUTOSAR COM module shall check the received data length
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   152                   * (PduInfoPtr->SduLength) and unpack and notify only completely received signals via ComNotification.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   153                   * Check if the Signal is part of the received rx pdu length */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   154                  if ((SigLastByteNo + 1u) > PduInfoPtr->SduLength)
	add	d15,#1
.L151:
	ld.hu	d0,[a12]4
.L200:
	ge.u	d15,d0,d15
.L201:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   155                  {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   156                      /* Signal is not received or received partially, Ignore further processing */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   157                      ProcessSignal_b = COM_FALSE;
	cmovn	d3,d15,#0
.L14:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   158                  }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   159              }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   160  #ifdef COM_RX_DYNAMIC_SIGNAL_SUPPORT
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   161              else
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   162              {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   163                  VAR(PduLengthType, AUTOMATIC) StartByteNo;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   164  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   165                  /* Calculate Dynamic Signal Start Position */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   166                  StartByteNo = (PduLengthType)(RxSigConstPtr->Bit_Pos >> 3u);
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   167  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   168                  /* Check if Dynamic Signal is received with atleast one byte */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   169                  Size = ((COM_GET_RXPDURAM_S(RxPduId).RxIPduLength > StartByteNo) ?
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   170  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   171                         /* Calculate its received length */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   172                         (Com_BitsizeType)( COM_GET_RXPDURAM_S(RxPduId).RxIPduLength - StartByteNo ) :
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   173  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   174                         /* Design Decision: Even if 0 bytes are received for a dynamic signal in RxIPdu,
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   175                          * configured Signal-ComNotification is always invoked.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   176                          * If it is not received, neither extract nor copy Dynamic Signal.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   177                          */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   178                         (0u));
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   179              }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   180  #endif /* #ifdef COM_RX_DYNAMIC_SIGNAL_SUPPORT */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   181  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   182              /* If complete signal is received, proceed to unpack and copy signal */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   183              if (ProcessSignal_b != COM_FALSE)
	jeq	d3,#0,.L15
.L202:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   184              {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   185                  ProcessSignal_b = Com_Prv_CopyRxSignal((Com_SignalIdType)Idx_Sig_ui, PduInfoPtr, Size);
	extr.u	d15,d9,#0,#16
.L94:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   186              }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   187  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   188          } /* End of Com_Prv_ProcessSigUpdateBit() check */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   189  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   190  #ifdef COM_RxSignalNotify
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   191          /* Set the _SIGNOTIF flag to invoke configured signal-ComNotification */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   192          Com_SetRamValue(RXSIG,_SIGNOTIF,RxSigRamPtr->rxSigRAMFields,ProcessSignal_b);
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   193  #else
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   194          /* return value from CopyRxSignal() is not used, if Signal notifications are not configured */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   195          (void)(ProcessSignal_b);
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   196  #endif
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   197  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   198          RxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   199          RxSigRamPtr++;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   200  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   201      } /* End of for loop */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   202  }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   203  #define COM_STOP_SEC_CODE
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   204  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   205  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   206  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   207  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   208   Function name    : Com_Prv_ProcessSigUpdateBit
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   209   Syntax           : boolean Com_Prv_ProcessSigUpdateBit( Com_SignalIdType SignalId, const PduInfoType * PduInfoPtr,
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   210                                                           uint8 UpdateBitStatus,     uint16_least * Idx_SigToutPtr )
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   211   Description      : Private function to validate signal UpdateBit
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   212   Parameter        : SignalId        - ID of rx-signal.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   213                    : PduInfoPtr      - Contains the length (SduLength) of the received I-PDU and
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   214                                        a pointer to a buffer (SduDataPtr) containing the I-PDU.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   215                      UpdateBitStatus - NOT_APPLICABLE: none of the rx-signals are configured with UB & TO
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   216                                        APPLICABLE    : some of the rx-signals are configured with UB & TO
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   217                      Idx_SigToutPtr  - Offset to be used to refer to the signal with UB & TO
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   218   Return value     : false - UpdateBit is configured & received with reset state.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   219                      true  - other cases
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   220   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   221  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   222  #ifdef COM_RxSigUpdateBit
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   223  /* MR12 RULE 8.13 VIOLATION: A pointer parameter(Idx_SigToutPtr) in a function prototype should be declared as pointer
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   224   to variable, if COM_RxSigUpdateTimeout feature is enabled then the pointer will be modified.*/
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   225  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_ProcessSigUpdateBit(
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   226                                                      VAR(Com_SignalIdType,AUTOMATIC)                 SignalId,
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   227                                                      P2CONST(PduInfoType, AUTOMATIC, COM_APPL_DATA)  PduInfoPtr,
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   228                                                      VAR(uint8, AUTOMATIC)                           UpdateBitStatus,
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   229                                                      P2VAR(uint16_least, AUTOMATIC, COM_APPL_DATA)   Idx_SigToutPtr
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   230                                                                  )
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   231  {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   232      Com_RxSigConstPtrType                                       RxSigConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   233  #ifdef COM_RxSigUpdateTimeout
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   234      Com_RxIpduConstPtrType                                      RxIPduConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   235      P2CONST(Com_SignalTimeoutInfo, AUTOMATIC, COM_APPL_CONST)   SigTimeOutConfigPtr;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   236      P2VAR(uint16, AUTOMATIC, COM_APPL_DATA)                     SigTimeOutTicksPtr;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   237  #endif
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   238      VAR(boolean, AUTOMATIC)                                     IsUpdateBitSet;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   239  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   240      /* Initialize update bit to true */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   241      IsUpdateBitSet = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   242  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   243      RxSigConstPtr  = COM_GET_RXSIG_CONSTDATA(SignalId);
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   244  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   245      /* Check for the update bit if configured */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   246      if (Com_GetValue(GEN,_UPDBITCONF,RxSigConstPtr->General))
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   247      {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   248          VAR(PduLengthType, AUTOMATIC) UB_ByteNo_u8;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   249          VAR(boolean, AUTOMATIC)       updateBitValue_b;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   250  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   251          UB_ByteNo_u8     = (PduLengthType)(RxSigConstPtr->Update_Bit_Pos >> 3u);
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   252  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   253          updateBitValue_b = Com_GetUpdateBitValue(PduInfoPtr->SduDataPtr, RxSigConstPtr->Update_Bit_Pos, UB_ByteNo_u8);
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   254  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   255          /* Start: Check if the Update bit is SET or NOT */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   256          if (((UB_ByteNo_u8 + 1u) <= PduInfoPtr->SduLength) && (updateBitValue_b == COM_FALSE))
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   257          {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   258              /* [SWS_Com_00802] If a signal or signal group with an attached update bit is received and
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   259               * the update-bit is not set, the AUTOSAR COM module shall discard this signal.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   260               * If the signal has not been updated, the signal will not be routed via the signal gateway.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   261               * It will only be discarded.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   262               * If the RTE reads a signal with an associated cleared update-bit, the init value or
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   263               * the last received value is returned. */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   264              IsUpdateBitSet  = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   265          }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   266  #ifdef COM_RxSigUpdateTimeout
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   267          else
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   268          {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   269              /* [SWS_Com_00794] In case of receiving of a smaller I-PDU than expected results into receiving a
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   270               * signal without its configured update-bit, the AUTOSAR COM module shall treat this signal as if
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   271               * its update bit was set and interpret such a signal as updated.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   272               * If UpdateBitStatus is UPDATEBIT_NOT_APPLICABLE(0x0), then it remains unchanged.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   273               * If UpdateBitStatus is UPDATEBIT_APPLICABLE(0x1), then it is changed to UPDATEBIT_SET(0x2) here.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   274               */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   275              UpdateBitStatus <<= 1u;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   276          }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   277  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   278          /* Check if deadline monitoring needs to be performed for signal with update-bit, within
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   279           * this IPDU.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   280           * This variable would be set UBDATEBIT_APPLICABLE only if atleast one the signal group within
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   281           * the IPDU has configured update-bit & timeout value and deadline monitoring for IPDU
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   282           * is not disabled.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   283           * check if present signal with update-bit has configured time out.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   284           * Only the signals with update-bit and configured timeout will be present in structure
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   285           * Com_SignalTimeoutInfo.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   286           */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   287          if (UpdateBitStatus != UPDATEBIT_NOT_APPLICABLE)
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   288          {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   289              RxIPduConstPtr = COM_GET_RX_IPDU_CONSTDATA(RxSigConstPtr->IpduRef);
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   290  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   291              /* Increment pointers to refer to current signal with update-bit & configured timeout
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   292               * (within this IPDU) */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   293              SigTimeOutConfigPtr = (RxIPduConstPtr->SignalTimeout_Ref->TimeoutInfo_Ref) + (*Idx_SigToutPtr);
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   294  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   295              if (SigTimeOutConfigPtr->SigId == (uint16)SignalId)
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   296              {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   297                  if (UpdateBitStatus == UPDATEBIT_SET)
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   298                  {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   299                      /* Increment pointer to refer to current signal timer
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   300                       * (within this IPDU) */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   301                      SigTimeOutTicksPtr  = (RxIPduConstPtr->SignalTimeout_Ref->TimeoutTicks_p) + (*Idx_SigToutPtr);
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   302  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   303                      /* Reload the timer for signal with TimeOut value
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   304                       * Timer should be reloaded only if corresponding update-bit is set for the signal
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   305                       * It is ensured by the code generator that if TimeOut value is zero, then the
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   306                       * signal is not considered for deadline monitoring and hence an entry is the
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   307                       * structure Com_SignalTimeoutInfo is not present.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   308                       * Hence there is no need to check for zero value of TimeOut.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   309                       */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   310                      SchM_Enter_Com_RxSigToTicks();
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   311  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   312  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   313  #if (COM_ENABLE_JITTERFLITER == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   314                      /* CC requirements:
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   315                       * An extra cycle is added to the timeout value after a PDU has been received incase filter is ON
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   316                       * Provides a chance incase of jitter( extra cycle is added in normal case and hence
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   317                       * if JITTERFILTER is enabled extra two cycles are added)
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   318                       */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   319                      (*SigTimeOutTicksPtr) = SigTimeOutConfigPtr->Timeout + 2;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   320  #else
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   321  /* FC_VariationPoint_END   */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   322                      /* Extra cycle is added to prevent early timeouts */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   323                      (*SigTimeOutTicksPtr) = SigTimeOutConfigPtr->Timeout + 1;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   324  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   325  #endif /* #ifdef COM_ENABLE_JITTERFLITER */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   326  /* FC_VariationPoint_END   */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   327  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   328                      SchM_Exit_Com_RxSigToTicks();
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   329                  }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   330  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   331                  /* Increment signal TO instance to refer to next signal with update-bit & configured timeout
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   332                   * (within this IPDU) */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   333                  (*Idx_SigToutPtr)++;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   334  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   335              } /* Current signal matches with the signal in the timeout configuration */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   336  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   337          } /* if (UpdateBitStatus != UPDATEBIT_NOT_APPLICABLE) */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   338  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   339  #else
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   340          /* unused signal timeout parameters */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   341          (void)(UpdateBitStatus);
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   342          (void)(Idx_SigToutPtr);
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   343  #endif /* #ifdef COM_RxSigUpdateTimeout */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   344  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   345      } /* End of UpdateBit check */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   346  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   347      return IsUpdateBitSet;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   348  }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   349  #endif /* #ifdef COM_RxSigUpdateBit */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   350  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   351  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   352   Function name    : Com_Prv_CopyRxSignal
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   353   Syntax           : boolean Com_Prv_CopyRxSignal( Com_SignalIdType SignalId, const PduInfoType * PduInfoPtr,
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   354                                                Com_BitsizeType  Size )
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   355   Description      : Private function to unpack and copy rx-signal
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   356   Parameter        : SignalId   - rx-signal to be processed
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   357                      PduInfoPtr - Contains the length (SduLength) of the received I-PDU and
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   358                                   a pointer to a buffer (SduDataPtr) containing the I-PDU.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   359                      Size       - received signal length
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   360   Return value     : true  - signal is copied into buffer
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   361                      false - signal is discarded
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   362   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   363  /* HIS METRIC CALLS VIOLATION IN Com_Prv_CopyRxSignal:
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   364     Com_Prv_CopyRxSignal function contains necessary function calls statements.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   365     HIS metric compliance would decrease readability and maintainability */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   366  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_CopyRxSignal(
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   367                                                VAR(Com_SignalIdType,AUTOMATIC)                 SignalId,
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   368                                                P2CONST(PduInfoType, AUTOMATIC, COM_APPL_DATA)  PduInfoPtr,
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   369                                                VAR(Com_BitsizeType, AUTOMATIC)                 Size
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   370                                                           )
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   371  {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   372      Com_RxIpduConstPtrType                  RxIPduConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   373      Com_RxSigConstPtrType                   RxSigConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   374      Com_RxSigRamPtrType                     RxSigRamPtr;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   375      VAR(Com_SigMaxType, AUTOMATIC)          RxSigNewVal;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   376      VAR(PduIdType, AUTOMATIC)               RxPduId;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   377      VAR(Com_MainFuncType, AUTOMATIC)        rxMainFuncId;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   378      VAR(uint8, AUTOMATIC)                   ConstByteValue_u8;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   379      VAR(uint8, AUTOMATIC)                   SigType;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   380      VAR(uint8, AUTOMATIC)                   SigEndianess;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   381      VAR(boolean, AUTOMATIC)                 copySignal_b;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   382  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   383      RxSigConstPtr      = COM_GET_RXSIG_CONSTDATA(SignalId);
	sha	d15,#4
	ld.a	a15,[a10]
	addsc.a	a15,a15,d15,#0
.L152:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   384      RxSigRamPtr        = &COM_GET_RXSIGNALFLAG(SignalId);
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   385  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   386      RxPduId            = RxSigConstPtr->IpduRef;
	ld.bu	d15,[a15]11
.L153:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   387      RxIPduConstPtr     = COM_GET_RX_IPDU_CONSTDATA(RxPduId);
	mul	d15,d15,#20
.L154:
	ld.a	a2,[a10]4
	addsc.a	a2,a2,d15,#0
.L155:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   388      rxMainFuncId       = RxIPduConstPtr->MainFunctionRef; /* Fetch the Rx-MainFunction internal Id */
	ld.bu	d11,[a2]17
.L156:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   389  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   390      ConstByteValue_u8  = RxSigConstPtr->General;
	ld.bu	d15,[a15]12
.L157:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   391  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   392      SigType            = Com_GetValue(GEN,_TYPE,ConstByteValue_u8);
	mov	d1,#5
.L113:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
	sha	d0,d15,#0
.L203:
	mov	d2,#255
.L204:
	rsub	d1,d1,#8
.L205:
	rsub	d1,#0
	sh	d2,d2,d1
.L206:
	and	d12,d0,d2
.L159:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));      (inlined)
	j	.L16

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }      (inlined)
.L16:
	mov	d0,#1
.L207:
	sh	d0,#5
.L208:
	and	d15,d0
.L158:
	ne	d15,d15,#0
.L209:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);      (inlined)
	j	.L17

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }      (inlined)
.L17:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   393      SigEndianess       = Com_GetValue(GEN,_ENDIANESS,ConstByteValue_u8);      (inlined)
	ne	d4,d15,#0
.L160:
	j	.L19
.L18:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   393      SigEndianess       = Com_GetValue(GEN,_ENDIANESS,ConstByteValue_u8);
	mov	d4,#0

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   393      SigEndianess       = Com_GetValue(GEN,_ENDIANESS,ConstByteValue_u8);      (inlined)
.L19:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   394  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   395      RxSigNewVal        = 0u;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   396      copySignal_b       = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   397  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   398      /* 1. For signals with update bit;this part will be executed when the Update bit is SET
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   399       * 2. For signals without update bit,process the signal further */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   400      /* Unpack the signal value */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   401  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   402  #ifdef COM_RXSIG_FLOAT64SUPP
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   403      if (SigType == COM_FLOAT64)
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   404      {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   405          VAR(float64, AUTOMATIC) RxSigNewVal_f64;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   406  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   407          RxSigNewVal_f64 = Com_UnPackFloatSignal( SigEndianess, RxSigConstPtr->Bit_Pos, PduInfoPtr->SduDataPtr );
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   408  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   409          SchM_Enter_Com_RxSigBuff(RXINDICATION);
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   410          /* Update the received data into the signal buffer */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   411          COM_GET_SIGTYPEFLOAT64_BUFF(rxMainFuncId,RxSigConstPtr->SigBuff_Index) = RxSigNewVal_f64;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   412          SchM_Exit_Com_RxSigBuff(RXINDICATION);
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   413      }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   414      else
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   415  #endif /* #ifdef COM_RXSIG_FLOAT64SUPP */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   416  /* FC_VariationPoint_END   */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   417      {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   418          /* Only UINT8_N and UINT8_DYN signals have type value greater than 8 */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   419          if ( !((SigType == COM_UINT8_N)
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   420  #ifdef COM_RX_DYNAMIC_SIGNAL_SUPPORT
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   421               ||(SigType == COM_UINT8_DYN)
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   422  #endif
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   423              ))
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   424          {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   425              RxSigNewVal = Com_UnpackSignal( SigEndianess, RxSigConstPtr->Bit_Pos, Size, PduInfoPtr->SduDataPtr,
	ld.a	a4,[a12]
.L210:
	ld.bu	d5,[a15]8
.L211:
	mov	d15,#8
.L212:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   419          if ( !((SigType == COM_UINT8_N)      (inlined)
	jeq	d15,d12,.L20
.L213:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   426                                                                                      ((SigType & 0x01u) != 0x0u));
	and	d15,d12,#1
.L214:
	ne	d7,d15,#0
	mov	d6,d10
.L163:
	call	Com_UnpackSignal
.L161:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   426                                                                                      ((SigType & 0x01u) != 0x0u));      (inlined)
	j	.L21

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   419          if ( !((SigType == COM_UINT8_N)      (inlined)
.L20:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   427          }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   428          else
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   429          {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   430              RxSigNewVal = (Com_SigMaxType)Com_UnpackOpaqueSignal(RxSigConstPtr->Bit_Pos, Size, PduInfoPtr->SduDataPtr);
	mov	d4,d5
.L164:
	mov	d5,d10
.L165:
	call	Com_UnpackOpaqueSignal

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   428          else      (inlined)
.L21:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   453          if ((Size != 0u)      (inlined)
	jeq	d10,#0,.L22
.L115:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   431          }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   432  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   433  #if defined(COM_RxSigInvalid) || defined(COM_RxFilters)
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   434  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   435          /* In the following function
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   436           * 1. Perform data Invalidation processing (REPLACE or NOTIFY)
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   437           * 2. Signal filter processing
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   438           */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   439          copySignal_b = Com_Prv_ValidateRxSignal( SignalId, &RxSigNewVal );
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   440  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   441  #endif /* #if defined(COM_RxSigInvalid) || defined(COM_RxFilters) */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   442      }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   443  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   444      /* Update the signal buffer,
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   445       * For signals with    update bit : Signal update bit set + signal validation pass
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   446       * For signals without update bit : Signal validation pass
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   447       */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   448  #if defined(COM_RxSigInvalid) || defined(COM_RxFilters)
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   449      if (copySignal_b != COM_FALSE)
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   450  #endif /* #if defined(COM_RxSigInvalid) || defined(COM_RxFilters) */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   451      {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   452          /* Proceed to copy signal buffer only for non-zero size */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   453          if ((Size != 0u)
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   454  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   455  #ifdef COM_RXSIG_FLOAT64SUPP
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   456          /* Signal copy is done above for FLOAT64 type signals, so below it is done for other types */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   457          && (SigType != COM_FLOAT64)
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   458  #endif
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   459  /* FC_VariationPoint_END   */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   460             )
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   461          {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   462              VAR(Com_SigBuffIndexType,AUTOMATIC) SigBuff_Index;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   463  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   464              SigBuff_Index = RxSigConstPtr->SigBuff_Index;
	ld.bu	d15,[a15]9
.L167:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   465  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   466              /* NOTE on Exclusive area COM_RXINDICATION:
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   467               * If there is a possibility that Com_RxIndication() can be interrupted by
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   468               * Com_ReceiveSignal() or Com_Init() function for any IPdu,
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   469               * then this exclusive area needs to be defined in Com_Cfg_SchM.h file.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   470               */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   471              /* Copy the new value of the signal into signal buffer */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   472  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   473  #ifdef COM_RX_DYNAMIC_SIGNAL_SUPPORT
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   474              if (SigType != COM_UINT8_DYN)
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   475  #endif
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   476              {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   477                  SchM_Enter_Com_RxSigBuff(RXINDICATION);
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   478  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   479                  if (SigType != COM_UINT8_N)
	mov	d0,#8
.L215:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   479                  if (SigType != COM_UINT8_N)      (inlined)
	jeq	d12,d0,.L23
.L118:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     1  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     2  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     3  #ifndef COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     4  #define COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     5  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     6  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     7   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     8   * Includes
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     9   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    10  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    11  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    12  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    13  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    17  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    18  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    19  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    20  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    21   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    22   * Type definitions
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    23   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    24  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    25  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    26  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    27  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    28   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    29   * Variables
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    30   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    31  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    32  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    33  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    34  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    35   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    36   * Extern declarations
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    37   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    38  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    39  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    40   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    41   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    42   * Inline function sets TMS data in to be accessesd via CurrentTxModePtr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    43   * after evaluating TMS mode for the IPdu
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    44   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    45  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    46  FUNC(void, COM_CODE) Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    47                                  Com_TxIpduRamPtrType                TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    48                                  Com_TxIpduConstPtrType              TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    49                                  VAR(uint16,AUTOMATIC)               TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    50                                  VAR(boolean,AUTOMATIC)              ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    51                                              );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    52  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    53  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    54   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    55   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    56   * Inline function to update Rx-GroupSignal application buffers
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    57   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    58  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    59  FUNC(void, COM_CODE) Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    60                                  Com_RxSigConstPtrType               RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    61                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    62                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    63                                               );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    64  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    65  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    66   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    67   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    68   * Inline function to update Rx-GroupSignal secondary buffers
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    69   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    70  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    71  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    72  FUNC(void, COM_CODE) Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    73                                  Com_RxGrpSigConstPtrType            RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    74                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    75                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    76                                                          );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    77  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    78  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    79  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    80   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    81   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    82   * Inline function to initialize signal intial value into the provided IPdu buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    83   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    84  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    85  FUNC(void, COM_CODE) Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    86                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    87                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    88                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    89                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    90                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    91                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    92                                                              );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    93  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    94  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    95   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    96   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    97   * Inline function to initialize Rx-signal group with initial values
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    98   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    99  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   100  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   101  FUNC(void, COM_CODE) Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   102                                  Com_RxSigGrpConstPtrType            RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   103                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   104                                                  );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   105  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   106  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   107  #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   108  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxNotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   109  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxErrNotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   110  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxTONotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   111  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallRxTONotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   112  #endif /* #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   113  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   114  /* Inline function to check for the RxIPdu and TxIpdu status*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   115  LOCAL_INLINE boolean Com_CheckRxIPduStatus(PduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   116  LOCAL_INLINE boolean Com_CheckTxIPduStatus(PduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   117  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   118  #if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   119  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   120  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Void(uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   121  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   122  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Ptr(boolean isInValidPtr, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   123  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Param_Ptr(boolean isInValidParam, boolean isInValidPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   124                                                                  uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   125  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Ptr_Only(boolean isInValidPtr, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   126  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Param_Only(boolean isInValidParam, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   127  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   128  #endif /*  #if (COM_CONFIGURATION_USE_DET == STD_ON) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   129  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   130  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   131  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   132  LOCAL_INLINE FUNC(void, COM_CODE) Com_CopyTxGroupSignalData( Com_SignalIdType    GrpSignalId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   133                                                               Com_SigMaxType      TxGrpSig_NewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   134                                                               Com_MainFuncType    TxMainFuncId );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   135  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   136  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   137  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   138   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   139   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   140   * Inline function to handle gateway and non-gateway use-case for tx-signal/signalGroup
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   141   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   142  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_ProceedToSendIpdu(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   143                                                  VAR(Com_IpduIdType, AUTOMATIC)          ComTxPduId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   144                                                  VAR(Com_SendIpduInfo, AUTOMATIC)        sendIpduFlag_u16
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   145                                                             );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   146  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   147  #ifdef COM_TxFilters
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   148  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_CheckModeChange(VAR(Com_IpduIdType, AUTOMATIC) TxIpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   149  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   150  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   151  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   152  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   153   * Inline Function Definition
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   154   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   155  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   156  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   157   Function name    : Com_SetCurrentTxModePtr [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   158   Syntax           : void Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   159                                  Com_TxIpduRamPtrType    TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   160                                  Com_TxIpduConstPtrType  TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   161                                  uint16                  TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   162                                  boolean                 ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   163                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   164   Description      : Inline function sets TMS data in to be accessesd via CurrentTxModePtr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   165                      after evaluating TMS mode for the IPdu
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   166  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   167                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   168                       * Mode                  |    Configuration details                              | Value|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   169                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   170                       * COM_MODE_VALID        |    Both the TRUE and FALSE modes are configured.      |    00|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   171                       * COM_TRUEMODE_VALID    |    Only TRUE mode is configured                       |    01|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   172                       * COM_FALSEMODE_VALID   |    Only FALSE mode is configured                      |    10|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   173                       * COM_MODE_INVALID      |    Both the TRUE and FALSE mode are not configured    |    11|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   174                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   175                      This INLINE function checks the TMS generated values against the requested mode and performs action
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   176                      |-------------|--------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   177                      |ModeRequested|Configured Mode values   |         Description                                           :      Action to be taken                |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   178                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   179                      |    0       |      0        |      0   |  FALSE mode is requested and IPdu TMS is COM_MODE_VALID         : Increment to the false mode data     |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   180                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   181                      |    0       |      0        |      1   |  FALSE mode is requested and IPdu TMS is COM_TRUEMODE_VALID     : Point to NONE mode data              |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   182                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   183                      |    0       |      1        |      0   |  FALSE mode is requested and IPdu TMS is COM_FALSEMODE_VALID     : Do nothing                          |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   184                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   185                      |    0       |      1        |      1   |  FALSE mode is requested and IPdu TMS is COM_MODE_INVALID     : Do nothing                             |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   186                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   187                      |    1       |      0        |      0   |  TRUE mode is requested and IPdu TMS is COM_MODE_VALID         : Do nothing                            |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   188                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   189                      |    1       |      0        |      1   |  TRUE mode is requested and IPdu TMS is COM_TRUEMODE_VALID     : Do nothing                            |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   190                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   191                      |    1       |      1        |      0   |  TRUE mode is requested and IPdu TMS is COM_FALSEMODE_VALID     : Point to NONE mode data              |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   192                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   193                      |    1       |      1        |      1   |  TRUE mode is requested and IPdu TMS is COM_MODE_INVALID         : Do nothing                          |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   194                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   195  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   196                      where 0 in column 1 stands for FALSE mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   197                      and   1 in column 1 stands for TRUE mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   198  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   199   Parameter        : TxIpduRamPtr    - pointer to Txipdu ram data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   200                    : TxIPduConstPtr  - pointer to Txipdu Rom data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   201                    : TMSStatus       - pointer to transmission mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   202                    : ModeRequested   - mode requested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   203   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   204   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   205  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   206  FUNC(void, COM_CODE) Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   207                                  Com_TxIpduRamPtrType                TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   208                                  Com_TxIpduConstPtrType              TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   209                                  VAR(uint16,AUTOMATIC)               TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   210                                  VAR(boolean,AUTOMATIC)              ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   211                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   212  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   213      /* Get the latest TM pointer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   214      TxIpduRamPtr->CurrentTxModePtr = TxIPduConstPtr->Com_TMConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   215  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   216      if(ModeRequested == COM_FALSE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   217      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   218          if((TMSStatus) == COM_TRUEMODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   219          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   220              /*If yes,load NONE mode data */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   221              TxIpduRamPtr->CurrentTxModePtr = &Com_NONE_TransModeInfo ;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   222          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   223          if((TMSStatus) == COM_MODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   224          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   225              /*Increment to FALSE mode data, if the FALSE mode is configured */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   226              TxIpduRamPtr->CurrentTxModePtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   227          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   228      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   229      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   230      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   231          if((TMSStatus) == COM_FALSEMODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   232          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   233              TxIpduRamPtr->CurrentTxModePtr = &Com_NONE_TransModeInfo ;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   234          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   235      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   236  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   237  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   238  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   239   Function name    : Com_UpdateRxGroupSignalSecondBuffer [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   240   Syntax           : void Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   241                                  Com_RxGrpSigConstPtrType    RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   242                                  Com_SigMaxType              RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   243                                  Com_MainFuncType            RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   244                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   245   Description      : Inline function copy Group signal value into the Group signal Second buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   246   Parameter        : RxGrpSigConstPtr - pointer to RxGroupSignal configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   247                    : RxNewVal         - latest RxGroupSignal data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   248                    : RxMainFuncId     - Internally generated Rx-MainFunction-Id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   249   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   250   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   251  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   252  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   253  FUNC(void, COM_CODE) Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   254                                  Com_RxGrpSigConstPtrType            RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   255                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   256                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   257                                                          )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   258  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   259      VAR(uint8,AUTOMATIC)    Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   260  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   261      Type = Com_GetValue(RXGRPSIG,_TYPE,RxGrpSigConstPtr->rxGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   262  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   263      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   264      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   265      case 0x00u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   266          /* UINT08 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   267          COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint8)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   268          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   269  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   270      case 0x01u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   271          /* UINT16 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   272          COM_GET_SECRXGRPSIGTYPEU16_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint16)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   273          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   274  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   275      case 0x02u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   276          /* UINT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   277          /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   278      case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   279          /* FLOAT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   280          /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   281          COM_GET_SECRXGRPSIGTYPEU32_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint32)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   282          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   283  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   284  #ifdef COM_RXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   285      case 0x08u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   286          /* UINT64/SINT64 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   287          COM_GET_SECRXGRPSIGTYPEU64_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   288          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   289  #endif /* #ifdef COM_RXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   290  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   291      case 0x03u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   292          /*Boolean Signal*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   293          COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint8)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   294          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   295  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   296      case 0x04u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   297          /* UINT8_N signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   298          Com_ByteCopyInit(&COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index),
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   299                           (uint32)RxNewVal,RxGrpSigConstPtr->BitSize);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   300          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   301      default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   302          /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   303           * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are allowed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   304           * to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   305           */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   306          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   307  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   308      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   309  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   310  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   311  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   312  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   313   Function name    : Com_UpdateRxSignalBuffer [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   314   Syntax           : void Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   315                                  Com_RxSigConstPtrType   RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   316                                  Com_SigMaxType          RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   317                                  Com_MainFuncType        RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   318                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   319   Description      : Inline function to copy signal value into the signal buffer and
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   320                      is used when signal value as a variable is being passed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   321   Parameter        : RxSigConstPtr - pointer to RxSignal configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   322                    : RxNewVal_Sig  - latest RxSignal data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   323                    : RxMainFuncId  - Internally generated Rx-MainFunction-Id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   324   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   325   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   326  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   327  FUNC(void, COM_CODE) Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   328                                  Com_RxSigConstPtrType               RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   329                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   330                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   331                                               )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   332  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   333      VAR(uint8,AUTOMATIC)    Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   334  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   335      Type = Com_GetValue(GEN,_TYPE,RxSigConstPtr->General);
	ld.bu	d15,[a15]12
.L168:
	mov	d1,#5
.L127:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
	sha	d0,d15,#0
.L216:
	mov	d15,#255
.L217:
	rsub	d1,d1,#8
.L218:
	rsub	d1,#0
	sh	d15,d15,d1
.L219:
	and	d0,d15
.L220:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));      (inlined)
	j	.L24

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }      (inlined)
.L24:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   336  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   337      switch(Type >> 1u)
	sha	d0,#-1
.L221:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   338      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   339      case 0x00u:     /* COM_UINT8 & COM_SINT8 */
	mov	d15,#0
	jeq	d15,d0,.L25
.L222:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   340      case (COM_BOOLEAN >> 1):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   341          COM_GET_SIGTYPEUINT8_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint8)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   342          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   343  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   344      case 0x01u:     /* COM_UINT16 & COM_SINT16 */
	mov	d15,#1
	jeq	d15,d0,.L26
.L223:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   345          COM_GET_SIGTYPEUINT16_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint16)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   346          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   347  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   348      case 0x02u:     /* COM_UINT32 & COM_SINT32 */
	mov	d15,#2
	jeq	d15,d0,.L27
.L224:
	mov	d15,#3
	jeq	d15,d0,.L28
.L225:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   349  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   350          /* COM_FLOAT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   351  #ifdef COM_FLOAT32SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   352      case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   353  #endif /* #ifdef COM_FLOAT32SUPP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   354  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   355          COM_GET_SIGTYPEUINT32_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint32)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   356          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   357  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   358  #ifdef COM_RXSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   359      case 0x08u:     /* COM_UINT64 & COM_SINT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   360          COM_GET_SIGTYPEUINT64_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   361          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   362  #endif /* #if defined(COM_RXSIG_INT64) && defined(COM_TXSIG_INT64) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   363  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   364      case 0x04u:     /* COM_UINT8_N */
	mov	d15,#4
	jeq	d15,d0,.L29
	j	.L30

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   339      case 0x00u:     /* COM_UINT8 & COM_SINT8 */      (inlined)
.L25:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   340      case (COM_BOOLEAN >> 1):      (inlined)
.L28:
	mul	d15,d11,#12
	movh.a	a2,#@his(Com_Prv_xRxRamBuf_acst)
	lea	a2,[a2]@los(Com_Prv_xRxRamBuf_acst)
	addsc.a	a2,a2,d15,#0
	ld.a	a2,[a2]
	ld.bu	d15,[a15]9
	addsc.a	a15,a2,d15,#0
.L162:
	st.b	[a15],d2
.L226:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   342          break;      (inlined)
	j	.L31

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   344      case 0x01u:     /* COM_UINT16 & COM_SINT16 */      (inlined)
.L26:
	mul	d15,d11,#12
	movh.a	a2,#@his(Com_Prv_xRxRamBuf_acst)
	lea	a2,[a2]@los(Com_Prv_xRxRamBuf_acst)
	addsc.a	a2,a2,d15,#0
	ld.a	a2,[a2]4
	ld.bu	d15,[a15]9
	addsc.a	a15,a2,d15,#1
.L169:
	st.h	[a15],d2
.L227:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   346          break;      (inlined)
	j	.L32

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   348      case 0x02u:     /* COM_UINT32 & COM_SINT32 */      (inlined)
.L27:
	mul	d15,d11,#12
	movh.a	a2,#@his(Com_Prv_xRxRamBuf_acst)
	lea	a2,[a2]@los(Com_Prv_xRxRamBuf_acst)
	addsc.a	a2,a2,d15,#0
	ld.a	a2,[a2]8
	ld.bu	d15,[a15]9
	addsc.a	a15,a2,d15,#2
.L170:
	st.w	[a15],d2
.L228:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   356          break;      (inlined)
	j	.L33

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   364      case 0x04u:     /* COM_UINT8_N */      (inlined)
.L29:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   365          Com_ByteCopyInit(&COM_GET_SIGTYPEUINT8_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index),
	mul	d15,d11,#12
	movh.a	a2,#@his(Com_Prv_xRxRamBuf_acst)
	lea	a2,[a2]@los(Com_Prv_xRxRamBuf_acst)
	addsc.a	a2,a2,d15,#0
	ld.a	a2,[a2]
	ld.bu	d15,[a15]9
	addsc.a	a4,a2,d15,#0
.L229:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   366                           (uint32)RxNewVal_Sig,RxSigConstPtr->BitSize);
	ld.bu	d5,[a15]10
	mov	d4,d2
.L171:
	call	Com_ByteCopyInit
.L166:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   367          break;      (inlined)
	j	.L34

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   368      default:      (inlined)
.L30:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   373          break;      (inlined)
	j	.L35

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   375  }      (inlined)
.L35:
.L34:
.L33:
.L32:
.L31:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   482                      Com_UpdateRxSignalBuffer(RxSigConstPtr, RxSigNewVal, rxMainFuncId);      (inlined)
	j	.L36

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   479                  if (SigType != COM_UINT8_N)      (inlined)
.L23:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   480                  {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   481                      /* Signal copy is done for rx signals */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   482                      Com_UpdateRxSignalBuffer(RxSigConstPtr, RxSigNewVal, rxMainFuncId);
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   483                  }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   484                  else
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   485                  {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   486                      /* UINT8_N signal */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   487                      Com_ByteCopy( &COM_GET_SIGTYPEUINT8_BUFF(rxMainFuncId,SigBuff_Index),
	mul	d0,d11,#12
	movh.a	a2,#@his(Com_Prv_xRxRamBuf_acst)
	lea	a2,[a2]@los(Com_Prv_xRxRamBuf_acst)
	addsc.a	a2,a2,d0,#0
	ld.a	a2,[a2]
	addsc.a	a4,a2,d15,#0
.L230:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   488                                    (PduInfoPtr->SduDataPtr + (RxSigConstPtr->Bit_Pos >> 3u)), Size );
	ld.a	a2,[a12]
.L231:
	ld.bu	d15,[a15]8
.L172:
	sha	d15,#-3
.L232:
	addsc.a	a5,a2,d15,#0
.L233:
	mov	d4,d10
.L173:
	call	Com_ByteCopy

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   484                  else      (inlined)
.L36:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   453          if ((Size != 0u)      (inlined)
.L22:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   489                  }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   490  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   491                  SchM_Exit_Com_RxSigBuff(RXINDICATION);
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   492              }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   493  #ifdef COM_RX_DYNAMIC_SIGNAL_SUPPORT
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   494              else
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   495              {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   496                  SchM_Enter_Com_RxSigDynBuff();
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   497  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   498                  /* UINT8_DYN signal */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   499                  Com_ByteCopy( &COM_GET_SIGTYPEUINT8DYN_BUFF(rxMainFuncId,SigBuff_Index),
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   500                                (PduInfoPtr->SduDataPtr + (RxSigConstPtr->Bit_Pos >> 3u)), Size );
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   501  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   502                  SchM_Exit_Com_RxSigDynBuff();
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   503              }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   504  #endif /* #ifdef COM_RX_DYNAMIC_SIGNAL_SUPPORT */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   505          }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   506  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   507  #ifdef COM_SIGNALGATEWAY
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   508          /* This part of code updates the Rx Gateway queue If the signal is updated in the signal buffer by one
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   509           * of the below means
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   510           * 1. Reception of Ipdu and thereby signal update after update bit processing
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   511           */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   512          if (Com_GetValue(RXSIG,_ISGWSIG,RxSigConstPtr->rxSignalFields))
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   513          {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   514              /* If the signal is recieved first time after the last call of Com_MainfunctionRouteSignals then
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   515               * 1. The fill bit per signal has to be set
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   516               * 2. Queue entry has to be done for the signal
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   517               * For the further receptions of the signal, Queue and signal fill bit are not set */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   518              Com_SetRamValue(RXSIG,_SIGNALFILLBIT,RxSigRamPtr->rxSigRAMFields,COM_TRUE);
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   519  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   520              /* This flag will tell if any GW signals in the Ipdu are updated */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   521              COM_GET_IS_GWSIG_UPDATED( RxPduId ) = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   522          }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   523  #endif /* #ifdef COM_SIGNALGATEWAY */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   524  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   525      } /* if (copySignal_b != COM_FALSE) */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   526  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   527      return copySignal_b;
	mov	d3,#1
.L174:

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   527      return copySignal_b;      (inlined)
	j	.L37

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   528  }      (inlined)
.L37:
.L15:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;      (inlined)
	ne	d15,d3,#0
.L175:
	j	.L39
.L38:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   439  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   440  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   441  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   442   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   443   * Bfx_PutBit_u16u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   444   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   445   * \brief Sets or clears a bit at a given position Pos_u32 in the 16-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   446   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   447   * A priori, range [0,15] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   448   * Note, neither the given position BitPn nor the given value Value not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   449   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   450   * \param   uint16*  Data   pointer to a 16-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   451   * \param   uint8    BitPn  position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   452   * \param   boolean  Value  defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   453   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   454   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   455   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   456  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   457  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   458      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   460      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   461      *Data = ((*Data & ((uint16)~(1uL << BitPn))) | ((uint16)((uint16)tmp_u8 << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   462  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   463  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   464  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   465  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   466   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   467   * Bfx_PutBit_u32u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   468   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   469   * \brief Sets or clears a bit at a given position Pos_u32 in the 32-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   470   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   471   * A priori, range [0,31] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   472   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   473   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   474   * \param   uint32*     Data        pointer to a 32-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   475   * \param   uint8       BitPn       position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   476   * \param   boolean     Value       defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   477   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   478   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   479   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   480  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   481  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   482      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   483      tmp_u8 = (Value)? 1u : 0u;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   484      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   485      *Data = ((*Data & ((uint32)~(1uL << BitPn))) | ((uint32)((uint32)tmp_u8 << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   486  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   487  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   488  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   489  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   490   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   491   * Bfx_PutBit_u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   492   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   493   * \brief Sets or clears a bit at a given position BitPn in the 8-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   494   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   495   * A priori, range [0,7] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   496   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   497   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   498   * \param  uint8*   Data    pointer to a 8-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   499   * \param  uint8    BitPn   position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   500   * \param  boolean  Value   defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   501   * \return void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   502   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   503   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   504  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   505  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   506      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;
	mov	d15,#0

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;      (inlined)
.L39:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   508      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   509      *Data = ((*Data & ((uint8)~(1uL <<BitPn))) | ((uint8)(tmp_u8 << BitPn)));
	ld.bu	d0,[a13]
.L234:
	mov	d1,#1
.L235:
	sh	d1,#0
.L236:
	xor	d1,d1,#255
.L237:
	and	d0,d1
.L238:
	sha	d15,#0
.L176:
	or	d0,d15
.L239:
	st.b	[a13],d0
.L129:
	lea	a14,[a14]16
.L240:
	add.a	a13,#1
.L241:
	add	d9,#1
.L2:
	jlt.u	d9,d8,.L3
.L242:
	ret
.L51:
	
__Com_Prv_ProcessSignal_function_end:
	.size	Com_Prv_ProcessSignal,__Com_Prv_ProcessSignal_function_end-Com_Prv_ProcessSignal
.L50:
	; End of function
	
	.calls	'Com_Prv_ProcessSignal','Com_UnpackSignal'
	.calls	'Com_Prv_ProcessSignal','Com_UnpackOpaqueSignal'
	.calls	'Com_Prv_ProcessSignal','Com_ByteCopyInit'
	.calls	'Com_Prv_ProcessSignal','Com_ByteCopy'
	.extern	Com_ByteCopy
	.extern	Com_ByteCopyInit
	.extern	Com_UnpackSignal
	.extern	Com_UnpackOpaqueSignal
	.extern	Com_RxSignalFlag
	.extern	Com_Prv_xRxSigCfg_acst
	.extern	Com_Prv_xRxIpduCfg_acst
	.extern	Com_Prv_xRxRamBuf_acst
	.calls	'Com_Prv_ProcessSignal','',8
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L43:
	.word	14444
	.half	3
	.word	.L44
	.byte	4
.L42:
	.byte	1
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_ProcessSignal.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L45
.L65:
	.byte	2
	.byte	'unsigned char',0,1,8
.L52:
	.byte	2
	.byte	'unsigned short int',0,2,7,3
	.byte	'Bfx_Prv_GetBit_u16u8_u8_Inl',0,3,1,207,2,22
	.word	143
	.byte	1,1,4
	.byte	'Data',0,1,207,2,57
	.word	160
	.byte	4
	.byte	'BitPn',0,1,207,2,69
	.word	143
	.byte	5,0
.L105:
	.byte	2
	.byte	'unsigned int',0,4,7,3
	.byte	'Bfx_Prv_GetBit_u32u8_u8_Inl',0,3,1,227,2,22
	.word	143
	.byte	1,1,4
	.byte	'Data',0,1,227,2,57
	.word	253
	.byte	4
	.byte	'BitPn',0,1,227,2,69
	.word	143
	.byte	5,0
.L81:
	.byte	3
	.byte	'Bfx_Prv_GetBit_u8u8_u8_Inl',0,3,1,247,2,22
	.word	143
	.byte	1,1
.L82:
	.byte	4
	.byte	'Data',0,1,247,2,55
	.word	143
.L84:
	.byte	4
	.byte	'BitPn',0,1,247,2,67
	.word	143
.L86:
	.byte	5,0
.L72:
	.byte	3
	.byte	'Bfx_Prv_GetBits_u8u8u8_u8_Inl',0,3,1,179,3,20
	.word	143
	.byte	1,1
.L74:
	.byte	4
	.byte	'Data',0,1,179,3,56
	.word	143
.L76:
	.byte	4
	.byte	'BitStartPn',0,1,179,3,68
	.word	143
.L78:
	.byte	4
	.byte	'BitLn',0,1,179,3,86
	.word	143
.L80:
	.byte	5,0,6
	.word	160
	.byte	7
	.byte	'Bfx_Prv_PutBit_u16u8u8_Inl',0,3,1,200,3,19,1,1,4
	.byte	'Data',0,1,200,3,54
	.word	503
	.byte	4
	.byte	'BitPn',0,1,200,3,66
	.word	143
	.byte	4
	.byte	'Value',0,1,200,3,81
	.word	143
	.byte	5,0,6
	.word	253
	.byte	7
	.byte	'Bfx_Prv_PutBit_u32u8u8_Inl',0,3,1,224,3,19,1,1,4
	.byte	'Data',0,1,224,3,54
	.word	589
	.byte	4
	.byte	'BitPn',0,1,224,3,66
	.word	143
	.byte	4
	.byte	'Value',0,1,224,3,81
	.word	143
	.byte	5,0,6
	.word	143
.L128:
	.byte	7
	.byte	'Bfx_Prv_PutBit_u8u8u8_Inl',0,3,1,248,3,19,1,1
.L130:
	.byte	4
	.byte	'Data',0,1,248,3,52
	.word	675
.L132:
	.byte	4
	.byte	'BitPn',0,1,248,3,64
	.word	143
.L134:
	.byte	4
	.byte	'Value',0,1,248,3,79
	.word	143
.L136:
	.byte	5,0,3
	.byte	'Bfx_Prv_TstParityEven_u32_u8_Inl',0,3,1,143,10,22
	.word	143
	.byte	1,1,4
	.byte	'Data',0,1,143,10,62
	.word	253
	.byte	5,0,8,1,1,6
	.word	821
	.byte	9,3,247,1,9,16,10
	.byte	'Notification_Cbk',0
	.word	824
	.byte	4,2,35,0,10
	.byte	'Init_Val',0
	.word	253
	.byte	4,2,35,4,10
	.byte	'Bit_Pos',0
	.word	143
	.byte	1,2,35,8,10
	.byte	'SigBuff_Index',0
	.word	143
	.byte	1,2,35,9,10
	.byte	'BitSize',0
	.word	143
	.byte	1,2,35,10,10
	.byte	'IpduRef',0
	.word	143
	.byte	1,2,35,11,10
	.byte	'General',0
	.word	143
	.byte	1,2,35,12,10
	.byte	'rxSignalFields',0
	.word	143
	.byte	1,2,35,13,0,11
	.word	829
	.byte	6
	.word	995
.L58:
	.byte	12
	.byte	'Com_RxSigConstPtrType',0,3,180,2,68
	.word	1000
.L117:
	.byte	7
	.byte	'Com_UpdateRxSignalBuffer',0,3,2,199,2,22,1,1
.L119:
	.byte	4
	.byte	'RxSigConstPtr',0,2,200,2,69
	.word	1005
.L121:
	.byte	4
	.byte	'RxNewVal_Sig',0,2,201,2,69
	.word	253
.L123:
	.byte	4
	.byte	'RxMainFuncId',0,2,202,2,69
	.word	143
.L125:
	.byte	13,5,0,0,11
	.word	829
	.byte	6
	.word	1140
	.byte	9,5,71,9,8,10
	.byte	'SduDataPtr',0
	.word	675
	.byte	4,2,35,0,10
	.byte	'SduLength',0
	.word	160
	.byte	2,2,35,4,0,11
	.word	1150
.L54:
	.byte	6
	.word	1195
.L93:
	.byte	3
	.byte	'Com_Prv_CopyRxSignal',0,3,4,238,2,38
	.word	143
	.byte	1,1
.L95:
	.byte	4
	.byte	'SignalId',0,4,239,2,95
	.word	160
.L97:
	.byte	4
	.byte	'PduInfoPtr',0,4,240,2,95
	.word	1200
.L99:
	.byte	4
	.byte	'Size',0,4,241,2,95
	.word	143
.L101:
	.byte	13
.L114:
	.byte	5,5,5,5,0,0,14
	.word	182
	.byte	15
	.word	222
	.byte	15
	.word	236
	.byte	5,0,14
	.word	269
	.byte	15
	.word	309
	.byte	15
	.word	323
	.byte	5,0,14
	.word	340
	.byte	15
	.word	379
	.byte	15
	.word	393
	.byte	5,0,14
	.word	410
	.byte	15
	.word	452
	.byte	15
	.word	466
	.byte	15
	.word	486
	.byte	5,0,14
	.word	508
	.byte	15
	.word	543
	.byte	15
	.word	557
	.byte	15
	.word	572
	.byte	5,0,14
	.word	594
	.byte	15
	.word	629
	.byte	15
	.word	643
	.byte	15
	.word	658
	.byte	5,0,14
	.word	680
	.byte	15
	.word	714
	.byte	15
	.word	728
	.byte	15
	.word	743
	.byte	5,0,14
	.word	760
	.byte	15
	.word	805
	.byte	5,0,11
	.word	143
	.byte	6
	.word	1448
	.byte	16
	.byte	'Com_ByteCopy',0,6,240,20,22,1,1,1,1,4
	.byte	'dest',0,6,240,20,77
	.word	675
	.byte	4
	.byte	'src',0,6,241,20,77
	.word	1453
	.byte	4
	.byte	'Len',0,6,242,20,77
	.word	253
	.byte	0,16
	.byte	'Com_ByteCopyInit',0,6,130,21,22,1,1,1,1,4
	.byte	'dest',0,6,130,21,81
	.word	675
	.byte	4
	.byte	'Init_Val',0,6,131,21,81
	.word	253
	.byte	4
	.byte	'Len',0,6,132,21,81
	.word	253
	.byte	0,17
	.byte	'Com_UnpackSignal',0,6,196,21,32
	.word	253
	.byte	1,1,1,1,4
	.byte	'Endianess',0,6,196,21,91
	.word	143
	.byte	4
	.byte	'Bit_Pos',0,6,197,21,91
	.word	143
	.byte	4
	.byte	'Bitsize',0,6,198,21,91
	.word	143
	.byte	4
	.byte	'Src_Buf',0,6,199,21,91
	.word	1453
	.byte	4
	.byte	'IsSigned',0,6,200,21,91
	.word	143
	.byte	0,17
	.byte	'Com_UnpackOpaqueSignal',0,6,239,21,24
	.word	253
	.byte	1,1,1,1,4
	.byte	'Bit_Pos',0,6,239,21,89
	.word	143
	.byte	4
	.byte	'SignalLength',0,6,240,21,89
	.word	143
	.byte	4
	.byte	'Src_Buf',0,6,241,21,89
	.word	1453
	.byte	0,9,3,137,7,9,20,10
	.byte	'BuffPtr',0
	.word	675
	.byte	4,2,35,0,10
	.byte	'TimeOutNotification_Cbk',0
	.word	824
	.byte	4,2,35,4,10
	.byte	'Size',0
	.word	160
	.byte	2,2,35,8,10
	.byte	'FirstTimeout_Factor',0
	.word	160
	.byte	2,2,35,10,10
	.byte	'Timeout_Fact',0
	.word	160
	.byte	2,2,35,12,10
	.byte	'No_Of_Sig_Ref',0
	.word	160
	.byte	2,2,35,14,10
	.byte	'RxSigId_Index',0
	.word	143
	.byte	1,2,35,16,10
	.byte	'MainFunctionRef',0
	.word	143
	.byte	1,2,35,17,10
	.byte	'rxIPduFields',0
	.word	143
	.byte	1,2,35,18,0,11
	.word	1805
	.byte	6
	.word	2020
	.byte	11
	.word	1805
	.byte	6
	.word	2030
.L56:
	.byte	12
	.byte	'Com_RxIpduConstPtrType',0,3,206,7,72
	.word	2035
	.byte	9,3,167,8,9,1,10
	.byte	'rxSigRAMFields',0
	.word	143
	.byte	1,2,35,0,0,6
	.word	2072
	.byte	6
	.word	2072
.L60:
	.byte	12
	.byte	'Com_RxSigRamPtrType',0,3,180,8,65
	.word	2108
.L62:
	.byte	2
	.byte	'unsigned long int',0,4,7,14
	.word	1036
	.byte	15
	.word	1069
	.byte	15
	.word	1092
	.byte	15
	.word	1114
	.byte	13,18
	.word	410
	.byte	15
	.word	452
	.byte	15
	.word	466
	.byte	15
	.word	486
	.byte	19
	.word	501
	.byte	0,5,0,0,14
	.word	1205
	.byte	15
	.word	1238
	.byte	15
	.word	1256
	.byte	15
	.word	1276
	.byte	13,13,18
	.word	1036
	.byte	15
	.word	1069
	.byte	15
	.word	1092
	.byte	15
	.word	1114
	.byte	20
	.word	1136
	.byte	18
	.word	410
	.byte	15
	.word	452
	.byte	15
	.word	466
	.byte	15
	.word	486
	.byte	19
	.word	501
	.byte	0,19
	.word	1137
	.byte	0,0,0,18
	.word	340
	.byte	15
	.word	379
	.byte	15
	.word	393
	.byte	19
	.word	408
	.byte	0,5,18
	.word	410
	.byte	15
	.word	452
	.byte	15
	.word	466
	.byte	15
	.word	486
	.byte	19
	.word	501
	.byte	0,5,5,0,0,21,1,6
	.word	2346
	.byte	12
	.byte	'__codeptr',0,4,1,1
	.word	2348
	.byte	2
	.byte	'char',0,1,6,12
	.byte	'sint8',0,7,76,25
	.word	2371
	.byte	12
	.byte	'uint8',0,7,81,25
	.word	143
	.byte	12
	.byte	'uint16',0,7,91,25
	.word	160
	.byte	12
	.byte	'uint32',0,7,106,24
	.word	253
	.byte	2
	.byte	'unsigned long long int',0,8,7,12
	.byte	'uint64',0,7,111,30
	.word	2437
	.byte	12
	.byte	'boolean',0,7,127,25
	.word	143
	.byte	12
	.byte	'StatusType',0,8,191,1,27
	.word	143
	.byte	12
	.byte	'Std_ReturnType',0,8,199,1,15
	.word	143
	.byte	9,8,206,1,9,8,10
	.byte	'vendorID',0
	.word	160
	.byte	2,2,35,0,10
	.byte	'moduleID',0
	.word	160
	.byte	2,2,35,2,10
	.byte	'sw_major_version',0
	.word	143
	.byte	1,2,35,4,10
	.byte	'sw_minor_version',0
	.word	143
	.byte	1,2,35,5,10
	.byte	'sw_patch_version',0
	.word	143
	.byte	1,2,35,6,0,12
	.byte	'Std_VersionInfoType',0,8,213,1,3
	.word	2538
	.byte	12
	.byte	'PduIdType',0,9,22,19
	.word	160
	.byte	12
	.byte	'PduLengthType',0,9,26,19
	.word	160
	.byte	12
	.byte	'PduInfoType',0,5,75,3
	.word	1150
	.byte	22,5,113,9,4,23
	.byte	'TP_DATACONF',0,0,23
	.byte	'TP_DATARETRY',0,1,23
	.byte	'TP_CONFPENDING',0,2,0,12
	.byte	'TpDataStateType',0,5,118,3
	.word	2748
	.byte	12
	.byte	'Com_SignalIdType',0,10,100,16
	.word	160
	.byte	12
	.byte	'Com_SignalGroupIdType',0,10,102,16
	.word	160
	.byte	12
	.byte	'Com_IpduIdType',0,10,104,15
	.word	143
	.byte	12
	.byte	'Com_GrpSignalIdType',0,10,107,18
	.word	143
	.byte	12
	.byte	'Com_TxIntSignalIdType',0,11,138,3,18
	.word	143
	.byte	12
	.byte	'Com_RxIntSignalIdType',0,11,139,3,18
	.word	143
	.byte	12
	.byte	'Com_BitsizeType',0,11,155,3,17
	.word	143
	.byte	12
	.byte	'Com_BitpositionType',0,11,156,3,15
	.word	143
	.byte	12
	.byte	'Com_RxGwQueueIndexType',0,11,161,3,15
	.word	143
	.byte	12
	.byte	'Com_SigBuffIndexType',0,11,164,3,15
	.word	143
	.byte	12
	.byte	'Com_SigMaxType',0,11,198,3,16
	.word	253
	.byte	12
	.byte	'Com_MainFuncType',0,11,231,3,16
	.word	143
	.byte	12
	.byte	'Com_NumOfIpdusType',0,11,233,3,15
	.word	143
	.byte	12
	.byte	'Com_TimeBaseType',0,11,235,3,15
	.word	143
	.byte	12
	.byte	'Can_IdType',0,12,32,16
	.word	253
	.byte	12
	.byte	'Can_HwHandleType',0,12,43,16
	.word	160
	.byte	9,13,93,9,8,10
	.byte	'Class',0
	.word	143
	.byte	1,2,35,0,10
	.byte	'TIN',0
	.word	143
	.byte	1,2,35,1,10
	.byte	'ReturnAddress',0
	.word	253
	.byte	4,2,35,4,0,12
	.byte	'OsTrapInfoType',0,13,97,3
	.word	3256
	.byte	24,68
	.word	253
	.byte	25,16,0,9,13,154,1,9,68,10
	.byte	'store',0
	.word	3336
	.byte	68,2,35,0,0,24,68
	.word	3345
	.byte	25,0,0,12
	.byte	'Os_JumpBufType',0,13,156,1,3
	.word	3367
	.byte	12
	.byte	'Os_StackTraceType',0,13,174,1,18
	.word	253
	.byte	9,13,175,1,9,8,10
	.byte	'sp',0
	.word	253
	.byte	4,2,35,0,10
	.byte	'ctx',0
	.word	253
	.byte	4,2,35,4,0,12
	.byte	'Os_StackValueType',0,13,175,1,63
	.word	3427
	.byte	12
	.byte	'Os_StackSizeType',0,13,176,1,27
	.word	3427
	.byte	12
	.byte	'Os_VoidVoidFunctionType',0,13,179,1,16
	.word	824
	.byte	12
	.byte	'ApplicationType',0,13,193,1,23
	.word	143
	.byte	26
	.byte	'Os_ApplicationConfigurationType_s',0,13,198,1,16,2,10
	.byte	'app_id',0
	.word	143
	.byte	1,2,35,0,10
	.byte	'access',0
	.word	143
	.byte	1,2,35,1,0,12
	.byte	'Os_ApplicationConfigurationType',0,13,201,1,3
	.word	3570
	.byte	12
	.byte	'Os_CoreStateType',0,13,203,1,16
	.word	253
	.byte	12
	.byte	'AreaIdType',0,13,204,1,16
	.word	160
	.byte	12
	.byte	'Os_PeripheralAddressType',0,13,212,1,22
	.word	253
	.byte	12
	.byte	'TickType',0,13,221,1,22
	.word	253
	.byte	12
	.byte	'Os_StopwatchTickType',0,13,225,1,22
	.word	253
	.byte	12
	.byte	'Os_Lockable',0,13,234,1,18
	.word	589
	.byte	12
	.byte	'CoreIdType',0,13,236,1,16
	.word	160
	.byte	12
	.byte	'SpinlockIdType',0,13,237,1,16
	.word	160
	.byte	22,13,239,1,9,4,23
	.byte	'TRYTOGETSPINLOCK_SUCCESS',0,0,23
	.byte	'TRYTOGETSPINLOCK_NOSUCCESS',0,1,0,12
	.byte	'TryToGetSpinlockType',0,13,239,1,74
	.word	3877
	.byte	22,13,174,2,9,4,23
	.byte	'APPLICATION_ACCESSIBLE',0,0,23
	.byte	'APPLICATION_RESTARTING',0,1,23
	.byte	'APPLICATION_TERMINATED',0,2,0,12
	.byte	'ApplicationStateType',0,13,174,2,92
	.word	3970
	.byte	27
	.byte	'void',0,6
	.word	4082
	.byte	28,1,1,29
	.word	143
	.byte	29
	.word	4088
	.byte	0,6
	.word	4093
	.byte	12
	.byte	'Os_FunctionEntryType',0,13,183,2,16
	.word	4107
	.byte	26
	.byte	'Os_MeterInfoType_s',0,13,193,2,16,48,10
	.byte	'elapsed',0
	.word	253
	.byte	4,2,35,0,10
	.byte	'previous',0
	.word	253
	.byte	4,2,35,4,10
	.byte	'max',0
	.word	253
	.byte	4,2,35,8,10
	.byte	'cumulative',0
	.word	253
	.byte	4,2,35,12,10
	.byte	'stackbase',0
	.word	3427
	.byte	8,2,35,16,10
	.byte	'stackusage',0
	.word	3427
	.byte	8,2,35,24,10
	.byte	'stackmax',0
	.word	3427
	.byte	8,2,35,32,10
	.byte	'stackbudget',0
	.word	3427
	.byte	8,2,35,40,0,12
	.byte	'Os_MeterInfoType',0,13,202,2,3
	.word	4142
	.byte	6
	.word	4142
	.byte	12
	.byte	'Os_MeterInfoRefType',0,13,203,2,50
	.word	4340
	.byte	12
	.byte	'EventMaskType',0,13,206,2,15
	.word	143
	.byte	12
	.byte	'Os_imaskType',0,13,211,2,16
	.word	253
	.byte	26
	.byte	'Os_ISRDynType_s',0,13,213,2,16,48,10
	.byte	'meter',0
	.word	4142
	.byte	48,2,35,0,0,12
	.byte	'Os_ISRDynType',0,13,215,2,3
	.word	4419
	.byte	6
	.word	4419
	.byte	11
	.word	4480
	.byte	26
	.byte	'Os_ISRType_s',0,13,216,2,16,24,10
	.byte	'entry_function',0
	.word	3512
	.byte	4,2,35,0,10
	.byte	'dynamic',0
	.word	4485
	.byte	4,2,35,4,10
	.byte	'imask',0
	.word	253
	.byte	4,2,35,8,10
	.byte	'stackbudget',0
	.word	3427
	.byte	8,2,35,12,10
	.byte	'access',0
	.word	143
	.byte	1,2,35,20,10
	.byte	'application',0
	.word	143
	.byte	1,2,35,21,0,12
	.byte	'Os_ISRType',0,13,223,2,3
	.word	4490
	.byte	6
	.word	821
	.byte	11
	.word	4490
	.byte	6
	.word	4649
	.byte	12
	.byte	'ISRType',0,13,224,2,46
	.word	4654
	.byte	12
	.byte	'Os_bitmask',0,13,239,2,22
	.word	253
	.byte	12
	.byte	'Os_pset0Type',0,13,240,2,20
	.word	253
	.byte	12
	.byte	'Os_pset1Type',0,13,241,2,20
	.word	253
	.byte	12
	.byte	'Os_pset2Type',0,13,242,2,20
	.word	253
	.byte	30,13,243,2,9,4,10
	.byte	'p0',0
	.word	253
	.byte	4,2,35,0,10
	.byte	'p1',0
	.word	253
	.byte	4,2,35,0,10
	.byte	'p2',0
	.word	253
	.byte	4,2,35,0,0,12
	.byte	'Os_psetType',0,13,247,2,3
	.word	4762
	.byte	30,13,249,2,9,4,10
	.byte	't0',0
	.word	253
	.byte	4,2,35,0,10
	.byte	't1',0
	.word	253
	.byte	4,2,35,0,10
	.byte	't2',0
	.word	253
	.byte	4,2,35,0,0,12
	.byte	'Os_tpmaskType',0,13,253,2,3
	.word	4826
	.byte	12
	.byte	'Os_ActivationCountType',0,13,254,2,23
	.word	143
	.byte	26
	.byte	'Os_TaskDynType_s',0,13,128,3,16,120,10
	.byte	'terminate_jump_buf',0
	.word	3376
	.byte	68,2,35,0,10
	.byte	'meter',0
	.word	4142
	.byte	48,2,35,68,10
	.byte	'activation_count',0
	.word	143
	.byte	1,2,35,116,0,12
	.byte	'Os_TaskDynType',0,13,132,3,3
	.word	4924
	.byte	24,68
	.word	3345
	.byte	25,0,0,6
	.word	4924
	.byte	11
	.word	5050
	.byte	26
	.byte	'Os_TaskType_s',0,13,134,3,16,40,10
	.byte	'dynamic',0
	.word	5055
	.byte	4,2,35,0,10
	.byte	'entry_function',0
	.word	3512
	.byte	4,2,35,4,10
	.byte	'pset',0
	.word	4762
	.byte	4,2,35,8,10
	.byte	'base_tpmask',0
	.word	4826
	.byte	4,2,35,12,10
	.byte	'tpmask',0
	.word	4826
	.byte	4,2,35,16,10
	.byte	'core_id',0
	.word	160
	.byte	2,2,35,20,10
	.byte	'index',0
	.word	253
	.byte	4,2,35,24,10
	.byte	'stackbudget',0
	.word	3427
	.byte	8,2,35,28,10
	.byte	'activation_count',0
	.word	143
	.byte	1,2,35,36,10
	.byte	'access',0
	.word	143
	.byte	1,2,35,37,10
	.byte	'application',0
	.word	143
	.byte	1,2,35,38,0,12
	.byte	'Os_TaskType',0,13,146,3,3
	.word	5060
	.byte	11
	.word	5060
	.byte	6
	.word	5310
	.byte	12
	.byte	'TaskType',0,13,147,3,47
	.word	5315
	.byte	31
	.byte	'Os_TaskStateType',0,13,155,3,6,4,23
	.byte	'SUSPENDED',0,0,23
	.byte	'READY',0,1,23
	.byte	'WAITING',0,2,23
	.byte	'RUNNING',0,3,0,12
	.byte	'TaskStateType',0,13,156,3,31
	.word	5338
	.byte	30,13,167,3,3,4,10
	.byte	'tpmask',0
	.word	4826
	.byte	4,2,35,0,0,26
	.byte	'Os_ResourceDynType_s',0,13,166,3,16,4,10
	.byte	'saved_priority',0
	.word	5425
	.byte	4,2,35,0,0,12
	.byte	'Os_ResourceDynType',0,13,170,3,3
	.word	5448
	.byte	6
	.word	5448
	.byte	11
	.word	5528
	.byte	26
	.byte	'Os_ResourceType_s',0,13,171,3,16,12,10
	.byte	'dynamic',0
	.word	5533
	.byte	4,2,35,0,10
	.byte	'tpmask',0
	.word	4826
	.byte	4,2,35,4,10
	.byte	'access',0
	.word	143
	.byte	1,2,35,8,0,12
	.byte	'Os_ResourceType',0,13,175,3,3
	.word	5538
	.byte	9,13,181,3,9,12,10
	.byte	'maxallowedvalue',0
	.word	253
	.byte	4,2,35,0,10
	.byte	'ticksperbase',0
	.word	253
	.byte	4,2,35,4,10
	.byte	'mincycle',0
	.word	253
	.byte	4,2,35,8,0,12
	.byte	'AlarmBaseType',0,13,185,3,3
	.word	5637
	.byte	9,13,206,3,9,8,10
	.byte	'Running',0
	.word	143
	.byte	1,2,35,0,10
	.byte	'Pending',0
	.word	143
	.byte	1,2,35,1,10
	.byte	'Delay',0
	.word	253
	.byte	4,2,35,4,0,12
	.byte	'Os_CounterStatusType',0,13,210,3,3
	.word	5732
	.byte	32
	.word	143
	.byte	1,1,6
	.word	5818
	.byte	12
	.byte	'Os_CounterIncrAdvType',0,13,217,3,22
	.word	5825
	.byte	26
	.byte	's_swd',0,13,222,3,12,4,10
	.byte	'count',0
	.word	253
	.byte	4,2,35,0,0,30,13,221,3,3,4,10
	.byte	'sw',0
	.word	5861
	.byte	4,2,35,0,0,26
	.byte	'Os_CounterDynType_s',0,13,220,3,16,4,10
	.byte	'type_dependent',0
	.word	5889
	.byte	4,2,35,0,0,12
	.byte	'Os_CounterDynType',0,13,226,3,3
	.word	5908
	.byte	6
	.word	5908
	.byte	11
	.word	5986
	.byte	26
	.byte	'Os_CounterType_s',0,13,227,3,16,28,10
	.byte	'dynamic',0
	.word	5991
	.byte	4,2,35,0,10
	.byte	'advincr',0
	.word	5830
	.byte	4,2,35,4,10
	.byte	'base',0
	.word	5637
	.byte	12,2,35,8,10
	.byte	'core',0
	.word	4088
	.byte	4,2,35,20,10
	.byte	'access',0
	.word	143
	.byte	1,2,35,24,10
	.byte	'application',0
	.word	143
	.byte	1,2,35,25,0,12
	.byte	'Os_CounterType',0,13,234,3,3
	.word	5996
	.byte	6
	.word	5818
	.byte	11
	.word	5996
	.byte	6
	.word	6148
	.byte	12
	.byte	'CounterType',0,13,235,3,52
	.word	6153
	.byte	31
	.byte	'Os_ScheduleTableStatusType',0,13,240,3,6,4,23
	.byte	'SCHEDULETABLE_STOPPED',0,0,23
	.byte	'SCHEDULETABLE_NEXT',0,1,23
	.byte	'SCHEDULETABLE_WAITING',0,2,23
	.byte	'SCHEDULETABLE_RUNNING',0,3,23
	.byte	'SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS',0,4,0,12
	.byte	'ScheduleTableStatusType',0,13,241,3,41
	.word	6179
	.byte	11
	.word	.L177-.L43
	.byte	6
	.word	6379
	.byte	12
	.byte	'ScheduleTableType',0,13,128,4,58
	.word	6384
	.byte	26
	.byte	'Os_ScheduleTableDynType_s',0,13,130,4,16,16,10
	.byte	'match',0
	.word	253
	.byte	4,2,35,0,10
	.byte	'next',0
	.word	6389
	.byte	4,2,35,4,10
	.byte	'state',0
	.word	6179
	.byte	4,2,35,8,10
	.byte	'config',0
	.word	160
	.byte	2,2,35,12,0,6
	.word	6416
	.byte	11
	.word	6509
.L177:
	.byte	26
	.byte	'Os_ScheduleTableType_s',0,13,247,3,16,16,10
	.byte	'dynamic',0
	.word	6514
	.byte	4,2,35,0,10
	.byte	'counter',0
	.word	6158
	.byte	4,2,35,4,10
	.byte	'repeat',0
	.word	143
	.byte	1,2,35,8,10
	.byte	'config',0
	.word	160
	.byte	2,2,35,10,10
	.byte	'initial',0
	.word	143
	.byte	1,2,35,12,10
	.byte	'access',0
	.word	143
	.byte	1,2,35,13,10
	.byte	'application',0
	.word	143
	.byte	1,2,35,14,0,12
	.byte	'Os_ScheduleTableType',0,13,255,3,3
	.word	6519
	.byte	11
	.word	6519
	.byte	6
	.word	6699
	.byte	11
	.word	5996
	.byte	6
	.word	6709
	.byte	33
	.word	3812
	.byte	33
	.word	4762
	.byte	33
	.word	4659
	.byte	33
	.word	5320
	.byte	33
	.word	4826
	.byte	33
	.word	143
	.byte	33
	.word	5320
	.byte	26
	.byte	'Os_ControlledCoreType_s',0,13,251,6,16,112,10
	.byte	'TrapInfo',0
	.word	3256
	.byte	8,2,35,0,10
	.byte	'lock_taskaccess',0
	.word	6719
	.byte	4,2,35,8,10
	.byte	'ReadyTasks',0
	.word	6724
	.byte	4,2,35,12,10
	.byte	'RunningISR',0
	.word	6729
	.byte	4,2,35,16,10
	.byte	'RunningTask',0
	.word	6734
	.byte	4,2,35,20,10
	.byte	'RunningTPMask',0
	.word	6739
	.byte	4,2,35,24,10
	.byte	'CurrentMeteredObject',0
	.word	4345
	.byte	4,2,35,28,10
	.byte	'IdleMeter',0
	.word	4142
	.byte	48,2,35,32,10
	.byte	'AppAccess',0
	.word	143
	.byte	1,2,35,80,10
	.byte	'AppOverride',0
	.word	6744
	.byte	1,2,35,81,10
	.byte	'GetStackValueAdjust',0
	.word	3427
	.byte	8,2,35,84,10
	.byte	'InErrorHook',0
	.word	143
	.byte	1,2,35,92,10
	.byte	'ChainTaskRef',0
	.word	6749
	.byte	4,2,35,96,10
	.byte	'GetStackUsageAdjust',0
	.word	3427
	.byte	8,2,35,100,10
	.byte	'InProtectionHook',0
	.word	143
	.byte	1,2,35,108,10
	.byte	'CoreIsActive',0
	.word	143
	.byte	1,2,35,109,10
	.byte	'InShutdownHook',0
	.word	143
	.byte	1,2,35,110,0,12
	.byte	'Os_ControlledCoreType',0,13,141,7,3
	.word	6754
	.byte	6
	.word	253
	.byte	11
	.word	4490
	.byte	6
	.word	7210
	.byte	11
	.word	5060
	.byte	6
	.word	7220
	.byte	6
	.word	4142
	.byte	26
	.byte	'Os_AnyCoreType_s',0,13,151,7,16,96,10
	.byte	'DisableAllImask',0
	.word	253
	.byte	4,2,35,0,10
	.byte	'SuspendAllImask',0
	.word	253
	.byte	4,2,35,4,10
	.byte	'SuspendOSImask',0
	.word	253
	.byte	4,2,35,8,10
	.byte	'DisableAllCount',0
	.word	253
	.byte	4,2,35,12,10
	.byte	'SuspendAllCount',0
	.word	253
	.byte	4,2,35,16,10
	.byte	'SuspendOSCount',0
	.word	253
	.byte	4,2,35,20,10
	.byte	'RestartJumpBuf',0
	.word	3376
	.byte	68,2,35,24,10
	.byte	'Restartable',0
	.word	143
	.byte	1,2,35,92,0,12
	.byte	'Os_AnyCoreType',0,13,160,7,3
	.word	7235
	.byte	12
	.byte	'Can_TxObjPriorityClassType',0,14,219,3,16
	.word	253
	.byte	26
	.byte	'Can_TxHwObjectConfigType',0,14,231,3,16,8,10
	.byte	'MsgObjId',0
	.word	143
	.byte	1,2,35,0,10
	.byte	'HwControllerId',0
	.word	143
	.byte	1,2,35,1,10
	.byte	'TxObjPriorityClass',0
	.word	253
	.byte	4,2,35,4,0,12
	.byte	'Can_TxHwObjectConfigType',0,14,252,3,3
	.word	7512
	.byte	26
	.byte	'Can_RxHwObjectConfigType',0,14,129,4,16,12,10
	.byte	'MaskRef',0
	.word	253
	.byte	4,2,35,0,10
	.byte	'MsgId',0
	.word	253
	.byte	4,2,35,4,10
	.byte	'MsgObjId',0
	.word	143
	.byte	1,2,35,8,10
	.byte	'HwControllerId',0
	.word	143
	.byte	1,2,35,9,0,12
	.byte	'Can_RxHwObjectConfigType',0,14,147,4,3
	.word	7648
	.byte	24,4
	.word	143
	.byte	25,3,0,26
	.byte	'Can_ControllerMOMapConfigType',0,14,181,4,16,4,10
	.byte	'ControllerMOMap',0
	.word	7788
	.byte	4,2,35,0,0,12
	.byte	'Can_ControllerMOMapConfigType',0,14,184,4,3
	.word	7797
	.byte	26
	.byte	'Can_NPCRValueType',0,14,188,4,16,2,10
	.byte	'Can_NPCRValue',0
	.word	160
	.byte	2,2,35,0,0,12
	.byte	'Can_NPCRValueType',0,14,191,4,3
	.word	7898
	.byte	26
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,14,194,4,16,8,10
	.byte	'CanControllerBaudrate',0
	.word	253
	.byte	4,2,35,0,10
	.byte	'CanControllerBaudrateCfg',0
	.word	160
	.byte	2,2,35,4,0,12
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,14,198,4,3
	.word	7973
	.byte	11
	.word	7973
	.byte	6
	.word	8138
	.byte	26
	.byte	'Can_BaudrateConfigPtrType',0,14,201,4,16,4,10
	.byte	'Can_kBaudrateConfigPtr',0
	.word	8143
	.byte	4,2,35,0,0,12
	.byte	'Can_BaudrateConfigPtrType',0,14,204,4,3
	.word	8148
	.byte	26
	.byte	'Can_EventHandlingType',0,14,226,4,16,4,10
	.byte	'CanEventType',0
	.word	7788
	.byte	4,2,35,0,0,12
	.byte	'Can_EventHandlingType',0,14,229,4,3
	.word	8248
	.byte	12
	.byte	'Rte_TransformerErrorCode',0,15,130,1,15
	.word	143
	.byte	12
	.byte	'Rte_TransformerClass',0,15,131,1,15
	.word	143
	.byte	9,15,168,1,9,12,10
	.byte	'in',0
	.word	4088
	.byte	4,2,35,0,10
	.byte	'out',0
	.word	4088
	.byte	4,2,35,4,10
	.byte	'used',0
	.word	160
	.byte	2,2,35,8,10
	.byte	'lost_data',0
	.word	143
	.byte	1,2,35,10,0,12
	.byte	'Rte_QDynType',0,15,173,1,3
	.word	8394
	.byte	22,15,175,1,9,4,23
	.byte	'RTE_DRA',0,0,23
	.byte	'RTE_WOWP',0,1,23
	.byte	'RTE_TASK',0,2,23
	.byte	'RTE_ARE',0,3,23
	.byte	'RTE_EV',0,4,23
	.byte	'RTE_MSI',0,5,0,12
	.byte	'Rte_NotificationType',0,15,182,1,3
	.word	8481
	.byte	6
	.word	8394
	.byte	26
	.byte	'Rte_QCmnType',0,15,184,1,16,24,10
	.byte	'dynamic',0
	.word	8579
	.byte	4,2,35,0,10
	.byte	'copy',0
	.word	143
	.byte	1,2,35,4,10
	.byte	'queue_size',0
	.word	160
	.byte	2,2,35,6,10
	.byte	'element_size',0
	.word	160
	.byte	2,2,35,8,10
	.byte	'buffer_start',0
	.word	4088
	.byte	4,2,35,12,10
	.byte	'buffer_end',0
	.word	4088
	.byte	4,2,35,16,10
	.byte	'notification_type',0
	.word	8481
	.byte	4,2,35,20,0,12
	.byte	'Rte_QCmnType',0,15,192,1,3
	.word	8584
	.byte	12
	.byte	'Rte_AlarmRefType',0,15,224,1,32
	.word	253
	.byte	12
	.byte	'Rte_AlarmIndexType',0,15,226,1,32
	.word	160
	.byte	24,128,8
	.word	143
	.byte	25,255,7,0,12
	.byte	'Impl_NVM_DstPtrType_1024',0,16,50,15
	.word	8822
	.byte	12
	.byte	'CanIf_u32_impl',0,16,69,16
	.word	253
	.byte	12
	.byte	'CanIf_u16_impl',0,16,71,16
	.word	160
	.byte	12
	.byte	'CanIf_u8_impl',0,16,73,15
	.word	143
	.byte	12
	.byte	'CanIf_ControllerModeType_Enum_impl',0,16,88,15
	.word	143
	.byte	12
	.byte	'CanIf_PduModeType_Enum_impl',0,16,90,15
	.word	143
	.byte	9,16,92,9,2,10
	.byte	'DeviceMode',0
	.word	143
	.byte	1,2,35,0,10
	.byte	'ChannelMode',0
	.word	143
	.byte	1,2,35,1,0,12
	.byte	'CanIf_ControllerStateType_struct_impl',0,16,95,3
	.word	9013
	.byte	12
	.byte	'CanIf_NotifStatusType_Enum_impl',0,16,100,15
	.word	143
	.byte	12
	.byte	'CanSM_boolean_Impl',0,16,120,15
	.word	143
	.byte	12
	.byte	'CanSM_u8_Impl',0,16,123,15
	.word	143
	.byte	12
	.byte	'CanSM_BusOffRecoveryStateType_Enum_impl',0,16,128,1,15
	.word	143
	.byte	12
	.byte	'CanSM_NetworkModeStateType_Enum_impl',0,16,132,1,15
	.word	143
	.byte	12
	.byte	'CanSM_u16_Impl',0,16,136,1,16
	.word	160
	.byte	12
	.byte	'CanSM_TimerStateType_Enum_impl',0,16,138,1,15
	.word	143
	.byte	9,16,140,1,9,4,10
	.byte	'cntTick_u16',0
	.word	160
	.byte	2,2,35,0,10
	.byte	'stTimer',0
	.word	143
	.byte	1,2,35,2,0,12
	.byte	'CanSM_TimerConfig_tst_struct_impl',0,16,143,1,3
	.word	9354
	.byte	12
	.byte	'Com_impl_u16',0,16,154,1,16
	.word	160
	.byte	12
	.byte	'Com_impl_u8',0,16,157,1,15
	.word	143
	.byte	12
	.byte	'ComM_uint32_Impl',0,16,173,1,16
	.word	253
	.byte	12
	.byte	'ComM_uint16_Impl',0,16,175,1,16
	.word	160
	.byte	12
	.byte	'ComM_uint8_Impl',0,16,177,1,15
	.word	143
	.byte	12
	.byte	'ComM_bool_Impl',0,16,179,1,15
	.word	143
	.byte	9,16,181,1,9,24,10
	.byte	'ChannelState_e',0
	.word	253
	.byte	4,2,35,0,10
	.byte	'LightTimeoutCtr_u32',0
	.word	253
	.byte	4,2,35,4,10
	.byte	'MinFullComTimeoutCtr_u16',0
	.word	160
	.byte	2,2,35,8,10
	.byte	'ChannelMode_u8',0
	.word	143
	.byte	1,2,35,10,10
	.byte	'BusSmMode_u8',0
	.word	143
	.byte	1,2,35,11,10
	.byte	'UserRequestCtr_u8',0
	.word	143
	.byte	1,2,35,12,10
	.byte	'PassiveRequestState_u8',0
	.word	143
	.byte	1,2,35,13,10
	.byte	'PncRequestCtr_u8',0
	.word	143
	.byte	1,2,35,14,10
	.byte	'InhibitionReqStatus_u8',0
	.word	143
	.byte	1,2,35,15,10
	.byte	'NmNetworkRequestStatus_b',0
	.word	143
	.byte	1,2,35,16,10
	.byte	'DiagnosticRequestState_b',0
	.word	143
	.byte	1,2,35,17,10
	.byte	'CommunicationAllowed_b',0
	.word	143
	.byte	1,2,35,18,10
	.byte	'NmBusSleepIndicationStatus_b',0
	.word	143
	.byte	1,2,35,19,10
	.byte	'NmPrepareBusSleepIndicationStatus_b',0
	.word	143
	.byte	1,2,35,20,10
	.byte	'NmNetworkModeStatus_b',0
	.word	143
	.byte	1,2,35,21,0,12
	.byte	'ComM_ChannelStruct_Impl',0,16,197,1,3
	.word	9586
	.byte	9,16,206,1,9,10,10
	.byte	'WakeUpInhibitionCtr_u16',0
	.word	160
	.byte	2,2,35,0,10
	.byte	'LimitToNoComCtr_u16',0
	.word	160
	.byte	2,2,35,2,10
	.byte	'RequestedUserMode_t',0
	.word	143
	.byte	1,2,35,4,10
	.byte	'IndicatedUserMode_t',0
	.word	143
	.byte	1,2,35,5,10
	.byte	'numChannelsInFullCom_u8',0
	.word	143
	.byte	1,2,35,6,10
	.byte	'numChannelsInSilentCom_u8',0
	.word	143
	.byte	1,2,35,7,10
	.byte	'numChannelsInNoCom_u8',0
	.word	143
	.byte	1,2,35,8,0,12
	.byte	'ComM_UserStruct_Impl',0,16,214,1,3
	.word	10090
	.byte	12
	.byte	'Dcm_IOOperationResponseType',0,16,252,1,15
	.word	143
	.byte	12
	.byte	'Dcm_RequestDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspRequestRoutineResultsOutSignal_0PrimitivType',0
	.byte	16,138,2,15
	.word	143
	.byte	12
	.byte	'Dcm_StartDataIn_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineInSignalPrimitivType',0,16,146,2,15
	.word	143
	.byte	12
	.byte	'Dcm_StartDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineOutSignalPrimitivType',0,16,150,2,15
	.word	143
	.byte	12
	.byte	'Dcm_StopDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStopRoutineOutSignalPrimitivType',0,16,154,2,15
	.word	143
	.byte	12
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockNative_1024_Type',0,16,243,3,34
	.word	8833
	.byte	24,128,8
	.word	143
	.byte	25,255,7,0,12
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockRedundant_1024_Type',0,16,246,3,34
	.word	8833
	.byte	12
	.byte	'Rte_TaskRefType',0,17,184,1,32
	.word	5320
	.byte	12
	.byte	'Rte_EventRefType',0,17,185,1,32
	.word	143
	.byte	12
	.byte	'Rte_EventType',0,17,186,1,32
	.word	253
	.byte	12
	.byte	'Rte_REActCounterType',0,17,252,1,15
	.word	143
	.byte	6
	.word	143
	.byte	12
	.byte	'Rte_REActCounterRefType',0,17,253,1,58
	.word	11012
	.byte	9,17,255,1,9,8,10
	.byte	'task',0
	.word	10908
	.byte	4,2,35,0,10
	.byte	'acnt',0
	.word	11017
	.byte	4,2,35,4,0,12
	.byte	'Rte_REContainerType',0,17,130,2,3
	.word	11050
	.byte	11
	.word	5060
	.byte	6
	.word	11114
	.byte	6
	.word	143
	.byte	11
	.word	11050
	.byte	6
	.word	11129
	.byte	12
	.byte	'Rte_REContainerRefType',0,17,132,2,60
	.word	11134
	.byte	12
	.byte	'Rte_MSICounterType',0,17,149,2,16
	.word	160
	.byte	6
	.word	160
	.byte	12
	.byte	'Rte_MSICounterRefType',0,17,150,2,56
	.word	11199
	.byte	12
	.byte	'Rte_MSIPendingFlagType',0,17,152,2,17
	.word	143
	.byte	6
	.word	143
	.byte	12
	.byte	'Rte_MSIPendingFlagRefType',0,17,153,2,60
	.word	11267
	.byte	9,17,163,2,9,24,10
	.byte	'counter',0
	.word	11204
	.byte	4,2,35,0,10
	.byte	'incCounter',0
	.word	143
	.byte	1,2,35,4,10
	.byte	'pending',0
	.word	11272
	.byte	4,2,35,8,10
	.byte	'osTask',0
	.word	10908
	.byte	4,2,35,12,10
	.byte	'acnt',0
	.word	11017
	.byte	4,2,35,16,10
	.byte	'osEvent',0
	.word	143
	.byte	1,2,35,20,10
	.byte	'MSIInit',0
	.word	160
	.byte	2,2,35,22,0,12
	.byte	'Rte_MSITableEntry',0,17,172,2,3
	.word	11307
	.byte	6
	.word	160
	.byte	6
	.word	143
	.byte	12
	.byte	'Rte_TaskArrayIndex',0,17,179,2,16
	.word	143
	.byte	12
	.byte	'Rte_NrWaitingTasks',0,17,180,2,16
	.word	143
	.byte	9,17,182,2,9,4,10
	.byte	'pending',0
	.word	143
	.byte	1,2,35,0,10
	.byte	'count',0
	.word	143
	.byte	1,2,35,1,10
	.byte	'firstWaitingTask',0
	.word	143
	.byte	1,2,35,2,0,12
	.byte	'Rte_WaitableDatum',0,17,186,2,3
	.word	11525
	.byte	6
	.word	11525
	.byte	9,17,226,2,9,12,10
	.byte	'event_id',0
	.word	253
	.byte	4,2,35,0,10
	.byte	'wd',0
	.word	11617
	.byte	4,2,35,4,10
	.byte	'timeout',0
	.word	253
	.byte	4,2,35,8,0,12
	.byte	'Rte_WOWP_NotificationType',0,17,230,2,3
	.word	11622
	.byte	11
	.word	11622
	.byte	6
	.word	11711
	.byte	12
	.byte	'Rte_WOWP_NotificationRefType',0,17,232,2,66
	.word	11716
	.byte	12
	.byte	'Rte_ARE_NotificationType',0,17,234,2,29
	.word	11050
	.byte	26
	.byte	'Rte_QTaskType',0,17,243,2,16,28,10
	.byte	'cmn',0
	.word	8584
	.byte	24,2,35,0,10
	.byte	'task',0
	.word	10908
	.byte	4,2,35,24,0,12
	.byte	'Rte_QTaskType',0,17,246,2,3
	.word	11793
	.byte	26
	.byte	'Rte_QREType',0,17,250,2,16,28,10
	.byte	'cmn',0
	.word	8584
	.byte	24,2,35,0,10
	.byte	're',0
	.word	11139
	.byte	4,2,35,24,0,12
	.byte	'Rte_QREType',0,17,253,2,3
	.word	11864
	.byte	11
	.word	11050
	.byte	6
	.word	11929
	.byte	26
	.byte	'Rte_QWWPType',0,17,129,3,16,28,10
	.byte	'cmn',0
	.word	8584
	.byte	24,2,35,0,10
	.byte	'wwp',0
	.word	11721
	.byte	4,2,35,24,0,12
	.byte	'Rte_QWWPType',0,17,132,3,3
	.word	11939
	.byte	11
	.word	11622
	.byte	6
	.word	12007
	.byte	26
	.byte	'Rte_QEvType',0,17,136,3,16,36,10
	.byte	'cmn',0
	.word	8584
	.byte	24,2,35,0,10
	.byte	'task',0
	.word	10908
	.byte	4,2,35,24,10
	.byte	'mask',0
	.word	143
	.byte	1,2,35,28,10
	.byte	'acnt',0
	.word	11017
	.byte	4,2,35,32,0,12
	.byte	'Rte_QEvType',0,17,141,3,3
	.word	12017
	.byte	26
	.byte	'Rte_QMSIType',0,17,145,3,16,48,10
	.byte	'cmn',0
	.word	8584
	.byte	24,2,35,0,10
	.byte	'task',0
	.word	10908
	.byte	4,2,35,24,10
	.byte	'mask',0
	.word	143
	.byte	1,2,35,28,10
	.byte	'acnt',0
	.word	11017
	.byte	4,2,35,32,10
	.byte	'msiCounter',0
	.word	11204
	.byte	4,2,35,36,10
	.byte	'msiPending',0
	.word	11272
	.byte	4,2,35,40,10
	.byte	'msiLimit',0
	.word	160
	.byte	2,2,35,44,0,12
	.byte	'Rte_QMSIType',0,17,153,3,3
	.word	12112
	.byte	9,3,52,9,1,34
	.byte	'isEventTrig',0,1
	.word	143
	.byte	1,7,2,35,0,34
	.byte	'isTriggerIpduSendWithMetadata',0,1
	.word	143
	.byte	1,6,2,35,0,34
	.byte	'isGwIpduSend',0,1
	.word	143
	.byte	1,5,2,35,0,34
	.byte	'isModeChangd',0,1
	.word	143
	.byte	1,4,2,35,0,34
	.byte	'sigTransProp',0,1
	.word	143
	.byte	1,3,2,35,0,34
	.byte	'isTimeoutReq',0,1
	.word	143
	.byte	1,2,2,35,0,34
	.byte	'ignoreRepetitions',0,1
	.word	143
	.byte	1,1,2,35,0,0,12
	.byte	'Com_SendIpduInfo',0,3,61,3
	.word	12267
	.byte	9,3,76,9,8,10
	.byte	'TimePeriodFact',0
	.word	160
	.byte	2,2,35,0,10
	.byte	'TimeOffsetFact',0
	.word	160
	.byte	2,2,35,2,10
	.byte	'RepetitionPeriodFact',0
	.word	160
	.byte	2,2,35,4,10
	.byte	'NumOfRepetitions',0
	.word	143
	.byte	1,2,35,6,10
	.byte	'Mode',0
	.word	143
	.byte	1,2,35,7,0,12
	.byte	'Com_TransModeInfo',0,3,93,2
	.word	12487
	.byte	11
	.word	12487
	.byte	6
	.word	12637
	.byte	12
	.byte	'Com_TMConstPtrType',0,3,103,65
	.word	12642
	.byte	9,3,136,1,9,12,10
	.byte	'Init_Val',0
	.word	253
	.byte	4,2,35,0,10
	.byte	'txSignalFields',0
	.word	160
	.byte	2,2,35,4,10
	.byte	'Bit_Pos',0
	.word	143
	.byte	1,2,35,6,10
	.byte	'BitSize',0
	.word	143
	.byte	1,2,35,7,10
	.byte	'IpduRef',0
	.word	143
	.byte	1,2,35,8,10
	.byte	'General',0
	.word	143
	.byte	1,2,35,9,0,12
	.byte	'Com_Prv_xTxSigCfg_tst',0,3,201,1,2
	.word	12674
	.byte	12
	.byte	'Com_Prv_xRxSigCfg_tst',0,3,171,2,2
	.word	829
	.byte	9,3,211,5,9,24,10
	.byte	'BuffPtr',0
	.word	675
	.byte	4,2,35,0,10
	.byte	'Com_TMConstPtr',0
	.word	12642
	.byte	4,2,35,4,10
	.byte	'Size',0
	.word	160
	.byte	2,2,35,8,10
	.byte	'Timeout_Fact',0
	.word	160
	.byte	2,2,35,10,10
	.byte	'Min_Delay_Time_Fact',0
	.word	160
	.byte	2,2,35,12,10
	.byte	'No_Of_Sig_Ref',0
	.word	160
	.byte	2,2,35,14,10
	.byte	'PdurId',0
	.word	160
	.byte	2,2,35,16,10
	.byte	'TxSigId_Index',0
	.word	143
	.byte	1,2,35,18,10
	.byte	'txIPduFields',0
	.word	160
	.byte	2,2,35,20,10
	.byte	'MainFunctionRef',0
	.word	143
	.byte	1,2,35,22,10
	.byte	'PaddingByte',0
	.word	143
	.byte	1,2,35,23,0,12
	.byte	'Com_Prv_xTxIpduInfoCfg_tst',0,3,162,6,3
	.word	12853
	.byte	11
	.word	12853
	.byte	6
	.word	13132
	.byte	12
	.byte	'Com_TxIpduConstPtrType',0,3,171,6,72
	.word	13137
	.byte	12
	.byte	'Com_Prv_xRxIpduInfoCfg_tst',0,3,197,7,3
	.word	1805
	.byte	9,3,219,7,9,4,10
	.byte	'FirstIpdu_Index',0
	.word	160
	.byte	2,2,35,0,10
	.byte	'NoOfRxPdus',0
	.word	160
	.byte	2,2,35,2,0,12
	.byte	'Com_Prv_xIpduGrpInfoCfg_tst',0,3,224,7,3
	.word	13210
	.byte	9,3,244,7,9,1,10
	.byte	'txSigRAMFields',0
	.word	143
	.byte	1,2,35,0,0,12
	.byte	'Com_TxSignalFlagType',0,3,248,7,2
	.word	13299
	.byte	12
	.byte	'Com_RxSignalFlagType',0,3,171,8,2
	.word	2072
	.byte	9,3,135,9,9,16,10
	.byte	'CurrentTxModePtr',0
	.word	12647
	.byte	4,2,35,0,10
	.byte	'Com_MinDelayTick',0
	.word	160
	.byte	2,2,35,4,10
	.byte	'Com_Tick_Tx',0
	.word	160
	.byte	2,2,35,6,10
	.byte	'Com_n_Tick_Tx',0
	.word	160
	.byte	2,2,35,8,10
	.byte	'Com_TickTxTimeout',0
	.word	160
	.byte	2,2,35,10,10
	.byte	'Com_TxFlags',0
	.word	160
	.byte	2,2,35,12,10
	.byte	'Com_n',0
	.word	143
	.byte	1,2,35,14,10
	.byte	'Com_TransMode',0
	.word	143
	.byte	1,2,35,15,0,12
	.byte	'Com_TxIpduRamData',0,3,189,9,3
	.word	13390
	.byte	11
	.word	12487
	.byte	6
	.word	13606
	.byte	6
	.word	13390
	.byte	12
	.byte	'Com_TxIpduRamPtrType',0,3,198,9,62
	.word	13616
	.byte	9,3,218,9,9,6,10
	.byte	'RxIPduLength',0
	.word	160
	.byte	2,2,35,0,10
	.byte	'RxTicks_u16',0
	.word	160
	.byte	2,2,35,2,10
	.byte	'RxFlags',0
	.word	143
	.byte	1,2,35,4,0,12
	.byte	'Com_RxIpduRamData',0,3,245,9,2
	.word	13651
	.byte	6
	.word	160
	.byte	9,3,128,10,9,8,10
	.byte	'RxGwQueuePtr',0
	.word	13745
	.byte	4,2,35,0,10
	.byte	'Com_RxGwQueueWrite_ux',0
	.word	143
	.byte	1,2,35,4,10
	.byte	'Com_RxGwQueueRead_ux',0
	.word	143
	.byte	1,2,35,5,0,12
	.byte	'Com_RxGwQueueRAMType',0,3,133,10,2
	.word	13750
	.byte	9,3,138,10,9,4,10
	.byte	'indexGwMapSigDestIdArray',0
	.word	160
	.byte	2,2,35,0,10
	.byte	'destCount',0
	.word	143
	.byte	1,2,35,2,0,12
	.byte	'Com_Prv_xGwMapSigCfg_tst',0,3,142,10,2
	.word	13870
	.byte	9,3,147,10,9,2,10
	.byte	'GwMap_DestId',0
	.word	160
	.byte	2,2,35,0,0,12
	.byte	'Com_Prv_xGwMapSigIdCfg_tst',0,3,150,10,2
	.word	13964
	.byte	9,3,183,10,9,4,10
	.byte	'StartIPduId',0
	.word	143
	.byte	1,2,35,0,10
	.byte	'NumOfIpdus',0
	.word	143
	.byte	1,2,35,1,10
	.byte	'TimeBaseInMs',0
	.word	143
	.byte	1,2,35,2,0,12
	.byte	'Com_MainFunctionCfgType',0,3,188,10,3
	.word	14029
	.byte	9,3,194,10,9,12,10
	.byte	'Com_SigType_pu8',0
	.word	675
	.byte	4,2,35,0,10
	.byte	'Com_SigType_pu16',0
	.word	503
	.byte	4,2,35,4,10
	.byte	'Com_SigType_pu32',0
	.word	589
	.byte	4,2,35,8,0,12
	.byte	'Com_Prv_xRxRamBuf_tst',0,3,253,10,3
	.word	14132
	.byte	12
	.byte	'rba_BswSrv_uint64',0,18,66,28
	.word	2437
	.byte	35
	.word	2072
	.byte	36,0,37
	.byte	'Com_RxSignalFlag',0,6,231,24,44
	.word	14273
	.byte	1,1,35
	.word	829
	.byte	36,0,11
	.word	14308
	.byte	37
	.byte	'Com_Prv_xRxSigCfg_acst',0,6,131,26,55
	.word	14315
	.byte	1,1,35
	.word	1805
	.byte	36,0,11
	.word	14354
	.byte	37
	.byte	'Com_Prv_xRxIpduCfg_acst',0,6,143,26,57
	.word	14361
	.byte	1,1,35
	.word	14132
	.byte	36,0,11
	.word	14401
	.byte	37
	.byte	'Com_Prv_xRxRamBuf_acst',0,6,235,26,48
	.word	14408
	.byte	1,1,0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L44:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,36,0,3,8,11,15,62,15,0,0,3,46,1,3,8,32,13,58,15,59,15
	.byte	57,15,73,19,54,15,39,12,0,0,4,5,0,3,8,58,15,59,15,57,15,73,19,0,0,5,11,0,0,0,6,15,0,73,19,0,0,7,46,1,3
	.byte	8,32,13,58,15,59,15,57,15,54,15,39,12,0,0,8,21,0,54,15,39,12,0,0,9,19,1,58,15,59,15,57,15,11,15,0,0,10
	.byte	13,0,3,8,73,19,11,15,56,9,0,0,11,38,0,73,19,0,0,12,22,0,3,8,58,15,59,15,57,15,73,19,0,0,13,11,1,0,0,14
	.byte	46,1,49,19,0,0,15,5,0,49,19,0,0,16,46,1,3,8,58,15,59,15,57,15,54,15,39,12,63,12,60,12,0,0,17,46,1,3,8
	.byte	58,15,59,15,57,15,73,19,54,15,39,12,63,12,60,12,0,0,18,29,1,49,19,0,0,19,11,0,49,19,0,0,20,11,1,49,19
	.byte	0,0,21,21,0,54,15,0,0,22,4,1,58,15,59,15,57,15,11,15,0,0,23,40,0,3,8,28,13,0,0,24,1,1,11,15,73,19,0,0
	.byte	25,33,0,47,15,0,0,26,19,1,3,8,58,15,59,15,57,15,11,15,0,0,27,59,0,3,8,0,0,28,21,1,54,15,39,12,0,0,29,5
	.byte	0,73,19,0,0,30,23,1,58,15,59,15,57,15,11,15,0,0,31,4,1,3,8,58,15,59,15,57,15,11,15,0,0,32,21,0,73,19,54
	.byte	15,39,12,0,0,33,53,0,73,19,0,0,34,13,0,3,8,11,15,73,19,13,15,12,15,56,9,0,0,35,1,1,73,19,0,0,36,33,0,0
	.byte	0,37,52,0,3,8,58,15,59,15,57,15,73,19,63,12,60,12,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L45:
	.word	.L179-.L178
.L178:
	.half	3
	.word	.L181-.L180
.L180:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Bfx\\api\\Bfx_Bit_Inl.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv_Inl.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv_Types.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_ProcessSignal.c',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Types.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Platform\\Platform_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Std_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Com\\Com_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Com\\Com_Cfg_Internal.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Can_GeneralTypes.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\RTOS_T\\Gen\\inc\\Os.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Can_17_MCanP\\inc\\Can_17_MCanP.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Type.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Intl.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\rba_BswSrv.h',0,0,0,0,0
.L181:
.L179:
	.sdecl	'.debug_info',debug,cluster('Com_Prv_ProcessSignal')
	.sect	'.debug_info'
.L46:
	.word	1318
	.half	3
	.word	.L47
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_ProcessSignal.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L49,.L48
	.byte	2
	.word	.L42
	.byte	3
	.byte	'Com_Prv_ProcessSignal',0,1,48,22,1,1,1
	.word	.L41,.L51,.L40
	.byte	4
	.byte	'RxPduId',0,1,49,81
	.word	.L52,.L53
	.byte	4
	.byte	'PduInfoPtr',0,1,50,81
	.word	.L54,.L55
	.byte	5
	.word	.L41,.L51
	.byte	6
	.byte	'RxIPduConstPtr',0,1,53,37
	.word	.L56,.L57
	.byte	6
	.byte	'RxSigConstPtr',0,1,54,37
	.word	.L58,.L59
	.byte	6
	.byte	'RxSigRamPtr',0,1,55,37
	.word	.L60,.L61
	.byte	6
	.byte	'Idx_Sig_ui',0,1,56,37
	.word	.L62,.L63
	.byte	6
	.byte	'limit_ui',0,1,57,37
	.word	.L62,.L64
	.byte	6
	.byte	'ProcessSignal_b',0,1,63,37
	.word	.L65,.L66
	.byte	5
	.word	.L67,.L15
	.byte	6
	.byte	'Size',0,1,112,49
	.word	.L65,.L68
	.byte	6
	.byte	'ConstByteValue_u8',0,1,113,49
	.word	.L65,.L69
	.byte	6
	.byte	'SigType',0,1,114,49
	.word	.L65,.L70
	.byte	6
	.byte	'SigEndianess',0,1,115,49
	.word	.L65,.L71
	.byte	7
	.word	.L72,.L73,.L4
	.byte	8
	.word	.L74,.L75
	.byte	8
	.word	.L76,.L77
	.byte	8
	.word	.L78,.L79
	.byte	9
	.word	.L80,.L73,.L4
	.byte	0,7
	.word	.L81,.L4,.L5
	.byte	8
	.word	.L82,.L83
	.byte	8
	.word	.L84,.L85
	.byte	9
	.word	.L86,.L4,.L5
	.byte	0,5
	.word	.L7,.L14
	.byte	6
	.byte	'SigLastByteNo',0,1,126,47
	.word	.L52,.L87
	.byte	10
	.word	.L88
	.byte	6
	.byte	'lastBitPosition',0,1,136,1,57
	.word	.L65,.L92
	.byte	0,0,7
	.word	.L93,.L94,.L15
	.byte	8
	.word	.L95,.L96
	.byte	8
	.word	.L97,.L98
	.byte	8
	.word	.L99,.L100
	.byte	11
	.word	.L101,.L94,.L15
	.byte	6
	.byte	'RxIPduConstPtr',0,1,244,2,45
	.word	.L56,.L102
	.byte	6
	.byte	'RxSigConstPtr',0,1,245,2,45
	.word	.L58,.L103
	.byte	6
	.byte	'RxSigRamPtr',0,1,246,2,45
	.word	.L60,.L104
	.byte	6
	.byte	'RxSigNewVal',0,1,247,2,45
	.word	.L105,.L106
	.byte	6
	.byte	'RxPduId',0,1,248,2,45
	.word	.L52,.L107
	.byte	6
	.byte	'rxMainFuncId',0,1,249,2,45
	.word	.L65,.L108
	.byte	6
	.byte	'ConstByteValue_u8',0,1,250,2,45
	.word	.L65,.L109
	.byte	6
	.byte	'SigType',0,1,251,2,45
	.word	.L65,.L110
	.byte	6
	.byte	'SigEndianess',0,1,252,2,45
	.word	.L65,.L111
	.byte	6
	.byte	'copySignal_b',0,1,253,2,45
	.word	.L65,.L112
	.byte	7
	.word	.L72,.L113,.L16
	.byte	8
	.word	.L74,.L75
	.byte	8
	.word	.L76,.L77
	.byte	8
	.word	.L78,.L79
	.byte	9
	.word	.L80,.L113,.L16
	.byte	0,7
	.word	.L81,.L16,.L17
	.byte	8
	.word	.L82,.L83
	.byte	8
	.word	.L84,.L85
	.byte	9
	.word	.L86,.L16,.L17
	.byte	0,11
	.word	.L114,.L115,.L22
	.byte	6
	.byte	'SigBuff_Index',0,1,206,3,49
	.word	.L65,.L116
	.byte	7
	.word	.L117,.L118,.L31
	.byte	8
	.word	.L119,.L120
	.byte	8
	.word	.L121,.L122
	.byte	8
	.word	.L123,.L124
	.byte	11
	.word	.L125,.L118,.L31
	.byte	6
	.byte	'Type',0,2,205,2,29
	.word	.L65,.L126
	.byte	7
	.word	.L72,.L127,.L24
	.byte	8
	.word	.L74,.L75
	.byte	8
	.word	.L76,.L77
	.byte	8
	.word	.L78,.L79
	.byte	9
	.word	.L80,.L127,.L24
	.byte	0,0,0,0,0,0,0,7
	.word	.L128,.L15,.L129
	.byte	8
	.word	.L130,.L131
	.byte	8
	.word	.L132,.L133
	.byte	8
	.word	.L134,.L135
	.byte	11
	.word	.L136,.L15,.L129
	.byte	6
	.byte	'tmp_u8',0,3,250,3,11
	.word	.L65,.L137
	.byte	0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('Com_Prv_ProcessSignal')
	.sect	'.debug_abbrev'
.L47:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,52,0,3
	.byte	8,58,15,59,15,57,15,73,16,2,6,0,0,7,29,1,49,16,17,1,18,1,0,0,8,5,0,49,16,2,6,0,0,9,11,0,49,16,17,1,18
	.byte	1,0,0,10,11,1,85,6,0,0,11,11,1,49,16,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('Com_Prv_ProcessSignal')
	.sect	'.debug_line'
.L48:
	.word	.L183-.L182
.L182:
	.half	3
	.word	.L185-.L184
.L184:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_ProcessSignal.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv_Inl.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Bfx\\api\\Bfx_Bit_Inl.h',0,0,0,0,0
.L185:
	.byte	5,22,7,0,5,2
	.word	.L41
	.byte	3,47,1,9
	.half	.L139-.L41
	.byte	3,17,1,5,49,9
	.half	.L140-.L139
	.byte	3,31,1,5,95,9
	.half	.L142-.L140
	.byte	1,5,65,9
	.half	.L143-.L142
	.byte	1,5,22,9
	.half	.L186-.L143
	.byte	3,1,1,5,21,9
	.half	.L144-.L186
	.byte	3,1,1,5,89,9
	.half	.L145-.L144
	.byte	3,3,1,5,25,9
	.half	.L3-.L145
	.byte	3,3,1,5,47,9
	.half	.L67-.L3
	.byte	3,13,1,5,34,9
	.half	.L146-.L67
	.byte	3,2,1,4,3,5,27,9
	.half	.L73-.L146
	.byte	3,190,2,1,5,45,9
	.half	.L187-.L73
	.byte	1,5,68,9
	.half	.L188-.L187
	.byte	1,5,60,9
	.half	.L189-.L188
	.byte	1,5,42,9
	.half	.L190-.L189
	.byte	1,5,5,9
	.half	.L191-.L190
	.byte	1,5,32,9
	.half	.L4-.L191
	.byte	3,68,1,5,36,9
	.half	.L192-.L4
	.byte	1,5,21,9
	.half	.L193-.L192
	.byte	1,5,48,9
	.half	.L147-.L193
	.byte	1,5,5,9
	.half	.L194-.L147
	.byte	1,4,1,5,34,9
	.half	.L5-.L194
	.byte	3,255,125,1,5,37,9
	.half	.L7-.L5
	.byte	3,8,1,5,53,9
	.half	.L89-.L7
	.byte	3,12,1,5,17,9
	.half	.L90-.L89
	.byte	3,122,1,5,52,7,9
	.half	.L91-.L90
	.byte	3,7,1,5,40,9
	.half	.L195-.L91
	.byte	1,5,89,7,9
	.half	.L196-.L195
	.byte	1,5,100,9
	.half	.L197-.L196
	.byte	1,5,65,9
	.half	.L9-.L197
	.byte	1,5,63,9
	.half	.L10-.L9
	.byte	3,127,1,5,55,9
	.half	.L149-.L10
	.byte	3,3,1,5,99,7,9
	.half	.L198-.L149
	.byte	1,5,105,9
	.half	.L150-.L198
	.byte	1,5,112,9
	.half	.L199-.L150
	.byte	1,5,79,9
	.half	.L11-.L199
	.byte	1,5,119,9
	.half	.L12-.L11
	.byte	1,5,78,9
	.half	.L8-.L12
	.byte	3,5,1,5,36,9
	.half	.L13-.L8
	.byte	3,6,1,5,54,9
	.half	.L151-.L13
	.byte	1,5,17,9
	.half	.L200-.L151
	.byte	1,5,37,9
	.half	.L201-.L200
	.byte	3,3,1,5,13,9
	.half	.L14-.L201
	.byte	3,26,1,5,56,7,9
	.half	.L202-.L14
	.byte	3,2,1,5,26,9
	.half	.L94-.L202
	.byte	3,198,1,1,5,39,9
	.half	.L152-.L94
	.byte	3,3,1,5,26,9
	.half	.L153-.L152
	.byte	3,1,1,5,40,9
	.half	.L155-.L153
	.byte	3,1,1,5,39,9
	.half	.L156-.L155
	.byte	3,2,1,5,26,9
	.half	.L157-.L156
	.byte	3,2,1,4,3,5,27,9
	.half	.L113-.L157
	.byte	3,45,1,5,45,9
	.half	.L203-.L113
	.byte	1,5,68,9
	.half	.L204-.L203
	.byte	1,5,60,9
	.half	.L205-.L204
	.byte	1,5,42,9
	.half	.L206-.L205
	.byte	1,5,5,9
	.half	.L159-.L206
	.byte	1,5,32,9
	.half	.L16-.L159
	.byte	3,68,1,5,36,9
	.half	.L207-.L16
	.byte	1,5,21,9
	.half	.L208-.L207
	.byte	1,5,48,9
	.half	.L158-.L208
	.byte	1,5,5,9
	.half	.L209-.L158
	.byte	1,4,1,5,26,9
	.half	.L17-.L209
	.byte	3,16,1,5,99,9
	.half	.L19-.L17
	.byte	3,32,1,5,72,9
	.half	.L210-.L19
	.byte	1,5,28,9
	.half	.L211-.L210
	.byte	3,122,1,5,15,9
	.half	.L212-.L211
	.byte	1,5,95,7,9
	.half	.L213-.L212
	.byte	3,7,1,5,104,9
	.half	.L214-.L213
	.byte	1,5,113,9
	.half	.L161-.L214
	.byte	1,5,106,9
	.half	.L20-.L161
	.byte	3,4,1,5,9,9
	.half	.L21-.L20
	.byte	3,23,1,5,42,7,9
	.half	.L115-.L21
	.byte	3,11,1,5,32,9
	.half	.L167-.L115
	.byte	3,15,1,5,17,9
	.half	.L215-.L167
	.byte	1,4,2,5,12,7,9
	.half	.L118-.L215
	.byte	3,240,126,1,4,3,5,27,9
	.half	.L127-.L118
	.byte	3,230,0,1,5,45,9
	.half	.L216-.L127
	.byte	1,5,68,9
	.half	.L217-.L216
	.byte	1,5,60,9
	.half	.L218-.L217
	.byte	1,5,42,9
	.half	.L219-.L218
	.byte	1,5,5,9
	.half	.L220-.L219
	.byte	1,4,2,5,17,9
	.half	.L24-.L220
	.byte	3,156,127,1,5,10,9
	.half	.L221-.L24
	.byte	3,2,1,9
	.half	.L222-.L221
	.byte	3,5,1,9
	.half	.L223-.L222
	.byte	3,4,1,5,23,9
	.half	.L224-.L223
	.byte	3,120,1,5,10,9
	.half	.L225-.L224
	.byte	3,24,1,5,9,9
	.half	.L28-.L225
	.byte	3,105,1,5,78,9
	.half	.L162-.L28
	.byte	1,5,9,9
	.half	.L226-.L162
	.byte	3,1,1,9
	.half	.L26-.L226
	.byte	3,3,1,5,79,9
	.half	.L169-.L26
	.byte	1,5,9,9
	.half	.L227-.L169
	.byte	3,1,1,9
	.half	.L27-.L227
	.byte	3,9,1,5,79,9
	.half	.L170-.L27
	.byte	1,5,9,9
	.half	.L228-.L170
	.byte	3,1,1,5,27,9
	.half	.L29-.L228
	.byte	3,9,1,5,60,9
	.half	.L229-.L29
	.byte	3,1,1,5,9,9
	.half	.L166-.L229
	.byte	3,1,1,9
	.half	.L30-.L166
	.byte	3,6,1,4,1,5,87,9
	.half	.L31-.L30
	.byte	3,237,0,1,5,36,9
	.half	.L23-.L31
	.byte	3,5,1,5,46,9
	.half	.L230-.L23
	.byte	3,1,1,5,75,9
	.half	.L231-.L230
	.byte	1,5,85,9
	.half	.L172-.L231
	.byte	1,5,59,9
	.half	.L232-.L172
	.byte	1,5,94,9
	.half	.L233-.L232
	.byte	1,5,5,9
	.half	.L22-.L233
	.byte	3,39,1,4,3,5,14,9
	.half	.L15-.L22
	.byte	3,108,1,5,26,9
	.half	.L175-.L15
	.byte	1,5,21,9
	.half	.L38-.L175
	.byte	1,5,15,9
	.half	.L39-.L38
	.byte	3,2,1,5,33,9
	.half	.L234-.L39
	.byte	1,5,37,9
	.half	.L235-.L234
	.byte	1,5,31,9
	.half	.L236-.L235
	.byte	1,5,21,9
	.half	.L237-.L236
	.byte	1,5,66,9
	.half	.L238-.L237
	.byte	1,5,48,9
	.half	.L176-.L238
	.byte	1,5,11,9
	.half	.L239-.L176
	.byte	1,4,1,5,22,9
	.half	.L129-.L239
	.byte	3,201,125,1,5,20,9
	.half	.L240-.L129
	.byte	3,1,1,5,101,9
	.half	.L241-.L240
	.byte	3,158,127,1,5,89,9
	.half	.L2-.L241
	.byte	1,5,1,7,9
	.half	.L242-.L2
	.byte	3,229,0,1,7,9
	.half	.L50-.L242
	.byte	0,1,1
.L183:
	.sdecl	'.debug_ranges',debug,cluster('Com_Prv_ProcessSignal')
	.sect	'.debug_ranges'
.L49:
	.word	-1,.L41,0,.L50-.L41,0,0
.L88:
	.word	-1,.L41,.L89-.L41,.L90-.L41,.L91-.L41,.L12-.L41,0,0
	.sdecl	'.debug_loc',debug,cluster('Com_Prv_ProcessSignal')
	.sect	'.debug_loc'
.L79:
	.word	0,0
.L85:
	.word	0,0
.L133:
	.word	0,0
.L77:
	.word	0,0
.L40:
	.word	-1,.L41,0,.L138-.L41
	.half	2
	.byte	138,0
	.word	.L138-.L41,.L51-.L41
	.half	2
	.byte	138,8
	.word	.L51-.L41,.L51-.L41
	.half	2
	.byte	138,0
	.word	0,0
.L69:
	.word	-1,.L41,.L146-.L41,.L147-.L41
	.half	1
	.byte	95
	.word	0,0
.L109:
	.word	-1,.L41,.L157-.L41,.L158-.L41
	.half	1
	.byte	95
	.word	0,0
.L83:
	.word	0,0
.L75:
	.word	0,0
.L131:
	.word	0,0
.L63:
	.word	-1,.L41,.L142-.L41,.L6-.L41
	.half	1
	.byte	89
	.word	.L7-.L41,.L18-.L41
	.half	1
	.byte	89
	.word	.L19-.L41,.L38-.L41
	.half	1
	.byte	89
	.word	.L39-.L41,.L51-.L41
	.half	1
	.byte	89
	.word	0,0
.L55:
	.word	-1,.L41,0,.L3-.L41
	.half	1
	.byte	100
	.word	.L139-.L41,.L6-.L41
	.half	1
	.byte	108
	.word	.L7-.L41,.L18-.L41
	.half	1
	.byte	108
	.word	.L19-.L41,.L38-.L41
	.half	1
	.byte	108
	.word	.L39-.L41,.L51-.L41
	.half	1
	.byte	108
	.word	0,0
.L98:
	.word	0,0
.L66:
	.word	-1,.L41,.L67-.L41,.L6-.L41
	.half	1
	.byte	83
	.word	.L7-.L41,.L18-.L41
	.half	1
	.byte	83
	.word	.L19-.L41,.L161-.L41
	.half	1
	.byte	83
	.word	.L20-.L41,.L21-.L41
	.half	1
	.byte	83
	.word	.L174-.L41,.L38-.L41
	.half	1
	.byte	83
	.word	.L39-.L41,.L2-.L41
	.half	1
	.byte	83
	.word	0,0
.L57:
	.word	-1,.L41,.L140-.L41,.L141-.L41
	.half	1
	.byte	111
	.word	0,0
.L102:
	.word	-1,.L41,.L155-.L41,.L18-.L41
	.half	1
	.byte	98
	.word	.L19-.L41,.L161-.L41
	.half	1
	.byte	98
	.word	.L20-.L41,.L21-.L41
	.half	1
	.byte	98
	.word	0,0
.L124:
	.word	0,0
.L122:
	.word	0,0
.L53:
	.word	-1,.L41,0,.L3-.L41
	.half	1
	.byte	84
	.word	0,0
.L107:
	.word	-1,.L41,.L153-.L41,.L154-.L41
	.half	1
	.byte	95
	.word	0,0
.L59:
	.word	-1,.L41,.L145-.L41,.L6-.L41
	.half	1
	.byte	110
	.word	.L7-.L41,.L18-.L41
	.half	1
	.byte	110
	.word	.L19-.L41,.L38-.L41
	.half	1
	.byte	110
	.word	.L39-.L41,.L51-.L41
	.half	1
	.byte	110
	.word	0,0
.L120:
	.word	0,0
.L103:
	.word	-1,.L41,.L152-.L41,.L18-.L41
	.half	1
	.byte	111
	.word	.L19-.L41,.L162-.L41
	.half	1
	.byte	111
	.word	.L26-.L41,.L169-.L41
	.half	1
	.byte	111
	.word	.L27-.L41,.L170-.L41
	.half	1
	.byte	111
	.word	.L29-.L41,.L31-.L41
	.half	1
	.byte	111
	.word	.L23-.L41,.L22-.L41
	.half	1
	.byte	111
	.word	0,0
.L106:
	.word	-1,.L41,.L161-.L41,.L20-.L41
	.half	1
	.byte	82
	.word	.L21-.L41,.L166-.L41
	.half	1
	.byte	82
	.word	.L171-.L41,.L166-.L41
	.half	1
	.byte	84
	.word	.L30-.L41,.L31-.L41
	.half	1
	.byte	82
	.word	.L23-.L41,.L22-.L41
	.half	1
	.byte	82
	.word	0,0
.L61:
	.word	-1,.L41,.L144-.L41,.L6-.L41
	.half	1
	.byte	109
	.word	.L7-.L41,.L18-.L41
	.half	1
	.byte	109
	.word	.L19-.L41,.L38-.L41
	.half	1
	.byte	109
	.word	.L39-.L41,.L51-.L41
	.half	1
	.byte	109
	.word	0,0
.L104:
	.word	0,0
.L116:
	.word	-1,.L41,.L167-.L41,.L168-.L41
	.half	1
	.byte	95
	.word	.L23-.L41,.L172-.L41
	.half	1
	.byte	95
	.word	0,0
.L71:
	.word	-1,.L41,.L148-.L41,.L6-.L41
	.half	1
	.byte	81
	.word	.L7-.L41,.L113-.L41
	.half	1
	.byte	81
	.word	0,0
.L111:
	.word	-1,.L41,.L160-.L41,.L18-.L41
	.half	1
	.byte	84
	.word	.L19-.L41,.L161-.L41
	.half	1
	.byte	84
	.word	.L20-.L41,.L164-.L41
	.half	1
	.byte	84
	.word	0,0
.L87:
	.word	-1,.L41,.L150-.L41,.L11-.L41
	.half	1
	.byte	95
	.word	.L12-.L41,.L8-.L41
	.half	1
	.byte	95
	.word	.L13-.L41,.L151-.L41
	.half	1
	.byte	95
	.word	0,0
.L70:
	.word	0,0
.L110:
	.word	-1,.L41,.L159-.L41,.L18-.L41
	.half	1
	.byte	92
	.word	.L19-.L41,.L15-.L41
	.half	1
	.byte	92
	.word	0,0
.L96:
	.word	0,0
.L68:
	.word	-1,.L41,.L89-.L41,.L18-.L41
	.half	1
	.byte	90
	.word	.L19-.L41,.L38-.L41
	.half	1
	.byte	90
	.word	.L163-.L41,.L161-.L41
	.half	1
	.byte	86
	.word	.L165-.L41,.L21-.L41
	.half	1
	.byte	85
	.word	.L173-.L41,.L22-.L41
	.half	1
	.byte	84
	.word	.L39-.L41,.L2-.L41
	.half	1
	.byte	90
	.word	0,0
.L100:
	.word	0,0
.L126:
	.word	0,0
.L135:
	.word	0,0
.L112:
	.word	0,0
.L92:
	.word	-1,.L41,.L149-.L41,.L150-.L41
	.half	1
	.byte	95
	.word	.L11-.L41,.L12-.L41
	.half	1
	.byte	95
	.word	0,0
.L64:
	.word	-1,.L41,.L143-.L41,.L6-.L41
	.half	1
	.byte	88
	.word	.L7-.L41,.L18-.L41
	.half	1
	.byte	88
	.word	.L19-.L41,.L38-.L41
	.half	1
	.byte	88
	.word	.L39-.L41,.L51-.L41
	.half	1
	.byte	88
	.word	0,0
.L108:
	.word	-1,.L41,.L156-.L41,.L18-.L41
	.half	1
	.byte	91
	.word	.L19-.L41,.L15-.L41
	.half	1
	.byte	91
	.word	0,0
.L137:
	.word	-1,.L41,.L175-.L41,.L38-.L41
	.half	1
	.byte	95
	.word	.L39-.L41,.L176-.L41
	.half	1
	.byte	95
	.word	0,0
	.sdecl	'.debug_frame',debug
	.sect	'.debug_frame'
.L243:
	.word	48
	.word	-1
	.byte	3,0,2,1,27,12,26,0,8,27,8,26,8,28,8,29,8,30,8,31,8,34,8,35,8,32,8,33,8,16,8,17,8,24,8,25,8,36,8,37,8,38
	.byte	8,39
	.sdecl	'.debug_frame',debug,cluster('Com_Prv_ProcessSignal')
	.sect	'.debug_frame'
	.word	36
	.word	.L243,.L41,.L51-.L41
	.byte	4
	.word	(.L138-.L41)/2
	.byte	19,8,22,26,3,19,138,8,4
	.word	(.L51-.L138)/2
	.byte	19,0,8,26,0,0

; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   528  }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   529  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   530  /***************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   531   Function name    : Com_Prv_ValidateRxSignal
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   532   Syntax           : boolean Com_Prv_ValidateRxSignal(Com_SignalIdType SignalId, Com_SigMaxType * RxNewValPtr)
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   533   Description      : Internal function used for validating Rx signal
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   534   Parameter        : SignalId    -> Id of the Signal
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   535                    : RxNewValPtr -> Pointer to New Signal value
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   536   Return value     : true  - Copy new signal value into signal buffer
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   537                      false - Do not copy new signal value into signal buffer
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   538   ***************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   539  #if defined(COM_RxSigInvalid) || defined (COM_RxFilters)
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   540  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   541  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_ValidateRxSignal(
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   542                                                  VAR(Com_SignalIdType, AUTOMATIC)                SignalId,
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   543                                                  P2VAR(Com_SigMaxType, AUTOMATIC, COM_APPL_DATA) RxNewValPtr
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   544                                                              )
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   545  {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   546      Com_RxSigConstPtrType   RxSigConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   547      Com_RxSigRamPtrType     RxSigRamPtr;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   548      VAR(uint8, AUTOMATIC)   ConstByteValue_u8;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   549      VAR(boolean, AUTOMATIC) isValidRxSig_b;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   550  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   551      RxSigConstPtr     = COM_GET_RXSIG_CONSTDATA(SignalId);
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   552      isValidRxSig_b    = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   553  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   554      RxSigRamPtr       = &COM_GET_RXSIGNALFLAG(SignalId);
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   555      ConstByteValue_u8 = RxSigConstPtr->rxSignalFields;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   556      /*Check For the Data Invalid Action and the value*/
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   557  #ifdef COM_RxSigInvalid
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   558      {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   559          VAR(uint8, AUTOMATIC) InvAction;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   560  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   561          InvAction = Com_GetValue(RXSIG,_INVACTION,ConstByteValue_u8);
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   562  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   563          /* For Float signals the invalid value is type casted to UNIT32 before comaparing */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   564          /* Check if the signal has invalid value configured and the newly received value is invalid value */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   565          /*if (RxSigConstPtr->rxSignalFields.DataInvalidType != (uint8)COM_NONE) &&
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   566           *   (RxSigConstPtr->DataInvalid_Val == *RxNewValPtr))*/
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   567          if ((InvAction != (uint8)COM_NONE) && ((Com_SigMaxType)RxSigConstPtr->DataInvalid_Val == *RxNewValPtr))
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   568          {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   569              if ( InvAction == (uint8)COM_REPLACE )
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   570              {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   571                  VAR(Com_SigMaxType,AUTOMATIC) RxSigVal;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   572  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   573                  /* Sign extension is performed on Init value during the below copy */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   574                  /* Read the initial value */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   575                  RxSigVal = (Com_SigMaxType)RxSigConstPtr->Init_Val;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   576  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   577  #ifdef COM_RXSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   578                  /* [SWS_Com_00723] The AUTOSAR COM module shall extend the init value (ComSignalInitValue) of a signal
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   579                   * to the size of its ComSignalType.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   580                   * Init_Val by default will be sign extended only for 32bits. Currently for COM_SINT64 signal types,
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   581                   * if the signal is of Negative, it is required to perform the sign extension till 64bits explicity. */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   582                  if ( Com_GetValue(GEN,_TYPE,RxSigConstPtr->General) == COM_SINT64 )
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   583                  {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   584                      RxSigVal = (Com_SigMaxType)((sint64)((sint32)RxSigVal));
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   585                  }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   586                  else
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   587                  {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   588                      /* do nothing for other signal types */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   589                  }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   590  #endif /* #ifdef COM_RXSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   591  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   592                  /* [SWS_Com_00681] The AUTOSAR COM module shall replace the signals value by its configured
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   593                   * ComSignalInitValue. After the replacement, the normal signal processing like filtering and
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   594                   * notification shall take place as if the ComSignalInitValue would have been received instead of
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   595                   * the ComSignalDataInvalidValue */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   596                  (*RxNewValPtr) = RxSigVal;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   597              }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   598              /* If invalid value is not configured ie if flag rxSignalFields.DataInvalidType is COM_NONE, then this
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   599               * check is performed at the beginning itself.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   600               * Hence the other value will be COM_NOTIFY.
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   601               */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   602  #ifdef COM_RxSigInvalidNotify
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   603              else
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   604              {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   605                  /* [SWS_Com_00680] The AUTOSAR COM module shall notify the RTE via the configured
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   606                   * ComInvalidNotification function. In this case, no other signal processing like filtering or the
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   607                   * normal signal indication shall take place. */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   608                  /* Signal is invalid,and the Invalid Action is configured
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   609                   * hence do not copy new value of signal into signal buffer */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   610                  isValidRxSig_b = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   611                  /* If this flag is set, do not call regular signal notification function */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   612                  /* Call Invalid Notification */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   613                  if(RxSigConstPtr->Sig_DataInvalid_Indication_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   614                  {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   615                      RxSigConstPtr->Sig_DataInvalid_Indication_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   616                  }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   617                  /* In this case, the signal buffer should contain the previous value of the signal,
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   618                   * leave the signal buffer unchanged
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   619                   */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   620              }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   621  #endif /* #ifdef COM_RxSigInvalidNotify */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   622          }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   623      }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   624  #endif /* #ifdef COM_RxSigInvalid */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   625  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   626  #ifdef COM_RxFilters
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   627      {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   628          VAR(uint8, AUTOMATIC) filterAlgo_u8;
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   629  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   630          filterAlgo_u8 = Com_GetValue(RXSIG,_FILTRALG,ConstByteValue_u8);
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   631  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   632          /* Proceed only if the signal filter is configured */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   633          if ( ( COM_FALSE != isValidRxSig_b ) && ( COM_NOTCONFIGURED != filterAlgo_u8 ) )
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   634          {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   635              /* The signal is valid, hence perform filtering */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   636              /* Get The Return value of the Filter which need not be returned if signal is invalid */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   637              /* The last parameter is Information from where the call to Com_Filter happens */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   638              /* NOTE on last parameter:
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   639              * 1.Currently the values for the parameter callContext_u8 are COM_TRUE/COM_FALSE
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   640              * 2.It is used only for filter ONE_EVERYN */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   641  #if defined (COM_F_MASKEDNEWDIFFERSOLD) && (defined (COM_RxIPduTimeout) || defined(COM_RxSigUpdateTimeout))
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   642              /* If the filter algo is COM_MASKED_NEW_DIFFERS_MASKED_OLD and the first valid reception of the signal after
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   643               * the reception deadline monitoring timeout should not be filtered out */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   644              if(!((Com_GetRamValue(RXSIG,_DMFILTERING,RxSigRamPtr->rxSigRAMFields) == COM_TRUE) &&
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   645                   (COM_MASKED_NEW_DIFFERS_MASKED_OLD == filterAlgo_u8)))
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   646              {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   647  #endif /* #if defined (COM_F_MASKEDNEWDIFFERSOLD) && (defined (COM_RxIPduTimeout) || defined(COM_RxSigUpdateTimeout)) */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   648                  isValidRxSig_b = Com_Filter((uint32)(*RxNewValPtr), filterAlgo_u8, RxSigConstPtr->Filter_Index,
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   649                                                                                                       COM_TRUE);
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   650  #if defined (COM_F_MASKEDNEWDIFFERSOLD) && (defined (COM_RxIPduTimeout) || defined(COM_RxSigUpdateTimeout))
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   651              }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   652              else
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   653              {
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   654                  /* Resetting this flag, for further reception of the signal, if Rx deadline monitoring timer elapses,
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   655                   * again this flag shall be set in Com_MainFunctionRx() */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   656                  Com_SetRamValue(RXSIG,_DMFILTERING,RxSigRamPtr->rxSigRAMFields,COM_FALSE);
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   657              }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   658  #endif /* #if defined (COM_F_MASKEDNEWDIFFERSOLD) && (defined (COM_RxIPduTimeout) || defined(COM_RxSigUpdateTimeout)) */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   659          }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   660      }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   661  #endif /* #ifdef COM_RxFilters */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   662  
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   663      return (isValidRxSig_b);
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   664  }
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   665  #endif /* #if defined(COM_RxSigInvalid) || defined (COM_RxFilters) */
; BSW\src\BSW\Gen\Com\src\Com_ProcessSignal.c	   666  

	; Module end
