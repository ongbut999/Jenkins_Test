	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 19053136 SN 09001910"
	.compiler_invocation	"ctc -f cc9984a -c99 --integer-enumeration -D__CPU__=tc27x -D__CPU_TC27X__ --core=tc1.6.x --eabi-compliant --fp-model=-float -D_TASKING_C_TRICORE_=1 -I.\\output\\inc -g2 -t4 --language=-comments,-gcc,+volatile,-strings --default-near-size=0 -O2ROPYGKLF-predict --default-a1-size=0 --default-a0-size=0 --source --switch=auto -o output\\objs\\BSW\\src\\BSW\\Gen\\Com\\Com_EnableRxDm.src BSW\\src\\BSW\\Gen\\Com\\src\\Com_EnableRxDm.c"
	.compiler_name		"ctc"
	;source	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_EnableRxDm.c'

	
$TC16X
	
	.sdecl	'.text.Com_EnableRxDm.Com_ReceptionDMControl',code,cluster('Com_ReceptionDMControl')
	.sect	'.text.Com_EnableRxDm.Com_ReceptionDMControl'
	.align	2
	
	.global	Com_ReceptionDMControl

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	     1  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	     2  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	     3  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	     4   * Preprocessor includes
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	     5   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	     6  #include "Com_Prv.h"
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	     7  #include "Com_Prv_Inl.h"
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	     8  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	     9  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    10   * Local Prototypes
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    11   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    12  #if defined (COM_RxIPduTimeout) || defined (COM_RxSigUpdateTimeout) || defined (COM_RxSigGrpUpdateTimeout)
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    13  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    14  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_ProcessRxDMIPduGroupVector(
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    15                                                              P2CONST(uint8, AUTOMATIC, COM_APPL_DATA) ipduGroupVector
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    16                                                                      );
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    17  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    18  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_EnableRxDeadlineMonitoring(VAR(Com_IpduIdType, AUTOMATIC) IpduId);
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    19  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    20  #endif
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    21  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    22  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    23   * Global functions (declared in header files)
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    24   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    25  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    26   Function name    : Com_ReceptionDMControl
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    27   Syntax           : void Com_ReceptionDMControl(Com_IpduGroupVector ipduGroupVector)
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    28   Description      : Service Enables deadline monitoring for the I-PDU groups within the given I-PDU group.
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    29   Parameter        : ipduGroupVector -> contains the requested deadline monitoring state (disabled = 0/ enabled = 1)
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    30                      for all I-PDU groups.
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    31   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    32  **********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    33  #define COM_START_SEC_CODE
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    34  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    35  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    36  FUNC(void, COM_CODE) Com_ReceptionDMControl(VAR(Com_IpduGroupVector, AUTOMATIC)  ipduGroupVector)
; Function Com_ReceptionDMControl
.L36:
Com_ReceptionDMControl:	.type	func
	mov.aa	a12,a4
.L110:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    37  {
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    38  #if defined (COM_RxIPduTimeout) || defined (COM_RxSigUpdateTimeout) || defined (COM_RxSigGrpUpdateTimeout)
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    39      /* Local pointer to hold the address of the Rx Ipdu status structure           */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    40      Com_RxIpduRamPtrType            RxIPduRamPtr;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    41      VAR(uint16_least, AUTOMATIC)    Index_u16;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    42  #endif
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    43      VAR(uint16,AUTOMATIC)           ByteNo_u16;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    44  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    45  #if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    46      if (Com_Prv_DETCheck_Ptr( (ipduGroupVector == NULL_PTR), COMServiceId_ReceptionDMControl ))
	mov.a	a15,#0
.L145:
	eq.a	d15,a12,a15
.L146:
	mov	d6,#6
.L56:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     1  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     2  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     3  #ifndef COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     4  #define COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     5  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     6  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     7   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     8   * Includes
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     9   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    10  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    11  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    12  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    13  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    17  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    18  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    19  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    20  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    21   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    22   * Type definitions
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    23   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    24  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    25  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    26  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    27  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    28   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    29   * Variables
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    30   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    31  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    32  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    33  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    34  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    35   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    36   * Extern declarations
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    37   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    38  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    39  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    40   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    41   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    42   * Inline function sets TMS data in to be accessesd via CurrentTxModePtr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    43   * after evaluating TMS mode for the IPdu
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    44   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    45  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    46  FUNC(void, COM_CODE) Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    47                                  Com_TxIpduRamPtrType                TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    48                                  Com_TxIpduConstPtrType              TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    49                                  VAR(uint16,AUTOMATIC)               TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    50                                  VAR(boolean,AUTOMATIC)              ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    51                                              );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    52  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    53  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    54   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    55   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    56   * Inline function to update Rx-GroupSignal application buffers
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    57   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    58  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    59  FUNC(void, COM_CODE) Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    60                                  Com_RxSigConstPtrType               RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    61                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    62                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    63                                               );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    64  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    65  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    66   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    67   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    68   * Inline function to update Rx-GroupSignal secondary buffers
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    69   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    70  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    71  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    72  FUNC(void, COM_CODE) Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    73                                  Com_RxGrpSigConstPtrType            RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    74                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    75                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    76                                                          );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    77  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    78  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    79  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    80   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    81   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    82   * Inline function to initialize signal intial value into the provided IPdu buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    83   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    84  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    85  FUNC(void, COM_CODE) Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    86                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    87                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    88                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    89                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    90                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    91                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    92                                                              );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    93  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    94  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    95   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    96   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    97   * Inline function to initialize Rx-signal group with initial values
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    98   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    99  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   100  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   101  FUNC(void, COM_CODE) Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   102                                  Com_RxSigGrpConstPtrType            RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   103                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   104                                                  );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   105  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   106  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   107  #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   108  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxNotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   109  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxErrNotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   110  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxTONotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   111  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallRxTONotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   112  #endif /* #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   113  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   114  /* Inline function to check for the RxIPdu and TxIpdu status*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   115  LOCAL_INLINE boolean Com_CheckRxIPduStatus(PduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   116  LOCAL_INLINE boolean Com_CheckTxIPduStatus(PduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   117  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   118  #if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   119  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   120  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Void(uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   121  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   122  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Ptr(boolean isInValidPtr, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   123  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Param_Ptr(boolean isInValidParam, boolean isInValidPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   124                                                                  uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   125  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Ptr_Only(boolean isInValidPtr, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   126  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Param_Only(boolean isInValidParam, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   127  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   128  #endif /*  #if (COM_CONFIGURATION_USE_DET == STD_ON) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   129  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   130  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   131  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   132  LOCAL_INLINE FUNC(void, COM_CODE) Com_CopyTxGroupSignalData( Com_SignalIdType    GrpSignalId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   133                                                               Com_SigMaxType      TxGrpSig_NewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   134                                                               Com_MainFuncType    TxMainFuncId );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   135  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   136  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   137  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   138   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   139   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   140   * Inline function to handle gateway and non-gateway use-case for tx-signal/signalGroup
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   141   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   142  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_ProceedToSendIpdu(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   143                                                  VAR(Com_IpduIdType, AUTOMATIC)          ComTxPduId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   144                                                  VAR(Com_SendIpduInfo, AUTOMATIC)        sendIpduFlag_u16
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   145                                                             );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   146  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   147  #ifdef COM_TxFilters
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   148  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_CheckModeChange(VAR(Com_IpduIdType, AUTOMATIC) TxIpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   149  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   150  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   151  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   152  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   153   * Inline Function Definition
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   154   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   155  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   156  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   157   Function name    : Com_SetCurrentTxModePtr [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   158   Syntax           : void Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   159                                  Com_TxIpduRamPtrType    TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   160                                  Com_TxIpduConstPtrType  TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   161                                  uint16                  TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   162                                  boolean                 ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   163                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   164   Description      : Inline function sets TMS data in to be accessesd via CurrentTxModePtr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   165                      after evaluating TMS mode for the IPdu
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   166  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   167                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   168                       * Mode                  |    Configuration details                              | Value|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   169                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   170                       * COM_MODE_VALID        |    Both the TRUE and FALSE modes are configured.      |    00|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   171                       * COM_TRUEMODE_VALID    |    Only TRUE mode is configured                       |    01|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   172                       * COM_FALSEMODE_VALID   |    Only FALSE mode is configured                      |    10|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   173                       * COM_MODE_INVALID      |    Both the TRUE and FALSE mode are not configured    |    11|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   174                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   175                      This INLINE function checks the TMS generated values against the requested mode and performs action
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   176                      |-------------|--------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   177                      |ModeRequested|Configured Mode values   |         Description                                           :      Action to be taken                |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   178                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   179                      |    0       |      0        |      0   |  FALSE mode is requested and IPdu TMS is COM_MODE_VALID         : Increment to the false mode data     |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   180                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   181                      |    0       |      0        |      1   |  FALSE mode is requested and IPdu TMS is COM_TRUEMODE_VALID     : Point to NONE mode data              |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   182                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   183                      |    0       |      1        |      0   |  FALSE mode is requested and IPdu TMS is COM_FALSEMODE_VALID     : Do nothing                          |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   184                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   185                      |    0       |      1        |      1   |  FALSE mode is requested and IPdu TMS is COM_MODE_INVALID     : Do nothing                             |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   186                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   187                      |    1       |      0        |      0   |  TRUE mode is requested and IPdu TMS is COM_MODE_VALID         : Do nothing                            |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   188                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   189                      |    1       |      0        |      1   |  TRUE mode is requested and IPdu TMS is COM_TRUEMODE_VALID     : Do nothing                            |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   190                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   191                      |    1       |      1        |      0   |  TRUE mode is requested and IPdu TMS is COM_FALSEMODE_VALID     : Point to NONE mode data              |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   192                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   193                      |    1       |      1        |      1   |  TRUE mode is requested and IPdu TMS is COM_MODE_INVALID         : Do nothing                          |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   194                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   195  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   196                      where 0 in column 1 stands for FALSE mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   197                      and   1 in column 1 stands for TRUE mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   198  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   199   Parameter        : TxIpduRamPtr    - pointer to Txipdu ram data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   200                    : TxIPduConstPtr  - pointer to Txipdu Rom data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   201                    : TMSStatus       - pointer to transmission mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   202                    : ModeRequested   - mode requested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   203   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   204   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   205  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   206  FUNC(void, COM_CODE) Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   207                                  Com_TxIpduRamPtrType                TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   208                                  Com_TxIpduConstPtrType              TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   209                                  VAR(uint16,AUTOMATIC)               TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   210                                  VAR(boolean,AUTOMATIC)              ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   211                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   212  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   213      /* Get the latest TM pointer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   214      TxIpduRamPtr->CurrentTxModePtr = TxIPduConstPtr->Com_TMConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   215  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   216      if(ModeRequested == COM_FALSE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   217      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   218          if((TMSStatus) == COM_TRUEMODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   219          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   220              /*If yes,load NONE mode data */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   221              TxIpduRamPtr->CurrentTxModePtr = &Com_NONE_TransModeInfo ;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   222          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   223          if((TMSStatus) == COM_MODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   224          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   225              /*Increment to FALSE mode data, if the FALSE mode is configured */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   226              TxIpduRamPtr->CurrentTxModePtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   227          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   228      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   229      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   230      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   231          if((TMSStatus) == COM_FALSEMODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   232          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   233              TxIpduRamPtr->CurrentTxModePtr = &Com_NONE_TransModeInfo ;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   234          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   235      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   236  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   237  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   238  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   239   Function name    : Com_UpdateRxGroupSignalSecondBuffer [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   240   Syntax           : void Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   241                                  Com_RxGrpSigConstPtrType    RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   242                                  Com_SigMaxType              RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   243                                  Com_MainFuncType            RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   244                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   245   Description      : Inline function copy Group signal value into the Group signal Second buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   246   Parameter        : RxGrpSigConstPtr - pointer to RxGroupSignal configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   247                    : RxNewVal         - latest RxGroupSignal data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   248                    : RxMainFuncId     - Internally generated Rx-MainFunction-Id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   249   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   250   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   251  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   252  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   253  FUNC(void, COM_CODE) Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   254                                  Com_RxGrpSigConstPtrType            RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   255                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   256                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   257                                                          )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   258  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   259      VAR(uint8,AUTOMATIC)    Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   260  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   261      Type = Com_GetValue(RXGRPSIG,_TYPE,RxGrpSigConstPtr->rxGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   262  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   263      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   264      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   265      case 0x00u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   266          /* UINT08 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   267          COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint8)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   268          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   269  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   270      case 0x01u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   271          /* UINT16 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   272          COM_GET_SECRXGRPSIGTYPEU16_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint16)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   273          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   274  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   275      case 0x02u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   276          /* UINT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   277          /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   278      case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   279          /* FLOAT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   280          /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   281          COM_GET_SECRXGRPSIGTYPEU32_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint32)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   282          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   283  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   284  #ifdef COM_RXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   285      case 0x08u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   286          /* UINT64/SINT64 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   287          COM_GET_SECRXGRPSIGTYPEU64_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   288          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   289  #endif /* #ifdef COM_RXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   290  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   291      case 0x03u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   292          /*Boolean Signal*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   293          COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint8)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   294          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   295  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   296      case 0x04u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   297          /* UINT8_N signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   298          Com_ByteCopyInit(&COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index),
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   299                           (uint32)RxNewVal,RxGrpSigConstPtr->BitSize);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   300          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   301      default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   302          /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   303           * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are allowed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   304           * to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   305           */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   306          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   307  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   308      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   309  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   310  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   311  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   312  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   313   Function name    : Com_UpdateRxSignalBuffer [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   314   Syntax           : void Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   315                                  Com_RxSigConstPtrType   RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   316                                  Com_SigMaxType          RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   317                                  Com_MainFuncType        RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   318                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   319   Description      : Inline function to copy signal value into the signal buffer and
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   320                      is used when signal value as a variable is being passed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   321   Parameter        : RxSigConstPtr - pointer to RxSignal configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   322                    : RxNewVal_Sig  - latest RxSignal data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   323                    : RxMainFuncId  - Internally generated Rx-MainFunction-Id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   324   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   325   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   326  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   327  FUNC(void, COM_CODE) Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   328                                  Com_RxSigConstPtrType               RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   329                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   330                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   331                                               )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   332  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   333      VAR(uint8,AUTOMATIC)    Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   334  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   335      Type = Com_GetValue(GEN,_TYPE,RxSigConstPtr->General);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   336  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   337      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   338      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   339      case 0x00u:     /* COM_UINT8 & COM_SINT8 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   340      case (COM_BOOLEAN >> 1):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   341          COM_GET_SIGTYPEUINT8_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint8)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   342          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   343  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   344      case 0x01u:     /* COM_UINT16 & COM_SINT16 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   345          COM_GET_SIGTYPEUINT16_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint16)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   346          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   347  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   348      case 0x02u:     /* COM_UINT32 & COM_SINT32 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   349  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   350          /* COM_FLOAT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   351  #ifdef COM_FLOAT32SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   352      case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   353  #endif /* #ifdef COM_FLOAT32SUPP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   354  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   355          COM_GET_SIGTYPEUINT32_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint32)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   356          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   357  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   358  #ifdef COM_RXSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   359      case 0x08u:     /* COM_UINT64 & COM_SINT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   360          COM_GET_SIGTYPEUINT64_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   361          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   362  #endif /* #if defined(COM_RXSIG_INT64) && defined(COM_TXSIG_INT64) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   363  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   364      case 0x04u:     /* COM_UINT8_N */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   365          Com_ByteCopyInit(&COM_GET_SIGTYPEUINT8_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index),
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   366                           (uint32)RxNewVal_Sig,RxSigConstPtr->BitSize);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   367          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   368      default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   369          /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   370           * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are allowed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   371           * to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   372           */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   373          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   374      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   375  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   376  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   377  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   378   Function name    : Com_InitializePduBuffWithSignalInitValue [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   379   Syntax           : void Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   380                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   381                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   382                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   383                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   384                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   385                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   386                                                                   )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   387   Description      : Inline function to call required interface to pack signal data into Ipdu buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   388   Parameter        : BuffPtr     - pointer to (SignalGroup)IPdu Buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   389                    : SigInitVal  - (Group)Signal InitValue
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   390                    : SigBitPos   - (Group)Signal Bit Position
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   391                    : SigBitSize  - (Group)Signal Bit Size
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   392                    : SigType     - (Group)Signal Type
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   393                    : SigEndianess- (Group)Signal Endianness
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   394   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   395   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   396  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   397  FUNC(void, COM_CODE) Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   398                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   399                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   400                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   401                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   402                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   403                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   404                                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   405  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   406      if ( SigType != (uint8)COM_UINT8_N )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   407      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   408  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   409  #if (defined(COM_TXSIG_FLOAT64SUPP) || defined(COM_TXGRPSIG_FLOAT64SUPP) ||\ 
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   410      (defined(COM_RX_SIGNALGROUP_ARRAY) && defined(COM_RXGRPSIG_FLOAT64SUPP)))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   411          if ( SigType == COM_FLOAT64 )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   412          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   413              /* Convert the float value into 32 bit stream and then pack the value */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   414              /* Com_PackFloatSignal(TxSigConstPtr->General.Endianess,TxSigConstPtr->Bit_Pos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   415                                     Com_getfloat64InitValue(SigNewVal), TxIPduConstPtr->BuffPtr); */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   416              Com_PackFloatSignal( SigEndianess, SigBitPos, Com_getfloat64InitValue(SigInitVal), BuffPtr );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   417          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   418          else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   419  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   420  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   421          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   422              /* Pack the signal with Initial Value */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   423              /* Com_PackSignal(TxSigConstPtr->General.Endianess,TxSigConstPtr->Bit_Pos,TxSigConstPtr->BitSize,SigNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   424               *                TxIPduConstPtr->BuffPtr);*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   425              Com_PackSignal( SigEndianess, SigBitPos, SigBitSize, SigInitVal, BuffPtr );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   426          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   427      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   428      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   429      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   430          PduLengthType ByteOffset_uo;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   431          /* Find the starting byte position(ByteNo_uo) of Signal in the IPDU buffer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   432          ByteOffset_uo = ( PduLengthType )( SigBitPos >> 3 );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   433  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   434          /* Now copy the Signal into the IPDU buffer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   435          Com_ByteCopyInit( (BuffPtr + ByteOffset_uo), (uint32)SigInitVal, SigBitSize );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   436      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   437  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   438  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   439  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   440   Function name    : Com_Prv_SigGrpReplaceToInit
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   441   Syntax           : void Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   442                                          Com_RxSigGrpConstPtrType  RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   443                                          Com_MainFuncType          RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   444                                                      )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   445   Description      : If the SigGrp is enabled with ArrayAccess, RxSigGrpBuffer will be packed with
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   446                      GroupSignal Init Values OR else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   447                      GroupSignals Shadow buffers will be replaced with its Init Values
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   448   Parameter        : RxSigGrpConstPtr - pointer to RxSignalGroup configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   449                    : RxMainFuncId     - Internally generated RxMainFunction-ID
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   450   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   451   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   452  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   453  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   454                                                  Com_RxSigGrpConstPtrType        RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   455                                                  VAR(Com_MainFuncType,AUTOMATIC) RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   456                                                               )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   457  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   458      Com_RxGrpSigConstPtrType      RxGrpSigConstPtr;      /* Local pointer to Rx GroupSignal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   459  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   460      Com_RxSigGrpArrayConstPtrType RxSigGrpArrayConstPtr; /* Local pointer to Rx SignalGroup Array configuration  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   461      uint8                       * RxSigGrpArrayBufRamPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   462      PduLengthType                 SigGrpBitOffset;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   463  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   464      VAR(uint16_least, AUTOMATIC)  index_ui;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   465      VAR(Com_SigMaxType, AUTOMATIC) SigValue;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   466  # if (defined(COM_RX_SIGNALGROUP_ARRAY) || defined(COM_RXGRPSIG_FLOAT64SUPP) || defined(COM_RXGRPSIG_INT64))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   467      VAR(uint8, AUTOMATIC)         SigType;  /* Signal Type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   468  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   469  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   470      boolean                       ConstIsSigGrpOfArrayType_b;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   471  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   472      ConstIsSigGrpOfArrayType_b = Com_GetValue(RXSIGGRP,_ARRAYACCESS,RxSigGrpConstPtr->rxSignalGrpFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   473  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   474      if ( ConstIsSigGrpOfArrayType_b )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   475      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   476          RxSigGrpArrayConstPtr  = COM_GET_RXSIGGRP_ARRAY_CONSTDATA( RxSigGrpConstPtr->SigGrpArray_Index );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   477  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   478          RxSigGrpArrayBufRamPtr = &COM_GET_RXSIGGRP_ARRAY_BUFF(RxMainFuncId, RxSigGrpArrayConstPtr->RxSigGrpBuf_Index );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   479  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   480          SigGrpBitOffset        = ( RxSigGrpArrayConstPtr->FirstByteNo * 8u );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   481  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   482          SchM_Enter_Com_RxSigGrpArrayBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   483      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   484      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   485  # endif /* # ifdef COM_RX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   486      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   487          SchM_Enter_Com_RxGrpSigSecBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   488      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   489  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   490      RxGrpSigConstPtr = COM_GET_RXGRPSIG_CONSTDATA( RxSigGrpConstPtr->FirstGrpSig_Index );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   491  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   492      for ( index_ui = (uint16_least)RxSigGrpConstPtr->No_Of_GrpSig; index_ui != (uint16_least)0; index_ui-- )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   493      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   494  # if (defined(COM_RX_SIGNALGROUP_ARRAY) || defined(COM_RXGRPSIG_FLOAT64SUPP) || defined(COM_RXGRPSIG_INT64))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   495          SigType = Com_GetValue(RXGRPSIG,_TYPE,RxGrpSigConstPtr->rxGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   496  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   497  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   498          SigValue = (Com_SigMaxType)RxGrpSigConstPtr->Init_Val;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   499  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   500  #ifdef COM_RXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   501          /* [SWS_Com_00723] The AUTOSAR COM module shall extend the init value (ComSignalInitValue) of a signal
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   502           * to the size of its ComSignalType.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   503           * Currently for COM_SINT64 signal type, ComSignalInitValue is supported for maximum 32bits.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   504           * If negative values are configured, by default these values will be sign extended only till 32bits.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   505           * so, for COM_SINT64, it is required to perform the sign extension till 64bits explicity. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   506          SigValue = (SigType == COM_SINT64) ? (Com_SigMaxType)((sint64)((sint32)SigValue)) : SigValue;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   507  #endif /* #ifdef COM_RXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   508  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   509  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   510          if ( ConstIsSigGrpOfArrayType_b )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   511          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   512              Com_BitpositionType RelativeSigBitPos; /* Relative BitPosition in RxSignalGroup Array */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   513  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   514              /* The Buffer into which Signal Values needs to be packed will be available with starting address
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   515               * of the Rx-SignalGroup Array Buffer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   516               * But we have GroupSignal: Bit_Pos, i.e., Signal's actual LSB in the IPdu Buffer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   517               * So, Rx-SignalGroup BitOffset(SigGrpBitOffset) is removed from each of the GroupSignal and
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   518               * is used as BitPosition to pack its value into the Rx-SignalGroup Array Buffer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   519              RelativeSigBitPos = RxGrpSigConstPtr->Bit_Pos - ( Com_BitpositionType )SigGrpBitOffset;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   520  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   521              Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   522                                                RxSigGrpArrayBufRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   523                                                SigValue,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   524                                                RelativeSigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   525                                                RxGrpSigConstPtr->BitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   526                                                SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   527                                                Com_GetValue(RXGRPSIG,_ENDIANESS,RxGrpSigConstPtr->rxGrpSigFields) );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   528          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   529          else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   530  # endif /* #ifdef COM_RX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   531          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   532  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   533  # ifdef COM_RXGRPSIG_FLOAT64SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   534              if(SigType == COM_FLOAT64)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   535              {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   536                  COM_GET_SECRXGRPSIGTYPEFLOAT64_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) =
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   537                                                                        Com_getfloat64InitValue(SigValue);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   538              }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   539              else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   540  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   541  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   542              {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   543                  Com_UpdateRxGroupSignalSecondBuffer(RxGrpSigConstPtr, SigValue, RxMainFuncId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   544              }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   545          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   546  # if defined(COM_RxFilters) && defined(COM_F_MASKEDNEWDIFFERSOLD)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   547          /* [SWS_Com_00603] The AUTOSAR COM module shall set the old_value of the filtering mechanisms
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   548           * for each signal to the ComSignalInitValue during start-up */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   549          if ( ( COM_INIT != Com_Uninit_Flag ) && ( COM_MASKED_NEW_DIFFERS_MASKED_OLD == RxGrpSigConstPtr->Filter_Algo ) )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   550          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   551              COM_GET_F_OLDVALUE(RxGrpSigConstPtr->Filter_Index) = (uint32)SigValue;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   552          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   553  # endif /* # if defined(COM_RxFilters) && defined(COM_F_MASKEDNEWDIFFERSOLD) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   554  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   555          RxGrpSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   556      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   557  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   558  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   559      if ( ConstIsSigGrpOfArrayType_b )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   560      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   561          SchM_Exit_Com_RxSigGrpArrayBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   562      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   563      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   564  # endif /* # ifdef COM_RX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   565      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   566          SchM_Exit_Com_RxGrpSigSecBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   567      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   568  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   569  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   570  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   571  #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   572  #ifdef COM_TxIPduNotification
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   573  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxNotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   574          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   575      Com_TxIpduConstPtrType TxIPduConstPtr;    /* Local pointer to Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   576      Com_TxSigConstPtrType TxSigConstPtr;    /* Local pointer to Tx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   577  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   578      Com_TxSigGrpConstPtrType TxSigGrpConstPtr; /* Local pointer to hold the address of Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   579  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   580      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   581  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   582      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   583      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   584      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   585  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   586      IpduId = COM_GET_TX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   587      TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   588      TxSigConstPtr = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   589  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   590      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(TxIPduConstPtr->FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   591  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   592  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   593      for(index_u8 = TxIPduConstPtr->TxSigId_Index; index_u8 < (TxIPduConstPtr->TxSigId_Index + TxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   594      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   595          if(TxSigConstPtr->Notification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   596          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   597              TxSigConstPtr->Notification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   598          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   599          TxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   600      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   601  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   602      for(index_u8 = TxIPduConstPtr->FirstTxSigGrp_Index; index_u8 < (TxIPduConstPtr->FirstTxSigGrp_Index + TxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   603      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   604          if(TxSigGrpConstPtr->Notification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   605          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   606              TxSigGrpConstPtr->Notification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   607          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   608          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   609      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   610  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   611  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   612          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   613  #endif /* #ifdef COM_TxIPduNotification */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   614  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   615  #ifdef COM_ERRORNOTIFICATION
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   616  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxErrNotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   617  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   618  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   619      Com_TxIpduConstPtrType TxIPduConstPtr;    /* Local pointer to Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   620      Com_TxSigConstPtrType TxSigConstPtr;    /* Local pointer to Tx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   621  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   622      Com_TxSigGrpConstPtrType TxSigGrpConstPtr; /* Local pointer to hold the address of Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   623  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   624      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   625  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   626      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   627      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   628      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   629  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   630      IpduId = COM_GET_TX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   631      TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   632      TxSigConstPtr = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   633  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   634      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(TxIPduConstPtr->FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   635  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   636  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   637      for(index_u8 = TxIPduConstPtr->TxSigId_Index; index_u8 < (TxIPduConstPtr->TxSigId_Index + TxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   638      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   639          if(TxSigConstPtr->NotificationError_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   640          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   641              TxSigConstPtr->NotificationError_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   642          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   643          TxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   644      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   645  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   646      for(index_u8 = TxIPduConstPtr->FirstTxSigGrp_Index; index_u8 < (TxIPduConstPtr->FirstTxSigGrp_Index + TxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   647      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   648          if(TxSigGrpConstPtr->NotificationError_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   649          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   650              TxSigGrpConstPtr->NotificationError_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   651          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   652          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   653      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   654  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   655  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   656  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   657  #endif /* #ifdef COM_ERRORNOTIFICATION */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   658  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   659  #ifdef COM_TxIPduTimeOutNotify
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   660  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxTONotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   661  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   662  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   663      Com_TxIpduConstPtrType TxIPduConstPtr;    /* Local pointer to Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   664      Com_TxSigConstPtrType TxSigConstPtr;    /* Local pointer to Tx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   665  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   666      Com_TxSigGrpConstPtrType TxSigGrpConstPtr; /* Local pointer to hold the address of Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   667  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   668      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   669  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   670      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   671      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   672      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   673  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   674      IpduId = COM_GET_TX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   675      TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   676      TxSigConstPtr = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   677  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   678      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(TxIPduConstPtr->FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   679  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   680  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   681      for(index_u8 = TxIPduConstPtr->TxSigId_Index; index_u8 < (TxIPduConstPtr->TxSigId_Index + TxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   682      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   683          if(TxSigConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   684          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   685              TxSigConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   686          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   687          TxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   688      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   689  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   690      for(index_u8 = TxIPduConstPtr->FirstTxSigGrp_Index; index_u8 < (TxIPduConstPtr->FirstTxSigGrp_Index + TxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   691      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   692          if(TxSigGrpConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   693          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   694              TxSigGrpConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   695          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   696          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   697      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   698  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   699  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   700  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   701  #endif /* #ifdef COM_TxIPduTimeOutNotify */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   702  #ifdef COM_RxIPduTimeoutNotify
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   703  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallRxTONotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   704  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   705  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   706      Com_RxIpduConstPtrType RxIPduConstPtr;    /* Local pointer to Rx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   707      Com_RxSigConstPtrType RxSigConstPtr;    /* Local pointer to Rx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   708  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   709      Com_RxSigGrpConstPtrType RxSigGrpConstPtr; /* Local pointer to hold the address of Rx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   710  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   711      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   712  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   713      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   714      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   715      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   716  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   717      IpduId = COM_GET_RX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   718      RxIPduConstPtr = COM_GET_RX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   719      RxSigConstPtr = COM_GET_RXSIG_CONSTDATA(RxIPduConstPtr->RxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   720  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   721      RxSigGrpConstPtr = COM_GET_RXSIGGRP_CONSTDATA(RxIPduConstPtr->FirstRxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   722  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   723  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   724      for(index_u8 = RxIPduConstPtr->RxSigId_Index; index_u8 < (RxIPduConstPtr->RxSigId_Index + RxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   725      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   726          if(RxSigConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   727          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   728              RxSigConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   729          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   730          RxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   731      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   732  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   733      for(index_u8 = RxIPduConstPtr->FirstRxSigGrp_Index; index_u8 < (RxIPduConstPtr->FirstRxSigGrp_Index + RxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   734      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   735          if(RxSigGrpConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   736          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   737              RxSigGrpConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   738          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   739          RxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   740      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   741  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   742  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   743  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   744  #endif /* #ifdef COM_RxIPduTimeoutNotify */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   745  #endif /* #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   746  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   747  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   748  LOCAL_INLINE FUNC(void, COM_CODE) Com_CopyTxGroupSignalData( Com_SignalIdType    GrpSignalId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   749                                                               Com_SigMaxType      TxGrpSig_NewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   750                                                               Com_MainFuncType    TxMainFuncId )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   751  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   752      Com_TxGrpSigConstPtrType                   TxGrpSigConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   753      VAR(Com_TxGrpSigBuffIndexType, AUTOMATIC)  GrpSigBuff_Index;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   754      VAR(uint8, AUTOMATIC)                      Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   755  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   756      TxGrpSigConstPtr = COM_GET_TXGRPSIG_CONSTDATA(GrpSignalId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   757      GrpSigBuff_Index = TxGrpSigConstPtr->TxGrpSigBuff_Index;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   758      Type = Com_GetValue(TXGRPSIG,_TYPE,TxGrpSigConstPtr->txGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   759  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   760      SchM_Enter_Com_TxGrpSigBuffer();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   761      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   762      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   763  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   764          case 0x00u: /* UINT8 and SINT8 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   765          case 0x03u: /* Boolean type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   766              COM_GET_TXGRPSIGTYPEU8_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint8)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   767              break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   768  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   769          /* UINT16 and SINT16 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   770          case 0x01u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   771              COM_GET_TXGRPSIGTYPEU16_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint16)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   772              break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   773  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   774          /* UINT32,SINT32 and FLOAT32 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   775          case 0x02u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   776          /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   777  #ifdef COM_FLOAT32SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   778          case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   779  #endif /* #ifdef COM_FLOAT32SUPP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   780          /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   781              COM_GET_TXGRPSIGTYPEU32_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint32)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   782              break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   783  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   784          /* UINT64 and SINT64 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   785  #ifdef COM_TXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   786          case 0x08u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   787              COM_GET_TXGRPSIGTYPEU64_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint64)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   788          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   789  #endif /* #ifdef COM_TXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   790  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   791          default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   792              /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   793               * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   794               * allowed to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   795               */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   796          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   797     }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   798      SchM_Exit_Com_TxGrpSigBuffer();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   799  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   800  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   801  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   802  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   803  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   804  #if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   805  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   806  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   807   Function name    : Com_Prv_DETCheck_Void
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   808   Syntax           : boolean Com_Prv_DETCheck_Void(uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   809   Description      : Inline function to check for module initialization
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   810   Parameter        : ApiId - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   811   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   812                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   813   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   814  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Void(uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   815  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   816      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   817      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   818  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   819      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   820      Status  = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   821  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   822      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   823      if (Com_Uninit_Flag == COM_UNINIT)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   824      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   825          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   826          COM_REPORT_ERROR_CHECK(ApiId, COM_E_UNINIT);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   827          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   828          Status = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   829      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   830      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   831      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   832          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   833      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   834  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   835      return Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   836  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   837  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   838  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   839   Function name    : Com_Prv_DETCheck_Param
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   840   Syntax           : boolean Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   841   Description      : Inline function to check for module initialization and valid parameter value.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   842   Parameter        : isInValidParam - calling service is called with invalid parameter value
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   843                      ApiId          - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   844   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   845                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   846   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   847  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   848  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   849      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   850      uint8   ErrorId;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   851      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   852  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   853      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   854      ErrorId = COM_DET_NO_ERROR;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   855      Status  = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   856  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   857      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   858      if (Com_Uninit_Flag == COM_UNINIT)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   859      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   860          ErrorId = COM_E_UNINIT;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   861      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   862      else if (isInValidParam)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   863      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   864          ErrorId = COM_E_PARAM;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   865      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   866      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   867      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   868          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   869      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   870  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   871      /* Check if ErrorId has Error Code */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   872      if (ErrorId != COM_DET_NO_ERROR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   873      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   874          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   875          COM_REPORT_ERROR_CHECK(ApiId, ErrorId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   876          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   877          Status = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   878      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   879      return Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   880  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   881  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   882  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   883   Function name    : Com_Prv_DETCheck_Ptr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   884   Syntax           : boolean Com_Prv_DETCheck_Ptr(boolean isInValidPtr, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   885   Description      : Inline function to check for module initialization and valid pointer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   886   Parameter        : isInValidPtr - calling service is called with invalid pointer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   887                      ApiId        - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   888   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   889                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   890   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   891  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Ptr(boolean isInValidPtr, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   892  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   893      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   894      uint8   ErrorId;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   895      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   896  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   897      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   898      ErrorId = COM_DET_NO_ERROR;
	mov	d7,#255
.L112:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   899      Status  = COM_TRUE;
	mov	d0,#1
.L113:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   900  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   901      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   902      if (Com_Uninit_Flag == COM_UNINIT)
	movh.a	a15,#@his(Com_Uninit_Flag)
	lea	a15,[a15]@los(Com_Uninit_Flag)
	ld.w	d1,[a15]
.L147:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   902      if (Com_Uninit_Flag == COM_UNINIT)      (inlined)
	jne	d1,#0,.L2
.L148:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   903      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   904          ErrorId = COM_E_UNINIT;
	mov	d7,#2
.L149:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   904          ErrorId = COM_E_UNINIT;      (inlined)
	j	.L3

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   902      if (Com_Uninit_Flag == COM_UNINIT)      (inlined)
.L2:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   906      else if (isInValidPtr)      (inlined)
	jeq	d15,#0,.L4
.L150:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   905      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   906      else if (isInValidPtr)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   907      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   908          ErrorId = COM_E_PARAM_POINTER;
	mov	d7,#3
.L151:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   908          ErrorId = COM_E_PARAM_POINTER;      (inlined)
	j	.L5

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   906      else if (isInValidPtr)      (inlined)
.L4:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   910      else      (inlined)
.L5:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   906      else if (isInValidPtr)      (inlined)
.L3:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   909      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   910      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   911      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   912          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   913      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   914  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   915      /* Check if ErrorId has Error Code */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   916      if (ErrorId != COM_DET_NO_ERROR)
	mov	d15,#255
.L152:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   916      if (ErrorId != COM_DET_NO_ERROR)      (inlined)
	jeq	d15,d7,.L6
.L153:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   917      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   918          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   919          COM_REPORT_ERROR_CHECK(ApiId, ErrorId);
	mov	d4,#50
	mov	d5,#0
	call	Det_ReportError
.L109:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   920          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   921          Status = COM_FALSE;
	mov	d0,#0

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   916      if (ErrorId != COM_DET_NO_ERROR)      (inlined)
.L6:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   923      return Status;      (inlined)
	j	.L7

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   924  }      (inlined)
.L7:
	jeq	d0,#0,.L8
.L57:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    47  #endif
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    48      {
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    49          /* START: Clear Unused BitFields
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    50          * If the Group vector is filled with non-zero in unconfigured bitfields,
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    51          * it might cause an exception in the software. */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    52          ByteNo_u16 = ( uint16 )( COM_GET_NUM_TOTAL_IPDU_GRP / 8u );
	mov	d15,#0
.L115:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    53          if ( ByteNo_u16 < COM_NUM_ARR_IPDUGRPVECT )
	jne	d15,#0,.L9
.L154:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    54          {
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    55              ipduGroupVector[ ByteNo_u16 ] &= ( ( uint8 )( 0xFF ) >> ( 8u - ( COM_GET_NUM_TOTAL_IPDU_GRP % 8u ) ) );
	mov.aa	a15,a12
.L155:
	add.a	a15,#0
	ld.bu	d0,[a15]
.L114:
	and	d0,d0,#3
	st.b	[a15],d0
.L156:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    56              ByteNo_u16++;
	add	d15,#1
.L157:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    57  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    58              while ( ByteNo_u16 < COM_NUM_ARR_IPDUGRPVECT )
	j	.L10
.L11:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    59              {
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    60                  ipduGroupVector[ ByteNo_u16 ] = ( uint8 )0;
	mov.aa	a15,a12
.L111:
	add.a	a15,#0
.L158:
	mov	d0,#0
.L159:
	st.b	[a15],d0
.L160:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    61                  ByteNo_u16++;
	add	d15,#1
.L10:
	jeq	d15,#0,.L11
.L9:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    62              }
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    63          }
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    64          /* END: Clear Unused BitFields */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    65  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    66  #if defined (COM_RxIPduTimeout) || defined (COM_RxSigUpdateTimeout) || defined (COM_RxSigGrpUpdateTimeout)
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    67  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    68          /* Extract ipduGroupVector and identify the IpduGroups with different states */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    69          Com_Prv_ProcessRxDMIPduGroupVector((P2CONST(uint8, AUTOMATIC, COM_APPL_DATA))(ipduGroupVector));
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    70  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    71          RxIPduRamPtr   = &COM_GET_RXPDURAM_S(0);
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    72  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    73          for (Index_u16 = 0; Index_u16 < COM_GET_NUM_RX_IPDU; Index_u16++)
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    74          {
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    75              if (COM_GET_IPDUCOUNTER_DM(Index_u16) >0 )
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    76              {
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    77                  /*If the state is changed from RESET to SET*/
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    78                  /*As the counters are already updated, no necessary actions are required the other way around */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    79                  /* if(RxIPduRamPtr->RxFlags.Pdu_DMStatus == 0)  */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    80                  if ((Com_GetRamValue(RXIPDU,_DMSTATUS,RxIPduRamPtr->RxFlags)) == COM_STOP)
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    81                  {
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    82                      Com_Prv_EnableRxDeadlineMonitoring((Com_IpduIdType)Index_u16);
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    83                      /* (RxIPduRamPtr->RxFlags.Pdu_DMStatus = COM_SET)  */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    84                      Com_SetRamValue(RXIPDU,_DMSTATUS,RxIPduRamPtr->RxFlags, COM_START);
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    85                  }
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    86              }
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    87              else
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    88              {
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    89                  /* if(RxIPduRamPtr->RxFlags.Pdu_DMStatus)  */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    90                  if (Com_GetRamValue(RXIPDU,_DMSTATUS,RxIPduRamPtr->RxFlags))
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    91                  {
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    92                      /*Interrupt is locked due to the updation of IPdu Group DM Status. */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    93                      /* (RxIPduRamPtr->RxFlags.Pdu_DMStatus = COM_RESET)  */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    94                      Com_SetRamValue(RXIPDU,_DMSTATUS,RxIPduRamPtr->RxFlags, COM_STOP);
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    95                  }
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    96              }
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    97              RxIPduRamPtr++;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    98          } /* End of Rx IPdu for loop */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	    99  #endif /* #if defined (COM_RxIPduTimeout) || defined (COM_RxSigUpdateTimeout) || defined (COM_RxSigGrpUpdateTimeout) */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   100      }
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   101  }
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   102  #define COM_STOP_SEC_CODE
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   103  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   104  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   105  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   106  #if defined (COM_RxIPduTimeout) || defined (COM_RxSigUpdateTimeout) || defined (COM_RxSigGrpUpdateTimeout)
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   107  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   108   Function name    : Com_Prv_ProcessRxDMIPduGroupVector
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   109   Syntax           : void Com_Prv_ProcessRxDMIPduGroupVector( const uint8 * ipduGroupVector )
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   110   Description      : Service to process IPduGroupVector and to modify the local IPduGroups states as requested
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   111                      by the application.
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   112   Parameter        : ipduGroupVector - I-PDU group vector containing the latest Rx-DM activation state
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   113                                        (stopped = 0/started = 1) for all I-PDU groups.
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   114   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   115   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   116  /* HIS METRIC LEVEL VIOLATION IN Com_Prv_ProcessRxDMIPduGroupVector:
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   117     Com_Prv_ProcessRxDMIPduGroupVector function contains "for" loops and simple "if" statements.
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   118     HIS metric compliance would decrease readability and maintainability */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   119  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_ProcessRxDMIPduGroupVector(
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   120                                              P2CONST(uint8, AUTOMATIC, COM_APPL_DATA) ipduGroupVector
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   121                                                                      )
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   122  {
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   123      /* Local pointer which holds the address of the array which stores the ipdu id */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   124      P2CONST(Com_IpduIdType, AUTOMATIC, COM_APPL_CONST)  IPduRefPtr;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   125      /* Local pointer to hold the address of Ipdu group structure                   */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   126      Com_IPduGrpConstPtrType                             IPduGrpConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   127      VAR(uint16_least,AUTOMATIC)                         Index_u16;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   128      VAR(uint16_least,AUTOMATIC)                         NoOfPdus_u16;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   129      VAR(Com_IpduGroupIdType, AUTOMATIC)                 IpduGrpId_u16; /* To store the Ipdu Group Id */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   130      VAR(uint8, AUTOMATIC)                               ByteVal_u8;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   131      VAR(uint8,AUTOMATIC)                                BitOffset_u8;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   132      VAR(uint8,AUTOMATIC)                                PduCounterVal;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   133  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   134      for (Index_u16 = 0; Index_u16 < COM_NUM_ARR_IPDUGRPVECT; Index_u16++)
	mov	d5,#0
.L116:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   134      for (Index_u16 = 0; Index_u16 < COM_NUM_ARR_IPDUGRPVECT; Index_u16++)      (inlined)
	j	.L12
.L13:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   135      {
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   136          if (Com_IpduGrpVector_DM[Index_u16] != ipduGroupVector[Index_u16] )
	mov.aa	a15,a12
.L117:
	add.a	a15,#0
	ld.bu	d0,[a15]
.L161:
	movh.a	a2,#@his(Com_IpduGrpVector_DM)
	lea	a2,[a2]@los(Com_IpduGrpVector_DM)
.L162:
	add.a	a2,#0
	ld.bu	d1,[a2]
.L163:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   136          if (Com_IpduGrpVector_DM[Index_u16] != ipduGroupVector[Index_u16] )      (inlined)
	jeq	d1,d0,.L14
.L118:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   137          {
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   138              /* Perform an XOR to find the Ipdu Groups which have changed the states */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   139              ByteVal_u8 = (uint8)((Com_IpduGrpVector_DM[Index_u16]) ^ (ipduGroupVector[Index_u16]));
	xor	d0,d1
.L164:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   140              BitOffset_u8 = 0u;
	mov	d1,#0

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   185              } while (ByteVal_u8 > 0u);      (inlined)
.L15:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   147                  if (COM_RESET != (ByteVal_u8 & 1u))      (inlined)
	jz.t	d0:0,.L16
.L165:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   141  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   142              /*If there are some Ipdu groups which have changed the status*/
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   143              do
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   144              {
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   145                  /*Check for the status of the changed Ipdu groups and perform actions accordingly*/
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   146                  /* Check if any of the IPdu Group is changed by performing right bit shift*/
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   147                  if (COM_RESET != (ByteVal_u8 & 1u))
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   148                  {
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   149                      /*Get the Ipdu group Id if the status is changed*/
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   150                      IpduGrpId_u16   = (Com_IpduGroupIdType)(8u * Index_u16)+ BitOffset_u8 ;
	sh	d2,d5,#3
.L120:
	add	d2,d1
.L166:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   151  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   152                      /* Convert external HandleId to internal HandleId
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   153                         IMP : ipduGroupVector will be set/reset based on the external ID.
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   154                         It is required to convert the ID only when accessing the tables
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   155                         For pre-compile , conversion is not required. Access Macro will return the same ID,
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   156                         which is passed to it */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   157  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   158                      IpduGrpId_u16   = COM_GET_IPDUGRP_ID(IpduGrpId_u16);
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   159  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   160                      /* Get the latest status of the IPdu group and store the any of the below value into PduCounterVal
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   161                       * 0x01u eq +1, to increment the IPDU_COUNTER
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   162                       * 0xFFu eq -1, to decrement the IPDU_COUNTER */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   163                      PduCounterVal   = ((((ipduGroupVector[Index_u16] >> BitOffset_u8) & 1u) != 0u) ? (0x1u) : (0xFFu));
	ld.bu	d3,[a15]
.L167:
	mov	d4,d1
.L121:
	rsub	d4,#0
.L119:
	sha	d3,d3,d4
.L168:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   163                      PduCounterVal   = ((((ipduGroupVector[Index_u16] >> BitOffset_u8) & 1u) != 0u) ? (0x1u) : (0xFFu));      (inlined)
	and	d15,d3,#1
.L169:
	mov	d3,#1
	sel	d3,d15,d3,#255
.L122:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   163                      PduCounterVal   = ((((ipduGroupVector[Index_u16] >> BitOffset_u8) & 1u) != 0u) ? (0x1u) : (0xFFu));      (inlined)
	j	.L18
.L17:
	mov	d3,#255

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   163                      PduCounterVal   = ((((ipduGroupVector[Index_u16] >> BitOffset_u8) & 1u) != 0u) ? (0x1u) : (0xFFu));      (inlined)
.L18:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   164  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   165                      IPduGrpConstPtr = COM_GET_IPDUGRP_CONSTDATA(IpduGrpId_u16);
	movh.a	a4,#@his(Com_Prv_xIpduGrpCfg_acst)
	lea	a4,[a4]@los(Com_Prv_xIpduGrpCfg_acst)
	addsc.a	a4,a4,d2,#2
.L123:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   166  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   167                      IPduRefPtr      = COM_GET_IPDUGRP_IPDUREF_CONSTDATA(IPduGrpConstPtr->FirstIpdu_Index);
	ld.hu	d15,[a4]0
	movh.a	a5,#@his(Com_Prv_xIPduGrp_IpduRefCfg_au8)
	lea	a5,[a5]@los(Com_Prv_xIPduGrp_IpduRefCfg_au8)
	addsc.a	a5,a5,d15,#0
.L124:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   168  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   169                      NoOfPdus_u16    = IPduGrpConstPtr->NoOfRxPdus;
	ld.hu	d15,[a4]2
.L125:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   171                      while (NoOfPdus_u16 > 0u)      (inlined)
	j	.L19
.L20:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   170  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   171                      while (NoOfPdus_u16 > 0u)
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   172                      {
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   173                          /*Check if the DM state of the Ipdu Group is changed and if it is an RX IPdu*/
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   174                           COM_GET_IPDUCOUNTER_DM(*IPduRefPtr) = (uint8)
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   175                          (COM_GET_IPDUCOUNTER_DM(*IPduRefPtr) + PduCounterVal);
	ld.bu	d2,[a5]
	movh.a	a4,#@his(Com_IpduCounter_DM)
	lea	a4,[a4]@los(Com_IpduCounter_DM)
	addsc.a	a4,a4,d2,#0
	ld.bu	d2,[a4]
.L170:
	add	d2,d3
.L171:
	st.b	[a4],d2
.L172:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   176  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   177                          IPduRefPtr++;
	add.a	a5,#1
.L173:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   178                          NoOfPdus_u16--;
	add	d15,#-1

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   171                      while (NoOfPdus_u16 > 0u)      (inlined)
.L19:
	jne	d15,#0,.L20

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   147                  if (COM_RESET != (ByteVal_u8 & 1u))      (inlined)
.L16:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   179                      }/* while (NoofPdus_u16 > 0 ) */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   180                  } /* if (COM_RESET != (ByteVal_u8 & 1u)) */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   181  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   182                  BitOffset_u8 ++;
	add	d1,#1
	extr.u	d1,d1,#0,#8
.L126:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   183                  ByteVal_u8 >>= 1u;
	sha	d0,#-1
.L174:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   185              } while (ByteVal_u8 > 0u);      (inlined)
	jne	d0,#0,.L15
.L175:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   184  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   185              } while (ByteVal_u8 > 0u);
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   186  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   187              /* update the status of the IPdu group */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   188              Com_IpduGrpVector_DM[Index_u16] = ipduGroupVector[Index_u16] ;
	ld.bu	d15,[a15]
.L176:
	st.b	[a2],d15

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   136          if (Com_IpduGrpVector_DM[Index_u16] != ipduGroupVector[Index_u16] )      (inlined)
.L14:
	add	d5,#1

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   134      for (Index_u16 = 0; Index_u16 < COM_NUM_ARR_IPDUGRPVECT; Index_u16++)      (inlined)
.L12:
	jeq	d5,#0,.L13
.L67:
	movh.a	a2,#@his(Com_RxIpduRam_s)
	lea	a2,[a2]@los(Com_RxIpduRam_s)
.L177:
	mov.aa	a4,a2
.L127:
	mov	d3,#0
.L128:
	j	.L21
.L22:
	ld.bu	d0,[a4]4
.L178:
	movh.a	a15,#@his(Com_IpduCounter_DM)
	lea	a15,[a15]@los(Com_IpduCounter_DM)
	addsc.a	a15,a15,d3,#0
	ld.bu	d15,[a15]
.L179:
	jeq	d15,#0,.L23
.L82:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
	mov	d1,#1
.L180:
	sh	d1,#1
.L181:
	and	d0,d1
.L182:
	ne	d15,d0,#0
.L183:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);      (inlined)
	j	.L24

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }      (inlined)
.L24:
	jne	d15,#0,.L25
.L89:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   189          } /* if (Com_IpduGrpVector_DM[Index_u16] != ipduGroupVector[Index_u16] ) */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   190  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   191      } /* End of For loop */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   192  }
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   193  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   194  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   195  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   196   Function name    : Com_Prv_EnableRxDeadlineMonitoring
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   197   Syntax           : void Com_Prv_EnableRxDeadlineMonitoring(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   198   Description      : Inline function to enable the Rx DeadlineMonitoring.
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   199   Parameter        : IpduId -> Id of the Rx ipdu
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   200   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   201  **********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   202  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_EnableRxDeadlineMonitoring(VAR(Com_IpduIdType, AUTOMATIC) IpduId)
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   203  {
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   204      Com_RxIpduConstPtrType                                      RxIPduConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   205  #ifdef COM_RxIPduTimeout
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   206      Com_RxIpduRamPtrType                                        RxIPduRamPtr;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   207  #endif
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   208  #if (defined(COM_RxSigUpdateTimeout) || defined(COM_RxSigGrpUpdateTimeout))
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   209      P2CONST(Com_SignalTimeoutInfo, AUTOMATIC, COM_APPL_CONST)   SigTimeOutConfigPtr;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   210      P2VAR(uint16, AUTOMATIC, COM_APPL_DATA)                     SigTimeOutTicksPtr;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   211      VAR(uint16_least, AUTOMATIC)                                Idx_Sig_ui;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   212      VAR(uint16_least, AUTOMATIC)                                NoOfSigOrSigGrp_ui;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   213  #endif
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   214  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   215      RxIPduConstPtr = COM_GET_RX_IPDU_CONSTDATA(IpduId);
	mul	d15,d3,#20
	movh.a	a15,#@his(Com_Prv_xRxIpduCfg_acst)
	lea	a15,[a15]@los(Com_Prv_xRxIpduCfg_acst)
	addsc.a	a5,a15,d15,#0
.L129:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   216  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   217  #ifdef COM_RxIPduTimeout
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   218      RxIPduRamPtr   = &COM_GET_RXPDURAM_S(IpduId);
	mul	d15,d3,#6
	addsc.a	a15,a2,d15,#0
.L130:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   219  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   220      /* If First timeout is not configured , load the timer with specific value ie COM_RXTIMER_MAX(0xFFFF).
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   221       * If First timeout is configured then load the actual value
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   222       */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   223      RxIPduRamPtr->RxTicks_u16 = (RxIPduConstPtr->FirstTimeout_Factor == 0) ? COM_RXTIMER_MAX :
	ld.hu	d15,[a5]10
.L184:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   223      RxIPduRamPtr->RxTicks_u16 = (RxIPduConstPtr->FirstTimeout_Factor == 0) ? COM_RXTIMER_MAX :      (inlined)
	jne	d15,#0,.L26
.L185:
	mov.u	d15,#65535
.L186:

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   223      RxIPduRamPtr->RxTicks_u16 = (RxIPduConstPtr->FirstTimeout_Factor == 0) ? COM_RXTIMER_MAX :      (inlined)
	j	.L27
.L26:
.L27:
	st.h	[a15]2,d15
.L90:
	mov.aa	a15,a4
.L131:
	add.a	a15,#4
	mov	d0,#1
.L98:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;      (inlined)
	ne	d0,d0,#0
.L132:
	j	.L29
.L28:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   439  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   440  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   441  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   442   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   443   * Bfx_PutBit_u16u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   444   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   445   * \brief Sets or clears a bit at a given position Pos_u32 in the 16-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   446   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   447   * A priori, range [0,15] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   448   * Note, neither the given position BitPn nor the given value Value not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   449   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   450   * \param   uint16*  Data   pointer to a 16-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   451   * \param   uint8    BitPn  position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   452   * \param   boolean  Value  defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   453   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   454   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   455   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   456  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   457  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   458      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   460      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   461      *Data = ((*Data & ((uint16)~(1uL << BitPn))) | ((uint16)((uint16)tmp_u8 << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   462  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   463  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   464  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   465  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   466   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   467   * Bfx_PutBit_u32u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   468   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   469   * \brief Sets or clears a bit at a given position Pos_u32 in the 32-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   470   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   471   * A priori, range [0,31] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   472   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   473   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   474   * \param   uint32*     Data        pointer to a 32-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   475   * \param   uint8       BitPn       position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   476   * \param   boolean     Value       defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   477   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   478   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   479   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   480  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   481  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   482      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   483      tmp_u8 = (Value)? 1u : 0u;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   484      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   485      *Data = ((*Data & ((uint32)~(1uL << BitPn))) | ((uint32)((uint32)tmp_u8 << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   486  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   487  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   488  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   489  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   490   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   491   * Bfx_PutBit_u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   492   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   493   * \brief Sets or clears a bit at a given position BitPn in the 8-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   494   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   495   * A priori, range [0,7] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   496   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   497   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   498   * \param  uint8*   Data    pointer to a 8-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   499   * \param  uint8    BitPn   position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   500   * \param  boolean  Value   defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   501   * \return void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   502   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   503   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   504  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   505  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   506      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;
	mov	d0,#0

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;      (inlined)
.L29:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   508      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   509      *Data = ((*Data & ((uint8)~(1uL <<BitPn))) | ((uint8)(tmp_u8 << BitPn)));
	ld.bu	d1,[a15]
.L187:
	mov	d2,#1
.L188:
	sh	d2,#1
.L189:
	xor	d2,d2,#255
.L190:
	and	d1,d2
.L191:
	sha	d0,#1
.L133:
	or	d1,d0
.L192:
	st.b	[a15],d1
.L25:
	j	.L30
.L23:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
	mov	d15,#1
.L193:
	sh	d15,#1
.L194:
	and	d0,d15
.L195:
	ne	d15,d0,#0
.L196:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);      (inlined)
	j	.L31

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }      (inlined)
.L31:
	jeq	d15,#0,.L32
.L197:
	mov.aa	a15,a4
	add.a	a15,#4
	mov	d15,#0
.L107:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;      (inlined)
	ne	d15,d15,#0
.L134:
	j	.L34
.L33:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   439  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   440  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   441  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   442   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   443   * Bfx_PutBit_u16u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   444   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   445   * \brief Sets or clears a bit at a given position Pos_u32 in the 16-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   446   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   447   * A priori, range [0,15] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   448   * Note, neither the given position BitPn nor the given value Value not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   449   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   450   * \param   uint16*  Data   pointer to a 16-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   451   * \param   uint8    BitPn  position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   452   * \param   boolean  Value  defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   453   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   454   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   455   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   456  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   457  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   458      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   460      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   461      *Data = ((*Data & ((uint16)~(1uL << BitPn))) | ((uint16)((uint16)tmp_u8 << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   462  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   463  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   464  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   465  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   466   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   467   * Bfx_PutBit_u32u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   468   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   469   * \brief Sets or clears a bit at a given position Pos_u32 in the 32-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   470   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   471   * A priori, range [0,31] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   472   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   473   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   474   * \param   uint32*     Data        pointer to a 32-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   475   * \param   uint8       BitPn       position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   476   * \param   boolean     Value       defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   477   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   478   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   479   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   480  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   481  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   482      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   483      tmp_u8 = (Value)? 1u : 0u;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   484      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   485      *Data = ((*Data & ((uint32)~(1uL << BitPn))) | ((uint32)((uint32)tmp_u8 << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   486  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   487  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   488  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   489  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   490   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   491   * Bfx_PutBit_u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   492   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   493   * \brief Sets or clears a bit at a given position BitPn in the 8-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   494   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   495   * A priori, range [0,7] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   496   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   497   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   498   * \param  uint8*   Data    pointer to a 8-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   499   * \param  uint8    BitPn   position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   500   * \param  boolean  Value   defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   501   * \return void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   502   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   503   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   504  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   505  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   506      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;
	mov	d15,#0

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;      (inlined)
.L34:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   508      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   509      *Data = ((*Data & ((uint8)~(1uL <<BitPn))) | ((uint8)(tmp_u8 << BitPn)));
	ld.bu	d0,[a15]
.L198:
	mov	d1,#1
.L199:
	sh	d1,#1
.L200:
	xor	d1,d1,#255
.L201:
	and	d0,d1
.L202:
	sha	d15,#1
.L135:
	or	d0,d15
.L203:
	st.b	[a15],d0
.L32:
.L30:
	add.a	a4,#6
.L204:
	add	d3,#1
.L21:
	jlt.u	d3,#5,.L22
.L8:
	ret
.L46:
	
__Com_ReceptionDMControl_function_end:
	.size	Com_ReceptionDMControl,__Com_ReceptionDMControl_function_end-Com_ReceptionDMControl
.L45:
	; End of function
	
	.calls	'Com_ReceptionDMControl','Det_ReportError'
	.extern	Det_ReportError
	.extern	Com_Uninit_Flag
	.extern	Com_RxIpduRam_s
	.extern	Com_IpduCounter_DM
	.extern	Com_IpduGrpVector_DM
	.extern	Com_Prv_xRxIpduCfg_acst
	.extern	Com_Prv_xIpduGrpCfg_acst
	.extern	Com_Prv_xIPduGrp_IpduRefCfg_au8
	.calls	'Com_ReceptionDMControl','',0
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L38:
	.word	14241
	.half	3
	.word	.L39
	.byte	4
.L37:
	.byte	1
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_EnableRxDm.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L40
.L63:
	.byte	2
	.byte	'unsigned char',0,1,8
.L53:
	.byte	2
	.byte	'unsigned short int',0,2,7,3
	.byte	'Bfx_Prv_GetBit_u16u8_u8_Inl',0,3,1,207,2,22
	.word	140
	.byte	1,1,4
	.byte	'Data',0,1,207,2,57
	.word	157
	.byte	4
	.byte	'BitPn',0,1,207,2,69
	.word	140
	.byte	5,0,2
	.byte	'unsigned int',0,4,7,3
	.byte	'Bfx_Prv_GetBit_u32u8_u8_Inl',0,3,1,227,2,22
	.word	140
	.byte	1,1,4
	.byte	'Data',0,1,227,2,57
	.word	250
	.byte	4
	.byte	'BitPn',0,1,227,2,69
	.word	140
	.byte	5,0
.L81:
	.byte	3
	.byte	'Bfx_Prv_GetBit_u8u8_u8_Inl',0,3,1,247,2,22
	.word	140
	.byte	1,1
.L83:
	.byte	4
	.byte	'Data',0,1,247,2,55
	.word	140
.L85:
	.byte	4
	.byte	'BitPn',0,1,247,2,67
	.word	140
.L87:
	.byte	5,0,3
	.byte	'Bfx_Prv_GetBits_u8u8u8_u8_Inl',0,3,1,179,3,20
	.word	140
	.byte	1,1,4
	.byte	'Data',0,1,179,3,56
	.word	140
	.byte	4
	.byte	'BitStartPn',0,1,179,3,68
	.word	140
	.byte	4
	.byte	'BitLn',0,1,179,3,86
	.word	140
	.byte	5,0,6
	.word	157
	.byte	7
	.byte	'Bfx_Prv_PutBit_u16u8u8_Inl',0,3,1,200,3,19,1,1,4
	.byte	'Data',0,1,200,3,54
	.word	500
	.byte	4
	.byte	'BitPn',0,1,200,3,66
	.word	140
	.byte	4
	.byte	'Value',0,1,200,3,81
	.word	140
	.byte	5,0,6
	.word	250
	.byte	7
	.byte	'Bfx_Prv_PutBit_u32u8u8_Inl',0,3,1,224,3,19,1,1,4
	.byte	'Data',0,1,224,3,54
	.word	586
	.byte	4
	.byte	'BitPn',0,1,224,3,66
	.word	140
	.byte	4
	.byte	'Value',0,1,224,3,81
	.word	140
	.byte	5,0,6
	.word	140
.L97:
	.byte	7
	.byte	'Bfx_Prv_PutBit_u8u8u8_Inl',0,3,1,248,3,19,1,1
.L99:
	.byte	4
	.byte	'Data',0,1,248,3,52
	.word	672
.L101:
	.byte	4
	.byte	'BitPn',0,1,248,3,64
	.word	140
.L103:
	.byte	4
	.byte	'Value',0,1,248,3,79
	.word	140
.L105:
	.byte	5,0,3
	.byte	'Bfx_Prv_TstParityEven_u32_u8_Inl',0,3,1,143,10,22
	.word	140
	.byte	1,1,4
	.byte	'Data',0,1,143,10,62
	.word	250
	.byte	5,0
.L55:
	.byte	3
	.byte	'Com_Prv_DETCheck_Ptr',0,3,2,251,6,37
	.word	140
	.byte	1,1
.L58:
	.byte	4
	.byte	'isInValidPtr',0,2,251,6,66
	.word	140
.L60:
	.byte	4
	.byte	'ApiId',0,2,251,6,86
	.word	140
.L62:
	.byte	5,0,8
	.word	140
	.byte	6
	.word	890
.L66:
	.byte	7
	.byte	'Com_Prv_ProcessRxDMIPduGroupVector',0,3,3,119,35,1,1
.L68:
	.byte	4
	.byte	'ipduGroupVector',0,3,120,86
	.word	895
.L70:
	.byte	5,0
.L88:
	.byte	7
	.byte	'Com_Prv_EnableRxDeadlineMonitoring',0,3,3,202,1,35,1,1
.L91:
	.byte	4
	.byte	'IpduId',0,3,202,1,101
	.word	140
.L93:
	.byte	5,0
.L47:
	.byte	6
	.word	140
	.byte	9,4,218,9,9,6,10
	.byte	'RxIPduLength',0
	.word	157
	.byte	2,2,35,0,10
	.byte	'RxTicks_u16',0
	.word	157
	.byte	2,2,35,2,10
	.byte	'RxFlags',0
	.word	140
	.byte	1,2,35,4,0,6
	.word	1034
	.byte	6
	.word	1034
.L49:
	.byte	11
	.byte	'Com_RxIpduRamPtrType',0,4,254,9,62
	.word	1106
.L51:
	.byte	2
	.byte	'unsigned long int',0,4,7,8
	.word	140
.L71:
	.byte	6
	.word	1162
	.byte	9,4,219,7,9,4,10
	.byte	'FirstIpdu_Index',0
	.word	157
	.byte	2,2,35,0,10
	.byte	'NoOfRxPdus',0
	.word	157
	.byte	2,2,35,2,0,8
	.word	1172
	.byte	6
	.word	1224
	.byte	8
	.word	1172
	.byte	6
	.word	1234
.L73:
	.byte	11
	.byte	'Com_IPduGrpConstPtrType',0,4,233,7,73
	.word	1239
	.byte	12,1,1,6
	.word	1277
	.byte	9,4,137,7,9,20,10
	.byte	'BuffPtr',0
	.word	672
	.byte	4,2,35,0,10
	.byte	'TimeOutNotification_Cbk',0
	.word	1280
	.byte	4,2,35,4,10
	.byte	'Size',0
	.word	157
	.byte	2,2,35,8,10
	.byte	'FirstTimeout_Factor',0
	.word	157
	.byte	2,2,35,10,10
	.byte	'Timeout_Fact',0
	.word	157
	.byte	2,2,35,12,10
	.byte	'No_Of_Sig_Ref',0
	.word	157
	.byte	2,2,35,14,10
	.byte	'RxSigId_Index',0
	.word	140
	.byte	1,2,35,16,10
	.byte	'MainFunctionRef',0
	.word	140
	.byte	1,2,35,17,10
	.byte	'rxIPduFields',0
	.word	140
	.byte	1,2,35,18,0,8
	.word	1285
	.byte	6
	.word	1500
	.byte	8
	.word	1285
	.byte	6
	.word	1510
.L94:
	.byte	11
	.byte	'Com_RxIpduConstPtrType',0,4,206,7,72
	.word	1515
	.byte	13
	.byte	'Det_ReportError',0,5,112,16
	.word	140
	.byte	1,1,1,1,4
	.byte	'ModuleId',0,5,112,39
	.word	157
	.byte	4
	.byte	'InstanceId',0,5,112,55
	.word	140
	.byte	4
	.byte	'ApiId',0,5,112,73
	.word	140
	.byte	4
	.byte	'ErrorId',0,5,112,86
	.word	140
	.byte	0,14
	.word	179
	.byte	15
	.word	219
	.byte	15
	.word	233
	.byte	5,0,14
	.word	266
	.byte	15
	.word	306
	.byte	15
	.word	320
	.byte	5,0,14
	.word	337
	.byte	15
	.word	376
	.byte	15
	.word	390
	.byte	5,0,14
	.word	407
	.byte	15
	.word	449
	.byte	15
	.word	463
	.byte	15
	.word	483
	.byte	5,0,14
	.word	505
	.byte	15
	.word	540
	.byte	15
	.word	554
	.byte	15
	.word	569
	.byte	5,0,14
	.word	591
	.byte	15
	.word	626
	.byte	15
	.word	640
	.byte	15
	.word	655
	.byte	5,0,14
	.word	677
	.byte	15
	.word	711
	.byte	15
	.word	725
	.byte	15
	.word	740
	.byte	5,0,14
	.word	757
	.byte	15
	.word	802
	.byte	5,0,14
	.word	818
	.byte	15
	.word	851
	.byte	15
	.word	873
	.byte	5,0,14
	.word	900
	.byte	15
	.word	942
	.byte	5,0,14
	.word	968
	.byte	15
	.word	1011
	.byte	5,0,16,1,6
	.word	1839
	.byte	11
	.byte	'__codeptr',0,3,1,1
	.word	1841
	.byte	2
	.byte	'char',0,1,6,11
	.byte	'sint8',0,6,76,25
	.word	1864
	.byte	11
	.byte	'uint8',0,6,81,25
	.word	140
	.byte	11
	.byte	'uint16',0,6,91,25
	.word	157
	.byte	11
	.byte	'uint32',0,6,106,24
	.word	250
	.byte	2
	.byte	'unsigned long long int',0,8,7,11
	.byte	'uint64',0,6,111,30
	.word	1930
	.byte	11
	.byte	'boolean',0,6,127,25
	.word	140
	.byte	11
	.byte	'StatusType',0,7,191,1,27
	.word	140
	.byte	11
	.byte	'Std_ReturnType',0,7,199,1,15
	.word	140
	.byte	9,7,206,1,9,8,10
	.byte	'vendorID',0
	.word	157
	.byte	2,2,35,0,10
	.byte	'moduleID',0
	.word	157
	.byte	2,2,35,2,10
	.byte	'sw_major_version',0
	.word	140
	.byte	1,2,35,4,10
	.byte	'sw_minor_version',0
	.word	140
	.byte	1,2,35,5,10
	.byte	'sw_patch_version',0
	.word	140
	.byte	1,2,35,6,0,11
	.byte	'Std_VersionInfoType',0,7,213,1,3
	.word	2031
	.byte	11
	.byte	'PduIdType',0,8,22,19
	.word	157
	.byte	11
	.byte	'PduLengthType',0,8,26,19
	.word	157
	.byte	17,9,113,9,4,18
	.byte	'TP_DATACONF',0,0,18
	.byte	'TP_DATARETRY',0,1,18
	.byte	'TP_CONFPENDING',0,2,0,11
	.byte	'TpDataStateType',0,9,118,3
	.word	2221
	.byte	11
	.byte	'Com_SignalIdType',0,10,100,16
	.word	157
	.byte	11
	.byte	'Com_SignalGroupIdType',0,10,102,16
	.word	157
	.byte	11
	.byte	'Com_IpduIdType',0,10,104,15
	.word	140
	.byte	11
	.byte	'Com_GrpSignalIdType',0,10,107,18
	.word	140
	.byte	19,1
	.word	140
	.byte	20,0,0,11
	.byte	'Com_IpduGroupVector',0,10,112,15
	.word	2403
	.byte	17,10,117,9,4,18
	.byte	'COM_UNINIT',0,0,18
	.byte	'COM_INIT',0,1,0,11
	.byte	'Com_StatusType',0,10,121,2
	.word	2440
	.byte	11
	.byte	'Com_TxIntSignalIdType',0,11,138,3,18
	.word	140
	.byte	11
	.byte	'Com_RxIntSignalIdType',0,11,139,3,18
	.word	140
	.byte	11
	.byte	'Com_BitsizeType',0,11,155,3,17
	.word	140
	.byte	11
	.byte	'Com_BitpositionType',0,11,156,3,15
	.word	140
	.byte	11
	.byte	'Com_RxGwQueueIndexType',0,11,161,3,15
	.word	140
	.byte	11
	.byte	'Com_SigBuffIndexType',0,11,164,3,15
	.word	140
	.byte	11
	.byte	'Com_SigMaxType',0,11,198,3,16
	.word	250
	.byte	11
	.byte	'Com_MainFuncType',0,11,231,3,16
	.word	140
	.byte	11
	.byte	'Com_NumOfIpdusType',0,11,233,3,15
	.word	140
	.byte	11
	.byte	'Com_TimeBaseType',0,11,235,3,15
	.word	140
	.byte	11
	.byte	'Can_IdType',0,12,32,16
	.word	250
	.byte	11
	.byte	'Can_HwHandleType',0,12,43,16
	.word	157
	.byte	9,13,93,9,8,10
	.byte	'Class',0
	.word	140
	.byte	1,2,35,0,10
	.byte	'TIN',0
	.word	140
	.byte	1,2,35,1,10
	.byte	'ReturnAddress',0
	.word	250
	.byte	4,2,35,4,0,11
	.byte	'OsTrapInfoType',0,13,97,3
	.word	2819
	.byte	19,68
	.word	250
	.byte	20,16,0,9,13,154,1,9,68,10
	.byte	'store',0
	.word	2899
	.byte	68,2,35,0,0,19,68
	.word	2908
	.byte	20,0,0,11
	.byte	'Os_JumpBufType',0,13,156,1,3
	.word	2930
	.byte	11
	.byte	'Os_StackTraceType',0,13,174,1,18
	.word	250
	.byte	9,13,175,1,9,8,10
	.byte	'sp',0
	.word	250
	.byte	4,2,35,0,10
	.byte	'ctx',0
	.word	250
	.byte	4,2,35,4,0,11
	.byte	'Os_StackValueType',0,13,175,1,63
	.word	2990
	.byte	11
	.byte	'Os_StackSizeType',0,13,176,1,27
	.word	2990
	.byte	11
	.byte	'Os_VoidVoidFunctionType',0,13,179,1,16
	.word	1280
	.byte	11
	.byte	'ApplicationType',0,13,193,1,23
	.word	140
	.byte	21
	.byte	'Os_ApplicationConfigurationType_s',0,13,198,1,16,2,10
	.byte	'app_id',0
	.word	140
	.byte	1,2,35,0,10
	.byte	'access',0
	.word	140
	.byte	1,2,35,1,0,11
	.byte	'Os_ApplicationConfigurationType',0,13,201,1,3
	.word	3133
	.byte	11
	.byte	'Os_CoreStateType',0,13,203,1,16
	.word	250
	.byte	11
	.byte	'AreaIdType',0,13,204,1,16
	.word	157
	.byte	11
	.byte	'Os_PeripheralAddressType',0,13,212,1,22
	.word	250
	.byte	11
	.byte	'TickType',0,13,221,1,22
	.word	250
	.byte	11
	.byte	'Os_StopwatchTickType',0,13,225,1,22
	.word	250
	.byte	11
	.byte	'Os_Lockable',0,13,234,1,18
	.word	586
	.byte	11
	.byte	'CoreIdType',0,13,236,1,16
	.word	157
	.byte	11
	.byte	'SpinlockIdType',0,13,237,1,16
	.word	157
	.byte	17,13,239,1,9,4,18
	.byte	'TRYTOGETSPINLOCK_SUCCESS',0,0,18
	.byte	'TRYTOGETSPINLOCK_NOSUCCESS',0,1,0,11
	.byte	'TryToGetSpinlockType',0,13,239,1,74
	.word	3440
	.byte	17,13,174,2,9,4,18
	.byte	'APPLICATION_ACCESSIBLE',0,0,18
	.byte	'APPLICATION_RESTARTING',0,1,18
	.byte	'APPLICATION_TERMINATED',0,2,0,11
	.byte	'ApplicationStateType',0,13,174,2,92
	.word	3533
	.byte	22
	.byte	'void',0,6
	.word	3645
	.byte	23,1,1,24
	.word	140
	.byte	24
	.word	3651
	.byte	0,6
	.word	3656
	.byte	11
	.byte	'Os_FunctionEntryType',0,13,183,2,16
	.word	3670
	.byte	21
	.byte	'Os_MeterInfoType_s',0,13,193,2,16,48,10
	.byte	'elapsed',0
	.word	250
	.byte	4,2,35,0,10
	.byte	'previous',0
	.word	250
	.byte	4,2,35,4,10
	.byte	'max',0
	.word	250
	.byte	4,2,35,8,10
	.byte	'cumulative',0
	.word	250
	.byte	4,2,35,12,10
	.byte	'stackbase',0
	.word	2990
	.byte	8,2,35,16,10
	.byte	'stackusage',0
	.word	2990
	.byte	8,2,35,24,10
	.byte	'stackmax',0
	.word	2990
	.byte	8,2,35,32,10
	.byte	'stackbudget',0
	.word	2990
	.byte	8,2,35,40,0,11
	.byte	'Os_MeterInfoType',0,13,202,2,3
	.word	3705
	.byte	6
	.word	3705
	.byte	11
	.byte	'Os_MeterInfoRefType',0,13,203,2,50
	.word	3903
	.byte	11
	.byte	'EventMaskType',0,13,206,2,15
	.word	140
	.byte	11
	.byte	'Os_imaskType',0,13,211,2,16
	.word	250
	.byte	21
	.byte	'Os_ISRDynType_s',0,13,213,2,16,48,10
	.byte	'meter',0
	.word	3705
	.byte	48,2,35,0,0,11
	.byte	'Os_ISRDynType',0,13,215,2,3
	.word	3982
	.byte	6
	.word	3982
	.byte	8
	.word	4043
	.byte	21
	.byte	'Os_ISRType_s',0,13,216,2,16,24,10
	.byte	'entry_function',0
	.word	3075
	.byte	4,2,35,0,10
	.byte	'dynamic',0
	.word	4048
	.byte	4,2,35,4,10
	.byte	'imask',0
	.word	250
	.byte	4,2,35,8,10
	.byte	'stackbudget',0
	.word	2990
	.byte	8,2,35,12,10
	.byte	'access',0
	.word	140
	.byte	1,2,35,20,10
	.byte	'application',0
	.word	140
	.byte	1,2,35,21,0,11
	.byte	'Os_ISRType',0,13,223,2,3
	.word	4053
	.byte	6
	.word	1277
	.byte	8
	.word	4053
	.byte	6
	.word	4212
	.byte	11
	.byte	'ISRType',0,13,224,2,46
	.word	4217
	.byte	11
	.byte	'Os_bitmask',0,13,239,2,22
	.word	250
	.byte	11
	.byte	'Os_pset0Type',0,13,240,2,20
	.word	250
	.byte	11
	.byte	'Os_pset1Type',0,13,241,2,20
	.word	250
	.byte	11
	.byte	'Os_pset2Type',0,13,242,2,20
	.word	250
	.byte	25,13,243,2,9,4,10
	.byte	'p0',0
	.word	250
	.byte	4,2,35,0,10
	.byte	'p1',0
	.word	250
	.byte	4,2,35,0,10
	.byte	'p2',0
	.word	250
	.byte	4,2,35,0,0,11
	.byte	'Os_psetType',0,13,247,2,3
	.word	4325
	.byte	25,13,249,2,9,4,10
	.byte	't0',0
	.word	250
	.byte	4,2,35,0,10
	.byte	't1',0
	.word	250
	.byte	4,2,35,0,10
	.byte	't2',0
	.word	250
	.byte	4,2,35,0,0,11
	.byte	'Os_tpmaskType',0,13,253,2,3
	.word	4389
	.byte	11
	.byte	'Os_ActivationCountType',0,13,254,2,23
	.word	140
	.byte	21
	.byte	'Os_TaskDynType_s',0,13,128,3,16,120,10
	.byte	'terminate_jump_buf',0
	.word	2939
	.byte	68,2,35,0,10
	.byte	'meter',0
	.word	3705
	.byte	48,2,35,68,10
	.byte	'activation_count',0
	.word	140
	.byte	1,2,35,116,0,11
	.byte	'Os_TaskDynType',0,13,132,3,3
	.word	4487
	.byte	19,68
	.word	2908
	.byte	20,0,0,6
	.word	4487
	.byte	8
	.word	4613
	.byte	21
	.byte	'Os_TaskType_s',0,13,134,3,16,40,10
	.byte	'dynamic',0
	.word	4618
	.byte	4,2,35,0,10
	.byte	'entry_function',0
	.word	3075
	.byte	4,2,35,4,10
	.byte	'pset',0
	.word	4325
	.byte	4,2,35,8,10
	.byte	'base_tpmask',0
	.word	4389
	.byte	4,2,35,12,10
	.byte	'tpmask',0
	.word	4389
	.byte	4,2,35,16,10
	.byte	'core_id',0
	.word	157
	.byte	2,2,35,20,10
	.byte	'index',0
	.word	250
	.byte	4,2,35,24,10
	.byte	'stackbudget',0
	.word	2990
	.byte	8,2,35,28,10
	.byte	'activation_count',0
	.word	140
	.byte	1,2,35,36,10
	.byte	'access',0
	.word	140
	.byte	1,2,35,37,10
	.byte	'application',0
	.word	140
	.byte	1,2,35,38,0,11
	.byte	'Os_TaskType',0,13,146,3,3
	.word	4623
	.byte	8
	.word	4623
	.byte	6
	.word	4873
	.byte	11
	.byte	'TaskType',0,13,147,3,47
	.word	4878
	.byte	26
	.byte	'Os_TaskStateType',0,13,155,3,6,4,18
	.byte	'SUSPENDED',0,0,18
	.byte	'READY',0,1,18
	.byte	'WAITING',0,2,18
	.byte	'RUNNING',0,3,0,11
	.byte	'TaskStateType',0,13,156,3,31
	.word	4901
	.byte	25,13,167,3,3,4,10
	.byte	'tpmask',0
	.word	4389
	.byte	4,2,35,0,0,21
	.byte	'Os_ResourceDynType_s',0,13,166,3,16,4,10
	.byte	'saved_priority',0
	.word	4988
	.byte	4,2,35,0,0,11
	.byte	'Os_ResourceDynType',0,13,170,3,3
	.word	5011
	.byte	6
	.word	5011
	.byte	8
	.word	5091
	.byte	21
	.byte	'Os_ResourceType_s',0,13,171,3,16,12,10
	.byte	'dynamic',0
	.word	5096
	.byte	4,2,35,0,10
	.byte	'tpmask',0
	.word	4389
	.byte	4,2,35,4,10
	.byte	'access',0
	.word	140
	.byte	1,2,35,8,0,11
	.byte	'Os_ResourceType',0,13,175,3,3
	.word	5101
	.byte	9,13,181,3,9,12,10
	.byte	'maxallowedvalue',0
	.word	250
	.byte	4,2,35,0,10
	.byte	'ticksperbase',0
	.word	250
	.byte	4,2,35,4,10
	.byte	'mincycle',0
	.word	250
	.byte	4,2,35,8,0,11
	.byte	'AlarmBaseType',0,13,185,3,3
	.word	5200
	.byte	9,13,206,3,9,8,10
	.byte	'Running',0
	.word	140
	.byte	1,2,35,0,10
	.byte	'Pending',0
	.word	140
	.byte	1,2,35,1,10
	.byte	'Delay',0
	.word	250
	.byte	4,2,35,4,0,11
	.byte	'Os_CounterStatusType',0,13,210,3,3
	.word	5295
	.byte	27
	.word	140
	.byte	1,1,6
	.word	5381
	.byte	11
	.byte	'Os_CounterIncrAdvType',0,13,217,3,22
	.word	5388
	.byte	21
	.byte	's_swd',0,13,222,3,12,4,10
	.byte	'count',0
	.word	250
	.byte	4,2,35,0,0,25,13,221,3,3,4,10
	.byte	'sw',0
	.word	5424
	.byte	4,2,35,0,0,21
	.byte	'Os_CounterDynType_s',0,13,220,3,16,4,10
	.byte	'type_dependent',0
	.word	5452
	.byte	4,2,35,0,0,11
	.byte	'Os_CounterDynType',0,13,226,3,3
	.word	5471
	.byte	6
	.word	5471
	.byte	8
	.word	5549
	.byte	21
	.byte	'Os_CounterType_s',0,13,227,3,16,28,10
	.byte	'dynamic',0
	.word	5554
	.byte	4,2,35,0,10
	.byte	'advincr',0
	.word	5393
	.byte	4,2,35,4,10
	.byte	'base',0
	.word	5200
	.byte	12,2,35,8,10
	.byte	'core',0
	.word	3651
	.byte	4,2,35,20,10
	.byte	'access',0
	.word	140
	.byte	1,2,35,24,10
	.byte	'application',0
	.word	140
	.byte	1,2,35,25,0,11
	.byte	'Os_CounterType',0,13,234,3,3
	.word	5559
	.byte	6
	.word	5381
	.byte	8
	.word	5559
	.byte	6
	.word	5711
	.byte	11
	.byte	'CounterType',0,13,235,3,52
	.word	5716
	.byte	26
	.byte	'Os_ScheduleTableStatusType',0,13,240,3,6,4,18
	.byte	'SCHEDULETABLE_STOPPED',0,0,18
	.byte	'SCHEDULETABLE_NEXT',0,1,18
	.byte	'SCHEDULETABLE_WAITING',0,2,18
	.byte	'SCHEDULETABLE_RUNNING',0,3,18
	.byte	'SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS',0,4,0,11
	.byte	'ScheduleTableStatusType',0,13,241,3,41
	.word	5742
	.byte	8
	.word	.L136-.L38
	.byte	6
	.word	5942
	.byte	11
	.byte	'ScheduleTableType',0,13,128,4,58
	.word	5947
	.byte	21
	.byte	'Os_ScheduleTableDynType_s',0,13,130,4,16,16,10
	.byte	'match',0
	.word	250
	.byte	4,2,35,0,10
	.byte	'next',0
	.word	5952
	.byte	4,2,35,4,10
	.byte	'state',0
	.word	5742
	.byte	4,2,35,8,10
	.byte	'config',0
	.word	157
	.byte	2,2,35,12,0,6
	.word	5979
	.byte	8
	.word	6072
.L136:
	.byte	21
	.byte	'Os_ScheduleTableType_s',0,13,247,3,16,16,10
	.byte	'dynamic',0
	.word	6077
	.byte	4,2,35,0,10
	.byte	'counter',0
	.word	5721
	.byte	4,2,35,4,10
	.byte	'repeat',0
	.word	140
	.byte	1,2,35,8,10
	.byte	'config',0
	.word	157
	.byte	2,2,35,10,10
	.byte	'initial',0
	.word	140
	.byte	1,2,35,12,10
	.byte	'access',0
	.word	140
	.byte	1,2,35,13,10
	.byte	'application',0
	.word	140
	.byte	1,2,35,14,0,11
	.byte	'Os_ScheduleTableType',0,13,255,3,3
	.word	6082
	.byte	8
	.word	6082
	.byte	6
	.word	6262
	.byte	8
	.word	5559
	.byte	6
	.word	6272
	.byte	28
	.word	3375
	.byte	28
	.word	4325
	.byte	28
	.word	4222
	.byte	28
	.word	4883
	.byte	28
	.word	4389
	.byte	28
	.word	140
	.byte	28
	.word	4883
	.byte	21
	.byte	'Os_ControlledCoreType_s',0,13,251,6,16,112,10
	.byte	'TrapInfo',0
	.word	2819
	.byte	8,2,35,0,10
	.byte	'lock_taskaccess',0
	.word	6282
	.byte	4,2,35,8,10
	.byte	'ReadyTasks',0
	.word	6287
	.byte	4,2,35,12,10
	.byte	'RunningISR',0
	.word	6292
	.byte	4,2,35,16,10
	.byte	'RunningTask',0
	.word	6297
	.byte	4,2,35,20,10
	.byte	'RunningTPMask',0
	.word	6302
	.byte	4,2,35,24,10
	.byte	'CurrentMeteredObject',0
	.word	3908
	.byte	4,2,35,28,10
	.byte	'IdleMeter',0
	.word	3705
	.byte	48,2,35,32,10
	.byte	'AppAccess',0
	.word	140
	.byte	1,2,35,80,10
	.byte	'AppOverride',0
	.word	6307
	.byte	1,2,35,81,10
	.byte	'GetStackValueAdjust',0
	.word	2990
	.byte	8,2,35,84,10
	.byte	'InErrorHook',0
	.word	140
	.byte	1,2,35,92,10
	.byte	'ChainTaskRef',0
	.word	6312
	.byte	4,2,35,96,10
	.byte	'GetStackUsageAdjust',0
	.word	2990
	.byte	8,2,35,100,10
	.byte	'InProtectionHook',0
	.word	140
	.byte	1,2,35,108,10
	.byte	'CoreIsActive',0
	.word	140
	.byte	1,2,35,109,10
	.byte	'InShutdownHook',0
	.word	140
	.byte	1,2,35,110,0,11
	.byte	'Os_ControlledCoreType',0,13,141,7,3
	.word	6317
	.byte	6
	.word	250
	.byte	8
	.word	4053
	.byte	6
	.word	6773
	.byte	8
	.word	4623
	.byte	6
	.word	6783
	.byte	6
	.word	3705
	.byte	21
	.byte	'Os_AnyCoreType_s',0,13,151,7,16,96,10
	.byte	'DisableAllImask',0
	.word	250
	.byte	4,2,35,0,10
	.byte	'SuspendAllImask',0
	.word	250
	.byte	4,2,35,4,10
	.byte	'SuspendOSImask',0
	.word	250
	.byte	4,2,35,8,10
	.byte	'DisableAllCount',0
	.word	250
	.byte	4,2,35,12,10
	.byte	'SuspendAllCount',0
	.word	250
	.byte	4,2,35,16,10
	.byte	'SuspendOSCount',0
	.word	250
	.byte	4,2,35,20,10
	.byte	'RestartJumpBuf',0
	.word	2939
	.byte	68,2,35,24,10
	.byte	'Restartable',0
	.word	140
	.byte	1,2,35,92,0,11
	.byte	'Os_AnyCoreType',0,13,160,7,3
	.word	6798
	.byte	11
	.byte	'Can_TxObjPriorityClassType',0,14,219,3,16
	.word	250
	.byte	21
	.byte	'Can_TxHwObjectConfigType',0,14,231,3,16,8,10
	.byte	'MsgObjId',0
	.word	140
	.byte	1,2,35,0,10
	.byte	'HwControllerId',0
	.word	140
	.byte	1,2,35,1,10
	.byte	'TxObjPriorityClass',0
	.word	250
	.byte	4,2,35,4,0,11
	.byte	'Can_TxHwObjectConfigType',0,14,252,3,3
	.word	7075
	.byte	21
	.byte	'Can_RxHwObjectConfigType',0,14,129,4,16,12,10
	.byte	'MaskRef',0
	.word	250
	.byte	4,2,35,0,10
	.byte	'MsgId',0
	.word	250
	.byte	4,2,35,4,10
	.byte	'MsgObjId',0
	.word	140
	.byte	1,2,35,8,10
	.byte	'HwControllerId',0
	.word	140
	.byte	1,2,35,9,0,11
	.byte	'Can_RxHwObjectConfigType',0,14,147,4,3
	.word	7211
	.byte	19,4
	.word	140
	.byte	20,3,0,21
	.byte	'Can_ControllerMOMapConfigType',0,14,181,4,16,4,10
	.byte	'ControllerMOMap',0
	.word	7351
	.byte	4,2,35,0,0,11
	.byte	'Can_ControllerMOMapConfigType',0,14,184,4,3
	.word	7360
	.byte	21
	.byte	'Can_NPCRValueType',0,14,188,4,16,2,10
	.byte	'Can_NPCRValue',0
	.word	157
	.byte	2,2,35,0,0,11
	.byte	'Can_NPCRValueType',0,14,191,4,3
	.word	7461
	.byte	21
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,14,194,4,16,8,10
	.byte	'CanControllerBaudrate',0
	.word	250
	.byte	4,2,35,0,10
	.byte	'CanControllerBaudrateCfg',0
	.word	157
	.byte	2,2,35,4,0,11
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,14,198,4,3
	.word	7536
	.byte	8
	.word	7536
	.byte	6
	.word	7701
	.byte	21
	.byte	'Can_BaudrateConfigPtrType',0,14,201,4,16,4,10
	.byte	'Can_kBaudrateConfigPtr',0
	.word	7706
	.byte	4,2,35,0,0,11
	.byte	'Can_BaudrateConfigPtrType',0,14,204,4,3
	.word	7711
	.byte	21
	.byte	'Can_EventHandlingType',0,14,226,4,16,4,10
	.byte	'CanEventType',0
	.word	7351
	.byte	4,2,35,0,0,11
	.byte	'Can_EventHandlingType',0,14,229,4,3
	.word	7811
	.byte	11
	.byte	'Rte_TransformerErrorCode',0,15,130,1,15
	.word	140
	.byte	11
	.byte	'Rte_TransformerClass',0,15,131,1,15
	.word	140
	.byte	9,15,168,1,9,12,10
	.byte	'in',0
	.word	3651
	.byte	4,2,35,0,10
	.byte	'out',0
	.word	3651
	.byte	4,2,35,4,10
	.byte	'used',0
	.word	157
	.byte	2,2,35,8,10
	.byte	'lost_data',0
	.word	140
	.byte	1,2,35,10,0,11
	.byte	'Rte_QDynType',0,15,173,1,3
	.word	7957
	.byte	17,15,175,1,9,4,18
	.byte	'RTE_DRA',0,0,18
	.byte	'RTE_WOWP',0,1,18
	.byte	'RTE_TASK',0,2,18
	.byte	'RTE_ARE',0,3,18
	.byte	'RTE_EV',0,4,18
	.byte	'RTE_MSI',0,5,0,11
	.byte	'Rte_NotificationType',0,15,182,1,3
	.word	8044
	.byte	6
	.word	7957
	.byte	21
	.byte	'Rte_QCmnType',0,15,184,1,16,24,10
	.byte	'dynamic',0
	.word	8142
	.byte	4,2,35,0,10
	.byte	'copy',0
	.word	140
	.byte	1,2,35,4,10
	.byte	'queue_size',0
	.word	157
	.byte	2,2,35,6,10
	.byte	'element_size',0
	.word	157
	.byte	2,2,35,8,10
	.byte	'buffer_start',0
	.word	3651
	.byte	4,2,35,12,10
	.byte	'buffer_end',0
	.word	3651
	.byte	4,2,35,16,10
	.byte	'notification_type',0
	.word	8044
	.byte	4,2,35,20,0,11
	.byte	'Rte_QCmnType',0,15,192,1,3
	.word	8147
	.byte	11
	.byte	'Rte_AlarmRefType',0,15,224,1,32
	.word	250
	.byte	11
	.byte	'Rte_AlarmIndexType',0,15,226,1,32
	.word	157
	.byte	19,128,8
	.word	140
	.byte	20,255,7,0,11
	.byte	'Impl_NVM_DstPtrType_1024',0,16,50,15
	.word	8385
	.byte	11
	.byte	'CanIf_u32_impl',0,16,69,16
	.word	250
	.byte	11
	.byte	'CanIf_u16_impl',0,16,71,16
	.word	157
	.byte	11
	.byte	'CanIf_u8_impl',0,16,73,15
	.word	140
	.byte	11
	.byte	'CanIf_ControllerModeType_Enum_impl',0,16,88,15
	.word	140
	.byte	11
	.byte	'CanIf_PduModeType_Enum_impl',0,16,90,15
	.word	140
	.byte	9,16,92,9,2,10
	.byte	'DeviceMode',0
	.word	140
	.byte	1,2,35,0,10
	.byte	'ChannelMode',0
	.word	140
	.byte	1,2,35,1,0,11
	.byte	'CanIf_ControllerStateType_struct_impl',0,16,95,3
	.word	8576
	.byte	11
	.byte	'CanIf_NotifStatusType_Enum_impl',0,16,100,15
	.word	140
	.byte	11
	.byte	'CanSM_boolean_Impl',0,16,120,15
	.word	140
	.byte	11
	.byte	'CanSM_u8_Impl',0,16,123,15
	.word	140
	.byte	11
	.byte	'CanSM_BusOffRecoveryStateType_Enum_impl',0,16,128,1,15
	.word	140
	.byte	11
	.byte	'CanSM_NetworkModeStateType_Enum_impl',0,16,132,1,15
	.word	140
	.byte	11
	.byte	'CanSM_u16_Impl',0,16,136,1,16
	.word	157
	.byte	11
	.byte	'CanSM_TimerStateType_Enum_impl',0,16,138,1,15
	.word	140
	.byte	9,16,140,1,9,4,10
	.byte	'cntTick_u16',0
	.word	157
	.byte	2,2,35,0,10
	.byte	'stTimer',0
	.word	140
	.byte	1,2,35,2,0,11
	.byte	'CanSM_TimerConfig_tst_struct_impl',0,16,143,1,3
	.word	8917
	.byte	11
	.byte	'Com_impl_u16',0,16,154,1,16
	.word	157
	.byte	11
	.byte	'Com_impl_u8',0,16,157,1,15
	.word	140
	.byte	11
	.byte	'ComM_uint32_Impl',0,16,173,1,16
	.word	250
	.byte	11
	.byte	'ComM_uint16_Impl',0,16,175,1,16
	.word	157
	.byte	11
	.byte	'ComM_uint8_Impl',0,16,177,1,15
	.word	140
	.byte	11
	.byte	'ComM_bool_Impl',0,16,179,1,15
	.word	140
	.byte	9,16,181,1,9,24,10
	.byte	'ChannelState_e',0
	.word	250
	.byte	4,2,35,0,10
	.byte	'LightTimeoutCtr_u32',0
	.word	250
	.byte	4,2,35,4,10
	.byte	'MinFullComTimeoutCtr_u16',0
	.word	157
	.byte	2,2,35,8,10
	.byte	'ChannelMode_u8',0
	.word	140
	.byte	1,2,35,10,10
	.byte	'BusSmMode_u8',0
	.word	140
	.byte	1,2,35,11,10
	.byte	'UserRequestCtr_u8',0
	.word	140
	.byte	1,2,35,12,10
	.byte	'PassiveRequestState_u8',0
	.word	140
	.byte	1,2,35,13,10
	.byte	'PncRequestCtr_u8',0
	.word	140
	.byte	1,2,35,14,10
	.byte	'InhibitionReqStatus_u8',0
	.word	140
	.byte	1,2,35,15,10
	.byte	'NmNetworkRequestStatus_b',0
	.word	140
	.byte	1,2,35,16,10
	.byte	'DiagnosticRequestState_b',0
	.word	140
	.byte	1,2,35,17,10
	.byte	'CommunicationAllowed_b',0
	.word	140
	.byte	1,2,35,18,10
	.byte	'NmBusSleepIndicationStatus_b',0
	.word	140
	.byte	1,2,35,19,10
	.byte	'NmPrepareBusSleepIndicationStatus_b',0
	.word	140
	.byte	1,2,35,20,10
	.byte	'NmNetworkModeStatus_b',0
	.word	140
	.byte	1,2,35,21,0,11
	.byte	'ComM_ChannelStruct_Impl',0,16,197,1,3
	.word	9149
	.byte	9,16,206,1,9,10,10
	.byte	'WakeUpInhibitionCtr_u16',0
	.word	157
	.byte	2,2,35,0,10
	.byte	'LimitToNoComCtr_u16',0
	.word	157
	.byte	2,2,35,2,10
	.byte	'RequestedUserMode_t',0
	.word	140
	.byte	1,2,35,4,10
	.byte	'IndicatedUserMode_t',0
	.word	140
	.byte	1,2,35,5,10
	.byte	'numChannelsInFullCom_u8',0
	.word	140
	.byte	1,2,35,6,10
	.byte	'numChannelsInSilentCom_u8',0
	.word	140
	.byte	1,2,35,7,10
	.byte	'numChannelsInNoCom_u8',0
	.word	140
	.byte	1,2,35,8,0,11
	.byte	'ComM_UserStruct_Impl',0,16,214,1,3
	.word	9653
	.byte	11
	.byte	'Dcm_IOOperationResponseType',0,16,252,1,15
	.word	140
	.byte	11
	.byte	'Dcm_RequestDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspRequestRoutineResultsOutSignal_0PrimitivType',0
	.byte	16,138,2,15
	.word	140
	.byte	11
	.byte	'Dcm_StartDataIn_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineInSignalPrimitivType',0,16,146,2,15
	.word	140
	.byte	11
	.byte	'Dcm_StartDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineOutSignalPrimitivType',0,16,150,2,15
	.word	140
	.byte	11
	.byte	'Dcm_StopDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStopRoutineOutSignalPrimitivType',0,16,154,2,15
	.word	140
	.byte	11
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockNative_1024_Type',0,16,243,3,34
	.word	8396
	.byte	19,128,8
	.word	140
	.byte	20,255,7,0,11
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockRedundant_1024_Type',0,16,246,3,34
	.word	8396
	.byte	11
	.byte	'Rte_TaskRefType',0,17,184,1,32
	.word	4883
	.byte	11
	.byte	'Rte_EventRefType',0,17,185,1,32
	.word	140
	.byte	11
	.byte	'Rte_EventType',0,17,186,1,32
	.word	250
	.byte	11
	.byte	'Rte_REActCounterType',0,17,252,1,15
	.word	140
	.byte	6
	.word	140
	.byte	11
	.byte	'Rte_REActCounterRefType',0,17,253,1,58
	.word	10575
	.byte	9,17,255,1,9,8,10
	.byte	'task',0
	.word	10471
	.byte	4,2,35,0,10
	.byte	'acnt',0
	.word	10580
	.byte	4,2,35,4,0,11
	.byte	'Rte_REContainerType',0,17,130,2,3
	.word	10613
	.byte	8
	.word	4623
	.byte	6
	.word	10677
	.byte	6
	.word	140
	.byte	8
	.word	10613
	.byte	6
	.word	10692
	.byte	11
	.byte	'Rte_REContainerRefType',0,17,132,2,60
	.word	10697
	.byte	11
	.byte	'Rte_MSICounterType',0,17,149,2,16
	.word	157
	.byte	6
	.word	157
	.byte	11
	.byte	'Rte_MSICounterRefType',0,17,150,2,56
	.word	10762
	.byte	11
	.byte	'Rte_MSIPendingFlagType',0,17,152,2,17
	.word	140
	.byte	6
	.word	140
	.byte	11
	.byte	'Rte_MSIPendingFlagRefType',0,17,153,2,60
	.word	10830
	.byte	9,17,163,2,9,24,10
	.byte	'counter',0
	.word	10767
	.byte	4,2,35,0,10
	.byte	'incCounter',0
	.word	140
	.byte	1,2,35,4,10
	.byte	'pending',0
	.word	10835
	.byte	4,2,35,8,10
	.byte	'osTask',0
	.word	10471
	.byte	4,2,35,12,10
	.byte	'acnt',0
	.word	10580
	.byte	4,2,35,16,10
	.byte	'osEvent',0
	.word	140
	.byte	1,2,35,20,10
	.byte	'MSIInit',0
	.word	157
	.byte	2,2,35,22,0,11
	.byte	'Rte_MSITableEntry',0,17,172,2,3
	.word	10870
	.byte	6
	.word	157
	.byte	6
	.word	140
	.byte	11
	.byte	'Rte_TaskArrayIndex',0,17,179,2,16
	.word	140
	.byte	11
	.byte	'Rte_NrWaitingTasks',0,17,180,2,16
	.word	140
	.byte	9,17,182,2,9,4,10
	.byte	'pending',0
	.word	140
	.byte	1,2,35,0,10
	.byte	'count',0
	.word	140
	.byte	1,2,35,1,10
	.byte	'firstWaitingTask',0
	.word	140
	.byte	1,2,35,2,0,11
	.byte	'Rte_WaitableDatum',0,17,186,2,3
	.word	11088
	.byte	6
	.word	11088
	.byte	9,17,226,2,9,12,10
	.byte	'event_id',0
	.word	250
	.byte	4,2,35,0,10
	.byte	'wd',0
	.word	11180
	.byte	4,2,35,4,10
	.byte	'timeout',0
	.word	250
	.byte	4,2,35,8,0,11
	.byte	'Rte_WOWP_NotificationType',0,17,230,2,3
	.word	11185
	.byte	8
	.word	11185
	.byte	6
	.word	11274
	.byte	11
	.byte	'Rte_WOWP_NotificationRefType',0,17,232,2,66
	.word	11279
	.byte	11
	.byte	'Rte_ARE_NotificationType',0,17,234,2,29
	.word	10613
	.byte	21
	.byte	'Rte_QTaskType',0,17,243,2,16,28,10
	.byte	'cmn',0
	.word	8147
	.byte	24,2,35,0,10
	.byte	'task',0
	.word	10471
	.byte	4,2,35,24,0,11
	.byte	'Rte_QTaskType',0,17,246,2,3
	.word	11356
	.byte	21
	.byte	'Rte_QREType',0,17,250,2,16,28,10
	.byte	'cmn',0
	.word	8147
	.byte	24,2,35,0,10
	.byte	're',0
	.word	10702
	.byte	4,2,35,24,0,11
	.byte	'Rte_QREType',0,17,253,2,3
	.word	11427
	.byte	8
	.word	10613
	.byte	6
	.word	11492
	.byte	21
	.byte	'Rte_QWWPType',0,17,129,3,16,28,10
	.byte	'cmn',0
	.word	8147
	.byte	24,2,35,0,10
	.byte	'wwp',0
	.word	11284
	.byte	4,2,35,24,0,11
	.byte	'Rte_QWWPType',0,17,132,3,3
	.word	11502
	.byte	8
	.word	11185
	.byte	6
	.word	11570
	.byte	21
	.byte	'Rte_QEvType',0,17,136,3,16,36,10
	.byte	'cmn',0
	.word	8147
	.byte	24,2,35,0,10
	.byte	'task',0
	.word	10471
	.byte	4,2,35,24,10
	.byte	'mask',0
	.word	140
	.byte	1,2,35,28,10
	.byte	'acnt',0
	.word	10580
	.byte	4,2,35,32,0,11
	.byte	'Rte_QEvType',0,17,141,3,3
	.word	11580
	.byte	21
	.byte	'Rte_QMSIType',0,17,145,3,16,48,10
	.byte	'cmn',0
	.word	8147
	.byte	24,2,35,0,10
	.byte	'task',0
	.word	10471
	.byte	4,2,35,24,10
	.byte	'mask',0
	.word	140
	.byte	1,2,35,28,10
	.byte	'acnt',0
	.word	10580
	.byte	4,2,35,32,10
	.byte	'msiCounter',0
	.word	10767
	.byte	4,2,35,36,10
	.byte	'msiPending',0
	.word	10835
	.byte	4,2,35,40,10
	.byte	'msiLimit',0
	.word	157
	.byte	2,2,35,44,0,11
	.byte	'Rte_QMSIType',0,17,153,3,3
	.word	11675
	.byte	9,4,52,9,1,29
	.byte	'isEventTrig',0,1
	.word	140
	.byte	1,7,2,35,0,29
	.byte	'isTriggerIpduSendWithMetadata',0,1
	.word	140
	.byte	1,6,2,35,0,29
	.byte	'isGwIpduSend',0,1
	.word	140
	.byte	1,5,2,35,0,29
	.byte	'isModeChangd',0,1
	.word	140
	.byte	1,4,2,35,0,29
	.byte	'sigTransProp',0,1
	.word	140
	.byte	1,3,2,35,0,29
	.byte	'isTimeoutReq',0,1
	.word	140
	.byte	1,2,2,35,0,29
	.byte	'ignoreRepetitions',0,1
	.word	140
	.byte	1,1,2,35,0,0,11
	.byte	'Com_SendIpduInfo',0,4,61,3
	.word	11830
	.byte	9,4,76,9,8,10
	.byte	'TimePeriodFact',0
	.word	157
	.byte	2,2,35,0,10
	.byte	'TimeOffsetFact',0
	.word	157
	.byte	2,2,35,2,10
	.byte	'RepetitionPeriodFact',0
	.word	157
	.byte	2,2,35,4,10
	.byte	'NumOfRepetitions',0
	.word	140
	.byte	1,2,35,6,10
	.byte	'Mode',0
	.word	140
	.byte	1,2,35,7,0,11
	.byte	'Com_TransModeInfo',0,4,93,2
	.word	12050
	.byte	8
	.word	12050
	.byte	6
	.word	12200
	.byte	11
	.byte	'Com_TMConstPtrType',0,4,103,65
	.word	12205
	.byte	9,4,136,1,9,12,10
	.byte	'Init_Val',0
	.word	250
	.byte	4,2,35,0,10
	.byte	'txSignalFields',0
	.word	157
	.byte	2,2,35,4,10
	.byte	'Bit_Pos',0
	.word	140
	.byte	1,2,35,6,10
	.byte	'BitSize',0
	.word	140
	.byte	1,2,35,7,10
	.byte	'IpduRef',0
	.word	140
	.byte	1,2,35,8,10
	.byte	'General',0
	.word	140
	.byte	1,2,35,9,0,11
	.byte	'Com_Prv_xTxSigCfg_tst',0,4,201,1,2
	.word	12237
	.byte	9,4,247,1,9,16,10
	.byte	'Notification_Cbk',0
	.word	1280
	.byte	4,2,35,0,10
	.byte	'Init_Val',0
	.word	250
	.byte	4,2,35,4,10
	.byte	'Bit_Pos',0
	.word	140
	.byte	1,2,35,8,10
	.byte	'SigBuff_Index',0
	.word	140
	.byte	1,2,35,9,10
	.byte	'BitSize',0
	.word	140
	.byte	1,2,35,10,10
	.byte	'IpduRef',0
	.word	140
	.byte	1,2,35,11,10
	.byte	'General',0
	.word	140
	.byte	1,2,35,12,10
	.byte	'rxSignalFields',0
	.word	140
	.byte	1,2,35,13,0,11
	.byte	'Com_Prv_xRxSigCfg_tst',0,4,171,2,2
	.word	12385
	.byte	8
	.word	12385
	.byte	6
	.word	12582
	.byte	11
	.byte	'Com_RxSigConstPtrType',0,4,180,2,68
	.word	12587
	.byte	9,4,211,5,9,24,10
	.byte	'BuffPtr',0
	.word	672
	.byte	4,2,35,0,10
	.byte	'Com_TMConstPtr',0
	.word	12205
	.byte	4,2,35,4,10
	.byte	'Size',0
	.word	157
	.byte	2,2,35,8,10
	.byte	'Timeout_Fact',0
	.word	157
	.byte	2,2,35,10,10
	.byte	'Min_Delay_Time_Fact',0
	.word	157
	.byte	2,2,35,12,10
	.byte	'No_Of_Sig_Ref',0
	.word	157
	.byte	2,2,35,14,10
	.byte	'PdurId',0
	.word	157
	.byte	2,2,35,16,10
	.byte	'TxSigId_Index',0
	.word	140
	.byte	1,2,35,18,10
	.byte	'txIPduFields',0
	.word	157
	.byte	2,2,35,20,10
	.byte	'MainFunctionRef',0
	.word	140
	.byte	1,2,35,22,10
	.byte	'PaddingByte',0
	.word	140
	.byte	1,2,35,23,0,11
	.byte	'Com_Prv_xTxIpduInfoCfg_tst',0,4,162,6,3
	.word	12623
	.byte	8
	.word	12623
	.byte	6
	.word	12902
	.byte	11
	.byte	'Com_TxIpduConstPtrType',0,4,171,6,72
	.word	12907
	.byte	11
	.byte	'Com_Prv_xRxIpduInfoCfg_tst',0,4,197,7,3
	.word	1285
	.byte	11
	.byte	'Com_Prv_xIpduGrpInfoCfg_tst',0,4,224,7,3
	.word	1172
	.byte	9,4,244,7,9,1,10
	.byte	'txSigRAMFields',0
	.word	140
	.byte	1,2,35,0,0,11
	.byte	'Com_TxSignalFlagType',0,4,248,7,2
	.word	13017
	.byte	9,4,167,8,9,1,10
	.byte	'rxSigRAMFields',0
	.word	140
	.byte	1,2,35,0,0,11
	.byte	'Com_RxSignalFlagType',0,4,171,8,2
	.word	13078
	.byte	9,4,135,9,9,16,10
	.byte	'CurrentTxModePtr',0
	.word	12210
	.byte	4,2,35,0,10
	.byte	'Com_MinDelayTick',0
	.word	157
	.byte	2,2,35,4,10
	.byte	'Com_Tick_Tx',0
	.word	157
	.byte	2,2,35,6,10
	.byte	'Com_n_Tick_Tx',0
	.word	157
	.byte	2,2,35,8,10
	.byte	'Com_TickTxTimeout',0
	.word	157
	.byte	2,2,35,10,10
	.byte	'Com_TxFlags',0
	.word	157
	.byte	2,2,35,12,10
	.byte	'Com_n',0
	.word	140
	.byte	1,2,35,14,10
	.byte	'Com_TransMode',0
	.word	140
	.byte	1,2,35,15,0,11
	.byte	'Com_TxIpduRamData',0,4,189,9,3
	.word	13139
	.byte	8
	.word	12050
	.byte	6
	.word	13355
	.byte	6
	.word	13139
	.byte	11
	.byte	'Com_TxIpduRamPtrType',0,4,198,9,62
	.word	13365
	.byte	11
	.byte	'Com_RxIpduRamData',0,4,245,9,2
	.word	1034
	.byte	6
	.word	157
	.byte	9,4,128,10,9,8,10
	.byte	'RxGwQueuePtr',0
	.word	13427
	.byte	4,2,35,0,10
	.byte	'Com_RxGwQueueWrite_ux',0
	.word	140
	.byte	1,2,35,4,10
	.byte	'Com_RxGwQueueRead_ux',0
	.word	140
	.byte	1,2,35,5,0,11
	.byte	'Com_RxGwQueueRAMType',0,4,133,10,2
	.word	13432
	.byte	9,4,138,10,9,4,10
	.byte	'indexGwMapSigDestIdArray',0
	.word	157
	.byte	2,2,35,0,10
	.byte	'destCount',0
	.word	140
	.byte	1,2,35,2,0,11
	.byte	'Com_Prv_xGwMapSigCfg_tst',0,4,142,10,2
	.word	13552
	.byte	9,4,147,10,9,2,10
	.byte	'GwMap_DestId',0
	.word	157
	.byte	2,2,35,0,0,11
	.byte	'Com_Prv_xGwMapSigIdCfg_tst',0,4,150,10,2
	.word	13646
	.byte	9,4,183,10,9,4,10
	.byte	'StartIPduId',0
	.word	140
	.byte	1,2,35,0,10
	.byte	'NumOfIpdus',0
	.word	140
	.byte	1,2,35,1,10
	.byte	'TimeBaseInMs',0
	.word	140
	.byte	1,2,35,2,0,11
	.byte	'Com_MainFunctionCfgType',0,4,188,10,3
	.word	13711
	.byte	9,4,194,10,9,12,10
	.byte	'Com_SigType_pu8',0
	.word	672
	.byte	4,2,35,0,10
	.byte	'Com_SigType_pu16',0
	.word	500
	.byte	4,2,35,4,10
	.byte	'Com_SigType_pu32',0
	.word	586
	.byte	4,2,35,8,0,11
	.byte	'Com_Prv_xRxRamBuf_tst',0,4,253,10,3
	.word	13814
	.byte	11
	.byte	'rba_BswSrv_uint64',0,18,66,28
	.word	1930
	.byte	30
	.byte	'Com_Uninit_Flag',0,19,139,24,45
	.word	2440
	.byte	1,1,31
	.word	1034
	.byte	32,0,30
	.byte	'Com_RxIpduRam_s',0,19,201,24,42
	.word	13982
	.byte	1,1,31
	.word	140
	.byte	32,0,30
	.byte	'Com_IpduCounter_DM',0,19,251,24,30
	.word	14016
	.byte	1,1,30
	.byte	'Com_IpduGrpVector_DM',0,19,148,25,42
	.word	2412
	.byte	1,1,19,1
	.word	140
	.byte	20,0,0,31
	.word	1285
	.byte	32,0,8
	.word	14094
	.byte	30
	.byte	'Com_Prv_xRxIpduCfg_acst',0,19,143,26,57
	.word	14101
	.byte	1,1,31
	.word	1172
	.byte	32,0,8
	.word	14141
	.byte	30
	.byte	'Com_Prv_xIpduGrpCfg_acst',0,19,149,26,57
	.word	14148
	.byte	1,1,31
	.word	140
	.byte	32,0,8
	.word	14189
	.byte	30
	.byte	'Com_Prv_xIPduGrp_IpduRefCfg_au8',0,19,164,26,41
	.word	14196
	.byte	1,1,0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L39:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,36,0,3,8,11,15,62,15,0,0,3,46,1,3,8,32,13,58,15,59,15
	.byte	57,15,73,19,54,15,39,12,0,0,4,5,0,3,8,58,15,59,15,57,15,73,19,0,0,5,11,0,0,0,6,15,0,73,19,0,0,7,46,1,3
	.byte	8,32,13,58,15,59,15,57,15,54,15,39,12,0,0,8,38,0,73,19,0,0,9,19,1,58,15,59,15,57,15,11,15,0,0,10,13,0
	.byte	3,8,73,19,11,15,56,9,0,0,11,22,0,3,8,58,15,59,15,57,15,73,19,0,0,12,21,0,54,15,39,12,0,0,13,46,1,3,8,58
	.byte	15,59,15,57,15,73,19,54,15,39,12,63,12,60,12,0,0,14,46,1,49,19,0,0,15,5,0,49,19,0,0,16,21,0,54,15,0,0
	.byte	17,4,1,58,15,59,15,57,15,11,15,0,0,18,40,0,3,8,28,13,0,0,19,1,1,11,15,73,19,0,0,20,33,0,47,15,0,0,21,19
	.byte	1,3,8,58,15,59,15,57,15,11,15,0,0,22,59,0,3,8,0,0,23,21,1,54,15,39,12,0,0,24,5,0,73,19,0,0,25,23,1,58
	.byte	15,59,15,57,15,11,15,0,0,26,4,1,3,8,58,15,59,15,57,15,11,15,0,0,27,21,0,73,19,54,15,39,12,0,0,28,53,0
	.byte	73,19,0,0,29,13,0,3,8,11,15,73,19,13,15,12,15,56,9,0,0,30,52,0,3,8,58,15,59,15,57,15,73,19,63,12,60,12
	.byte	0,0,31,1,1,73,19,0,0,32,33,0,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L40:
	.word	.L138-.L137
.L137:
	.half	3
	.word	.L140-.L139
.L139:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Bfx\\api\\Bfx_Bit_Inl.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv_Inl.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_EnableRxDm.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Det\\api\\Det.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Platform\\Platform_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Std_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Com\\Com_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Com\\Com_Cfg_Internal.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Can_GeneralTypes.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\RTOS_T\\Gen\\inc\\Os.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Can_17_MCanP\\inc\\Can_17_MCanP.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Type.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Intl.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\rba_BswSrv.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv.h',0,0,0,0,0
.L140:
.L138:
	.sdecl	'.debug_info',debug,cluster('Com_ReceptionDMControl')
	.sect	'.debug_info'
.L41:
	.word	955
	.half	3
	.word	.L42
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_EnableRxDm.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L44,.L43
	.byte	2
	.word	.L37
	.byte	3
	.byte	'Com_ReceptionDMControl',0,1,36,22,1,1,1
	.word	.L36,.L46,.L35
	.byte	4
	.byte	'ipduGroupVector',0,1,36,82
	.word	.L47,.L48
	.byte	5
	.word	.L36,.L46
	.byte	6
	.byte	'RxIPduRamPtr',0,1,40,37
	.word	.L49,.L50
	.byte	6
	.byte	'Index_u16',0,1,41,37
	.word	.L51,.L52
	.byte	6
	.byte	'ByteNo_u16',0,1,43,37
	.word	.L53,.L54
	.byte	7
	.word	.L55,.L56,.L57
	.byte	8
	.word	.L58,.L59
	.byte	8
	.word	.L60,.L61
	.byte	9
	.word	.L62,.L56,.L57
	.byte	6
	.byte	'ErrorId',0,2,254,6,13
	.word	.L63,.L64
	.byte	6
	.byte	'Status',0,2,255,6,13
	.word	.L63,.L65
	.byte	0,0,7
	.word	.L66,.L9,.L67
	.byte	8
	.word	.L68,.L69
	.byte	9
	.word	.L70,.L9,.L67
	.byte	6
	.byte	'IPduRefPtr',0,1,124,57
	.word	.L71,.L72
	.byte	6
	.byte	'IPduGrpConstPtr',0,1,126,57
	.word	.L73,.L74
	.byte	6
	.byte	'Index_u16',0,1,127,57
	.word	.L51,.L75
	.byte	6
	.byte	'NoOfPdus_u16',0,1,128,1,57
	.word	.L51,.L76
	.byte	6
	.byte	'IpduGrpId_u16',0,1,129,1,57
	.word	.L53,.L77
	.byte	6
	.byte	'ByteVal_u8',0,1,130,1,57
	.word	.L63,.L78
	.byte	6
	.byte	'BitOffset_u8',0,1,131,1,57
	.word	.L63,.L79
	.byte	6
	.byte	'PduCounterVal',0,1,132,1,57
	.word	.L63,.L80
	.byte	0,0,7
	.word	.L81,.L82,.L24
	.byte	8
	.word	.L83,.L84
	.byte	8
	.word	.L85,.L86
	.byte	10
	.word	.L87,.L82,.L24
	.byte	0,7
	.word	.L88,.L89,.L90
	.byte	8
	.word	.L91,.L92
	.byte	9
	.word	.L93,.L89,.L90
	.byte	6
	.byte	'RxIPduConstPtr',0,1,204,1,65
	.word	.L94,.L95
	.byte	6
	.byte	'RxIPduRamPtr',0,1,206,1,65
	.word	.L49,.L96
	.byte	0,0,7
	.word	.L97,.L98,.L25
	.byte	8
	.word	.L99,.L100
	.byte	8
	.word	.L101,.L102
	.byte	8
	.word	.L103,.L104
	.byte	9
	.word	.L105,.L98,.L25
	.byte	6
	.byte	'tmp_u8',0,3,250,3,11
	.word	.L63,.L106
	.byte	0,0,7
	.word	.L81,.L23,.L31
	.byte	8
	.word	.L83,.L84
	.byte	8
	.word	.L85,.L86
	.byte	10
	.word	.L87,.L23,.L31
	.byte	0,7
	.word	.L97,.L107,.L30
	.byte	8
	.word	.L99,.L100
	.byte	8
	.word	.L101,.L102
	.byte	8
	.word	.L103,.L104
	.byte	9
	.word	.L105,.L107,.L30
	.byte	6
	.byte	'tmp_u8',0,3,250,3,11
	.word	.L63,.L108
	.byte	0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('Com_ReceptionDMControl')
	.sect	'.debug_abbrev'
.L42:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,52,0,3
	.byte	8,58,15,59,15,57,15,73,16,2,6,0,0,7,29,1,49,16,17,1,18,1,0,0,8,5,0,49,16,2,6,0,0,9,11,1,49,16,17,1,18
	.byte	1,0,0,10,11,0,49,16,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('Com_ReceptionDMControl')
	.sect	'.debug_line'
.L43:
	.word	.L142-.L141
.L141:
	.half	3
	.word	.L144-.L143
.L143:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_EnableRxDm.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv_Inl.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Bfx\\api\\Bfx_Bit_Inl.h',0,0,0,0,0
.L144:
	.byte	5,22,7,0,5,2
	.word	.L36
	.byte	3,35,1,5,51,9
	.half	.L110-.L36
	.byte	3,10,1,5,48,9
	.half	.L145-.L110
	.byte	1,5,62,9
	.half	.L146-.L145
	.byte	1,4,2,5,13,9
	.half	.L56-.L146
	.byte	3,212,6,1,9
	.half	.L112-.L56
	.byte	3,1,1,5,9,9
	.half	.L113-.L112
	.byte	3,3,1,5,5,9
	.half	.L147-.L113
	.byte	1,5,17,7,9
	.half	.L148-.L147
	.byte	3,2,1,5,31,9
	.half	.L149-.L148
	.byte	1,5,10,9
	.half	.L2-.L149
	.byte	3,2,1,5,17,7,9
	.half	.L150-.L2
	.byte	3,2,1,5,38,9
	.half	.L151-.L150
	.byte	1,5,20,9
	.half	.L3-.L151
	.byte	3,8,1,5,5,9
	.half	.L152-.L3
	.byte	1,5,9,7,9
	.half	.L153-.L152
	.byte	3,3,1,5,16,9
	.half	.L109-.L153
	.byte	3,2,1,5,5,9
	.half	.L6-.L109
	.byte	3,2,1,4,1,9
	.half	.L7-.L6
	.byte	3,147,121,1,5,20,7,9
	.half	.L57-.L7
	.byte	3,6,1,5,9,9
	.half	.L115-.L57
	.byte	3,1,1,5,30,7,9
	.half	.L154-.L115
	.byte	3,2,1,5,28,9
	.half	.L155-.L154
	.byte	1,5,43,9
	.half	.L114-.L155
	.byte	1,5,23,9
	.half	.L156-.L114
	.byte	3,1,1,5,58,9
	.half	.L157-.L156
	.byte	3,2,1,5,34,9
	.half	.L11-.L157
	.byte	3,2,1,5,32,9
	.half	.L111-.L11
	.byte	1,5,49,9
	.half	.L158-.L111
	.byte	1,5,47,9
	.half	.L159-.L158
	.byte	1,5,27,9
	.half	.L160-.L159
	.byte	3,1,1,5,58,9
	.half	.L10-.L160
	.byte	3,125,1,5,20,7,9
	.half	.L9-.L10
	.byte	3,204,0,1,5,60,9
	.half	.L116-.L9
	.byte	1,5,64,9
	.half	.L13-.L116
	.byte	3,2,1,5,63,9
	.half	.L117-.L13
	.byte	1,5,13,9
	.half	.L161-.L117
	.byte	1,5,33,9
	.half	.L162-.L161
	.byte	1,5,9,9
	.half	.L163-.L162
	.byte	1,5,68,7,9
	.half	.L118-.L163
	.byte	3,3,1,5,26,9
	.half	.L164-.L118
	.byte	3,1,1,5,17,9
	.half	.L15-.L164
	.byte	3,7,1,5,66,7,9
	.half	.L165-.L15
	.byte	3,3,1,5,76,9
	.half	.L120-.L165
	.byte	1,5,58,9
	.half	.L166-.L120
	.byte	3,13,1,5,70,9
	.half	.L167-.L166
	.byte	1,5,40,9
	.half	.L168-.L167
	.byte	1,5,100,9
	.half	.L169-.L168
	.byte	1,5,109,9
	.half	.L122-.L169
	.byte	1,5,100,9
	.half	.L17-.L122
	.byte	1,5,39,9
	.half	.L18-.L17
	.byte	3,2,1,9
	.half	.L123-.L18
	.byte	3,2,1,5,54,9
	.half	.L124-.L123
	.byte	3,2,1,5,45,9
	.half	.L125-.L124
	.byte	3,2,1,5,26,9
	.half	.L20-.L125
	.byte	3,4,1,5,62,9
	.half	.L170-.L20
	.byte	1,9
	.half	.L171-.L170
	.byte	3,127,1,5,35,9
	.half	.L172-.L171
	.byte	3,3,1,5,37,9
	.half	.L173-.L172
	.byte	3,1,1,5,45,9
	.half	.L19-.L173
	.byte	3,121,1,5,30,7,9
	.half	.L16-.L19
	.byte	3,11,1,5,28,9
	.half	.L126-.L16
	.byte	3,1,1,5,38,9
	.half	.L174-.L126
	.byte	3,2,1,5,62,7,9
	.half	.L175-.L174
	.byte	3,3,1,5,45,9
	.half	.L176-.L175
	.byte	1,5,71,9
	.half	.L14-.L176
	.byte	3,74,1,5,60,9
	.half	.L12-.L14
	.byte	1,5,27,7,9
	.half	.L67-.L12
	.byte	3,65,1,5,24,9
	.half	.L177-.L67
	.byte	1,9
	.half	.L127-.L177
	.byte	3,2,1,5,60,9
	.half	.L128-.L127
	.byte	1,5,22,9
	.half	.L22-.L128
	.byte	3,7,1,5,17,9
	.half	.L178-.L22
	.byte	3,123,1,5,13,9
	.half	.L179-.L178
	.byte	1,4,3,5,32,7,9
	.half	.L82-.L179
	.byte	3,174,2,1,5,36,9
	.half	.L180-.L82
	.byte	1,5,21,9
	.half	.L181-.L180
	.byte	1,5,48,9
	.half	.L182-.L181
	.byte	1,5,5,9
	.half	.L183-.L182
	.byte	1,4,1,5,17,9
	.half	.L24-.L183
	.byte	3,215,125,1,5,22,7,9
	.half	.L89-.L24
	.byte	3,135,1,1,5,23,9
	.half	.L129-.L89
	.byte	3,3,1,5,48,9
	.half	.L130-.L129
	.byte	3,5,1,5,33,9
	.half	.L184-.L130
	.byte	1,5,76,7,9
	.half	.L185-.L184
	.byte	1,5,94,9
	.half	.L186-.L185
	.byte	1,5,31,9
	.half	.L27-.L186
	.byte	1,5,21,9
	.half	.L90-.L27
	.byte	3,245,126,1,4,3,5,14,9
	.half	.L98-.L90
	.byte	3,167,3,1,5,26,9
	.half	.L132-.L98
	.byte	1,5,21,9
	.half	.L28-.L132
	.byte	1,5,15,9
	.half	.L29-.L28
	.byte	3,2,1,5,33,9
	.half	.L187-.L29
	.byte	1,5,37,9
	.half	.L188-.L187
	.byte	1,5,31,9
	.half	.L189-.L188
	.byte	1,5,21,9
	.half	.L190-.L189
	.byte	1,5,66,9
	.half	.L191-.L190
	.byte	1,5,48,9
	.half	.L133-.L191
	.byte	1,5,11,9
	.half	.L192-.L133
	.byte	1,4,1,5,17,9
	.half	.L25-.L192
	.byte	3,211,124,1,4,3,5,32,9
	.half	.L23-.L25
	.byte	3,169,2,1,5,36,9
	.half	.L193-.L23
	.byte	1,5,21,9
	.half	.L194-.L193
	.byte	1,5,48,9
	.half	.L195-.L194
	.byte	1,5,5,9
	.half	.L196-.L195
	.byte	1,4,1,5,17,9
	.half	.L31-.L196
	.byte	3,225,125,1,5,21,7,9
	.half	.L197-.L31
	.byte	3,4,1,4,3,5,14,9
	.half	.L107-.L197
	.byte	3,157,3,1,5,26,9
	.half	.L134-.L107
	.byte	1,5,21,9
	.half	.L33-.L134
	.byte	1,5,15,9
	.half	.L34-.L33
	.byte	3,2,1,5,33,9
	.half	.L198-.L34
	.byte	1,5,37,9
	.half	.L199-.L198
	.byte	1,5,31,9
	.half	.L200-.L199
	.byte	1,5,21,9
	.half	.L201-.L200
	.byte	1,5,66,9
	.half	.L202-.L201
	.byte	1,5,48,9
	.half	.L135-.L202
	.byte	1,5,11,9
	.half	.L203-.L135
	.byte	1,4,1,5,25,9
	.half	.L30-.L203
	.byte	3,228,124,1,5,71,9
	.half	.L204-.L30
	.byte	3,104,1,5,60,9
	.half	.L21-.L204
	.byte	1,5,1,7,9
	.half	.L8-.L21
	.byte	3,28,1,7,9
	.half	.L45-.L8
	.byte	0,1,1
.L142:
	.sdecl	'.debug_ranges',debug,cluster('Com_ReceptionDMControl')
	.sect	'.debug_ranges'
.L44:
	.word	-1,.L36,0,.L45-.L36,0,0
	.sdecl	'.debug_loc',debug,cluster('Com_ReceptionDMControl')
	.sect	'.debug_loc'
.L61:
	.word	0,0
.L79:
	.word	-1,.L36,.L15-.L36,.L119-.L36
	.half	1
	.byte	81
	.word	.L121-.L36,.L17-.L36
	.half	1
	.byte	84
	.word	.L18-.L36,.L16-.L36
	.half	1
	.byte	84
	.word	.L126-.L36,.L14-.L36
	.half	1
	.byte	81
	.word	0,0
.L86:
	.word	0,0
.L102:
	.word	0,0
.L54:
	.word	-1,.L36,.L115-.L36,.L9-.L36
	.half	1
	.byte	95
	.word	0,0
.L78:
	.word	-1,.L36,.L118-.L36,.L17-.L36
	.half	5
	.byte	144,32,157,32,0
	.word	.L18-.L36,.L14-.L36
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L35:
	.word	-1,.L36,0,.L46-.L36
	.half	2
	.byte	138,0
	.word	0,0
.L84:
	.word	0,0
.L100:
	.word	0,0
.L64:
	.word	-1,.L36,.L112-.L36,.L109-.L36
	.half	1
	.byte	87
	.word	0,0
.L74:
	.word	-1,.L36,.L123-.L36,.L20-.L36
	.half	1
	.byte	100
	.word	0,0
.L72:
	.word	-1,.L36,.L124-.L36,.L16-.L36
	.half	1
	.byte	101
	.word	0,0
.L52:
	.word	-1,.L36,.L128-.L36,.L28-.L36
	.half	1
	.byte	83
	.word	.L29-.L36,.L33-.L36
	.half	1
	.byte	83
	.word	.L34-.L36,.L8-.L36
	.half	1
	.byte	83
	.word	0,0
.L75:
	.word	-1,.L36,.L116-.L36,.L17-.L36
	.half	1
	.byte	85
	.word	.L18-.L36,.L28-.L36
	.half	1
	.byte	85
	.word	.L29-.L36,.L33-.L36
	.half	1
	.byte	85
	.word	.L34-.L36,.L8-.L36
	.half	1
	.byte	85
	.word	0,0
.L77:
	.word	-1,.L36,.L120-.L36,.L17-.L36
	.half	1
	.byte	82
	.word	.L18-.L36,.L20-.L36
	.half	1
	.byte	82
	.word	0,0
.L92:
	.word	0,0
.L76:
	.word	-1,.L36,.L125-.L36,.L16-.L36
	.half	1
	.byte	95
	.word	0,0
.L80:
	.word	-1,.L36,.L122-.L36,.L17-.L36
	.half	1
	.byte	83
	.word	.L18-.L36,.L16-.L36
	.half	1
	.byte	83
	.word	0,0
.L95:
	.word	-1,.L36,.L129-.L36,.L28-.L36
	.half	1
	.byte	101
	.word	.L29-.L36,.L25-.L36
	.half	1
	.byte	101
	.word	0,0
.L50:
	.word	-1,.L36,.L127-.L36,.L28-.L36
	.half	1
	.byte	100
	.word	.L29-.L36,.L33-.L36
	.half	1
	.byte	100
	.word	.L34-.L36,.L8-.L36
	.half	1
	.byte	100
	.word	0,0
.L96:
	.word	-1,.L36,.L130-.L36,.L131-.L36
	.half	1
	.byte	111
	.word	0,0
.L65:
	.word	-1,.L36,.L113-.L36,.L109-.L36
	.half	5
	.byte	144,32,157,32,0
	.word	.L6-.L36,.L114-.L36
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L104:
	.word	0,0
.L48:
	.word	-1,.L36,0,.L109-.L36
	.half	1
	.byte	100
	.word	.L110-.L36,.L111-.L36
	.half	1
	.byte	108
	.word	.L111-.L36,.L10-.L36
	.half	1
	.byte	111
	.word	.L13-.L36,.L117-.L36
	.half	1
	.byte	108
	.word	0,0
.L69:
	.word	0,0
.L59:
	.word	0,0
.L108:
	.word	-1,.L36,.L134-.L36,.L33-.L36
	.half	1
	.byte	95
	.word	.L34-.L36,.L135-.L36
	.half	1
	.byte	95
	.word	0,0
.L106:
	.word	-1,.L36,.L132-.L36,.L28-.L36
	.half	5
	.byte	144,32,157,32,0
	.word	.L29-.L36,.L133-.L36
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
	.sdecl	'.debug_frame',debug
	.sect	'.debug_frame'
.L205:
	.word	48
	.word	-1
	.byte	3,0,2,1,27,12,26,0,8,27,8,26,8,28,8,29,8,30,8,31,8,34,8,35,8,32,8,33,8,16,8,17,8,24,8,25,8,36,8,37,8,38
	.byte	8,39
	.sdecl	'.debug_frame',debug,cluster('Com_ReceptionDMControl')
	.sect	'.debug_frame'
	.word	12
	.word	.L205,.L36,.L46-.L36

; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   224                                                                               RxIPduConstPtr->FirstTimeout_Factor;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   225  #endif /* #ifdef COM_RxIPduTimeout */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   226  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   227  #ifdef COM_RxSigUpdateTimeout
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   228      /* If this IPDU has signals with update-bits , initialise the pointers.
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   229       * Separate deadline monitoring should be performed for signals with update-bit
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   230       */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   231      if (RxIPduConstPtr->SignalTimeout_Ref != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   232      {
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   233          /* Get the number of signals with update-bit & configured timeout, within this IPDU */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   234          NoOfSigOrSigGrp_ui  = RxIPduConstPtr->SignalTimeout_Ref->numWithUpdateBit;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   235          /* Initialise pointer to Com_SignalTimeoutInfo */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   236          SigTimeOutConfigPtr = RxIPduConstPtr->SignalTimeout_Ref->TimeoutInfo_Ref;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   237          /* Initialise pointer to signal RAM timer */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   238          SigTimeOutTicksPtr  = RxIPduConstPtr->SignalTimeout_Ref->TimeoutTicks_p;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   239  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   240          SchM_Enter_Com_RxSigToTicks();
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   241  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   242          for (Idx_Sig_ui = NoOfSigOrSigGrp_ui; Idx_Sig_ui != 0u; Idx_Sig_ui--)
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   243          {
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   244              /* If FirstTimeOutFactor is not configured then load timer with COM_RXTIMER_MAX(0xFFFF)
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   245               * If FirstTimeOutFactor is configured then load the ComFirstTimeout value
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   246               */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   247              (*SigTimeOutTicksPtr) = (SigTimeOutConfigPtr->First_Timeout == 0) ? COM_RXTIMER_MAX :
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   248                                                                                  SigTimeOutConfigPtr->First_Timeout;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   249  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   250              /* Increment pointers to refer next signal with update-bit(within this IPDU) */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   251              SigTimeOutTicksPtr++;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   252              SigTimeOutConfigPtr++;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   253  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   254          }/*End of for loop*/
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   255  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   256          SchM_Exit_Com_RxSigToTicks();
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   257      }
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   258  #endif /* #ifdef COM_RxSigUpdateTimeout */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   259  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   260  #ifdef COM_RxSigGrpUpdateTimeout
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   261      /* If this IPDU has signal groups with update-bits , initialise the pointers.
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   262       * Separate deadline monitoring should be performed for signal groups with update-bit
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   263       */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   264      if (RxIPduConstPtr->SignalGrpTimeout_Ref != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   265      {
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   266          /* Get the number of signals with update-bit & configured timeout, within this IPDU */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   267          NoOfSigOrSigGrp_ui  = RxIPduConstPtr->SignalGrpTimeout_Ref->numWithUpdateBit;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   268          /* Initialise pointer to Com_SignalGrpTimeoutInfo */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   269          SigTimeOutConfigPtr = RxIPduConstPtr->SignalGrpTimeout_Ref->TimeoutInfo_Ref;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   270          /* Initialise pointer to signalGroup timer */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   271          SigTimeOutTicksPtr = RxIPduConstPtr->SignalGrpTimeout_Ref->TimeoutTicks_p;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   272  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   273          SchM_Enter_Com_RxSigGrpToTicks();
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   274  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   275          for (Idx_Sig_ui = NoOfSigOrSigGrp_ui; Idx_Sig_ui != 0u; Idx_Sig_ui--)
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   276          {
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   277              /* If FirstTimeOutFactor is not configured then load timer with COM_RXTIMER_MAX(0xFFFF)
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   278               * If FirstTimeOutFactor is configured then load the ComFirstTimeout value
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   279               */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   280              (*SigTimeOutTicksPtr) = (SigTimeOutConfigPtr->First_Timeout == 0) ? COM_RXTIMER_MAX :
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   281                                                                                  SigTimeOutConfigPtr->First_Timeout;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   282  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   283              /* Increment pointers to refer next signal group with update-bit(within this IPDU)
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   284               * If no next signal group with update-bit is present in the IPDU, then the if() check fails and
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   285               * the code inside if() block is not executed.
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   286               */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   287              SigTimeOutConfigPtr++;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   288              SigTimeOutTicksPtr++;
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   289          }/*End of for loop*/
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   290  
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   291          SchM_Exit_Com_RxSigGrpToTicks();
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   292      }
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   293  #endif /* #ifdef COM_RxSigGrpUpdateTimeout */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   294  }
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   295  #endif /* #if defined (COM_RxIPduTimeout) || defined (COM_RxSigUpdateTimeout) || defined (COM_RxSigGrpUpdateTimeout) */
; BSW\src\BSW\Gen\Com\src\Com_EnableRxDm.c	   296  

	; Module end
