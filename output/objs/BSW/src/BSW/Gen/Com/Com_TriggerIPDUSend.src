	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 19053136 SN 09001910"
	.compiler_invocation	"ctc -f cc14668a -c99 --integer-enumeration -D__CPU__=tc27x -D__CPU_TC27X__ --core=tc1.6.x --eabi-compliant --fp-model=-float -D_TASKING_C_TRICORE_=1 -I.\\output\\inc -g2 -t4 --language=-comments,-gcc,+volatile,-strings --default-near-size=0 -O2ROPYGKLF-predict --default-a1-size=0 --default-a0-size=0 --source --switch=auto -o output\\objs\\BSW\\src\\BSW\\Gen\\Com\\Com_TriggerIPDUSend.src BSW\\src\\BSW\\Gen\\Com\\src\\Com_TriggerIPDUSend.c"
	.compiler_name		"ctc"
	;source	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_TriggerIPDUSend.c'

	
$TC16X
	
	.sdecl	'.text.Com_TriggerIPDUSend.Com_TriggerIPDUSend',code,cluster('Com_TriggerIPDUSend')
	.sect	'.text.Com_TriggerIPDUSend.Com_TriggerIPDUSend'
	.align	2
	
	.global	Com_TriggerIPDUSend

; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	     1  
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	     2  
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	     3  /**************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	     4  /* Preprocessor includes                                                                          */
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	     5  /**************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	     6  #include "Com_Prv.h"
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	     7  #include "Com_Prv_Inl.h"
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	     8  /**************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	     9  /* Global functions (declared in header files )                                                   */
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    10  /**************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    11  /***************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    12   Function name    : Com_TriggerIPDUSend
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    13   Syntax           : void Com_TriggerIPDUSend(PduIdType PduId)
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    14   Description      : Service used within the Ipdu-Callout.
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    15   The I-PDU with the given ID is triggered for transmission
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    16   Parameter        : PduId-> Id of the Tx ipdu
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    17   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    18   ***************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    19  #define COM_START_SEC_CODE
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    20  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    21  FUNC(void, COM_CODE) Com_TriggerIPDUSend(VAR(PduIdType, AUTOMATIC) PduId)
; Function Com_TriggerIPDUSend
.L15:
Com_TriggerIPDUSend:	.type	func
	mov	d8,d4
.L60:

; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    22  {
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    23  #ifdef COM_TxIPduTimeOut
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    24      Com_TxIpduConstPtrType TxIPduConstPtr; /* Loca pointer to Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    25  #endif
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    26      Com_TxIpduRamPtrType TxIpduRamPtr; /* Local pointer to the Tx ipdu status structure */
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    27  
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    28      /* Call DET Function to check for the DET Errors COM_E_UNINIT and COM_E_PARAM */
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    29  #if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    30      if ( Com_Prv_DETCheck_Param( (PduId >= COM_GET_NUM_TX_IPDU), COMServiceId_TriggerIpduSend) )
	ge.u	d0,d8,#4
.L75:
	mov	d6,#23
.L33:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     1  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     2  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     3  #ifndef COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     4  #define COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     5  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     6  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     7   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     8   * Includes
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     9   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    10  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    11  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    12  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    13  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    17  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    18  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    19  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    20  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    21   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    22   * Type definitions
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    23   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    24  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    25  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    26  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    27  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    28   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    29   * Variables
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    30   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    31  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    32  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    33  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    34  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    35   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    36   * Extern declarations
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    37   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    38  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    39  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    40   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    41   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    42   * Inline function sets TMS data in to be accessesd via CurrentTxModePtr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    43   * after evaluating TMS mode for the IPdu
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    44   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    45  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    46  FUNC(void, COM_CODE) Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    47                                  Com_TxIpduRamPtrType                TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    48                                  Com_TxIpduConstPtrType              TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    49                                  VAR(uint16,AUTOMATIC)               TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    50                                  VAR(boolean,AUTOMATIC)              ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    51                                              );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    52  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    53  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    54   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    55   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    56   * Inline function to update Rx-GroupSignal application buffers
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    57   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    58  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    59  FUNC(void, COM_CODE) Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    60                                  Com_RxSigConstPtrType               RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    61                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    62                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    63                                               );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    64  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    65  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    66   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    67   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    68   * Inline function to update Rx-GroupSignal secondary buffers
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    69   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    70  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    71  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    72  FUNC(void, COM_CODE) Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    73                                  Com_RxGrpSigConstPtrType            RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    74                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    75                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    76                                                          );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    77  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    78  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    79  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    80   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    81   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    82   * Inline function to initialize signal intial value into the provided IPdu buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    83   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    84  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    85  FUNC(void, COM_CODE) Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    86                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    87                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    88                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    89                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    90                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    91                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    92                                                              );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    93  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    94  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    95   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    96   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    97   * Inline function to initialize Rx-signal group with initial values
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    98   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    99  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   100  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   101  FUNC(void, COM_CODE) Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   102                                  Com_RxSigGrpConstPtrType            RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   103                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   104                                                  );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   105  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   106  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   107  #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   108  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxNotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   109  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxErrNotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   110  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxTONotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   111  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallRxTONotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   112  #endif /* #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   113  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   114  /* Inline function to check for the RxIPdu and TxIpdu status*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   115  LOCAL_INLINE boolean Com_CheckRxIPduStatus(PduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   116  LOCAL_INLINE boolean Com_CheckTxIPduStatus(PduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   117  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   118  #if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   119  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   120  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Void(uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   121  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   122  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Ptr(boolean isInValidPtr, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   123  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Param_Ptr(boolean isInValidParam, boolean isInValidPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   124                                                                  uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   125  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Ptr_Only(boolean isInValidPtr, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   126  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Param_Only(boolean isInValidParam, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   127  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   128  #endif /*  #if (COM_CONFIGURATION_USE_DET == STD_ON) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   129  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   130  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   131  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   132  LOCAL_INLINE FUNC(void, COM_CODE) Com_CopyTxGroupSignalData( Com_SignalIdType    GrpSignalId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   133                                                               Com_SigMaxType      TxGrpSig_NewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   134                                                               Com_MainFuncType    TxMainFuncId );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   135  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   136  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   137  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   138   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   139   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   140   * Inline function to handle gateway and non-gateway use-case for tx-signal/signalGroup
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   141   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   142  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_ProceedToSendIpdu(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   143                                                  VAR(Com_IpduIdType, AUTOMATIC)          ComTxPduId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   144                                                  VAR(Com_SendIpduInfo, AUTOMATIC)        sendIpduFlag_u16
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   145                                                             );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   146  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   147  #ifdef COM_TxFilters
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   148  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_CheckModeChange(VAR(Com_IpduIdType, AUTOMATIC) TxIpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   149  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   150  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   151  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   152  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   153   * Inline Function Definition
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   154   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   155  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   156  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   157   Function name    : Com_SetCurrentTxModePtr [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   158   Syntax           : void Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   159                                  Com_TxIpduRamPtrType    TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   160                                  Com_TxIpduConstPtrType  TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   161                                  uint16                  TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   162                                  boolean                 ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   163                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   164   Description      : Inline function sets TMS data in to be accessesd via CurrentTxModePtr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   165                      after evaluating TMS mode for the IPdu
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   166  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   167                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   168                       * Mode                  |    Configuration details                              | Value|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   169                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   170                       * COM_MODE_VALID        |    Both the TRUE and FALSE modes are configured.      |    00|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   171                       * COM_TRUEMODE_VALID    |    Only TRUE mode is configured                       |    01|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   172                       * COM_FALSEMODE_VALID   |    Only FALSE mode is configured                      |    10|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   173                       * COM_MODE_INVALID      |    Both the TRUE and FALSE mode are not configured    |    11|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   174                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   175                      This INLINE function checks the TMS generated values against the requested mode and performs action
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   176                      |-------------|--------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   177                      |ModeRequested|Configured Mode values   |         Description                                           :      Action to be taken                |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   178                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   179                      |    0       |      0        |      0   |  FALSE mode is requested and IPdu TMS is COM_MODE_VALID         : Increment to the false mode data     |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   180                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   181                      |    0       |      0        |      1   |  FALSE mode is requested and IPdu TMS is COM_TRUEMODE_VALID     : Point to NONE mode data              |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   182                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   183                      |    0       |      1        |      0   |  FALSE mode is requested and IPdu TMS is COM_FALSEMODE_VALID     : Do nothing                          |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   184                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   185                      |    0       |      1        |      1   |  FALSE mode is requested and IPdu TMS is COM_MODE_INVALID     : Do nothing                             |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   186                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   187                      |    1       |      0        |      0   |  TRUE mode is requested and IPdu TMS is COM_MODE_VALID         : Do nothing                            |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   188                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   189                      |    1       |      0        |      1   |  TRUE mode is requested and IPdu TMS is COM_TRUEMODE_VALID     : Do nothing                            |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   190                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   191                      |    1       |      1        |      0   |  TRUE mode is requested and IPdu TMS is COM_FALSEMODE_VALID     : Point to NONE mode data              |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   192                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   193                      |    1       |      1        |      1   |  TRUE mode is requested and IPdu TMS is COM_MODE_INVALID         : Do nothing                          |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   194                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   195  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   196                      where 0 in column 1 stands for FALSE mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   197                      and   1 in column 1 stands for TRUE mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   198  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   199   Parameter        : TxIpduRamPtr    - pointer to Txipdu ram data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   200                    : TxIPduConstPtr  - pointer to Txipdu Rom data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   201                    : TMSStatus       - pointer to transmission mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   202                    : ModeRequested   - mode requested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   203   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   204   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   205  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   206  FUNC(void, COM_CODE) Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   207                                  Com_TxIpduRamPtrType                TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   208                                  Com_TxIpduConstPtrType              TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   209                                  VAR(uint16,AUTOMATIC)               TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   210                                  VAR(boolean,AUTOMATIC)              ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   211                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   212  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   213      /* Get the latest TM pointer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   214      TxIpduRamPtr->CurrentTxModePtr = TxIPduConstPtr->Com_TMConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   215  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   216      if(ModeRequested == COM_FALSE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   217      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   218          if((TMSStatus) == COM_TRUEMODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   219          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   220              /*If yes,load NONE mode data */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   221              TxIpduRamPtr->CurrentTxModePtr = &Com_NONE_TransModeInfo ;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   222          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   223          if((TMSStatus) == COM_MODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   224          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   225              /*Increment to FALSE mode data, if the FALSE mode is configured */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   226              TxIpduRamPtr->CurrentTxModePtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   227          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   228      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   229      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   230      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   231          if((TMSStatus) == COM_FALSEMODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   232          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   233              TxIpduRamPtr->CurrentTxModePtr = &Com_NONE_TransModeInfo ;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   234          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   235      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   236  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   237  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   238  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   239   Function name    : Com_UpdateRxGroupSignalSecondBuffer [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   240   Syntax           : void Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   241                                  Com_RxGrpSigConstPtrType    RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   242                                  Com_SigMaxType              RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   243                                  Com_MainFuncType            RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   244                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   245   Description      : Inline function copy Group signal value into the Group signal Second buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   246   Parameter        : RxGrpSigConstPtr - pointer to RxGroupSignal configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   247                    : RxNewVal         - latest RxGroupSignal data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   248                    : RxMainFuncId     - Internally generated Rx-MainFunction-Id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   249   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   250   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   251  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   252  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   253  FUNC(void, COM_CODE) Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   254                                  Com_RxGrpSigConstPtrType            RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   255                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   256                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   257                                                          )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   258  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   259      VAR(uint8,AUTOMATIC)    Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   260  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   261      Type = Com_GetValue(RXGRPSIG,_TYPE,RxGrpSigConstPtr->rxGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   262  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   263      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   264      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   265      case 0x00u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   266          /* UINT08 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   267          COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint8)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   268          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   269  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   270      case 0x01u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   271          /* UINT16 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   272          COM_GET_SECRXGRPSIGTYPEU16_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint16)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   273          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   274  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   275      case 0x02u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   276          /* UINT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   277          /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   278      case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   279          /* FLOAT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   280          /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   281          COM_GET_SECRXGRPSIGTYPEU32_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint32)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   282          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   283  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   284  #ifdef COM_RXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   285      case 0x08u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   286          /* UINT64/SINT64 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   287          COM_GET_SECRXGRPSIGTYPEU64_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   288          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   289  #endif /* #ifdef COM_RXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   290  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   291      case 0x03u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   292          /*Boolean Signal*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   293          COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint8)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   294          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   295  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   296      case 0x04u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   297          /* UINT8_N signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   298          Com_ByteCopyInit(&COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index),
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   299                           (uint32)RxNewVal,RxGrpSigConstPtr->BitSize);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   300          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   301      default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   302          /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   303           * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are allowed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   304           * to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   305           */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   306          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   307  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   308      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   309  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   310  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   311  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   312  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   313   Function name    : Com_UpdateRxSignalBuffer [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   314   Syntax           : void Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   315                                  Com_RxSigConstPtrType   RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   316                                  Com_SigMaxType          RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   317                                  Com_MainFuncType        RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   318                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   319   Description      : Inline function to copy signal value into the signal buffer and
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   320                      is used when signal value as a variable is being passed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   321   Parameter        : RxSigConstPtr - pointer to RxSignal configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   322                    : RxNewVal_Sig  - latest RxSignal data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   323                    : RxMainFuncId  - Internally generated Rx-MainFunction-Id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   324   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   325   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   326  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   327  FUNC(void, COM_CODE) Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   328                                  Com_RxSigConstPtrType               RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   329                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   330                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   331                                               )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   332  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   333      VAR(uint8,AUTOMATIC)    Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   334  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   335      Type = Com_GetValue(GEN,_TYPE,RxSigConstPtr->General);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   336  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   337      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   338      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   339      case 0x00u:     /* COM_UINT8 & COM_SINT8 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   340      case (COM_BOOLEAN >> 1):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   341          COM_GET_SIGTYPEUINT8_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint8)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   342          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   343  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   344      case 0x01u:     /* COM_UINT16 & COM_SINT16 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   345          COM_GET_SIGTYPEUINT16_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint16)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   346          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   347  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   348      case 0x02u:     /* COM_UINT32 & COM_SINT32 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   349  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   350          /* COM_FLOAT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   351  #ifdef COM_FLOAT32SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   352      case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   353  #endif /* #ifdef COM_FLOAT32SUPP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   354  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   355          COM_GET_SIGTYPEUINT32_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint32)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   356          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   357  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   358  #ifdef COM_RXSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   359      case 0x08u:     /* COM_UINT64 & COM_SINT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   360          COM_GET_SIGTYPEUINT64_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   361          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   362  #endif /* #if defined(COM_RXSIG_INT64) && defined(COM_TXSIG_INT64) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   363  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   364      case 0x04u:     /* COM_UINT8_N */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   365          Com_ByteCopyInit(&COM_GET_SIGTYPEUINT8_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index),
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   366                           (uint32)RxNewVal_Sig,RxSigConstPtr->BitSize);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   367          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   368      default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   369          /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   370           * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are allowed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   371           * to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   372           */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   373          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   374      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   375  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   376  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   377  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   378   Function name    : Com_InitializePduBuffWithSignalInitValue [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   379   Syntax           : void Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   380                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   381                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   382                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   383                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   384                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   385                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   386                                                                   )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   387   Description      : Inline function to call required interface to pack signal data into Ipdu buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   388   Parameter        : BuffPtr     - pointer to (SignalGroup)IPdu Buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   389                    : SigInitVal  - (Group)Signal InitValue
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   390                    : SigBitPos   - (Group)Signal Bit Position
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   391                    : SigBitSize  - (Group)Signal Bit Size
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   392                    : SigType     - (Group)Signal Type
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   393                    : SigEndianess- (Group)Signal Endianness
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   394   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   395   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   396  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   397  FUNC(void, COM_CODE) Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   398                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   399                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   400                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   401                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   402                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   403                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   404                                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   405  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   406      if ( SigType != (uint8)COM_UINT8_N )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   407      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   408  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   409  #if (defined(COM_TXSIG_FLOAT64SUPP) || defined(COM_TXGRPSIG_FLOAT64SUPP) ||\ 
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   410      (defined(COM_RX_SIGNALGROUP_ARRAY) && defined(COM_RXGRPSIG_FLOAT64SUPP)))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   411          if ( SigType == COM_FLOAT64 )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   412          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   413              /* Convert the float value into 32 bit stream and then pack the value */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   414              /* Com_PackFloatSignal(TxSigConstPtr->General.Endianess,TxSigConstPtr->Bit_Pos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   415                                     Com_getfloat64InitValue(SigNewVal), TxIPduConstPtr->BuffPtr); */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   416              Com_PackFloatSignal( SigEndianess, SigBitPos, Com_getfloat64InitValue(SigInitVal), BuffPtr );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   417          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   418          else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   419  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   420  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   421          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   422              /* Pack the signal with Initial Value */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   423              /* Com_PackSignal(TxSigConstPtr->General.Endianess,TxSigConstPtr->Bit_Pos,TxSigConstPtr->BitSize,SigNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   424               *                TxIPduConstPtr->BuffPtr);*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   425              Com_PackSignal( SigEndianess, SigBitPos, SigBitSize, SigInitVal, BuffPtr );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   426          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   427      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   428      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   429      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   430          PduLengthType ByteOffset_uo;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   431          /* Find the starting byte position(ByteNo_uo) of Signal in the IPDU buffer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   432          ByteOffset_uo = ( PduLengthType )( SigBitPos >> 3 );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   433  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   434          /* Now copy the Signal into the IPDU buffer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   435          Com_ByteCopyInit( (BuffPtr + ByteOffset_uo), (uint32)SigInitVal, SigBitSize );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   436      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   437  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   438  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   439  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   440   Function name    : Com_Prv_SigGrpReplaceToInit
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   441   Syntax           : void Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   442                                          Com_RxSigGrpConstPtrType  RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   443                                          Com_MainFuncType          RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   444                                                      )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   445   Description      : If the SigGrp is enabled with ArrayAccess, RxSigGrpBuffer will be packed with
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   446                      GroupSignal Init Values OR else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   447                      GroupSignals Shadow buffers will be replaced with its Init Values
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   448   Parameter        : RxSigGrpConstPtr - pointer to RxSignalGroup configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   449                    : RxMainFuncId     - Internally generated RxMainFunction-ID
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   450   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   451   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   452  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   453  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   454                                                  Com_RxSigGrpConstPtrType        RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   455                                                  VAR(Com_MainFuncType,AUTOMATIC) RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   456                                                               )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   457  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   458      Com_RxGrpSigConstPtrType      RxGrpSigConstPtr;      /* Local pointer to Rx GroupSignal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   459  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   460      Com_RxSigGrpArrayConstPtrType RxSigGrpArrayConstPtr; /* Local pointer to Rx SignalGroup Array configuration  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   461      uint8                       * RxSigGrpArrayBufRamPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   462      PduLengthType                 SigGrpBitOffset;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   463  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   464      VAR(uint16_least, AUTOMATIC)  index_ui;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   465      VAR(Com_SigMaxType, AUTOMATIC) SigValue;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   466  # if (defined(COM_RX_SIGNALGROUP_ARRAY) || defined(COM_RXGRPSIG_FLOAT64SUPP) || defined(COM_RXGRPSIG_INT64))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   467      VAR(uint8, AUTOMATIC)         SigType;  /* Signal Type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   468  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   469  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   470      boolean                       ConstIsSigGrpOfArrayType_b;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   471  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   472      ConstIsSigGrpOfArrayType_b = Com_GetValue(RXSIGGRP,_ARRAYACCESS,RxSigGrpConstPtr->rxSignalGrpFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   473  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   474      if ( ConstIsSigGrpOfArrayType_b )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   475      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   476          RxSigGrpArrayConstPtr  = COM_GET_RXSIGGRP_ARRAY_CONSTDATA( RxSigGrpConstPtr->SigGrpArray_Index );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   477  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   478          RxSigGrpArrayBufRamPtr = &COM_GET_RXSIGGRP_ARRAY_BUFF(RxMainFuncId, RxSigGrpArrayConstPtr->RxSigGrpBuf_Index );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   479  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   480          SigGrpBitOffset        = ( RxSigGrpArrayConstPtr->FirstByteNo * 8u );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   481  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   482          SchM_Enter_Com_RxSigGrpArrayBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   483      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   484      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   485  # endif /* # ifdef COM_RX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   486      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   487          SchM_Enter_Com_RxGrpSigSecBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   488      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   489  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   490      RxGrpSigConstPtr = COM_GET_RXGRPSIG_CONSTDATA( RxSigGrpConstPtr->FirstGrpSig_Index );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   491  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   492      for ( index_ui = (uint16_least)RxSigGrpConstPtr->No_Of_GrpSig; index_ui != (uint16_least)0; index_ui-- )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   493      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   494  # if (defined(COM_RX_SIGNALGROUP_ARRAY) || defined(COM_RXGRPSIG_FLOAT64SUPP) || defined(COM_RXGRPSIG_INT64))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   495          SigType = Com_GetValue(RXGRPSIG,_TYPE,RxGrpSigConstPtr->rxGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   496  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   497  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   498          SigValue = (Com_SigMaxType)RxGrpSigConstPtr->Init_Val;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   499  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   500  #ifdef COM_RXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   501          /* [SWS_Com_00723] The AUTOSAR COM module shall extend the init value (ComSignalInitValue) of a signal
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   502           * to the size of its ComSignalType.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   503           * Currently for COM_SINT64 signal type, ComSignalInitValue is supported for maximum 32bits.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   504           * If negative values are configured, by default these values will be sign extended only till 32bits.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   505           * so, for COM_SINT64, it is required to perform the sign extension till 64bits explicity. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   506          SigValue = (SigType == COM_SINT64) ? (Com_SigMaxType)((sint64)((sint32)SigValue)) : SigValue;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   507  #endif /* #ifdef COM_RXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   508  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   509  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   510          if ( ConstIsSigGrpOfArrayType_b )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   511          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   512              Com_BitpositionType RelativeSigBitPos; /* Relative BitPosition in RxSignalGroup Array */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   513  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   514              /* The Buffer into which Signal Values needs to be packed will be available with starting address
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   515               * of the Rx-SignalGroup Array Buffer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   516               * But we have GroupSignal: Bit_Pos, i.e., Signal's actual LSB in the IPdu Buffer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   517               * So, Rx-SignalGroup BitOffset(SigGrpBitOffset) is removed from each of the GroupSignal and
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   518               * is used as BitPosition to pack its value into the Rx-SignalGroup Array Buffer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   519              RelativeSigBitPos = RxGrpSigConstPtr->Bit_Pos - ( Com_BitpositionType )SigGrpBitOffset;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   520  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   521              Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   522                                                RxSigGrpArrayBufRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   523                                                SigValue,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   524                                                RelativeSigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   525                                                RxGrpSigConstPtr->BitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   526                                                SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   527                                                Com_GetValue(RXGRPSIG,_ENDIANESS,RxGrpSigConstPtr->rxGrpSigFields) );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   528          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   529          else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   530  # endif /* #ifdef COM_RX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   531          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   532  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   533  # ifdef COM_RXGRPSIG_FLOAT64SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   534              if(SigType == COM_FLOAT64)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   535              {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   536                  COM_GET_SECRXGRPSIGTYPEFLOAT64_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) =
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   537                                                                        Com_getfloat64InitValue(SigValue);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   538              }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   539              else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   540  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   541  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   542              {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   543                  Com_UpdateRxGroupSignalSecondBuffer(RxGrpSigConstPtr, SigValue, RxMainFuncId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   544              }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   545          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   546  # if defined(COM_RxFilters) && defined(COM_F_MASKEDNEWDIFFERSOLD)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   547          /* [SWS_Com_00603] The AUTOSAR COM module shall set the old_value of the filtering mechanisms
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   548           * for each signal to the ComSignalInitValue during start-up */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   549          if ( ( COM_INIT != Com_Uninit_Flag ) && ( COM_MASKED_NEW_DIFFERS_MASKED_OLD == RxGrpSigConstPtr->Filter_Algo ) )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   550          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   551              COM_GET_F_OLDVALUE(RxGrpSigConstPtr->Filter_Index) = (uint32)SigValue;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   552          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   553  # endif /* # if defined(COM_RxFilters) && defined(COM_F_MASKEDNEWDIFFERSOLD) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   554  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   555          RxGrpSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   556      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   557  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   558  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   559      if ( ConstIsSigGrpOfArrayType_b )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   560      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   561          SchM_Exit_Com_RxSigGrpArrayBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   562      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   563      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   564  # endif /* # ifdef COM_RX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   565      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   566          SchM_Exit_Com_RxGrpSigSecBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   567      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   568  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   569  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   570  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   571  #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   572  #ifdef COM_TxIPduNotification
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   573  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxNotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   574          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   575      Com_TxIpduConstPtrType TxIPduConstPtr;    /* Local pointer to Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   576      Com_TxSigConstPtrType TxSigConstPtr;    /* Local pointer to Tx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   577  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   578      Com_TxSigGrpConstPtrType TxSigGrpConstPtr; /* Local pointer to hold the address of Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   579  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   580      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   581  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   582      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   583      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   584      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   585  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   586      IpduId = COM_GET_TX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   587      TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   588      TxSigConstPtr = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   589  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   590      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(TxIPduConstPtr->FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   591  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   592  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   593      for(index_u8 = TxIPduConstPtr->TxSigId_Index; index_u8 < (TxIPduConstPtr->TxSigId_Index + TxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   594      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   595          if(TxSigConstPtr->Notification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   596          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   597              TxSigConstPtr->Notification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   598          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   599          TxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   600      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   601  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   602      for(index_u8 = TxIPduConstPtr->FirstTxSigGrp_Index; index_u8 < (TxIPduConstPtr->FirstTxSigGrp_Index + TxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   603      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   604          if(TxSigGrpConstPtr->Notification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   605          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   606              TxSigGrpConstPtr->Notification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   607          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   608          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   609      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   610  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   611  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   612          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   613  #endif /* #ifdef COM_TxIPduNotification */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   614  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   615  #ifdef COM_ERRORNOTIFICATION
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   616  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxErrNotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   617  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   618  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   619      Com_TxIpduConstPtrType TxIPduConstPtr;    /* Local pointer to Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   620      Com_TxSigConstPtrType TxSigConstPtr;    /* Local pointer to Tx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   621  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   622      Com_TxSigGrpConstPtrType TxSigGrpConstPtr; /* Local pointer to hold the address of Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   623  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   624      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   625  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   626      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   627      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   628      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   629  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   630      IpduId = COM_GET_TX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   631      TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   632      TxSigConstPtr = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   633  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   634      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(TxIPduConstPtr->FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   635  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   636  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   637      for(index_u8 = TxIPduConstPtr->TxSigId_Index; index_u8 < (TxIPduConstPtr->TxSigId_Index + TxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   638      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   639          if(TxSigConstPtr->NotificationError_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   640          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   641              TxSigConstPtr->NotificationError_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   642          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   643          TxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   644      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   645  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   646      for(index_u8 = TxIPduConstPtr->FirstTxSigGrp_Index; index_u8 < (TxIPduConstPtr->FirstTxSigGrp_Index + TxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   647      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   648          if(TxSigGrpConstPtr->NotificationError_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   649          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   650              TxSigGrpConstPtr->NotificationError_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   651          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   652          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   653      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   654  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   655  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   656  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   657  #endif /* #ifdef COM_ERRORNOTIFICATION */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   658  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   659  #ifdef COM_TxIPduTimeOutNotify
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   660  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxTONotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   661  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   662  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   663      Com_TxIpduConstPtrType TxIPduConstPtr;    /* Local pointer to Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   664      Com_TxSigConstPtrType TxSigConstPtr;    /* Local pointer to Tx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   665  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   666      Com_TxSigGrpConstPtrType TxSigGrpConstPtr; /* Local pointer to hold the address of Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   667  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   668      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   669  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   670      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   671      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   672      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   673  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   674      IpduId = COM_GET_TX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   675      TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   676      TxSigConstPtr = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   677  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   678      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(TxIPduConstPtr->FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   679  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   680  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   681      for(index_u8 = TxIPduConstPtr->TxSigId_Index; index_u8 < (TxIPduConstPtr->TxSigId_Index + TxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   682      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   683          if(TxSigConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   684          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   685              TxSigConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   686          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   687          TxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   688      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   689  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   690      for(index_u8 = TxIPduConstPtr->FirstTxSigGrp_Index; index_u8 < (TxIPduConstPtr->FirstTxSigGrp_Index + TxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   691      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   692          if(TxSigGrpConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   693          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   694              TxSigGrpConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   695          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   696          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   697      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   698  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   699  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   700  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   701  #endif /* #ifdef COM_TxIPduTimeOutNotify */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   702  #ifdef COM_RxIPduTimeoutNotify
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   703  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallRxTONotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   704  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   705  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   706      Com_RxIpduConstPtrType RxIPduConstPtr;    /* Local pointer to Rx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   707      Com_RxSigConstPtrType RxSigConstPtr;    /* Local pointer to Rx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   708  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   709      Com_RxSigGrpConstPtrType RxSigGrpConstPtr; /* Local pointer to hold the address of Rx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   710  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   711      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   712  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   713      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   714      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   715      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   716  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   717      IpduId = COM_GET_RX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   718      RxIPduConstPtr = COM_GET_RX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   719      RxSigConstPtr = COM_GET_RXSIG_CONSTDATA(RxIPduConstPtr->RxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   720  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   721      RxSigGrpConstPtr = COM_GET_RXSIGGRP_CONSTDATA(RxIPduConstPtr->FirstRxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   722  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   723  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   724      for(index_u8 = RxIPduConstPtr->RxSigId_Index; index_u8 < (RxIPduConstPtr->RxSigId_Index + RxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   725      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   726          if(RxSigConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   727          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   728              RxSigConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   729          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   730          RxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   731      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   732  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   733      for(index_u8 = RxIPduConstPtr->FirstRxSigGrp_Index; index_u8 < (RxIPduConstPtr->FirstRxSigGrp_Index + RxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   734      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   735          if(RxSigGrpConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   736          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   737              RxSigGrpConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   738          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   739          RxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   740      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   741  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   742  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   743  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   744  #endif /* #ifdef COM_RxIPduTimeoutNotify */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   745  #endif /* #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   746  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   747  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   748  LOCAL_INLINE FUNC(void, COM_CODE) Com_CopyTxGroupSignalData( Com_SignalIdType    GrpSignalId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   749                                                               Com_SigMaxType      TxGrpSig_NewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   750                                                               Com_MainFuncType    TxMainFuncId )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   751  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   752      Com_TxGrpSigConstPtrType                   TxGrpSigConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   753      VAR(Com_TxGrpSigBuffIndexType, AUTOMATIC)  GrpSigBuff_Index;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   754      VAR(uint8, AUTOMATIC)                      Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   755  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   756      TxGrpSigConstPtr = COM_GET_TXGRPSIG_CONSTDATA(GrpSignalId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   757      GrpSigBuff_Index = TxGrpSigConstPtr->TxGrpSigBuff_Index;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   758      Type = Com_GetValue(TXGRPSIG,_TYPE,TxGrpSigConstPtr->txGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   759  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   760      SchM_Enter_Com_TxGrpSigBuffer();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   761      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   762      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   763  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   764          case 0x00u: /* UINT8 and SINT8 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   765          case 0x03u: /* Boolean type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   766              COM_GET_TXGRPSIGTYPEU8_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint8)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   767              break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   768  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   769          /* UINT16 and SINT16 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   770          case 0x01u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   771              COM_GET_TXGRPSIGTYPEU16_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint16)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   772              break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   773  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   774          /* UINT32,SINT32 and FLOAT32 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   775          case 0x02u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   776          /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   777  #ifdef COM_FLOAT32SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   778          case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   779  #endif /* #ifdef COM_FLOAT32SUPP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   780          /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   781              COM_GET_TXGRPSIGTYPEU32_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint32)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   782              break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   783  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   784          /* UINT64 and SINT64 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   785  #ifdef COM_TXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   786          case 0x08u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   787              COM_GET_TXGRPSIGTYPEU64_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint64)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   788          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   789  #endif /* #ifdef COM_TXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   790  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   791          default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   792              /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   793               * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   794               * allowed to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   795               */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   796          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   797     }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   798      SchM_Exit_Com_TxGrpSigBuffer();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   799  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   800  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   801  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   802  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   803  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   804  #if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   805  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   806  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   807   Function name    : Com_Prv_DETCheck_Void
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   808   Syntax           : boolean Com_Prv_DETCheck_Void(uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   809   Description      : Inline function to check for module initialization
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   810   Parameter        : ApiId - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   811   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   812                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   813   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   814  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Void(uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   815  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   816      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   817      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   818  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   819      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   820      Status  = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   821  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   822      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   823      if (Com_Uninit_Flag == COM_UNINIT)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   824      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   825          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   826          COM_REPORT_ERROR_CHECK(ApiId, COM_E_UNINIT);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   827          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   828          Status = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   829      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   830      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   831      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   832          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   833      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   834  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   835      return Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   836  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   837  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   838  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   839   Function name    : Com_Prv_DETCheck_Param
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   840   Syntax           : boolean Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   841   Description      : Inline function to check for module initialization and valid parameter value.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   842   Parameter        : isInValidParam - calling service is called with invalid parameter value
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   843                      ApiId          - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   844   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   845                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   846   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   847  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   848  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   849      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   850      uint8   ErrorId;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   851      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   852  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   853      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   854      ErrorId = COM_DET_NO_ERROR;
	mov	d7,#255
.L61:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   855      Status  = COM_TRUE;
	mov	d1,#1
.L63:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   856  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   857      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   858      if (Com_Uninit_Flag == COM_UNINIT)
	movh.a	a15,#@his(Com_Uninit_Flag)
	lea	a15,[a15]@los(Com_Uninit_Flag)
	ld.w	d15,[a15]
.L76:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   858      if (Com_Uninit_Flag == COM_UNINIT)      (inlined)
	jne	d15,#0,.L2
.L77:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   859      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   860          ErrorId = COM_E_UNINIT;
	mov	d7,#2
.L78:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   860          ErrorId = COM_E_UNINIT;      (inlined)
	j	.L3

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   858      if (Com_Uninit_Flag == COM_UNINIT)      (inlined)
.L2:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   862      else if (isInValidParam)      (inlined)
	jeq	d0,#0,.L4
.L79:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   861      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   862      else if (isInValidParam)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   863      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   864          ErrorId = COM_E_PARAM;
	mov	d7,#1
.L80:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   864          ErrorId = COM_E_PARAM;      (inlined)
	j	.L5

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   862      else if (isInValidParam)      (inlined)
.L4:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   866      else      (inlined)
.L5:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   862      else if (isInValidParam)      (inlined)
.L3:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   865      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   866      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   867      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   868          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   869      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   870  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   871      /* Check if ErrorId has Error Code */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   872      if (ErrorId != COM_DET_NO_ERROR)
	mov	d15,#255
.L81:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   872      if (ErrorId != COM_DET_NO_ERROR)      (inlined)
	jeq	d15,d7,.L6
.L82:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   873      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   874          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   875          COM_REPORT_ERROR_CHECK(ApiId, ErrorId);
	mov	d4,#50
.L59:
	mov	d5,#0
	call	Det_ReportError
.L62:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   876          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   877          Status = COM_FALSE;
	mov	d1,#0

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   872      if (ErrorId != COM_DET_NO_ERROR)      (inlined)
.L6:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   879      return Status;      (inlined)
	j	.L7

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   880  }      (inlined)
.L7:
	jeq	d1,#0,.L8
.L34:

; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    31  #endif
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    32  
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    33      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    34       * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    35       * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    36      {
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    37          PduId = COM_GET_TX_IPDU_ID(PduId);
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    38  
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    39          TxIpduRamPtr = &COM_GET_TXPDURAM_S(PduId);
	movh.a	a15,#@his(Com_TxIpduRam_s)
	lea	a15,[a15]@los(Com_TxIpduRam_s)
.L83:

; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    40  
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    41  #ifdef COM_TxIPduTimeOut
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    42  
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    43          TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(PduId);
	mul	d15,d8,#24
	movh.a	a2,#@his(Com_Prv_xTxIpduCfg_acst)
	lea	a2,[a2]@los(Com_Prv_xTxIpduCfg_acst)
	addsc.a	a2,a2,d15,#0
.L44:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     1  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     2  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     3  #ifndef COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     4  #define COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     5  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     6  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     7   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     8   * Includes
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     9   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    10  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    11  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    12  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    13  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    17  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    18  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    19  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    20  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    21   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    22   * Type definitions
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    23   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    24  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    25  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    26  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    27  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    28   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    29   * Variables
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    30   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    31  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    32  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    33  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    34  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    35   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    36   * Extern declarations
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    37   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    38  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    39  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    40   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    41   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    42   * Inline function sets TMS data in to be accessesd via CurrentTxModePtr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    43   * after evaluating TMS mode for the IPdu
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    44   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    45  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    46  FUNC(void, COM_CODE) Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    47                                  Com_TxIpduRamPtrType                TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    48                                  Com_TxIpduConstPtrType              TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    49                                  VAR(uint16,AUTOMATIC)               TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    50                                  VAR(boolean,AUTOMATIC)              ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    51                                              );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    52  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    53  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    54   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    55   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    56   * Inline function to update Rx-GroupSignal application buffers
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    57   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    58  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    59  FUNC(void, COM_CODE) Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    60                                  Com_RxSigConstPtrType               RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    61                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    62                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    63                                               );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    64  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    65  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    66   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    67   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    68   * Inline function to update Rx-GroupSignal secondary buffers
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    69   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    70  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    71  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    72  FUNC(void, COM_CODE) Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    73                                  Com_RxGrpSigConstPtrType            RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    74                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    75                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    76                                                          );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    77  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    78  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    79  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    80   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    81   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    82   * Inline function to initialize signal intial value into the provided IPdu buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    83   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    84  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    85  FUNC(void, COM_CODE) Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    86                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    87                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    88                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    89                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    90                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    91                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    92                                                              );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    93  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    94  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    95   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    96   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    97   * Inline function to initialize Rx-signal group with initial values
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    98   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    99  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   100  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   101  FUNC(void, COM_CODE) Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   102                                  Com_RxSigGrpConstPtrType            RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   103                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   104                                                  );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   105  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   106  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   107  #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   108  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxNotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   109  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxErrNotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   110  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxTONotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   111  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallRxTONotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   112  #endif /* #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   113  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   114  /* Inline function to check for the RxIPdu and TxIpdu status*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   115  LOCAL_INLINE boolean Com_CheckRxIPduStatus(PduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   116  LOCAL_INLINE boolean Com_CheckTxIPduStatus(PduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   117  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   118  #if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   119  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   120  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Void(uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   121  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   122  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Ptr(boolean isInValidPtr, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   123  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Param_Ptr(boolean isInValidParam, boolean isInValidPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   124                                                                  uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   125  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Ptr_Only(boolean isInValidPtr, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   126  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Param_Only(boolean isInValidParam, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   127  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   128  #endif /*  #if (COM_CONFIGURATION_USE_DET == STD_ON) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   129  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   130  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   131  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   132  LOCAL_INLINE FUNC(void, COM_CODE) Com_CopyTxGroupSignalData( Com_SignalIdType    GrpSignalId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   133                                                               Com_SigMaxType      TxGrpSig_NewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   134                                                               Com_MainFuncType    TxMainFuncId );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   135  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   136  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   137  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   138   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   139   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   140   * Inline function to handle gateway and non-gateway use-case for tx-signal/signalGroup
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   141   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   142  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_ProceedToSendIpdu(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   143                                                  VAR(Com_IpduIdType, AUTOMATIC)          ComTxPduId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   144                                                  VAR(Com_SendIpduInfo, AUTOMATIC)        sendIpduFlag_u16
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   145                                                             );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   146  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   147  #ifdef COM_TxFilters
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   148  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_CheckModeChange(VAR(Com_IpduIdType, AUTOMATIC) TxIpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   149  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   150  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   151  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   152  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   153   * Inline Function Definition
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   154   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   155  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   156  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   157   Function name    : Com_SetCurrentTxModePtr [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   158   Syntax           : void Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   159                                  Com_TxIpduRamPtrType    TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   160                                  Com_TxIpduConstPtrType  TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   161                                  uint16                  TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   162                                  boolean                 ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   163                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   164   Description      : Inline function sets TMS data in to be accessesd via CurrentTxModePtr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   165                      after evaluating TMS mode for the IPdu
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   166  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   167                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   168                       * Mode                  |    Configuration details                              | Value|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   169                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   170                       * COM_MODE_VALID        |    Both the TRUE and FALSE modes are configured.      |    00|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   171                       * COM_TRUEMODE_VALID    |    Only TRUE mode is configured                       |    01|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   172                       * COM_FALSEMODE_VALID   |    Only FALSE mode is configured                      |    10|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   173                       * COM_MODE_INVALID      |    Both the TRUE and FALSE mode are not configured    |    11|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   174                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   175                      This INLINE function checks the TMS generated values against the requested mode and performs action
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   176                      |-------------|--------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   177                      |ModeRequested|Configured Mode values   |         Description                                           :      Action to be taken                |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   178                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   179                      |    0       |      0        |      0   |  FALSE mode is requested and IPdu TMS is COM_MODE_VALID         : Increment to the false mode data     |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   180                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   181                      |    0       |      0        |      1   |  FALSE mode is requested and IPdu TMS is COM_TRUEMODE_VALID     : Point to NONE mode data              |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   182                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   183                      |    0       |      1        |      0   |  FALSE mode is requested and IPdu TMS is COM_FALSEMODE_VALID     : Do nothing                          |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   184                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   185                      |    0       |      1        |      1   |  FALSE mode is requested and IPdu TMS is COM_MODE_INVALID     : Do nothing                             |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   186                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   187                      |    1       |      0        |      0   |  TRUE mode is requested and IPdu TMS is COM_MODE_VALID         : Do nothing                            |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   188                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   189                      |    1       |      0        |      1   |  TRUE mode is requested and IPdu TMS is COM_TRUEMODE_VALID     : Do nothing                            |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   190                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   191                      |    1       |      1        |      0   |  TRUE mode is requested and IPdu TMS is COM_FALSEMODE_VALID     : Point to NONE mode data              |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   192                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   193                      |    1       |      1        |      1   |  TRUE mode is requested and IPdu TMS is COM_MODE_INVALID         : Do nothing                          |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   194                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   195  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   196                      where 0 in column 1 stands for FALSE mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   197                      and   1 in column 1 stands for TRUE mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   198  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   199   Parameter        : TxIpduRamPtr    - pointer to Txipdu ram data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   200                    : TxIPduConstPtr  - pointer to Txipdu Rom data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   201                    : TMSStatus       - pointer to transmission mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   202                    : ModeRequested   - mode requested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   203   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   204   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   205  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   206  FUNC(void, COM_CODE) Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   207                                  Com_TxIpduRamPtrType                TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   208                                  Com_TxIpduConstPtrType              TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   209                                  VAR(uint16,AUTOMATIC)               TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   210                                  VAR(boolean,AUTOMATIC)              ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   211                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   212  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   213      /* Get the latest TM pointer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   214      TxIpduRamPtr->CurrentTxModePtr = TxIPduConstPtr->Com_TMConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   215  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   216      if(ModeRequested == COM_FALSE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   217      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   218          if((TMSStatus) == COM_TRUEMODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   219          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   220              /*If yes,load NONE mode data */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   221              TxIpduRamPtr->CurrentTxModePtr = &Com_NONE_TransModeInfo ;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   222          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   223          if((TMSStatus) == COM_MODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   224          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   225              /*Increment to FALSE mode data, if the FALSE mode is configured */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   226              TxIpduRamPtr->CurrentTxModePtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   227          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   228      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   229      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   230      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   231          if((TMSStatus) == COM_FALSEMODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   232          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   233              TxIpduRamPtr->CurrentTxModePtr = &Com_NONE_TransModeInfo ;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   234          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   235      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   236  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   237  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   238  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   239   Function name    : Com_UpdateRxGroupSignalSecondBuffer [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   240   Syntax           : void Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   241                                  Com_RxGrpSigConstPtrType    RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   242                                  Com_SigMaxType              RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   243                                  Com_MainFuncType            RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   244                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   245   Description      : Inline function copy Group signal value into the Group signal Second buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   246   Parameter        : RxGrpSigConstPtr - pointer to RxGroupSignal configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   247                    : RxNewVal         - latest RxGroupSignal data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   248                    : RxMainFuncId     - Internally generated Rx-MainFunction-Id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   249   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   250   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   251  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   252  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   253  FUNC(void, COM_CODE) Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   254                                  Com_RxGrpSigConstPtrType            RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   255                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   256                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   257                                                          )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   258  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   259      VAR(uint8,AUTOMATIC)    Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   260  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   261      Type = Com_GetValue(RXGRPSIG,_TYPE,RxGrpSigConstPtr->rxGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   262  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   263      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   264      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   265      case 0x00u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   266          /* UINT08 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   267          COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint8)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   268          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   269  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   270      case 0x01u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   271          /* UINT16 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   272          COM_GET_SECRXGRPSIGTYPEU16_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint16)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   273          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   274  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   275      case 0x02u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   276          /* UINT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   277          /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   278      case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   279          /* FLOAT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   280          /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   281          COM_GET_SECRXGRPSIGTYPEU32_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint32)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   282          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   283  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   284  #ifdef COM_RXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   285      case 0x08u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   286          /* UINT64/SINT64 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   287          COM_GET_SECRXGRPSIGTYPEU64_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   288          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   289  #endif /* #ifdef COM_RXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   290  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   291      case 0x03u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   292          /*Boolean Signal*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   293          COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint8)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   294          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   295  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   296      case 0x04u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   297          /* UINT8_N signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   298          Com_ByteCopyInit(&COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index),
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   299                           (uint32)RxNewVal,RxGrpSigConstPtr->BitSize);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   300          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   301      default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   302          /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   303           * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are allowed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   304           * to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   305           */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   306          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   307  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   308      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   309  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   310  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   311  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   312  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   313   Function name    : Com_UpdateRxSignalBuffer [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   314   Syntax           : void Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   315                                  Com_RxSigConstPtrType   RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   316                                  Com_SigMaxType          RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   317                                  Com_MainFuncType        RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   318                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   319   Description      : Inline function to copy signal value into the signal buffer and
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   320                      is used when signal value as a variable is being passed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   321   Parameter        : RxSigConstPtr - pointer to RxSignal configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   322                    : RxNewVal_Sig  - latest RxSignal data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   323                    : RxMainFuncId  - Internally generated Rx-MainFunction-Id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   324   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   325   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   326  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   327  FUNC(void, COM_CODE) Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   328                                  Com_RxSigConstPtrType               RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   329                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   330                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   331                                               )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   332  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   333      VAR(uint8,AUTOMATIC)    Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   334  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   335      Type = Com_GetValue(GEN,_TYPE,RxSigConstPtr->General);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   336  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   337      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   338      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   339      case 0x00u:     /* COM_UINT8 & COM_SINT8 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   340      case (COM_BOOLEAN >> 1):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   341          COM_GET_SIGTYPEUINT8_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint8)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   342          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   343  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   344      case 0x01u:     /* COM_UINT16 & COM_SINT16 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   345          COM_GET_SIGTYPEUINT16_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint16)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   346          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   347  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   348      case 0x02u:     /* COM_UINT32 & COM_SINT32 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   349  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   350          /* COM_FLOAT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   351  #ifdef COM_FLOAT32SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   352      case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   353  #endif /* #ifdef COM_FLOAT32SUPP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   354  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   355          COM_GET_SIGTYPEUINT32_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint32)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   356          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   357  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   358  #ifdef COM_RXSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   359      case 0x08u:     /* COM_UINT64 & COM_SINT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   360          COM_GET_SIGTYPEUINT64_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   361          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   362  #endif /* #if defined(COM_RXSIG_INT64) && defined(COM_TXSIG_INT64) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   363  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   364      case 0x04u:     /* COM_UINT8_N */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   365          Com_ByteCopyInit(&COM_GET_SIGTYPEUINT8_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index),
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   366                           (uint32)RxNewVal_Sig,RxSigConstPtr->BitSize);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   367          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   368      default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   369          /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   370           * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are allowed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   371           * to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   372           */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   373          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   374      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   375  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   376  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   377  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   378   Function name    : Com_InitializePduBuffWithSignalInitValue [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   379   Syntax           : void Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   380                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   381                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   382                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   383                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   384                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   385                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   386                                                                   )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   387   Description      : Inline function to call required interface to pack signal data into Ipdu buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   388   Parameter        : BuffPtr     - pointer to (SignalGroup)IPdu Buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   389                    : SigInitVal  - (Group)Signal InitValue
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   390                    : SigBitPos   - (Group)Signal Bit Position
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   391                    : SigBitSize  - (Group)Signal Bit Size
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   392                    : SigType     - (Group)Signal Type
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   393                    : SigEndianess- (Group)Signal Endianness
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   394   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   395   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   396  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   397  FUNC(void, COM_CODE) Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   398                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   399                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   400                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   401                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   402                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   403                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   404                                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   405  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   406      if ( SigType != (uint8)COM_UINT8_N )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   407      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   408  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   409  #if (defined(COM_TXSIG_FLOAT64SUPP) || defined(COM_TXGRPSIG_FLOAT64SUPP) ||\ 
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   410      (defined(COM_RX_SIGNALGROUP_ARRAY) && defined(COM_RXGRPSIG_FLOAT64SUPP)))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   411          if ( SigType == COM_FLOAT64 )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   412          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   413              /* Convert the float value into 32 bit stream and then pack the value */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   414              /* Com_PackFloatSignal(TxSigConstPtr->General.Endianess,TxSigConstPtr->Bit_Pos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   415                                     Com_getfloat64InitValue(SigNewVal), TxIPduConstPtr->BuffPtr); */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   416              Com_PackFloatSignal( SigEndianess, SigBitPos, Com_getfloat64InitValue(SigInitVal), BuffPtr );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   417          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   418          else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   419  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   420  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   421          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   422              /* Pack the signal with Initial Value */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   423              /* Com_PackSignal(TxSigConstPtr->General.Endianess,TxSigConstPtr->Bit_Pos,TxSigConstPtr->BitSize,SigNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   424               *                TxIPduConstPtr->BuffPtr);*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   425              Com_PackSignal( SigEndianess, SigBitPos, SigBitSize, SigInitVal, BuffPtr );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   426          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   427      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   428      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   429      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   430          PduLengthType ByteOffset_uo;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   431          /* Find the starting byte position(ByteNo_uo) of Signal in the IPDU buffer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   432          ByteOffset_uo = ( PduLengthType )( SigBitPos >> 3 );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   433  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   434          /* Now copy the Signal into the IPDU buffer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   435          Com_ByteCopyInit( (BuffPtr + ByteOffset_uo), (uint32)SigInitVal, SigBitSize );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   436      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   437  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   438  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   439  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   440   Function name    : Com_Prv_SigGrpReplaceToInit
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   441   Syntax           : void Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   442                                          Com_RxSigGrpConstPtrType  RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   443                                          Com_MainFuncType          RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   444                                                      )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   445   Description      : If the SigGrp is enabled with ArrayAccess, RxSigGrpBuffer will be packed with
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   446                      GroupSignal Init Values OR else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   447                      GroupSignals Shadow buffers will be replaced with its Init Values
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   448   Parameter        : RxSigGrpConstPtr - pointer to RxSignalGroup configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   449                    : RxMainFuncId     - Internally generated RxMainFunction-ID
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   450   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   451   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   452  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   453  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   454                                                  Com_RxSigGrpConstPtrType        RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   455                                                  VAR(Com_MainFuncType,AUTOMATIC) RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   456                                                               )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   457  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   458      Com_RxGrpSigConstPtrType      RxGrpSigConstPtr;      /* Local pointer to Rx GroupSignal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   459  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   460      Com_RxSigGrpArrayConstPtrType RxSigGrpArrayConstPtr; /* Local pointer to Rx SignalGroup Array configuration  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   461      uint8                       * RxSigGrpArrayBufRamPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   462      PduLengthType                 SigGrpBitOffset;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   463  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   464      VAR(uint16_least, AUTOMATIC)  index_ui;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   465      VAR(Com_SigMaxType, AUTOMATIC) SigValue;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   466  # if (defined(COM_RX_SIGNALGROUP_ARRAY) || defined(COM_RXGRPSIG_FLOAT64SUPP) || defined(COM_RXGRPSIG_INT64))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   467      VAR(uint8, AUTOMATIC)         SigType;  /* Signal Type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   468  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   469  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   470      boolean                       ConstIsSigGrpOfArrayType_b;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   471  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   472      ConstIsSigGrpOfArrayType_b = Com_GetValue(RXSIGGRP,_ARRAYACCESS,RxSigGrpConstPtr->rxSignalGrpFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   473  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   474      if ( ConstIsSigGrpOfArrayType_b )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   475      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   476          RxSigGrpArrayConstPtr  = COM_GET_RXSIGGRP_ARRAY_CONSTDATA( RxSigGrpConstPtr->SigGrpArray_Index );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   477  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   478          RxSigGrpArrayBufRamPtr = &COM_GET_RXSIGGRP_ARRAY_BUFF(RxMainFuncId, RxSigGrpArrayConstPtr->RxSigGrpBuf_Index );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   479  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   480          SigGrpBitOffset        = ( RxSigGrpArrayConstPtr->FirstByteNo * 8u );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   481  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   482          SchM_Enter_Com_RxSigGrpArrayBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   483      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   484      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   485  # endif /* # ifdef COM_RX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   486      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   487          SchM_Enter_Com_RxGrpSigSecBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   488      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   489  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   490      RxGrpSigConstPtr = COM_GET_RXGRPSIG_CONSTDATA( RxSigGrpConstPtr->FirstGrpSig_Index );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   491  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   492      for ( index_ui = (uint16_least)RxSigGrpConstPtr->No_Of_GrpSig; index_ui != (uint16_least)0; index_ui-- )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   493      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   494  # if (defined(COM_RX_SIGNALGROUP_ARRAY) || defined(COM_RXGRPSIG_FLOAT64SUPP) || defined(COM_RXGRPSIG_INT64))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   495          SigType = Com_GetValue(RXGRPSIG,_TYPE,RxGrpSigConstPtr->rxGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   496  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   497  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   498          SigValue = (Com_SigMaxType)RxGrpSigConstPtr->Init_Val;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   499  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   500  #ifdef COM_RXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   501          /* [SWS_Com_00723] The AUTOSAR COM module shall extend the init value (ComSignalInitValue) of a signal
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   502           * to the size of its ComSignalType.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   503           * Currently for COM_SINT64 signal type, ComSignalInitValue is supported for maximum 32bits.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   504           * If negative values are configured, by default these values will be sign extended only till 32bits.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   505           * so, for COM_SINT64, it is required to perform the sign extension till 64bits explicity. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   506          SigValue = (SigType == COM_SINT64) ? (Com_SigMaxType)((sint64)((sint32)SigValue)) : SigValue;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   507  #endif /* #ifdef COM_RXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   508  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   509  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   510          if ( ConstIsSigGrpOfArrayType_b )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   511          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   512              Com_BitpositionType RelativeSigBitPos; /* Relative BitPosition in RxSignalGroup Array */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   513  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   514              /* The Buffer into which Signal Values needs to be packed will be available with starting address
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   515               * of the Rx-SignalGroup Array Buffer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   516               * But we have GroupSignal: Bit_Pos, i.e., Signal's actual LSB in the IPdu Buffer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   517               * So, Rx-SignalGroup BitOffset(SigGrpBitOffset) is removed from each of the GroupSignal and
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   518               * is used as BitPosition to pack its value into the Rx-SignalGroup Array Buffer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   519              RelativeSigBitPos = RxGrpSigConstPtr->Bit_Pos - ( Com_BitpositionType )SigGrpBitOffset;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   520  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   521              Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   522                                                RxSigGrpArrayBufRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   523                                                SigValue,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   524                                                RelativeSigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   525                                                RxGrpSigConstPtr->BitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   526                                                SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   527                                                Com_GetValue(RXGRPSIG,_ENDIANESS,RxGrpSigConstPtr->rxGrpSigFields) );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   528          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   529          else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   530  # endif /* #ifdef COM_RX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   531          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   532  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   533  # ifdef COM_RXGRPSIG_FLOAT64SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   534              if(SigType == COM_FLOAT64)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   535              {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   536                  COM_GET_SECRXGRPSIGTYPEFLOAT64_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) =
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   537                                                                        Com_getfloat64InitValue(SigValue);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   538              }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   539              else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   540  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   541  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   542              {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   543                  Com_UpdateRxGroupSignalSecondBuffer(RxGrpSigConstPtr, SigValue, RxMainFuncId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   544              }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   545          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   546  # if defined(COM_RxFilters) && defined(COM_F_MASKEDNEWDIFFERSOLD)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   547          /* [SWS_Com_00603] The AUTOSAR COM module shall set the old_value of the filtering mechanisms
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   548           * for each signal to the ComSignalInitValue during start-up */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   549          if ( ( COM_INIT != Com_Uninit_Flag ) && ( COM_MASKED_NEW_DIFFERS_MASKED_OLD == RxGrpSigConstPtr->Filter_Algo ) )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   550          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   551              COM_GET_F_OLDVALUE(RxGrpSigConstPtr->Filter_Index) = (uint32)SigValue;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   552          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   553  # endif /* # if defined(COM_RxFilters) && defined(COM_F_MASKEDNEWDIFFERSOLD) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   554  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   555          RxGrpSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   556      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   557  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   558  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   559      if ( ConstIsSigGrpOfArrayType_b )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   560      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   561          SchM_Exit_Com_RxSigGrpArrayBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   562      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   563      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   564  # endif /* # ifdef COM_RX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   565      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   566          SchM_Exit_Com_RxGrpSigSecBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   567      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   568  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   569  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   570  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   571  #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   572  #ifdef COM_TxIPduNotification
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   573  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxNotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   574          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   575      Com_TxIpduConstPtrType TxIPduConstPtr;    /* Local pointer to Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   576      Com_TxSigConstPtrType TxSigConstPtr;    /* Local pointer to Tx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   577  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   578      Com_TxSigGrpConstPtrType TxSigGrpConstPtr; /* Local pointer to hold the address of Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   579  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   580      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   581  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   582      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   583      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   584      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   585  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   586      IpduId = COM_GET_TX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   587      TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   588      TxSigConstPtr = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   589  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   590      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(TxIPduConstPtr->FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   591  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   592  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   593      for(index_u8 = TxIPduConstPtr->TxSigId_Index; index_u8 < (TxIPduConstPtr->TxSigId_Index + TxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   594      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   595          if(TxSigConstPtr->Notification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   596          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   597              TxSigConstPtr->Notification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   598          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   599          TxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   600      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   601  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   602      for(index_u8 = TxIPduConstPtr->FirstTxSigGrp_Index; index_u8 < (TxIPduConstPtr->FirstTxSigGrp_Index + TxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   603      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   604          if(TxSigGrpConstPtr->Notification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   605          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   606              TxSigGrpConstPtr->Notification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   607          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   608          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   609      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   610  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   611  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   612          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   613  #endif /* #ifdef COM_TxIPduNotification */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   614  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   615  #ifdef COM_ERRORNOTIFICATION
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   616  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxErrNotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   617  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   618  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   619      Com_TxIpduConstPtrType TxIPduConstPtr;    /* Local pointer to Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   620      Com_TxSigConstPtrType TxSigConstPtr;    /* Local pointer to Tx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   621  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   622      Com_TxSigGrpConstPtrType TxSigGrpConstPtr; /* Local pointer to hold the address of Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   623  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   624      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   625  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   626      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   627      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   628      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   629  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   630      IpduId = COM_GET_TX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   631      TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   632      TxSigConstPtr = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   633  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   634      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(TxIPduConstPtr->FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   635  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   636  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   637      for(index_u8 = TxIPduConstPtr->TxSigId_Index; index_u8 < (TxIPduConstPtr->TxSigId_Index + TxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   638      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   639          if(TxSigConstPtr->NotificationError_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   640          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   641              TxSigConstPtr->NotificationError_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   642          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   643          TxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   644      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   645  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   646      for(index_u8 = TxIPduConstPtr->FirstTxSigGrp_Index; index_u8 < (TxIPduConstPtr->FirstTxSigGrp_Index + TxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   647      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   648          if(TxSigGrpConstPtr->NotificationError_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   649          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   650              TxSigGrpConstPtr->NotificationError_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   651          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   652          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   653      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   654  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   655  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   656  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   657  #endif /* #ifdef COM_ERRORNOTIFICATION */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   658  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   659  #ifdef COM_TxIPduTimeOutNotify
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   660  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxTONotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   661  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   662  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   663      Com_TxIpduConstPtrType TxIPduConstPtr;    /* Local pointer to Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   664      Com_TxSigConstPtrType TxSigConstPtr;    /* Local pointer to Tx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   665  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   666      Com_TxSigGrpConstPtrType TxSigGrpConstPtr; /* Local pointer to hold the address of Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   667  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   668      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   669  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   670      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   671      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   672      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   673  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   674      IpduId = COM_GET_TX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   675      TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   676      TxSigConstPtr = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   677  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   678      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(TxIPduConstPtr->FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   679  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   680  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   681      for(index_u8 = TxIPduConstPtr->TxSigId_Index; index_u8 < (TxIPduConstPtr->TxSigId_Index + TxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   682      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   683          if(TxSigConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   684          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   685              TxSigConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   686          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   687          TxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   688      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   689  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   690      for(index_u8 = TxIPduConstPtr->FirstTxSigGrp_Index; index_u8 < (TxIPduConstPtr->FirstTxSigGrp_Index + TxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   691      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   692          if(TxSigGrpConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   693          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   694              TxSigGrpConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   695          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   696          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   697      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   698  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   699  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   700  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   701  #endif /* #ifdef COM_TxIPduTimeOutNotify */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   702  #ifdef COM_RxIPduTimeoutNotify
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   703  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallRxTONotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   704  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   705  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   706      Com_RxIpduConstPtrType RxIPduConstPtr;    /* Local pointer to Rx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   707      Com_RxSigConstPtrType RxSigConstPtr;    /* Local pointer to Rx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   708  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   709      Com_RxSigGrpConstPtrType RxSigGrpConstPtr; /* Local pointer to hold the address of Rx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   710  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   711      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   712  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   713      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   714      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   715      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   716  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   717      IpduId = COM_GET_RX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   718      RxIPduConstPtr = COM_GET_RX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   719      RxSigConstPtr = COM_GET_RXSIG_CONSTDATA(RxIPduConstPtr->RxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   720  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   721      RxSigGrpConstPtr = COM_GET_RXSIGGRP_CONSTDATA(RxIPduConstPtr->FirstRxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   722  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   723  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   724      for(index_u8 = RxIPduConstPtr->RxSigId_Index; index_u8 < (RxIPduConstPtr->RxSigId_Index + RxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   725      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   726          if(RxSigConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   727          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   728              RxSigConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   729          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   730          RxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   731      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   732  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   733      for(index_u8 = RxIPduConstPtr->FirstRxSigGrp_Index; index_u8 < (RxIPduConstPtr->FirstRxSigGrp_Index + RxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   734      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   735          if(RxSigGrpConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   736          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   737              RxSigGrpConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   738          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   739          RxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   740      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   741  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   742  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   743  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   744  #endif /* #ifdef COM_RxIPduTimeoutNotify */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   745  #endif /* #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   746  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   747  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   748  LOCAL_INLINE FUNC(void, COM_CODE) Com_CopyTxGroupSignalData( Com_SignalIdType    GrpSignalId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   749                                                               Com_SigMaxType      TxGrpSig_NewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   750                                                               Com_MainFuncType    TxMainFuncId )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   751  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   752      Com_TxGrpSigConstPtrType                   TxGrpSigConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   753      VAR(Com_TxGrpSigBuffIndexType, AUTOMATIC)  GrpSigBuff_Index;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   754      VAR(uint8, AUTOMATIC)                      Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   755  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   756      TxGrpSigConstPtr = COM_GET_TXGRPSIG_CONSTDATA(GrpSignalId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   757      GrpSigBuff_Index = TxGrpSigConstPtr->TxGrpSigBuff_Index;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   758      Type = Com_GetValue(TXGRPSIG,_TYPE,TxGrpSigConstPtr->txGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   759  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   760      SchM_Enter_Com_TxGrpSigBuffer();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   761      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   762      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   763  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   764          case 0x00u: /* UINT8 and SINT8 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   765          case 0x03u: /* Boolean type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   766              COM_GET_TXGRPSIGTYPEU8_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint8)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   767              break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   768  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   769          /* UINT16 and SINT16 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   770          case 0x01u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   771              COM_GET_TXGRPSIGTYPEU16_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint16)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   772              break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   773  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   774          /* UINT32,SINT32 and FLOAT32 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   775          case 0x02u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   776          /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   777  #ifdef COM_FLOAT32SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   778          case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   779  #endif /* #ifdef COM_FLOAT32SUPP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   780          /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   781              COM_GET_TXGRPSIGTYPEU32_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint32)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   782              break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   783  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   784          /* UINT64 and SINT64 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   785  #ifdef COM_TXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   786          case 0x08u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   787              COM_GET_TXGRPSIGTYPEU64_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint64)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   788          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   789  #endif /* #ifdef COM_TXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   790  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   791          default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   792              /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   793               * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   794               * allowed to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   795               */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   796          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   797     }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   798      SchM_Exit_Com_TxGrpSigBuffer();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   799  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   800  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   801  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   802  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   803  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   804  #if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   805  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   806  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   807   Function name    : Com_Prv_DETCheck_Void
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   808   Syntax           : boolean Com_Prv_DETCheck_Void(uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   809   Description      : Inline function to check for module initialization
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   810   Parameter        : ApiId - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   811   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   812                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   813   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   814  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Void(uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   815  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   816      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   817      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   818  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   819      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   820      Status  = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   821  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   822      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   823      if (Com_Uninit_Flag == COM_UNINIT)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   824      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   825          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   826          COM_REPORT_ERROR_CHECK(ApiId, COM_E_UNINIT);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   827          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   828          Status = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   829      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   830      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   831      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   832          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   833      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   834  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   835      return Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   836  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   837  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   838  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   839   Function name    : Com_Prv_DETCheck_Param
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   840   Syntax           : boolean Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   841   Description      : Inline function to check for module initialization and valid parameter value.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   842   Parameter        : isInValidParam - calling service is called with invalid parameter value
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   843                      ApiId          - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   844   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   845                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   846   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   847  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   848  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   849      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   850      uint8   ErrorId;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   851      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   852  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   853      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   854      ErrorId = COM_DET_NO_ERROR;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   855      Status  = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   856  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   857      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   858      if (Com_Uninit_Flag == COM_UNINIT)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   859      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   860          ErrorId = COM_E_UNINIT;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   861      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   862      else if (isInValidParam)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   863      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   864          ErrorId = COM_E_PARAM;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   865      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   866      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   867      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   868          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   869      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   870  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   871      /* Check if ErrorId has Error Code */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   872      if (ErrorId != COM_DET_NO_ERROR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   873      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   874          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   875          COM_REPORT_ERROR_CHECK(ApiId, ErrorId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   876          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   877          Status = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   878      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   879      return Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   880  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   881  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   882  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   883   Function name    : Com_Prv_DETCheck_Ptr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   884   Syntax           : boolean Com_Prv_DETCheck_Ptr(boolean isInValidPtr, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   885   Description      : Inline function to check for module initialization and valid pointer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   886   Parameter        : isInValidPtr - calling service is called with invalid pointer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   887                      ApiId        - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   888   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   889                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   890   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   891  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Ptr(boolean isInValidPtr, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   892  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   893      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   894      uint8   ErrorId;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   895      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   896  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   897      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   898      ErrorId = COM_DET_NO_ERROR;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   899      Status  = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   900  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   901      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   902      if (Com_Uninit_Flag == COM_UNINIT)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   903      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   904          ErrorId = COM_E_UNINIT;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   905      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   906      else if (isInValidPtr)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   907      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   908          ErrorId = COM_E_PARAM_POINTER;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   909      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   910      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   911      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   912          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   913      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   914  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   915      /* Check if ErrorId has Error Code */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   916      if (ErrorId != COM_DET_NO_ERROR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   917      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   918          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   919          COM_REPORT_ERROR_CHECK(ApiId, ErrorId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   920          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   921          Status = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   922      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   923      return Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   924  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   925  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   926  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   927   Function name    : Com_Prv_DETCheck_Param_Ptr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   928   Syntax           : boolean Com_Prv_DETCheck_Param_Ptr(boolean isInValidParam, boolean isInValidPtr, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   929   Description      : Inline function to check for module initialization, valid parameter value and valid pointer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   930   Parameter        : isInValidParam - calling service is called with invalid parameter value
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   931                      isInValidPtr   - calling service is called with invalid pointer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   932                      ApiId          - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   933   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   934                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   935   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   936  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Param_Ptr(boolean isInValidParam, boolean isInValidPtr, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   937  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   938      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   939      uint8   ErrorId;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   940      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   941  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   942      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   943      ErrorId = COM_DET_NO_ERROR;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   944      Status  = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   945  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   946      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   947      if (Com_Uninit_Flag == COM_UNINIT)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   948      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   949          ErrorId = COM_E_UNINIT;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   950      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   951      else if (isInValidParam)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   952      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   953          ErrorId = COM_E_PARAM;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   954      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   955      else if (isInValidPtr)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   956      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   957          ErrorId = COM_E_PARAM_POINTER;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   958      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   959      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   960      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   961          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   962      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   963  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   964      /* Check if ErrorId has Error Code */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   965      if (ErrorId != COM_DET_NO_ERROR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   966      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   967          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   968          COM_REPORT_ERROR_CHECK(ApiId, ErrorId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   969          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   970          Status = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   971      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   972      return Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   973  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   974  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   975  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   976  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   977   Function name    : Com_Prv_DETCheck_Ptr_Only
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   978   Syntax           : boolean Com_Prv_DETCheck_Ptr_Only(boolean isInValidPtr, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   979   Description      : Inline function to check for valid pointer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   980   Parameter        : isInValidPtr - calling service is called with invalid pointer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   981                      ApiId        - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   982   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   983                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   984   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   985  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Ptr_Only(boolean isInValidPtr, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   986  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   987      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   988      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   989  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   990      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   991      Status = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   992  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   993      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   994      if (isInValidPtr)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   995      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   996          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   997          COM_REPORT_ERROR_CHECK(ApiId, COM_E_PARAM_POINTER);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   998          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   999          Status = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1000      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1001      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1002      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1003          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1004      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1005  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1006      return Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1007  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1008  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1009  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1010  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1011   Function name    : Com_Prv_DETCheck_Param_Only
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1012   Syntax           : boolean Com_Prv_DETCheck_Param_Only(boolean isInValidParam, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1013   Description      : Inline function to check for module initialization and valid parameter value.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1014   Parameter        : isInValidParam - calling service is called with invalid parameter value
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1015                      ApiId          - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1016   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1017                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1018   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1019  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Param_Only(boolean isInValidParam, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1020  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1021      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1022      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1023  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1024      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1025      Status = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1026  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1027      if (isInValidParam)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1028      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1029          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1030          COM_REPORT_ERROR_CHECK(ApiId, COM_E_PARAM);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1031          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1032          Status = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1033      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1034      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1035      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1036          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1037      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1038  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1039      return Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1040  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1041  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1042  #endif /* #if(COM_CONFIGURATION_USE_DET == STD_ON) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1043  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1044  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1045   Function name    : Com_CheckTxIPduStatus
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1046   Syntax           : boolean Com_CheckTxIPduStatus(PduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1047   Description      : Inline function to check TxIPdu status
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1048   Parameter        : IpduId - TxIPdu Id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1049   Return value     : COM_TRUE  - TxIPdu is started
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1050                      COM_FALSE - TxIPdu is stopped
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1051   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1052  LOCAL_INLINE boolean Com_CheckTxIPduStatus(PduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1053  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1054      VAR(boolean, AUTOMATIC) TxIPduStatus;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1055  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1056      TxIPduStatus =  Com_GetRamValue(TXIPDU,_PDUSTATUS,COM_GET_TXPDURAM_S(IpduId).Com_TxFlags)
	sha	d15,d8,#4
	addsc.a	a15,a15,d15,#0
	ld.hu	d15,[a15]12
.L51:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
	mov	d0,#1
.L84:
	sh	d0,#0
.L85:
	and	d15,d0
.L86:
	ne	d15,d15,#0
.L87:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));      (inlined)
	j	.L9

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }      (inlined)
.L9:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1070      return TxIPduStatus;      (inlined)
	j	.L10

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1071  }      (inlined)
.L10:

; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    44  
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    45  #endif
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    46  
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    47      if(Com_CheckTxIPduStatus((PduIdType)PduId))
	jeq	d15,#0,.L11
.L45:

; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    48          {
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    49  
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    50              /* Check whether the large data pdu flag has been reset */
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    51  #ifdef COM_TP_IPDUTYPE
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    52              if (Com_GetRamValue(TXIPDU,_LARGEDATAINPROG,TxIpduRamPtr->Com_TxFlags) != COM_TRUE)
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    53  #endif /*#ifdef COM_TP_IPDUTYPE*/
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    54              {
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    55                  /* All unused flags are reset here */
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    56                  Com_SendIpduInfo sendIpduFlag_u16 = COM_CLEAR_SENDIPDU_FLAGS;
	movh.a	a15,#@his(.1.ini)
	lea	a15,[a15]@los(.1.ini)
	ld.bu	d5,[a15]
.L64:

; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    57                  sendIpduFlag_u16.isEventTrig = COM_SET;
	mov	d15,#1
.L88:
	insert	d5,d5,d15,#0,#1
.L89:

; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    58                  /* Call Com_Prv_SendIpdu,for the Ipdu, indicating mode change */
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    59                  sendIpduFlag_u16.isModeChangd = COM_RESET;
	mov	d15,#0
.L90:
	insert	d5,d5,d15,#3,#1
.L91:

; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    60                  /* As the signal transfer property information is not known here.
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    61                   * It is assumed, for transmission from this APi,the signal transfer property is Pending */
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    62                  /* The timeout handling should happen as usual*/
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    63  #ifdef COM_TxIPduTimeOut
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    64  
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    65                  sendIpduFlag_u16.isTimeoutReq = (0u != TxIPduConstPtr->Timeout_Fact)? COM_SET : COM_RESET;
	ld.hu	d15,[a2]10
.L92:
	ne	d15,d15,#0
.L93:
	j	.L13
.L12:
	mov	d15,#0
.L13:
	insert	d5,d5,d15,#5,#1
.L94:

; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    66  
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    67  #endif
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    68                  /* [SWS_Com_00388] Ignore repetitions */
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    69                  sendIpduFlag_u16.ignoreRepetitions = COM_SET;
	mov	d15,#1
.L95:
	insert	d5,d5,d15,#6,#1
.L96:

; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    70  
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    71                  Com_Prv_SendIpdu((PduIdType) PduId, sendIpduFlag_u16);
	mov	d4,d8
.L65:
	call	Com_Prv_SendIpdu
.L11:
.L8:

; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    72              }
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    73  
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    74          }
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    75      }
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    76  }
	ret
.L25:
	
__Com_TriggerIPDUSend_function_end:
	.size	Com_TriggerIPDUSend,__Com_TriggerIPDUSend_function_end-Com_TriggerIPDUSend
.L24:
	; End of function
	
	.sdecl	'.rodata.Com_TriggerIPDUSend..1.ini',data,rom
	.sect	'.rodata.Com_TriggerIPDUSend..1.ini'
.1.ini:	.type	object
	.size	.1.ini,1
	.space	1
	.calls	'Com_TriggerIPDUSend','Det_ReportError'
	.calls	'Com_TriggerIPDUSend','Com_Prv_SendIpdu'
	.extern	Det_ReportError
	.extern	Com_Prv_SendIpdu
	.extern	Com_Uninit_Flag
	.extern	Com_TxIpduRam_s
	.extern	Com_Prv_xTxIpduCfg_acst
	.calls	'Com_TriggerIPDUSend','',0
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L17:
	.word	13865
	.half	3
	.word	.L18
	.byte	4
.L16:
	.byte	1
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_TriggerIPDUSend.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L19
.L40:
	.byte	2
	.byte	'unsigned char',0,1,8
.L26:
	.byte	2
	.byte	'unsigned short int',0,2,7
.L50:
	.byte	3
	.byte	'Bfx_Prv_GetBit_u16u8_u8_Inl',0,3,1,207,2,22
	.word	145
	.byte	1,1
.L52:
	.byte	4
	.byte	'Data',0,1,207,2,57
	.word	162
.L54:
	.byte	4
	.byte	'BitPn',0,1,207,2,69
	.word	145
.L56:
	.byte	5,0,2
	.byte	'unsigned int',0,4,7,3
	.byte	'Bfx_Prv_GetBit_u32u8_u8_Inl',0,3,1,227,2,22
	.word	145
	.byte	1,1,4
	.byte	'Data',0,1,227,2,57
	.word	255
	.byte	4
	.byte	'BitPn',0,1,227,2,69
	.word	145
	.byte	5,0,3
	.byte	'Bfx_Prv_GetBit_u8u8_u8_Inl',0,3,1,247,2,22
	.word	145
	.byte	1,1,4
	.byte	'Data',0,1,247,2,55
	.word	145
	.byte	4
	.byte	'BitPn',0,1,247,2,67
	.word	145
	.byte	5,0,3
	.byte	'Bfx_Prv_GetBits_u8u8u8_u8_Inl',0,3,1,179,3,20
	.word	145
	.byte	1,1,4
	.byte	'Data',0,1,179,3,56
	.word	145
	.byte	4
	.byte	'BitStartPn',0,1,179,3,68
	.word	145
	.byte	4
	.byte	'BitLn',0,1,179,3,86
	.word	145
	.byte	5,0,6
	.word	162
	.byte	7
	.byte	'Bfx_Prv_PutBit_u16u8u8_Inl',0,3,1,200,3,19,1,1,4
	.byte	'Data',0,1,200,3,54
	.word	505
	.byte	4
	.byte	'BitPn',0,1,200,3,66
	.word	145
	.byte	4
	.byte	'Value',0,1,200,3,81
	.word	145
	.byte	5,0,6
	.word	255
	.byte	7
	.byte	'Bfx_Prv_PutBit_u32u8u8_Inl',0,3,1,224,3,19,1,1,4
	.byte	'Data',0,1,224,3,54
	.word	591
	.byte	4
	.byte	'BitPn',0,1,224,3,66
	.word	145
	.byte	4
	.byte	'Value',0,1,224,3,81
	.word	145
	.byte	5,0,6
	.word	145
	.byte	7
	.byte	'Bfx_Prv_PutBit_u8u8u8_Inl',0,3,1,248,3,19,1,1,4
	.byte	'Data',0,1,248,3,52
	.word	677
	.byte	4
	.byte	'BitPn',0,1,248,3,64
	.word	145
	.byte	4
	.byte	'Value',0,1,248,3,79
	.word	145
	.byte	5,0,3
	.byte	'Bfx_Prv_TstParityEven_u32_u8_Inl',0,3,1,143,10,22
	.word	145
	.byte	1,1,4
	.byte	'Data',0,1,143,10,62
	.word	255
	.byte	5,0
.L43:
	.byte	3
	.byte	'Com_CheckTxIPduStatus',0,3,2,156,8,22
	.word	145
	.byte	1,1
.L46:
	.byte	4
	.byte	'IpduId',0,2,156,8,54
	.word	162
.L48:
	.byte	8,5,0,0
.L32:
	.byte	3
	.byte	'Com_Prv_DETCheck_Param',0,3,2,207,6,37
	.word	145
	.byte	1,1
.L35:
	.byte	4
	.byte	'isInValidParam',0,2,207,6,68
	.word	145
.L37:
	.byte	4
	.byte	'ApiId',0,2,207,6,90
	.word	145
.L39:
	.byte	5,0,9,3,76,9,8,10
	.byte	'TimePeriodFact',0
	.word	162
	.byte	2,2,35,0,10
	.byte	'TimeOffsetFact',0
	.word	162
	.byte	2,2,35,2,10
	.byte	'RepetitionPeriodFact',0
	.word	162
	.byte	2,2,35,4,10
	.byte	'NumOfRepetitions',0
	.word	145
	.byte	1,2,35,6,10
	.byte	'Mode',0
	.word	145
	.byte	1,2,35,7,0,11
	.word	953
	.byte	6
	.word	1077
	.byte	9,3,211,5,9,24,10
	.byte	'BuffPtr',0
	.word	677
	.byte	4,2,35,0,10
	.byte	'Com_TMConstPtr',0
	.word	1082
	.byte	4,2,35,4,10
	.byte	'Size',0
	.word	162
	.byte	2,2,35,8,10
	.byte	'Timeout_Fact',0
	.word	162
	.byte	2,2,35,10,10
	.byte	'Min_Delay_Time_Fact',0
	.word	162
	.byte	2,2,35,12,10
	.byte	'No_Of_Sig_Ref',0
	.word	162
	.byte	2,2,35,14,10
	.byte	'PdurId',0
	.word	162
	.byte	2,2,35,16,10
	.byte	'TxSigId_Index',0
	.word	145
	.byte	1,2,35,18,10
	.byte	'txIPduFields',0
	.word	162
	.byte	2,2,35,20,10
	.byte	'MainFunctionRef',0
	.word	145
	.byte	1,2,35,22,10
	.byte	'PaddingByte',0
	.word	145
	.byte	1,2,35,23,0,11
	.word	1087
	.byte	6
	.word	1330
	.byte	11
	.word	1087
	.byte	6
	.word	1340
.L28:
	.byte	12
	.byte	'Com_TxIpduConstPtrType',0,3,171,6,72
	.word	1345
	.byte	12
	.byte	'Com_TMConstPtrType',0,3,103,65
	.word	1082
	.byte	9,3,135,9,9,16,10
	.byte	'CurrentTxModePtr',0
	.word	1382
	.byte	4,2,35,0,10
	.byte	'Com_MinDelayTick',0
	.word	162
	.byte	2,2,35,4,10
	.byte	'Com_Tick_Tx',0
	.word	162
	.byte	2,2,35,6,10
	.byte	'Com_n_Tick_Tx',0
	.word	162
	.byte	2,2,35,8,10
	.byte	'Com_TickTxTimeout',0
	.word	162
	.byte	2,2,35,10,10
	.byte	'Com_TxFlags',0
	.word	162
	.byte	2,2,35,12,10
	.byte	'Com_n',0
	.word	145
	.byte	1,2,35,14,10
	.byte	'Com_TransMode',0
	.word	145
	.byte	1,2,35,15,0,6
	.word	1409
	.byte	11
	.word	953
	.byte	6
	.word	1603
	.byte	6
	.word	1409
.L30:
	.byte	12
	.byte	'Com_TxIpduRamPtrType',0,3,198,9,62
	.word	1613
.L57:
	.byte	9,3,52,9,1,13
	.byte	'isEventTrig',0,1
	.word	145
	.byte	1,7,2,35,0,13
	.byte	'isTriggerIpduSendWithMetadata',0,1
	.word	145
	.byte	1,6,2,35,0,13
	.byte	'isGwIpduSend',0,1
	.word	145
	.byte	1,5,2,35,0,13
	.byte	'isModeChangd',0,1
	.word	145
	.byte	1,4,2,35,0,13
	.byte	'sigTransProp',0,1
	.word	145
	.byte	1,3,2,35,0,13
	.byte	'isTimeoutReq',0,1
	.word	145
	.byte	1,2,2,35,0,13
	.byte	'ignoreRepetitions',0,1
	.word	145
	.byte	1,1,2,35,0,0,14
	.byte	'Det_ReportError',0,4,112,16
	.word	145
	.byte	1,1,1,1,4
	.byte	'ModuleId',0,4,112,39
	.word	162
	.byte	4
	.byte	'InstanceId',0,4,112,55
	.word	145
	.byte	4
	.byte	'ApiId',0,4,112,73
	.word	145
	.byte	4
	.byte	'ErrorId',0,4,112,86
	.word	145
	.byte	0,15
	.word	184
	.byte	16
	.word	224
	.byte	16
	.word	238
	.byte	5,0,15
	.word	271
	.byte	16
	.word	311
	.byte	16
	.word	325
	.byte	5,0,15
	.word	342
	.byte	16
	.word	381
	.byte	16
	.word	395
	.byte	5,0,15
	.word	412
	.byte	16
	.word	454
	.byte	16
	.word	468
	.byte	16
	.word	488
	.byte	5,0,15
	.word	510
	.byte	16
	.word	545
	.byte	16
	.word	559
	.byte	16
	.word	574
	.byte	5,0,15
	.word	596
	.byte	16
	.word	631
	.byte	16
	.word	645
	.byte	16
	.word	660
	.byte	5,0,15
	.word	682
	.byte	16
	.word	716
	.byte	16
	.word	730
	.byte	16
	.word	745
	.byte	5,0,15
	.word	762
	.byte	16
	.word	807
	.byte	5,0,17
	.byte	'Com_Prv_SendIpdu',0,5,255,21,22,1,1,1,1,4
	.byte	'ComTxPduId',0,5,255,21,66
	.word	162
	.byte	4
	.byte	'sendIpduFlag_u16',0,5,128,22,73
	.word	1648
	.byte	0,15
	.word	823
	.byte	16
	.word	857
	.byte	8,18
	.word	184
	.byte	16
	.word	224
	.byte	16
	.word	238
	.byte	19
	.word	253
	.byte	0,5,0,0,15
	.word	877
	.byte	16
	.word	912
	.byte	16
	.word	936
	.byte	5,0,20,1,6
	.word	2214
	.byte	12
	.byte	'__codeptr',0,6,1,1
	.word	2216
	.byte	2
	.byte	'char',0,1,6,12
	.byte	'sint8',0,7,76,25
	.word	2239
	.byte	12
	.byte	'uint8',0,7,81,25
	.word	145
	.byte	12
	.byte	'uint16',0,7,91,25
	.word	162
	.byte	12
	.byte	'uint32',0,7,106,24
	.word	255
	.byte	2
	.byte	'unsigned long long int',0,8,7,12
	.byte	'uint64',0,7,111,30
	.word	2305
	.byte	12
	.byte	'boolean',0,7,127,25
	.word	145
	.byte	12
	.byte	'StatusType',0,8,191,1,27
	.word	145
	.byte	12
	.byte	'Std_ReturnType',0,8,199,1,15
	.word	145
	.byte	9,8,206,1,9,8,10
	.byte	'vendorID',0
	.word	162
	.byte	2,2,35,0,10
	.byte	'moduleID',0
	.word	162
	.byte	2,2,35,2,10
	.byte	'sw_major_version',0
	.word	145
	.byte	1,2,35,4,10
	.byte	'sw_minor_version',0
	.word	145
	.byte	1,2,35,5,10
	.byte	'sw_patch_version',0
	.word	145
	.byte	1,2,35,6,0,12
	.byte	'Std_VersionInfoType',0,8,213,1,3
	.word	2406
	.byte	12
	.byte	'PduIdType',0,9,22,19
	.word	162
	.byte	12
	.byte	'PduLengthType',0,9,26,19
	.word	162
	.byte	21,10,113,9,4,22
	.byte	'TP_DATACONF',0,0,22
	.byte	'TP_DATARETRY',0,1,22
	.byte	'TP_CONFPENDING',0,2,0,12
	.byte	'TpDataStateType',0,10,118,3
	.word	2596
	.byte	12
	.byte	'Com_SignalIdType',0,11,100,16
	.word	162
	.byte	12
	.byte	'Com_SignalGroupIdType',0,11,102,16
	.word	162
	.byte	12
	.byte	'Com_IpduIdType',0,11,104,15
	.word	145
	.byte	12
	.byte	'Com_GrpSignalIdType',0,11,107,18
	.word	145
	.byte	21,11,117,9,4,22
	.byte	'COM_UNINIT',0,0,22
	.byte	'COM_INIT',0,1,0,12
	.byte	'Com_StatusType',0,11,121,2
	.word	2778
	.byte	12
	.byte	'Com_TxIntSignalIdType',0,12,138,3,18
	.word	145
	.byte	12
	.byte	'Com_RxIntSignalIdType',0,12,139,3,18
	.word	145
	.byte	12
	.byte	'Com_BitsizeType',0,12,155,3,17
	.word	145
	.byte	12
	.byte	'Com_BitpositionType',0,12,156,3,15
	.word	145
	.byte	12
	.byte	'Com_RxGwQueueIndexType',0,12,161,3,15
	.word	145
	.byte	12
	.byte	'Com_SigBuffIndexType',0,12,164,3,15
	.word	145
	.byte	12
	.byte	'Com_SigMaxType',0,12,198,3,16
	.word	255
	.byte	12
	.byte	'Com_MainFuncType',0,12,231,3,16
	.word	145
	.byte	12
	.byte	'Com_NumOfIpdusType',0,12,233,3,15
	.word	145
	.byte	12
	.byte	'Com_TimeBaseType',0,12,235,3,15
	.word	145
	.byte	12
	.byte	'Can_IdType',0,13,32,16
	.word	255
	.byte	12
	.byte	'Can_HwHandleType',0,13,43,16
	.word	162
	.byte	9,14,93,9,8,10
	.byte	'Class',0
	.word	145
	.byte	1,2,35,0,10
	.byte	'TIN',0
	.word	145
	.byte	1,2,35,1,10
	.byte	'ReturnAddress',0
	.word	255
	.byte	4,2,35,4,0,12
	.byte	'OsTrapInfoType',0,14,97,3
	.word	3157
	.byte	23,68
	.word	255
	.byte	24,16,0,9,14,154,1,9,68,10
	.byte	'store',0
	.word	3237
	.byte	68,2,35,0,0,23,68
	.word	3246
	.byte	24,0,0,12
	.byte	'Os_JumpBufType',0,14,156,1,3
	.word	3268
	.byte	12
	.byte	'Os_StackTraceType',0,14,174,1,18
	.word	255
	.byte	9,14,175,1,9,8,10
	.byte	'sp',0
	.word	255
	.byte	4,2,35,0,10
	.byte	'ctx',0
	.word	255
	.byte	4,2,35,4,0,12
	.byte	'Os_StackValueType',0,14,175,1,63
	.word	3328
	.byte	12
	.byte	'Os_StackSizeType',0,14,176,1,27
	.word	3328
	.byte	25,1,1,6
	.word	3413
	.byte	12
	.byte	'Os_VoidVoidFunctionType',0,14,179,1,16
	.word	3416
	.byte	12
	.byte	'ApplicationType',0,14,193,1,23
	.word	145
	.byte	26
	.byte	'Os_ApplicationConfigurationType_s',0,14,198,1,16,2,10
	.byte	'app_id',0
	.word	145
	.byte	1,2,35,0,10
	.byte	'access',0
	.word	145
	.byte	1,2,35,1,0,12
	.byte	'Os_ApplicationConfigurationType',0,14,201,1,3
	.word	3479
	.byte	12
	.byte	'Os_CoreStateType',0,14,203,1,16
	.word	255
	.byte	12
	.byte	'AreaIdType',0,14,204,1,16
	.word	162
	.byte	12
	.byte	'Os_PeripheralAddressType',0,14,212,1,22
	.word	255
	.byte	12
	.byte	'TickType',0,14,221,1,22
	.word	255
	.byte	12
	.byte	'Os_StopwatchTickType',0,14,225,1,22
	.word	255
	.byte	12
	.byte	'Os_Lockable',0,14,234,1,18
	.word	591
	.byte	12
	.byte	'CoreIdType',0,14,236,1,16
	.word	162
	.byte	12
	.byte	'SpinlockIdType',0,14,237,1,16
	.word	162
	.byte	21,14,239,1,9,4,22
	.byte	'TRYTOGETSPINLOCK_SUCCESS',0,0,22
	.byte	'TRYTOGETSPINLOCK_NOSUCCESS',0,1,0,12
	.byte	'TryToGetSpinlockType',0,14,239,1,74
	.word	3786
	.byte	21,14,174,2,9,4,22
	.byte	'APPLICATION_ACCESSIBLE',0,0,22
	.byte	'APPLICATION_RESTARTING',0,1,22
	.byte	'APPLICATION_TERMINATED',0,2,0,12
	.byte	'ApplicationStateType',0,14,174,2,92
	.word	3879
	.byte	27
	.byte	'void',0,6
	.word	3991
	.byte	28,1,1,29
	.word	145
	.byte	29
	.word	3997
	.byte	0,6
	.word	4002
	.byte	12
	.byte	'Os_FunctionEntryType',0,14,183,2,16
	.word	4016
	.byte	26
	.byte	'Os_MeterInfoType_s',0,14,193,2,16,48,10
	.byte	'elapsed',0
	.word	255
	.byte	4,2,35,0,10
	.byte	'previous',0
	.word	255
	.byte	4,2,35,4,10
	.byte	'max',0
	.word	255
	.byte	4,2,35,8,10
	.byte	'cumulative',0
	.word	255
	.byte	4,2,35,12,10
	.byte	'stackbase',0
	.word	3328
	.byte	8,2,35,16,10
	.byte	'stackusage',0
	.word	3328
	.byte	8,2,35,24,10
	.byte	'stackmax',0
	.word	3328
	.byte	8,2,35,32,10
	.byte	'stackbudget',0
	.word	3328
	.byte	8,2,35,40,0,12
	.byte	'Os_MeterInfoType',0,14,202,2,3
	.word	4051
	.byte	6
	.word	4051
	.byte	12
	.byte	'Os_MeterInfoRefType',0,14,203,2,50
	.word	4249
	.byte	12
	.byte	'EventMaskType',0,14,206,2,15
	.word	145
	.byte	12
	.byte	'Os_imaskType',0,14,211,2,16
	.word	255
	.byte	26
	.byte	'Os_ISRDynType_s',0,14,213,2,16,48,10
	.byte	'meter',0
	.word	4051
	.byte	48,2,35,0,0,12
	.byte	'Os_ISRDynType',0,14,215,2,3
	.word	4328
	.byte	6
	.word	4328
	.byte	11
	.word	4389
	.byte	26
	.byte	'Os_ISRType_s',0,14,216,2,16,24,10
	.byte	'entry_function',0
	.word	3421
	.byte	4,2,35,0,10
	.byte	'dynamic',0
	.word	4394
	.byte	4,2,35,4,10
	.byte	'imask',0
	.word	255
	.byte	4,2,35,8,10
	.byte	'stackbudget',0
	.word	3328
	.byte	8,2,35,12,10
	.byte	'access',0
	.word	145
	.byte	1,2,35,20,10
	.byte	'application',0
	.word	145
	.byte	1,2,35,21,0,12
	.byte	'Os_ISRType',0,14,223,2,3
	.word	4399
	.byte	6
	.word	3413
	.byte	11
	.word	4399
	.byte	6
	.word	4558
	.byte	12
	.byte	'ISRType',0,14,224,2,46
	.word	4563
	.byte	12
	.byte	'Os_bitmask',0,14,239,2,22
	.word	255
	.byte	12
	.byte	'Os_pset0Type',0,14,240,2,20
	.word	255
	.byte	12
	.byte	'Os_pset1Type',0,14,241,2,20
	.word	255
	.byte	12
	.byte	'Os_pset2Type',0,14,242,2,20
	.word	255
	.byte	30,14,243,2,9,4,10
	.byte	'p0',0
	.word	255
	.byte	4,2,35,0,10
	.byte	'p1',0
	.word	255
	.byte	4,2,35,0,10
	.byte	'p2',0
	.word	255
	.byte	4,2,35,0,0,12
	.byte	'Os_psetType',0,14,247,2,3
	.word	4671
	.byte	30,14,249,2,9,4,10
	.byte	't0',0
	.word	255
	.byte	4,2,35,0,10
	.byte	't1',0
	.word	255
	.byte	4,2,35,0,10
	.byte	't2',0
	.word	255
	.byte	4,2,35,0,0,12
	.byte	'Os_tpmaskType',0,14,253,2,3
	.word	4735
	.byte	12
	.byte	'Os_ActivationCountType',0,14,254,2,23
	.word	145
	.byte	26
	.byte	'Os_TaskDynType_s',0,14,128,3,16,120,10
	.byte	'terminate_jump_buf',0
	.word	3277
	.byte	68,2,35,0,10
	.byte	'meter',0
	.word	4051
	.byte	48,2,35,68,10
	.byte	'activation_count',0
	.word	145
	.byte	1,2,35,116,0,12
	.byte	'Os_TaskDynType',0,14,132,3,3
	.word	4833
	.byte	23,68
	.word	3246
	.byte	24,0,0,6
	.word	4833
	.byte	11
	.word	4959
	.byte	26
	.byte	'Os_TaskType_s',0,14,134,3,16,40,10
	.byte	'dynamic',0
	.word	4964
	.byte	4,2,35,0,10
	.byte	'entry_function',0
	.word	3421
	.byte	4,2,35,4,10
	.byte	'pset',0
	.word	4671
	.byte	4,2,35,8,10
	.byte	'base_tpmask',0
	.word	4735
	.byte	4,2,35,12,10
	.byte	'tpmask',0
	.word	4735
	.byte	4,2,35,16,10
	.byte	'core_id',0
	.word	162
	.byte	2,2,35,20,10
	.byte	'index',0
	.word	255
	.byte	4,2,35,24,10
	.byte	'stackbudget',0
	.word	3328
	.byte	8,2,35,28,10
	.byte	'activation_count',0
	.word	145
	.byte	1,2,35,36,10
	.byte	'access',0
	.word	145
	.byte	1,2,35,37,10
	.byte	'application',0
	.word	145
	.byte	1,2,35,38,0,12
	.byte	'Os_TaskType',0,14,146,3,3
	.word	4969
	.byte	11
	.word	4969
	.byte	6
	.word	5219
	.byte	12
	.byte	'TaskType',0,14,147,3,47
	.word	5224
	.byte	31
	.byte	'Os_TaskStateType',0,14,155,3,6,4,22
	.byte	'SUSPENDED',0,0,22
	.byte	'READY',0,1,22
	.byte	'WAITING',0,2,22
	.byte	'RUNNING',0,3,0,12
	.byte	'TaskStateType',0,14,156,3,31
	.word	5247
	.byte	30,14,167,3,3,4,10
	.byte	'tpmask',0
	.word	4735
	.byte	4,2,35,0,0,26
	.byte	'Os_ResourceDynType_s',0,14,166,3,16,4,10
	.byte	'saved_priority',0
	.word	5334
	.byte	4,2,35,0,0,12
	.byte	'Os_ResourceDynType',0,14,170,3,3
	.word	5357
	.byte	6
	.word	5357
	.byte	11
	.word	5437
	.byte	26
	.byte	'Os_ResourceType_s',0,14,171,3,16,12,10
	.byte	'dynamic',0
	.word	5442
	.byte	4,2,35,0,10
	.byte	'tpmask',0
	.word	4735
	.byte	4,2,35,4,10
	.byte	'access',0
	.word	145
	.byte	1,2,35,8,0,12
	.byte	'Os_ResourceType',0,14,175,3,3
	.word	5447
	.byte	9,14,181,3,9,12,10
	.byte	'maxallowedvalue',0
	.word	255
	.byte	4,2,35,0,10
	.byte	'ticksperbase',0
	.word	255
	.byte	4,2,35,4,10
	.byte	'mincycle',0
	.word	255
	.byte	4,2,35,8,0,12
	.byte	'AlarmBaseType',0,14,185,3,3
	.word	5546
	.byte	9,14,206,3,9,8,10
	.byte	'Running',0
	.word	145
	.byte	1,2,35,0,10
	.byte	'Pending',0
	.word	145
	.byte	1,2,35,1,10
	.byte	'Delay',0
	.word	255
	.byte	4,2,35,4,0,12
	.byte	'Os_CounterStatusType',0,14,210,3,3
	.word	5641
	.byte	32
	.word	145
	.byte	1,1,6
	.word	5727
	.byte	12
	.byte	'Os_CounterIncrAdvType',0,14,217,3,22
	.word	5734
	.byte	26
	.byte	's_swd',0,14,222,3,12,4,10
	.byte	'count',0
	.word	255
	.byte	4,2,35,0,0,30,14,221,3,3,4,10
	.byte	'sw',0
	.word	5770
	.byte	4,2,35,0,0,26
	.byte	'Os_CounterDynType_s',0,14,220,3,16,4,10
	.byte	'type_dependent',0
	.word	5798
	.byte	4,2,35,0,0,12
	.byte	'Os_CounterDynType',0,14,226,3,3
	.word	5817
	.byte	6
	.word	5817
	.byte	11
	.word	5895
	.byte	26
	.byte	'Os_CounterType_s',0,14,227,3,16,28,10
	.byte	'dynamic',0
	.word	5900
	.byte	4,2,35,0,10
	.byte	'advincr',0
	.word	5739
	.byte	4,2,35,4,10
	.byte	'base',0
	.word	5546
	.byte	12,2,35,8,10
	.byte	'core',0
	.word	3997
	.byte	4,2,35,20,10
	.byte	'access',0
	.word	145
	.byte	1,2,35,24,10
	.byte	'application',0
	.word	145
	.byte	1,2,35,25,0,12
	.byte	'Os_CounterType',0,14,234,3,3
	.word	5905
	.byte	6
	.word	5727
	.byte	11
	.word	5905
	.byte	6
	.word	6057
	.byte	12
	.byte	'CounterType',0,14,235,3,52
	.word	6062
	.byte	31
	.byte	'Os_ScheduleTableStatusType',0,14,240,3,6,4,22
	.byte	'SCHEDULETABLE_STOPPED',0,0,22
	.byte	'SCHEDULETABLE_NEXT',0,1,22
	.byte	'SCHEDULETABLE_WAITING',0,2,22
	.byte	'SCHEDULETABLE_RUNNING',0,3,22
	.byte	'SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS',0,4,0,12
	.byte	'ScheduleTableStatusType',0,14,241,3,41
	.word	6088
	.byte	11
	.word	.L66-.L17
	.byte	6
	.word	6288
	.byte	12
	.byte	'ScheduleTableType',0,14,128,4,58
	.word	6293
	.byte	26
	.byte	'Os_ScheduleTableDynType_s',0,14,130,4,16,16,10
	.byte	'match',0
	.word	255
	.byte	4,2,35,0,10
	.byte	'next',0
	.word	6298
	.byte	4,2,35,4,10
	.byte	'state',0
	.word	6088
	.byte	4,2,35,8,10
	.byte	'config',0
	.word	162
	.byte	2,2,35,12,0,6
	.word	6325
	.byte	11
	.word	6418
.L66:
	.byte	26
	.byte	'Os_ScheduleTableType_s',0,14,247,3,16,16,10
	.byte	'dynamic',0
	.word	6423
	.byte	4,2,35,0,10
	.byte	'counter',0
	.word	6067
	.byte	4,2,35,4,10
	.byte	'repeat',0
	.word	145
	.byte	1,2,35,8,10
	.byte	'config',0
	.word	162
	.byte	2,2,35,10,10
	.byte	'initial',0
	.word	145
	.byte	1,2,35,12,10
	.byte	'access',0
	.word	145
	.byte	1,2,35,13,10
	.byte	'application',0
	.word	145
	.byte	1,2,35,14,0,12
	.byte	'Os_ScheduleTableType',0,14,255,3,3
	.word	6428
	.byte	11
	.word	6428
	.byte	6
	.word	6608
	.byte	11
	.word	5905
	.byte	6
	.word	6618
	.byte	33
	.word	3721
	.byte	33
	.word	4671
	.byte	33
	.word	4568
	.byte	33
	.word	5229
	.byte	33
	.word	4735
	.byte	33
	.word	145
	.byte	33
	.word	5229
	.byte	26
	.byte	'Os_ControlledCoreType_s',0,14,251,6,16,112,10
	.byte	'TrapInfo',0
	.word	3157
	.byte	8,2,35,0,10
	.byte	'lock_taskaccess',0
	.word	6628
	.byte	4,2,35,8,10
	.byte	'ReadyTasks',0
	.word	6633
	.byte	4,2,35,12,10
	.byte	'RunningISR',0
	.word	6638
	.byte	4,2,35,16,10
	.byte	'RunningTask',0
	.word	6643
	.byte	4,2,35,20,10
	.byte	'RunningTPMask',0
	.word	6648
	.byte	4,2,35,24,10
	.byte	'CurrentMeteredObject',0
	.word	4254
	.byte	4,2,35,28,10
	.byte	'IdleMeter',0
	.word	4051
	.byte	48,2,35,32,10
	.byte	'AppAccess',0
	.word	145
	.byte	1,2,35,80,10
	.byte	'AppOverride',0
	.word	6653
	.byte	1,2,35,81,10
	.byte	'GetStackValueAdjust',0
	.word	3328
	.byte	8,2,35,84,10
	.byte	'InErrorHook',0
	.word	145
	.byte	1,2,35,92,10
	.byte	'ChainTaskRef',0
	.word	6658
	.byte	4,2,35,96,10
	.byte	'GetStackUsageAdjust',0
	.word	3328
	.byte	8,2,35,100,10
	.byte	'InProtectionHook',0
	.word	145
	.byte	1,2,35,108,10
	.byte	'CoreIsActive',0
	.word	145
	.byte	1,2,35,109,10
	.byte	'InShutdownHook',0
	.word	145
	.byte	1,2,35,110,0,12
	.byte	'Os_ControlledCoreType',0,14,141,7,3
	.word	6663
	.byte	6
	.word	255
	.byte	11
	.word	4399
	.byte	6
	.word	7119
	.byte	11
	.word	4969
	.byte	6
	.word	7129
	.byte	6
	.word	4051
	.byte	26
	.byte	'Os_AnyCoreType_s',0,14,151,7,16,96,10
	.byte	'DisableAllImask',0
	.word	255
	.byte	4,2,35,0,10
	.byte	'SuspendAllImask',0
	.word	255
	.byte	4,2,35,4,10
	.byte	'SuspendOSImask',0
	.word	255
	.byte	4,2,35,8,10
	.byte	'DisableAllCount',0
	.word	255
	.byte	4,2,35,12,10
	.byte	'SuspendAllCount',0
	.word	255
	.byte	4,2,35,16,10
	.byte	'SuspendOSCount',0
	.word	255
	.byte	4,2,35,20,10
	.byte	'RestartJumpBuf',0
	.word	3277
	.byte	68,2,35,24,10
	.byte	'Restartable',0
	.word	145
	.byte	1,2,35,92,0,12
	.byte	'Os_AnyCoreType',0,14,160,7,3
	.word	7144
	.byte	12
	.byte	'Can_TxObjPriorityClassType',0,15,219,3,16
	.word	255
	.byte	26
	.byte	'Can_TxHwObjectConfigType',0,15,231,3,16,8,10
	.byte	'MsgObjId',0
	.word	145
	.byte	1,2,35,0,10
	.byte	'HwControllerId',0
	.word	145
	.byte	1,2,35,1,10
	.byte	'TxObjPriorityClass',0
	.word	255
	.byte	4,2,35,4,0,12
	.byte	'Can_TxHwObjectConfigType',0,15,252,3,3
	.word	7421
	.byte	26
	.byte	'Can_RxHwObjectConfigType',0,15,129,4,16,12,10
	.byte	'MaskRef',0
	.word	255
	.byte	4,2,35,0,10
	.byte	'MsgId',0
	.word	255
	.byte	4,2,35,4,10
	.byte	'MsgObjId',0
	.word	145
	.byte	1,2,35,8,10
	.byte	'HwControllerId',0
	.word	145
	.byte	1,2,35,9,0,12
	.byte	'Can_RxHwObjectConfigType',0,15,147,4,3
	.word	7557
	.byte	23,4
	.word	145
	.byte	24,3,0,26
	.byte	'Can_ControllerMOMapConfigType',0,15,181,4,16,4,10
	.byte	'ControllerMOMap',0
	.word	7697
	.byte	4,2,35,0,0,12
	.byte	'Can_ControllerMOMapConfigType',0,15,184,4,3
	.word	7706
	.byte	26
	.byte	'Can_NPCRValueType',0,15,188,4,16,2,10
	.byte	'Can_NPCRValue',0
	.word	162
	.byte	2,2,35,0,0,12
	.byte	'Can_NPCRValueType',0,15,191,4,3
	.word	7807
	.byte	26
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,15,194,4,16,8,10
	.byte	'CanControllerBaudrate',0
	.word	255
	.byte	4,2,35,0,10
	.byte	'CanControllerBaudrateCfg',0
	.word	162
	.byte	2,2,35,4,0,12
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,15,198,4,3
	.word	7882
	.byte	11
	.word	7882
	.byte	6
	.word	8047
	.byte	26
	.byte	'Can_BaudrateConfigPtrType',0,15,201,4,16,4,10
	.byte	'Can_kBaudrateConfigPtr',0
	.word	8052
	.byte	4,2,35,0,0,12
	.byte	'Can_BaudrateConfigPtrType',0,15,204,4,3
	.word	8057
	.byte	26
	.byte	'Can_EventHandlingType',0,15,226,4,16,4,10
	.byte	'CanEventType',0
	.word	7697
	.byte	4,2,35,0,0,12
	.byte	'Can_EventHandlingType',0,15,229,4,3
	.word	8157
	.byte	12
	.byte	'Rte_TransformerErrorCode',0,16,130,1,15
	.word	145
	.byte	12
	.byte	'Rte_TransformerClass',0,16,131,1,15
	.word	145
	.byte	9,16,168,1,9,12,10
	.byte	'in',0
	.word	3997
	.byte	4,2,35,0,10
	.byte	'out',0
	.word	3997
	.byte	4,2,35,4,10
	.byte	'used',0
	.word	162
	.byte	2,2,35,8,10
	.byte	'lost_data',0
	.word	145
	.byte	1,2,35,10,0,12
	.byte	'Rte_QDynType',0,16,173,1,3
	.word	8303
	.byte	21,16,175,1,9,4,22
	.byte	'RTE_DRA',0,0,22
	.byte	'RTE_WOWP',0,1,22
	.byte	'RTE_TASK',0,2,22
	.byte	'RTE_ARE',0,3,22
	.byte	'RTE_EV',0,4,22
	.byte	'RTE_MSI',0,5,0,12
	.byte	'Rte_NotificationType',0,16,182,1,3
	.word	8390
	.byte	6
	.word	8303
	.byte	26
	.byte	'Rte_QCmnType',0,16,184,1,16,24,10
	.byte	'dynamic',0
	.word	8488
	.byte	4,2,35,0,10
	.byte	'copy',0
	.word	145
	.byte	1,2,35,4,10
	.byte	'queue_size',0
	.word	162
	.byte	2,2,35,6,10
	.byte	'element_size',0
	.word	162
	.byte	2,2,35,8,10
	.byte	'buffer_start',0
	.word	3997
	.byte	4,2,35,12,10
	.byte	'buffer_end',0
	.word	3997
	.byte	4,2,35,16,10
	.byte	'notification_type',0
	.word	8390
	.byte	4,2,35,20,0,12
	.byte	'Rte_QCmnType',0,16,192,1,3
	.word	8493
	.byte	12
	.byte	'Rte_AlarmRefType',0,16,224,1,32
	.word	255
	.byte	12
	.byte	'Rte_AlarmIndexType',0,16,226,1,32
	.word	162
	.byte	23,128,8
	.word	145
	.byte	24,255,7,0,12
	.byte	'Impl_NVM_DstPtrType_1024',0,17,50,15
	.word	8731
	.byte	12
	.byte	'CanIf_u32_impl',0,17,69,16
	.word	255
	.byte	12
	.byte	'CanIf_u16_impl',0,17,71,16
	.word	162
	.byte	12
	.byte	'CanIf_u8_impl',0,17,73,15
	.word	145
	.byte	12
	.byte	'CanIf_ControllerModeType_Enum_impl',0,17,88,15
	.word	145
	.byte	12
	.byte	'CanIf_PduModeType_Enum_impl',0,17,90,15
	.word	145
	.byte	9,17,92,9,2,10
	.byte	'DeviceMode',0
	.word	145
	.byte	1,2,35,0,10
	.byte	'ChannelMode',0
	.word	145
	.byte	1,2,35,1,0,12
	.byte	'CanIf_ControllerStateType_struct_impl',0,17,95,3
	.word	8922
	.byte	12
	.byte	'CanIf_NotifStatusType_Enum_impl',0,17,100,15
	.word	145
	.byte	12
	.byte	'CanSM_boolean_Impl',0,17,120,15
	.word	145
	.byte	12
	.byte	'CanSM_u8_Impl',0,17,123,15
	.word	145
	.byte	12
	.byte	'CanSM_BusOffRecoveryStateType_Enum_impl',0,17,128,1,15
	.word	145
	.byte	12
	.byte	'CanSM_NetworkModeStateType_Enum_impl',0,17,132,1,15
	.word	145
	.byte	12
	.byte	'CanSM_u16_Impl',0,17,136,1,16
	.word	162
	.byte	12
	.byte	'CanSM_TimerStateType_Enum_impl',0,17,138,1,15
	.word	145
	.byte	9,17,140,1,9,4,10
	.byte	'cntTick_u16',0
	.word	162
	.byte	2,2,35,0,10
	.byte	'stTimer',0
	.word	145
	.byte	1,2,35,2,0,12
	.byte	'CanSM_TimerConfig_tst_struct_impl',0,17,143,1,3
	.word	9263
	.byte	12
	.byte	'Com_impl_u16',0,17,154,1,16
	.word	162
	.byte	12
	.byte	'Com_impl_u8',0,17,157,1,15
	.word	145
	.byte	12
	.byte	'ComM_uint32_Impl',0,17,173,1,16
	.word	255
	.byte	12
	.byte	'ComM_uint16_Impl',0,17,175,1,16
	.word	162
	.byte	12
	.byte	'ComM_uint8_Impl',0,17,177,1,15
	.word	145
	.byte	12
	.byte	'ComM_bool_Impl',0,17,179,1,15
	.word	145
	.byte	9,17,181,1,9,24,10
	.byte	'ChannelState_e',0
	.word	255
	.byte	4,2,35,0,10
	.byte	'LightTimeoutCtr_u32',0
	.word	255
	.byte	4,2,35,4,10
	.byte	'MinFullComTimeoutCtr_u16',0
	.word	162
	.byte	2,2,35,8,10
	.byte	'ChannelMode_u8',0
	.word	145
	.byte	1,2,35,10,10
	.byte	'BusSmMode_u8',0
	.word	145
	.byte	1,2,35,11,10
	.byte	'UserRequestCtr_u8',0
	.word	145
	.byte	1,2,35,12,10
	.byte	'PassiveRequestState_u8',0
	.word	145
	.byte	1,2,35,13,10
	.byte	'PncRequestCtr_u8',0
	.word	145
	.byte	1,2,35,14,10
	.byte	'InhibitionReqStatus_u8',0
	.word	145
	.byte	1,2,35,15,10
	.byte	'NmNetworkRequestStatus_b',0
	.word	145
	.byte	1,2,35,16,10
	.byte	'DiagnosticRequestState_b',0
	.word	145
	.byte	1,2,35,17,10
	.byte	'CommunicationAllowed_b',0
	.word	145
	.byte	1,2,35,18,10
	.byte	'NmBusSleepIndicationStatus_b',0
	.word	145
	.byte	1,2,35,19,10
	.byte	'NmPrepareBusSleepIndicationStatus_b',0
	.word	145
	.byte	1,2,35,20,10
	.byte	'NmNetworkModeStatus_b',0
	.word	145
	.byte	1,2,35,21,0,12
	.byte	'ComM_ChannelStruct_Impl',0,17,197,1,3
	.word	9495
	.byte	9,17,206,1,9,10,10
	.byte	'WakeUpInhibitionCtr_u16',0
	.word	162
	.byte	2,2,35,0,10
	.byte	'LimitToNoComCtr_u16',0
	.word	162
	.byte	2,2,35,2,10
	.byte	'RequestedUserMode_t',0
	.word	145
	.byte	1,2,35,4,10
	.byte	'IndicatedUserMode_t',0
	.word	145
	.byte	1,2,35,5,10
	.byte	'numChannelsInFullCom_u8',0
	.word	145
	.byte	1,2,35,6,10
	.byte	'numChannelsInSilentCom_u8',0
	.word	145
	.byte	1,2,35,7,10
	.byte	'numChannelsInNoCom_u8',0
	.word	145
	.byte	1,2,35,8,0,12
	.byte	'ComM_UserStruct_Impl',0,17,214,1,3
	.word	9999
	.byte	12
	.byte	'Dcm_IOOperationResponseType',0,17,252,1,15
	.word	145
	.byte	12
	.byte	'Dcm_RequestDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspRequestRoutineResultsOutSignal_0PrimitivType',0
	.byte	17,138,2,15
	.word	145
	.byte	12
	.byte	'Dcm_StartDataIn_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineInSignalPrimitivType',0,17,146,2,15
	.word	145
	.byte	12
	.byte	'Dcm_StartDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineOutSignalPrimitivType',0,17,150,2,15
	.word	145
	.byte	12
	.byte	'Dcm_StopDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStopRoutineOutSignalPrimitivType',0,17,154,2,15
	.word	145
	.byte	12
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockNative_1024_Type',0,17,243,3,34
	.word	8742
	.byte	23,128,8
	.word	145
	.byte	24,255,7,0,12
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockRedundant_1024_Type',0,17,246,3,34
	.word	8742
	.byte	12
	.byte	'Rte_TaskRefType',0,18,184,1,32
	.word	5229
	.byte	12
	.byte	'Rte_EventRefType',0,18,185,1,32
	.word	145
	.byte	12
	.byte	'Rte_EventType',0,18,186,1,32
	.word	255
	.byte	12
	.byte	'Rte_REActCounterType',0,18,252,1,15
	.word	145
	.byte	6
	.word	145
	.byte	12
	.byte	'Rte_REActCounterRefType',0,18,253,1,58
	.word	10921
	.byte	9,18,255,1,9,8,10
	.byte	'task',0
	.word	10817
	.byte	4,2,35,0,10
	.byte	'acnt',0
	.word	10926
	.byte	4,2,35,4,0,12
	.byte	'Rte_REContainerType',0,18,130,2,3
	.word	10959
	.byte	11
	.word	4969
	.byte	6
	.word	11023
	.byte	6
	.word	145
	.byte	11
	.word	10959
	.byte	6
	.word	11038
	.byte	12
	.byte	'Rte_REContainerRefType',0,18,132,2,60
	.word	11043
	.byte	12
	.byte	'Rte_MSICounterType',0,18,149,2,16
	.word	162
	.byte	6
	.word	162
	.byte	12
	.byte	'Rte_MSICounterRefType',0,18,150,2,56
	.word	11108
	.byte	12
	.byte	'Rte_MSIPendingFlagType',0,18,152,2,17
	.word	145
	.byte	6
	.word	145
	.byte	12
	.byte	'Rte_MSIPendingFlagRefType',0,18,153,2,60
	.word	11176
	.byte	9,18,163,2,9,24,10
	.byte	'counter',0
	.word	11113
	.byte	4,2,35,0,10
	.byte	'incCounter',0
	.word	145
	.byte	1,2,35,4,10
	.byte	'pending',0
	.word	11181
	.byte	4,2,35,8,10
	.byte	'osTask',0
	.word	10817
	.byte	4,2,35,12,10
	.byte	'acnt',0
	.word	10926
	.byte	4,2,35,16,10
	.byte	'osEvent',0
	.word	145
	.byte	1,2,35,20,10
	.byte	'MSIInit',0
	.word	162
	.byte	2,2,35,22,0,12
	.byte	'Rte_MSITableEntry',0,18,172,2,3
	.word	11216
	.byte	6
	.word	162
	.byte	6
	.word	145
	.byte	12
	.byte	'Rte_TaskArrayIndex',0,18,179,2,16
	.word	145
	.byte	12
	.byte	'Rte_NrWaitingTasks',0,18,180,2,16
	.word	145
	.byte	9,18,182,2,9,4,10
	.byte	'pending',0
	.word	145
	.byte	1,2,35,0,10
	.byte	'count',0
	.word	145
	.byte	1,2,35,1,10
	.byte	'firstWaitingTask',0
	.word	145
	.byte	1,2,35,2,0,12
	.byte	'Rte_WaitableDatum',0,18,186,2,3
	.word	11434
	.byte	6
	.word	11434
	.byte	9,18,226,2,9,12,10
	.byte	'event_id',0
	.word	255
	.byte	4,2,35,0,10
	.byte	'wd',0
	.word	11526
	.byte	4,2,35,4,10
	.byte	'timeout',0
	.word	255
	.byte	4,2,35,8,0,12
	.byte	'Rte_WOWP_NotificationType',0,18,230,2,3
	.word	11531
	.byte	11
	.word	11531
	.byte	6
	.word	11620
	.byte	12
	.byte	'Rte_WOWP_NotificationRefType',0,18,232,2,66
	.word	11625
	.byte	12
	.byte	'Rte_ARE_NotificationType',0,18,234,2,29
	.word	10959
	.byte	26
	.byte	'Rte_QTaskType',0,18,243,2,16,28,10
	.byte	'cmn',0
	.word	8493
	.byte	24,2,35,0,10
	.byte	'task',0
	.word	10817
	.byte	4,2,35,24,0,12
	.byte	'Rte_QTaskType',0,18,246,2,3
	.word	11702
	.byte	26
	.byte	'Rte_QREType',0,18,250,2,16,28,10
	.byte	'cmn',0
	.word	8493
	.byte	24,2,35,0,10
	.byte	're',0
	.word	11048
	.byte	4,2,35,24,0,12
	.byte	'Rte_QREType',0,18,253,2,3
	.word	11773
	.byte	11
	.word	10959
	.byte	6
	.word	11838
	.byte	26
	.byte	'Rte_QWWPType',0,18,129,3,16,28,10
	.byte	'cmn',0
	.word	8493
	.byte	24,2,35,0,10
	.byte	'wwp',0
	.word	11630
	.byte	4,2,35,24,0,12
	.byte	'Rte_QWWPType',0,18,132,3,3
	.word	11848
	.byte	11
	.word	11531
	.byte	6
	.word	11916
	.byte	26
	.byte	'Rte_QEvType',0,18,136,3,16,36,10
	.byte	'cmn',0
	.word	8493
	.byte	24,2,35,0,10
	.byte	'task',0
	.word	10817
	.byte	4,2,35,24,10
	.byte	'mask',0
	.word	145
	.byte	1,2,35,28,10
	.byte	'acnt',0
	.word	10926
	.byte	4,2,35,32,0,12
	.byte	'Rte_QEvType',0,18,141,3,3
	.word	11926
	.byte	26
	.byte	'Rte_QMSIType',0,18,145,3,16,48,10
	.byte	'cmn',0
	.word	8493
	.byte	24,2,35,0,10
	.byte	'task',0
	.word	10817
	.byte	4,2,35,24,10
	.byte	'mask',0
	.word	145
	.byte	1,2,35,28,10
	.byte	'acnt',0
	.word	10926
	.byte	4,2,35,32,10
	.byte	'msiCounter',0
	.word	11113
	.byte	4,2,35,36,10
	.byte	'msiPending',0
	.word	11181
	.byte	4,2,35,40,10
	.byte	'msiLimit',0
	.word	162
	.byte	2,2,35,44,0,12
	.byte	'Rte_QMSIType',0,18,153,3,3
	.word	12021
	.byte	12
	.byte	'Com_SendIpduInfo',0,3,61,3
	.word	1648
	.byte	12
	.byte	'Com_TransModeInfo',0,3,93,2
	.word	953
	.byte	9,3,136,1,9,12,10
	.byte	'Init_Val',0
	.word	255
	.byte	4,2,35,0,10
	.byte	'txSignalFields',0
	.word	162
	.byte	2,2,35,4,10
	.byte	'Bit_Pos',0
	.word	145
	.byte	1,2,35,6,10
	.byte	'BitSize',0
	.word	145
	.byte	1,2,35,7,10
	.byte	'IpduRef',0
	.word	145
	.byte	1,2,35,8,10
	.byte	'General',0
	.word	145
	.byte	1,2,35,9,0,12
	.byte	'Com_Prv_xTxSigCfg_tst',0,3,201,1,2
	.word	12227
	.byte	9,3,247,1,9,16,10
	.byte	'Notification_Cbk',0
	.word	3416
	.byte	4,2,35,0,10
	.byte	'Init_Val',0
	.word	255
	.byte	4,2,35,4,10
	.byte	'Bit_Pos',0
	.word	145
	.byte	1,2,35,8,10
	.byte	'SigBuff_Index',0
	.word	145
	.byte	1,2,35,9,10
	.byte	'BitSize',0
	.word	145
	.byte	1,2,35,10,10
	.byte	'IpduRef',0
	.word	145
	.byte	1,2,35,11,10
	.byte	'General',0
	.word	145
	.byte	1,2,35,12,10
	.byte	'rxSignalFields',0
	.word	145
	.byte	1,2,35,13,0,12
	.byte	'Com_Prv_xRxSigCfg_tst',0,3,171,2,2
	.word	12375
	.byte	11
	.word	12375
	.byte	6
	.word	12572
	.byte	12
	.byte	'Com_RxSigConstPtrType',0,3,180,2,68
	.word	12577
	.byte	12
	.byte	'Com_Prv_xTxIpduInfoCfg_tst',0,3,162,6,3
	.word	1087
	.byte	9,3,137,7,9,20,10
	.byte	'BuffPtr',0
	.word	677
	.byte	4,2,35,0,10
	.byte	'TimeOutNotification_Cbk',0
	.word	3416
	.byte	4,2,35,4,10
	.byte	'Size',0
	.word	162
	.byte	2,2,35,8,10
	.byte	'FirstTimeout_Factor',0
	.word	162
	.byte	2,2,35,10,10
	.byte	'Timeout_Fact',0
	.word	162
	.byte	2,2,35,12,10
	.byte	'No_Of_Sig_Ref',0
	.word	162
	.byte	2,2,35,14,10
	.byte	'RxSigId_Index',0
	.word	145
	.byte	1,2,35,16,10
	.byte	'MainFunctionRef',0
	.word	145
	.byte	1,2,35,17,10
	.byte	'rxIPduFields',0
	.word	145
	.byte	1,2,35,18,0,12
	.byte	'Com_Prv_xRxIpduInfoCfg_tst',0,3,197,7,3
	.word	12649
	.byte	9,3,219,7,9,4,10
	.byte	'FirstIpdu_Index',0
	.word	162
	.byte	2,2,35,0,10
	.byte	'NoOfRxPdus',0
	.word	162
	.byte	2,2,35,2,0,12
	.byte	'Com_Prv_xIpduGrpInfoCfg_tst',0,3,224,7,3
	.word	12900
	.byte	9,3,244,7,9,1,10
	.byte	'txSigRAMFields',0
	.word	145
	.byte	1,2,35,0,0,12
	.byte	'Com_TxSignalFlagType',0,3,248,7,2
	.word	12989
	.byte	9,3,167,8,9,1,10
	.byte	'rxSigRAMFields',0
	.word	145
	.byte	1,2,35,0,0,12
	.byte	'Com_RxSignalFlagType',0,3,171,8,2
	.word	13050
	.byte	12
	.byte	'Com_TxIpduRamData',0,3,189,9,3
	.word	1409
	.byte	9,3,218,9,9,6,10
	.byte	'RxIPduLength',0
	.word	162
	.byte	2,2,35,0,10
	.byte	'RxTicks_u16',0
	.word	162
	.byte	2,2,35,2,10
	.byte	'RxFlags',0
	.word	145
	.byte	1,2,35,4,0,12
	.byte	'Com_RxIpduRamData',0,3,245,9,2
	.word	13138
	.byte	6
	.word	162
	.byte	9,3,128,10,9,8,10
	.byte	'RxGwQueuePtr',0
	.word	13232
	.byte	4,2,35,0,10
	.byte	'Com_RxGwQueueWrite_ux',0
	.word	145
	.byte	1,2,35,4,10
	.byte	'Com_RxGwQueueRead_ux',0
	.word	145
	.byte	1,2,35,5,0,12
	.byte	'Com_RxGwQueueRAMType',0,3,133,10,2
	.word	13237
	.byte	9,3,138,10,9,4,10
	.byte	'indexGwMapSigDestIdArray',0
	.word	162
	.byte	2,2,35,0,10
	.byte	'destCount',0
	.word	145
	.byte	1,2,35,2,0,12
	.byte	'Com_Prv_xGwMapSigCfg_tst',0,3,142,10,2
	.word	13357
	.byte	9,3,147,10,9,2,10
	.byte	'GwMap_DestId',0
	.word	162
	.byte	2,2,35,0,0,12
	.byte	'Com_Prv_xGwMapSigIdCfg_tst',0,3,150,10,2
	.word	13451
	.byte	9,3,183,10,9,4,10
	.byte	'StartIPduId',0
	.word	145
	.byte	1,2,35,0,10
	.byte	'NumOfIpdus',0
	.word	145
	.byte	1,2,35,1,10
	.byte	'TimeBaseInMs',0
	.word	145
	.byte	1,2,35,2,0,12
	.byte	'Com_MainFunctionCfgType',0,3,188,10,3
	.word	13516
	.byte	9,3,194,10,9,12,10
	.byte	'Com_SigType_pu8',0
	.word	677
	.byte	4,2,35,0,10
	.byte	'Com_SigType_pu16',0
	.word	505
	.byte	4,2,35,4,10
	.byte	'Com_SigType_pu32',0
	.word	591
	.byte	4,2,35,8,0,12
	.byte	'Com_Prv_xRxRamBuf_tst',0,3,253,10,3
	.word	13619
	.byte	12
	.byte	'rba_BswSrv_uint64',0,19,66,28
	.word	2305
	.byte	34
	.byte	'Com_Uninit_Flag',0,5,139,24,45
	.word	2778
	.byte	1,1,35
	.word	1409
	.byte	36,0,34
	.byte	'Com_TxIpduRam_s',0,5,211,24,42
	.word	13787
	.byte	1,1,35
	.word	1087
	.byte	36,0,11
	.word	13821
	.byte	34
	.byte	'Com_Prv_xTxIpduCfg_acst',0,5,137,26,57
	.word	13828
	.byte	1,1,0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L18:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,36,0,3,8,11,15,62,15,0,0,3,46,1,3,8,32,13,58,15,59,15
	.byte	57,15,73,19,54,15,39,12,0,0,4,5,0,3,8,58,15,59,15,57,15,73,19,0,0,5,11,0,0,0,6,15,0,73,19,0,0,7,46,1,3
	.byte	8,32,13,58,15,59,15,57,15,54,15,39,12,0,0,8,11,1,0,0,9,19,1,58,15,59,15,57,15,11,15,0,0,10,13,0,3,8,73
	.byte	19,11,15,56,9,0,0,11,38,0,73,19,0,0,12,22,0,3,8,58,15,59,15,57,15,73,19,0,0,13,13,0,3,8,11,15,73,19,13
	.byte	15,12,15,56,9,0,0,14,46,1,3,8,58,15,59,15,57,15,73,19,54,15,39,12,63,12,60,12,0,0,15,46,1,49,19,0,0,16
	.byte	5,0,49,19,0,0,17,46,1,3,8,58,15,59,15,57,15,54,15,39,12,63,12,60,12,0,0,18,29,1,49,19,0,0,19,11,0,49,19
	.byte	0,0,20,21,0,54,15,0,0,21,4,1,58,15,59,15,57,15,11,15,0,0,22,40,0,3,8,28,13,0,0,23,1,1,11,15,73,19,0,0
	.byte	24,33,0,47,15,0,0,25,21,0,54,15,39,12,0,0,26,19,1,3,8,58,15,59,15,57,15,11,15,0,0,27,59,0,3,8,0,0,28,21
	.byte	1,54,15,39,12,0,0,29,5,0,73,19,0,0,30,23,1,58,15,59,15,57,15,11,15,0,0,31,4,1,3,8,58,15,59,15,57,15,11
	.byte	15,0,0,32,21,0,73,19,54,15,39,12,0,0,33,53,0,73,19,0,0,34,52,0,3,8,58,15,59,15,57,15,73,19,63,12,60,12
	.byte	0,0,35,1,1,73,19,0,0,36,33,0,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L19:
	.word	.L68-.L67
.L67:
	.half	3
	.word	.L70-.L69
.L69:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Bfx\\api\\Bfx_Bit_Inl.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv_Inl.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Det\\api\\Det.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_TriggerIPDUSend.c',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Platform\\Platform_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Std_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Com\\Com_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Com\\Com_Cfg_Internal.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Can_GeneralTypes.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\RTOS_T\\Gen\\inc\\Os.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Can_17_MCanP\\inc\\Can_17_MCanP.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Type.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Intl.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\rba_BswSrv.h',0,0,0,0,0
.L70:
.L68:
	.sdecl	'.debug_info',debug,cluster('Com_TriggerIPDUSend')
	.sect	'.debug_info'
.L20:
	.word	505
	.half	3
	.word	.L21
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_TriggerIPDUSend.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L23,.L22
	.byte	2
	.word	.L16
	.byte	3
	.byte	'Com_TriggerIPDUSend',0,1,21,22,1,1,1
	.word	.L15,.L25,.L14
	.byte	4
	.byte	'PduId',0,1,21,68
	.word	.L26,.L27
	.byte	5
	.word	.L15,.L25
	.byte	6
	.byte	'TxIPduConstPtr',0,1,24,28
	.word	.L28,.L29
	.byte	6
	.byte	'TxIpduRamPtr',0,1,26,26
	.word	.L30,.L31
	.byte	7
	.word	.L32,.L33,.L34
	.byte	8
	.word	.L35,.L36
	.byte	8
	.word	.L37,.L38
	.byte	9
	.word	.L39,.L33,.L34
	.byte	6
	.byte	'ErrorId',0,2,210,6,13
	.word	.L40,.L41
	.byte	6
	.byte	'Status',0,2,211,6,13
	.word	.L40,.L42
	.byte	0,0,7
	.word	.L43,.L44,.L45
	.byte	8
	.word	.L46,.L47
	.byte	9
	.word	.L48,.L44,.L45
	.byte	6
	.byte	'TxIPduStatus',0,2,158,8,29
	.word	.L40,.L49
	.byte	7
	.word	.L50,.L51,.L9
	.byte	8
	.word	.L52,.L53
	.byte	8
	.word	.L54,.L55
	.byte	10
	.word	.L56,.L51,.L9
	.byte	0,0,0,5
	.word	.L45,.L8
	.byte	6
	.byte	'sendIpduFlag_u16',0,1,56,34
	.word	.L57,.L58
	.byte	0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('Com_TriggerIPDUSend')
	.sect	'.debug_abbrev'
.L21:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,52,0,3
	.byte	8,58,15,59,15,57,15,73,16,2,6,0,0,7,29,1,49,16,17,1,18,1,0,0,8,5,0,49,16,2,6,0,0,9,11,1,49,16,17,1,18
	.byte	1,0,0,10,11,0,49,16,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('Com_TriggerIPDUSend')
	.sect	'.debug_line'
.L22:
	.word	.L72-.L71
.L71:
	.half	3
	.word	.L74-.L73
.L73:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_TriggerIPDUSend.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv_Inl.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Bfx\\api\\Bfx_Bit_Inl.h',0,0,0,0,0
.L74:
	.byte	5,22,7,0,5,2
	.word	.L15
	.byte	3,20,1,5,41,9
	.half	.L60-.L15
	.byte	3,9,1,5,66,9
	.half	.L75-.L60
	.byte	1,4,2,5,13,9
	.half	.L33-.L75
	.byte	3,184,6,1,9
	.half	.L61-.L33
	.byte	3,1,1,5,9,9
	.half	.L63-.L61
	.byte	3,3,1,5,5,9
	.half	.L76-.L63
	.byte	1,5,17,7,9
	.half	.L77-.L76
	.byte	3,2,1,5,31,9
	.half	.L78-.L77
	.byte	1,5,10,9
	.half	.L2-.L78
	.byte	3,2,1,5,17,7,9
	.half	.L79-.L2
	.byte	3,2,1,5,30,9
	.half	.L80-.L79
	.byte	1,5,20,9
	.half	.L3-.L80
	.byte	3,8,1,5,5,9
	.half	.L81-.L3
	.byte	1,5,9,7,9
	.half	.L82-.L81
	.byte	3,3,1,5,16,9
	.half	.L62-.L82
	.byte	3,2,1,5,5,9
	.half	.L6-.L62
	.byte	3,2,1,4,1,9
	.half	.L7-.L6
	.byte	3,175,121,1,5,25,7,9
	.half	.L34-.L7
	.byte	3,9,1,5,26,9
	.half	.L83-.L34
	.byte	3,4,1,4,2,5,21,9
	.half	.L44-.L83
	.byte	3,245,7,1,4,3,5,35,9
	.half	.L51-.L44
	.byte	3,177,122,1,5,39,9
	.half	.L84-.L51
	.byte	1,5,22,9
	.half	.L85-.L84
	.byte	1,5,51,9
	.half	.L86-.L85
	.byte	1,5,5,9
	.half	.L87-.L86
	.byte	1,4,2,9
	.half	.L9-.L87
	.byte	3,221,5,1,4,1,9
	.half	.L10-.L9
	.byte	3,129,120,1,5,53,7,9
	.half	.L45-.L10
	.byte	3,9,1,5,48,9
	.half	.L64-.L45
	.byte	3,1,1,5,46,9
	.half	.L88-.L64
	.byte	1,5,49,9
	.half	.L89-.L88
	.byte	3,2,1,5,47,9
	.half	.L90-.L89
	.byte	1,5,70,9
	.half	.L91-.L90
	.byte	3,6,1,5,49,9
	.half	.L92-.L91
	.byte	1,5,95,9
	.half	.L93-.L92
	.byte	1,5,85,9
	.half	.L12-.L93
	.byte	1,5,47,9
	.half	.L13-.L12
	.byte	1,5,54,9
	.half	.L94-.L13
	.byte	3,4,1,5,52,9
	.half	.L95-.L94
	.byte	1,5,53,9
	.half	.L96-.L95
	.byte	3,2,1,5,1,9
	.half	.L8-.L96
	.byte	3,5,1,7,9
	.half	.L24-.L8
	.byte	0,1,1
.L72:
	.sdecl	'.debug_ranges',debug,cluster('Com_TriggerIPDUSend')
	.sect	'.debug_ranges'
.L23:
	.word	-1,.L15,0,.L24-.L15,0,0
	.sdecl	'.debug_loc',debug,cluster('Com_TriggerIPDUSend')
	.sect	'.debug_loc'
.L38:
	.word	0,0
.L55:
	.word	0,0
.L14:
	.word	-1,.L15,0,.L25-.L15
	.half	2
	.byte	138,0
	.word	0,0
.L53:
	.word	0,0
.L41:
	.word	-1,.L15,.L61-.L15,.L62-.L15
	.half	1
	.byte	87
	.word	0,0
.L47:
	.word	0,0
.L27:
	.word	-1,.L15,0,.L59-.L15
	.half	1
	.byte	84
	.word	.L60-.L15,.L12-.L15
	.half	1
	.byte	88
	.word	.L13-.L15,.L25-.L15
	.half	1
	.byte	88
	.word	.L65-.L15,.L8-.L15
	.half	1
	.byte	84
	.word	0,0
.L42:
	.word	-1,.L15,.L63-.L15,.L62-.L15
	.half	1
	.byte	81
	.word	.L6-.L15,.L12-.L15
	.half	1
	.byte	81
	.word	.L13-.L15,.L8-.L15
	.half	1
	.byte	81
	.word	0,0
.L29:
	.word	-1,.L15,.L44-.L15,.L12-.L15
	.half	1
	.byte	98
	.word	.L13-.L15,.L8-.L15
	.half	1
	.byte	98
	.word	0,0
.L49:
	.word	0,0
.L31:
	.word	0,0
.L36:
	.word	0,0
.L58:
	.word	-1,.L15,.L64-.L15,.L12-.L15
	.half	1
	.byte	85
	.word	.L13-.L15,.L8-.L15
	.half	1
	.byte	85
	.word	0,0
	.sdecl	'.debug_frame',debug
	.sect	'.debug_frame'
.L97:
	.word	48
	.word	-1
	.byte	3,0,2,1,27,12,26,0,8,27,8,26,8,28,8,29,8,30,8,31,8,34,8,35,8,32,8,33,8,16,8,17,8,24,8,25,8,36,8,37,8,38
	.byte	8,39
	.sdecl	'.debug_frame',debug,cluster('Com_TriggerIPDUSend')
	.sect	'.debug_frame'
	.word	12
	.word	.L97,.L15,.L25-.L15

; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    77  #define COM_STOP_SEC_CODE
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    78  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_TriggerIPDUSend.c	    79  

	; Module end
