	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 19053136 SN 09001910"
	.compiler_invocation	"ctc -f cc14820a -c99 --integer-enumeration -D__CPU__=tc27x -D__CPU_TC27X__ --core=tc1.6.x --eabi-compliant --fp-model=-float -D_TASKING_C_TRICORE_=1 -I.\\output\\inc -g2 -t4 --language=-comments,-gcc,+volatile,-strings --default-near-size=0 -O2ROPYGKLF-predict --default-a1-size=0 --default-a0-size=0 --source --switch=auto -o output\\objs\\BSW\\src\\BSW\\Gen\\Com\\Com_TxChangeMode.src BSW\\src\\BSW\\Gen\\Com\\src\\Com_TxChangeMode.c"
	.compiler_name		"ctc"
	;source	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_TxChangeMode.c'

	
$TC16X
	
	.sdecl	'.text.Com_TxChangeMode.Com_TxChangeMode',code,cluster('Com_TxChangeMode')
	.sect	'.text.Com_TxChangeMode.Com_TxChangeMode'
	.align	2
	
	.global	Com_TxChangeMode

; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	     1  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	     2  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	     3  /**************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	     4  /* Preprocessor includes                                                                          */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	     5  /**************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	     6  #include "Com_Prv.h"
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	     7  #include "Com_Prv_Inl.h"
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	     8  /**************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	     9  /* Global functions (declared in header files )                                                   */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    10  /**************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    11  #ifdef COM_TxFilters
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    12  LOCAL_INLINE FUNC(void,COM_CODE) Com_Prv_TxChangeMode_Signal            (VAR(Com_IpduIdType, AUTOMATIC) TxIpduId);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    13  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    14  # ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    15  LOCAL_INLINE FUNC(void,COM_CODE) Com_Prv_TxChangeMode_SignalGroup       (VAR(Com_IpduIdType, AUTOMATIC) TxIpduId);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    16  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_TxChangeMode_GroupSignal    (VAR(Com_IpduIdType, AUTOMATIC) TxIpduId,
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    17                                                                           Com_TxGrpSigConstPtrType TxGrpSigConstPtr);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    18  # endif
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    19  #endif
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    20  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    21  /***************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    22   Function name    : Com_TxChangeMode
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    23   Syntax           : void Com_TxChangeMode(Com_IpduIdType TxIpduId)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    24   Description      : Internal function used for Transmission Mode Selector
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    25   Parameter        : TxIpduId
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    26   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    27   ***************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    28  #define COM_START_SEC_CODE
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    29  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    30  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    31  /* HIS METRIC CALLS VIOLATION IN Com_TxChangeMode:
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    32     Com_TxChangeMode function contains necessary function calls statements.
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    33     HIS metric compliance would decrease readability and maintainability */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    34  FUNC(void,COM_CODE) Com_TxChangeMode(VAR(Com_IpduIdType, AUTOMATIC) TxIpduId)
; Function Com_TxChangeMode
.L12:
Com_TxChangeMode:	.type	func
	mov	d0,d4
.L73:

; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    35  {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    36      /* Local pointer to hold the address of Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    37      Com_TxIpduConstPtrType                          TxIPduConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    38      /* Local pointer to hold the address of the Tx ipdu status structure */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    39      Com_TxIpduRamPtrType                            TxIpduRamPtr;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    40      VAR(uint8, AUTOMATIC)                           LatestTransMode_u8;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    41      VAR(boolean, AUTOMATIC)                         Mode;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    42  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    43      /* Initialise Mode as TRUE, it could be the most probable case */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    44      Mode = COM_TRUE;
	mov	d3,#1
.L75:

; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    45      TxIPduConstPtr   = COM_GET_TX_IPDU_CONSTDATA(TxIpduId);
	mul	d15,d0,#24
	movh.a	a15,#@his(Com_Prv_xTxIpduCfg_acst)
	lea	a15,[a15]@los(Com_Prv_xTxIpduCfg_acst)
	addsc.a	a2,a15,d15,#0
.L76:

; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    46      TxIpduRamPtr     = &COM_GET_TXPDURAM_S(TxIpduId);
	sha	d0,#4
.L74:
	movh.a	a15,#@his(Com_TxIpduRam_s)
	lea	a15,[a15]@los(Com_TxIpduRam_s)
	addsc.a	a15,a15,d0,#0
.L77:

; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    47  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    48      /* Call Filter for all signals and Group Signals in the IPDU */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    49  #ifdef COM_TxFilters
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    50      TxIpduRamPtr->Com_TMSTrueCounter_u8 = 0;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    51  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    52      /* Check if Transmission Mode switch is possible by signal filter mechanism */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    53      if (Com_GetValue(TXIPDU,_FILTEREVALREQ,TxIPduConstPtr->txIPduFields) != COM_FALSE )
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    54      {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    55          Com_Prv_TxChangeMode_Signal(TxIpduId);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    56  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    57  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    58          Com_Prv_TxChangeMode_SignalGroup(TxIpduId);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    59  #endif
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    60  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    61          if (TxIpduRamPtr->Com_TMSTrueCounter_u8 != 0)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    62          {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    63              /* If any signal/signal group evaluates filter as TRUE, then TM TRUE is selected for IPDU */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    64              Mode = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    65          }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    66          else
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    67          {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    68              /* If all signal/signal group evaluates filter as FALSE, then TM FALSE is selected for IPDU */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    69              Mode = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    70          }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    71      }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    72  #endif /*COM_TxFilters*/
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    73  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    74      /* If a change of the TMS causes a change of the transmission mode for one I-PDU, the timer for the cycle
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    75      time of the periodic and the Mixed Tx Mode shall be retstarted */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    76  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    77      /* Update the TxModeState with the Mode */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    78      Com_SetRamValue(TXIPDU,_TXMODESTATE,TxIpduRamPtr->Com_TransMode,Mode);
	lea	a4,[a15]15
.L32:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;      (inlined)
	ne	d0,d3,#0
.L78:
	j	.L3
.L2:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   439  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   440  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   441  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   442   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   443   * Bfx_PutBit_u16u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   444   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   445   * \brief Sets or clears a bit at a given position Pos_u32 in the 16-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   446   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   447   * A priori, range [0,15] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   448   * Note, neither the given position BitPn nor the given value Value not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   449   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   450   * \param   uint16*  Data   pointer to a 16-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   451   * \param   uint8    BitPn  position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   452   * \param   boolean  Value  defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   453   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   454   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   455   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   456  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   457  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   458      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   460      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   461      *Data = ((*Data & ((uint16)~(1uL << BitPn))) | ((uint16)((uint16)tmp_u8 << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   462  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   463  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   464  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   465  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   466   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   467   * Bfx_PutBit_u32u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   468   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   469   * \brief Sets or clears a bit at a given position Pos_u32 in the 32-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   470   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   471   * A priori, range [0,31] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   472   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   473   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   474   * \param   uint32*     Data        pointer to a 32-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   475   * \param   uint8       BitPn       position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   476   * \param   boolean     Value       defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   477   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   478   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   479   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   480  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   481  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   482      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   483      tmp_u8 = (Value)? 1u : 0u;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   484      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   485      *Data = ((*Data & ((uint32)~(1uL << BitPn))) | ((uint32)((uint32)tmp_u8 << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   486  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   487  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   488  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   489  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   490   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   491   * Bfx_PutBit_u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   492   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   493   * \brief Sets or clears a bit at a given position BitPn in the 8-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   494   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   495   * A priori, range [0,7] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   496   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   497   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   498   * \param  uint8*   Data    pointer to a 8-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   499   * \param  uint8    BitPn   position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   500   * \param  boolean  Value   defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   501   * \return void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   502   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   503   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   504  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   505  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   506      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;
	mov	d0,#0

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;      (inlined)
.L3:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   508      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   509      *Data = ((*Data & ((uint8)~(1uL <<BitPn))) | ((uint8)(tmp_u8 << BitPn)));
	ld.bu	d1,[a4]
.L92:
	mov	d2,#1
.L93:
	sh	d2,#2
.L94:
	xor	d2,d2,#255
.L95:
	and	d1,d2
.L96:
	sha	d0,#2
.L80:
	or	d1,d0
.L97:
	st.b	[a4],d1
.L33:

; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    79      /* Update the CurrentTxModePtr */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    80      Com_SetCurrentTxModePtr(TxIpduRamPtr,TxIPduConstPtr,Com_GetValue(TXIPDU,_TMS,TxIPduConstPtr->txIPduFields),Mode);
	ld.hu	d0,[a2]20
	mov	d1,#2
.L43:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
	sha	d0,#-1
.L98:
	mov.u	d2,#65535
.L99:
	rsub	d15,d1,#16
.L100:
	rsub	d15,#0
	sh	d2,d2,d15
.L101:
	and	d15,d0,d2
.L102:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));      (inlined)
	j	.L4

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }      (inlined)
.L4:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     1  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     2  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     3  #ifndef COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     4  #define COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     5  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     6  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     7   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     8   * Includes
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     9   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    10  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    11  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    12  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    13  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    17  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    18  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    19  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    20  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    21   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    22   * Type definitions
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    23   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    24  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    25  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    26  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    27  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    28   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    29   * Variables
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    30   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    31  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    32  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    33  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    34  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    35   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    36   * Extern declarations
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    37   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    38  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    39  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    40   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    41   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    42   * Inline function sets TMS data in to be accessesd via CurrentTxModePtr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    43   * after evaluating TMS mode for the IPdu
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    44   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    45  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    46  FUNC(void, COM_CODE) Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    47                                  Com_TxIpduRamPtrType                TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    48                                  Com_TxIpduConstPtrType              TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    49                                  VAR(uint16,AUTOMATIC)               TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    50                                  VAR(boolean,AUTOMATIC)              ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    51                                              );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    52  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    53  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    54   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    55   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    56   * Inline function to update Rx-GroupSignal application buffers
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    57   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    58  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    59  FUNC(void, COM_CODE) Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    60                                  Com_RxSigConstPtrType               RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    61                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    62                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    63                                               );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    64  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    65  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    66   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    67   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    68   * Inline function to update Rx-GroupSignal secondary buffers
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    69   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    70  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    71  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    72  FUNC(void, COM_CODE) Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    73                                  Com_RxGrpSigConstPtrType            RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    74                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    75                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    76                                                          );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    77  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    78  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    79  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    80   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    81   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    82   * Inline function to initialize signal intial value into the provided IPdu buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    83   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    84  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    85  FUNC(void, COM_CODE) Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    86                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    87                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    88                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    89                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    90                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    91                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    92                                                              );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    93  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    94  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    95   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    96   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    97   * Inline function to initialize Rx-signal group with initial values
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    98   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    99  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   100  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   101  FUNC(void, COM_CODE) Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   102                                  Com_RxSigGrpConstPtrType            RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   103                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   104                                                  );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   105  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   106  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   107  #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   108  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxNotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   109  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxErrNotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   110  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxTONotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   111  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallRxTONotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   112  #endif /* #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   113  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   114  /* Inline function to check for the RxIPdu and TxIpdu status*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   115  LOCAL_INLINE boolean Com_CheckRxIPduStatus(PduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   116  LOCAL_INLINE boolean Com_CheckTxIPduStatus(PduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   117  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   118  #if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   119  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   120  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Void(uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   121  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   122  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Ptr(boolean isInValidPtr, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   123  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Param_Ptr(boolean isInValidParam, boolean isInValidPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   124                                                                  uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   125  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Ptr_Only(boolean isInValidPtr, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   126  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Param_Only(boolean isInValidParam, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   127  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   128  #endif /*  #if (COM_CONFIGURATION_USE_DET == STD_ON) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   129  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   130  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   131  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   132  LOCAL_INLINE FUNC(void, COM_CODE) Com_CopyTxGroupSignalData( Com_SignalIdType    GrpSignalId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   133                                                               Com_SigMaxType      TxGrpSig_NewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   134                                                               Com_MainFuncType    TxMainFuncId );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   135  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   136  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   137  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   138   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   139   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   140   * Inline function to handle gateway and non-gateway use-case for tx-signal/signalGroup
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   141   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   142  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_ProceedToSendIpdu(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   143                                                  VAR(Com_IpduIdType, AUTOMATIC)          ComTxPduId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   144                                                  VAR(Com_SendIpduInfo, AUTOMATIC)        sendIpduFlag_u16
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   145                                                             );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   146  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   147  #ifdef COM_TxFilters
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   148  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_CheckModeChange(VAR(Com_IpduIdType, AUTOMATIC) TxIpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   149  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   150  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   151  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   152  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   153   * Inline Function Definition
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   154   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   155  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   156  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   157   Function name    : Com_SetCurrentTxModePtr [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   158   Syntax           : void Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   159                                  Com_TxIpduRamPtrType    TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   160                                  Com_TxIpduConstPtrType  TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   161                                  uint16                  TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   162                                  boolean                 ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   163                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   164   Description      : Inline function sets TMS data in to be accessesd via CurrentTxModePtr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   165                      after evaluating TMS mode for the IPdu
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   166  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   167                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   168                       * Mode                  |    Configuration details                              | Value|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   169                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   170                       * COM_MODE_VALID        |    Both the TRUE and FALSE modes are configured.      |    00|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   171                       * COM_TRUEMODE_VALID    |    Only TRUE mode is configured                       |    01|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   172                       * COM_FALSEMODE_VALID   |    Only FALSE mode is configured                      |    10|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   173                       * COM_MODE_INVALID      |    Both the TRUE and FALSE mode are not configured    |    11|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   174                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   175                      This INLINE function checks the TMS generated values against the requested mode and performs action
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   176                      |-------------|--------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   177                      |ModeRequested|Configured Mode values   |         Description                                           :      Action to be taken                |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   178                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   179                      |    0       |      0        |      0   |  FALSE mode is requested and IPdu TMS is COM_MODE_VALID         : Increment to the false mode data     |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   180                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   181                      |    0       |      0        |      1   |  FALSE mode is requested and IPdu TMS is COM_TRUEMODE_VALID     : Point to NONE mode data              |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   182                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   183                      |    0       |      1        |      0   |  FALSE mode is requested and IPdu TMS is COM_FALSEMODE_VALID     : Do nothing                          |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   184                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   185                      |    0       |      1        |      1   |  FALSE mode is requested and IPdu TMS is COM_MODE_INVALID     : Do nothing                             |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   186                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   187                      |    1       |      0        |      0   |  TRUE mode is requested and IPdu TMS is COM_MODE_VALID         : Do nothing                            |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   188                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   189                      |    1       |      0        |      1   |  TRUE mode is requested and IPdu TMS is COM_TRUEMODE_VALID     : Do nothing                            |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   190                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   191                      |    1       |      1        |      0   |  TRUE mode is requested and IPdu TMS is COM_FALSEMODE_VALID     : Point to NONE mode data              |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   192                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   193                      |    1       |      1        |      1   |  TRUE mode is requested and IPdu TMS is COM_MODE_INVALID         : Do nothing                          |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   194                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   195  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   196                      where 0 in column 1 stands for FALSE mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   197                      and   1 in column 1 stands for TRUE mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   198  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   199   Parameter        : TxIpduRamPtr    - pointer to Txipdu ram data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   200                    : TxIPduConstPtr  - pointer to Txipdu Rom data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   201                    : TMSStatus       - pointer to transmission mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   202                    : ModeRequested   - mode requested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   203   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   204   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   205  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   206  FUNC(void, COM_CODE) Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   207                                  Com_TxIpduRamPtrType                TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   208                                  Com_TxIpduConstPtrType              TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   209                                  VAR(uint16,AUTOMATIC)               TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   210                                  VAR(boolean,AUTOMATIC)              ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   211                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   212  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   213      /* Get the latest TM pointer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   214      TxIpduRamPtr->CurrentTxModePtr = TxIPduConstPtr->Com_TMConstPtr;
	ld.a	a2,[a2]4
.L79:
	st.a	[a15],a2
.L103:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   216      if(ModeRequested == COM_FALSE)      (inlined)
	jne	d3,#0,.L5
.L104:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   218          if((TMSStatus) == COM_TRUEMODE_VALID)      (inlined)
	jne	d15,#1,.L6
.L105:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   215  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   216      if(ModeRequested == COM_FALSE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   217      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   218          if((TMSStatus) == COM_TRUEMODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   219          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   220              /*If yes,load NONE mode data */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   221              TxIpduRamPtr->CurrentTxModePtr = &Com_NONE_TransModeInfo ;
	movh.a	a2,#@his(Com_NONE_TransModeInfo)
	lea	a2,[a2]@los(Com_NONE_TransModeInfo)
.L106:
	st.a	[a15],a2

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   218          if((TMSStatus) == COM_TRUEMODE_VALID)      (inlined)
.L6:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   223          if((TMSStatus) == COM_MODE_VALID)      (inlined)
	jne	d15,#0,.L7
.L107:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   222          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   223          if((TMSStatus) == COM_MODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   224          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   225              /*Increment to FALSE mode data, if the FALSE mode is configured */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   226              TxIpduRamPtr->CurrentTxModePtr++;
	ld.a	a2,[a15]
.L108:
	lea	a2,[a2]8
	st.a	[a15],a2

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   223          if((TMSStatus) == COM_MODE_VALID)      (inlined)
.L7:
	j	.L8

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   216      if(ModeRequested == COM_FALSE)      (inlined)
.L5:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   231          if((TMSStatus) == COM_FALSEMODE_VALID)      (inlined)
	jne	d15,#2,.L9
.L109:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   227          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   228      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   229      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   230      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   231          if((TMSStatus) == COM_FALSEMODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   232          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   233              TxIpduRamPtr->CurrentTxModePtr = &Com_NONE_TransModeInfo ;
	movh.a	a2,#@his(Com_NONE_TransModeInfo)
	lea	a2,[a2]@los(Com_NONE_TransModeInfo)
.L110:
	st.a	[a15],a2

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   231          if((TMSStatus) == COM_FALSEMODE_VALID)      (inlined)
.L9:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   229      else      (inlined)
.L8:

; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    81  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    82      /* Update the Com_LatestTransMode[TxIpduId] */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    83      LatestTransMode_u8 = TxIpduRamPtr->CurrentTxModePtr->Mode;
	ld.a	a2,[a15]
.L111:
	ld.bu	d15,[a2]7
.L81:

; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    84      Com_SetRamValue(TXIPDU,_LATESTMODE,TxIpduRamPtr->Com_TransMode,LatestTransMode_u8);
	lea	a2,[a15]15
	mov	d0,#2
.L62:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   439  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   440  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   441  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   442   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   443   * Bfx_PutBit_u16u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   444   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   445   * \brief Sets or clears a bit at a given position Pos_u32 in the 16-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   446   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   447   * A priori, range [0,15] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   448   * Note, neither the given position BitPn nor the given value Value not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   449   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   450   * \param   uint16*  Data   pointer to a 16-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   451   * \param   uint8    BitPn  position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   452   * \param   boolean  Value  defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   453   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   454   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   455   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   456  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   457  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   458      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   460      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   461      *Data = ((*Data & ((uint16)~(1uL << BitPn))) | ((uint16)((uint16)tmp_u8 << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   462  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   463  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   464  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   465  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   466   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   467   * Bfx_PutBit_u32u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   468   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   469   * \brief Sets or clears a bit at a given position Pos_u32 in the 32-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   470   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   471   * A priori, range [0,31] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   472   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   473   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   474   * \param   uint32*     Data        pointer to a 32-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   475   * \param   uint8       BitPn       position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   476   * \param   boolean     Value       defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   477   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   478   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   479   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   480  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   481  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   482      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   483      tmp_u8 = (Value)? 1u : 0u;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   484      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   485      *Data = ((*Data & ((uint32)~(1uL << BitPn))) | ((uint32)((uint32)tmp_u8 << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   486  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   487  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   488  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   489  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   490   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   491   * Bfx_PutBit_u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   492   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   493   * \brief Sets or clears a bit at a given position BitPn in the 8-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   494   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   495   * A priori, range [0,7] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   496   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   497   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   498   * \param  uint8*   Data    pointer to a 8-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   499   * \param  uint8    BitPn   position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   500   * \param  boolean  Value   defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   501   * \return void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   502   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   503   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   504  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   505  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   506      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   508      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   509      *Data = ((*Data & ((uint8)~(1uL <<BitPn))) | ((uint8)(tmp_u8 << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   510  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   511  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   512  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   513  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   514   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   515   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   516   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   517   * \brief Sets or clears a bit at a given position Pos_u32 in the 16-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   518   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   519   * A priori, range [0,15] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   520   * Note, neither the given position BitPn nor the given value Value not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   521   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   522   * \param   uint16*   Data        pointer to a 16-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   523   * \param   uint8     BitStartPn  position of the bit, from where the pattern has to be inserted
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   524   * \param   uint8     BitLn       bit length of the pattern to be inserted
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   525   * \param   uint16    Pattern     pattern of the bit to be inserted
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   526   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   527   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   528   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   529  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   530  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   531      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   532      *Data = (((uint16) (~(uint16) ((BFX_MAXUINT16_U >> (16uL - BitLn)) << BitStartPn))) & *Data) | (uint16)(((BFX_MAXUINT16_U
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   533              >> (16uL - BitLn)) & Pattern) << BitStartPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   534  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   535  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   536  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   537  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   538   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   539   * Bfx_PutBits_u32u8u8u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   540   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   541   * \brief Sets or clears a bit at a given position Pos_u32 in the 32-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   542   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   543   * A priori, range [0,31] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   544   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   545   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   546   * \param   uint32*  Data         pointer to a 32-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   547   * \param   uint8    BitStartPn   position of the bit, from where the pattern has to be inserted
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   548   * \param   uint8    BitLn        bit length of the pattern to be inserted
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   549   * \param   uint32   Pattern      pattern of the bit to be inserted
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   550   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   551   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   552   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   553  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   554  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   555      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   556      *Data = (((uint32) (~(uint32)((BFX_MAXUINT32_U >> (32uL - BitLn)) << BitStartPn))) & *Data) | (uint32)(((BFX_MAXUINT32_U >> (32uL
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   557              - BitLn)) & Pattern) << BitStartPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   558  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   559  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   560  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   561  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   562   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   563   * Bfx_PutBits_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   564   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   565   * \brief Sets or clears a bit at a given position BitPn in the 8-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   566   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   567   * A priori, range [0,7] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   568   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   569   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   570   * \param  uint8*   Data          pointer to a 8-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   571   * \param  uint8    BitStartPn    position of the bit, from where the pattern has to be inserted
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   572   * \param  uint8    BitLn         bit length of the pattern to be inserted
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   573   * \param  uint8    Pattern       pattern of the bit to be inserted
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   574   * \return void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   575   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   576   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   577  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   578  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   579      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   580      *Data = (((uint8) (~(uint8)((BFX_MAXUINT8_U >> (8uL - BitLn)) << BitStartPn))) & *Data) | (uint8)(((BFX_MAXUINT8_U >> (8uL
	mov	d1,#255
.L112:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   581              - BitLn)) & Pattern) << BitStartPn);
	rsub	d0,d0,#8
.L113:
	rsub	d0,#0
	sh	d1,d1,d0
.L114:
	sh	d0,d1,#0
.L115:
	xor	d0,d0,#255
.L116:
	ld.bu	d2,[a2]
.L117:
	and	d0,d2
.L118:
	and	d1,d15
.L119:
	sh	d1,#0
.L120:
	or	d0,d1
.L121:
	st.b	[a2],d0
.L63:

; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    85  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    86      /* Reset the timers */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    87      /* This check is equivalent to
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    88       * if(((LatestTransMode_u8 == COM_TXMODE_PERIODIC) ||
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    89       *    (LatestTransMode_u8 == COM_TXMODE_MIXED)) )
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    90       */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    91      if( 0u != ( LatestTransMode_u8 & COM_TXMODE_MIXED ) )
	jz.t	d15:0,.L10
.L122:

; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    92      {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    93          /* The function may be interrupted by Com_MainFunctionTx().This will lead to inconsistant data in
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    94           * Com_MainFunctionTx(), So Interrupt is locked here. */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    95          TxIpduRamPtr->Com_Tick_Tx = COM_GET_TXIPDU_TIMEPERIOD(TxIpduId, (TxIpduRamPtr->CurrentTxModePtr));
	ld.a	a2,[a15]
	ld.hu	d15,[a2]0
.L82:
	st.h	[a15]6,d15
.L123:

; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    96  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    97          /*Below Initialize is done if Com_TxChangeMode() is called by Ipdu_GroupStart()*/
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    98          TxIpduRamPtr ->Com_n_Tick_Tx = 0;
	mov	d15,#0
.L124:
	st.h	[a15]8,d15
.L125:

; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	    99          /*This means there is no n Transmission, This will be updated in Com_SendSignal()and Com_SendSignalGroup()*/
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   100          TxIpduRamPtr ->Com_n = 0;
	mov	d15,#0
.L126:
	st.b	[a15]14,d15
.L10:

; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   101          /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   102  #ifdef COM_MIXEDPHASESHIFT
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   103          Com_SetRamValue(TXIPDU,_MIXEDPHASESHIFT,TxIpduRamPtr->Com_TransMode,
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   104                                                  TxIpduRamPtr->CurrentTxModePtr->MixedPhaseShift);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   105  #endif /* #ifdef COM_MIXEDPHASESHIFT */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   106          /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   107      }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   108  }
	ret
.L22:
	
__Com_TxChangeMode_function_end:
	.size	Com_TxChangeMode,__Com_TxChangeMode_function_end-Com_TxChangeMode
.L21:
	; End of function
	
	.extern	Com_TxIpduRam_s
	.extern	Com_NONE_TransModeInfo
	.extern	Com_Prv_xTxIpduCfg_acst
	.calls	'Com_TxChangeMode','',0
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L14:
	.word	13869
	.half	3
	.word	.L15
	.byte	4
.L13:
	.byte	1
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_TxChangeMode.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L16
.L23:
	.byte	2
	.byte	'unsigned char',0,1,8,2
	.byte	'unsigned short int',0,2,7,3
	.byte	'Bfx_Prv_GetBit_u16u8_u8_Inl',0,3,1,207,2,22
	.word	142
	.byte	1,1,4
	.byte	'Data',0,1,207,2,57
	.word	159
	.byte	4
	.byte	'BitPn',0,1,207,2,69
	.word	142
	.byte	5,0,2
	.byte	'unsigned int',0,4,7,3
	.byte	'Bfx_Prv_GetBit_u32u8_u8_Inl',0,3,1,227,2,22
	.word	142
	.byte	1,1,4
	.byte	'Data',0,1,227,2,57
	.word	252
	.byte	4
	.byte	'BitPn',0,1,227,2,69
	.word	142
	.byte	5,0,3
	.byte	'Bfx_Prv_GetBit_u8u8_u8_Inl',0,3,1,247,2,22
	.word	142
	.byte	1,1,4
	.byte	'Data',0,1,247,2,55
	.word	142
	.byte	4
	.byte	'BitPn',0,1,247,2,67
	.word	142
	.byte	5,0
.L42:
	.byte	3
	.byte	'Bfx_Prv_GetBits_u16u8u8_u16_Inl',0,3,1,139,3,21
	.word	159
	.byte	1,1
.L44:
	.byte	4
	.byte	'Data',0,1,139,3,60
	.word	159
.L46:
	.byte	4
	.byte	'BitStartPn',0,1,139,3,72
	.word	142
.L48:
	.byte	4
	.byte	'BitLn',0,1,139,3,90
	.word	142
.L50:
	.byte	5,0,3
	.byte	'Bfx_Prv_GetBits_u8u8u8_u8_Inl',0,3,1,179,3,20
	.word	142
	.byte	1,1,4
	.byte	'Data',0,1,179,3,56
	.word	142
	.byte	4
	.byte	'BitStartPn',0,1,179,3,68
	.word	142
	.byte	4
	.byte	'BitLn',0,1,179,3,86
	.word	142
	.byte	5,0,6
	.word	159
	.byte	7
	.byte	'Bfx_Prv_PutBit_u16u8u8_Inl',0,3,1,200,3,19,1,1,4
	.byte	'Data',0,1,200,3,54
	.word	597
	.byte	4
	.byte	'BitPn',0,1,200,3,66
	.word	142
	.byte	4
	.byte	'Value',0,1,200,3,81
	.word	142
	.byte	5,0,6
	.word	252
	.byte	7
	.byte	'Bfx_Prv_PutBit_u32u8u8_Inl',0,3,1,224,3,19,1,1,4
	.byte	'Data',0,1,224,3,54
	.word	683
	.byte	4
	.byte	'BitPn',0,1,224,3,66
	.word	142
	.byte	4
	.byte	'Value',0,1,224,3,81
	.word	142
	.byte	5,0,6
	.word	142
.L31:
	.byte	7
	.byte	'Bfx_Prv_PutBit_u8u8u8_Inl',0,3,1,248,3,19,1,1
.L34:
	.byte	4
	.byte	'Data',0,1,248,3,52
	.word	769
.L36:
	.byte	4
	.byte	'BitPn',0,1,248,3,64
	.word	142
.L38:
	.byte	4
	.byte	'Value',0,1,248,3,79
	.word	142
.L40:
	.byte	5,0
.L61:
	.byte	7
	.byte	'Bfx_Prv_PutBits_u8u8u8u8_Inl',0,3,1,193,4,19,1,1
.L64:
	.byte	4
	.byte	'Data',0,1,193,4,55
	.word	769
.L66:
	.byte	4
	.byte	'BitStartPn',0,1,193,4,67
	.word	142
.L68:
	.byte	4
	.byte	'BitLn',0,1,193,4,85
	.word	142
.L70:
	.byte	4
	.byte	'Pattern',0,1,193,4,98
	.word	142
.L72:
	.byte	5,0,3
	.byte	'Bfx_Prv_TstParityEven_u32_u8_Inl',0,3,1,143,10,22
	.word	142
	.byte	1,1,4
	.byte	'Data',0,1,143,10,62
	.word	252
	.byte	5,0,8,3,76,9,8,9
	.byte	'TimePeriodFact',0
	.word	159
	.byte	2,2,35,0,9
	.byte	'TimeOffsetFact',0
	.word	159
	.byte	2,2,35,2,9
	.byte	'RepetitionPeriodFact',0
	.word	159
	.byte	2,2,35,4,9
	.byte	'NumOfRepetitions',0
	.word	142
	.byte	1,2,35,6,9
	.byte	'Mode',0
	.word	142
	.byte	1,2,35,7,0,10
	.word	1020
	.byte	6
	.word	1144
	.byte	11
	.byte	'Com_TMConstPtrType',0,3,103,65
	.word	1149
	.byte	8,3,135,9,9,16,9
	.byte	'CurrentTxModePtr',0
	.word	1154
	.byte	4,2,35,0,9
	.byte	'Com_MinDelayTick',0
	.word	159
	.byte	2,2,35,4,9
	.byte	'Com_Tick_Tx',0
	.word	159
	.byte	2,2,35,6,9
	.byte	'Com_n_Tick_Tx',0
	.word	159
	.byte	2,2,35,8,9
	.byte	'Com_TickTxTimeout',0
	.word	159
	.byte	2,2,35,10,9
	.byte	'Com_TxFlags',0
	.word	159
	.byte	2,2,35,12,9
	.byte	'Com_n',0
	.word	142
	.byte	1,2,35,14,9
	.byte	'Com_TransMode',0
	.word	142
	.byte	1,2,35,15,0,6
	.word	1181
.L27:
	.byte	11
	.byte	'Com_TxIpduRamPtrType',0,3,198,9,62
	.word	1370
	.byte	8,3,211,5,9,24,9
	.byte	'BuffPtr',0
	.word	769
	.byte	4,2,35,0,9
	.byte	'Com_TMConstPtr',0
	.word	1149
	.byte	4,2,35,4,9
	.byte	'Size',0
	.word	159
	.byte	2,2,35,8,9
	.byte	'Timeout_Fact',0
	.word	159
	.byte	2,2,35,10,9
	.byte	'Min_Delay_Time_Fact',0
	.word	159
	.byte	2,2,35,12,9
	.byte	'No_Of_Sig_Ref',0
	.word	159
	.byte	2,2,35,14,9
	.byte	'PdurId',0
	.word	159
	.byte	2,2,35,16,9
	.byte	'TxSigId_Index',0
	.word	142
	.byte	1,2,35,18,9
	.byte	'txIPduFields',0
	.word	159
	.byte	2,2,35,20,9
	.byte	'MainFunctionRef',0
	.word	142
	.byte	1,2,35,22,9
	.byte	'PaddingByte',0
	.word	142
	.byte	1,2,35,23,0,10
	.word	1405
	.byte	6
	.word	1648
.L25:
	.byte	11
	.byte	'Com_TxIpduConstPtrType',0,3,171,6,72
	.word	1653
.L51:
	.byte	7
	.byte	'Com_SetCurrentTxModePtr',0,3,2,206,1,22,1,1
.L52:
	.byte	4
	.byte	'TxIpduRamPtr',0,2,207,1,69
	.word	1375
.L54:
	.byte	4
	.byte	'TxIPduConstPtr',0,2,208,1,69
	.word	1658
.L56:
	.byte	4
	.byte	'TMSStatus',0,2,209,1,69
	.word	159
.L58:
	.byte	4
	.byte	'ModeRequested',0,2,210,1,69
	.word	142
.L60:
	.byte	5,0,6
	.word	1181
	.byte	10
	.word	1020
	.byte	6
	.word	1817
	.byte	10
	.word	1405
	.byte	6
	.word	1827
	.byte	12
	.word	181
	.byte	13
	.word	221
	.byte	13
	.word	235
	.byte	5,0,12
	.word	268
	.byte	13
	.word	308
	.byte	13
	.word	322
	.byte	5,0,12
	.word	339
	.byte	13
	.word	378
	.byte	13
	.word	392
	.byte	5,0,12
	.word	409
	.byte	13
	.word	453
	.byte	13
	.word	467
	.byte	13
	.word	487
	.byte	5,0,12
	.word	504
	.byte	13
	.word	546
	.byte	13
	.word	560
	.byte	13
	.word	580
	.byte	5,0,12
	.word	602
	.byte	13
	.word	637
	.byte	13
	.word	651
	.byte	13
	.word	666
	.byte	5,0,12
	.word	688
	.byte	13
	.word	723
	.byte	13
	.word	737
	.byte	13
	.word	752
	.byte	5,0,12
	.word	774
	.byte	13
	.word	808
	.byte	13
	.word	822
	.byte	13
	.word	837
	.byte	5,0,12
	.word	854
	.byte	13
	.word	891
	.byte	13
	.word	905
	.byte	13
	.word	925
	.byte	13
	.word	940
	.byte	5,0,12
	.word	959
	.byte	13
	.word	1004
	.byte	5,0,12
	.word	1690
	.byte	13
	.word	1722
	.byte	13
	.word	1744
	.byte	13
	.word	1768
	.byte	13
	.word	1787
	.byte	5,0,14,1,6
	.word	2064
	.byte	11
	.byte	'__codeptr',0,4,1,1
	.word	2066
	.byte	2
	.byte	'char',0,1,6,11
	.byte	'sint8',0,5,76,25
	.word	2089
	.byte	11
	.byte	'uint8',0,5,81,25
	.word	142
	.byte	11
	.byte	'uint16',0,5,91,25
	.word	159
	.byte	11
	.byte	'uint32',0,5,106,24
	.word	252
	.byte	2
	.byte	'unsigned long long int',0,8,7,11
	.byte	'uint64',0,5,111,30
	.word	2155
	.byte	11
	.byte	'boolean',0,5,127,25
	.word	142
	.byte	11
	.byte	'StatusType',0,6,191,1,27
	.word	142
	.byte	11
	.byte	'Std_ReturnType',0,6,199,1,15
	.word	142
	.byte	8,6,206,1,9,8,9
	.byte	'vendorID',0
	.word	159
	.byte	2,2,35,0,9
	.byte	'moduleID',0
	.word	159
	.byte	2,2,35,2,9
	.byte	'sw_major_version',0
	.word	142
	.byte	1,2,35,4,9
	.byte	'sw_minor_version',0
	.word	142
	.byte	1,2,35,5,9
	.byte	'sw_patch_version',0
	.word	142
	.byte	1,2,35,6,0,11
	.byte	'Std_VersionInfoType',0,6,213,1,3
	.word	2256
	.byte	11
	.byte	'PduIdType',0,7,22,19
	.word	159
	.byte	11
	.byte	'PduLengthType',0,7,26,19
	.word	159
	.byte	15,8,113,9,4,16
	.byte	'TP_DATACONF',0,0,16
	.byte	'TP_DATARETRY',0,1,16
	.byte	'TP_CONFPENDING',0,2,0,11
	.byte	'TpDataStateType',0,8,118,3
	.word	2446
	.byte	11
	.byte	'Com_SignalIdType',0,9,100,16
	.word	159
	.byte	11
	.byte	'Com_SignalGroupIdType',0,9,102,16
	.word	159
	.byte	11
	.byte	'Com_IpduIdType',0,9,104,15
	.word	142
	.byte	11
	.byte	'Com_GrpSignalIdType',0,9,107,18
	.word	142
	.byte	11
	.byte	'Com_TxIntSignalIdType',0,10,138,3,18
	.word	142
	.byte	11
	.byte	'Com_RxIntSignalIdType',0,10,139,3,18
	.word	142
	.byte	11
	.byte	'Com_BitsizeType',0,10,155,3,17
	.word	142
	.byte	11
	.byte	'Com_BitpositionType',0,10,156,3,15
	.word	142
	.byte	11
	.byte	'Com_RxGwQueueIndexType',0,10,161,3,15
	.word	142
	.byte	11
	.byte	'Com_SigBuffIndexType',0,10,164,3,15
	.word	142
	.byte	11
	.byte	'Com_SigMaxType',0,10,198,3,16
	.word	252
	.byte	11
	.byte	'Com_MainFuncType',0,10,231,3,16
	.word	142
	.byte	11
	.byte	'Com_NumOfIpdusType',0,10,233,3,15
	.word	142
	.byte	11
	.byte	'Com_TimeBaseType',0,10,235,3,15
	.word	142
	.byte	11
	.byte	'Can_IdType',0,11,32,16
	.word	252
	.byte	11
	.byte	'Can_HwHandleType',0,11,43,16
	.word	159
	.byte	8,12,93,9,8,9
	.byte	'Class',0
	.word	142
	.byte	1,2,35,0,9
	.byte	'TIN',0
	.word	142
	.byte	1,2,35,1,9
	.byte	'ReturnAddress',0
	.word	252
	.byte	4,2,35,4,0,11
	.byte	'OsTrapInfoType',0,12,97,3
	.word	2954
	.byte	17,68
	.word	252
	.byte	18,16,0,8,12,154,1,9,68,9
	.byte	'store',0
	.word	3034
	.byte	68,2,35,0,0,17,68
	.word	3043
	.byte	18,0,0,11
	.byte	'Os_JumpBufType',0,12,156,1,3
	.word	3065
	.byte	11
	.byte	'Os_StackTraceType',0,12,174,1,18
	.word	252
	.byte	8,12,175,1,9,8,9
	.byte	'sp',0
	.word	252
	.byte	4,2,35,0,9
	.byte	'ctx',0
	.word	252
	.byte	4,2,35,4,0,11
	.byte	'Os_StackValueType',0,12,175,1,63
	.word	3125
	.byte	11
	.byte	'Os_StackSizeType',0,12,176,1,27
	.word	3125
	.byte	19,1,1,6
	.word	3210
	.byte	11
	.byte	'Os_VoidVoidFunctionType',0,12,179,1,16
	.word	3213
	.byte	11
	.byte	'ApplicationType',0,12,193,1,23
	.word	142
	.byte	20
	.byte	'Os_ApplicationConfigurationType_s',0,12,198,1,16,2,9
	.byte	'app_id',0
	.word	142
	.byte	1,2,35,0,9
	.byte	'access',0
	.word	142
	.byte	1,2,35,1,0,11
	.byte	'Os_ApplicationConfigurationType',0,12,201,1,3
	.word	3276
	.byte	11
	.byte	'Os_CoreStateType',0,12,203,1,16
	.word	252
	.byte	11
	.byte	'AreaIdType',0,12,204,1,16
	.word	159
	.byte	11
	.byte	'Os_PeripheralAddressType',0,12,212,1,22
	.word	252
	.byte	11
	.byte	'TickType',0,12,221,1,22
	.word	252
	.byte	11
	.byte	'Os_StopwatchTickType',0,12,225,1,22
	.word	252
	.byte	11
	.byte	'Os_Lockable',0,12,234,1,18
	.word	683
	.byte	11
	.byte	'CoreIdType',0,12,236,1,16
	.word	159
	.byte	11
	.byte	'SpinlockIdType',0,12,237,1,16
	.word	159
	.byte	15,12,239,1,9,4,16
	.byte	'TRYTOGETSPINLOCK_SUCCESS',0,0,16
	.byte	'TRYTOGETSPINLOCK_NOSUCCESS',0,1,0,11
	.byte	'TryToGetSpinlockType',0,12,239,1,74
	.word	3583
	.byte	15,12,174,2,9,4,16
	.byte	'APPLICATION_ACCESSIBLE',0,0,16
	.byte	'APPLICATION_RESTARTING',0,1,16
	.byte	'APPLICATION_TERMINATED',0,2,0,11
	.byte	'ApplicationStateType',0,12,174,2,92
	.word	3676
	.byte	21
	.byte	'void',0,6
	.word	3788
	.byte	22,1,1,23
	.word	142
	.byte	23
	.word	3794
	.byte	0,6
	.word	3799
	.byte	11
	.byte	'Os_FunctionEntryType',0,12,183,2,16
	.word	3813
	.byte	20
	.byte	'Os_MeterInfoType_s',0,12,193,2,16,48,9
	.byte	'elapsed',0
	.word	252
	.byte	4,2,35,0,9
	.byte	'previous',0
	.word	252
	.byte	4,2,35,4,9
	.byte	'max',0
	.word	252
	.byte	4,2,35,8,9
	.byte	'cumulative',0
	.word	252
	.byte	4,2,35,12,9
	.byte	'stackbase',0
	.word	3125
	.byte	8,2,35,16,9
	.byte	'stackusage',0
	.word	3125
	.byte	8,2,35,24,9
	.byte	'stackmax',0
	.word	3125
	.byte	8,2,35,32,9
	.byte	'stackbudget',0
	.word	3125
	.byte	8,2,35,40,0,11
	.byte	'Os_MeterInfoType',0,12,202,2,3
	.word	3848
	.byte	6
	.word	3848
	.byte	11
	.byte	'Os_MeterInfoRefType',0,12,203,2,50
	.word	4046
	.byte	11
	.byte	'EventMaskType',0,12,206,2,15
	.word	142
	.byte	11
	.byte	'Os_imaskType',0,12,211,2,16
	.word	252
	.byte	20
	.byte	'Os_ISRDynType_s',0,12,213,2,16,48,9
	.byte	'meter',0
	.word	3848
	.byte	48,2,35,0,0,11
	.byte	'Os_ISRDynType',0,12,215,2,3
	.word	4125
	.byte	6
	.word	4125
	.byte	10
	.word	4186
	.byte	20
	.byte	'Os_ISRType_s',0,12,216,2,16,24,9
	.byte	'entry_function',0
	.word	3218
	.byte	4,2,35,0,9
	.byte	'dynamic',0
	.word	4191
	.byte	4,2,35,4,9
	.byte	'imask',0
	.word	252
	.byte	4,2,35,8,9
	.byte	'stackbudget',0
	.word	3125
	.byte	8,2,35,12,9
	.byte	'access',0
	.word	142
	.byte	1,2,35,20,9
	.byte	'application',0
	.word	142
	.byte	1,2,35,21,0,11
	.byte	'Os_ISRType',0,12,223,2,3
	.word	4196
	.byte	6
	.word	3210
	.byte	10
	.word	4196
	.byte	6
	.word	4355
	.byte	11
	.byte	'ISRType',0,12,224,2,46
	.word	4360
	.byte	11
	.byte	'Os_bitmask',0,12,239,2,22
	.word	252
	.byte	11
	.byte	'Os_pset0Type',0,12,240,2,20
	.word	252
	.byte	11
	.byte	'Os_pset1Type',0,12,241,2,20
	.word	252
	.byte	11
	.byte	'Os_pset2Type',0,12,242,2,20
	.word	252
	.byte	24,12,243,2,9,4,9
	.byte	'p0',0
	.word	252
	.byte	4,2,35,0,9
	.byte	'p1',0
	.word	252
	.byte	4,2,35,0,9
	.byte	'p2',0
	.word	252
	.byte	4,2,35,0,0,11
	.byte	'Os_psetType',0,12,247,2,3
	.word	4468
	.byte	24,12,249,2,9,4,9
	.byte	't0',0
	.word	252
	.byte	4,2,35,0,9
	.byte	't1',0
	.word	252
	.byte	4,2,35,0,9
	.byte	't2',0
	.word	252
	.byte	4,2,35,0,0,11
	.byte	'Os_tpmaskType',0,12,253,2,3
	.word	4532
	.byte	11
	.byte	'Os_ActivationCountType',0,12,254,2,23
	.word	142
	.byte	20
	.byte	'Os_TaskDynType_s',0,12,128,3,16,120,9
	.byte	'terminate_jump_buf',0
	.word	3074
	.byte	68,2,35,0,9
	.byte	'meter',0
	.word	3848
	.byte	48,2,35,68,9
	.byte	'activation_count',0
	.word	142
	.byte	1,2,35,116,0,11
	.byte	'Os_TaskDynType',0,12,132,3,3
	.word	4630
	.byte	17,68
	.word	3043
	.byte	18,0,0,6
	.word	4630
	.byte	10
	.word	4756
	.byte	20
	.byte	'Os_TaskType_s',0,12,134,3,16,40,9
	.byte	'dynamic',0
	.word	4761
	.byte	4,2,35,0,9
	.byte	'entry_function',0
	.word	3218
	.byte	4,2,35,4,9
	.byte	'pset',0
	.word	4468
	.byte	4,2,35,8,9
	.byte	'base_tpmask',0
	.word	4532
	.byte	4,2,35,12,9
	.byte	'tpmask',0
	.word	4532
	.byte	4,2,35,16,9
	.byte	'core_id',0
	.word	159
	.byte	2,2,35,20,9
	.byte	'index',0
	.word	252
	.byte	4,2,35,24,9
	.byte	'stackbudget',0
	.word	3125
	.byte	8,2,35,28,9
	.byte	'activation_count',0
	.word	142
	.byte	1,2,35,36,9
	.byte	'access',0
	.word	142
	.byte	1,2,35,37,9
	.byte	'application',0
	.word	142
	.byte	1,2,35,38,0,11
	.byte	'Os_TaskType',0,12,146,3,3
	.word	4766
	.byte	10
	.word	4766
	.byte	6
	.word	5016
	.byte	11
	.byte	'TaskType',0,12,147,3,47
	.word	5021
	.byte	25
	.byte	'Os_TaskStateType',0,12,155,3,6,4,16
	.byte	'SUSPENDED',0,0,16
	.byte	'READY',0,1,16
	.byte	'WAITING',0,2,16
	.byte	'RUNNING',0,3,0,11
	.byte	'TaskStateType',0,12,156,3,31
	.word	5044
	.byte	24,12,167,3,3,4,9
	.byte	'tpmask',0
	.word	4532
	.byte	4,2,35,0,0,20
	.byte	'Os_ResourceDynType_s',0,12,166,3,16,4,9
	.byte	'saved_priority',0
	.word	5131
	.byte	4,2,35,0,0,11
	.byte	'Os_ResourceDynType',0,12,170,3,3
	.word	5154
	.byte	6
	.word	5154
	.byte	10
	.word	5234
	.byte	20
	.byte	'Os_ResourceType_s',0,12,171,3,16,12,9
	.byte	'dynamic',0
	.word	5239
	.byte	4,2,35,0,9
	.byte	'tpmask',0
	.word	4532
	.byte	4,2,35,4,9
	.byte	'access',0
	.word	142
	.byte	1,2,35,8,0,11
	.byte	'Os_ResourceType',0,12,175,3,3
	.word	5244
	.byte	8,12,181,3,9,12,9
	.byte	'maxallowedvalue',0
	.word	252
	.byte	4,2,35,0,9
	.byte	'ticksperbase',0
	.word	252
	.byte	4,2,35,4,9
	.byte	'mincycle',0
	.word	252
	.byte	4,2,35,8,0,11
	.byte	'AlarmBaseType',0,12,185,3,3
	.word	5343
	.byte	8,12,206,3,9,8,9
	.byte	'Running',0
	.word	142
	.byte	1,2,35,0,9
	.byte	'Pending',0
	.word	142
	.byte	1,2,35,1,9
	.byte	'Delay',0
	.word	252
	.byte	4,2,35,4,0,11
	.byte	'Os_CounterStatusType',0,12,210,3,3
	.word	5438
	.byte	26
	.word	142
	.byte	1,1,6
	.word	5524
	.byte	11
	.byte	'Os_CounterIncrAdvType',0,12,217,3,22
	.word	5531
	.byte	20
	.byte	's_swd',0,12,222,3,12,4,9
	.byte	'count',0
	.word	252
	.byte	4,2,35,0,0,24,12,221,3,3,4,9
	.byte	'sw',0
	.word	5567
	.byte	4,2,35,0,0,20
	.byte	'Os_CounterDynType_s',0,12,220,3,16,4,9
	.byte	'type_dependent',0
	.word	5595
	.byte	4,2,35,0,0,11
	.byte	'Os_CounterDynType',0,12,226,3,3
	.word	5614
	.byte	6
	.word	5614
	.byte	10
	.word	5692
	.byte	20
	.byte	'Os_CounterType_s',0,12,227,3,16,28,9
	.byte	'dynamic',0
	.word	5697
	.byte	4,2,35,0,9
	.byte	'advincr',0
	.word	5536
	.byte	4,2,35,4,9
	.byte	'base',0
	.word	5343
	.byte	12,2,35,8,9
	.byte	'core',0
	.word	3794
	.byte	4,2,35,20,9
	.byte	'access',0
	.word	142
	.byte	1,2,35,24,9
	.byte	'application',0
	.word	142
	.byte	1,2,35,25,0,11
	.byte	'Os_CounterType',0,12,234,3,3
	.word	5702
	.byte	6
	.word	5524
	.byte	10
	.word	5702
	.byte	6
	.word	5854
	.byte	11
	.byte	'CounterType',0,12,235,3,52
	.word	5859
	.byte	25
	.byte	'Os_ScheduleTableStatusType',0,12,240,3,6,4,16
	.byte	'SCHEDULETABLE_STOPPED',0,0,16
	.byte	'SCHEDULETABLE_NEXT',0,1,16
	.byte	'SCHEDULETABLE_WAITING',0,2,16
	.byte	'SCHEDULETABLE_RUNNING',0,3,16
	.byte	'SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS',0,4,0,11
	.byte	'ScheduleTableStatusType',0,12,241,3,41
	.word	5885
	.byte	10
	.word	.L83-.L14
	.byte	6
	.word	6085
	.byte	11
	.byte	'ScheduleTableType',0,12,128,4,58
	.word	6090
	.byte	20
	.byte	'Os_ScheduleTableDynType_s',0,12,130,4,16,16,9
	.byte	'match',0
	.word	252
	.byte	4,2,35,0,9
	.byte	'next',0
	.word	6095
	.byte	4,2,35,4,9
	.byte	'state',0
	.word	5885
	.byte	4,2,35,8,9
	.byte	'config',0
	.word	159
	.byte	2,2,35,12,0,6
	.word	6122
	.byte	10
	.word	6215
.L83:
	.byte	20
	.byte	'Os_ScheduleTableType_s',0,12,247,3,16,16,9
	.byte	'dynamic',0
	.word	6220
	.byte	4,2,35,0,9
	.byte	'counter',0
	.word	5864
	.byte	4,2,35,4,9
	.byte	'repeat',0
	.word	142
	.byte	1,2,35,8,9
	.byte	'config',0
	.word	159
	.byte	2,2,35,10,9
	.byte	'initial',0
	.word	142
	.byte	1,2,35,12,9
	.byte	'access',0
	.word	142
	.byte	1,2,35,13,9
	.byte	'application',0
	.word	142
	.byte	1,2,35,14,0,11
	.byte	'Os_ScheduleTableType',0,12,255,3,3
	.word	6225
	.byte	10
	.word	6225
	.byte	6
	.word	6405
	.byte	10
	.word	5702
	.byte	6
	.word	6415
	.byte	27
	.word	3518
	.byte	27
	.word	4468
	.byte	27
	.word	4365
	.byte	27
	.word	5026
	.byte	27
	.word	4532
	.byte	27
	.word	142
	.byte	27
	.word	5026
	.byte	20
	.byte	'Os_ControlledCoreType_s',0,12,251,6,16,112,9
	.byte	'TrapInfo',0
	.word	2954
	.byte	8,2,35,0,9
	.byte	'lock_taskaccess',0
	.word	6425
	.byte	4,2,35,8,9
	.byte	'ReadyTasks',0
	.word	6430
	.byte	4,2,35,12,9
	.byte	'RunningISR',0
	.word	6435
	.byte	4,2,35,16,9
	.byte	'RunningTask',0
	.word	6440
	.byte	4,2,35,20,9
	.byte	'RunningTPMask',0
	.word	6445
	.byte	4,2,35,24,9
	.byte	'CurrentMeteredObject',0
	.word	4051
	.byte	4,2,35,28,9
	.byte	'IdleMeter',0
	.word	3848
	.byte	48,2,35,32,9
	.byte	'AppAccess',0
	.word	142
	.byte	1,2,35,80,9
	.byte	'AppOverride',0
	.word	6450
	.byte	1,2,35,81,9
	.byte	'GetStackValueAdjust',0
	.word	3125
	.byte	8,2,35,84,9
	.byte	'InErrorHook',0
	.word	142
	.byte	1,2,35,92,9
	.byte	'ChainTaskRef',0
	.word	6455
	.byte	4,2,35,96,9
	.byte	'GetStackUsageAdjust',0
	.word	3125
	.byte	8,2,35,100,9
	.byte	'InProtectionHook',0
	.word	142
	.byte	1,2,35,108,9
	.byte	'CoreIsActive',0
	.word	142
	.byte	1,2,35,109,9
	.byte	'InShutdownHook',0
	.word	142
	.byte	1,2,35,110,0,11
	.byte	'Os_ControlledCoreType',0,12,141,7,3
	.word	6460
	.byte	6
	.word	252
	.byte	10
	.word	4196
	.byte	6
	.word	6916
	.byte	10
	.word	4766
	.byte	6
	.word	6926
	.byte	6
	.word	3848
	.byte	20
	.byte	'Os_AnyCoreType_s',0,12,151,7,16,96,9
	.byte	'DisableAllImask',0
	.word	252
	.byte	4,2,35,0,9
	.byte	'SuspendAllImask',0
	.word	252
	.byte	4,2,35,4,9
	.byte	'SuspendOSImask',0
	.word	252
	.byte	4,2,35,8,9
	.byte	'DisableAllCount',0
	.word	252
	.byte	4,2,35,12,9
	.byte	'SuspendAllCount',0
	.word	252
	.byte	4,2,35,16,9
	.byte	'SuspendOSCount',0
	.word	252
	.byte	4,2,35,20,9
	.byte	'RestartJumpBuf',0
	.word	3074
	.byte	68,2,35,24,9
	.byte	'Restartable',0
	.word	142
	.byte	1,2,35,92,0,11
	.byte	'Os_AnyCoreType',0,12,160,7,3
	.word	6941
	.byte	11
	.byte	'Can_TxObjPriorityClassType',0,13,219,3,16
	.word	252
	.byte	20
	.byte	'Can_TxHwObjectConfigType',0,13,231,3,16,8,9
	.byte	'MsgObjId',0
	.word	142
	.byte	1,2,35,0,9
	.byte	'HwControllerId',0
	.word	142
	.byte	1,2,35,1,9
	.byte	'TxObjPriorityClass',0
	.word	252
	.byte	4,2,35,4,0,11
	.byte	'Can_TxHwObjectConfigType',0,13,252,3,3
	.word	7218
	.byte	20
	.byte	'Can_RxHwObjectConfigType',0,13,129,4,16,12,9
	.byte	'MaskRef',0
	.word	252
	.byte	4,2,35,0,9
	.byte	'MsgId',0
	.word	252
	.byte	4,2,35,4,9
	.byte	'MsgObjId',0
	.word	142
	.byte	1,2,35,8,9
	.byte	'HwControllerId',0
	.word	142
	.byte	1,2,35,9,0,11
	.byte	'Can_RxHwObjectConfigType',0,13,147,4,3
	.word	7354
	.byte	17,4
	.word	142
	.byte	18,3,0,20
	.byte	'Can_ControllerMOMapConfigType',0,13,181,4,16,4,9
	.byte	'ControllerMOMap',0
	.word	7494
	.byte	4,2,35,0,0,11
	.byte	'Can_ControllerMOMapConfigType',0,13,184,4,3
	.word	7503
	.byte	20
	.byte	'Can_NPCRValueType',0,13,188,4,16,2,9
	.byte	'Can_NPCRValue',0
	.word	159
	.byte	2,2,35,0,0,11
	.byte	'Can_NPCRValueType',0,13,191,4,3
	.word	7604
	.byte	20
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,13,194,4,16,8,9
	.byte	'CanControllerBaudrate',0
	.word	252
	.byte	4,2,35,0,9
	.byte	'CanControllerBaudrateCfg',0
	.word	159
	.byte	2,2,35,4,0,11
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,13,198,4,3
	.word	7679
	.byte	10
	.word	7679
	.byte	6
	.word	7844
	.byte	20
	.byte	'Can_BaudrateConfigPtrType',0,13,201,4,16,4,9
	.byte	'Can_kBaudrateConfigPtr',0
	.word	7849
	.byte	4,2,35,0,0,11
	.byte	'Can_BaudrateConfigPtrType',0,13,204,4,3
	.word	7854
	.byte	20
	.byte	'Can_EventHandlingType',0,13,226,4,16,4,9
	.byte	'CanEventType',0
	.word	7494
	.byte	4,2,35,0,0,11
	.byte	'Can_EventHandlingType',0,13,229,4,3
	.word	7954
	.byte	11
	.byte	'Rte_TransformerErrorCode',0,14,130,1,15
	.word	142
	.byte	11
	.byte	'Rte_TransformerClass',0,14,131,1,15
	.word	142
	.byte	8,14,168,1,9,12,9
	.byte	'in',0
	.word	3794
	.byte	4,2,35,0,9
	.byte	'out',0
	.word	3794
	.byte	4,2,35,4,9
	.byte	'used',0
	.word	159
	.byte	2,2,35,8,9
	.byte	'lost_data',0
	.word	142
	.byte	1,2,35,10,0,11
	.byte	'Rte_QDynType',0,14,173,1,3
	.word	8100
	.byte	15,14,175,1,9,4,16
	.byte	'RTE_DRA',0,0,16
	.byte	'RTE_WOWP',0,1,16
	.byte	'RTE_TASK',0,2,16
	.byte	'RTE_ARE',0,3,16
	.byte	'RTE_EV',0,4,16
	.byte	'RTE_MSI',0,5,0,11
	.byte	'Rte_NotificationType',0,14,182,1,3
	.word	8187
	.byte	6
	.word	8100
	.byte	20
	.byte	'Rte_QCmnType',0,14,184,1,16,24,9
	.byte	'dynamic',0
	.word	8285
	.byte	4,2,35,0,9
	.byte	'copy',0
	.word	142
	.byte	1,2,35,4,9
	.byte	'queue_size',0
	.word	159
	.byte	2,2,35,6,9
	.byte	'element_size',0
	.word	159
	.byte	2,2,35,8,9
	.byte	'buffer_start',0
	.word	3794
	.byte	4,2,35,12,9
	.byte	'buffer_end',0
	.word	3794
	.byte	4,2,35,16,9
	.byte	'notification_type',0
	.word	8187
	.byte	4,2,35,20,0,11
	.byte	'Rte_QCmnType',0,14,192,1,3
	.word	8290
	.byte	11
	.byte	'Rte_AlarmRefType',0,14,224,1,32
	.word	252
	.byte	11
	.byte	'Rte_AlarmIndexType',0,14,226,1,32
	.word	159
	.byte	17,128,8
	.word	142
	.byte	18,255,7,0,11
	.byte	'Impl_NVM_DstPtrType_1024',0,15,50,15
	.word	8528
	.byte	11
	.byte	'CanIf_u32_impl',0,15,69,16
	.word	252
	.byte	11
	.byte	'CanIf_u16_impl',0,15,71,16
	.word	159
	.byte	11
	.byte	'CanIf_u8_impl',0,15,73,15
	.word	142
	.byte	11
	.byte	'CanIf_ControllerModeType_Enum_impl',0,15,88,15
	.word	142
	.byte	11
	.byte	'CanIf_PduModeType_Enum_impl',0,15,90,15
	.word	142
	.byte	8,15,92,9,2,9
	.byte	'DeviceMode',0
	.word	142
	.byte	1,2,35,0,9
	.byte	'ChannelMode',0
	.word	142
	.byte	1,2,35,1,0,11
	.byte	'CanIf_ControllerStateType_struct_impl',0,15,95,3
	.word	8719
	.byte	11
	.byte	'CanIf_NotifStatusType_Enum_impl',0,15,100,15
	.word	142
	.byte	11
	.byte	'CanSM_boolean_Impl',0,15,120,15
	.word	142
	.byte	11
	.byte	'CanSM_u8_Impl',0,15,123,15
	.word	142
	.byte	11
	.byte	'CanSM_BusOffRecoveryStateType_Enum_impl',0,15,128,1,15
	.word	142
	.byte	11
	.byte	'CanSM_NetworkModeStateType_Enum_impl',0,15,132,1,15
	.word	142
	.byte	11
	.byte	'CanSM_u16_Impl',0,15,136,1,16
	.word	159
	.byte	11
	.byte	'CanSM_TimerStateType_Enum_impl',0,15,138,1,15
	.word	142
	.byte	8,15,140,1,9,4,9
	.byte	'cntTick_u16',0
	.word	159
	.byte	2,2,35,0,9
	.byte	'stTimer',0
	.word	142
	.byte	1,2,35,2,0,11
	.byte	'CanSM_TimerConfig_tst_struct_impl',0,15,143,1,3
	.word	9060
	.byte	11
	.byte	'Com_impl_u16',0,15,154,1,16
	.word	159
	.byte	11
	.byte	'Com_impl_u8',0,15,157,1,15
	.word	142
	.byte	11
	.byte	'ComM_uint32_Impl',0,15,173,1,16
	.word	252
	.byte	11
	.byte	'ComM_uint16_Impl',0,15,175,1,16
	.word	159
	.byte	11
	.byte	'ComM_uint8_Impl',0,15,177,1,15
	.word	142
	.byte	11
	.byte	'ComM_bool_Impl',0,15,179,1,15
	.word	142
	.byte	8,15,181,1,9,24,9
	.byte	'ChannelState_e',0
	.word	252
	.byte	4,2,35,0,9
	.byte	'LightTimeoutCtr_u32',0
	.word	252
	.byte	4,2,35,4,9
	.byte	'MinFullComTimeoutCtr_u16',0
	.word	159
	.byte	2,2,35,8,9
	.byte	'ChannelMode_u8',0
	.word	142
	.byte	1,2,35,10,9
	.byte	'BusSmMode_u8',0
	.word	142
	.byte	1,2,35,11,9
	.byte	'UserRequestCtr_u8',0
	.word	142
	.byte	1,2,35,12,9
	.byte	'PassiveRequestState_u8',0
	.word	142
	.byte	1,2,35,13,9
	.byte	'PncRequestCtr_u8',0
	.word	142
	.byte	1,2,35,14,9
	.byte	'InhibitionReqStatus_u8',0
	.word	142
	.byte	1,2,35,15,9
	.byte	'NmNetworkRequestStatus_b',0
	.word	142
	.byte	1,2,35,16,9
	.byte	'DiagnosticRequestState_b',0
	.word	142
	.byte	1,2,35,17,9
	.byte	'CommunicationAllowed_b',0
	.word	142
	.byte	1,2,35,18,9
	.byte	'NmBusSleepIndicationStatus_b',0
	.word	142
	.byte	1,2,35,19,9
	.byte	'NmPrepareBusSleepIndicationStatus_b',0
	.word	142
	.byte	1,2,35,20,9
	.byte	'NmNetworkModeStatus_b',0
	.word	142
	.byte	1,2,35,21,0,11
	.byte	'ComM_ChannelStruct_Impl',0,15,197,1,3
	.word	9292
	.byte	8,15,206,1,9,10,9
	.byte	'WakeUpInhibitionCtr_u16',0
	.word	159
	.byte	2,2,35,0,9
	.byte	'LimitToNoComCtr_u16',0
	.word	159
	.byte	2,2,35,2,9
	.byte	'RequestedUserMode_t',0
	.word	142
	.byte	1,2,35,4,9
	.byte	'IndicatedUserMode_t',0
	.word	142
	.byte	1,2,35,5,9
	.byte	'numChannelsInFullCom_u8',0
	.word	142
	.byte	1,2,35,6,9
	.byte	'numChannelsInSilentCom_u8',0
	.word	142
	.byte	1,2,35,7,9
	.byte	'numChannelsInNoCom_u8',0
	.word	142
	.byte	1,2,35,8,0,11
	.byte	'ComM_UserStruct_Impl',0,15,214,1,3
	.word	9796
	.byte	11
	.byte	'Dcm_IOOperationResponseType',0,15,252,1,15
	.word	142
	.byte	11
	.byte	'Dcm_RequestDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspRequestRoutineResultsOutSignal_0PrimitivType',0
	.byte	15,138,2,15
	.word	142
	.byte	11
	.byte	'Dcm_StartDataIn_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineInSignalPrimitivType',0,15,146,2,15
	.word	142
	.byte	11
	.byte	'Dcm_StartDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineOutSignalPrimitivType',0,15,150,2,15
	.word	142
	.byte	11
	.byte	'Dcm_StopDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStopRoutineOutSignalPrimitivType',0,15,154,2,15
	.word	142
	.byte	11
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockNative_1024_Type',0,15,243,3,34
	.word	8539
	.byte	17,128,8
	.word	142
	.byte	18,255,7,0,11
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockRedundant_1024_Type',0,15,246,3,34
	.word	8539
	.byte	11
	.byte	'Rte_TaskRefType',0,16,184,1,32
	.word	5026
	.byte	11
	.byte	'Rte_EventRefType',0,16,185,1,32
	.word	142
	.byte	11
	.byte	'Rte_EventType',0,16,186,1,32
	.word	252
	.byte	11
	.byte	'Rte_REActCounterType',0,16,252,1,15
	.word	142
	.byte	6
	.word	142
	.byte	11
	.byte	'Rte_REActCounterRefType',0,16,253,1,58
	.word	10718
	.byte	8,16,255,1,9,8,9
	.byte	'task',0
	.word	10614
	.byte	4,2,35,0,9
	.byte	'acnt',0
	.word	10723
	.byte	4,2,35,4,0,11
	.byte	'Rte_REContainerType',0,16,130,2,3
	.word	10756
	.byte	10
	.word	4766
	.byte	6
	.word	10820
	.byte	6
	.word	142
	.byte	10
	.word	10756
	.byte	6
	.word	10835
	.byte	11
	.byte	'Rte_REContainerRefType',0,16,132,2,60
	.word	10840
	.byte	11
	.byte	'Rte_MSICounterType',0,16,149,2,16
	.word	159
	.byte	6
	.word	159
	.byte	11
	.byte	'Rte_MSICounterRefType',0,16,150,2,56
	.word	10905
	.byte	11
	.byte	'Rte_MSIPendingFlagType',0,16,152,2,17
	.word	142
	.byte	6
	.word	142
	.byte	11
	.byte	'Rte_MSIPendingFlagRefType',0,16,153,2,60
	.word	10973
	.byte	8,16,163,2,9,24,9
	.byte	'counter',0
	.word	10910
	.byte	4,2,35,0,9
	.byte	'incCounter',0
	.word	142
	.byte	1,2,35,4,9
	.byte	'pending',0
	.word	10978
	.byte	4,2,35,8,9
	.byte	'osTask',0
	.word	10614
	.byte	4,2,35,12,9
	.byte	'acnt',0
	.word	10723
	.byte	4,2,35,16,9
	.byte	'osEvent',0
	.word	142
	.byte	1,2,35,20,9
	.byte	'MSIInit',0
	.word	159
	.byte	2,2,35,22,0,11
	.byte	'Rte_MSITableEntry',0,16,172,2,3
	.word	11013
	.byte	6
	.word	159
	.byte	6
	.word	142
	.byte	11
	.byte	'Rte_TaskArrayIndex',0,16,179,2,16
	.word	142
	.byte	11
	.byte	'Rte_NrWaitingTasks',0,16,180,2,16
	.word	142
	.byte	8,16,182,2,9,4,9
	.byte	'pending',0
	.word	142
	.byte	1,2,35,0,9
	.byte	'count',0
	.word	142
	.byte	1,2,35,1,9
	.byte	'firstWaitingTask',0
	.word	142
	.byte	1,2,35,2,0,11
	.byte	'Rte_WaitableDatum',0,16,186,2,3
	.word	11231
	.byte	6
	.word	11231
	.byte	8,16,226,2,9,12,9
	.byte	'event_id',0
	.word	252
	.byte	4,2,35,0,9
	.byte	'wd',0
	.word	11323
	.byte	4,2,35,4,9
	.byte	'timeout',0
	.word	252
	.byte	4,2,35,8,0,11
	.byte	'Rte_WOWP_NotificationType',0,16,230,2,3
	.word	11328
	.byte	10
	.word	11328
	.byte	6
	.word	11417
	.byte	11
	.byte	'Rte_WOWP_NotificationRefType',0,16,232,2,66
	.word	11422
	.byte	11
	.byte	'Rte_ARE_NotificationType',0,16,234,2,29
	.word	10756
	.byte	20
	.byte	'Rte_QTaskType',0,16,243,2,16,28,9
	.byte	'cmn',0
	.word	8290
	.byte	24,2,35,0,9
	.byte	'task',0
	.word	10614
	.byte	4,2,35,24,0,11
	.byte	'Rte_QTaskType',0,16,246,2,3
	.word	11499
	.byte	20
	.byte	'Rte_QREType',0,16,250,2,16,28,9
	.byte	'cmn',0
	.word	8290
	.byte	24,2,35,0,9
	.byte	're',0
	.word	10845
	.byte	4,2,35,24,0,11
	.byte	'Rte_QREType',0,16,253,2,3
	.word	11570
	.byte	10
	.word	10756
	.byte	6
	.word	11635
	.byte	20
	.byte	'Rte_QWWPType',0,16,129,3,16,28,9
	.byte	'cmn',0
	.word	8290
	.byte	24,2,35,0,9
	.byte	'wwp',0
	.word	11427
	.byte	4,2,35,24,0,11
	.byte	'Rte_QWWPType',0,16,132,3,3
	.word	11645
	.byte	10
	.word	11328
	.byte	6
	.word	11713
	.byte	20
	.byte	'Rte_QEvType',0,16,136,3,16,36,9
	.byte	'cmn',0
	.word	8290
	.byte	24,2,35,0,9
	.byte	'task',0
	.word	10614
	.byte	4,2,35,24,9
	.byte	'mask',0
	.word	142
	.byte	1,2,35,28,9
	.byte	'acnt',0
	.word	10723
	.byte	4,2,35,32,0,11
	.byte	'Rte_QEvType',0,16,141,3,3
	.word	11723
	.byte	20
	.byte	'Rte_QMSIType',0,16,145,3,16,48,9
	.byte	'cmn',0
	.word	8290
	.byte	24,2,35,0,9
	.byte	'task',0
	.word	10614
	.byte	4,2,35,24,9
	.byte	'mask',0
	.word	142
	.byte	1,2,35,28,9
	.byte	'acnt',0
	.word	10723
	.byte	4,2,35,32,9
	.byte	'msiCounter',0
	.word	10910
	.byte	4,2,35,36,9
	.byte	'msiPending',0
	.word	10978
	.byte	4,2,35,40,9
	.byte	'msiLimit',0
	.word	159
	.byte	2,2,35,44,0,11
	.byte	'Rte_QMSIType',0,16,153,3,3
	.word	11818
	.byte	8,3,52,9,1,28
	.byte	'isEventTrig',0,1
	.word	142
	.byte	1,7,2,35,0,28
	.byte	'isTriggerIpduSendWithMetadata',0,1
	.word	142
	.byte	1,6,2,35,0,28
	.byte	'isGwIpduSend',0,1
	.word	142
	.byte	1,5,2,35,0,28
	.byte	'isModeChangd',0,1
	.word	142
	.byte	1,4,2,35,0,28
	.byte	'sigTransProp',0,1
	.word	142
	.byte	1,3,2,35,0,28
	.byte	'isTimeoutReq',0,1
	.word	142
	.byte	1,2,2,35,0,28
	.byte	'ignoreRepetitions',0,1
	.word	142
	.byte	1,1,2,35,0,0,11
	.byte	'Com_SendIpduInfo',0,3,61,3
	.word	11973
	.byte	11
	.byte	'Com_TransModeInfo',0,3,93,2
	.word	1020
	.byte	8,3,136,1,9,12,9
	.byte	'Init_Val',0
	.word	252
	.byte	4,2,35,0,9
	.byte	'txSignalFields',0
	.word	159
	.byte	2,2,35,4,9
	.byte	'Bit_Pos',0
	.word	142
	.byte	1,2,35,6,9
	.byte	'BitSize',0
	.word	142
	.byte	1,2,35,7,9
	.byte	'IpduRef',0
	.word	142
	.byte	1,2,35,8,9
	.byte	'General',0
	.word	142
	.byte	1,2,35,9,0,11
	.byte	'Com_Prv_xTxSigCfg_tst',0,3,201,1,2
	.word	12219
	.byte	8,3,247,1,9,16,9
	.byte	'Notification_Cbk',0
	.word	3213
	.byte	4,2,35,0,9
	.byte	'Init_Val',0
	.word	252
	.byte	4,2,35,4,9
	.byte	'Bit_Pos',0
	.word	142
	.byte	1,2,35,8,9
	.byte	'SigBuff_Index',0
	.word	142
	.byte	1,2,35,9,9
	.byte	'BitSize',0
	.word	142
	.byte	1,2,35,10,9
	.byte	'IpduRef',0
	.word	142
	.byte	1,2,35,11,9
	.byte	'General',0
	.word	142
	.byte	1,2,35,12,9
	.byte	'rxSignalFields',0
	.word	142
	.byte	1,2,35,13,0,11
	.byte	'Com_Prv_xRxSigCfg_tst',0,3,171,2,2
	.word	12367
	.byte	10
	.word	12367
	.byte	6
	.word	12564
	.byte	11
	.byte	'Com_RxSigConstPtrType',0,3,180,2,68
	.word	12569
	.byte	11
	.byte	'Com_Prv_xTxIpduInfoCfg_tst',0,3,162,6,3
	.word	1405
	.byte	8,3,137,7,9,20,9
	.byte	'BuffPtr',0
	.word	769
	.byte	4,2,35,0,9
	.byte	'TimeOutNotification_Cbk',0
	.word	3213
	.byte	4,2,35,4,9
	.byte	'Size',0
	.word	159
	.byte	2,2,35,8,9
	.byte	'FirstTimeout_Factor',0
	.word	159
	.byte	2,2,35,10,9
	.byte	'Timeout_Fact',0
	.word	159
	.byte	2,2,35,12,9
	.byte	'No_Of_Sig_Ref',0
	.word	159
	.byte	2,2,35,14,9
	.byte	'RxSigId_Index',0
	.word	142
	.byte	1,2,35,16,9
	.byte	'MainFunctionRef',0
	.word	142
	.byte	1,2,35,17,9
	.byte	'rxIPduFields',0
	.word	142
	.byte	1,2,35,18,0,11
	.byte	'Com_Prv_xRxIpduInfoCfg_tst',0,3,197,7,3
	.word	12641
	.byte	8,3,219,7,9,4,9
	.byte	'FirstIpdu_Index',0
	.word	159
	.byte	2,2,35,0,9
	.byte	'NoOfRxPdus',0
	.word	159
	.byte	2,2,35,2,0,11
	.byte	'Com_Prv_xIpduGrpInfoCfg_tst',0,3,224,7,3
	.word	12892
	.byte	8,3,244,7,9,1,9
	.byte	'txSigRAMFields',0
	.word	142
	.byte	1,2,35,0,0,11
	.byte	'Com_TxSignalFlagType',0,3,248,7,2
	.word	12981
	.byte	8,3,167,8,9,1,9
	.byte	'rxSigRAMFields',0
	.word	142
	.byte	1,2,35,0,0,11
	.byte	'Com_RxSignalFlagType',0,3,171,8,2
	.word	13042
	.byte	11
	.byte	'Com_TxIpduRamData',0,3,189,9,3
	.word	1181
	.byte	8,3,218,9,9,6,9
	.byte	'RxIPduLength',0
	.word	159
	.byte	2,2,35,0,9
	.byte	'RxTicks_u16',0
	.word	159
	.byte	2,2,35,2,9
	.byte	'RxFlags',0
	.word	142
	.byte	1,2,35,4,0,11
	.byte	'Com_RxIpduRamData',0,3,245,9,2
	.word	13130
	.byte	6
	.word	159
	.byte	8,3,128,10,9,8,9
	.byte	'RxGwQueuePtr',0
	.word	13224
	.byte	4,2,35,0,9
	.byte	'Com_RxGwQueueWrite_ux',0
	.word	142
	.byte	1,2,35,4,9
	.byte	'Com_RxGwQueueRead_ux',0
	.word	142
	.byte	1,2,35,5,0,11
	.byte	'Com_RxGwQueueRAMType',0,3,133,10,2
	.word	13229
	.byte	8,3,138,10,9,4,9
	.byte	'indexGwMapSigDestIdArray',0
	.word	159
	.byte	2,2,35,0,9
	.byte	'destCount',0
	.word	142
	.byte	1,2,35,2,0,11
	.byte	'Com_Prv_xGwMapSigCfg_tst',0,3,142,10,2
	.word	13349
	.byte	8,3,147,10,9,2,9
	.byte	'GwMap_DestId',0
	.word	159
	.byte	2,2,35,0,0,11
	.byte	'Com_Prv_xGwMapSigIdCfg_tst',0,3,150,10,2
	.word	13443
	.byte	8,3,183,10,9,4,9
	.byte	'StartIPduId',0
	.word	142
	.byte	1,2,35,0,9
	.byte	'NumOfIpdus',0
	.word	142
	.byte	1,2,35,1,9
	.byte	'TimeBaseInMs',0
	.word	142
	.byte	1,2,35,2,0,11
	.byte	'Com_MainFunctionCfgType',0,3,188,10,3
	.word	13508
	.byte	8,3,194,10,9,12,9
	.byte	'Com_SigType_pu8',0
	.word	769
	.byte	4,2,35,0,9
	.byte	'Com_SigType_pu16',0
	.word	597
	.byte	4,2,35,4,9
	.byte	'Com_SigType_pu32',0
	.word	683
	.byte	4,2,35,8,0,11
	.byte	'Com_Prv_xRxRamBuf_tst',0,3,253,10,3
	.word	13611
	.byte	11
	.byte	'rba_BswSrv_uint64',0,17,66,28
	.word	2155
	.byte	29
	.word	1181
	.byte	30,0,31
	.byte	'Com_TxIpduRam_s',0,18,211,24,42
	.word	13752
	.byte	1,1,10
	.word	1020
	.byte	31
	.byte	'Com_NONE_TransModeInfo',0,18,209,25,44
	.word	13786
	.byte	1,1,29
	.word	1405
	.byte	30,0,10
	.word	13825
	.byte	31
	.byte	'Com_Prv_xTxIpduCfg_acst',0,18,137,26,57
	.word	13832
	.byte	1,1,0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L15:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,36,0,3,8,11,15,62,15,0,0,3,46,1,3,8,32,13,58,15,59,15
	.byte	57,15,73,19,54,15,39,12,0,0,4,5,0,3,8,58,15,59,15,57,15,73,19,0,0,5,11,0,0,0,6,15,0,73,19,0,0,7,46,1,3
	.byte	8,32,13,58,15,59,15,57,15,54,15,39,12,0,0,8,19,1,58,15,59,15,57,15,11,15,0,0,9,13,0,3,8,73,19,11,15,56
	.byte	9,0,0,10,38,0,73,19,0,0,11,22,0,3,8,58,15,59,15,57,15,73,19,0,0,12,46,1,49,19,0,0,13,5,0,49,19,0,0,14
	.byte	21,0,54,15,0,0,15,4,1,58,15,59,15,57,15,11,15,0,0,16,40,0,3,8,28,13,0,0,17,1,1,11,15,73,19,0,0,18,33,0
	.byte	47,15,0,0,19,21,0,54,15,39,12,0,0,20,19,1,3,8,58,15,59,15,57,15,11,15,0,0,21,59,0,3,8,0,0,22,21,1,54,15
	.byte	39,12,0,0,23,5,0,73,19,0,0,24,23,1,58,15,59,15,57,15,11,15,0,0,25,4,1,3,8,58,15,59,15,57,15,11,15,0,0
	.byte	26,21,0,73,19,54,15,39,12,0,0,27,53,0,73,19,0,0,28,13,0,3,8,11,15,73,19,13,15,12,15,56,9,0,0,29,1,1,73
	.byte	19,0,0,30,33,0,0,0,31,52,0,3,8,58,15,59,15,57,15,73,19,63,12,60,12,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L16:
	.word	.L85-.L84
.L84:
	.half	3
	.word	.L87-.L86
.L86:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Bfx\\api\\Bfx_Bit_Inl.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv_Inl.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv_Types.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_TxChangeMode.c',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Platform\\Platform_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Std_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Com\\Com_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Com\\Com_Cfg_Internal.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Can_GeneralTypes.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\RTOS_T\\Gen\\inc\\Os.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Can_17_MCanP\\inc\\Can_17_MCanP.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Type.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Intl.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\rba_BswSrv.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv.h',0,0,0,0,0
.L87:
.L85:
	.sdecl	'.debug_info',debug,cluster('Com_TxChangeMode')
	.sect	'.debug_info'
.L17:
	.word	571
	.half	3
	.word	.L18
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_TxChangeMode.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L20,.L19
	.byte	2
	.word	.L13
	.byte	3
	.byte	'Com_TxChangeMode',0,1,34,21,1,1,1
	.word	.L12,.L22,.L11
	.byte	4
	.byte	'TxIpduId',0,1,34,69
	.word	.L23,.L24
	.byte	5
	.word	.L12,.L22
	.byte	6
	.byte	'TxIPduConstPtr',0,1,37,53
	.word	.L25,.L26
	.byte	6
	.byte	'TxIpduRamPtr',0,1,39,53
	.word	.L27,.L28
	.byte	6
	.byte	'LatestTransMode_u8',0,1,40,53
	.word	.L23,.L29
	.byte	6
	.byte	'Mode',0,1,41,53
	.word	.L23,.L30
	.byte	7
	.word	.L31,.L32,.L33
	.byte	8
	.word	.L34,.L35
	.byte	8
	.word	.L36,.L37
	.byte	8
	.word	.L38,.L39
	.byte	9
	.word	.L40,.L32,.L33
	.byte	6
	.byte	'tmp_u8',0,2,250,3,11
	.word	.L23,.L41
	.byte	0,0,7
	.word	.L42,.L43,.L4
	.byte	8
	.word	.L44,.L45
	.byte	8
	.word	.L46,.L47
	.byte	8
	.word	.L48,.L49
	.byte	10
	.word	.L50,.L43,.L4
	.byte	0,7
	.word	.L51,.L4,.L8
	.byte	8
	.word	.L52,.L53
	.byte	8
	.word	.L54,.L55
	.byte	8
	.word	.L56,.L57
	.byte	8
	.word	.L58,.L59
	.byte	10
	.word	.L60,.L4,.L8
	.byte	0,7
	.word	.L61,.L62,.L63
	.byte	8
	.word	.L64,.L65
	.byte	8
	.word	.L66,.L67
	.byte	8
	.word	.L68,.L69
	.byte	8
	.word	.L70,.L71
	.byte	10
	.word	.L72,.L62,.L63
	.byte	0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('Com_TxChangeMode')
	.sect	'.debug_abbrev'
.L18:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,52,0,3
	.byte	8,58,15,59,15,57,15,73,16,2,6,0,0,7,29,1,49,16,17,1,18,1,0,0,8,5,0,49,16,2,6,0,0,9,11,1,49,16,17,1,18
	.byte	1,0,0,10,11,0,49,16,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('Com_TxChangeMode')
	.sect	'.debug_line'
.L19:
	.word	.L89-.L88
.L88:
	.half	3
	.word	.L91-.L90
.L90:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_TxChangeMode.c',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Bfx\\api\\Bfx_Bit_Inl.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv_Inl.h',0,0,0,0,0
.L91:
	.byte	5,21,7,0,5,2
	.word	.L12
	.byte	3,33,1,5,10,9
	.half	.L73-.L12
	.byte	3,10,1,5,24,9
	.half	.L75-.L73
	.byte	3,1,1,5,25,9
	.half	.L76-.L75
	.byte	3,1,1,5,5,9
	.half	.L77-.L76
	.byte	3,32,1,4,2,5,14,9
	.half	.L32-.L77
	.byte	3,173,3,1,5,26,9
	.half	.L78-.L32
	.byte	1,5,21,9
	.half	.L2-.L78
	.byte	1,5,15,9
	.half	.L3-.L2
	.byte	3,2,1,5,33,9
	.half	.L92-.L3
	.byte	1,5,37,9
	.half	.L93-.L92
	.byte	1,5,31,9
	.half	.L94-.L93
	.byte	1,5,21,9
	.half	.L95-.L94
	.byte	1,5,66,9
	.half	.L96-.L95
	.byte	1,5,48,9
	.half	.L80-.L96
	.byte	1,5,11,9
	.half	.L97-.L80
	.byte	1,4,1,5,57,9
	.half	.L33-.L97
	.byte	3,211,124,1,4,2,5,28,9
	.half	.L43-.L33
	.byte	3,189,2,1,5,46,9
	.half	.L98-.L43
	.byte	1,5,71,9
	.half	.L99-.L98
	.byte	1,5,62,9
	.half	.L100-.L99
	.byte	1,5,43,9
	.half	.L101-.L100
	.byte	1,5,5,9
	.half	.L102-.L101
	.byte	1,4,3,5,52,9
	.half	.L4-.L102
	.byte	3,201,126,1,5,36,9
	.half	.L79-.L4
	.byte	1,5,5,9
	.half	.L103-.L79
	.byte	3,2,1,5,9,7,9
	.half	.L104-.L103
	.byte	3,2,1,5,47,7,9
	.half	.L105-.L104
	.byte	3,3,1,5,44,9
	.half	.L106-.L105
	.byte	1,5,9,9
	.half	.L6-.L106
	.byte	3,2,1,5,25,7,9
	.half	.L107-.L6
	.byte	3,3,1,5,43,9
	.half	.L108-.L107
	.byte	1,5,9,9
	.half	.L7-.L108
	.byte	3,125,1,9
	.half	.L5-.L7
	.byte	3,8,1,5,47,7,9
	.half	.L109-.L5
	.byte	3,2,1,5,44,9
	.half	.L110-.L109
	.byte	1,4,1,5,38,9
	.half	.L8-.L110
	.byte	3,234,126,1,5,56,9
	.half	.L111-.L8
	.byte	1,5,5,9
	.half	.L81-.L111
	.byte	3,1,1,4,2,5,105,9
	.half	.L62-.L81
	.byte	3,240,3,1,5,13,9
	.half	.L112-.L62
	.byte	3,1,1,5,120,9
	.half	.L113-.L112
	.byte	3,127,1,5,67,9
	.half	.L114-.L113
	.byte	1,5,24,9
	.half	.L115-.L114
	.byte	1,5,86,9
	.half	.L116-.L115
	.byte	1,5,84,9
	.half	.L117-.L116
	.byte	1,5,23,9
	.half	.L118-.L117
	.byte	3,1,1,5,34,9
	.half	.L119-.L118
	.byte	1,5,93,9
	.half	.L120-.L119
	.byte	3,127,1,5,11,9
	.half	.L121-.L120
	.byte	1,4,1,5,5,9
	.half	.L63-.L121
	.byte	3,151,124,1,5,37,7,9
	.half	.L122-.L63
	.byte	3,4,1,5,35,9
	.half	.L82-.L122
	.byte	1,5,40,9
	.half	.L123-.L82
	.byte	3,3,1,5,38,9
	.half	.L124-.L123
	.byte	1,5,32,9
	.half	.L125-.L124
	.byte	3,2,1,5,30,9
	.half	.L126-.L125
	.byte	1,5,1,9
	.half	.L10-.L126
	.byte	3,8,1,7,9
	.half	.L21-.L10
	.byte	0,1,1
.L89:
	.sdecl	'.debug_ranges',debug,cluster('Com_TxChangeMode')
	.sect	'.debug_ranges'
.L20:
	.word	-1,.L12,0,.L21-.L12,0,0
	.sdecl	'.debug_loc',debug,cluster('Com_TxChangeMode')
	.sect	'.debug_loc'
.L49:
	.word	0,0
.L69:
	.word	0,0
.L37:
	.word	0,0
.L47:
	.word	0,0
.L67:
	.word	0,0
.L11:
	.word	-1,.L12,0,.L22-.L12
	.half	2
	.byte	138,0
	.word	0,0
.L45:
	.word	0,0
.L35:
	.word	0,0
.L65:
	.word	0,0
.L29:
	.word	-1,.L12,.L81-.L12,.L82-.L12
	.half	1
	.byte	95
	.word	0,0
.L30:
	.word	-1,.L12,.L75-.L12,.L2-.L12
	.half	1
	.byte	83
	.word	.L3-.L12,.L22-.L12
	.half	1
	.byte	83
	.word	0,0
.L59:
	.word	0,0
.L71:
	.word	0,0
.L57:
	.word	0,0
.L26:
	.word	-1,.L12,.L76-.L12,.L2-.L12
	.half	1
	.byte	98
	.word	.L3-.L12,.L79-.L12
	.half	1
	.byte	98
	.word	0,0
.L55:
	.word	0,0
.L24:
	.word	-1,.L12,0,.L2-.L12
	.half	1
	.byte	84
	.word	.L73-.L12,.L74-.L12
	.half	5
	.byte	144,32,157,32,0
	.word	.L3-.L12,.L22-.L12
	.half	1
	.byte	84
	.word	0,0
.L28:
	.word	-1,.L12,.L77-.L12,.L2-.L12
	.half	1
	.byte	111
	.word	.L3-.L12,.L22-.L12
	.half	1
	.byte	111
	.word	0,0
.L53:
	.word	0,0
.L39:
	.word	0,0
.L41:
	.word	-1,.L12,.L78-.L12,.L2-.L12
	.half	5
	.byte	144,32,157,32,0
	.word	.L3-.L12,.L80-.L12
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
	.sdecl	'.debug_frame',debug
	.sect	'.debug_frame'
.L127:
	.word	48
	.word	-1
	.byte	3,0,2,1,27,12,26,0,8,27,8,26,8,28,8,29,8,30,8,31,8,34,8,35,8,32,8,33,8,16,8,17,8,24,8,25,8,36,8,37,8,38
	.byte	8,39
	.sdecl	'.debug_frame',debug,cluster('Com_TxChangeMode')
	.sect	'.debug_frame'
	.word	20
	.word	.L127,.L12,.L22-.L12
	.byte	8,19,8,21,8,22,8,23

; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   109  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   110  #define COM_STOP_SEC_CODE
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   111  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   112  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   113  /***************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   114   Function name    : Com_Prv_TxChangeMode_Signal
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   115   Syntax           : void Com_Prv_TxChangeMode_Signal(Com_IpduIdType TxIpduId)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   116   Description      : Internal function used for Transmission Mode Selector
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   117   Parameter        : TxIpduId
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   118   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   119   ***************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   120  #ifdef COM_TxFilters
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   121  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   122  LOCAL_INLINE FUNC(void,COM_CODE) Com_Prv_TxChangeMode_Signal(VAR(Com_IpduIdType, AUTOMATIC) TxIpduId)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   123  {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   124      /* Local pointer to hold the address of Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   125      Com_TxIpduConstPtrType                          TxIPduConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   126      /* Local pointer to hold the address of the Tx ipdu status structure */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   127      Com_TxIpduRamPtrType                            TxIpduRamPtr;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   128      /* Local pointer to Tx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   129      Com_TxSigConstPtrType                           TxSigConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   130      /* Local pointer to Tx signal status structure */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   131      Com_TxSigRamPtrType                             TxSigRamPtr;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   132      VAR(uint16_least, AUTOMATIC)                    Index_ui;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   133      VAR(Com_SigMaxType, AUTOMATIC)                  TxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   134      VAR(uint8, AUTOMATIC)                           FilterAlg_u8;  /* Filter type */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   135      VAR(uint8, AUTOMATIC)                           ConstByteValue_u8;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   136      VAR(uint8, AUTOMATIC)                           Type;   /* Signal Type */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   137      VAR(boolean, AUTOMATIC)                         Filter_Val;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   138  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   139      TxIPduConstPtr  = COM_GET_TX_IPDU_CONSTDATA(TxIpduId);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   140      TxIpduRamPtr    = &COM_GET_TXPDURAM_S(TxIpduId);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   141      TxSigConstPtr   = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   142      TxSigRamPtr     = &COM_GET_TXSIGNALFLAG(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   143  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   144      for(Index_ui = TxIPduConstPtr->No_Of_Sig_Ref; Index_ui != 0u; Index_ui--)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   145      {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   146          FilterAlg_u8 = (uint8)Com_GetValue(TXSIG,_FILTRALG,TxSigConstPtr->txSignalFields);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   147  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   148          /* Check if the filter is configured, NOTE: If filter is not configured, then the Value will be COM_ALWAYS
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   149              in the configuration and this means that the signal will not contribute to TMS calculation */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   150          if(FilterAlg_u8 != (uint8)COM_NOTCONFIGURED)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   151          {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   152              ConstByteValue_u8 = TxSigConstPtr->General;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   153              Type = Com_GetValue(GEN,_TYPE,ConstByteValue_u8);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   154  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   155              if(Type != (uint8)COM_UINT8_N)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   156              {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   157                  TxNewVal = Com_UnpackSignal( Com_GetValue(GEN,_ENDIANESS,ConstByteValue_u8),
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   158                                               TxSigConstPtr->Bit_Pos,
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   159                                               TxSigConstPtr->BitSize,
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   160                                               TxIPduConstPtr ->BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   161                                               ((Type & 0x01u) != 0x0u));
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   162              }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   163              else
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   164              {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   165                  TxNewVal = 0;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   166                  /* This variable will not be checked in Com_Filter, as the Algorithm for Uint8[n] will be only
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   167                   * ALWAYS or NEVER */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   168              }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   169              /* The last parameter is Information from where the call to Com_Filter happens */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   170              /* NOTE on last parameter:
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   171               * 1.Currently the values for the parameter CallContext_b are COM_TRUE/COM_FALSE
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   172               * 2.It is used only for filter ONE_EVERYN */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   173              Filter_Val = Com_Filter((uint32)TxNewVal,FilterAlg_u8, TxSigConstPtr->Filter_Index, COM_FALSE);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   174  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   175              if (Filter_Val != COM_FALSE)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   176              {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   177                  /* Increment TRUE counter , based on filter condition */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   178                  TxIpduRamPtr ->Com_TMSTrueCounter_u8++;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   179              }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   180              /* Store the latest filter state of the signal */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   181              Com_SetRamValue(TXSIG,_SIGCHNGMODE,TxSigRamPtr->txSigRAMFields,Filter_Val);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   182          }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   183          TxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   184          TxSigRamPtr++;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   185      }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   186  }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   187  #endif /* #ifdef COM_TxFilters */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   188  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   189  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   190  /***************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   191   Function name    : Com_Prv_TxChangeMode_SignalGroup
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   192   Syntax           : void Com_Prv_TxChangeMode_SignalGroup(Com_IpduIdType TxIpduId)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   193   Description      : Internal function used for Transmission Mode Selector
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   194   Parameter        : TxIpduId
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   195   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   196   ***************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   197  #if defined(COM_TxFilters) && defined(COM_TX_SIGNALGROUP)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   198  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   199  LOCAL_INLINE FUNC(void,COM_CODE) Com_Prv_TxChangeMode_SignalGroup(VAR(Com_IpduIdType, AUTOMATIC) TxIpduId)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   200  {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   201      /* Local pointer to hold the address of Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   202      Com_TxIpduConstPtrType                          TxIPduConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   203      /* Local pointer to Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   204      Com_TxSigGrpConstPtrType                        TxSigGrpConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   205      /* Local pointer to Tx GroupSignal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   206      Com_TxGrpSigConstPtrType                        TxGrpSigConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   207      /* Local pointer to Tx GroupSignal status structure */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   208      Com_TxGrpSigRamPtrType                          TxGrpSigRamPtr;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   209      VAR(uint16_least, AUTOMATIC)                    GrpSig_Index_ui;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   210      VAR(uint16_least, AUTOMATIC)                    Index_ui;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   211      VAR(boolean, AUTOMATIC)                         Filter_Val;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   212  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   213      TxIPduConstPtr   = COM_GET_TX_IPDU_CONSTDATA(TxIpduId);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   214  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   215      /* Secondly check for Group Signals */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   216      /* For Selection of the transmission mode the Group signals shall be treated as normal signals */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   217      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(TxIPduConstPtr->FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   218  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   219      for(Index_ui = TxIPduConstPtr->No_Of_SigGrp_Ref; Index_ui!= 0u; Index_ui--)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   220      {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   221          if(Com_GetValue(TXSIGGRP,_FILTEREVALREQ,TxSigGrpConstPtr->txSignalGrpFields) != COM_FALSE)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   222          {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   223              /* Now check for each Group Signal of this signal group */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   224              TxGrpSigRamPtr = &COM_GET_TXGRPSIGFLAG(TxSigGrpConstPtr->FirstGrpSig_Index);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   225  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   226              TxGrpSigConstPtr = COM_GET_TXGRPSIG_CONSTDATA(TxSigGrpConstPtr->FirstGrpSig_Index);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   227  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   228              for(GrpSig_Index_ui = TxSigGrpConstPtr->No_Of_GrpSig; GrpSig_Index_ui != 0u; GrpSig_Index_ui--)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   229              {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   230                  /* Check if the filter is configured, NOTE: If filter is not configured,
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   231                  then the Value will be COM_ALWAYS in the configuration */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   232                  if(TxGrpSigConstPtr->Filter_Algo != (uint8)COM_NOTCONFIGURED)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   233                  {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   234                      Filter_Val = Com_Prv_TxChangeMode_GroupSignal(TxIpduId, TxGrpSigConstPtr);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   235  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   236                      /* Store the latest filter state of the signal */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   237                      Com_SetRamValue(TXGRPSIG,_SIGCHNGMODE,TxGrpSigRamPtr->txGrpSigRAMFields,Filter_Val);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   238                  }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   239                  TxGrpSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   240                  TxGrpSigRamPtr++;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   241              }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   242          }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   243          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   244      }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   245  }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   246  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   247  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   248  /***************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   249   Function name    : Com_Prv_TxChangeMode_GroupSignal
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   250   Syntax           : boolean Com_Prv_TxChangeMode_GroupSignal    (VAR(Com_IpduIdType, AUTOMATIC) TxIpduId,
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   251                                                                   Com_TxGrpSigConstPtrType TxGrpSigConstPtr)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   252   Description      : Internal function used for Transmission Mode Selector
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   253   Parameter        : TxIpduId         - TX Pdu Id
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   254                      TxGrpSigConstPtr - Group signal constant pointer
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   255   Return value     : Filter_Val - COM_TRUE/COM_FALSE
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   256   ***************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   257  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_TxChangeMode_GroupSignal   (VAR(Com_IpduIdType, AUTOMATIC) TxIpduId,
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   258                                                                          Com_TxGrpSigConstPtrType TxGrpSigConstPtr)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   259  {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   260      /* Local pointer to hold the address of Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   261      Com_TxIpduConstPtrType                          TxIPduConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   262      Com_TxIpduRamPtrType                            TxIpduRamPtr;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   263  # ifdef COM_TX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   264      Com_TxSigGrpConstPtrType                        TxSigGrpConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   265  #endif
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   266      VAR(Com_SigMaxType, AUTOMATIC)                  TxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   267      VAR(Com_TxGrpSigBuffIndexType, AUTOMATIC)       GrpSigBuff_Index;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   268      VAR(Com_MainFuncType,AUTOMATIC)                 txMainFuncId;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   269      VAR(uint8, AUTOMATIC)                           ConstByteValue_u8;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   270      VAR(uint8, AUTOMATIC)                           Type;   /* Signal Type */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   271      VAR(boolean, AUTOMATIC)                         Filter_Val;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   272  # ifdef COM_TX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   273      VAR(boolean, AUTOMATIC)                         ConstIsSigGrpOfArrayType_b;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   274  #endif
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   275  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   276      TxIPduConstPtr  = COM_GET_TX_IPDU_CONSTDATA(TxIpduId);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   277      TxIpduRamPtr    = &COM_GET_TXPDURAM_S(TxIpduId);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   278      txMainFuncId    = TxIPduConstPtr->MainFunctionRef;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   279      TxNewVal        = 0u;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   280  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   281      ConstByteValue_u8 = TxGrpSigConstPtr->txGrpSigFields;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   282      Type = Com_GetValue(TXGRPSIG,_TYPE,ConstByteValue_u8);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   283  # ifdef COM_TX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   284      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(TxGrpSigConstPtr->SigGrpRef);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   285      ConstIsSigGrpOfArrayType_b = Com_GetValue(TXSIGGRP,_ARRAYACCESS,TxSigGrpConstPtr->txSignalGrpFields);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   286  # endif
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   287      if(Type != (uint8)COM_UINT8_N)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   288      {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   289  # ifdef COM_TX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   290          if ( ConstIsSigGrpOfArrayType_b )
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   291          {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   292              /* Unpack GroupSignal data from SignalGroup with ArrayAccess */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   293              TxNewVal = Com_UnpackSignal( Com_GetValue(TXGRPSIG,_ENDIANESS,ConstByteValue_u8),
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   294                                           TxGrpSigConstPtr->Bit_Pos,
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   295                                           TxGrpSigConstPtr->BitSize,
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   296                                           TxIPduConstPtr->BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   297                                           ((Type & 0x01u) != 0x0u));
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   298  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   299          }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   300          else
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   301  # endif /* # ifdef COM_TX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   302          {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   303              GrpSigBuff_Index = TxGrpSigConstPtr->TxGrpSigBuff_Index;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   304  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   305              switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   306              {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   307              case 0x00u: /* SINT8 signal, UINT8 signal */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   308              case 0x03u: /*Boolean Signal*/
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   309                  TxNewVal = COM_GET_TXGRPSIGTYPEU8_BUFF(txMainFuncId, GrpSigBuff_Index);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   310                  break;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   311  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   312              case 0x01u:
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   313                  /* SINT16 signal, UINT16 signal */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   314                  TxNewVal = COM_GET_TXGRPSIGTYPEU16_BUFF(txMainFuncId, GrpSigBuff_Index);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   315                  break;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   316  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   317              case 0x02u:
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   318                  /* SINT32 signal, UINT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   319                  TxNewVal = COM_GET_TXGRPSIGTYPEU32_BUFF(txMainFuncId, GrpSigBuff_Index);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   320                  break;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   321  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   322  # ifdef COM_TXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   323              case 0x08u:
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   324                  /* SINT64 signal, UINT64 signal */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   325                  TxNewVal = COM_GET_TXGRPSIGTYPEU64_BUFF(txMainFuncId, GrpSigBuff_Index);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   326                  break;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   327  # endif /* #ifdef COM_TXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   328  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   329              default:
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   330              /**
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   331               * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   332               * types are allowed to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   333               */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   334                  break;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   335              }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   336          }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   337      }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   338      else
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   339      {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   340          /* For GroupSignal of array types(UINT8[n]), signal values are not used for
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   341           * filter(ALWAYS, NEVER, ONE_EVERY_N) evaluation */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   342          TxNewVal = 0u;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   343      }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   344      /* The last parameter is Information from where the call to Com_Filter happens */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   345      /* NOTE on last parameter:
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   346      * 1.Currently the values for the parameter CallContext_b are COM_TRUE/COM_FALSE
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   347      * 2.It is used only for filter ONE_EVERYN */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   348      Filter_Val = Com_Filter((uint32)TxNewVal, TxGrpSigConstPtr->Filter_Algo,
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   349                          TxGrpSigConstPtr->Filter_Index,COM_FALSE);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   350  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   351      if (Filter_Val != COM_FALSE)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   352      {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   353          /* Increment TRUE counter , based on filter condition */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   354          TxIpduRamPtr ->Com_TMSTrueCounter_u8++;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   355      }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   356      return Filter_Val;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   357  }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   358  #endif /* #if defined(COM_TxFilters) && defined(COM_TX_SIGNALGROUP) */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   359  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   360  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   361  /***************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   362   Function name    : Com_Prv_SigTxChangeMode
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   363   Syntax           : boolean Com_Prv_SigTxChangeMode(uint16 SignalId, uint32 TxNewVal)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   364   Description      : This function evaluates the current TMS of the IPDU, based on the corresponding signal
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   365                      which is updated.
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   366   Parameter        : SignalId -> Id of the signal
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   367                    : TxNewVal -> New signal value
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   368   Return value     : COM_TRUE/COM_FALSE
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   369   ***************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   370  #ifdef COM_TxFilters
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   371  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   372  #define COM_START_SEC_CODE
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   373  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   374  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   375  FUNC(boolean,COM_CODE) Com_Prv_SigTxChangeMode(VAR(Com_SignalIdType, AUTOMATIC) SignalId,
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   376                                                 VAR(uint32, AUTOMATIC) TxNewVal)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   377  {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   378  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   379      Com_TxIpduRamPtrType    TxIpduRamPtr;      /* Local pointer to Tx ipdu   dynamic configuration */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   380      Com_TxSigConstPtrType   TxSigConstPtr;     /* Local pointer to Tx signal static  configuration */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   381      Com_TxSigRamPtrType     TxSigRamPtr;       /* Local pointer to Tx signal dynamic configuration */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   382      VAR(Com_IpduIdType, AUTOMATIC)  TxIpduId;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   383      VAR(boolean, AUTOMATIC)         sig_TMSState;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   384      VAR(boolean, AUTOMATIC)         ReturnValue;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   385  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   386      TxSigConstPtr   = COM_GET_TXSIG_CONSTDATA(SignalId);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   387      TxIpduId        = TxSigConstPtr->IpduRef;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   388  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   389      TxIpduRamPtr    = &COM_GET_TXPDURAM_S(TxIpduId);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   390  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   391      /* Call Filter for all signals in the IPDU */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   392      SchM_Enter_Com_TxIpduProtArea(SIGTXCHANGEMODE);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   393      {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   394          TxSigRamPtr     = &COM_GET_TXSIGNALFLAG(SignalId);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   395  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   396          /* Check the configured filter algorithm */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   397          if(Com_GetValue(TXSIG,_FILTRALG,TxSigConstPtr->txSignalFields) > (uint16)COM_NEVER)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   398          {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   399              /* Evaluate current filter state of the signal */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   400              /* The last parameter is Information from where the call to Com_Filter happens */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   401              /* NOTE on last parameter:
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   402               * 1.Currently the values for the parameter CallContext_b are COM_TRUE/COM_FALSE
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   403               * 2.It is used only for filter ONE_EVERYN */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   404              sig_TMSState = Com_Filter(TxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   405                                 (uint8)Com_GetValue(TXSIG,_FILTRALG,TxSigConstPtr->txSignalFields),
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   406                                     TxSigConstPtr->Filter_Index,COM_TRUE);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   407              /* Update TMS TRUE counter , only if filter state of the signal changes.
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   408               * Otherwise, TMS TRUE counter value remains unchanged.
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   409               */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   410              if (Com_GetRamValue(TXSIG,_SIGCHNGMODE,TxSigRamPtr->txSigRAMFields)!= sig_TMSState)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   411              {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   412                  /* Signal has changed from FALSE to TRUE, hence increment TMS TRUE counter, else
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   413                   * if Signal has changed from TRUE to FALSE, hence decrement TMS TRUE counter
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   414                   */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   415                  TxIpduRamPtr ->Com_TMSTrueCounter_u8 =
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   416                         ((sig_TMSState != COM_FALSE) ? (TxIpduRamPtr ->Com_TMSTrueCounter_u8 + 1):
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   417                                                      (TxIpduRamPtr ->Com_TMSTrueCounter_u8-1));
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   418  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   419                  /* Update the latest filter state of the signal, if the signal filter state changes */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   420                  Com_SetRamValue(TXSIG,_SIGCHNGMODE,TxSigRamPtr->txSigRAMFields,sig_TMSState);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   421              }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   422          }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   423      }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   424      /* Call function to check for the mode changes */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   425      ReturnValue = Com_Prv_CheckModeChange(TxIpduId);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   426      SchM_Exit_Com_TxIpduProtArea(SIGTXCHANGEMODE);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   427  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   428      return(ReturnValue);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   429  }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   430  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   431  #define COM_STOP_SEC_CODE
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   432  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   433  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   434  #endif /* #ifdef COM_TxFilters */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   435  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   436  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   437  #if (defined(COM_TxFilters) && defined(COM_TX_SIGNALGROUP))
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   438  /***************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   439   Function name    : Com_Prv_SigGrpTxChangeMode
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   440   Syntax           : FUNC(boolean,COM_CODE) Com_Prv_SigGrpTxChangeMode(VAR(Com_IpduIdType, AUTOMATIC) SignalGroupId
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   441   Description      : This function evaluates the current TMS of the IPDU, based on the corresponding signal or
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   442                      signal group which is updated.
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   443   Parameter        : SignalGroupId -> Id of the SignalGroup
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   444   Return value     : COM_TRUE/COM_FALSE
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   445   ***************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   446  #define COM_START_SEC_CODE
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   447  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   448  /* HIS METRIC CALLS, LEVEL VIOLATION IN Com_Prv_SigGrpTxChangeMode:
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   449     Com_Prv_SigGrpTxChangeMode function contains necessary function calls and simple "if", "switch" case statements.
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   450     HIS metric compliance would decrease readability and maintainability */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   451  FUNC(boolean,COM_CODE) Com_Prv_SigGrpTxChangeMode(VAR(Com_SignalGroupIdType, AUTOMATIC) SignalGroupId)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   452  {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   453  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   454      Com_TxIpduConstPtrType  TxIPduConstPtr;    /* Local pointer to Tx ipdu   static  configuration */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   455      Com_TxIpduRamPtrType    TxIpduRamPtr;      /* Local pointer to Tx ipdu   dynamic configuration */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   456      /* Local pointer to Tx GroupSignal dynamic configuration */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   457      Com_TxGrpSigRamPtrType                      TxGrpSigRamPtr;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   458      /* Local pointer to Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   459      Com_TxSigGrpConstPtrType                    TxSigGrpConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   460      /* Local pointer to Tx GroupSignal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   461      Com_TxGrpSigConstPtrType                    TxGrpSigConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   462  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   463      VAR(Com_SigMaxType, AUTOMATIC)              TxNewVal_GrpSig;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   464      VAR(Com_TxGrpSigBuffIndexType, AUTOMATIC)   GrpSigBuff_Index;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   465      VAR(Com_IpduIdType, AUTOMATIC)              TxIpduId;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   466      VAR(uint16_least, AUTOMATIC)                GrpSig_Index_ui;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   467      VAR(uint8, AUTOMATIC)                       ConstByteValue_u8;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   468      VAR(boolean, AUTOMATIC)                     sig_TMSState;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   469      VAR(boolean, AUTOMATIC)                     ReturnValue;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   470      VAR(uint8, AUTOMATIC)                       Type;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   471      VAR(Com_MainFuncType,AUTOMATIC)             txMainFuncId;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   472  #ifdef COM_TX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   473      boolean                                     ConstIsSigGrpOfArrayType_b;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   474  #endif
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   475  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   476      TxNewVal_GrpSig  = (Com_SigMaxType)COM_ZERO;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   477      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(SignalGroupId);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   478      TxIpduId         = TxSigGrpConstPtr->IpduRef;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   479  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   480      TxIpduRamPtr    = &COM_GET_TXPDURAM_S(TxIpduId);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   481      TxIPduConstPtr  = COM_GET_TX_IPDU_CONSTDATA(TxIpduId);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   482  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   483      /* Call Filter for all Group Signals in the IPDU */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   484      SchM_Enter_Com_TxIpduProtArea(SIGGRPTXCHANGEMODE);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   485  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   486      /* Get the Bit field Byte value */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   487      TxGrpSigRamPtr              = &COM_GET_TXGRPSIGFLAG(TxSigGrpConstPtr->FirstGrpSig_Index);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   488  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   489      TxGrpSigConstPtr            = COM_GET_TXGRPSIG_CONSTDATA(TxSigGrpConstPtr->FirstGrpSig_Index);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   490  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   491      txMainFuncId = TxIPduConstPtr->MainFunctionRef;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   492  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   493  #ifdef COM_TX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   494      ConstIsSigGrpOfArrayType_b  = Com_GetValue(TXSIGGRP,_ARRAYACCESS,TxSigGrpConstPtr->txSignalGrpFields);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   495  #endif
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   496  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   497      for(GrpSig_Index_ui = TxSigGrpConstPtr->No_Of_GrpSig; GrpSig_Index_ui != 0u; GrpSig_Index_ui--)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   498      {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   499          /* Check if the filter is configured, NOTE: If filter is not configured,
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   500             then the Value will be COM_ALWAYS in the configuration */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   501          if((TxGrpSigConstPtr->Filter_Algo != (uint8)COM_NOTCONFIGURED) && (TxGrpSigConstPtr->Filter_Algo > COM_NEVER))
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   502          {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   503  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   504              ConstByteValue_u8   = TxGrpSigConstPtr->txGrpSigFields;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   505              Type                = Com_GetValue(TXGRPSIG,_TYPE,ConstByteValue_u8);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   506  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   507              if(Type != (uint8)COM_UINT8_N)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   508              {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   509  #ifdef COM_TX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   510                  if (ConstIsSigGrpOfArrayType_b)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   511                  {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   512                      /* Unpack GroupSignal data from SignalGroup with ArrayAccess */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   513                      TxNewVal_GrpSig = Com_UnpackSignal( Com_GetValue(TXGRPSIG,_ENDIANESS,ConstByteValue_u8),
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   514                                                          TxGrpSigConstPtr->Bit_Pos,
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   515                                                          TxGrpSigConstPtr->BitSize,
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   516                                                          TxIPduConstPtr->BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   517                                                          ((Type & 0x01u) != 0x0u));
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   518                  }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   519                  else
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   520  #endif /* # ifdef COM_TX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   521                  {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   522                      GrpSigBuff_Index = TxGrpSigConstPtr->TxGrpSigBuff_Index;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   523  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   524                      switch(Type >> COM_ONE)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   525                      {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   526                      case 0x00u:  /* UINT8   Signal */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   527                      case 0x03u:  /* Boolean Signal */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   528                          TxNewVal_GrpSig = COM_GET_TXGRPSIGTYPEU8_BUFF(txMainFuncId, GrpSigBuff_Index);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   529                          break;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   530  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   531                      case 0x01u:
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   532                          /* UINT16 signal */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   533                          TxNewVal_GrpSig = COM_GET_TXGRPSIGTYPEU16_BUFF(txMainFuncId, GrpSigBuff_Index);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   534                          break;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   535  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   536                      case 0x02u:
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   537                          /* UINT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   538                          TxNewVal_GrpSig = COM_GET_TXGRPSIGTYPEU32_BUFF(txMainFuncId, GrpSigBuff_Index);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   539                          break;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   540  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   541  #ifdef COM_TXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   542                      case 0x08u:
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   543                          /* UINT64 signal */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   544                          TxNewVal_GrpSig = COM_GET_TXGRPSIGTYPEU64_BUFF(txMainFuncId, GrpSigBuff_Index);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   545                          break;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   546  #endif /* #ifdef COM_TXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   547  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   548                      default:
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   549                          /**
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   550                           * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   551                           * types are allowed to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   552                           */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   553                          break;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   554                      }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   555                  }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   556              }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   557              else
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   558              {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   559                  /* For GroupSignal of array types(UINT8[n]), signal values are not used for
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   560                   * filter(ALWAYS, NEVER, ONE_EVERY_N) evaluation */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   561                  TxNewVal_GrpSig = COM_ZERO;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   562              }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   563  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   564              /* The last parameter is Information from where the call to Com_Filter happens */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   565              /* NOTE on last parameter:
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   566               * 1.Currently the values for the parameter CallContext_b are COM_TRUE/COM_FALSE
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   567               * 2.It is used only for filter ONE_EVERYN */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   568              sig_TMSState = Com_Filter((uint32)TxNewVal_GrpSig, TxGrpSigConstPtr->Filter_Algo,
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   569                                                                 TxGrpSigConstPtr->Filter_Index,COM_TRUE);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   570  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   571              /* Update TMS TRUE counter , only if filter state of the signal changes.
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   572               * Otherwise, TMS TRUE counter value remains unchanged.
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   573               */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   574              if (Com_GetRamValue(TXGRPSIG,_SIGCHNGMODE,TxGrpSigRamPtr->txGrpSigRAMFields)!= sig_TMSState)
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   575              {
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   576  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   577                  /* Signal has changed from FALSE to TRUE, hence increment TMS TRUE counter,
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   578                   * else if Signal has changed from TRUE to FALSE, hence decrement TMS TRUE counter
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   579                   */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   580                  TxIpduRamPtr->Com_TMSTrueCounter_u8 =
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   581                      ((sig_TMSState != COM_FALSE) ? (TxIpduRamPtr->Com_TMSTrueCounter_u8+1):
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   582                                                          (TxIpduRamPtr->Com_TMSTrueCounter_u8-1));
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   583  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   584                  Com_SetRamValue(TXGRPSIG,_SIGCHNGMODE,TxGrpSigRamPtr->txGrpSigRAMFields,sig_TMSState);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   585              }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   586          }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   587          TxGrpSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   588          TxGrpSigRamPtr++;
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   589      }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   590      /* Call function to check whether mode is changed or not */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   591      ReturnValue = Com_Prv_CheckModeChange(TxIpduId);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   592  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   593      SchM_Exit_Com_TxIpduProtArea(SIGGRPTXCHANGEMODE);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   594  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   595      return(ReturnValue);
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   596  }
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   597  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   598  #define COM_STOP_SEC_CODE
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   599  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   600  
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   601  #endif /* #if (defined(COM_TxFilters) && defined(COM_TX_SIGNALGROUP)) */
; BSW\src\BSW\Gen\Com\src\Com_TxChangeMode.c	   602  

	; Module end
