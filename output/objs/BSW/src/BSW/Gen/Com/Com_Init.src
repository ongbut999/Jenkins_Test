	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 19053136 SN 09001910"
	.compiler_invocation	"ctc -f cc14328a -c99 --integer-enumeration -D__CPU__=tc27x -D__CPU_TC27X__ --core=tc1.6.x --eabi-compliant --fp-model=-float -D_TASKING_C_TRICORE_=1 -I.\\output\\inc -g2 -t4 --language=-comments,-gcc,+volatile,-strings --default-near-size=0 -O2ROPYGKLF-predict --default-a1-size=0 --default-a0-size=0 --source --switch=auto -o output\\objs\\BSW\\src\\BSW\\Gen\\Com\\Com_Init.src BSW\\src\\BSW\\Gen\\Com\\src\\Com_Init.c"
	.compiler_name		"ctc"
	;source	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Init.c'

	
$TC16X
	
	.sdecl	'.text.Com_Init.Com_Init',code,cluster('Com_Init')
	.sect	'.text.Com_Init.Com_Init'
	.align	2
	
	.global	Com_Init

; BSW\src\BSW\Gen\Com\src\Com_Init.c	     1  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	     2  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	     3  /**************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	     4  /* Preprocessor includes                                                                          */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	     5  /**************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	     6  #include "Com_Prv.h"
; BSW\src\BSW\Gen\Com\src\Com_Init.c	     7  #include "Com_Prv_Inl.h"
; BSW\src\BSW\Gen\Com\src\Com_Init.c	     8  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	     9  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    10  #define COM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    11  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    12  VAR(Com_StatusType,COM_VAR)         Com_Uninit_Flag;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    13  #define COM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    14  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    15  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    16  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    17  /* Note: Com_Prv_Config_pcst pointer variable should always be under Pre-Compile MemMap section, or else it can lead to
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    18   * RAM corruption */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    19  #define COM_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    20  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    21  P2CONST(Com_ConfigData_tst,AUTOMATIC,COM_APPL_CONST) Com_Prv_Config_pcst;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    22  #define COM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    23  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    24  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    25  /*
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    26   ***************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    27   * Prototypes
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    28   ***************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    29   */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    30  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    31  #if(COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    32  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    33  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_CompareVersionInfo(
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    34                                                 P2CONST(Std_VersionInfoType, AUTOMATIC, COM_APPL_CONST) srcVersionInfo,
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    35                                                 P2CONST(Std_VersionInfoType, AUTOMATIC, COM_APPL_CONST) destVersionInfo
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    36                                                              );
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    37  #endif /* #if(COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE) */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    38  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    39  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    40  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_Init_Receive(void);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    41  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    42  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_Init_Send(void);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    43  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    44  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    45  #ifdef COM_IPDU_WITHOUT_IPDUGROUPREF
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    46  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_Init_IpduWoGroupRef(VAR(PduIdType, AUTOMATIC) IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    47  #endif /* COM_IPDU_WITHOUT_IPDUGROUPREF */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    48  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    49  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_Init_TxSignal(VAR(PduIdType, AUTOMATIC) IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    50  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    51  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    52  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_Init_TxSignalGroup(VAR(PduIdType, AUTOMATIC) IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    53  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    54  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_Init_GroupSignal(Com_TxIpduConstPtrType TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    55                                                                Com_TxSigGrpConstPtrType TxSigGrpConstPtr);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    56  #endif /* COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    57  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    58  /**************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    59  /* Global functions (declared in header files )                                                   */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    60  /**************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    61  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    62  /***************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    63   Function name    : Com_Init
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    64   Syntax           : void Com_Init(const Com_ConfigType* config)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    65   Description      : Service for initializing COM module
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    66   Parameter        : config -> Pointer to Com module's configuration data
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    67   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    68   ***************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    69  #define COM_START_SEC_CODE
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    70  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    71  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    72  FUNC(void, COM_CODE) Com_Init(P2CONST(Com_ConfigType, AUTOMATIC, COM_APPL_DATA) config)
; Function Com_Init
.L44:
Com_Init:	.type	func
	sub.a	a10,#8
.L193:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	    73  {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    74  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    75  #if defined (COM_SIGNALGATEWAY) || defined (COM_SIGNALGROUPGATEWAY)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    76      Com_RxGwQueuePtrType          l_RxGwQueuePtr_struc;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    77  #endif /* #if defined (COM_SIGNALGATEWAY) || defined (COM_SIGNALGROUPGATEWAY) */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    78  #ifdef COM_F_ONEEVERYN
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    79      VAR(uint16_least, AUTOMATIC)  Idx_ui;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    80  #endif /* #ifdef COM_F_ONEEVERYN */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    81  #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    82  {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    83      /* variable to read version info from Com_GetVersionInfo */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    84      VAR(Std_VersionInfoType, AUTOMATIC) versionInfo_s;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    85      /* Read the pre-compile version info */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    86      Com_GetVersionInfo(&versionInfo_s);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    87  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    88  # if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    89      /* Call DET Function to check for the DET Error COM_E_PARAM_POINTER */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    90      if(Com_Prv_DETCheck_Ptr_Only((config == NULL_PTR), COMServiceId_Init))
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    91  #endif /* (COM_CONFIGURATION_USE_DET == STD_ON) */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    92      {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    93          /* Compare pre-compile & post-build version info */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    94          if(Com_CompareVersionInfo(&versionInfo_s, config->versionInfo))
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    95          {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    96              /* versionInfo doesnt match .. Inform application */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    97              ComAppl_IncompatibleGenerator();
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    98  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	    99              /* Abort further initialisation ..Com will remain in COM_UNINIT state */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   100              return;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   101          }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   102  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   103          /* MR12 RULE 11.5 VIOLATION: On assignment, target pointer will reference to the memory address, and there are
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   104           * no side effects. Hence suppressed the warning. */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   105          Com_Prv_Config_pcst = (P2CONST(Com_ConfigData_tst,AUTOMATIC,COM_APPL_CONST))config->Com_ConfigData;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   106      }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   107  }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   108  #else
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   109      (void)config;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   110  #endif /* (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE) */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   111  #if defined (COM_SIGNALGATEWAY) || defined (COM_SIGNALGROUPGATEWAY)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   112      l_RxGwQueuePtr_struc                        = COM_GET_RXGWQUEUE_S;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   113      l_RxGwQueuePtr_struc->Com_RxGwQueueRead_ux  = COM_ZERO;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   114      l_RxGwQueuePtr_struc->Com_RxGwQueueWrite_ux = COM_ZERO;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   115      l_RxGwQueuePtr_struc->RxGwQueuePtr          = &COM_GET_RXGWQUEUE_AUX(0);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   116  #endif /* #if defined (COM_SIGNALGATEWAY) || defined (COM_SIGNALGROUPGATEWAY) */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   117  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   118      rba_BswSrv_MemSet8(&Com_IpduGrpVector[COM_ZERO]   ,(uint32)COM_ZERO,(uint32)COM_NUM_ARR_IPDUGRPVECT);
	movh.a	a15,#@his(Com_IpduGrpVector)
	lea	a15,[a15]@los(Com_IpduGrpVector)
.L230:
	mov	d15,#0
.L62:

; .\Integration\BSW\Include\rba_BswSrv.h	     1  /*
; .\Integration\BSW\Include\rba_BswSrv.h	     2   * This is a template file. It defines integration functions necessary to complete RTA-BSW.
; .\Integration\BSW\Include\rba_BswSrv.h	     3   * The integrator must complete the templates before deploying software containing functions defined in this file.
; .\Integration\BSW\Include\rba_BswSrv.h	     4   * Once templates have been completed, the integrator should delete the #error line.
; .\Integration\BSW\Include\rba_BswSrv.h	     5   * Note: The integrator is responsible for updates made to this file.
; .\Integration\BSW\Include\rba_BswSrv.h	     6   *
; .\Integration\BSW\Include\rba_BswSrv.h	     7   * To remove the following error define the macro NOT_READY_FOR_TESTING_OR_DEPLOYMENT with a compiler option (e.g. -D NOT_READY_FOR_TESTING_OR_DEPLOYMENT)
; .\Integration\BSW\Include\rba_BswSrv.h	     8   * The removal of the error only allows the user to proceed with the building phase
; .\Integration\BSW\Include\rba_BswSrv.h	     9   */
; .\Integration\BSW\Include\rba_BswSrv.h	    10  
; .\Integration\BSW\Include\rba_BswSrv.h	    11  
; .\Integration\BSW\Include\rba_BswSrv.h	    12  
; .\Integration\BSW\Include\rba_BswSrv.h	    13  
; .\Integration\BSW\Include\rba_BswSrv.h	    14  /*
; .\Integration\BSW\Include\rba_BswSrv.h	    15   * This is a template file. It defines integration functions necessary to complete RTA-BSW.
; .\Integration\BSW\Include\rba_BswSrv.h	    16   * The integrator must complete the templates before deploying software containing functions defined in this file.
; .\Integration\BSW\Include\rba_BswSrv.h	    17   * Once templates have been completed, the integrator should delete the #error line.
; .\Integration\BSW\Include\rba_BswSrv.h	    18   * Note: The integrator is responsible for updates made to this file.
; .\Integration\BSW\Include\rba_BswSrv.h	    19   *
; .\Integration\BSW\Include\rba_BswSrv.h	    20   * To remove the following error define the macro NOT_READY_FOR_TESTING_OR_DEPLOYMENT with a compiler option (e.g. -D NOT_READY_FOR_TESTING_OR_DEPLOYMENT)
; .\Integration\BSW\Include\rba_BswSrv.h	    21   * The removal of the error only allows the user to proceed with the building phase
; .\Integration\BSW\Include\rba_BswSrv.h	    22   */
; .\Integration\BSW\Include\rba_BswSrv.h	    23  
; .\Integration\BSW\Include\rba_BswSrv.h	    24  
; .\Integration\BSW\Include\rba_BswSrv.h	    25  #ifndef RBA_BSWSRV_H
; .\Integration\BSW\Include\rba_BswSrv.h	    26  #define RBA_BSWSRV_H
; .\Integration\BSW\Include\rba_BswSrv.h	    27  
; .\Integration\BSW\Include\rba_BswSrv.h	    28  
; .\Integration\BSW\Include\rba_BswSrv.h	    29  
; .\Integration\BSW\Include\rba_BswSrv.h	    30  /*
; .\Integration\BSW\Include\rba_BswSrv.h	    31   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    32   * Includes
; .\Integration\BSW\Include\rba_BswSrv.h	    33   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    34   */
; .\Integration\BSW\Include\rba_BswSrv.h	    35  
; .\Integration\BSW\Include\rba_BswSrv.h	    36  #include "Std_Types.h"
; .\Integration\BSW\Include\rba_BswSrv.h	    37  
; .\Integration\BSW\Include\rba_BswSrv.h	    38  /*
; .\Integration\BSW\Include\rba_BswSrv.h	    39   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    40   * Defines
; .\Integration\BSW\Include\rba_BswSrv.h	    41   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    42   */
; .\Integration\BSW\Include\rba_BswSrv.h	    43  /* Vendor and module identification */
; .\Integration\BSW\Include\rba_BswSrv.h	    44  #define RBA_BSWSRV_VENDOR_ID   (6)
; .\Integration\BSW\Include\rba_BswSrv.h	    45  #define RBA_BSWSRV_MODULE_ID   (255)
; .\Integration\BSW\Include\rba_BswSrv.h	    46  #define RBA_BSWSRV_INSTANCE_ID (0)
; .\Integration\BSW\Include\rba_BswSrv.h	    47  
; .\Integration\BSW\Include\rba_BswSrv.h	    48  /* Module version information */
; .\Integration\BSW\Include\rba_BswSrv.h	    49  #define RBA_BSWSRV_SW_MAJOR_VERSION (3)
; .\Integration\BSW\Include\rba_BswSrv.h	    50  #define RBA_BSWSRV_SW_MINOR_VERSION (0)
; .\Integration\BSW\Include\rba_BswSrv.h	    51  #define RBA_BSWSRV_SW_PATCH_VERSION (0)
; .\Integration\BSW\Include\rba_BswSrv.h	    52  
; .\Integration\BSW\Include\rba_BswSrv.h	    53  
; .\Integration\BSW\Include\rba_BswSrv.h	    54  
; .\Integration\BSW\Include\rba_BswSrv.h	    55  
; .\Integration\BSW\Include\rba_BswSrv.h	    56  #  define RBA_BSWSRV_PARAM_UNUSED(param)          (void)(param)         /* iwm7abt workaround for defect CSCRM00957569 */
; .\Integration\BSW\Include\rba_BswSrv.h	    57  #  define RBA_BSWSRV_PRV_C_IMPL
; .\Integration\BSW\Include\rba_BswSrv.h	    58  
; .\Integration\BSW\Include\rba_BswSrv.h	    59  
; .\Integration\BSW\Include\rba_BswSrv.h	    60  /*
; .\Integration\BSW\Include\rba_BswSrv.h	    61   *********************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    62   * Type definition
; .\Integration\BSW\Include\rba_BswSrv.h	    63   *********************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    64   */
; .\Integration\BSW\Include\rba_BswSrv.h	    65  
; .\Integration\BSW\Include\rba_BswSrv.h	    66  typedef unsigned long long rba_BswSrv_uint64;
; .\Integration\BSW\Include\rba_BswSrv.h	    67  
; .\Integration\BSW\Include\rba_BswSrv.h	    68  
; .\Integration\BSW\Include\rba_BswSrv.h	    69  /*
; .\Integration\BSW\Include\rba_BswSrv.h	    70   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    71   * Variable declarations
; .\Integration\BSW\Include\rba_BswSrv.h	    72   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    73   */
; .\Integration\BSW\Include\rba_BswSrv.h	    74  
; .\Integration\BSW\Include\rba_BswSrv.h	    75   /*
; .\Integration\BSW\Include\rba_BswSrv.h	    76   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    77   * Prototypes
; .\Integration\BSW\Include\rba_BswSrv.h	    78   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    79   */
; .\Integration\BSW\Include\rba_BswSrv.h	    80  
; .\Integration\BSW\Include\rba_BswSrv.h	    81  #define RBA_BSWSRV_START_SEC_CODE
; .\Integration\BSW\Include\rba_BswSrv.h	    82  #include "rba_BswSrv_MemMap.h"
; .\Integration\BSW\Include\rba_BswSrv.h	    83  extern void* rba_BswSrv_MemCopy(void* xDest_pv, const void* xSrc_pcv, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    84  extern void* rba_BswSrv_MemSet(void* xDest_pv, sint32 xPattern_u32, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    85  extern sint32 rba_BswSrv_MemCompare(const void* xSrc1_pcv, const void* xSrc2_pcv, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    86  #define RBA_BSWSRV_STOP_SEC_CODE
; .\Integration\BSW\Include\rba_BswSrv.h	    87  #include "rba_BswSrv_MemMap.h"
; .\Integration\BSW\Include\rba_BswSrv.h	    88  
; .\Integration\BSW\Include\rba_BswSrv.h	    89  LOCAL_INLINE uint32 rba_BswSrv_ByteOrderSwap32(uint32 Input_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    90  LOCAL_INLINE uint16 rba_BswSrv_ByteOrderSwap16(uint16 Input_u16);
; .\Integration\BSW\Include\rba_BswSrv.h	    91  LOCAL_INLINE void   rba_BswSrv_MemCopy64(rba_BswSrv_uint64* xDest_pu64, const rba_BswSrv_uint64* xSrc_pcu64, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    92  LOCAL_INLINE void   rba_BswSrv_MemCopy32(uint32* xDest_pu32, const uint32* xSrc_pcu32, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    93  LOCAL_INLINE void   rba_BswSrv_MemCopy16(uint16* xDest_pu16, const uint16* xSrc_pcu16, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    94  LOCAL_INLINE void   rba_BswSrv_MemCopy8(uint8* xDest_pu8, const uint8* xSrc_pcu8, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    95  LOCAL_INLINE uint32 rba_BswSrv_MemCompare64(const rba_BswSrv_uint64* xSrc1_pcu64, const rba_BswSrv_uint64* xSrc2_pcu64, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    96  LOCAL_INLINE uint32 rba_BswSrv_MemCompare32(const uint32* xSrc1_pcu32, const uint32* xSrc2_pcu32, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    97  LOCAL_INLINE uint32 rba_BswSrv_MemCompare16(const uint16* xSrc1_pcu16, const uint16* xSrc2_pcu16, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    98  LOCAL_INLINE uint32 rba_BswSrv_MemCompare8(const uint8* xSrc1_pcu8, const uint8* xSrc2_pcu8, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    99  LOCAL_INLINE void   rba_BswSrv_MemSet64(rba_BswSrv_uint64* xDest_pu64, rba_BswSrv_uint64 xPattern_u64, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	   100  LOCAL_INLINE void   rba_BswSrv_MemSet32(uint32* xDest_pu32, uint32 xPattern_u32, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	   101  LOCAL_INLINE void   rba_BswSrv_MemSet16(uint16* xDest_pu16, uint32 xPattern_u32, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	   102  LOCAL_INLINE void   rba_BswSrv_MemSet8(uint8* xDest_pu8, uint32 xPattern_u32, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	   103  
; .\Integration\BSW\Include\rba_BswSrv.h	   104  /*
; .\Integration\BSW\Include\rba_BswSrv.h	   105   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   106   * Inline function definitions
; .\Integration\BSW\Include\rba_BswSrv.h	   107   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   108   */
; .\Integration\BSW\Include\rba_BswSrv.h	   109  
; .\Integration\BSW\Include\rba_BswSrv.h	   110  
; .\Integration\BSW\Include\rba_BswSrv.h	   111  
; .\Integration\BSW\Include\rba_BswSrv.h	   112  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   113   *********************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   114   * rba_BswSrv_ByteOrderSwap32
; .\Integration\BSW\Include\rba_BswSrv.h	   115   *
; .\Integration\BSW\Include\rba_BswSrv.h	   116   * Swaps the byte order of a 32 bit value for endianess conversion.
; .\Integration\BSW\Include\rba_BswSrv.h	   117   *
; .\Integration\BSW\Include\rba_BswSrv.h	   118   * \param   Input_u32: input value
; .\Integration\BSW\Include\rba_BswSrv.h	   119   * \return  value with swapped byte order
; .\Integration\BSW\Include\rba_BswSrv.h	   120   * \retval  uint32
; .\Integration\BSW\Include\rba_BswSrv.h	   121   * \seealso
; .\Integration\BSW\Include\rba_BswSrv.h	   122   * \usedresources
; .\Integration\BSW\Include\rba_BswSrv.h	   123   *********************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   124   */
; .\Integration\BSW\Include\rba_BswSrv.h	   125  LOCAL_INLINE uint32 rba_BswSrv_ByteOrderSwap32(uint32 Input_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   126  {
; .\Integration\BSW\Include\rba_BswSrv.h	   127      uint32 retVal_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   128  
; .\Integration\BSW\Include\rba_BswSrv.h	   129  
; .\Integration\BSW\Include\rba_BswSrv.h	   130      retVal_u32 = (Input_u32 << 24) | ((Input_u32 & 0xFF00u) << 8) | ((Input_u32 & 0x00FF0000u) >> 8) | (Input_u32 >> 24);
; .\Integration\BSW\Include\rba_BswSrv.h	   131  
; .\Integration\BSW\Include\rba_BswSrv.h	   132  
; .\Integration\BSW\Include\rba_BswSrv.h	   133      /* MISRA RULE 9.1 VIOLATION: variable is set by inline assembly but the checker does not understand this */
; .\Integration\BSW\Include\rba_BswSrv.h	   134      return retVal_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   135  }
; .\Integration\BSW\Include\rba_BswSrv.h	   136  
; .\Integration\BSW\Include\rba_BswSrv.h	   137  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   138   *********************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   139   * rba_BswSrv_ByteOrderSwap16
; .\Integration\BSW\Include\rba_BswSrv.h	   140   *
; .\Integration\BSW\Include\rba_BswSrv.h	   141   * Swaps the byte order of a 16 bit value for endianess conversion.
; .\Integration\BSW\Include\rba_BswSrv.h	   142   *
; .\Integration\BSW\Include\rba_BswSrv.h	   143   * \param   Input_u16: input value
; .\Integration\BSW\Include\rba_BswSrv.h	   144   * \return  value with swapped byte order
; .\Integration\BSW\Include\rba_BswSrv.h	   145   * \retval  uint16
; .\Integration\BSW\Include\rba_BswSrv.h	   146   * \seealso
; .\Integration\BSW\Include\rba_BswSrv.h	   147   * \usedresources
; .\Integration\BSW\Include\rba_BswSrv.h	   148   *********************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   149   */
; .\Integration\BSW\Include\rba_BswSrv.h	   150  LOCAL_INLINE uint16 rba_BswSrv_ByteOrderSwap16(uint16 Input_u16)
; .\Integration\BSW\Include\rba_BswSrv.h	   151  {
; .\Integration\BSW\Include\rba_BswSrv.h	   152      uint16 retVal_u16;
; .\Integration\BSW\Include\rba_BswSrv.h	   153  
; .\Integration\BSW\Include\rba_BswSrv.h	   154  
; .\Integration\BSW\Include\rba_BswSrv.h	   155      retVal_u16 = ((Input_u16 & 0x00FFu) << 8) | ((Input_u16 & 0xFF00u) >> 8);
; .\Integration\BSW\Include\rba_BswSrv.h	   156  
; .\Integration\BSW\Include\rba_BswSrv.h	   157  
; .\Integration\BSW\Include\rba_BswSrv.h	   158      /* MISRA RULE 9.1 VIOLATION: variable is set by inline assembly but the checker does not understand this */
; .\Integration\BSW\Include\rba_BswSrv.h	   159      return retVal_u16;
; .\Integration\BSW\Include\rba_BswSrv.h	   160  }
; .\Integration\BSW\Include\rba_BswSrv.h	   161  
; .\Integration\BSW\Include\rba_BswSrv.h	   162  
; .\Integration\BSW\Include\rba_BswSrv.h	   163  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   164   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   165   * rba_BswSrv_MemCopy64 - copy non overlapping memory in 64 Bit blocks
; .\Integration\BSW\Include\rba_BswSrv.h	   166   *
; .\Integration\BSW\Include\rba_BswSrv.h	   167   * Memory copy routine. Source and destination must not overlap. Pointer parameters must be 8 Byte
; .\Integration\BSW\Include\rba_BswSrv.h	   168   * aligned. The size should be a multiple of 8. If not, it is rounded down to the next multiple
; .\Integration\BSW\Include\rba_BswSrv.h	   169   * of 8.
; .\Integration\BSW\Include\rba_BswSrv.h	   170   *
; .\Integration\BSW\Include\rba_BswSrv.h	   171   * \param   xDest_pu64      destination address
; .\Integration\BSW\Include\rba_BswSrv.h	   172   * \param   xSrc_pcu64      source address
; .\Integration\BSW\Include\rba_BswSrv.h	   173   * \param   numBytes_u32    number of bytes to be copied
; .\Integration\BSW\Include\rba_BswSrv.h	   174   * \seealso     rba_BswSrv_MemCopy8, rba_BswSrv_MemCopy16, rba_BswSrv_MemCopy32
; .\Integration\BSW\Include\rba_BswSrv.h	   175   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   176   */
; .\Integration\BSW\Include\rba_BswSrv.h	   177  LOCAL_INLINE void rba_BswSrv_MemCopy64(rba_BswSrv_uint64* xDest_pu64, const rba_BswSrv_uint64* xSrc_pcu64, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   178  {
; .\Integration\BSW\Include\rba_BswSrv.h	   179  
; .\Integration\BSW\Include\rba_BswSrv.h	   180      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   181  
; .\Integration\BSW\Include\rba_BswSrv.h	   182      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 8); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   183      {
; .\Integration\BSW\Include\rba_BswSrv.h	   184          *xDest_pu64 = *xSrc_pcu64;
; .\Integration\BSW\Include\rba_BswSrv.h	   185          xDest_pu64++;
; .\Integration\BSW\Include\rba_BswSrv.h	   186          xSrc_pcu64++;
; .\Integration\BSW\Include\rba_BswSrv.h	   187      }
; .\Integration\BSW\Include\rba_BswSrv.h	   188  
; .\Integration\BSW\Include\rba_BswSrv.h	   189      return;
; .\Integration\BSW\Include\rba_BswSrv.h	   190  }
; .\Integration\BSW\Include\rba_BswSrv.h	   191  
; .\Integration\BSW\Include\rba_BswSrv.h	   192  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   193   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   194   * rba_BswSrv_MemCopy32 - copy non overlapping memory in 32 Bit blocks
; .\Integration\BSW\Include\rba_BswSrv.h	   195   *
; .\Integration\BSW\Include\rba_BswSrv.h	   196   * Memory copy routine. Source and destination must not overlap. Pointer parameters must be 4 Byte
; .\Integration\BSW\Include\rba_BswSrv.h	   197   * aligned. The size should be a multiple of 4. If not, it is rounded down to the next multiple
; .\Integration\BSW\Include\rba_BswSrv.h	   198   * of 4.
; .\Integration\BSW\Include\rba_BswSrv.h	   199   *
; .\Integration\BSW\Include\rba_BswSrv.h	   200   * \param   xDest_pu32      destination address
; .\Integration\BSW\Include\rba_BswSrv.h	   201   * \param   xSrc_pcu32      source address
; .\Integration\BSW\Include\rba_BswSrv.h	   202   * \param   numBytes_u32    number of bytes to be copied
; .\Integration\BSW\Include\rba_BswSrv.h	   203   * \seealso     rba_BswSrv_MemCopy8, rba_BswSrv_MemCopy16, rba_BswSrv_MemCopy64
; .\Integration\BSW\Include\rba_BswSrv.h	   204   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   205   */
; .\Integration\BSW\Include\rba_BswSrv.h	   206  LOCAL_INLINE void rba_BswSrv_MemCopy32(uint32* xDest_pu32, const uint32* xSrc_pcu32, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   207  {
; .\Integration\BSW\Include\rba_BswSrv.h	   208      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   209  
; .\Integration\BSW\Include\rba_BswSrv.h	   210      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 4); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   211      {
; .\Integration\BSW\Include\rba_BswSrv.h	   212          *xDest_pu32 = *xSrc_pcu32;
; .\Integration\BSW\Include\rba_BswSrv.h	   213          xDest_pu32++;
; .\Integration\BSW\Include\rba_BswSrv.h	   214          xSrc_pcu32++;
; .\Integration\BSW\Include\rba_BswSrv.h	   215      }
; .\Integration\BSW\Include\rba_BswSrv.h	   216  
; .\Integration\BSW\Include\rba_BswSrv.h	   217      return;
; .\Integration\BSW\Include\rba_BswSrv.h	   218  }
; .\Integration\BSW\Include\rba_BswSrv.h	   219  
; .\Integration\BSW\Include\rba_BswSrv.h	   220  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   221   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   222   * rba_BswSrv_MemCopy16 - copy non overlapping memory in 16 Bit blocks
; .\Integration\BSW\Include\rba_BswSrv.h	   223   *
; .\Integration\BSW\Include\rba_BswSrv.h	   224   * Memory copy routine. Source and destination must not overlap. Pointer parameters must be 2 Byte
; .\Integration\BSW\Include\rba_BswSrv.h	   225   * aligned. The size should be a multiple of 2. If not, it is rounded down to the next multiple
; .\Integration\BSW\Include\rba_BswSrv.h	   226   * of 2.
; .\Integration\BSW\Include\rba_BswSrv.h	   227   *
; .\Integration\BSW\Include\rba_BswSrv.h	   228   * \param   xDest_pu16      destination address
; .\Integration\BSW\Include\rba_BswSrv.h	   229   * \param   xSrc_pcu16      source address
; .\Integration\BSW\Include\rba_BswSrv.h	   230   * \param   numBytes_u32    number of bytes to be copied
; .\Integration\BSW\Include\rba_BswSrv.h	   231   * \seealso     rba_BswSrv_MemCopy8, rba_BswSrv_MemCopy32, rba_BswSrv_MemCopy64
; .\Integration\BSW\Include\rba_BswSrv.h	   232   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   233   */
; .\Integration\BSW\Include\rba_BswSrv.h	   234  LOCAL_INLINE void rba_BswSrv_MemCopy16(uint16* xDest_pu16, const uint16* xSrc_pcu16, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   235  {
; .\Integration\BSW\Include\rba_BswSrv.h	   236      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   237  
; .\Integration\BSW\Include\rba_BswSrv.h	   238      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 2); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   239      {
; .\Integration\BSW\Include\rba_BswSrv.h	   240          *xDest_pu16 = *xSrc_pcu16;
; .\Integration\BSW\Include\rba_BswSrv.h	   241          xDest_pu16++;
; .\Integration\BSW\Include\rba_BswSrv.h	   242          xSrc_pcu16++;
; .\Integration\BSW\Include\rba_BswSrv.h	   243      }
; .\Integration\BSW\Include\rba_BswSrv.h	   244  
; .\Integration\BSW\Include\rba_BswSrv.h	   245      return;
; .\Integration\BSW\Include\rba_BswSrv.h	   246  }
; .\Integration\BSW\Include\rba_BswSrv.h	   247  
; .\Integration\BSW\Include\rba_BswSrv.h	   248  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   249   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   250   * rba_BswSrv_MemCopy8 - copy non overlapping memory
; .\Integration\BSW\Include\rba_BswSrv.h	   251   *
; .\Integration\BSW\Include\rba_BswSrv.h	   252   * Memory copy routine. Source and destination must not overlap.
; .\Integration\BSW\Include\rba_BswSrv.h	   253   *
; .\Integration\BSW\Include\rba_BswSrv.h	   254   * \param   xDest_pu8       destination address
; .\Integration\BSW\Include\rba_BswSrv.h	   255   * \param   xSrc_pcu8       source address
; .\Integration\BSW\Include\rba_BswSrv.h	   256   * \param   numBytes_u32    number of bytes to be copied
; .\Integration\BSW\Include\rba_BswSrv.h	   257   * \seealso     rba_BswSrv_MemCopy16, rba_BswSrv_MemCopy32, rba_BswSrv_MemCopy64
; .\Integration\BSW\Include\rba_BswSrv.h	   258   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   259   */
; .\Integration\BSW\Include\rba_BswSrv.h	   260  LOCAL_INLINE void rba_BswSrv_MemCopy8(uint8* xDest_pu8, const uint8* xSrc_pcu8, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   261  {
; .\Integration\BSW\Include\rba_BswSrv.h	   262      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   263  
; .\Integration\BSW\Include\rba_BswSrv.h	   264      for(ctLoop_u32 = 0; ctLoop_u32 < numBytes_u32; ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   265      {
; .\Integration\BSW\Include\rba_BswSrv.h	   266          *xDest_pu8 = *xSrc_pcu8;
; .\Integration\BSW\Include\rba_BswSrv.h	   267          xDest_pu8++;
; .\Integration\BSW\Include\rba_BswSrv.h	   268          xSrc_pcu8++;
; .\Integration\BSW\Include\rba_BswSrv.h	   269      }
; .\Integration\BSW\Include\rba_BswSrv.h	   270  
; .\Integration\BSW\Include\rba_BswSrv.h	   271      return;
; .\Integration\BSW\Include\rba_BswSrv.h	   272  }
; .\Integration\BSW\Include\rba_BswSrv.h	   273  
; .\Integration\BSW\Include\rba_BswSrv.h	   274  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   275   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   276   * rba_BswSrv_MemCompare64 - compare memory in 64 Bit blocks
; .\Integration\BSW\Include\rba_BswSrv.h	   277   *
; .\Integration\BSW\Include\rba_BswSrv.h	   278   * Memory compare routine. Pointer parameters must be 8 Byte aligned. The size should be a
; .\Integration\BSW\Include\rba_BswSrv.h	   279   * multiple of 8. If not, it is rounded down to the next multiple of 8.
; .\Integration\BSW\Include\rba_BswSrv.h	   280   *
; .\Integration\BSW\Include\rba_BswSrv.h	   281   * \param   xSrc1_pcu32     first source address
; .\Integration\BSW\Include\rba_BswSrv.h	   282   * \param   xSrc2_pcu32     second source address
; .\Integration\BSW\Include\rba_BswSrv.h	   283   * \param   numBytes_u32    number of bytes to be compared
; .\Integration\BSW\Include\rba_BswSrv.h	   284   * \return  stEqual_u32     result of comparison
; .\Integration\BSW\Include\rba_BswSrv.h	   285   * \retval  0               memory area contents are equal
; .\Integration\BSW\Include\rba_BswSrv.h	   286   * \retval  1               memory area contents differ
; .\Integration\BSW\Include\rba_BswSrv.h	   287   * \seealso     rba_BswSrv_MemCompare8, rba_BswSrv_MemCompare16, rba_BswSrv_MemCompare32
; .\Integration\BSW\Include\rba_BswSrv.h	   288   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   289   */
; .\Integration\BSW\Include\rba_BswSrv.h	   290  LOCAL_INLINE uint32 rba_BswSrv_MemCompare64(const rba_BswSrv_uint64* xSrc1_pcu64, const rba_BswSrv_uint64* xSrc2_pcu64, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   291  {
; .\Integration\BSW\Include\rba_BswSrv.h	   292  
; .\Integration\BSW\Include\rba_BswSrv.h	   293      uint32 stEqual_u32 = 0ul;
; .\Integration\BSW\Include\rba_BswSrv.h	   294      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   295  
; .\Integration\BSW\Include\rba_BswSrv.h	   296      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 8); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   297      {
; .\Integration\BSW\Include\rba_BswSrv.h	   298          /* MISRA RULE 12.13 VIOLATION: required for code optimization */
; .\Integration\BSW\Include\rba_BswSrv.h	   299          if (*xSrc1_pcu64++ != *xSrc2_pcu64++)
; .\Integration\BSW\Include\rba_BswSrv.h	   300          {
; .\Integration\BSW\Include\rba_BswSrv.h	   301              stEqual_u32 = 1ul;
; .\Integration\BSW\Include\rba_BswSrv.h	   302              break;
; .\Integration\BSW\Include\rba_BswSrv.h	   303          }
; .\Integration\BSW\Include\rba_BswSrv.h	   304      }
; .\Integration\BSW\Include\rba_BswSrv.h	   305  
; .\Integration\BSW\Include\rba_BswSrv.h	   306      return stEqual_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   307  }
; .\Integration\BSW\Include\rba_BswSrv.h	   308  
; .\Integration\BSW\Include\rba_BswSrv.h	   309  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   310   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   311   * rba_BswSrv_MemCompare32 - compare memory in 32 Bit blocks
; .\Integration\BSW\Include\rba_BswSrv.h	   312   *
; .\Integration\BSW\Include\rba_BswSrv.h	   313   * Memory compare routine. Pointer parameters must be 4 Byte aligned. The size should be a
; .\Integration\BSW\Include\rba_BswSrv.h	   314   * multiple of 4. If not, it is rounded down to the next multiple of 4.
; .\Integration\BSW\Include\rba_BswSrv.h	   315   *
; .\Integration\BSW\Include\rba_BswSrv.h	   316   * \param   xSrc1_pcu32     first source address
; .\Integration\BSW\Include\rba_BswSrv.h	   317   * \param   xSrc2_pcu32     second source address
; .\Integration\BSW\Include\rba_BswSrv.h	   318   * \param   numBytes_u32    number of bytes to be compared
; .\Integration\BSW\Include\rba_BswSrv.h	   319   * \return  stEqual_u32     result of comparison
; .\Integration\BSW\Include\rba_BswSrv.h	   320   * \retval  0               memory area contents are equal
; .\Integration\BSW\Include\rba_BswSrv.h	   321   * \retval  1               memory area contents differ
; .\Integration\BSW\Include\rba_BswSrv.h	   322   * \seealso     rba_BswSrv_MemCompare8, rba_BswSrv_MemCompare16, rba_BswSrv_MemCompare64
; .\Integration\BSW\Include\rba_BswSrv.h	   323   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   324   */
; .\Integration\BSW\Include\rba_BswSrv.h	   325  LOCAL_INLINE uint32 rba_BswSrv_MemCompare32(const uint32* xSrc1_pcu32, const uint32* xSrc2_pcu32, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   326  {
; .\Integration\BSW\Include\rba_BswSrv.h	   327  
; .\Integration\BSW\Include\rba_BswSrv.h	   328      uint32 stEqual_u32 = 0ul;
; .\Integration\BSW\Include\rba_BswSrv.h	   329      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   330  
; .\Integration\BSW\Include\rba_BswSrv.h	   331      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 4); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   332      {
; .\Integration\BSW\Include\rba_BswSrv.h	   333          /* MISRA RULE 12.13 VIOLATION: required for code optimization */
; .\Integration\BSW\Include\rba_BswSrv.h	   334          if (*xSrc1_pcu32++ != *xSrc2_pcu32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   335          {
; .\Integration\BSW\Include\rba_BswSrv.h	   336              stEqual_u32 = 1ul;
; .\Integration\BSW\Include\rba_BswSrv.h	   337              break;
; .\Integration\BSW\Include\rba_BswSrv.h	   338          }
; .\Integration\BSW\Include\rba_BswSrv.h	   339      }
; .\Integration\BSW\Include\rba_BswSrv.h	   340  
; .\Integration\BSW\Include\rba_BswSrv.h	   341      return stEqual_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   342  }
; .\Integration\BSW\Include\rba_BswSrv.h	   343  
; .\Integration\BSW\Include\rba_BswSrv.h	   344  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   345   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   346   * rba_BswSrv_MemCompare16 - compare memory in 16 Bit blocks
; .\Integration\BSW\Include\rba_BswSrv.h	   347   *
; .\Integration\BSW\Include\rba_BswSrv.h	   348   * Memory compare routine. Pointer parameters must be 2 Byte aligned. The size should be a
; .\Integration\BSW\Include\rba_BswSrv.h	   349   * multiple of 2. If not, it is rounded down to the next multiple of 2.
; .\Integration\BSW\Include\rba_BswSrv.h	   350   *
; .\Integration\BSW\Include\rba_BswSrv.h	   351   * \param   xSrc1_pcu16     first source address
; .\Integration\BSW\Include\rba_BswSrv.h	   352   * \param   xSrc2_pcu16     second source address
; .\Integration\BSW\Include\rba_BswSrv.h	   353   * \param   numBytes_u32    number of bytes to be compared
; .\Integration\BSW\Include\rba_BswSrv.h	   354   * \return  stEqual_u32     result of comparison
; .\Integration\BSW\Include\rba_BswSrv.h	   355   * \retval  0               memory area contents are equal
; .\Integration\BSW\Include\rba_BswSrv.h	   356   * \retval  1               memory area contents differ
; .\Integration\BSW\Include\rba_BswSrv.h	   357   * \seealso     rba_BswSrv_MemCompare8, rba_BswSrv_MemCompare32, rba_BswSrv_MemCompare64
; .\Integration\BSW\Include\rba_BswSrv.h	   358   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   359   */
; .\Integration\BSW\Include\rba_BswSrv.h	   360  LOCAL_INLINE uint32 rba_BswSrv_MemCompare16(const uint16* xSrc1_pcu16, const uint16* xSrc2_pcu16, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   361  {
; .\Integration\BSW\Include\rba_BswSrv.h	   362  
; .\Integration\BSW\Include\rba_BswSrv.h	   363      uint32 stEqual_u32 = 0ul;
; .\Integration\BSW\Include\rba_BswSrv.h	   364      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   365  
; .\Integration\BSW\Include\rba_BswSrv.h	   366      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 2); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   367      {
; .\Integration\BSW\Include\rba_BswSrv.h	   368          /* MISRA RULE 12.13 VIOLATION: required for code optimization */
; .\Integration\BSW\Include\rba_BswSrv.h	   369          if (*xSrc1_pcu16++ != *xSrc2_pcu16++)
; .\Integration\BSW\Include\rba_BswSrv.h	   370          {
; .\Integration\BSW\Include\rba_BswSrv.h	   371              stEqual_u32 = 1ul;
; .\Integration\BSW\Include\rba_BswSrv.h	   372              break;
; .\Integration\BSW\Include\rba_BswSrv.h	   373          }
; .\Integration\BSW\Include\rba_BswSrv.h	   374      }
; .\Integration\BSW\Include\rba_BswSrv.h	   375  
; .\Integration\BSW\Include\rba_BswSrv.h	   376      return stEqual_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   377  }
; .\Integration\BSW\Include\rba_BswSrv.h	   378  
; .\Integration\BSW\Include\rba_BswSrv.h	   379  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   380   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   381   * rba_BswSrv_MemCompare8 - compare memory
; .\Integration\BSW\Include\rba_BswSrv.h	   382   *
; .\Integration\BSW\Include\rba_BswSrv.h	   383   * Memory compare routine.
; .\Integration\BSW\Include\rba_BswSrv.h	   384   *
; .\Integration\BSW\Include\rba_BswSrv.h	   385   * \param   xSrc1_pcu8      pointer to the first source address
; .\Integration\BSW\Include\rba_BswSrv.h	   386   * \param   xSrc2_pcu8      pointer to the second source address
; .\Integration\BSW\Include\rba_BswSrv.h	   387   * \param   numBytes_u32    number of bytes to be compared
; .\Integration\BSW\Include\rba_BswSrv.h	   388   * \return  stEqual_u32     result of comparison
; .\Integration\BSW\Include\rba_BswSrv.h	   389   * \retval  0               memory area contents are equal
; .\Integration\BSW\Include\rba_BswSrv.h	   390   * \retval  1               memory area contents differ
; .\Integration\BSW\Include\rba_BswSrv.h	   391   * \seealso     rba_BswSrv_MemCompare16, rba_BswSrv_MemCompare32, rba_BswSrv_MemCompare64
; .\Integration\BSW\Include\rba_BswSrv.h	   392   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   393   */
; .\Integration\BSW\Include\rba_BswSrv.h	   394  LOCAL_INLINE uint32 rba_BswSrv_MemCompare8(const uint8* xSrc1_pcu8, const uint8* xSrc2_pcu8, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   395  {
; .\Integration\BSW\Include\rba_BswSrv.h	   396  
; .\Integration\BSW\Include\rba_BswSrv.h	   397      uint32 stEqual_u32 = 0ul;
; .\Integration\BSW\Include\rba_BswSrv.h	   398      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   399  
; .\Integration\BSW\Include\rba_BswSrv.h	   400      for(ctLoop_u32 = 0; ctLoop_u32 < numBytes_u32; ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   401      {
; .\Integration\BSW\Include\rba_BswSrv.h	   402          /* MISRA RULE 12.13 VIOLATION: required for code optimization */
; .\Integration\BSW\Include\rba_BswSrv.h	   403          if (*xSrc1_pcu8++ != *xSrc2_pcu8++)
; .\Integration\BSW\Include\rba_BswSrv.h	   404          {
; .\Integration\BSW\Include\rba_BswSrv.h	   405              stEqual_u32 = 1ul;
; .\Integration\BSW\Include\rba_BswSrv.h	   406              break;
; .\Integration\BSW\Include\rba_BswSrv.h	   407          }
; .\Integration\BSW\Include\rba_BswSrv.h	   408      }
; .\Integration\BSW\Include\rba_BswSrv.h	   409  
; .\Integration\BSW\Include\rba_BswSrv.h	   410      return stEqual_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   411  }
; .\Integration\BSW\Include\rba_BswSrv.h	   412  
; .\Integration\BSW\Include\rba_BswSrv.h	   413  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   414   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   415   * rba_BswSrv_MemSet64 - initialize memory with 64 Bit data
; .\Integration\BSW\Include\rba_BswSrv.h	   416   *
; .\Integration\BSW\Include\rba_BswSrv.h	   417   * Memory initialization routine. 64 Bit Pattern is written to the destination.
; .\Integration\BSW\Include\rba_BswSrv.h	   418   * Destination must be 4 Byte aligned. The size should be a multiple of 8. If not, it is rounded
; .\Integration\BSW\Include\rba_BswSrv.h	   419   * down to the next multiple of 8.
; .\Integration\BSW\Include\rba_BswSrv.h	   420   *
; .\Integration\BSW\Include\rba_BswSrv.h	   421   * \param   xDest_pu32      destination address
; .\Integration\BSW\Include\rba_BswSrv.h	   422   * \param   Pattern_u32     fill pattern
; .\Integration\BSW\Include\rba_BswSrv.h	   423   * \param   numBytes_u32    number of bytes to be initialized
; .\Integration\BSW\Include\rba_BswSrv.h	   424   * \seealso     rba_BswSrv_MemSet8, rba_BswSrv_MemSet16, rba_BswSrv_MemSet32
; .\Integration\BSW\Include\rba_BswSrv.h	   425   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   426   */
; .\Integration\BSW\Include\rba_BswSrv.h	   427  LOCAL_INLINE void rba_BswSrv_MemSet64(rba_BswSrv_uint64* xDest_pu64, rba_BswSrv_uint64 xPattern_u64, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   428  {
; .\Integration\BSW\Include\rba_BswSrv.h	   429  
; .\Integration\BSW\Include\rba_BswSrv.h	   430      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   431  
; .\Integration\BSW\Include\rba_BswSrv.h	   432      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 8); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   433      {
; .\Integration\BSW\Include\rba_BswSrv.h	   434          *xDest_pu64 = xPattern_u64;
; .\Integration\BSW\Include\rba_BswSrv.h	   435          xDest_pu64++;
; .\Integration\BSW\Include\rba_BswSrv.h	   436      }
; .\Integration\BSW\Include\rba_BswSrv.h	   437  
; .\Integration\BSW\Include\rba_BswSrv.h	   438      return;
; .\Integration\BSW\Include\rba_BswSrv.h	   439  }
; .\Integration\BSW\Include\rba_BswSrv.h	   440  
; .\Integration\BSW\Include\rba_BswSrv.h	   441  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   442   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   443   * rba_BswSrv_MemSet32 - initialize memory with 32 Bit data
; .\Integration\BSW\Include\rba_BswSrv.h	   444   *
; .\Integration\BSW\Include\rba_BswSrv.h	   445   * Memory initialization routine. 32 Bit Pattern is written to the destination.
; .\Integration\BSW\Include\rba_BswSrv.h	   446   * Destination must be 4 Byte aligned. The size should be a multiple of 4. If not, it is rounded
; .\Integration\BSW\Include\rba_BswSrv.h	   447   * down to the next multiple of 4.
; .\Integration\BSW\Include\rba_BswSrv.h	   448   *
; .\Integration\BSW\Include\rba_BswSrv.h	   449   * \param   xDest_pu32      destination address
; .\Integration\BSW\Include\rba_BswSrv.h	   450   * \param   Pattern_u32     fill pattern
; .\Integration\BSW\Include\rba_BswSrv.h	   451   * \param   numBytes_u32    number of bytes to be initialized
; .\Integration\BSW\Include\rba_BswSrv.h	   452   * \seealso     rba_BswSrv_MemSet8, rba_BswSrv_MemSet16, rba_BswSrv_MemSet64
; .\Integration\BSW\Include\rba_BswSrv.h	   453   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   454   */
; .\Integration\BSW\Include\rba_BswSrv.h	   455  LOCAL_INLINE void rba_BswSrv_MemSet32(uint32* xDest_pu32, uint32 xPattern_u32, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   456  {
; .\Integration\BSW\Include\rba_BswSrv.h	   457      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   458  
; .\Integration\BSW\Include\rba_BswSrv.h	   459      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 4); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   460      {
; .\Integration\BSW\Include\rba_BswSrv.h	   461          *xDest_pu32 = xPattern_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   462          xDest_pu32++;
; .\Integration\BSW\Include\rba_BswSrv.h	   463      }
; .\Integration\BSW\Include\rba_BswSrv.h	   464  
; .\Integration\BSW\Include\rba_BswSrv.h	   465      return;
; .\Integration\BSW\Include\rba_BswSrv.h	   466  }
; .\Integration\BSW\Include\rba_BswSrv.h	   467  
; .\Integration\BSW\Include\rba_BswSrv.h	   468  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   469   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   470   * rba_BswSrv_MemSet16 - initialize memory with 16 Bit data
; .\Integration\BSW\Include\rba_BswSrv.h	   471   *
; .\Integration\BSW\Include\rba_BswSrv.h	   472   * Memory initialization routine. 16 Bit Pattern is written to the destination.
; .\Integration\BSW\Include\rba_BswSrv.h	   473   * Destination must be 2 Byte aligned. The size should be a multiple of 2. If not, it is rounded
; .\Integration\BSW\Include\rba_BswSrv.h	   474   * down to the next multiple of 2.
; .\Integration\BSW\Include\rba_BswSrv.h	   475   *
; .\Integration\BSW\Include\rba_BswSrv.h	   476   * \param   xDest_pu32      destination address
; .\Integration\BSW\Include\rba_BswSrv.h	   477   * \param   Pattern_u32     fill pattern
; .\Integration\BSW\Include\rba_BswSrv.h	   478   * \param   numBytes_u32    number of bytes to be initialized
; .\Integration\BSW\Include\rba_BswSrv.h	   479   * \seealso     rba_BswSrv_MemSet8, rba_BswSrv_MemSet32, rba_BswSrv_MemSet64
; .\Integration\BSW\Include\rba_BswSrv.h	   480   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   481   */
; .\Integration\BSW\Include\rba_BswSrv.h	   482  LOCAL_INLINE void rba_BswSrv_MemSet16(uint16* xDest_pu16, uint32 xPattern_u32, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   483  {
; .\Integration\BSW\Include\rba_BswSrv.h	   484      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   485  
; .\Integration\BSW\Include\rba_BswSrv.h	   486      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 2); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   487      {
; .\Integration\BSW\Include\rba_BswSrv.h	   488          *xDest_pu16 = (uint16)xPattern_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   489          xDest_pu16++;
; .\Integration\BSW\Include\rba_BswSrv.h	   490      }
; .\Integration\BSW\Include\rba_BswSrv.h	   491  
; .\Integration\BSW\Include\rba_BswSrv.h	   492      return;
; .\Integration\BSW\Include\rba_BswSrv.h	   493  }
; .\Integration\BSW\Include\rba_BswSrv.h	   494  
; .\Integration\BSW\Include\rba_BswSrv.h	   495  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   496   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   497   * rba_BswSrv_MemSet8 - initialize memory with 8 Bit data
; .\Integration\BSW\Include\rba_BswSrv.h	   498   *
; .\Integration\BSW\Include\rba_BswSrv.h	   499   * Memory initialization routine. 8 Bit Pattern is written to the destination.
; .\Integration\BSW\Include\rba_BswSrv.h	   500   *
; .\Integration\BSW\Include\rba_BswSrv.h	   501   * \param   xDest_pu8       destination address
; .\Integration\BSW\Include\rba_BswSrv.h	   502   * \param   xPattern_u32    fill pattern, only lower 8 bit used
; .\Integration\BSW\Include\rba_BswSrv.h	   503   * \param   numBytes_u32    number of bytes to be initialized
; .\Integration\BSW\Include\rba_BswSrv.h	   504   * \seealso     rba_BswSrv_MemSet16, rba_BswSrv_MemSet32, rba_BswSrv_MemSet64
; .\Integration\BSW\Include\rba_BswSrv.h	   505   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   506   */
; .\Integration\BSW\Include\rba_BswSrv.h	   507  LOCAL_INLINE void rba_BswSrv_MemSet8(uint8* xDest_pu8, uint32 xPattern_u32, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   508  {
; .\Integration\BSW\Include\rba_BswSrv.h	   509      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   510  
; .\Integration\BSW\Include\rba_BswSrv.h	   511      for(ctLoop_u32 = 0; ctLoop_u32 < numBytes_u32; ctLoop_u32++)
	mov	d0,#0
.L194:

; .\Integration\BSW\Include\rba_BswSrv.h	   511      for(ctLoop_u32 = 0; ctLoop_u32 < numBytes_u32; ctLoop_u32++)      (inlined)
	j	.L2
.L3:

; .\Integration\BSW\Include\rba_BswSrv.h	   512      {
; .\Integration\BSW\Include\rba_BswSrv.h	   513          *xDest_pu8 = (uint8)xPattern_u32;
	st.b	[a15],d15
.L231:

; .\Integration\BSW\Include\rba_BswSrv.h	   514          xDest_pu8++;
	add.a	a15,#1
.L232:
	add	d0,#1

; .\Integration\BSW\Include\rba_BswSrv.h	   511      for(ctLoop_u32 = 0; ctLoop_u32 < numBytes_u32; ctLoop_u32++)      (inlined)
.L2:
	jlt.u	d0,#1,.L3
.L233:

; .\Integration\BSW\Include\rba_BswSrv.h	   517      return;      (inlined)
	j	.L4

; .\Integration\BSW\Include\rba_BswSrv.h	   518  }      (inlined)
.L4:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   119      rba_BswSrv_MemSet8(&Com_IpduGrpVector_DM[COM_ZERO],(uint32)COM_ZERO,(uint32)COM_NUM_ARR_IPDUGRPVECT);
	movh.a	a15,#@his(Com_IpduGrpVector_DM)
	lea	a15,[a15]@los(Com_IpduGrpVector_DM)
.L234:
	mov	d15,#0
.L72:

; .\Integration\BSW\Include\rba_BswSrv.h	     1  /*
; .\Integration\BSW\Include\rba_BswSrv.h	     2   * This is a template file. It defines integration functions necessary to complete RTA-BSW.
; .\Integration\BSW\Include\rba_BswSrv.h	     3   * The integrator must complete the templates before deploying software containing functions defined in this file.
; .\Integration\BSW\Include\rba_BswSrv.h	     4   * Once templates have been completed, the integrator should delete the #error line.
; .\Integration\BSW\Include\rba_BswSrv.h	     5   * Note: The integrator is responsible for updates made to this file.
; .\Integration\BSW\Include\rba_BswSrv.h	     6   *
; .\Integration\BSW\Include\rba_BswSrv.h	     7   * To remove the following error define the macro NOT_READY_FOR_TESTING_OR_DEPLOYMENT with a compiler option (e.g. -D NOT_READY_FOR_TESTING_OR_DEPLOYMENT)
; .\Integration\BSW\Include\rba_BswSrv.h	     8   * The removal of the error only allows the user to proceed with the building phase
; .\Integration\BSW\Include\rba_BswSrv.h	     9   */
; .\Integration\BSW\Include\rba_BswSrv.h	    10  
; .\Integration\BSW\Include\rba_BswSrv.h	    11  
; .\Integration\BSW\Include\rba_BswSrv.h	    12  
; .\Integration\BSW\Include\rba_BswSrv.h	    13  
; .\Integration\BSW\Include\rba_BswSrv.h	    14  /*
; .\Integration\BSW\Include\rba_BswSrv.h	    15   * This is a template file. It defines integration functions necessary to complete RTA-BSW.
; .\Integration\BSW\Include\rba_BswSrv.h	    16   * The integrator must complete the templates before deploying software containing functions defined in this file.
; .\Integration\BSW\Include\rba_BswSrv.h	    17   * Once templates have been completed, the integrator should delete the #error line.
; .\Integration\BSW\Include\rba_BswSrv.h	    18   * Note: The integrator is responsible for updates made to this file.
; .\Integration\BSW\Include\rba_BswSrv.h	    19   *
; .\Integration\BSW\Include\rba_BswSrv.h	    20   * To remove the following error define the macro NOT_READY_FOR_TESTING_OR_DEPLOYMENT with a compiler option (e.g. -D NOT_READY_FOR_TESTING_OR_DEPLOYMENT)
; .\Integration\BSW\Include\rba_BswSrv.h	    21   * The removal of the error only allows the user to proceed with the building phase
; .\Integration\BSW\Include\rba_BswSrv.h	    22   */
; .\Integration\BSW\Include\rba_BswSrv.h	    23  
; .\Integration\BSW\Include\rba_BswSrv.h	    24  
; .\Integration\BSW\Include\rba_BswSrv.h	    25  #ifndef RBA_BSWSRV_H
; .\Integration\BSW\Include\rba_BswSrv.h	    26  #define RBA_BSWSRV_H
; .\Integration\BSW\Include\rba_BswSrv.h	    27  
; .\Integration\BSW\Include\rba_BswSrv.h	    28  
; .\Integration\BSW\Include\rba_BswSrv.h	    29  
; .\Integration\BSW\Include\rba_BswSrv.h	    30  /*
; .\Integration\BSW\Include\rba_BswSrv.h	    31   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    32   * Includes
; .\Integration\BSW\Include\rba_BswSrv.h	    33   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    34   */
; .\Integration\BSW\Include\rba_BswSrv.h	    35  
; .\Integration\BSW\Include\rba_BswSrv.h	    36  #include "Std_Types.h"
; .\Integration\BSW\Include\rba_BswSrv.h	    37  
; .\Integration\BSW\Include\rba_BswSrv.h	    38  /*
; .\Integration\BSW\Include\rba_BswSrv.h	    39   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    40   * Defines
; .\Integration\BSW\Include\rba_BswSrv.h	    41   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    42   */
; .\Integration\BSW\Include\rba_BswSrv.h	    43  /* Vendor and module identification */
; .\Integration\BSW\Include\rba_BswSrv.h	    44  #define RBA_BSWSRV_VENDOR_ID   (6)
; .\Integration\BSW\Include\rba_BswSrv.h	    45  #define RBA_BSWSRV_MODULE_ID   (255)
; .\Integration\BSW\Include\rba_BswSrv.h	    46  #define RBA_BSWSRV_INSTANCE_ID (0)
; .\Integration\BSW\Include\rba_BswSrv.h	    47  
; .\Integration\BSW\Include\rba_BswSrv.h	    48  /* Module version information */
; .\Integration\BSW\Include\rba_BswSrv.h	    49  #define RBA_BSWSRV_SW_MAJOR_VERSION (3)
; .\Integration\BSW\Include\rba_BswSrv.h	    50  #define RBA_BSWSRV_SW_MINOR_VERSION (0)
; .\Integration\BSW\Include\rba_BswSrv.h	    51  #define RBA_BSWSRV_SW_PATCH_VERSION (0)
; .\Integration\BSW\Include\rba_BswSrv.h	    52  
; .\Integration\BSW\Include\rba_BswSrv.h	    53  
; .\Integration\BSW\Include\rba_BswSrv.h	    54  
; .\Integration\BSW\Include\rba_BswSrv.h	    55  
; .\Integration\BSW\Include\rba_BswSrv.h	    56  #  define RBA_BSWSRV_PARAM_UNUSED(param)          (void)(param)         /* iwm7abt workaround for defect CSCRM00957569 */
; .\Integration\BSW\Include\rba_BswSrv.h	    57  #  define RBA_BSWSRV_PRV_C_IMPL
; .\Integration\BSW\Include\rba_BswSrv.h	    58  
; .\Integration\BSW\Include\rba_BswSrv.h	    59  
; .\Integration\BSW\Include\rba_BswSrv.h	    60  /*
; .\Integration\BSW\Include\rba_BswSrv.h	    61   *********************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    62   * Type definition
; .\Integration\BSW\Include\rba_BswSrv.h	    63   *********************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    64   */
; .\Integration\BSW\Include\rba_BswSrv.h	    65  
; .\Integration\BSW\Include\rba_BswSrv.h	    66  typedef unsigned long long rba_BswSrv_uint64;
; .\Integration\BSW\Include\rba_BswSrv.h	    67  
; .\Integration\BSW\Include\rba_BswSrv.h	    68  
; .\Integration\BSW\Include\rba_BswSrv.h	    69  /*
; .\Integration\BSW\Include\rba_BswSrv.h	    70   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    71   * Variable declarations
; .\Integration\BSW\Include\rba_BswSrv.h	    72   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    73   */
; .\Integration\BSW\Include\rba_BswSrv.h	    74  
; .\Integration\BSW\Include\rba_BswSrv.h	    75   /*
; .\Integration\BSW\Include\rba_BswSrv.h	    76   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    77   * Prototypes
; .\Integration\BSW\Include\rba_BswSrv.h	    78   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    79   */
; .\Integration\BSW\Include\rba_BswSrv.h	    80  
; .\Integration\BSW\Include\rba_BswSrv.h	    81  #define RBA_BSWSRV_START_SEC_CODE
; .\Integration\BSW\Include\rba_BswSrv.h	    82  #include "rba_BswSrv_MemMap.h"
; .\Integration\BSW\Include\rba_BswSrv.h	    83  extern void* rba_BswSrv_MemCopy(void* xDest_pv, const void* xSrc_pcv, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    84  extern void* rba_BswSrv_MemSet(void* xDest_pv, sint32 xPattern_u32, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    85  extern sint32 rba_BswSrv_MemCompare(const void* xSrc1_pcv, const void* xSrc2_pcv, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    86  #define RBA_BSWSRV_STOP_SEC_CODE
; .\Integration\BSW\Include\rba_BswSrv.h	    87  #include "rba_BswSrv_MemMap.h"
; .\Integration\BSW\Include\rba_BswSrv.h	    88  
; .\Integration\BSW\Include\rba_BswSrv.h	    89  LOCAL_INLINE uint32 rba_BswSrv_ByteOrderSwap32(uint32 Input_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    90  LOCAL_INLINE uint16 rba_BswSrv_ByteOrderSwap16(uint16 Input_u16);
; .\Integration\BSW\Include\rba_BswSrv.h	    91  LOCAL_INLINE void   rba_BswSrv_MemCopy64(rba_BswSrv_uint64* xDest_pu64, const rba_BswSrv_uint64* xSrc_pcu64, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    92  LOCAL_INLINE void   rba_BswSrv_MemCopy32(uint32* xDest_pu32, const uint32* xSrc_pcu32, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    93  LOCAL_INLINE void   rba_BswSrv_MemCopy16(uint16* xDest_pu16, const uint16* xSrc_pcu16, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    94  LOCAL_INLINE void   rba_BswSrv_MemCopy8(uint8* xDest_pu8, const uint8* xSrc_pcu8, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    95  LOCAL_INLINE uint32 rba_BswSrv_MemCompare64(const rba_BswSrv_uint64* xSrc1_pcu64, const rba_BswSrv_uint64* xSrc2_pcu64, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    96  LOCAL_INLINE uint32 rba_BswSrv_MemCompare32(const uint32* xSrc1_pcu32, const uint32* xSrc2_pcu32, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    97  LOCAL_INLINE uint32 rba_BswSrv_MemCompare16(const uint16* xSrc1_pcu16, const uint16* xSrc2_pcu16, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    98  LOCAL_INLINE uint32 rba_BswSrv_MemCompare8(const uint8* xSrc1_pcu8, const uint8* xSrc2_pcu8, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    99  LOCAL_INLINE void   rba_BswSrv_MemSet64(rba_BswSrv_uint64* xDest_pu64, rba_BswSrv_uint64 xPattern_u64, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	   100  LOCAL_INLINE void   rba_BswSrv_MemSet32(uint32* xDest_pu32, uint32 xPattern_u32, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	   101  LOCAL_INLINE void   rba_BswSrv_MemSet16(uint16* xDest_pu16, uint32 xPattern_u32, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	   102  LOCAL_INLINE void   rba_BswSrv_MemSet8(uint8* xDest_pu8, uint32 xPattern_u32, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	   103  
; .\Integration\BSW\Include\rba_BswSrv.h	   104  /*
; .\Integration\BSW\Include\rba_BswSrv.h	   105   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   106   * Inline function definitions
; .\Integration\BSW\Include\rba_BswSrv.h	   107   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   108   */
; .\Integration\BSW\Include\rba_BswSrv.h	   109  
; .\Integration\BSW\Include\rba_BswSrv.h	   110  
; .\Integration\BSW\Include\rba_BswSrv.h	   111  
; .\Integration\BSW\Include\rba_BswSrv.h	   112  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   113   *********************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   114   * rba_BswSrv_ByteOrderSwap32
; .\Integration\BSW\Include\rba_BswSrv.h	   115   *
; .\Integration\BSW\Include\rba_BswSrv.h	   116   * Swaps the byte order of a 32 bit value for endianess conversion.
; .\Integration\BSW\Include\rba_BswSrv.h	   117   *
; .\Integration\BSW\Include\rba_BswSrv.h	   118   * \param   Input_u32: input value
; .\Integration\BSW\Include\rba_BswSrv.h	   119   * \return  value with swapped byte order
; .\Integration\BSW\Include\rba_BswSrv.h	   120   * \retval  uint32
; .\Integration\BSW\Include\rba_BswSrv.h	   121   * \seealso
; .\Integration\BSW\Include\rba_BswSrv.h	   122   * \usedresources
; .\Integration\BSW\Include\rba_BswSrv.h	   123   *********************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   124   */
; .\Integration\BSW\Include\rba_BswSrv.h	   125  LOCAL_INLINE uint32 rba_BswSrv_ByteOrderSwap32(uint32 Input_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   126  {
; .\Integration\BSW\Include\rba_BswSrv.h	   127      uint32 retVal_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   128  
; .\Integration\BSW\Include\rba_BswSrv.h	   129  
; .\Integration\BSW\Include\rba_BswSrv.h	   130      retVal_u32 = (Input_u32 << 24) | ((Input_u32 & 0xFF00u) << 8) | ((Input_u32 & 0x00FF0000u) >> 8) | (Input_u32 >> 24);
; .\Integration\BSW\Include\rba_BswSrv.h	   131  
; .\Integration\BSW\Include\rba_BswSrv.h	   132  
; .\Integration\BSW\Include\rba_BswSrv.h	   133      /* MISRA RULE 9.1 VIOLATION: variable is set by inline assembly but the checker does not understand this */
; .\Integration\BSW\Include\rba_BswSrv.h	   134      return retVal_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   135  }
; .\Integration\BSW\Include\rba_BswSrv.h	   136  
; .\Integration\BSW\Include\rba_BswSrv.h	   137  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   138   *********************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   139   * rba_BswSrv_ByteOrderSwap16
; .\Integration\BSW\Include\rba_BswSrv.h	   140   *
; .\Integration\BSW\Include\rba_BswSrv.h	   141   * Swaps the byte order of a 16 bit value for endianess conversion.
; .\Integration\BSW\Include\rba_BswSrv.h	   142   *
; .\Integration\BSW\Include\rba_BswSrv.h	   143   * \param   Input_u16: input value
; .\Integration\BSW\Include\rba_BswSrv.h	   144   * \return  value with swapped byte order
; .\Integration\BSW\Include\rba_BswSrv.h	   145   * \retval  uint16
; .\Integration\BSW\Include\rba_BswSrv.h	   146   * \seealso
; .\Integration\BSW\Include\rba_BswSrv.h	   147   * \usedresources
; .\Integration\BSW\Include\rba_BswSrv.h	   148   *********************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   149   */
; .\Integration\BSW\Include\rba_BswSrv.h	   150  LOCAL_INLINE uint16 rba_BswSrv_ByteOrderSwap16(uint16 Input_u16)
; .\Integration\BSW\Include\rba_BswSrv.h	   151  {
; .\Integration\BSW\Include\rba_BswSrv.h	   152      uint16 retVal_u16;
; .\Integration\BSW\Include\rba_BswSrv.h	   153  
; .\Integration\BSW\Include\rba_BswSrv.h	   154  
; .\Integration\BSW\Include\rba_BswSrv.h	   155      retVal_u16 = ((Input_u16 & 0x00FFu) << 8) | ((Input_u16 & 0xFF00u) >> 8);
; .\Integration\BSW\Include\rba_BswSrv.h	   156  
; .\Integration\BSW\Include\rba_BswSrv.h	   157  
; .\Integration\BSW\Include\rba_BswSrv.h	   158      /* MISRA RULE 9.1 VIOLATION: variable is set by inline assembly but the checker does not understand this */
; .\Integration\BSW\Include\rba_BswSrv.h	   159      return retVal_u16;
; .\Integration\BSW\Include\rba_BswSrv.h	   160  }
; .\Integration\BSW\Include\rba_BswSrv.h	   161  
; .\Integration\BSW\Include\rba_BswSrv.h	   162  
; .\Integration\BSW\Include\rba_BswSrv.h	   163  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   164   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   165   * rba_BswSrv_MemCopy64 - copy non overlapping memory in 64 Bit blocks
; .\Integration\BSW\Include\rba_BswSrv.h	   166   *
; .\Integration\BSW\Include\rba_BswSrv.h	   167   * Memory copy routine. Source and destination must not overlap. Pointer parameters must be 8 Byte
; .\Integration\BSW\Include\rba_BswSrv.h	   168   * aligned. The size should be a multiple of 8. If not, it is rounded down to the next multiple
; .\Integration\BSW\Include\rba_BswSrv.h	   169   * of 8.
; .\Integration\BSW\Include\rba_BswSrv.h	   170   *
; .\Integration\BSW\Include\rba_BswSrv.h	   171   * \param   xDest_pu64      destination address
; .\Integration\BSW\Include\rba_BswSrv.h	   172   * \param   xSrc_pcu64      source address
; .\Integration\BSW\Include\rba_BswSrv.h	   173   * \param   numBytes_u32    number of bytes to be copied
; .\Integration\BSW\Include\rba_BswSrv.h	   174   * \seealso     rba_BswSrv_MemCopy8, rba_BswSrv_MemCopy16, rba_BswSrv_MemCopy32
; .\Integration\BSW\Include\rba_BswSrv.h	   175   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   176   */
; .\Integration\BSW\Include\rba_BswSrv.h	   177  LOCAL_INLINE void rba_BswSrv_MemCopy64(rba_BswSrv_uint64* xDest_pu64, const rba_BswSrv_uint64* xSrc_pcu64, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   178  {
; .\Integration\BSW\Include\rba_BswSrv.h	   179  
; .\Integration\BSW\Include\rba_BswSrv.h	   180      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   181  
; .\Integration\BSW\Include\rba_BswSrv.h	   182      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 8); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   183      {
; .\Integration\BSW\Include\rba_BswSrv.h	   184          *xDest_pu64 = *xSrc_pcu64;
; .\Integration\BSW\Include\rba_BswSrv.h	   185          xDest_pu64++;
; .\Integration\BSW\Include\rba_BswSrv.h	   186          xSrc_pcu64++;
; .\Integration\BSW\Include\rba_BswSrv.h	   187      }
; .\Integration\BSW\Include\rba_BswSrv.h	   188  
; .\Integration\BSW\Include\rba_BswSrv.h	   189      return;
; .\Integration\BSW\Include\rba_BswSrv.h	   190  }
; .\Integration\BSW\Include\rba_BswSrv.h	   191  
; .\Integration\BSW\Include\rba_BswSrv.h	   192  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   193   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   194   * rba_BswSrv_MemCopy32 - copy non overlapping memory in 32 Bit blocks
; .\Integration\BSW\Include\rba_BswSrv.h	   195   *
; .\Integration\BSW\Include\rba_BswSrv.h	   196   * Memory copy routine. Source and destination must not overlap. Pointer parameters must be 4 Byte
; .\Integration\BSW\Include\rba_BswSrv.h	   197   * aligned. The size should be a multiple of 4. If not, it is rounded down to the next multiple
; .\Integration\BSW\Include\rba_BswSrv.h	   198   * of 4.
; .\Integration\BSW\Include\rba_BswSrv.h	   199   *
; .\Integration\BSW\Include\rba_BswSrv.h	   200   * \param   xDest_pu32      destination address
; .\Integration\BSW\Include\rba_BswSrv.h	   201   * \param   xSrc_pcu32      source address
; .\Integration\BSW\Include\rba_BswSrv.h	   202   * \param   numBytes_u32    number of bytes to be copied
; .\Integration\BSW\Include\rba_BswSrv.h	   203   * \seealso     rba_BswSrv_MemCopy8, rba_BswSrv_MemCopy16, rba_BswSrv_MemCopy64
; .\Integration\BSW\Include\rba_BswSrv.h	   204   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   205   */
; .\Integration\BSW\Include\rba_BswSrv.h	   206  LOCAL_INLINE void rba_BswSrv_MemCopy32(uint32* xDest_pu32, const uint32* xSrc_pcu32, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   207  {
; .\Integration\BSW\Include\rba_BswSrv.h	   208      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   209  
; .\Integration\BSW\Include\rba_BswSrv.h	   210      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 4); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   211      {
; .\Integration\BSW\Include\rba_BswSrv.h	   212          *xDest_pu32 = *xSrc_pcu32;
; .\Integration\BSW\Include\rba_BswSrv.h	   213          xDest_pu32++;
; .\Integration\BSW\Include\rba_BswSrv.h	   214          xSrc_pcu32++;
; .\Integration\BSW\Include\rba_BswSrv.h	   215      }
; .\Integration\BSW\Include\rba_BswSrv.h	   216  
; .\Integration\BSW\Include\rba_BswSrv.h	   217      return;
; .\Integration\BSW\Include\rba_BswSrv.h	   218  }
; .\Integration\BSW\Include\rba_BswSrv.h	   219  
; .\Integration\BSW\Include\rba_BswSrv.h	   220  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   221   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   222   * rba_BswSrv_MemCopy16 - copy non overlapping memory in 16 Bit blocks
; .\Integration\BSW\Include\rba_BswSrv.h	   223   *
; .\Integration\BSW\Include\rba_BswSrv.h	   224   * Memory copy routine. Source and destination must not overlap. Pointer parameters must be 2 Byte
; .\Integration\BSW\Include\rba_BswSrv.h	   225   * aligned. The size should be a multiple of 2. If not, it is rounded down to the next multiple
; .\Integration\BSW\Include\rba_BswSrv.h	   226   * of 2.
; .\Integration\BSW\Include\rba_BswSrv.h	   227   *
; .\Integration\BSW\Include\rba_BswSrv.h	   228   * \param   xDest_pu16      destination address
; .\Integration\BSW\Include\rba_BswSrv.h	   229   * \param   xSrc_pcu16      source address
; .\Integration\BSW\Include\rba_BswSrv.h	   230   * \param   numBytes_u32    number of bytes to be copied
; .\Integration\BSW\Include\rba_BswSrv.h	   231   * \seealso     rba_BswSrv_MemCopy8, rba_BswSrv_MemCopy32, rba_BswSrv_MemCopy64
; .\Integration\BSW\Include\rba_BswSrv.h	   232   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   233   */
; .\Integration\BSW\Include\rba_BswSrv.h	   234  LOCAL_INLINE void rba_BswSrv_MemCopy16(uint16* xDest_pu16, const uint16* xSrc_pcu16, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   235  {
; .\Integration\BSW\Include\rba_BswSrv.h	   236      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   237  
; .\Integration\BSW\Include\rba_BswSrv.h	   238      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 2); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   239      {
; .\Integration\BSW\Include\rba_BswSrv.h	   240          *xDest_pu16 = *xSrc_pcu16;
; .\Integration\BSW\Include\rba_BswSrv.h	   241          xDest_pu16++;
; .\Integration\BSW\Include\rba_BswSrv.h	   242          xSrc_pcu16++;
; .\Integration\BSW\Include\rba_BswSrv.h	   243      }
; .\Integration\BSW\Include\rba_BswSrv.h	   244  
; .\Integration\BSW\Include\rba_BswSrv.h	   245      return;
; .\Integration\BSW\Include\rba_BswSrv.h	   246  }
; .\Integration\BSW\Include\rba_BswSrv.h	   247  
; .\Integration\BSW\Include\rba_BswSrv.h	   248  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   249   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   250   * rba_BswSrv_MemCopy8 - copy non overlapping memory
; .\Integration\BSW\Include\rba_BswSrv.h	   251   *
; .\Integration\BSW\Include\rba_BswSrv.h	   252   * Memory copy routine. Source and destination must not overlap.
; .\Integration\BSW\Include\rba_BswSrv.h	   253   *
; .\Integration\BSW\Include\rba_BswSrv.h	   254   * \param   xDest_pu8       destination address
; .\Integration\BSW\Include\rba_BswSrv.h	   255   * \param   xSrc_pcu8       source address
; .\Integration\BSW\Include\rba_BswSrv.h	   256   * \param   numBytes_u32    number of bytes to be copied
; .\Integration\BSW\Include\rba_BswSrv.h	   257   * \seealso     rba_BswSrv_MemCopy16, rba_BswSrv_MemCopy32, rba_BswSrv_MemCopy64
; .\Integration\BSW\Include\rba_BswSrv.h	   258   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   259   */
; .\Integration\BSW\Include\rba_BswSrv.h	   260  LOCAL_INLINE void rba_BswSrv_MemCopy8(uint8* xDest_pu8, const uint8* xSrc_pcu8, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   261  {
; .\Integration\BSW\Include\rba_BswSrv.h	   262      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   263  
; .\Integration\BSW\Include\rba_BswSrv.h	   264      for(ctLoop_u32 = 0; ctLoop_u32 < numBytes_u32; ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   265      {
; .\Integration\BSW\Include\rba_BswSrv.h	   266          *xDest_pu8 = *xSrc_pcu8;
; .\Integration\BSW\Include\rba_BswSrv.h	   267          xDest_pu8++;
; .\Integration\BSW\Include\rba_BswSrv.h	   268          xSrc_pcu8++;
; .\Integration\BSW\Include\rba_BswSrv.h	   269      }
; .\Integration\BSW\Include\rba_BswSrv.h	   270  
; .\Integration\BSW\Include\rba_BswSrv.h	   271      return;
; .\Integration\BSW\Include\rba_BswSrv.h	   272  }
; .\Integration\BSW\Include\rba_BswSrv.h	   273  
; .\Integration\BSW\Include\rba_BswSrv.h	   274  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   275   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   276   * rba_BswSrv_MemCompare64 - compare memory in 64 Bit blocks
; .\Integration\BSW\Include\rba_BswSrv.h	   277   *
; .\Integration\BSW\Include\rba_BswSrv.h	   278   * Memory compare routine. Pointer parameters must be 8 Byte aligned. The size should be a
; .\Integration\BSW\Include\rba_BswSrv.h	   279   * multiple of 8. If not, it is rounded down to the next multiple of 8.
; .\Integration\BSW\Include\rba_BswSrv.h	   280   *
; .\Integration\BSW\Include\rba_BswSrv.h	   281   * \param   xSrc1_pcu32     first source address
; .\Integration\BSW\Include\rba_BswSrv.h	   282   * \param   xSrc2_pcu32     second source address
; .\Integration\BSW\Include\rba_BswSrv.h	   283   * \param   numBytes_u32    number of bytes to be compared
; .\Integration\BSW\Include\rba_BswSrv.h	   284   * \return  stEqual_u32     result of comparison
; .\Integration\BSW\Include\rba_BswSrv.h	   285   * \retval  0               memory area contents are equal
; .\Integration\BSW\Include\rba_BswSrv.h	   286   * \retval  1               memory area contents differ
; .\Integration\BSW\Include\rba_BswSrv.h	   287   * \seealso     rba_BswSrv_MemCompare8, rba_BswSrv_MemCompare16, rba_BswSrv_MemCompare32
; .\Integration\BSW\Include\rba_BswSrv.h	   288   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   289   */
; .\Integration\BSW\Include\rba_BswSrv.h	   290  LOCAL_INLINE uint32 rba_BswSrv_MemCompare64(const rba_BswSrv_uint64* xSrc1_pcu64, const rba_BswSrv_uint64* xSrc2_pcu64, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   291  {
; .\Integration\BSW\Include\rba_BswSrv.h	   292  
; .\Integration\BSW\Include\rba_BswSrv.h	   293      uint32 stEqual_u32 = 0ul;
; .\Integration\BSW\Include\rba_BswSrv.h	   294      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   295  
; .\Integration\BSW\Include\rba_BswSrv.h	   296      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 8); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   297      {
; .\Integration\BSW\Include\rba_BswSrv.h	   298          /* MISRA RULE 12.13 VIOLATION: required for code optimization */
; .\Integration\BSW\Include\rba_BswSrv.h	   299          if (*xSrc1_pcu64++ != *xSrc2_pcu64++)
; .\Integration\BSW\Include\rba_BswSrv.h	   300          {
; .\Integration\BSW\Include\rba_BswSrv.h	   301              stEqual_u32 = 1ul;
; .\Integration\BSW\Include\rba_BswSrv.h	   302              break;
; .\Integration\BSW\Include\rba_BswSrv.h	   303          }
; .\Integration\BSW\Include\rba_BswSrv.h	   304      }
; .\Integration\BSW\Include\rba_BswSrv.h	   305  
; .\Integration\BSW\Include\rba_BswSrv.h	   306      return stEqual_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   307  }
; .\Integration\BSW\Include\rba_BswSrv.h	   308  
; .\Integration\BSW\Include\rba_BswSrv.h	   309  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   310   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   311   * rba_BswSrv_MemCompare32 - compare memory in 32 Bit blocks
; .\Integration\BSW\Include\rba_BswSrv.h	   312   *
; .\Integration\BSW\Include\rba_BswSrv.h	   313   * Memory compare routine. Pointer parameters must be 4 Byte aligned. The size should be a
; .\Integration\BSW\Include\rba_BswSrv.h	   314   * multiple of 4. If not, it is rounded down to the next multiple of 4.
; .\Integration\BSW\Include\rba_BswSrv.h	   315   *
; .\Integration\BSW\Include\rba_BswSrv.h	   316   * \param   xSrc1_pcu32     first source address
; .\Integration\BSW\Include\rba_BswSrv.h	   317   * \param   xSrc2_pcu32     second source address
; .\Integration\BSW\Include\rba_BswSrv.h	   318   * \param   numBytes_u32    number of bytes to be compared
; .\Integration\BSW\Include\rba_BswSrv.h	   319   * \return  stEqual_u32     result of comparison
; .\Integration\BSW\Include\rba_BswSrv.h	   320   * \retval  0               memory area contents are equal
; .\Integration\BSW\Include\rba_BswSrv.h	   321   * \retval  1               memory area contents differ
; .\Integration\BSW\Include\rba_BswSrv.h	   322   * \seealso     rba_BswSrv_MemCompare8, rba_BswSrv_MemCompare16, rba_BswSrv_MemCompare64
; .\Integration\BSW\Include\rba_BswSrv.h	   323   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   324   */
; .\Integration\BSW\Include\rba_BswSrv.h	   325  LOCAL_INLINE uint32 rba_BswSrv_MemCompare32(const uint32* xSrc1_pcu32, const uint32* xSrc2_pcu32, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   326  {
; .\Integration\BSW\Include\rba_BswSrv.h	   327  
; .\Integration\BSW\Include\rba_BswSrv.h	   328      uint32 stEqual_u32 = 0ul;
; .\Integration\BSW\Include\rba_BswSrv.h	   329      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   330  
; .\Integration\BSW\Include\rba_BswSrv.h	   331      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 4); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   332      {
; .\Integration\BSW\Include\rba_BswSrv.h	   333          /* MISRA RULE 12.13 VIOLATION: required for code optimization */
; .\Integration\BSW\Include\rba_BswSrv.h	   334          if (*xSrc1_pcu32++ != *xSrc2_pcu32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   335          {
; .\Integration\BSW\Include\rba_BswSrv.h	   336              stEqual_u32 = 1ul;
; .\Integration\BSW\Include\rba_BswSrv.h	   337              break;
; .\Integration\BSW\Include\rba_BswSrv.h	   338          }
; .\Integration\BSW\Include\rba_BswSrv.h	   339      }
; .\Integration\BSW\Include\rba_BswSrv.h	   340  
; .\Integration\BSW\Include\rba_BswSrv.h	   341      return stEqual_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   342  }
; .\Integration\BSW\Include\rba_BswSrv.h	   343  
; .\Integration\BSW\Include\rba_BswSrv.h	   344  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   345   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   346   * rba_BswSrv_MemCompare16 - compare memory in 16 Bit blocks
; .\Integration\BSW\Include\rba_BswSrv.h	   347   *
; .\Integration\BSW\Include\rba_BswSrv.h	   348   * Memory compare routine. Pointer parameters must be 2 Byte aligned. The size should be a
; .\Integration\BSW\Include\rba_BswSrv.h	   349   * multiple of 2. If not, it is rounded down to the next multiple of 2.
; .\Integration\BSW\Include\rba_BswSrv.h	   350   *
; .\Integration\BSW\Include\rba_BswSrv.h	   351   * \param   xSrc1_pcu16     first source address
; .\Integration\BSW\Include\rba_BswSrv.h	   352   * \param   xSrc2_pcu16     second source address
; .\Integration\BSW\Include\rba_BswSrv.h	   353   * \param   numBytes_u32    number of bytes to be compared
; .\Integration\BSW\Include\rba_BswSrv.h	   354   * \return  stEqual_u32     result of comparison
; .\Integration\BSW\Include\rba_BswSrv.h	   355   * \retval  0               memory area contents are equal
; .\Integration\BSW\Include\rba_BswSrv.h	   356   * \retval  1               memory area contents differ
; .\Integration\BSW\Include\rba_BswSrv.h	   357   * \seealso     rba_BswSrv_MemCompare8, rba_BswSrv_MemCompare32, rba_BswSrv_MemCompare64
; .\Integration\BSW\Include\rba_BswSrv.h	   358   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   359   */
; .\Integration\BSW\Include\rba_BswSrv.h	   360  LOCAL_INLINE uint32 rba_BswSrv_MemCompare16(const uint16* xSrc1_pcu16, const uint16* xSrc2_pcu16, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   361  {
; .\Integration\BSW\Include\rba_BswSrv.h	   362  
; .\Integration\BSW\Include\rba_BswSrv.h	   363      uint32 stEqual_u32 = 0ul;
; .\Integration\BSW\Include\rba_BswSrv.h	   364      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   365  
; .\Integration\BSW\Include\rba_BswSrv.h	   366      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 2); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   367      {
; .\Integration\BSW\Include\rba_BswSrv.h	   368          /* MISRA RULE 12.13 VIOLATION: required for code optimization */
; .\Integration\BSW\Include\rba_BswSrv.h	   369          if (*xSrc1_pcu16++ != *xSrc2_pcu16++)
; .\Integration\BSW\Include\rba_BswSrv.h	   370          {
; .\Integration\BSW\Include\rba_BswSrv.h	   371              stEqual_u32 = 1ul;
; .\Integration\BSW\Include\rba_BswSrv.h	   372              break;
; .\Integration\BSW\Include\rba_BswSrv.h	   373          }
; .\Integration\BSW\Include\rba_BswSrv.h	   374      }
; .\Integration\BSW\Include\rba_BswSrv.h	   375  
; .\Integration\BSW\Include\rba_BswSrv.h	   376      return stEqual_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   377  }
; .\Integration\BSW\Include\rba_BswSrv.h	   378  
; .\Integration\BSW\Include\rba_BswSrv.h	   379  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   380   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   381   * rba_BswSrv_MemCompare8 - compare memory
; .\Integration\BSW\Include\rba_BswSrv.h	   382   *
; .\Integration\BSW\Include\rba_BswSrv.h	   383   * Memory compare routine.
; .\Integration\BSW\Include\rba_BswSrv.h	   384   *
; .\Integration\BSW\Include\rba_BswSrv.h	   385   * \param   xSrc1_pcu8      pointer to the first source address
; .\Integration\BSW\Include\rba_BswSrv.h	   386   * \param   xSrc2_pcu8      pointer to the second source address
; .\Integration\BSW\Include\rba_BswSrv.h	   387   * \param   numBytes_u32    number of bytes to be compared
; .\Integration\BSW\Include\rba_BswSrv.h	   388   * \return  stEqual_u32     result of comparison
; .\Integration\BSW\Include\rba_BswSrv.h	   389   * \retval  0               memory area contents are equal
; .\Integration\BSW\Include\rba_BswSrv.h	   390   * \retval  1               memory area contents differ
; .\Integration\BSW\Include\rba_BswSrv.h	   391   * \seealso     rba_BswSrv_MemCompare16, rba_BswSrv_MemCompare32, rba_BswSrv_MemCompare64
; .\Integration\BSW\Include\rba_BswSrv.h	   392   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   393   */
; .\Integration\BSW\Include\rba_BswSrv.h	   394  LOCAL_INLINE uint32 rba_BswSrv_MemCompare8(const uint8* xSrc1_pcu8, const uint8* xSrc2_pcu8, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   395  {
; .\Integration\BSW\Include\rba_BswSrv.h	   396  
; .\Integration\BSW\Include\rba_BswSrv.h	   397      uint32 stEqual_u32 = 0ul;
; .\Integration\BSW\Include\rba_BswSrv.h	   398      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   399  
; .\Integration\BSW\Include\rba_BswSrv.h	   400      for(ctLoop_u32 = 0; ctLoop_u32 < numBytes_u32; ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   401      {
; .\Integration\BSW\Include\rba_BswSrv.h	   402          /* MISRA RULE 12.13 VIOLATION: required for code optimization */
; .\Integration\BSW\Include\rba_BswSrv.h	   403          if (*xSrc1_pcu8++ != *xSrc2_pcu8++)
; .\Integration\BSW\Include\rba_BswSrv.h	   404          {
; .\Integration\BSW\Include\rba_BswSrv.h	   405              stEqual_u32 = 1ul;
; .\Integration\BSW\Include\rba_BswSrv.h	   406              break;
; .\Integration\BSW\Include\rba_BswSrv.h	   407          }
; .\Integration\BSW\Include\rba_BswSrv.h	   408      }
; .\Integration\BSW\Include\rba_BswSrv.h	   409  
; .\Integration\BSW\Include\rba_BswSrv.h	   410      return stEqual_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   411  }
; .\Integration\BSW\Include\rba_BswSrv.h	   412  
; .\Integration\BSW\Include\rba_BswSrv.h	   413  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   414   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   415   * rba_BswSrv_MemSet64 - initialize memory with 64 Bit data
; .\Integration\BSW\Include\rba_BswSrv.h	   416   *
; .\Integration\BSW\Include\rba_BswSrv.h	   417   * Memory initialization routine. 64 Bit Pattern is written to the destination.
; .\Integration\BSW\Include\rba_BswSrv.h	   418   * Destination must be 4 Byte aligned. The size should be a multiple of 8. If not, it is rounded
; .\Integration\BSW\Include\rba_BswSrv.h	   419   * down to the next multiple of 8.
; .\Integration\BSW\Include\rba_BswSrv.h	   420   *
; .\Integration\BSW\Include\rba_BswSrv.h	   421   * \param   xDest_pu32      destination address
; .\Integration\BSW\Include\rba_BswSrv.h	   422   * \param   Pattern_u32     fill pattern
; .\Integration\BSW\Include\rba_BswSrv.h	   423   * \param   numBytes_u32    number of bytes to be initialized
; .\Integration\BSW\Include\rba_BswSrv.h	   424   * \seealso     rba_BswSrv_MemSet8, rba_BswSrv_MemSet16, rba_BswSrv_MemSet32
; .\Integration\BSW\Include\rba_BswSrv.h	   425   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   426   */
; .\Integration\BSW\Include\rba_BswSrv.h	   427  LOCAL_INLINE void rba_BswSrv_MemSet64(rba_BswSrv_uint64* xDest_pu64, rba_BswSrv_uint64 xPattern_u64, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   428  {
; .\Integration\BSW\Include\rba_BswSrv.h	   429  
; .\Integration\BSW\Include\rba_BswSrv.h	   430      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   431  
; .\Integration\BSW\Include\rba_BswSrv.h	   432      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 8); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   433      {
; .\Integration\BSW\Include\rba_BswSrv.h	   434          *xDest_pu64 = xPattern_u64;
; .\Integration\BSW\Include\rba_BswSrv.h	   435          xDest_pu64++;
; .\Integration\BSW\Include\rba_BswSrv.h	   436      }
; .\Integration\BSW\Include\rba_BswSrv.h	   437  
; .\Integration\BSW\Include\rba_BswSrv.h	   438      return;
; .\Integration\BSW\Include\rba_BswSrv.h	   439  }
; .\Integration\BSW\Include\rba_BswSrv.h	   440  
; .\Integration\BSW\Include\rba_BswSrv.h	   441  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   442   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   443   * rba_BswSrv_MemSet32 - initialize memory with 32 Bit data
; .\Integration\BSW\Include\rba_BswSrv.h	   444   *
; .\Integration\BSW\Include\rba_BswSrv.h	   445   * Memory initialization routine. 32 Bit Pattern is written to the destination.
; .\Integration\BSW\Include\rba_BswSrv.h	   446   * Destination must be 4 Byte aligned. The size should be a multiple of 4. If not, it is rounded
; .\Integration\BSW\Include\rba_BswSrv.h	   447   * down to the next multiple of 4.
; .\Integration\BSW\Include\rba_BswSrv.h	   448   *
; .\Integration\BSW\Include\rba_BswSrv.h	   449   * \param   xDest_pu32      destination address
; .\Integration\BSW\Include\rba_BswSrv.h	   450   * \param   Pattern_u32     fill pattern
; .\Integration\BSW\Include\rba_BswSrv.h	   451   * \param   numBytes_u32    number of bytes to be initialized
; .\Integration\BSW\Include\rba_BswSrv.h	   452   * \seealso     rba_BswSrv_MemSet8, rba_BswSrv_MemSet16, rba_BswSrv_MemSet64
; .\Integration\BSW\Include\rba_BswSrv.h	   453   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   454   */
; .\Integration\BSW\Include\rba_BswSrv.h	   455  LOCAL_INLINE void rba_BswSrv_MemSet32(uint32* xDest_pu32, uint32 xPattern_u32, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   456  {
; .\Integration\BSW\Include\rba_BswSrv.h	   457      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   458  
; .\Integration\BSW\Include\rba_BswSrv.h	   459      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 4); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   460      {
; .\Integration\BSW\Include\rba_BswSrv.h	   461          *xDest_pu32 = xPattern_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   462          xDest_pu32++;
; .\Integration\BSW\Include\rba_BswSrv.h	   463      }
; .\Integration\BSW\Include\rba_BswSrv.h	   464  
; .\Integration\BSW\Include\rba_BswSrv.h	   465      return;
; .\Integration\BSW\Include\rba_BswSrv.h	   466  }
; .\Integration\BSW\Include\rba_BswSrv.h	   467  
; .\Integration\BSW\Include\rba_BswSrv.h	   468  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   469   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   470   * rba_BswSrv_MemSet16 - initialize memory with 16 Bit data
; .\Integration\BSW\Include\rba_BswSrv.h	   471   *
; .\Integration\BSW\Include\rba_BswSrv.h	   472   * Memory initialization routine. 16 Bit Pattern is written to the destination.
; .\Integration\BSW\Include\rba_BswSrv.h	   473   * Destination must be 2 Byte aligned. The size should be a multiple of 2. If not, it is rounded
; .\Integration\BSW\Include\rba_BswSrv.h	   474   * down to the next multiple of 2.
; .\Integration\BSW\Include\rba_BswSrv.h	   475   *
; .\Integration\BSW\Include\rba_BswSrv.h	   476   * \param   xDest_pu32      destination address
; .\Integration\BSW\Include\rba_BswSrv.h	   477   * \param   Pattern_u32     fill pattern
; .\Integration\BSW\Include\rba_BswSrv.h	   478   * \param   numBytes_u32    number of bytes to be initialized
; .\Integration\BSW\Include\rba_BswSrv.h	   479   * \seealso     rba_BswSrv_MemSet8, rba_BswSrv_MemSet32, rba_BswSrv_MemSet64
; .\Integration\BSW\Include\rba_BswSrv.h	   480   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   481   */
; .\Integration\BSW\Include\rba_BswSrv.h	   482  LOCAL_INLINE void rba_BswSrv_MemSet16(uint16* xDest_pu16, uint32 xPattern_u32, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   483  {
; .\Integration\BSW\Include\rba_BswSrv.h	   484      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   485  
; .\Integration\BSW\Include\rba_BswSrv.h	   486      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 2); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   487      {
; .\Integration\BSW\Include\rba_BswSrv.h	   488          *xDest_pu16 = (uint16)xPattern_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   489          xDest_pu16++;
; .\Integration\BSW\Include\rba_BswSrv.h	   490      }
; .\Integration\BSW\Include\rba_BswSrv.h	   491  
; .\Integration\BSW\Include\rba_BswSrv.h	   492      return;
; .\Integration\BSW\Include\rba_BswSrv.h	   493  }
; .\Integration\BSW\Include\rba_BswSrv.h	   494  
; .\Integration\BSW\Include\rba_BswSrv.h	   495  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   496   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   497   * rba_BswSrv_MemSet8 - initialize memory with 8 Bit data
; .\Integration\BSW\Include\rba_BswSrv.h	   498   *
; .\Integration\BSW\Include\rba_BswSrv.h	   499   * Memory initialization routine. 8 Bit Pattern is written to the destination.
; .\Integration\BSW\Include\rba_BswSrv.h	   500   *
; .\Integration\BSW\Include\rba_BswSrv.h	   501   * \param   xDest_pu8       destination address
; .\Integration\BSW\Include\rba_BswSrv.h	   502   * \param   xPattern_u32    fill pattern, only lower 8 bit used
; .\Integration\BSW\Include\rba_BswSrv.h	   503   * \param   numBytes_u32    number of bytes to be initialized
; .\Integration\BSW\Include\rba_BswSrv.h	   504   * \seealso     rba_BswSrv_MemSet16, rba_BswSrv_MemSet32, rba_BswSrv_MemSet64
; .\Integration\BSW\Include\rba_BswSrv.h	   505   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   506   */
; .\Integration\BSW\Include\rba_BswSrv.h	   507  LOCAL_INLINE void rba_BswSrv_MemSet8(uint8* xDest_pu8, uint32 xPattern_u32, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   508  {
; .\Integration\BSW\Include\rba_BswSrv.h	   509      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   510  
; .\Integration\BSW\Include\rba_BswSrv.h	   511      for(ctLoop_u32 = 0; ctLoop_u32 < numBytes_u32; ctLoop_u32++)
	mov	d0,#0
.L195:

; .\Integration\BSW\Include\rba_BswSrv.h	   511      for(ctLoop_u32 = 0; ctLoop_u32 < numBytes_u32; ctLoop_u32++)      (inlined)
	j	.L5
.L6:

; .\Integration\BSW\Include\rba_BswSrv.h	   512      {
; .\Integration\BSW\Include\rba_BswSrv.h	   513          *xDest_pu8 = (uint8)xPattern_u32;
	st.b	[a15],d15
.L235:

; .\Integration\BSW\Include\rba_BswSrv.h	   514          xDest_pu8++;
	add.a	a15,#1
.L236:
	add	d0,#1

; .\Integration\BSW\Include\rba_BswSrv.h	   511      for(ctLoop_u32 = 0; ctLoop_u32 < numBytes_u32; ctLoop_u32++)      (inlined)
.L5:
	jlt.u	d0,#1,.L6
.L237:

; .\Integration\BSW\Include\rba_BswSrv.h	   517      return;      (inlined)
	j	.L7

; .\Integration\BSW\Include\rba_BswSrv.h	   518  }      (inlined)
.L7:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   120  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   121  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   122  #if (COM_COMMON_TX_PERIOD == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   123      /* Reset common IPDU Tx period feature, if active */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   124      Com_ReducedPeriod_u16 = COM_ZERO;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   125  #endif /* COM_COMMON_TX_PERIOD */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   126  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   127  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   128  #ifdef COM_F_ONEEVERYN
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   129      /* Initialize RAM structure Com_OneEveryN */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   130      for (Idx_ui = COM_ZERO; Idx_ui < COM_GET_NUM_SIG_GRPSIG_WITH_ONE_EVERY_N_FILTER; Idx_ui++)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   131      {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   132          COM_GET_ONEEVERYN( Idx_ui ).Period     = COM_GET_ONEEVERYN_CONST( Idx_ui ).Period;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   133          COM_GET_ONEEVERYN( Idx_ui ).Offset     = COM_GET_ONEEVERYN_CONST( Idx_ui ).Offset;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   134          COM_GET_ONEEVERYN( Idx_ui ).Occurrence = COM_GET_ONEEVERYN_CONST( Idx_ui ).Occurrence;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   135      }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   136  #endif /* #ifdef COM_F_ONEEVERYN */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   137  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   138      /* Initialize configured Receive Signals, Signal Groups */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   139      Com_Prv_Init_Receive();
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   140      /* Initialize configured transmission Signals, Signal Groups */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   141      Com_Prv_Init_Send();
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   142  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   143      /* END: Reset all IPDU Buffer with the padding Bytes */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   144  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   145  #ifdef COM_TXIPDUCONTROL_VIA_RBA_NDS_ECUVARIANT
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   146      /* Initial value for all the TxIpdus should be set for IpduControl Via Rba_Nds_EcuVariant feature */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   147      rba_BswSrv_MemSet8(&Com_TxIpduControlVector[COM_ZERO],(uint32)0xFFu,(uint32)COM_NUM_ARR_TXIPDUCONTROLVECTOR);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   148  #endif /* #ifdef COM_TXIPDUCONTROL_VIA_RBA_NDS_ECUVARIANT */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   149  #ifdef COM_RXIPDUCONTROL_VIA_RBA_NDS_ECUVARIANT
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   150      /* Initial value for all the RxIpdus should be set for IpduControl Via Rba_Nds_EcuVariant feature */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   151      rba_BswSrv_MemSet8(&Com_RxIpduControlVector[COM_ZERO],(uint32)0xFFu,(uint32)COM_NUM_ARR_RXIPDUCONTROLVECTOR);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   152  #endif /* #ifdef COM_RXIPDUCONTROL_VIA_RBA_NDS_ECUVARIANT */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   153  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   154  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   155  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   156      /* Reset the UNINIT flag */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   157      Com_Uninit_Flag = COM_INIT;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   158  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   159  }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   160  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   161  #define COM_STOP_SEC_CODE
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   162  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   163  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   164  /**
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   165   ***************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   166   * Com_CompareVersionInfo - compare version info structures ie of type Std_VersionInfoType
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   167   *
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   168   * compare version info structures ie of type Std_VersionInfoType.
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   169   *
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   170   * \param   srcVersionInfo      pointer to first Std_VersionInfoType structure
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   171   * \param   destVersionInfo     pointer to second Std_VersionInfoType structure
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   172   * \return  stEqual_u32         result of comparison
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   173   * \retval  0                   memory area contents are equal
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   174   * \retval  1                   memory area contents differ
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   175    ***************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   176   */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   177  #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   178  #define COM_START_SEC_CODE
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   179  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   180  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_CompareVersionInfo(
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   181                    P2CONST(Std_VersionInfoType, AUTOMATIC, COM_APPL_CONST) srcVersionInfo,
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   182                    P2CONST(Std_VersionInfoType, AUTOMATIC, COM_APPL_CONST) destVersionInfo
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   183                                                             )
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   184  {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   185      VAR(boolean, AUTOMATIC)   stEqual_b;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   186      stEqual_b = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   187  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   188      if ((srcVersionInfo->vendorID == destVersionInfo->vendorID) &&
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   189          (srcVersionInfo->moduleID == destVersionInfo->moduleID) &&
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   190          (srcVersionInfo->sw_major_version == destVersionInfo->sw_major_version) &&
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   191          (srcVersionInfo->sw_minor_version == destVersionInfo->sw_minor_version) &&
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   192          (srcVersionInfo->sw_patch_version == destVersionInfo->sw_patch_version)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   193      )
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   194      {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   195          stEqual_b = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   196      }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   197      return stEqual_b;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   198  }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   199  #define COM_STOP_SEC_CODE
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   200  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   201  #endif /* #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE) */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   202  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   203  /***************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   204   Function name    : Com_Prv_Init_Receive
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   205   Syntax           : void Com_Prv_Init_Receive(void)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   206   Description      : Service to initialize all configured signals, signalGroup at the receiver side
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   207   Parameter        : None
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   208   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   209   ***************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   210  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_Init_Receive(void)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   211  {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   212  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   213      Com_RxIpduRamPtrType          RxIPduRamPtr; /* Local pointer to hold the address of Rx ipdu status structure */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   214      Com_RxIpduConstPtrType        RxIPduConstPtr; /*Local pointer to hold the address of Rx ipdu static configuration*/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   215      Com_RxSigConstPtrType         RxSigConstPtr; /*Local pointer to hold the address of Rx signal static configuration*/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   216      VAR(uint16_least, AUTOMATIC)  Idx_ui;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   217      VAR(uint16_least, AUTOMATIC)  Idx_ByteNSig_ui;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   218  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   219  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   220      Com_RxSigGrpConstPtrType      RxSigGrpConstPtr; /* Local pointer to Rx GroupSignal configuration */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   221      VAR(uint16_least, AUTOMATIC)  Idx_SigGrp_ui;    /* Signal Group Id */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   222  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   223  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   224      Com_RxSigRamPtrType                 RxSigRamPtr;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   225      VAR(Com_SigMaxType,AUTOMATIC)       RxSigVal;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   226      VAR(Com_MainFuncType,AUTOMATIC)     rxMainFuncId;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   227  #ifdef COM_RxFilters
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   228  # ifdef COM_F_MASKEDNEWDIFFERSOLD
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   229      VAR(uint8, AUTOMATIC)               ConstByteValue_u8;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   230  # endif /* #ifdef COM_F_MASKEDNEWDIFFERSOLD */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   231  #endif
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   232  #if defined( COM_RXSIG_INT64 ) || defined( COM_RXSIG_FLOAT64SUPP )
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   233      VAR(uint8, AUTOMATIC)               Type;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   234  #endif
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   235  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   236  #if defined (COM_SIGNALGATEWAY) || defined (COM_SIGNALGROUPGATEWAY)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   237      Com_RxGwQueuePtrType          l_RxGwQueuePtr_struc;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   238  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   239      l_RxGwQueuePtr_struc                        = COM_GET_RXGWQUEUE_S;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   240      l_RxGwQueuePtr_struc->Com_RxGwQueueRead_ux  = COM_ZERO;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   241      l_RxGwQueuePtr_struc->Com_RxGwQueueWrite_ux = COM_ZERO;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   242      l_RxGwQueuePtr_struc->RxGwQueuePtr          = &COM_GET_RXGWQUEUE_AUX(0);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   243  #endif /* #if defined (COM_SIGNALGATEWAY) || defined (COM_SIGNALGROUPGATEWAY) */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   244  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   245      /* Start: Reset all Rx Flags */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   246      RxIPduRamPtr   = &COM_GET_RXPDURAM_S(0);
	movh.a	a12,#@his(Com_RxIpduRam_s)
.L196:
	lea	a12,[a12]@los(Com_RxIpduRam_s)
.L238:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   247  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   248      RxIPduConstPtr = COM_GET_RX_IPDU_CONSTDATA(0);
	movh.a	a13,#@his(Com_Prv_xRxIpduCfg_acst)
.L197:
	lea	a13,[a13]@los(Com_Prv_xRxIpduCfg_acst)
.L239:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   249  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   250      for(Idx_ui = COM_ZERO; Idx_ui < COM_GET_NUM_RX_IPDU; Idx_ui++)
	mov	d8,#0
.L198:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   250      for(Idx_ui = COM_ZERO; Idx_ui < COM_GET_NUM_RX_IPDU; Idx_ui++)      (inlined)
	j	.L8
.L9:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   251      {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   252  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   253          COM_GET_IPDUCOUNTER_S(Idx_ui)  = (uint8)COM_ZERO;
	movh.a	a2,#@his(Com_IpduCounter_s)
	lea	a2,[a2]@los(Com_IpduCounter_s)
	addsc.a	a2,a2,d8,#0
.L240:
	mov	d0,#0
.L241:
	st.b	[a2],d0
.L242:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   254          COM_GET_IPDUCOUNTER_DM(Idx_ui) = (uint8)COM_ZERO;
	movh.a	a15,#@his(Com_IpduCounter_DM)
	lea	a15,[a15]@los(Com_IpduCounter_DM)
	addsc.a	a15,a15,d8,#0
.L243:
	mov	d0,#0
.L244:
	st.b	[a15],d0
.L245:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   255  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   256          /*Reset all the Rx Ipdu flags*/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   257          RxIPduRamPtr ->RxFlags      = (uint8)COM_ZERO;
	mov	d15,#0
.L246:
	st.b	[a12]4,d15
.L247:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   258          RxIPduRamPtr ->RxIPduLength = COM_ZERO;
	mov	d0,#0
.L248:
	st.h	[a12],d0
.L249:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   259  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   260          /* Here the Ipdu entry is popped out of the queue,The flag is reset to capture the changes in Com_RxIndication*/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   261          Com_SetRamValue(RXIPDU,_GWPDU_TOBEPROCESSED,RxIPduRamPtr->RxFlags,COM_FALSE);
	mov.aa	a15,a12
	add.a	a15,#4
	mov	d0,#0
.L92:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;      (inlined)
	ne	d0,d0,#0
.L199:
	j	.L11
.L10:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   439  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   440  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   441  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   442   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   443   * Bfx_PutBit_u16u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   444   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   445   * \brief Sets or clears a bit at a given position Pos_u32 in the 16-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   446   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   447   * A priori, range [0,15] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   448   * Note, neither the given position BitPn nor the given value Value not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   449   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   450   * \param   uint16*  Data   pointer to a 16-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   451   * \param   uint8    BitPn  position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   452   * \param   boolean  Value  defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   453   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   454   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   455   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   456  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   457  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   458      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   460      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   461      *Data = ((*Data & ((uint16)~(1uL << BitPn))) | ((uint16)((uint16)tmp_u8 << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   462  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   463  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   464  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   465  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   466   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   467   * Bfx_PutBit_u32u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   468   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   469   * \brief Sets or clears a bit at a given position Pos_u32 in the 32-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   470   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   471   * A priori, range [0,31] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   472   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   473   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   474   * \param   uint32*     Data        pointer to a 32-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   475   * \param   uint8       BitPn       position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   476   * \param   boolean     Value       defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   477   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   478   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   479   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   480  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   481  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   482      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   483      tmp_u8 = (Value)? 1u : 0u;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   484      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   485      *Data = ((*Data & ((uint32)~(1uL << BitPn))) | ((uint32)((uint32)tmp_u8 << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   486  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   487  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   488  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   489  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   490   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   491   * Bfx_PutBit_u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   492   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   493   * \brief Sets or clears a bit at a given position BitPn in the 8-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   494   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   495   * A priori, range [0,7] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   496   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   497   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   498   * \param  uint8*   Data    pointer to a 8-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   499   * \param  uint8    BitPn   position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   500   * \param  boolean  Value   defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   501   * \return void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   502   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   503   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   504  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   505  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   506      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;
	mov	d0,#0

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;      (inlined)
.L11:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   508      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   509      *Data = ((*Data & ((uint8)~(1uL <<BitPn))) | ((uint8)(tmp_u8 << BitPn)));
	ld.bu	d1,[a15]
.L250:
	mov	d15,#1
.L251:
	sh	d15,#3
.L252:
	xor	d15,d15,#255
.L253:
	and	d1,d15
.L254:
	sha	d0,#3
.L203:
	or	d1,d0
.L255:
	st.b	[a15],d1
.L93:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   262  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   263          /* AUTOSAR COM shall initialize all signals on receiver side with the configured init values */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   264          RxSigRamPtr     = &COM_GET_RXSIGNALFLAG(RxIPduConstPtr->RxSigId_Index);
	ld.bu	d15,[a13]16
	movh.a	a15,#@his(Com_RxSignalFlag)
	lea	a15,[a15]@los(Com_RxSignalFlag)
	addsc.a	a14,a15,d15,#0
.L204:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   265          RxSigConstPtr   = COM_GET_RXSIG_CONSTDATA(RxIPduConstPtr->RxSigId_Index);
	sha	d15,#4
	movh.a	a15,#@his(Com_Prv_xRxSigCfg_acst)
	lea	a15,[a15]@los(Com_Prv_xRxSigCfg_acst)
	addsc.a	a15,a15,d15,#0
.L205:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   266  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   267          /* Fetch the Rx-MainFunction internal Id */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   268          rxMainFuncId    = RxIPduConstPtr->MainFunctionRef;
	ld.bu	d9,[a13]17
.L206:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   269  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   270          for(Idx_ByteNSig_ui  = (uint16_least)(RxIPduConstPtr->No_Of_Sig_Ref);Idx_ByteNSig_ui != (uint16_least)COM_ZERO; Idx_ByteNSig_ui-- )
	ld.hu	d10,[a13]14
.L207:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   270          for(Idx_ByteNSig_ui  = (uint16_least)(RxIPduConstPtr->No_Of_Sig_Ref);Idx_ByteNSig_ui != (uint16_least)COM_ZERO; Idx_ByteNSig_ui-- )      (inlined)
	j	.L12
.L13:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   271          {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   272              /* Reset all the flags in the rxSigRAMFields */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   273              RxSigRamPtr->rxSigRAMFields = (uint8)COM_ZERO;
	mov	d0,#0
.L256:
	st.b	[a14],d0
.L257:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   274              /* Get the init value of the signal */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   275              /* Sign extension to be performed on Init value
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   276               * But when a signed value is assigned to a uint32 variable,it is sign extended by default */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   277              RxSigVal    = (Com_SigMaxType)RxSigConstPtr->Init_Val;
	ld.w	d4,[a15]4
.L103:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     1  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     2  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     3  #ifndef COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     4  #define COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     5  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     6  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     7   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     8   * Includes
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     9   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    10  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    11  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    12  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    13  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    17  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    18  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    19  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    20  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    21   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    22   * Type definitions
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    23   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    24  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    25  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    26  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    27  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    28   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    29   * Variables
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    30   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    31  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    32  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    33  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    34  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    35   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    36   * Extern declarations
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    37   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    38  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    39  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    40   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    41   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    42   * Inline function sets TMS data in to be accessesd via CurrentTxModePtr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    43   * after evaluating TMS mode for the IPdu
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    44   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    45  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    46  FUNC(void, COM_CODE) Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    47                                  Com_TxIpduRamPtrType                TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    48                                  Com_TxIpduConstPtrType              TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    49                                  VAR(uint16,AUTOMATIC)               TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    50                                  VAR(boolean,AUTOMATIC)              ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    51                                              );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    52  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    53  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    54   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    55   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    56   * Inline function to update Rx-GroupSignal application buffers
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    57   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    58  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    59  FUNC(void, COM_CODE) Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    60                                  Com_RxSigConstPtrType               RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    61                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    62                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    63                                               );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    64  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    65  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    66   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    67   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    68   * Inline function to update Rx-GroupSignal secondary buffers
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    69   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    70  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    71  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    72  FUNC(void, COM_CODE) Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    73                                  Com_RxGrpSigConstPtrType            RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    74                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    75                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    76                                                          );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    77  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    78  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    79  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    80   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    81   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    82   * Inline function to initialize signal intial value into the provided IPdu buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    83   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    84  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    85  FUNC(void, COM_CODE) Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    86                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    87                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    88                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    89                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    90                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    91                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    92                                                              );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    93  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    94  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    95   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    96   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    97   * Inline function to initialize Rx-signal group with initial values
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    98   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    99  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   100  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   101  FUNC(void, COM_CODE) Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   102                                  Com_RxSigGrpConstPtrType            RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   103                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   104                                                  );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   105  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   106  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   107  #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   108  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxNotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   109  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxErrNotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   110  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxTONotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   111  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallRxTONotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   112  #endif /* #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   113  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   114  /* Inline function to check for the RxIPdu and TxIpdu status*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   115  LOCAL_INLINE boolean Com_CheckRxIPduStatus(PduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   116  LOCAL_INLINE boolean Com_CheckTxIPduStatus(PduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   117  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   118  #if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   119  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   120  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Void(uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   121  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   122  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Ptr(boolean isInValidPtr, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   123  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Param_Ptr(boolean isInValidParam, boolean isInValidPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   124                                                                  uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   125  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Ptr_Only(boolean isInValidPtr, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   126  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Param_Only(boolean isInValidParam, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   127  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   128  #endif /*  #if (COM_CONFIGURATION_USE_DET == STD_ON) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   129  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   130  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   131  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   132  LOCAL_INLINE FUNC(void, COM_CODE) Com_CopyTxGroupSignalData( Com_SignalIdType    GrpSignalId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   133                                                               Com_SigMaxType      TxGrpSig_NewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   134                                                               Com_MainFuncType    TxMainFuncId );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   135  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   136  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   137  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   138   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   139   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   140   * Inline function to handle gateway and non-gateway use-case for tx-signal/signalGroup
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   141   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   142  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_ProceedToSendIpdu(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   143                                                  VAR(Com_IpduIdType, AUTOMATIC)          ComTxPduId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   144                                                  VAR(Com_SendIpduInfo, AUTOMATIC)        sendIpduFlag_u16
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   145                                                             );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   146  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   147  #ifdef COM_TxFilters
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   148  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_CheckModeChange(VAR(Com_IpduIdType, AUTOMATIC) TxIpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   149  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   150  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   151  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   152  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   153   * Inline Function Definition
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   154   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   155  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   156  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   157   Function name    : Com_SetCurrentTxModePtr [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   158   Syntax           : void Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   159                                  Com_TxIpduRamPtrType    TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   160                                  Com_TxIpduConstPtrType  TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   161                                  uint16                  TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   162                                  boolean                 ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   163                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   164   Description      : Inline function sets TMS data in to be accessesd via CurrentTxModePtr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   165                      after evaluating TMS mode for the IPdu
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   166  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   167                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   168                       * Mode                  |    Configuration details                              | Value|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   169                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   170                       * COM_MODE_VALID        |    Both the TRUE and FALSE modes are configured.      |    00|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   171                       * COM_TRUEMODE_VALID    |    Only TRUE mode is configured                       |    01|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   172                       * COM_FALSEMODE_VALID   |    Only FALSE mode is configured                      |    10|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   173                       * COM_MODE_INVALID      |    Both the TRUE and FALSE mode are not configured    |    11|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   174                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   175                      This INLINE function checks the TMS generated values against the requested mode and performs action
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   176                      |-------------|--------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   177                      |ModeRequested|Configured Mode values   |         Description                                           :      Action to be taken                |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   178                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   179                      |    0       |      0        |      0   |  FALSE mode is requested and IPdu TMS is COM_MODE_VALID         : Increment to the false mode data     |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   180                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   181                      |    0       |      0        |      1   |  FALSE mode is requested and IPdu TMS is COM_TRUEMODE_VALID     : Point to NONE mode data              |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   182                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   183                      |    0       |      1        |      0   |  FALSE mode is requested and IPdu TMS is COM_FALSEMODE_VALID     : Do nothing                          |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   184                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   185                      |    0       |      1        |      1   |  FALSE mode is requested and IPdu TMS is COM_MODE_INVALID     : Do nothing                             |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   186                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   187                      |    1       |      0        |      0   |  TRUE mode is requested and IPdu TMS is COM_MODE_VALID         : Do nothing                            |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   188                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   189                      |    1       |      0        |      1   |  TRUE mode is requested and IPdu TMS is COM_TRUEMODE_VALID     : Do nothing                            |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   190                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   191                      |    1       |      1        |      0   |  TRUE mode is requested and IPdu TMS is COM_FALSEMODE_VALID     : Point to NONE mode data              |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   192                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   193                      |    1       |      1        |      1   |  TRUE mode is requested and IPdu TMS is COM_MODE_INVALID         : Do nothing                          |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   194                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   195  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   196                      where 0 in column 1 stands for FALSE mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   197                      and   1 in column 1 stands for TRUE mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   198  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   199   Parameter        : TxIpduRamPtr    - pointer to Txipdu ram data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   200                    : TxIPduConstPtr  - pointer to Txipdu Rom data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   201                    : TMSStatus       - pointer to transmission mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   202                    : ModeRequested   - mode requested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   203   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   204   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   205  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   206  FUNC(void, COM_CODE) Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   207                                  Com_TxIpduRamPtrType                TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   208                                  Com_TxIpduConstPtrType              TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   209                                  VAR(uint16,AUTOMATIC)               TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   210                                  VAR(boolean,AUTOMATIC)              ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   211                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   212  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   213      /* Get the latest TM pointer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   214      TxIpduRamPtr->CurrentTxModePtr = TxIPduConstPtr->Com_TMConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   215  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   216      if(ModeRequested == COM_FALSE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   217      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   218          if((TMSStatus) == COM_TRUEMODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   219          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   220              /*If yes,load NONE mode data */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   221              TxIpduRamPtr->CurrentTxModePtr = &Com_NONE_TransModeInfo ;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   222          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   223          if((TMSStatus) == COM_MODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   224          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   225              /*Increment to FALSE mode data, if the FALSE mode is configured */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   226              TxIpduRamPtr->CurrentTxModePtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   227          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   228      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   229      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   230      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   231          if((TMSStatus) == COM_FALSEMODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   232          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   233              TxIpduRamPtr->CurrentTxModePtr = &Com_NONE_TransModeInfo ;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   234          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   235      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   236  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   237  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   238  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   239   Function name    : Com_UpdateRxGroupSignalSecondBuffer [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   240   Syntax           : void Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   241                                  Com_RxGrpSigConstPtrType    RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   242                                  Com_SigMaxType              RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   243                                  Com_MainFuncType            RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   244                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   245   Description      : Inline function copy Group signal value into the Group signal Second buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   246   Parameter        : RxGrpSigConstPtr - pointer to RxGroupSignal configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   247                    : RxNewVal         - latest RxGroupSignal data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   248                    : RxMainFuncId     - Internally generated Rx-MainFunction-Id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   249   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   250   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   251  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   252  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   253  FUNC(void, COM_CODE) Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   254                                  Com_RxGrpSigConstPtrType            RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   255                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   256                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   257                                                          )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   258  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   259      VAR(uint8,AUTOMATIC)    Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   260  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   261      Type = Com_GetValue(RXGRPSIG,_TYPE,RxGrpSigConstPtr->rxGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   262  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   263      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   264      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   265      case 0x00u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   266          /* UINT08 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   267          COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint8)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   268          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   269  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   270      case 0x01u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   271          /* UINT16 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   272          COM_GET_SECRXGRPSIGTYPEU16_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint16)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   273          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   274  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   275      case 0x02u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   276          /* UINT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   277          /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   278      case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   279          /* FLOAT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   280          /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   281          COM_GET_SECRXGRPSIGTYPEU32_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint32)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   282          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   283  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   284  #ifdef COM_RXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   285      case 0x08u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   286          /* UINT64/SINT64 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   287          COM_GET_SECRXGRPSIGTYPEU64_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   288          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   289  #endif /* #ifdef COM_RXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   290  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   291      case 0x03u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   292          /*Boolean Signal*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   293          COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint8)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   294          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   295  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   296      case 0x04u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   297          /* UINT8_N signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   298          Com_ByteCopyInit(&COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index),
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   299                           (uint32)RxNewVal,RxGrpSigConstPtr->BitSize);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   300          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   301      default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   302          /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   303           * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are allowed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   304           * to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   305           */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   306          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   307  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   308      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   309  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   310  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   311  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   312  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   313   Function name    : Com_UpdateRxSignalBuffer [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   314   Syntax           : void Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   315                                  Com_RxSigConstPtrType   RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   316                                  Com_SigMaxType          RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   317                                  Com_MainFuncType        RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   318                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   319   Description      : Inline function to copy signal value into the signal buffer and
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   320                      is used when signal value as a variable is being passed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   321   Parameter        : RxSigConstPtr - pointer to RxSignal configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   322                    : RxNewVal_Sig  - latest RxSignal data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   323                    : RxMainFuncId  - Internally generated Rx-MainFunction-Id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   324   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   325   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   326  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   327  FUNC(void, COM_CODE) Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   328                                  Com_RxSigConstPtrType               RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   329                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   330                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   331                                               )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   332  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   333      VAR(uint8,AUTOMATIC)    Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   334  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   335      Type = Com_GetValue(GEN,_TYPE,RxSigConstPtr->General);
	ld.bu	d15,[a15]12
	mov	d1,#5
.L113:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
	sha	d0,d15,#0
.L258:
	mov	d15,#255
.L259:
	rsub	d1,d1,#8
.L260:
	rsub	d1,#0
	sh	d15,d15,d1
.L261:
	and	d0,d15
.L262:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));      (inlined)
	j	.L14

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }      (inlined)
.L14:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   336  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   337      switch(Type >> 1u)
	sha	d0,#-1
.L263:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   338      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   339      case 0x00u:     /* COM_UINT8 & COM_SINT8 */
	mov	d15,#0
	jeq	d15,d0,.L15
.L264:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   340      case (COM_BOOLEAN >> 1):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   341          COM_GET_SIGTYPEUINT8_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint8)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   342          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   343  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   344      case 0x01u:     /* COM_UINT16 & COM_SINT16 */
	mov	d15,#1
	jeq	d15,d0,.L16
.L265:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   345          COM_GET_SIGTYPEUINT16_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint16)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   346          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   347  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   348      case 0x02u:     /* COM_UINT32 & COM_SINT32 */
	mov	d15,#2
	jeq	d15,d0,.L17
.L266:
	mov	d15,#3
	jeq	d15,d0,.L18
.L267:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   349  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   350          /* COM_FLOAT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   351  #ifdef COM_FLOAT32SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   352      case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   353  #endif /* #ifdef COM_FLOAT32SUPP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   354  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   355          COM_GET_SIGTYPEUINT32_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint32)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   356          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   357  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   358  #ifdef COM_RXSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   359      case 0x08u:     /* COM_UINT64 & COM_SINT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   360          COM_GET_SIGTYPEUINT64_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   361          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   362  #endif /* #if defined(COM_RXSIG_INT64) && defined(COM_TXSIG_INT64) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   363  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   364      case 0x04u:     /* COM_UINT8_N */
	mov	d15,#4
	jeq	d15,d0,.L19
	j	.L20

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   339      case 0x00u:     /* COM_UINT8 & COM_SINT8 */      (inlined)
.L15:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   340      case (COM_BOOLEAN >> 1):      (inlined)
.L18:
	mul	d15,d9,#12
	movh.a	a2,#@his(Com_Prv_xRxRamBuf_acst)
	lea	a2,[a2]@los(Com_Prv_xRxRamBuf_acst)
	addsc.a	a2,a2,d15,#0
	ld.a	a2,[a2]
	ld.bu	d15,[a15]9
	addsc.a	a2,a2,d15,#0
.L268:
	st.b	[a2],d4
.L269:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   342          break;      (inlined)
	j	.L21

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   344      case 0x01u:     /* COM_UINT16 & COM_SINT16 */      (inlined)
.L16:
	mul	d15,d9,#12
	movh.a	a2,#@his(Com_Prv_xRxRamBuf_acst)
	lea	a2,[a2]@los(Com_Prv_xRxRamBuf_acst)
	addsc.a	a2,a2,d15,#0
	ld.a	a2,[a2]4
	ld.bu	d15,[a15]9
	addsc.a	a2,a2,d15,#1
.L270:
	st.h	[a2],d4
.L271:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   346          break;      (inlined)
	j	.L22

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   348      case 0x02u:     /* COM_UINT32 & COM_SINT32 */      (inlined)
.L17:
	mul	d15,d9,#12
	movh.a	a2,#@his(Com_Prv_xRxRamBuf_acst)
	lea	a2,[a2]@los(Com_Prv_xRxRamBuf_acst)
	addsc.a	a2,a2,d15,#0
	ld.a	a2,[a2]8
	ld.bu	d15,[a15]9
	addsc.a	a2,a2,d15,#2
.L272:
	st.w	[a2],d4
.L273:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   356          break;      (inlined)
	j	.L23

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   364      case 0x04u:     /* COM_UINT8_N */      (inlined)
.L19:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   365          Com_ByteCopyInit(&COM_GET_SIGTYPEUINT8_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index),
	mul	d15,d9,#12
	movh.a	a2,#@his(Com_Prv_xRxRamBuf_acst)
	lea	a2,[a2]@los(Com_Prv_xRxRamBuf_acst)
	addsc.a	a2,a2,d15,#0
	ld.a	a2,[a2]
	ld.bu	d15,[a15]9
	addsc.a	a4,a2,d15,#0
.L274:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   366                           (uint32)RxNewVal_Sig,RxSigConstPtr->BitSize);
	ld.bu	d5,[a15]10
	call	Com_ByteCopyInit
.L208:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   367          break;      (inlined)
	j	.L24

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   368      default:      (inlined)
.L20:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   373          break;      (inlined)
	j	.L25

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   375  }      (inlined)
.L25:
.L24:
.L23:
.L22:
.L21:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   278  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   279  #if defined( COM_RXSIG_INT64 ) || defined( COM_RXSIG_FLOAT64SUPP )
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   280              /* Get the signal type */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   281              Type        = Com_GetValue(GEN,_TYPE,RxSigConstPtr->General);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   282  #endif /* #if defined( COM_RXSIG_INT64 ) || defined( COM_RXSIG_FLOAT64SUPP ) */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   283  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   284  #ifdef COM_RXSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   285              /* [SWS_Com_00723] The AUTOSAR COM module shall extend the init value (ComSignalInitValue) of a signal
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   286               * to the size of its ComSignalType.
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   287               * Init_Val by default will be sign extended only for 32bits. Currently for COM_SINT64 signal types,
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   288               * if the signal is of Negative, it is required to perform the sign extension till 64bits explicitly. */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   289              if ( Type == COM_SINT64 )
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   290              {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   291                  RxSigVal = (Com_SigMaxType)((sint64)((sint32)RxSigVal));
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   292              }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   293              else
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   294              {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   295                  /* do nothing for other signal types */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   296              }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   297  #endif /* #ifdef COM_RXSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   298  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   299      /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   300  #ifdef COM_RXSIG_FLOAT64SUPP
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   301  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   302              if(Type == COM_FLOAT64)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   303              {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   304                  /* For float64 signals, RxSigConstPtr->Init_Val holds index to float array holding init values.*/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   305                  COM_GET_SIGTYPEFLOAT64_BUFF(rxMainFuncId,RxSigConstPtr->SigBuff_Index) =
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   306                                                           Com_getfloat64InitValue(RxSigVal);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   307              }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   308              else
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   309  #endif /* #ifdef COM_RXSIG_FLOAT64SUPP */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   310      /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   311              {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   312                  Com_UpdateRxSignalBuffer(RxSigConstPtr, RxSigVal, rxMainFuncId);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   313              }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   314  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   315  #ifdef COM_RxFilters
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   316  # ifdef COM_F_MASKEDNEWDIFFERSOLD
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   317  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   318              ConstByteValue_u8 = RxSigConstPtr->rxSignalFields;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   319              /* Check the filter algorithm */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   320              if(Com_GetValue(RXSIG,_FILTRALG,ConstByteValue_u8) == (uint8)COM_MASKED_NEW_DIFFERS_MASKED_OLD)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   321              {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   322                  /* Load the new received value as old value */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   323                  COM_GET_F_OLDVALUE(RxSigConstPtr->Filter_Index) = (uint32)RxSigVal;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   324              }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   325  # endif /* #ifdef COM_F_MASKEDNEWDIFFERSOLD */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   326  #endif /* #ifdef COM_RxFilters */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   327              RxSigRamPtr++;
	add.a	a14,#1
.L275:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   328              RxSigConstPtr++;
	lea	a15,[a15]16
.L276:
	add	d10,#-1

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   270          for(Idx_ByteNSig_ui  = (uint16_least)(RxIPduConstPtr->No_Of_Sig_Ref);Idx_ByteNSig_ui != (uint16_least)COM_ZERO; Idx_ByteNSig_ui-- )      (inlined)
.L12:
	jne	d10,#0,.L13
.L277:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   329          }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   330  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   331  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   332          {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   333  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   334              Com_RxSigGrpRamPtrType RxSigGrpRamPtr;    /* Local RAM pointer to SignalGroup RAM structure */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   335              RxSigGrpRamPtr = &COM_GET_RXSIGGRPFLAG(RxIPduConstPtr->FirstRxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   336  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   337              /* AUTOSAR COM shall initialize all Rx-SignalGroup Array(if any) and Secondary GroupSignal Buffers
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   338               * on receiver side with the configured init values */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   339  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   340              RxSigGrpConstPtr = COM_GET_RXSIGGRP_CONSTDATA( RxIPduConstPtr->FirstRxSigGrp_Index );
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   341  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   342              for (Idx_SigGrp_ui  = (uint16_least)RxIPduConstPtr->No_Of_SigGrp_Ref;Idx_SigGrp_ui != (uint16_least)COM_ZERO;Idx_SigGrp_ui-- )
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   343              {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   344                  Com_Prv_SigGrpReplaceToInit( RxSigGrpConstPtr, rxMainFuncId );
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   345                  /* Reset all the flags in the rxSigGrpRAMFields */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   346                  RxSigGrpRamPtr->rxSigGrpRAMFields = (uint8)COM_ZERO;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   347  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   348                  RxSigGrpRamPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   349                  RxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   350              }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   351          }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   352  #endif  /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   353  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   354          /* As per this requirement there is no need of updating the Rx Shadowbuffer */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   355          RxIPduRamPtr++;
	add.a	a12,#6
.L278:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   356          RxIPduConstPtr++;
	lea	a13,[a13]20
.L279:
	add	d8,#1

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   250      for(Idx_ui = COM_ZERO; Idx_ui < COM_GET_NUM_RX_IPDU; Idx_ui++)      (inlined)
.L8:
	jlt.u	d8,#5,.L9
.L75:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   357      }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   358      /* End: Reset all Rx Falgs */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   359  }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   360  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   361  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   362  /***************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   363   Function name    : Com_Prv_Init_Send
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   364   Syntax           : void Com_Prv_Init_Send(void)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   365   Description      : Service to initialize all configured signals, signalGroup at the sender side
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   366   Parameter        : None
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   367   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   368   ***************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   369  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_Init_Send(void)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   370  {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   371  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   372      Com_TxIpduRamPtrType           TxIpduRamPtr;   /* Local ptr to hold the address of Tx ipdu status structure */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   373      Com_TxIpduConstPtrType         TxIPduConstPtr; /* Local ptr to hold the address of Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   374      VAR(uint16, AUTOMATIC)         Idx_ui;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   375  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   376      /* START: Reset all IPDU Buffer with the padding Bytes */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   377      /*Update the bytes with Initial Value*/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   378      TxIpduRamPtr   = &COM_GET_TXPDURAM_S(0);
	movh.a	a12,#@his(Com_TxIpduRam_s)
.L202:
	lea	a12,[a12]@los(Com_TxIpduRam_s)
.L280:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   379  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   380      TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(0);
	movh.a	a13,#@his(Com_Prv_xTxIpduCfg_acst)
.L201:
	lea	a13,[a13]@los(Com_Prv_xTxIpduCfg_acst)
	st.a	[a10],a13
.L281:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   381  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   382      for(Idx_ui = COM_ZERO; Idx_ui < COM_GET_NUM_TX_IPDU; Idx_ui++)
	mov	d8,#0
.L200:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   382      for(Idx_ui = COM_ZERO; Idx_ui < COM_GET_NUM_TX_IPDU; Idx_ui++)      (inlined)
	j	.L26
.L27:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   383      {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   384          /*Reset all the Tx Flags*/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   385          TxIpduRamPtr ->Com_TxFlags      = (uint16)COM_ZERO;
	mov	d15,#0
.L282:
	st.h	[a12]12,d15
.L283:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   386  #ifdef COM_TX_DYNAMIC_SIGNAL_SUPPORT
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   387          TxIpduRamPtr->Com_DynLength     = COM_ZERO;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   388  #endif /* #ifdef COM_TX_DYNAMIC_SIGNAL_SUPPORT */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   389          TxIpduRamPtr->CurrentTxModePtr  = TxIPduConstPtr->Com_TMConstPtr;
	ld.a	a2,[a13]4
.L284:
	st.a	[a12],a2
.L285:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   390  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   391          /*Update the IPDU buffer with Padding Bytes/Unused Area default*/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   392          rba_BswSrv_MemSet8((TxIPduConstPtr->BuffPtr),(uint32)TxIPduConstPtr->PaddingByte, (uint32)TxIPduConstPtr->Size);
	ld.a	a2,[a13]
.L286:
	ld.bu	d0,[a13]23
.L287:
	ld.hu	d1,[a13]8
.L130:

; .\Integration\BSW\Include\rba_BswSrv.h	     1  /*
; .\Integration\BSW\Include\rba_BswSrv.h	     2   * This is a template file. It defines integration functions necessary to complete RTA-BSW.
; .\Integration\BSW\Include\rba_BswSrv.h	     3   * The integrator must complete the templates before deploying software containing functions defined in this file.
; .\Integration\BSW\Include\rba_BswSrv.h	     4   * Once templates have been completed, the integrator should delete the #error line.
; .\Integration\BSW\Include\rba_BswSrv.h	     5   * Note: The integrator is responsible for updates made to this file.
; .\Integration\BSW\Include\rba_BswSrv.h	     6   *
; .\Integration\BSW\Include\rba_BswSrv.h	     7   * To remove the following error define the macro NOT_READY_FOR_TESTING_OR_DEPLOYMENT with a compiler option (e.g. -D NOT_READY_FOR_TESTING_OR_DEPLOYMENT)
; .\Integration\BSW\Include\rba_BswSrv.h	     8   * The removal of the error only allows the user to proceed with the building phase
; .\Integration\BSW\Include\rba_BswSrv.h	     9   */
; .\Integration\BSW\Include\rba_BswSrv.h	    10  
; .\Integration\BSW\Include\rba_BswSrv.h	    11  
; .\Integration\BSW\Include\rba_BswSrv.h	    12  
; .\Integration\BSW\Include\rba_BswSrv.h	    13  
; .\Integration\BSW\Include\rba_BswSrv.h	    14  /*
; .\Integration\BSW\Include\rba_BswSrv.h	    15   * This is a template file. It defines integration functions necessary to complete RTA-BSW.
; .\Integration\BSW\Include\rba_BswSrv.h	    16   * The integrator must complete the templates before deploying software containing functions defined in this file.
; .\Integration\BSW\Include\rba_BswSrv.h	    17   * Once templates have been completed, the integrator should delete the #error line.
; .\Integration\BSW\Include\rba_BswSrv.h	    18   * Note: The integrator is responsible for updates made to this file.
; .\Integration\BSW\Include\rba_BswSrv.h	    19   *
; .\Integration\BSW\Include\rba_BswSrv.h	    20   * To remove the following error define the macro NOT_READY_FOR_TESTING_OR_DEPLOYMENT with a compiler option (e.g. -D NOT_READY_FOR_TESTING_OR_DEPLOYMENT)
; .\Integration\BSW\Include\rba_BswSrv.h	    21   * The removal of the error only allows the user to proceed with the building phase
; .\Integration\BSW\Include\rba_BswSrv.h	    22   */
; .\Integration\BSW\Include\rba_BswSrv.h	    23  
; .\Integration\BSW\Include\rba_BswSrv.h	    24  
; .\Integration\BSW\Include\rba_BswSrv.h	    25  #ifndef RBA_BSWSRV_H
; .\Integration\BSW\Include\rba_BswSrv.h	    26  #define RBA_BSWSRV_H
; .\Integration\BSW\Include\rba_BswSrv.h	    27  
; .\Integration\BSW\Include\rba_BswSrv.h	    28  
; .\Integration\BSW\Include\rba_BswSrv.h	    29  
; .\Integration\BSW\Include\rba_BswSrv.h	    30  /*
; .\Integration\BSW\Include\rba_BswSrv.h	    31   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    32   * Includes
; .\Integration\BSW\Include\rba_BswSrv.h	    33   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    34   */
; .\Integration\BSW\Include\rba_BswSrv.h	    35  
; .\Integration\BSW\Include\rba_BswSrv.h	    36  #include "Std_Types.h"
; .\Integration\BSW\Include\rba_BswSrv.h	    37  
; .\Integration\BSW\Include\rba_BswSrv.h	    38  /*
; .\Integration\BSW\Include\rba_BswSrv.h	    39   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    40   * Defines
; .\Integration\BSW\Include\rba_BswSrv.h	    41   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    42   */
; .\Integration\BSW\Include\rba_BswSrv.h	    43  /* Vendor and module identification */
; .\Integration\BSW\Include\rba_BswSrv.h	    44  #define RBA_BSWSRV_VENDOR_ID   (6)
; .\Integration\BSW\Include\rba_BswSrv.h	    45  #define RBA_BSWSRV_MODULE_ID   (255)
; .\Integration\BSW\Include\rba_BswSrv.h	    46  #define RBA_BSWSRV_INSTANCE_ID (0)
; .\Integration\BSW\Include\rba_BswSrv.h	    47  
; .\Integration\BSW\Include\rba_BswSrv.h	    48  /* Module version information */
; .\Integration\BSW\Include\rba_BswSrv.h	    49  #define RBA_BSWSRV_SW_MAJOR_VERSION (3)
; .\Integration\BSW\Include\rba_BswSrv.h	    50  #define RBA_BSWSRV_SW_MINOR_VERSION (0)
; .\Integration\BSW\Include\rba_BswSrv.h	    51  #define RBA_BSWSRV_SW_PATCH_VERSION (0)
; .\Integration\BSW\Include\rba_BswSrv.h	    52  
; .\Integration\BSW\Include\rba_BswSrv.h	    53  
; .\Integration\BSW\Include\rba_BswSrv.h	    54  
; .\Integration\BSW\Include\rba_BswSrv.h	    55  
; .\Integration\BSW\Include\rba_BswSrv.h	    56  #  define RBA_BSWSRV_PARAM_UNUSED(param)          (void)(param)         /* iwm7abt workaround for defect CSCRM00957569 */
; .\Integration\BSW\Include\rba_BswSrv.h	    57  #  define RBA_BSWSRV_PRV_C_IMPL
; .\Integration\BSW\Include\rba_BswSrv.h	    58  
; .\Integration\BSW\Include\rba_BswSrv.h	    59  
; .\Integration\BSW\Include\rba_BswSrv.h	    60  /*
; .\Integration\BSW\Include\rba_BswSrv.h	    61   *********************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    62   * Type definition
; .\Integration\BSW\Include\rba_BswSrv.h	    63   *********************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    64   */
; .\Integration\BSW\Include\rba_BswSrv.h	    65  
; .\Integration\BSW\Include\rba_BswSrv.h	    66  typedef unsigned long long rba_BswSrv_uint64;
; .\Integration\BSW\Include\rba_BswSrv.h	    67  
; .\Integration\BSW\Include\rba_BswSrv.h	    68  
; .\Integration\BSW\Include\rba_BswSrv.h	    69  /*
; .\Integration\BSW\Include\rba_BswSrv.h	    70   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    71   * Variable declarations
; .\Integration\BSW\Include\rba_BswSrv.h	    72   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    73   */
; .\Integration\BSW\Include\rba_BswSrv.h	    74  
; .\Integration\BSW\Include\rba_BswSrv.h	    75   /*
; .\Integration\BSW\Include\rba_BswSrv.h	    76   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    77   * Prototypes
; .\Integration\BSW\Include\rba_BswSrv.h	    78   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	    79   */
; .\Integration\BSW\Include\rba_BswSrv.h	    80  
; .\Integration\BSW\Include\rba_BswSrv.h	    81  #define RBA_BSWSRV_START_SEC_CODE
; .\Integration\BSW\Include\rba_BswSrv.h	    82  #include "rba_BswSrv_MemMap.h"
; .\Integration\BSW\Include\rba_BswSrv.h	    83  extern void* rba_BswSrv_MemCopy(void* xDest_pv, const void* xSrc_pcv, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    84  extern void* rba_BswSrv_MemSet(void* xDest_pv, sint32 xPattern_u32, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    85  extern sint32 rba_BswSrv_MemCompare(const void* xSrc1_pcv, const void* xSrc2_pcv, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    86  #define RBA_BSWSRV_STOP_SEC_CODE
; .\Integration\BSW\Include\rba_BswSrv.h	    87  #include "rba_BswSrv_MemMap.h"
; .\Integration\BSW\Include\rba_BswSrv.h	    88  
; .\Integration\BSW\Include\rba_BswSrv.h	    89  LOCAL_INLINE uint32 rba_BswSrv_ByteOrderSwap32(uint32 Input_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    90  LOCAL_INLINE uint16 rba_BswSrv_ByteOrderSwap16(uint16 Input_u16);
; .\Integration\BSW\Include\rba_BswSrv.h	    91  LOCAL_INLINE void   rba_BswSrv_MemCopy64(rba_BswSrv_uint64* xDest_pu64, const rba_BswSrv_uint64* xSrc_pcu64, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    92  LOCAL_INLINE void   rba_BswSrv_MemCopy32(uint32* xDest_pu32, const uint32* xSrc_pcu32, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    93  LOCAL_INLINE void   rba_BswSrv_MemCopy16(uint16* xDest_pu16, const uint16* xSrc_pcu16, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    94  LOCAL_INLINE void   rba_BswSrv_MemCopy8(uint8* xDest_pu8, const uint8* xSrc_pcu8, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    95  LOCAL_INLINE uint32 rba_BswSrv_MemCompare64(const rba_BswSrv_uint64* xSrc1_pcu64, const rba_BswSrv_uint64* xSrc2_pcu64, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    96  LOCAL_INLINE uint32 rba_BswSrv_MemCompare32(const uint32* xSrc1_pcu32, const uint32* xSrc2_pcu32, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    97  LOCAL_INLINE uint32 rba_BswSrv_MemCompare16(const uint16* xSrc1_pcu16, const uint16* xSrc2_pcu16, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    98  LOCAL_INLINE uint32 rba_BswSrv_MemCompare8(const uint8* xSrc1_pcu8, const uint8* xSrc2_pcu8, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	    99  LOCAL_INLINE void   rba_BswSrv_MemSet64(rba_BswSrv_uint64* xDest_pu64, rba_BswSrv_uint64 xPattern_u64, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	   100  LOCAL_INLINE void   rba_BswSrv_MemSet32(uint32* xDest_pu32, uint32 xPattern_u32, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	   101  LOCAL_INLINE void   rba_BswSrv_MemSet16(uint16* xDest_pu16, uint32 xPattern_u32, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	   102  LOCAL_INLINE void   rba_BswSrv_MemSet8(uint8* xDest_pu8, uint32 xPattern_u32, uint32 numBytes_u32);
; .\Integration\BSW\Include\rba_BswSrv.h	   103  
; .\Integration\BSW\Include\rba_BswSrv.h	   104  /*
; .\Integration\BSW\Include\rba_BswSrv.h	   105   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   106   * Inline function definitions
; .\Integration\BSW\Include\rba_BswSrv.h	   107   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   108   */
; .\Integration\BSW\Include\rba_BswSrv.h	   109  
; .\Integration\BSW\Include\rba_BswSrv.h	   110  
; .\Integration\BSW\Include\rba_BswSrv.h	   111  
; .\Integration\BSW\Include\rba_BswSrv.h	   112  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   113   *********************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   114   * rba_BswSrv_ByteOrderSwap32
; .\Integration\BSW\Include\rba_BswSrv.h	   115   *
; .\Integration\BSW\Include\rba_BswSrv.h	   116   * Swaps the byte order of a 32 bit value for endianess conversion.
; .\Integration\BSW\Include\rba_BswSrv.h	   117   *
; .\Integration\BSW\Include\rba_BswSrv.h	   118   * \param   Input_u32: input value
; .\Integration\BSW\Include\rba_BswSrv.h	   119   * \return  value with swapped byte order
; .\Integration\BSW\Include\rba_BswSrv.h	   120   * \retval  uint32
; .\Integration\BSW\Include\rba_BswSrv.h	   121   * \seealso
; .\Integration\BSW\Include\rba_BswSrv.h	   122   * \usedresources
; .\Integration\BSW\Include\rba_BswSrv.h	   123   *********************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   124   */
; .\Integration\BSW\Include\rba_BswSrv.h	   125  LOCAL_INLINE uint32 rba_BswSrv_ByteOrderSwap32(uint32 Input_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   126  {
; .\Integration\BSW\Include\rba_BswSrv.h	   127      uint32 retVal_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   128  
; .\Integration\BSW\Include\rba_BswSrv.h	   129  
; .\Integration\BSW\Include\rba_BswSrv.h	   130      retVal_u32 = (Input_u32 << 24) | ((Input_u32 & 0xFF00u) << 8) | ((Input_u32 & 0x00FF0000u) >> 8) | (Input_u32 >> 24);
; .\Integration\BSW\Include\rba_BswSrv.h	   131  
; .\Integration\BSW\Include\rba_BswSrv.h	   132  
; .\Integration\BSW\Include\rba_BswSrv.h	   133      /* MISRA RULE 9.1 VIOLATION: variable is set by inline assembly but the checker does not understand this */
; .\Integration\BSW\Include\rba_BswSrv.h	   134      return retVal_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   135  }
; .\Integration\BSW\Include\rba_BswSrv.h	   136  
; .\Integration\BSW\Include\rba_BswSrv.h	   137  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   138   *********************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   139   * rba_BswSrv_ByteOrderSwap16
; .\Integration\BSW\Include\rba_BswSrv.h	   140   *
; .\Integration\BSW\Include\rba_BswSrv.h	   141   * Swaps the byte order of a 16 bit value for endianess conversion.
; .\Integration\BSW\Include\rba_BswSrv.h	   142   *
; .\Integration\BSW\Include\rba_BswSrv.h	   143   * \param   Input_u16: input value
; .\Integration\BSW\Include\rba_BswSrv.h	   144   * \return  value with swapped byte order
; .\Integration\BSW\Include\rba_BswSrv.h	   145   * \retval  uint16
; .\Integration\BSW\Include\rba_BswSrv.h	   146   * \seealso
; .\Integration\BSW\Include\rba_BswSrv.h	   147   * \usedresources
; .\Integration\BSW\Include\rba_BswSrv.h	   148   *********************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   149   */
; .\Integration\BSW\Include\rba_BswSrv.h	   150  LOCAL_INLINE uint16 rba_BswSrv_ByteOrderSwap16(uint16 Input_u16)
; .\Integration\BSW\Include\rba_BswSrv.h	   151  {
; .\Integration\BSW\Include\rba_BswSrv.h	   152      uint16 retVal_u16;
; .\Integration\BSW\Include\rba_BswSrv.h	   153  
; .\Integration\BSW\Include\rba_BswSrv.h	   154  
; .\Integration\BSW\Include\rba_BswSrv.h	   155      retVal_u16 = ((Input_u16 & 0x00FFu) << 8) | ((Input_u16 & 0xFF00u) >> 8);
; .\Integration\BSW\Include\rba_BswSrv.h	   156  
; .\Integration\BSW\Include\rba_BswSrv.h	   157  
; .\Integration\BSW\Include\rba_BswSrv.h	   158      /* MISRA RULE 9.1 VIOLATION: variable is set by inline assembly but the checker does not understand this */
; .\Integration\BSW\Include\rba_BswSrv.h	   159      return retVal_u16;
; .\Integration\BSW\Include\rba_BswSrv.h	   160  }
; .\Integration\BSW\Include\rba_BswSrv.h	   161  
; .\Integration\BSW\Include\rba_BswSrv.h	   162  
; .\Integration\BSW\Include\rba_BswSrv.h	   163  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   164   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   165   * rba_BswSrv_MemCopy64 - copy non overlapping memory in 64 Bit blocks
; .\Integration\BSW\Include\rba_BswSrv.h	   166   *
; .\Integration\BSW\Include\rba_BswSrv.h	   167   * Memory copy routine. Source and destination must not overlap. Pointer parameters must be 8 Byte
; .\Integration\BSW\Include\rba_BswSrv.h	   168   * aligned. The size should be a multiple of 8. If not, it is rounded down to the next multiple
; .\Integration\BSW\Include\rba_BswSrv.h	   169   * of 8.
; .\Integration\BSW\Include\rba_BswSrv.h	   170   *
; .\Integration\BSW\Include\rba_BswSrv.h	   171   * \param   xDest_pu64      destination address
; .\Integration\BSW\Include\rba_BswSrv.h	   172   * \param   xSrc_pcu64      source address
; .\Integration\BSW\Include\rba_BswSrv.h	   173   * \param   numBytes_u32    number of bytes to be copied
; .\Integration\BSW\Include\rba_BswSrv.h	   174   * \seealso     rba_BswSrv_MemCopy8, rba_BswSrv_MemCopy16, rba_BswSrv_MemCopy32
; .\Integration\BSW\Include\rba_BswSrv.h	   175   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   176   */
; .\Integration\BSW\Include\rba_BswSrv.h	   177  LOCAL_INLINE void rba_BswSrv_MemCopy64(rba_BswSrv_uint64* xDest_pu64, const rba_BswSrv_uint64* xSrc_pcu64, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   178  {
; .\Integration\BSW\Include\rba_BswSrv.h	   179  
; .\Integration\BSW\Include\rba_BswSrv.h	   180      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   181  
; .\Integration\BSW\Include\rba_BswSrv.h	   182      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 8); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   183      {
; .\Integration\BSW\Include\rba_BswSrv.h	   184          *xDest_pu64 = *xSrc_pcu64;
; .\Integration\BSW\Include\rba_BswSrv.h	   185          xDest_pu64++;
; .\Integration\BSW\Include\rba_BswSrv.h	   186          xSrc_pcu64++;
; .\Integration\BSW\Include\rba_BswSrv.h	   187      }
; .\Integration\BSW\Include\rba_BswSrv.h	   188  
; .\Integration\BSW\Include\rba_BswSrv.h	   189      return;
; .\Integration\BSW\Include\rba_BswSrv.h	   190  }
; .\Integration\BSW\Include\rba_BswSrv.h	   191  
; .\Integration\BSW\Include\rba_BswSrv.h	   192  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   193   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   194   * rba_BswSrv_MemCopy32 - copy non overlapping memory in 32 Bit blocks
; .\Integration\BSW\Include\rba_BswSrv.h	   195   *
; .\Integration\BSW\Include\rba_BswSrv.h	   196   * Memory copy routine. Source and destination must not overlap. Pointer parameters must be 4 Byte
; .\Integration\BSW\Include\rba_BswSrv.h	   197   * aligned. The size should be a multiple of 4. If not, it is rounded down to the next multiple
; .\Integration\BSW\Include\rba_BswSrv.h	   198   * of 4.
; .\Integration\BSW\Include\rba_BswSrv.h	   199   *
; .\Integration\BSW\Include\rba_BswSrv.h	   200   * \param   xDest_pu32      destination address
; .\Integration\BSW\Include\rba_BswSrv.h	   201   * \param   xSrc_pcu32      source address
; .\Integration\BSW\Include\rba_BswSrv.h	   202   * \param   numBytes_u32    number of bytes to be copied
; .\Integration\BSW\Include\rba_BswSrv.h	   203   * \seealso     rba_BswSrv_MemCopy8, rba_BswSrv_MemCopy16, rba_BswSrv_MemCopy64
; .\Integration\BSW\Include\rba_BswSrv.h	   204   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   205   */
; .\Integration\BSW\Include\rba_BswSrv.h	   206  LOCAL_INLINE void rba_BswSrv_MemCopy32(uint32* xDest_pu32, const uint32* xSrc_pcu32, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   207  {
; .\Integration\BSW\Include\rba_BswSrv.h	   208      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   209  
; .\Integration\BSW\Include\rba_BswSrv.h	   210      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 4); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   211      {
; .\Integration\BSW\Include\rba_BswSrv.h	   212          *xDest_pu32 = *xSrc_pcu32;
; .\Integration\BSW\Include\rba_BswSrv.h	   213          xDest_pu32++;
; .\Integration\BSW\Include\rba_BswSrv.h	   214          xSrc_pcu32++;
; .\Integration\BSW\Include\rba_BswSrv.h	   215      }
; .\Integration\BSW\Include\rba_BswSrv.h	   216  
; .\Integration\BSW\Include\rba_BswSrv.h	   217      return;
; .\Integration\BSW\Include\rba_BswSrv.h	   218  }
; .\Integration\BSW\Include\rba_BswSrv.h	   219  
; .\Integration\BSW\Include\rba_BswSrv.h	   220  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   221   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   222   * rba_BswSrv_MemCopy16 - copy non overlapping memory in 16 Bit blocks
; .\Integration\BSW\Include\rba_BswSrv.h	   223   *
; .\Integration\BSW\Include\rba_BswSrv.h	   224   * Memory copy routine. Source and destination must not overlap. Pointer parameters must be 2 Byte
; .\Integration\BSW\Include\rba_BswSrv.h	   225   * aligned. The size should be a multiple of 2. If not, it is rounded down to the next multiple
; .\Integration\BSW\Include\rba_BswSrv.h	   226   * of 2.
; .\Integration\BSW\Include\rba_BswSrv.h	   227   *
; .\Integration\BSW\Include\rba_BswSrv.h	   228   * \param   xDest_pu16      destination address
; .\Integration\BSW\Include\rba_BswSrv.h	   229   * \param   xSrc_pcu16      source address
; .\Integration\BSW\Include\rba_BswSrv.h	   230   * \param   numBytes_u32    number of bytes to be copied
; .\Integration\BSW\Include\rba_BswSrv.h	   231   * \seealso     rba_BswSrv_MemCopy8, rba_BswSrv_MemCopy32, rba_BswSrv_MemCopy64
; .\Integration\BSW\Include\rba_BswSrv.h	   232   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   233   */
; .\Integration\BSW\Include\rba_BswSrv.h	   234  LOCAL_INLINE void rba_BswSrv_MemCopy16(uint16* xDest_pu16, const uint16* xSrc_pcu16, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   235  {
; .\Integration\BSW\Include\rba_BswSrv.h	   236      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   237  
; .\Integration\BSW\Include\rba_BswSrv.h	   238      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 2); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   239      {
; .\Integration\BSW\Include\rba_BswSrv.h	   240          *xDest_pu16 = *xSrc_pcu16;
; .\Integration\BSW\Include\rba_BswSrv.h	   241          xDest_pu16++;
; .\Integration\BSW\Include\rba_BswSrv.h	   242          xSrc_pcu16++;
; .\Integration\BSW\Include\rba_BswSrv.h	   243      }
; .\Integration\BSW\Include\rba_BswSrv.h	   244  
; .\Integration\BSW\Include\rba_BswSrv.h	   245      return;
; .\Integration\BSW\Include\rba_BswSrv.h	   246  }
; .\Integration\BSW\Include\rba_BswSrv.h	   247  
; .\Integration\BSW\Include\rba_BswSrv.h	   248  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   249   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   250   * rba_BswSrv_MemCopy8 - copy non overlapping memory
; .\Integration\BSW\Include\rba_BswSrv.h	   251   *
; .\Integration\BSW\Include\rba_BswSrv.h	   252   * Memory copy routine. Source and destination must not overlap.
; .\Integration\BSW\Include\rba_BswSrv.h	   253   *
; .\Integration\BSW\Include\rba_BswSrv.h	   254   * \param   xDest_pu8       destination address
; .\Integration\BSW\Include\rba_BswSrv.h	   255   * \param   xSrc_pcu8       source address
; .\Integration\BSW\Include\rba_BswSrv.h	   256   * \param   numBytes_u32    number of bytes to be copied
; .\Integration\BSW\Include\rba_BswSrv.h	   257   * \seealso     rba_BswSrv_MemCopy16, rba_BswSrv_MemCopy32, rba_BswSrv_MemCopy64
; .\Integration\BSW\Include\rba_BswSrv.h	   258   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   259   */
; .\Integration\BSW\Include\rba_BswSrv.h	   260  LOCAL_INLINE void rba_BswSrv_MemCopy8(uint8* xDest_pu8, const uint8* xSrc_pcu8, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   261  {
; .\Integration\BSW\Include\rba_BswSrv.h	   262      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   263  
; .\Integration\BSW\Include\rba_BswSrv.h	   264      for(ctLoop_u32 = 0; ctLoop_u32 < numBytes_u32; ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   265      {
; .\Integration\BSW\Include\rba_BswSrv.h	   266          *xDest_pu8 = *xSrc_pcu8;
; .\Integration\BSW\Include\rba_BswSrv.h	   267          xDest_pu8++;
; .\Integration\BSW\Include\rba_BswSrv.h	   268          xSrc_pcu8++;
; .\Integration\BSW\Include\rba_BswSrv.h	   269      }
; .\Integration\BSW\Include\rba_BswSrv.h	   270  
; .\Integration\BSW\Include\rba_BswSrv.h	   271      return;
; .\Integration\BSW\Include\rba_BswSrv.h	   272  }
; .\Integration\BSW\Include\rba_BswSrv.h	   273  
; .\Integration\BSW\Include\rba_BswSrv.h	   274  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   275   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   276   * rba_BswSrv_MemCompare64 - compare memory in 64 Bit blocks
; .\Integration\BSW\Include\rba_BswSrv.h	   277   *
; .\Integration\BSW\Include\rba_BswSrv.h	   278   * Memory compare routine. Pointer parameters must be 8 Byte aligned. The size should be a
; .\Integration\BSW\Include\rba_BswSrv.h	   279   * multiple of 8. If not, it is rounded down to the next multiple of 8.
; .\Integration\BSW\Include\rba_BswSrv.h	   280   *
; .\Integration\BSW\Include\rba_BswSrv.h	   281   * \param   xSrc1_pcu32     first source address
; .\Integration\BSW\Include\rba_BswSrv.h	   282   * \param   xSrc2_pcu32     second source address
; .\Integration\BSW\Include\rba_BswSrv.h	   283   * \param   numBytes_u32    number of bytes to be compared
; .\Integration\BSW\Include\rba_BswSrv.h	   284   * \return  stEqual_u32     result of comparison
; .\Integration\BSW\Include\rba_BswSrv.h	   285   * \retval  0               memory area contents are equal
; .\Integration\BSW\Include\rba_BswSrv.h	   286   * \retval  1               memory area contents differ
; .\Integration\BSW\Include\rba_BswSrv.h	   287   * \seealso     rba_BswSrv_MemCompare8, rba_BswSrv_MemCompare16, rba_BswSrv_MemCompare32
; .\Integration\BSW\Include\rba_BswSrv.h	   288   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   289   */
; .\Integration\BSW\Include\rba_BswSrv.h	   290  LOCAL_INLINE uint32 rba_BswSrv_MemCompare64(const rba_BswSrv_uint64* xSrc1_pcu64, const rba_BswSrv_uint64* xSrc2_pcu64, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   291  {
; .\Integration\BSW\Include\rba_BswSrv.h	   292  
; .\Integration\BSW\Include\rba_BswSrv.h	   293      uint32 stEqual_u32 = 0ul;
; .\Integration\BSW\Include\rba_BswSrv.h	   294      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   295  
; .\Integration\BSW\Include\rba_BswSrv.h	   296      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 8); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   297      {
; .\Integration\BSW\Include\rba_BswSrv.h	   298          /* MISRA RULE 12.13 VIOLATION: required for code optimization */
; .\Integration\BSW\Include\rba_BswSrv.h	   299          if (*xSrc1_pcu64++ != *xSrc2_pcu64++)
; .\Integration\BSW\Include\rba_BswSrv.h	   300          {
; .\Integration\BSW\Include\rba_BswSrv.h	   301              stEqual_u32 = 1ul;
; .\Integration\BSW\Include\rba_BswSrv.h	   302              break;
; .\Integration\BSW\Include\rba_BswSrv.h	   303          }
; .\Integration\BSW\Include\rba_BswSrv.h	   304      }
; .\Integration\BSW\Include\rba_BswSrv.h	   305  
; .\Integration\BSW\Include\rba_BswSrv.h	   306      return stEqual_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   307  }
; .\Integration\BSW\Include\rba_BswSrv.h	   308  
; .\Integration\BSW\Include\rba_BswSrv.h	   309  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   310   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   311   * rba_BswSrv_MemCompare32 - compare memory in 32 Bit blocks
; .\Integration\BSW\Include\rba_BswSrv.h	   312   *
; .\Integration\BSW\Include\rba_BswSrv.h	   313   * Memory compare routine. Pointer parameters must be 4 Byte aligned. The size should be a
; .\Integration\BSW\Include\rba_BswSrv.h	   314   * multiple of 4. If not, it is rounded down to the next multiple of 4.
; .\Integration\BSW\Include\rba_BswSrv.h	   315   *
; .\Integration\BSW\Include\rba_BswSrv.h	   316   * \param   xSrc1_pcu32     first source address
; .\Integration\BSW\Include\rba_BswSrv.h	   317   * \param   xSrc2_pcu32     second source address
; .\Integration\BSW\Include\rba_BswSrv.h	   318   * \param   numBytes_u32    number of bytes to be compared
; .\Integration\BSW\Include\rba_BswSrv.h	   319   * \return  stEqual_u32     result of comparison
; .\Integration\BSW\Include\rba_BswSrv.h	   320   * \retval  0               memory area contents are equal
; .\Integration\BSW\Include\rba_BswSrv.h	   321   * \retval  1               memory area contents differ
; .\Integration\BSW\Include\rba_BswSrv.h	   322   * \seealso     rba_BswSrv_MemCompare8, rba_BswSrv_MemCompare16, rba_BswSrv_MemCompare64
; .\Integration\BSW\Include\rba_BswSrv.h	   323   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   324   */
; .\Integration\BSW\Include\rba_BswSrv.h	   325  LOCAL_INLINE uint32 rba_BswSrv_MemCompare32(const uint32* xSrc1_pcu32, const uint32* xSrc2_pcu32, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   326  {
; .\Integration\BSW\Include\rba_BswSrv.h	   327  
; .\Integration\BSW\Include\rba_BswSrv.h	   328      uint32 stEqual_u32 = 0ul;
; .\Integration\BSW\Include\rba_BswSrv.h	   329      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   330  
; .\Integration\BSW\Include\rba_BswSrv.h	   331      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 4); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   332      {
; .\Integration\BSW\Include\rba_BswSrv.h	   333          /* MISRA RULE 12.13 VIOLATION: required for code optimization */
; .\Integration\BSW\Include\rba_BswSrv.h	   334          if (*xSrc1_pcu32++ != *xSrc2_pcu32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   335          {
; .\Integration\BSW\Include\rba_BswSrv.h	   336              stEqual_u32 = 1ul;
; .\Integration\BSW\Include\rba_BswSrv.h	   337              break;
; .\Integration\BSW\Include\rba_BswSrv.h	   338          }
; .\Integration\BSW\Include\rba_BswSrv.h	   339      }
; .\Integration\BSW\Include\rba_BswSrv.h	   340  
; .\Integration\BSW\Include\rba_BswSrv.h	   341      return stEqual_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   342  }
; .\Integration\BSW\Include\rba_BswSrv.h	   343  
; .\Integration\BSW\Include\rba_BswSrv.h	   344  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   345   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   346   * rba_BswSrv_MemCompare16 - compare memory in 16 Bit blocks
; .\Integration\BSW\Include\rba_BswSrv.h	   347   *
; .\Integration\BSW\Include\rba_BswSrv.h	   348   * Memory compare routine. Pointer parameters must be 2 Byte aligned. The size should be a
; .\Integration\BSW\Include\rba_BswSrv.h	   349   * multiple of 2. If not, it is rounded down to the next multiple of 2.
; .\Integration\BSW\Include\rba_BswSrv.h	   350   *
; .\Integration\BSW\Include\rba_BswSrv.h	   351   * \param   xSrc1_pcu16     first source address
; .\Integration\BSW\Include\rba_BswSrv.h	   352   * \param   xSrc2_pcu16     second source address
; .\Integration\BSW\Include\rba_BswSrv.h	   353   * \param   numBytes_u32    number of bytes to be compared
; .\Integration\BSW\Include\rba_BswSrv.h	   354   * \return  stEqual_u32     result of comparison
; .\Integration\BSW\Include\rba_BswSrv.h	   355   * \retval  0               memory area contents are equal
; .\Integration\BSW\Include\rba_BswSrv.h	   356   * \retval  1               memory area contents differ
; .\Integration\BSW\Include\rba_BswSrv.h	   357   * \seealso     rba_BswSrv_MemCompare8, rba_BswSrv_MemCompare32, rba_BswSrv_MemCompare64
; .\Integration\BSW\Include\rba_BswSrv.h	   358   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   359   */
; .\Integration\BSW\Include\rba_BswSrv.h	   360  LOCAL_INLINE uint32 rba_BswSrv_MemCompare16(const uint16* xSrc1_pcu16, const uint16* xSrc2_pcu16, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   361  {
; .\Integration\BSW\Include\rba_BswSrv.h	   362  
; .\Integration\BSW\Include\rba_BswSrv.h	   363      uint32 stEqual_u32 = 0ul;
; .\Integration\BSW\Include\rba_BswSrv.h	   364      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   365  
; .\Integration\BSW\Include\rba_BswSrv.h	   366      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 2); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   367      {
; .\Integration\BSW\Include\rba_BswSrv.h	   368          /* MISRA RULE 12.13 VIOLATION: required for code optimization */
; .\Integration\BSW\Include\rba_BswSrv.h	   369          if (*xSrc1_pcu16++ != *xSrc2_pcu16++)
; .\Integration\BSW\Include\rba_BswSrv.h	   370          {
; .\Integration\BSW\Include\rba_BswSrv.h	   371              stEqual_u32 = 1ul;
; .\Integration\BSW\Include\rba_BswSrv.h	   372              break;
; .\Integration\BSW\Include\rba_BswSrv.h	   373          }
; .\Integration\BSW\Include\rba_BswSrv.h	   374      }
; .\Integration\BSW\Include\rba_BswSrv.h	   375  
; .\Integration\BSW\Include\rba_BswSrv.h	   376      return stEqual_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   377  }
; .\Integration\BSW\Include\rba_BswSrv.h	   378  
; .\Integration\BSW\Include\rba_BswSrv.h	   379  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   380   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   381   * rba_BswSrv_MemCompare8 - compare memory
; .\Integration\BSW\Include\rba_BswSrv.h	   382   *
; .\Integration\BSW\Include\rba_BswSrv.h	   383   * Memory compare routine.
; .\Integration\BSW\Include\rba_BswSrv.h	   384   *
; .\Integration\BSW\Include\rba_BswSrv.h	   385   * \param   xSrc1_pcu8      pointer to the first source address
; .\Integration\BSW\Include\rba_BswSrv.h	   386   * \param   xSrc2_pcu8      pointer to the second source address
; .\Integration\BSW\Include\rba_BswSrv.h	   387   * \param   numBytes_u32    number of bytes to be compared
; .\Integration\BSW\Include\rba_BswSrv.h	   388   * \return  stEqual_u32     result of comparison
; .\Integration\BSW\Include\rba_BswSrv.h	   389   * \retval  0               memory area contents are equal
; .\Integration\BSW\Include\rba_BswSrv.h	   390   * \retval  1               memory area contents differ
; .\Integration\BSW\Include\rba_BswSrv.h	   391   * \seealso     rba_BswSrv_MemCompare16, rba_BswSrv_MemCompare32, rba_BswSrv_MemCompare64
; .\Integration\BSW\Include\rba_BswSrv.h	   392   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   393   */
; .\Integration\BSW\Include\rba_BswSrv.h	   394  LOCAL_INLINE uint32 rba_BswSrv_MemCompare8(const uint8* xSrc1_pcu8, const uint8* xSrc2_pcu8, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   395  {
; .\Integration\BSW\Include\rba_BswSrv.h	   396  
; .\Integration\BSW\Include\rba_BswSrv.h	   397      uint32 stEqual_u32 = 0ul;
; .\Integration\BSW\Include\rba_BswSrv.h	   398      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   399  
; .\Integration\BSW\Include\rba_BswSrv.h	   400      for(ctLoop_u32 = 0; ctLoop_u32 < numBytes_u32; ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   401      {
; .\Integration\BSW\Include\rba_BswSrv.h	   402          /* MISRA RULE 12.13 VIOLATION: required for code optimization */
; .\Integration\BSW\Include\rba_BswSrv.h	   403          if (*xSrc1_pcu8++ != *xSrc2_pcu8++)
; .\Integration\BSW\Include\rba_BswSrv.h	   404          {
; .\Integration\BSW\Include\rba_BswSrv.h	   405              stEqual_u32 = 1ul;
; .\Integration\BSW\Include\rba_BswSrv.h	   406              break;
; .\Integration\BSW\Include\rba_BswSrv.h	   407          }
; .\Integration\BSW\Include\rba_BswSrv.h	   408      }
; .\Integration\BSW\Include\rba_BswSrv.h	   409  
; .\Integration\BSW\Include\rba_BswSrv.h	   410      return stEqual_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   411  }
; .\Integration\BSW\Include\rba_BswSrv.h	   412  
; .\Integration\BSW\Include\rba_BswSrv.h	   413  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   414   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   415   * rba_BswSrv_MemSet64 - initialize memory with 64 Bit data
; .\Integration\BSW\Include\rba_BswSrv.h	   416   *
; .\Integration\BSW\Include\rba_BswSrv.h	   417   * Memory initialization routine. 64 Bit Pattern is written to the destination.
; .\Integration\BSW\Include\rba_BswSrv.h	   418   * Destination must be 4 Byte aligned. The size should be a multiple of 8. If not, it is rounded
; .\Integration\BSW\Include\rba_BswSrv.h	   419   * down to the next multiple of 8.
; .\Integration\BSW\Include\rba_BswSrv.h	   420   *
; .\Integration\BSW\Include\rba_BswSrv.h	   421   * \param   xDest_pu32      destination address
; .\Integration\BSW\Include\rba_BswSrv.h	   422   * \param   Pattern_u32     fill pattern
; .\Integration\BSW\Include\rba_BswSrv.h	   423   * \param   numBytes_u32    number of bytes to be initialized
; .\Integration\BSW\Include\rba_BswSrv.h	   424   * \seealso     rba_BswSrv_MemSet8, rba_BswSrv_MemSet16, rba_BswSrv_MemSet32
; .\Integration\BSW\Include\rba_BswSrv.h	   425   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   426   */
; .\Integration\BSW\Include\rba_BswSrv.h	   427  LOCAL_INLINE void rba_BswSrv_MemSet64(rba_BswSrv_uint64* xDest_pu64, rba_BswSrv_uint64 xPattern_u64, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   428  {
; .\Integration\BSW\Include\rba_BswSrv.h	   429  
; .\Integration\BSW\Include\rba_BswSrv.h	   430      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   431  
; .\Integration\BSW\Include\rba_BswSrv.h	   432      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 8); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   433      {
; .\Integration\BSW\Include\rba_BswSrv.h	   434          *xDest_pu64 = xPattern_u64;
; .\Integration\BSW\Include\rba_BswSrv.h	   435          xDest_pu64++;
; .\Integration\BSW\Include\rba_BswSrv.h	   436      }
; .\Integration\BSW\Include\rba_BswSrv.h	   437  
; .\Integration\BSW\Include\rba_BswSrv.h	   438      return;
; .\Integration\BSW\Include\rba_BswSrv.h	   439  }
; .\Integration\BSW\Include\rba_BswSrv.h	   440  
; .\Integration\BSW\Include\rba_BswSrv.h	   441  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   442   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   443   * rba_BswSrv_MemSet32 - initialize memory with 32 Bit data
; .\Integration\BSW\Include\rba_BswSrv.h	   444   *
; .\Integration\BSW\Include\rba_BswSrv.h	   445   * Memory initialization routine. 32 Bit Pattern is written to the destination.
; .\Integration\BSW\Include\rba_BswSrv.h	   446   * Destination must be 4 Byte aligned. The size should be a multiple of 4. If not, it is rounded
; .\Integration\BSW\Include\rba_BswSrv.h	   447   * down to the next multiple of 4.
; .\Integration\BSW\Include\rba_BswSrv.h	   448   *
; .\Integration\BSW\Include\rba_BswSrv.h	   449   * \param   xDest_pu32      destination address
; .\Integration\BSW\Include\rba_BswSrv.h	   450   * \param   Pattern_u32     fill pattern
; .\Integration\BSW\Include\rba_BswSrv.h	   451   * \param   numBytes_u32    number of bytes to be initialized
; .\Integration\BSW\Include\rba_BswSrv.h	   452   * \seealso     rba_BswSrv_MemSet8, rba_BswSrv_MemSet16, rba_BswSrv_MemSet64
; .\Integration\BSW\Include\rba_BswSrv.h	   453   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   454   */
; .\Integration\BSW\Include\rba_BswSrv.h	   455  LOCAL_INLINE void rba_BswSrv_MemSet32(uint32* xDest_pu32, uint32 xPattern_u32, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   456  {
; .\Integration\BSW\Include\rba_BswSrv.h	   457      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   458  
; .\Integration\BSW\Include\rba_BswSrv.h	   459      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 4); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   460      {
; .\Integration\BSW\Include\rba_BswSrv.h	   461          *xDest_pu32 = xPattern_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   462          xDest_pu32++;
; .\Integration\BSW\Include\rba_BswSrv.h	   463      }
; .\Integration\BSW\Include\rba_BswSrv.h	   464  
; .\Integration\BSW\Include\rba_BswSrv.h	   465      return;
; .\Integration\BSW\Include\rba_BswSrv.h	   466  }
; .\Integration\BSW\Include\rba_BswSrv.h	   467  
; .\Integration\BSW\Include\rba_BswSrv.h	   468  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   469   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   470   * rba_BswSrv_MemSet16 - initialize memory with 16 Bit data
; .\Integration\BSW\Include\rba_BswSrv.h	   471   *
; .\Integration\BSW\Include\rba_BswSrv.h	   472   * Memory initialization routine. 16 Bit Pattern is written to the destination.
; .\Integration\BSW\Include\rba_BswSrv.h	   473   * Destination must be 2 Byte aligned. The size should be a multiple of 2. If not, it is rounded
; .\Integration\BSW\Include\rba_BswSrv.h	   474   * down to the next multiple of 2.
; .\Integration\BSW\Include\rba_BswSrv.h	   475   *
; .\Integration\BSW\Include\rba_BswSrv.h	   476   * \param   xDest_pu32      destination address
; .\Integration\BSW\Include\rba_BswSrv.h	   477   * \param   Pattern_u32     fill pattern
; .\Integration\BSW\Include\rba_BswSrv.h	   478   * \param   numBytes_u32    number of bytes to be initialized
; .\Integration\BSW\Include\rba_BswSrv.h	   479   * \seealso     rba_BswSrv_MemSet8, rba_BswSrv_MemSet32, rba_BswSrv_MemSet64
; .\Integration\BSW\Include\rba_BswSrv.h	   480   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   481   */
; .\Integration\BSW\Include\rba_BswSrv.h	   482  LOCAL_INLINE void rba_BswSrv_MemSet16(uint16* xDest_pu16, uint32 xPattern_u32, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   483  {
; .\Integration\BSW\Include\rba_BswSrv.h	   484      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   485  
; .\Integration\BSW\Include\rba_BswSrv.h	   486      for(ctLoop_u32 = 0; ctLoop_u32 < (numBytes_u32 / 2); ctLoop_u32++)
; .\Integration\BSW\Include\rba_BswSrv.h	   487      {
; .\Integration\BSW\Include\rba_BswSrv.h	   488          *xDest_pu16 = (uint16)xPattern_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   489          xDest_pu16++;
; .\Integration\BSW\Include\rba_BswSrv.h	   490      }
; .\Integration\BSW\Include\rba_BswSrv.h	   491  
; .\Integration\BSW\Include\rba_BswSrv.h	   492      return;
; .\Integration\BSW\Include\rba_BswSrv.h	   493  }
; .\Integration\BSW\Include\rba_BswSrv.h	   494  
; .\Integration\BSW\Include\rba_BswSrv.h	   495  /**
; .\Integration\BSW\Include\rba_BswSrv.h	   496   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   497   * rba_BswSrv_MemSet8 - initialize memory with 8 Bit data
; .\Integration\BSW\Include\rba_BswSrv.h	   498   *
; .\Integration\BSW\Include\rba_BswSrv.h	   499   * Memory initialization routine. 8 Bit Pattern is written to the destination.
; .\Integration\BSW\Include\rba_BswSrv.h	   500   *
; .\Integration\BSW\Include\rba_BswSrv.h	   501   * \param   xDest_pu8       destination address
; .\Integration\BSW\Include\rba_BswSrv.h	   502   * \param   xPattern_u32    fill pattern, only lower 8 bit used
; .\Integration\BSW\Include\rba_BswSrv.h	   503   * \param   numBytes_u32    number of bytes to be initialized
; .\Integration\BSW\Include\rba_BswSrv.h	   504   * \seealso     rba_BswSrv_MemSet16, rba_BswSrv_MemSet32, rba_BswSrv_MemSet64
; .\Integration\BSW\Include\rba_BswSrv.h	   505   ***************************************************************************************************
; .\Integration\BSW\Include\rba_BswSrv.h	   506   */
; .\Integration\BSW\Include\rba_BswSrv.h	   507  LOCAL_INLINE void rba_BswSrv_MemSet8(uint8* xDest_pu8, uint32 xPattern_u32, uint32 numBytes_u32)
; .\Integration\BSW\Include\rba_BswSrv.h	   508  {
; .\Integration\BSW\Include\rba_BswSrv.h	   509      uint32 ctLoop_u32;
; .\Integration\BSW\Include\rba_BswSrv.h	   510  
; .\Integration\BSW\Include\rba_BswSrv.h	   511      for(ctLoop_u32 = 0; ctLoop_u32 < numBytes_u32; ctLoop_u32++)
	mov	d2,#0
.L209:

; .\Integration\BSW\Include\rba_BswSrv.h	   511      for(ctLoop_u32 = 0; ctLoop_u32 < numBytes_u32; ctLoop_u32++)      (inlined)
	j	.L28
.L29:

; .\Integration\BSW\Include\rba_BswSrv.h	   512      {
; .\Integration\BSW\Include\rba_BswSrv.h	   513          *xDest_pu8 = (uint8)xPattern_u32;
	st.b	[a2],d0
.L288:

; .\Integration\BSW\Include\rba_BswSrv.h	   514          xDest_pu8++;
	add.a	a2,#1
.L289:
	add	d2,#1

; .\Integration\BSW\Include\rba_BswSrv.h	   511      for(ctLoop_u32 = 0; ctLoop_u32 < numBytes_u32; ctLoop_u32++)      (inlined)
.L28:
	jlt.u	d2,d1,.L29
.L290:

; .\Integration\BSW\Include\rba_BswSrv.h	   517      return;      (inlined)
	j	.L30

; .\Integration\BSW\Include\rba_BswSrv.h	   518  }      (inlined)
.L30:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   393  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   394          /* Start: Reset all Tx Flags */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   395          if(Com_GetValue( TXIPDU,_PDUWITHPDUGRP,TxIPduConstPtr->txIPduFields ) != COM_FALSE)
	ld.hu	d0,[a13]20
.L133:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
	mov	d1,#1
.L291:
	sh	d1,d1,#14
.L292:
	and	d0,d1
.L293:
	ne	d15,d0,#0
.L294:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));      (inlined)
	j	.L31

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }      (inlined)
.L31:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   395          if(Com_GetValue( TXIPDU,_PDUWITHPDUGRP,TxIPduConstPtr->txIPduFields ) != COM_FALSE)      (inlined)
	jeq	d15,#0,.L32
.L295:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   396          {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   397              COM_GET_IPDUCOUNTER_S(Idx_ui + COM_GET_NUM_RX_IPDU) = COM_ZERO;
	movh.a	a15,#@his(Com_IpduCounter_s)
	lea	a15,[a15]@los(Com_IpduCounter_s)
	addsc.a	a15,a15,d8,#0
.L296:
	mov	d15,#0
.L297:
	st.b	[a15]5,d15
.L298:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   398  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   399              /* Set the TxIPdu-Mode to most probable case */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   400              Com_SetRamValue(TXIPDU,_TXMODESTATE,TxIpduRamPtr->Com_TransMode,COM_TRUE);
	lea	a15,[a12]15
	mov	d15,#1
.L139:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;      (inlined)
	ne	d15,d15,#0
.L210:
	j	.L34
.L33:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   439  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   440  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   441  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   442   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   443   * Bfx_PutBit_u16u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   444   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   445   * \brief Sets or clears a bit at a given position Pos_u32 in the 16-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   446   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   447   * A priori, range [0,15] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   448   * Note, neither the given position BitPn nor the given value Value not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   449   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   450   * \param   uint16*  Data   pointer to a 16-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   451   * \param   uint8    BitPn  position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   452   * \param   boolean  Value  defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   453   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   454   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   455   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   456  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   457  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   458      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   460      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   461      *Data = ((*Data & ((uint16)~(1uL << BitPn))) | ((uint16)((uint16)tmp_u8 << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   462  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   463  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   464  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   465  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   466   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   467   * Bfx_PutBit_u32u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   468   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   469   * \brief Sets or clears a bit at a given position Pos_u32 in the 32-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   470   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   471   * A priori, range [0,31] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   472   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   473   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   474   * \param   uint32*     Data        pointer to a 32-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   475   * \param   uint8       BitPn       position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   476   * \param   boolean     Value       defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   477   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   478   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   479   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   480  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   481  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   482      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   483      tmp_u8 = (Value)? 1u : 0u;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   484      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   485      *Data = ((*Data & ((uint32)~(1uL << BitPn))) | ((uint32)((uint32)tmp_u8 << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   486  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   487  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   488  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   489  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   490   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   491   * Bfx_PutBit_u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   492   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   493   * \brief Sets or clears a bit at a given position BitPn in the 8-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   494   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   495   * A priori, range [0,7] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   496   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   497   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   498   * \param  uint8*   Data    pointer to a 8-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   499   * \param  uint8    BitPn   position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   500   * \param  boolean  Value   defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   501   * \return void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   502   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   503   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   504  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   505  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   506      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;
	mov	d15,#0

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;      (inlined)
.L34:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   508      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   509      *Data = ((*Data & ((uint8)~(1uL <<BitPn))) | ((uint8)(tmp_u8 << BitPn)));
	ld.bu	d0,[a15]
.L299:
	mov	d1,#1
.L300:
	sh	d1,#2
.L301:
	xor	d1,d1,#255
.L302:
	and	d0,d1
.L303:
	sha	d15,#2
.L212:
	or	d0,d15
.L304:
	st.b	[a15],d0
.L140:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   401  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   402              Com_SetRamValue(TXIPDU,_LATESTMODE,TxIpduRamPtr->Com_TransMode,(uint8)COM_TXMODE_NONE);
	lea	a15,[a12]15
	mov	d1,#2
	mov	d0,#2
.L143:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   439  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   440  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   441  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   442   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   443   * Bfx_PutBit_u16u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   444   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   445   * \brief Sets or clears a bit at a given position Pos_u32 in the 16-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   446   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   447   * A priori, range [0,15] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   448   * Note, neither the given position BitPn nor the given value Value not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   449   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   450   * \param   uint16*  Data   pointer to a 16-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   451   * \param   uint8    BitPn  position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   452   * \param   boolean  Value  defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   453   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   454   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   455   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   456  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   457  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   458      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   460      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   461      *Data = ((*Data & ((uint16)~(1uL << BitPn))) | ((uint16)((uint16)tmp_u8 << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   462  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   463  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   464  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   465  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   466   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   467   * Bfx_PutBit_u32u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   468   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   469   * \brief Sets or clears a bit at a given position Pos_u32 in the 32-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   470   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   471   * A priori, range [0,31] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   472   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   473   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   474   * \param   uint32*     Data        pointer to a 32-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   475   * \param   uint8       BitPn       position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   476   * \param   boolean     Value       defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   477   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   478   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   479   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   480  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   481  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   482      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   483      tmp_u8 = (Value)? 1u : 0u;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   484      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   485      *Data = ((*Data & ((uint32)~(1uL << BitPn))) | ((uint32)((uint32)tmp_u8 << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   486  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   487  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   488  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   489  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   490   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   491   * Bfx_PutBit_u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   492   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   493   * \brief Sets or clears a bit at a given position BitPn in the 8-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   494   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   495   * A priori, range [0,7] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   496   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   497   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   498   * \param  uint8*   Data    pointer to a 8-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   499   * \param  uint8    BitPn   position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   500   * \param  boolean  Value   defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   501   * \return void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   502   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   503   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   504  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   505  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   506      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   508      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   509      *Data = ((*Data & ((uint8)~(1uL <<BitPn))) | ((uint8)(tmp_u8 << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   510  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   511  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   512  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   513  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   514   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   515   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   516   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   517   * \brief Sets or clears a bit at a given position Pos_u32 in the 16-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   518   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   519   * A priori, range [0,15] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   520   * Note, neither the given position BitPn nor the given value Value not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   521   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   522   * \param   uint16*   Data        pointer to a 16-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   523   * \param   uint8     BitStartPn  position of the bit, from where the pattern has to be inserted
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   524   * \param   uint8     BitLn       bit length of the pattern to be inserted
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   525   * \param   uint16    Pattern     pattern of the bit to be inserted
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   526   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   527   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   528   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   529  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   530  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   531      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   532      *Data = (((uint16) (~(uint16) ((BFX_MAXUINT16_U >> (16uL - BitLn)) << BitStartPn))) & *Data) | (uint16)(((BFX_MAXUINT16_U
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   533              >> (16uL - BitLn)) & Pattern) << BitStartPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   534  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   535  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   536  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   537  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   538   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   539   * Bfx_PutBits_u32u8u8u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   540   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   541   * \brief Sets or clears a bit at a given position Pos_u32 in the 32-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   542   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   543   * A priori, range [0,31] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   544   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   545   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   546   * \param   uint32*  Data         pointer to a 32-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   547   * \param   uint8    BitStartPn   position of the bit, from where the pattern has to be inserted
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   548   * \param   uint8    BitLn        bit length of the pattern to be inserted
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   549   * \param   uint32   Pattern      pattern of the bit to be inserted
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   550   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   551   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   552   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   553  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   554  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   555      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   556      *Data = (((uint32) (~(uint32)((BFX_MAXUINT32_U >> (32uL - BitLn)) << BitStartPn))) & *Data) | (uint32)(((BFX_MAXUINT32_U >> (32uL
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   557              - BitLn)) & Pattern) << BitStartPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   558  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   559  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   560  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   561  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   562   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   563   * Bfx_PutBits_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   564   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   565   * \brief Sets or clears a bit at a given position BitPn in the 8-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   566   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   567   * A priori, range [0,7] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   568   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   569   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   570   * \param  uint8*   Data          pointer to a 8-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   571   * \param  uint8    BitStartPn    position of the bit, from where the pattern has to be inserted
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   572   * \param  uint8    BitLn         bit length of the pattern to be inserted
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   573   * \param  uint8    Pattern       pattern of the bit to be inserted
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   574   * \return void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   575   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   576   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   577  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   578  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   579      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   580      *Data = (((uint8) (~(uint8)((BFX_MAXUINT8_U >> (8uL - BitLn)) << BitStartPn))) & *Data) | (uint8)(((BFX_MAXUINT8_U >> (8uL
	mov	d15,#255
.L305:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   581              - BitLn)) & Pattern) << BitStartPn);
	rsub	d1,d1,#8
.L306:
	rsub	d1,#0
	sh	d15,d15,d1
.L307:
	sh	d1,d15,#0
.L308:
	xor	d1,d1,#255
.L309:
	ld.bu	d2,[a15]
.L211:
	and	d1,d2
.L310:
	and	d0,d15
.L311:
	sh	d0,#0
.L312:
	or	d1,d0
.L313:
	st.b	[a15],d1

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   395          if(Com_GetValue( TXIPDU,_PDUWITHPDUGRP,TxIPduConstPtr->txIPduFields ) != COM_FALSE)      (inlined)
.L32:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   403              /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   404              #ifdef COM_MIXEDPHASESHIFT
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   405              /* Disable MixedPhaseShift by default */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   406              Com_SetRamValue(TXIPDU,_MIXEDPHASESHIFT,TxIpduRamPtr->Com_TransMode,COM_FALSE);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   407              #endif /* #ifdef COM_MIXEDPHASESHIFT */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   408              /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   409          }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   410  #ifdef COM_IPDU_WITHOUT_IPDUGROUPREF
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   411          else
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   412          {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   413              /* Call function to initialize Ipdu which does not belongs to any IpduGroup */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   414              Com_Prv_Init_IpduWoGroupRef(Idx_ui);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   415          }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   416  #endif /* #ifdef COM_IPDU_WITHOUT_IPDUGROUPREF */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   417  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   418  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   419          /*Reset all other Tx Global variables including Min Delays*/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   420  #ifdef COM_TxIPduTimeOut
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   421          TxIpduRamPtr->Com_TickTxTimeout     = COM_ZERO;
	mov	d15,#0
.L314:
	st.h	[a12]10,d15
.L315:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   422  #endif /* #ifdef COM_TxIPduTimeOut */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   423  #ifdef COM_TxFilters
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   424          TxIpduRamPtr->Com_TMSTrueCounter_u8 = COM_ZERO;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   425  #endif /* #ifdef COM_TxFilters */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   426          TxIpduRamPtr->Com_n                 = COM_ZERO;
	mov	d15,#0
.L316:
	st.b	[a12]14,d15
.L317:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   427  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   428          TxIpduRamPtr->Com_MinDelayTick      = COM_ZERO; /*Minimum Delay Tick for the Tx IPDU's */
	mov	d15,#0
.L318:
	st.h	[a12]4,d15
.L154:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   429  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   430          /* Call function to initialize configured transmission signals */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   431          Com_Prv_Init_TxSignal(Idx_ui);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   432  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   433  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   434          /* Call function to initialize configured transmission signalgroup */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   435          Com_Prv_Init_TxSignalGroup(Idx_ui);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   436  #endif
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   437  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   438          TxIPduConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   439          TxIpduRamPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   440  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   441      } /*end of for(Idx_ui=0;Idx_ui<COM_GET_NUM_TX_IPDU;Idx_ui++)*/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   442  }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   443  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   444  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   445  #ifdef COM_IPDU_WITHOUT_IPDUGROUPREF
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   446  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   447  /***************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   448   Function name    : Com_Prv_Init_IpduWoGroupRef
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   449   Syntax           : void Com_Prv_Init_IpduWoGroupRef(PduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   450   Description      : Service for initializing COM module for the transmission
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   451   Parameter        : IpduId         -> Index of the Ipdu
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   452   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   453   ***************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   454  /* HIS METRIC CALLS VIOLATION IN Com_Prv_Init_IpduWoGroupRef:
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   455     Com_Prv_Init_IpduWoGroupRef function contains necessary function calls statements.
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   456     HIS metric compliance would decrease readability and maintainability */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   457  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_Init_IpduWoGroupRef(VAR(PduIdType, AUTOMATIC) IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   458  {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   459  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   460      /* Variable declaration */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   461      Com_TxIpduRamPtrType        TxIpduRamPtr;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   462      Com_TxIpduConstPtrType      TxIPduConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   463      VAR(boolean, AUTOMATIC)     DefaultTMSStatus;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   464  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   465      /*Update the bytes with Initial Value*/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   466      TxIpduRamPtr   = &COM_GET_TXPDURAM_S(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   467  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   468      TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   469  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   470      /* Fetch the default TMS status which is evaluated during the code generation time
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   471       * for the ComIpdu's which are not part of any ComIpduGroup  */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   472      DefaultTMSStatus = Com_GetValue(TXIPDU,_DEFAULTTMSSTATUS,TxIPduConstPtr->txIPduFields);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   473  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   474      /* [SWS_Com_00840] If an I-PDU is not assigned to any I-PDU group, the I-PDU shall be initially started
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   475       * (and never been stopped) */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   476      COM_GET_IPDUCOUNTER_S(IpduId + COM_GET_NUM_RX_IPDU) = COM_ONE;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   477  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   478      Com_SetRamValue(TXIPDU,_PDUSTATUS,TxIpduRamPtr->Com_TxFlags,COM_START);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   479  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   480      /* [SWS_Com_00877]: If an I-PDU is not part of any I-PDU Group, it is started during the initialization of COM.
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   481       * Its starting transmission mode shall be evaluated according to the
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   482       * ComSignalInitValue of the signals contributing to its TMS.
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   483       * Set the Tx Mode state as DefaultTMSStatus. */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   484      Com_SetRamValue(TXIPDU,_TXMODESTATE,TxIpduRamPtr->Com_TransMode,DefaultTMSStatus);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   485      /* Set accordingly the TxModeMode as per DefaultTMSStatus */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   486      Com_SetCurrentTxModePtr(TxIpduRamPtr,TxIPduConstPtr,Com_GetValue(TXIPDU,_TMS,TxIPduConstPtr->txIPduFields),DefaultTMSStatus);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   487      /* Set the latest mode as per current mode */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   488      Com_SetRamValue(TXIPDU,_LATESTMODE,TxIpduRamPtr->Com_TransMode,TxIpduRamPtr->CurrentTxModePtr->Mode);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   489      /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   490  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   491      /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   492      if(COM_RESET != (Com_GetRamValue(TXIPDU,_LATESTMODE,TxIpduRamPtr->Com_TransMode) & COM_TXMODE_MIXED))
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   493      {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   494          /* I.e Load the TxTimeOffset for cyclic type Pdu's(PERIODIC or MIXED) */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   495          TxIpduRamPtr->Com_Tick_Tx = COM_GET_TXIPDU_TIMEOFFSET(IpduId, TxIpduRamPtr->CurrentTxModePtr);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   496  #ifdef COM_MIXEDPHASESHIFT
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   497          /* Set the MixedPhaseShift Mode */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   498          Com_SetRamValue(TXIPDU,_MIXEDPHASESHIFT,TxIpduRamPtr->Com_TransMode,TxIpduRamPtr->CurrentTxModePtr->MixedPhaseShift);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   499  #endif /* #ifdef COM_MIXEDPHASESHIFT */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   500      }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   501  }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   502  #endif /* #ifdef COM_IPDU_WITHOUT_IPDUGROUPREF */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   503  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   504  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   505  /***************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   506   Function name    : Com_Prv_Init_TxSignal
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   507   Syntax           : void Com_Prv_Init_TxSignal(VAR(PduIdType, AUTOMATIC) IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   508   Description      : Service to initialize all configured signals at the sender side
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   509   Parameter        : IpduId -> Index of the Ipdu
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   510   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   511   ***************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   512  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_Init_TxSignal(VAR(PduIdType, AUTOMATIC) IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   513  {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   514  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   515      Com_TxIpduConstPtrType         TxIPduConstPtr; /* Local ptr to hold the address of Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   516      Com_TxSigConstPtrType          TxSigConstPtr;  /* Local ptr to hold the address of Tx signal static configuration*/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   517      VAR(Com_SigMaxType, AUTOMATIC) TxSigNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   518  #if (defined(COM_TxFilters) && defined(COM_F_MASKEDNEWDIFFERSOLD)) || defined(COM_EffectiveSigTOC)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   519      /* Variable to hold the signal property */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   520      VAR(uint16, AUTOMATIC)         ConstByteValue_u16;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   521  #endif /* #if (defined(COM_TxFilters) && defined(COM_F_MASKEDNEWDIFFERSOLD)) || defined(COM_EffectiveSigTOC) */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   522  #ifdef COM_EffectiveSigTOC
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   523      /* Variable to hold the Transfer Property of Signal */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   524      VAR(uint16, AUTOMATIC)         TxSigTp_u16;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   525  #endif /* #ifdef COM_EffectiveSigTOC */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   526  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   527      VAR(uint16_least, AUTOMATIC)   Idx_ByteNSig_ui;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   528  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   529  #ifdef COM_TxSigUpdateBit
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   530      VAR(PduLengthType, AUTOMATIC)  ByteNo_u8;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   531  #endif /* #ifdef COM_TxSigUpdateBit */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   532      VAR(uint8, AUTOMATIC)          ConstByteValue_u8;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   533      VAR(uint8, AUTOMATIC)          Type;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   534  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   535      TxIPduConstPtr      = COM_GET_TX_IPDU_CONSTDATA(IpduId);
	mul	d15,d8,#24
	ld.a	a15,[a10]
	addsc.a	a14,a15,d15,#0
.L213:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   536  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   537      /* AUTOSAR COM shall initialize all signals on sender side with
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   538      the configured init values */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   539      TxSigConstPtr       = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
	ld.bu	d15,[a14]18
	mul	d15,d15,#12
	movh.a	a15,#@his(Com_Prv_xTxSigCfg_acst)
	lea	a15,[a15]@los(Com_Prv_xTxSigCfg_acst)
	addsc.a	a15,a15,d15,#0
.L214:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   540  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   541      for(Idx_ByteNSig_ui = TxIPduConstPtr->No_Of_Sig_Ref; Idx_ByteNSig_ui != COM_ZERO; Idx_ByteNSig_ui--)
	ld.hu	d9,[a14]14
.L215:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   541      for(Idx_ByteNSig_ui = TxIPduConstPtr->No_Of_Sig_Ref; Idx_ByteNSig_ui != COM_ZERO; Idx_ByteNSig_ui--)      (inlined)
	j	.L35
.L36:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   542      {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   543  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   544          ConstByteValue_u8   = TxSigConstPtr->General;
	ld.bu	d15,[a15]9
.L216:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   545          /* Get the signal type */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   546          Type                = Com_GetValue(GEN,_TYPE,ConstByteValue_u8);
	mov	d1,#5
.L166:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
	sha	d0,d15,#0
.L319:
	mov	d2,#255
.L320:
	rsub	d1,d1,#8
.L321:
	rsub	d1,#0
	sh	d2,d2,d1
.L218:
	and	d0,d2
.L322:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));      (inlined)
	j	.L37

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }      (inlined)
.L37:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   547  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   548          /* Sign extension to be performed on Init value
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   549          * But when a signed value is assigned to a uint32 variable,it is sign extended by default*/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   550          TxSigNewVal         = (Com_SigMaxType)TxSigConstPtr->Init_Val;
	ld.w	d7,[a15]
.L168:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
	mov	d1,#1
.L323:
	sh	d1,#5
.L324:
	and	d15,d1
.L217:
	ne	d15,d15,#0
.L325:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);      (inlined)
	j	.L38

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }      (inlined)
.L38:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   572                                                    Com_GetValue(GEN,_ENDIANESS,ConstByteValue_u8)  );      (inlined)
	ne	d4,d15,#0
	j	.L40
.L39:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   551  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   552  #ifdef COM_TXSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   553          /* [SWS_Com_00723] The AUTOSAR COM module shall extend the init value (ComSignalInitValue) of a signal
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   554          * to the size of its ComSignalType.
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   555          * Currently for COM_SINT64 signal type, ComSignalInitValue is supported for maximum 32bits.
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   556          * If negative values are configured, by default these values will be sign extended only till 32bits.
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   557          * so, for COM_SINT64, it is required to perform the sign extension till 64bits explicitly. */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   558          if ( Type == COM_SINT64 )
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   559          {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   560              TxSigNewVal = (Com_SigMaxType)((sint64)((sint32)TxSigNewVal));
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   561          }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   562          else
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   563          {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   564              /* do nothing for other signal types */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   565          }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   566  #endif /* #ifdef COM_TXSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   567  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   568          Com_InitializePduBuffWithSignalInitValue( TxIPduConstPtr->BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   569                                                    TxSigNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   570                                                    TxSigConstPtr->Bit_Pos,
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   571                                                    TxSigConstPtr->BitSize, Type,
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   572                                                    Com_GetValue(GEN,_ENDIANESS,ConstByteValue_u8)  );
	mov	d4,#0

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   572                                                    Com_GetValue(GEN,_ENDIANESS,ConstByteValue_u8)  );      (inlined)
.L40:
	ld.a	a4,[a14]
.L326:
	ld.bu	d5,[a15]6
.L327:
	ld.bu	d6,[a15]7
.L175:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     1  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     2  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     3  #ifndef COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     4  #define COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     5  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     6  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     7   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     8   * Includes
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     9   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    10  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    11  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    12  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    13  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    17  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    18  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    19  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    20  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    21   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    22   * Type definitions
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    23   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    24  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    25  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    26  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    27  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    28   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    29   * Variables
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    30   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    31  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    32  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    33  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    34  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    35   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    36   * Extern declarations
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    37   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    38  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    39  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    40   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    41   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    42   * Inline function sets TMS data in to be accessesd via CurrentTxModePtr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    43   * after evaluating TMS mode for the IPdu
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    44   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    45  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    46  FUNC(void, COM_CODE) Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    47                                  Com_TxIpduRamPtrType                TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    48                                  Com_TxIpduConstPtrType              TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    49                                  VAR(uint16,AUTOMATIC)               TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    50                                  VAR(boolean,AUTOMATIC)              ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    51                                              );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    52  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    53  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    54   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    55   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    56   * Inline function to update Rx-GroupSignal application buffers
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    57   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    58  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    59  FUNC(void, COM_CODE) Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    60                                  Com_RxSigConstPtrType               RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    61                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    62                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    63                                               );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    64  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    65  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    66   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    67   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    68   * Inline function to update Rx-GroupSignal secondary buffers
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    69   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    70  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    71  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    72  FUNC(void, COM_CODE) Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    73                                  Com_RxGrpSigConstPtrType            RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    74                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    75                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    76                                                          );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    77  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    78  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    79  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    80   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    81   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    82   * Inline function to initialize signal intial value into the provided IPdu buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    83   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    84  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    85  FUNC(void, COM_CODE) Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    86                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    87                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    88                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    89                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    90                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    91                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    92                                                              );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    93  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    94  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    95   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    96   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    97   * Inline function to initialize Rx-signal group with initial values
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    98   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    99  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   100  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   101  FUNC(void, COM_CODE) Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   102                                  Com_RxSigGrpConstPtrType            RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   103                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   104                                                  );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   105  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   106  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   107  #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   108  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxNotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   109  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxErrNotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   110  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxTONotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   111  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallRxTONotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   112  #endif /* #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   113  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   114  /* Inline function to check for the RxIPdu and TxIpdu status*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   115  LOCAL_INLINE boolean Com_CheckRxIPduStatus(PduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   116  LOCAL_INLINE boolean Com_CheckTxIPduStatus(PduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   117  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   118  #if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   119  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   120  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Void(uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   121  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   122  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Ptr(boolean isInValidPtr, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   123  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Param_Ptr(boolean isInValidParam, boolean isInValidPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   124                                                                  uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   125  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Ptr_Only(boolean isInValidPtr, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   126  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Param_Only(boolean isInValidParam, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   127  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   128  #endif /*  #if (COM_CONFIGURATION_USE_DET == STD_ON) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   129  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   130  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   131  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   132  LOCAL_INLINE FUNC(void, COM_CODE) Com_CopyTxGroupSignalData( Com_SignalIdType    GrpSignalId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   133                                                               Com_SigMaxType      TxGrpSig_NewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   134                                                               Com_MainFuncType    TxMainFuncId );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   135  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   136  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   137  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   138   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   139   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   140   * Inline function to handle gateway and non-gateway use-case for tx-signal/signalGroup
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   141   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   142  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_ProceedToSendIpdu(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   143                                                  VAR(Com_IpduIdType, AUTOMATIC)          ComTxPduId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   144                                                  VAR(Com_SendIpduInfo, AUTOMATIC)        sendIpduFlag_u16
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   145                                                             );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   146  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   147  #ifdef COM_TxFilters
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   148  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_CheckModeChange(VAR(Com_IpduIdType, AUTOMATIC) TxIpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   149  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   150  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   151  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   152  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   153   * Inline Function Definition
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   154   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   155  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   156  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   157   Function name    : Com_SetCurrentTxModePtr [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   158   Syntax           : void Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   159                                  Com_TxIpduRamPtrType    TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   160                                  Com_TxIpduConstPtrType  TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   161                                  uint16                  TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   162                                  boolean                 ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   163                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   164   Description      : Inline function sets TMS data in to be accessesd via CurrentTxModePtr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   165                      after evaluating TMS mode for the IPdu
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   166  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   167                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   168                       * Mode                  |    Configuration details                              | Value|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   169                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   170                       * COM_MODE_VALID        |    Both the TRUE and FALSE modes are configured.      |    00|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   171                       * COM_TRUEMODE_VALID    |    Only TRUE mode is configured                       |    01|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   172                       * COM_FALSEMODE_VALID   |    Only FALSE mode is configured                      |    10|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   173                       * COM_MODE_INVALID      |    Both the TRUE and FALSE mode are not configured    |    11|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   174                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   175                      This INLINE function checks the TMS generated values against the requested mode and performs action
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   176                      |-------------|--------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   177                      |ModeRequested|Configured Mode values   |         Description                                           :      Action to be taken                |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   178                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   179                      |    0       |      0        |      0   |  FALSE mode is requested and IPdu TMS is COM_MODE_VALID         : Increment to the false mode data     |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   180                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   181                      |    0       |      0        |      1   |  FALSE mode is requested and IPdu TMS is COM_TRUEMODE_VALID     : Point to NONE mode data              |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   182                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   183                      |    0       |      1        |      0   |  FALSE mode is requested and IPdu TMS is COM_FALSEMODE_VALID     : Do nothing                          |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   184                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   185                      |    0       |      1        |      1   |  FALSE mode is requested and IPdu TMS is COM_MODE_INVALID     : Do nothing                             |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   186                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   187                      |    1       |      0        |      0   |  TRUE mode is requested and IPdu TMS is COM_MODE_VALID         : Do nothing                            |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   188                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   189                      |    1       |      0        |      1   |  TRUE mode is requested and IPdu TMS is COM_TRUEMODE_VALID     : Do nothing                            |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   190                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   191                      |    1       |      1        |      0   |  TRUE mode is requested and IPdu TMS is COM_FALSEMODE_VALID     : Point to NONE mode data              |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   192                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   193                      |    1       |      1        |      1   |  TRUE mode is requested and IPdu TMS is COM_MODE_INVALID         : Do nothing                          |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   194                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   195  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   196                      where 0 in column 1 stands for FALSE mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   197                      and   1 in column 1 stands for TRUE mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   198  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   199   Parameter        : TxIpduRamPtr    - pointer to Txipdu ram data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   200                    : TxIPduConstPtr  - pointer to Txipdu Rom data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   201                    : TMSStatus       - pointer to transmission mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   202                    : ModeRequested   - mode requested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   203   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   204   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   205  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   206  FUNC(void, COM_CODE) Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   207                                  Com_TxIpduRamPtrType                TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   208                                  Com_TxIpduConstPtrType              TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   209                                  VAR(uint16,AUTOMATIC)               TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   210                                  VAR(boolean,AUTOMATIC)              ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   211                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   212  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   213      /* Get the latest TM pointer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   214      TxIpduRamPtr->CurrentTxModePtr = TxIPduConstPtr->Com_TMConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   215  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   216      if(ModeRequested == COM_FALSE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   217      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   218          if((TMSStatus) == COM_TRUEMODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   219          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   220              /*If yes,load NONE mode data */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   221              TxIpduRamPtr->CurrentTxModePtr = &Com_NONE_TransModeInfo ;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   222          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   223          if((TMSStatus) == COM_MODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   224          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   225              /*Increment to FALSE mode data, if the FALSE mode is configured */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   226              TxIpduRamPtr->CurrentTxModePtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   227          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   228      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   229      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   230      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   231          if((TMSStatus) == COM_FALSEMODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   232          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   233              TxIpduRamPtr->CurrentTxModePtr = &Com_NONE_TransModeInfo ;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   234          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   235      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   236  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   237  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   238  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   239   Function name    : Com_UpdateRxGroupSignalSecondBuffer [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   240   Syntax           : void Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   241                                  Com_RxGrpSigConstPtrType    RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   242                                  Com_SigMaxType              RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   243                                  Com_MainFuncType            RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   244                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   245   Description      : Inline function copy Group signal value into the Group signal Second buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   246   Parameter        : RxGrpSigConstPtr - pointer to RxGroupSignal configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   247                    : RxNewVal         - latest RxGroupSignal data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   248                    : RxMainFuncId     - Internally generated Rx-MainFunction-Id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   249   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   250   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   251  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   252  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   253  FUNC(void, COM_CODE) Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   254                                  Com_RxGrpSigConstPtrType            RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   255                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   256                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   257                                                          )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   258  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   259      VAR(uint8,AUTOMATIC)    Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   260  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   261      Type = Com_GetValue(RXGRPSIG,_TYPE,RxGrpSigConstPtr->rxGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   262  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   263      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   264      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   265      case 0x00u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   266          /* UINT08 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   267          COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint8)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   268          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   269  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   270      case 0x01u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   271          /* UINT16 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   272          COM_GET_SECRXGRPSIGTYPEU16_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint16)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   273          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   274  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   275      case 0x02u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   276          /* UINT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   277          /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   278      case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   279          /* FLOAT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   280          /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   281          COM_GET_SECRXGRPSIGTYPEU32_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint32)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   282          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   283  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   284  #ifdef COM_RXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   285      case 0x08u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   286          /* UINT64/SINT64 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   287          COM_GET_SECRXGRPSIGTYPEU64_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   288          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   289  #endif /* #ifdef COM_RXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   290  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   291      case 0x03u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   292          /*Boolean Signal*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   293          COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint8)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   294          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   295  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   296      case 0x04u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   297          /* UINT8_N signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   298          Com_ByteCopyInit(&COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index),
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   299                           (uint32)RxNewVal,RxGrpSigConstPtr->BitSize);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   300          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   301      default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   302          /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   303           * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are allowed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   304           * to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   305           */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   306          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   307  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   308      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   309  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   310  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   311  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   312  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   313   Function name    : Com_UpdateRxSignalBuffer [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   314   Syntax           : void Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   315                                  Com_RxSigConstPtrType   RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   316                                  Com_SigMaxType          RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   317                                  Com_MainFuncType        RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   318                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   319   Description      : Inline function to copy signal value into the signal buffer and
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   320                      is used when signal value as a variable is being passed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   321   Parameter        : RxSigConstPtr - pointer to RxSignal configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   322                    : RxNewVal_Sig  - latest RxSignal data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   323                    : RxMainFuncId  - Internally generated Rx-MainFunction-Id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   324   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   325   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   326  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   327  FUNC(void, COM_CODE) Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   328                                  Com_RxSigConstPtrType               RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   329                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   330                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   331                                               )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   332  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   333      VAR(uint8,AUTOMATIC)    Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   334  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   335      Type = Com_GetValue(GEN,_TYPE,RxSigConstPtr->General);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   336  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   337      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   338      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   339      case 0x00u:     /* COM_UINT8 & COM_SINT8 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   340      case (COM_BOOLEAN >> 1):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   341          COM_GET_SIGTYPEUINT8_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint8)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   342          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   343  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   344      case 0x01u:     /* COM_UINT16 & COM_SINT16 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   345          COM_GET_SIGTYPEUINT16_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint16)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   346          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   347  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   348      case 0x02u:     /* COM_UINT32 & COM_SINT32 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   349  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   350          /* COM_FLOAT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   351  #ifdef COM_FLOAT32SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   352      case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   353  #endif /* #ifdef COM_FLOAT32SUPP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   354  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   355          COM_GET_SIGTYPEUINT32_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint32)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   356          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   357  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   358  #ifdef COM_RXSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   359      case 0x08u:     /* COM_UINT64 & COM_SINT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   360          COM_GET_SIGTYPEUINT64_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   361          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   362  #endif /* #if defined(COM_RXSIG_INT64) && defined(COM_TXSIG_INT64) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   363  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   364      case 0x04u:     /* COM_UINT8_N */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   365          Com_ByteCopyInit(&COM_GET_SIGTYPEUINT8_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index),
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   366                           (uint32)RxNewVal_Sig,RxSigConstPtr->BitSize);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   367          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   368      default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   369          /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   370           * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are allowed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   371           * to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   372           */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   373          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   374      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   375  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   376  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   377  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   378   Function name    : Com_InitializePduBuffWithSignalInitValue [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   379   Syntax           : void Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   380                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   381                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   382                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   383                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   384                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   385                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   386                                                                   )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   387   Description      : Inline function to call required interface to pack signal data into Ipdu buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   388   Parameter        : BuffPtr     - pointer to (SignalGroup)IPdu Buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   389                    : SigInitVal  - (Group)Signal InitValue
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   390                    : SigBitPos   - (Group)Signal Bit Position
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   391                    : SigBitSize  - (Group)Signal Bit Size
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   392                    : SigType     - (Group)Signal Type
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   393                    : SigEndianess- (Group)Signal Endianness
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   394   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   395   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   396  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   397  FUNC(void, COM_CODE) Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   398                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   399                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   400                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   401                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   402                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   403                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   404                                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   405  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   406      if ( SigType != (uint8)COM_UINT8_N )
	mov	d15,#8
.L328:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   406      if ( SigType != (uint8)COM_UINT8_N )      (inlined)
	jeq	d15,d0,.L41
.L329:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   407      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   408  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   409  #if (defined(COM_TXSIG_FLOAT64SUPP) || defined(COM_TXGRPSIG_FLOAT64SUPP) ||\ 
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   410      (defined(COM_RX_SIGNALGROUP_ARRAY) && defined(COM_RXGRPSIG_FLOAT64SUPP)))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   411          if ( SigType == COM_FLOAT64 )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   412          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   413              /* Convert the float value into 32 bit stream and then pack the value */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   414              /* Com_PackFloatSignal(TxSigConstPtr->General.Endianess,TxSigConstPtr->Bit_Pos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   415                                     Com_getfloat64InitValue(SigNewVal), TxIPduConstPtr->BuffPtr); */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   416              Com_PackFloatSignal( SigEndianess, SigBitPos, Com_getfloat64InitValue(SigInitVal), BuffPtr );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   417          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   418          else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   419  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   420  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   421          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   422              /* Pack the signal with Initial Value */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   423              /* Com_PackSignal(TxSigConstPtr->General.Endianess,TxSigConstPtr->Bit_Pos,TxSigConstPtr->BitSize,SigNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   424               *                TxIPduConstPtr->BuffPtr);*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   425              Com_PackSignal( SigEndianess, SigBitPos, SigBitSize, SigInitVal, BuffPtr );
	call	Com_PackSignal
.L219:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   425              Com_PackSignal( SigEndianess, SigBitPos, SigBitSize, SigInitVal, BuffPtr );      (inlined)
	j	.L42

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   406      if ( SigType != (uint8)COM_UINT8_N )      (inlined)
.L41:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   426          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   427      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   428      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   429      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   430          PduLengthType ByteOffset_uo;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   431          /* Find the starting byte position(ByteNo_uo) of Signal in the IPDU buffer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   432          ByteOffset_uo = ( PduLengthType )( SigBitPos >> 3 );
	sha	d5,#-3
.L330:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   433  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   434          /* Now copy the Signal into the IPDU buffer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   435          Com_ByteCopyInit( (BuffPtr + ByteOffset_uo), (uint32)SigInitVal, SigBitSize );
	addsc.a	a4,a4,d5,#0
.L331:
	mov	e4,d6,d7
.L220:
	call	Com_ByteCopyInit

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   428      else      (inlined)
.L42:

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   573  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   574  #if (defined(COM_TxFilters) && defined(COM_F_MASKEDNEWDIFFERSOLD)) || defined(COM_EffectiveSigTOC)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   575          /* Load the signal property to variable */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   576          ConstByteValue_u16 = TxSigConstPtr->txSignalFields;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   577  #endif /* #if (defined(COM_TxFilters) && defined(COM_F_MASKEDNEWDIFFERSOLD)) || defined(COM_EffectiveSigTOC) */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   578  #if (defined(COM_TxFilters) && defined(COM_F_MASKEDNEWDIFFERSOLD))
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   579          /* The old value of the filter is set to Initial value */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   580          if(Com_GetValue(TXSIG,_FILTRALG,ConstByteValue_u16) == (uint16)COM_MASKED_NEW_DIFFERS_MASKED_OLD)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   581          {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   582              COM_GET_F_OLDVALUE(TxSigConstPtr->Filter_Index) = (uint32)TxSigNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   583          }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   584  #endif /* #if (defined(COM_TxFilters) && defined(COM_F_MASKEDNEWDIFFERSOLD)) */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   585  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   586  #ifdef COM_EffectiveSigTOC
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   587          /* Get Signal Transfer Property */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   588          TxSigTp_u16 = Com_GetValue(TXSIG,_TP,ConstByteValue_u16);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   589          /* MR12 RULE 13.5 VIOLATION: Below conditional statement reads signal field status.
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   590          * HIS-LEVEL parameter will be violated if more conditional statements are added.
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   591          * Hence the warning is suppressed. */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   592  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   593          /* Assign Init value as Old Value, if Signal's Transfer property is TriggeredOnChange or
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   594           * TriggeredOnChangeWithoutRepetition */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   595          if (COM_SIG_TP_IS_TRIGGERED_ON_CHANGE(TxSigTp_u16))
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   596          {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   597              COM_GET_OLDVALTRIGONCHANGE(TxSigConstPtr->OldValue_Index) = (Com_OldValTrigOnChngType)TxSigNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   598          }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   599  #endif /* #ifdef COM_EffectiveSigTOC */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   600  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   601  #ifdef COM_TxSigUpdateBit
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   602          /* Only the first byte of txIPduFields is needed */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   603          ConstByteValue_u8 = (uint8)TxIPduConstPtr->txIPduFields;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   604          /* Check the clear update bit */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   605          /* MR12 RULE 13.5 VIOLATION: Below conditional statement reads signal field status.
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   606          * HIS-LEVEL parameter will be violated if more conditional statements are added.
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   607          * Hence the warning is suppressed. */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   608          if((Com_GetValue(TXIPDU,_CLRUPDBIT,ConstByteValue_u8) != (uint16)COM_CLRUPDATEBIT_NONE) &&
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   609                  (Com_GetValue(GEN,_UPDBITCONF,TxSigConstPtr->General)))
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   610          {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   611              /*Find the Byte No*/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   612              ByteNo_u8 = (PduLengthType)(TxSigConstPtr->Update_Bit_Pos>>3u);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   613  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   614              /*Update the Bit in IPDU Buffer*/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   615              Com_ClearUpdateBitValue(TxIPduConstPtr, TxSigConstPtr->Update_Bit_Pos, ByteNo_u8)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   616          }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   617  #endif/*COM_TxSigUpdateBit*/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   618          TxSigConstPtr++;
	lea	a15,[a15]12
.L332:
	add	d9,#-1

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   541      for(Idx_ByteNSig_ui = TxIPduConstPtr->No_Of_Sig_Ref; Idx_ByteNSig_ui != COM_ZERO; Idx_ByteNSig_ui--)      (inlined)
.L35:
	jne	d9,#0,.L36
.L155:
	lea	a13,[a13]24
.L333:
	lea	a12,[a12]16
.L334:
	add	d8,#1

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   382      for(Idx_ui = COM_ZERO; Idx_ui < COM_GET_NUM_TX_IPDU; Idx_ui++)      (inlined)
.L26:
	jlt.u	d8,#4,.L27
.L122:
	movh.a	a15,#@his(Com_Uninit_Flag)
	lea	a15,[a15]@los(Com_Uninit_Flag)
.L335:
	mov	d15,#1
.L336:
	st.w	[a15],d15
.L337:
	ret
.L58:
	
__Com_Init_function_end:
	.size	Com_Init,__Com_Init_function_end-Com_Init
.L53:
	; End of function
	
	.sdecl	'.bss.Com_Init.Com_Uninit_Flag',data,cluster('Com_Uninit_Flag')
	.sect	'.bss.Com_Init.Com_Uninit_Flag'
	.global	Com_Uninit_Flag
	.align	4
Com_Uninit_Flag:	.type	object
	.size	Com_Uninit_Flag,4
	.space	4
	.sdecl	'.bss.Com_Init.Com_Prv_Config_pcst',data,cluster('Com_Prv_Config_pcst')
	.sect	'.bss.Com_Init.Com_Prv_Config_pcst'
	.global	Com_Prv_Config_pcst
	.align	4
Com_Prv_Config_pcst:	.type	object
	.size	Com_Prv_Config_pcst,4
	.space	4
	.calls	'Com_Init','Com_ByteCopyInit'
	.calls	'Com_Init','Com_PackSignal'
	.extern	Com_ByteCopyInit
	.extern	Com_PackSignal
	.extern	Com_RxIpduRam_s
	.extern	Com_TxIpduRam_s
	.extern	Com_RxSignalFlag
	.extern	Com_IpduCounter_s
	.extern	Com_IpduCounter_DM
	.extern	Com_IpduGrpVector
	.extern	Com_IpduGrpVector_DM
	.extern	Com_Prv_xTxSigCfg_acst
	.extern	Com_Prv_xRxSigCfg_acst
	.extern	Com_Prv_xTxIpduCfg_acst
	.extern	Com_Prv_xRxIpduCfg_acst
	.extern	Com_Prv_xRxRamBuf_acst
	.calls	'Com_Init','',8
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L46:
	.word	16675
	.half	3
	.word	.L47
	.byte	4
.L45:
	.byte	1
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Init.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L48
.L89:
	.byte	2
	.byte	'unsigned char',0,1,8,3
	.word	134
.L70:
	.byte	2
	.byte	'unsigned int',0,4,7
.L61:
	.byte	4
	.byte	'rba_BswSrv_MemSet8',0,3,1,251,3,19,1,1
.L63:
	.byte	5
	.byte	'xDest_pu8',0,1,251,3,45
	.word	151
.L65:
	.byte	5
	.byte	'xPattern_u32',0,1,251,3,63
	.word	156
.L67:
	.byte	5
	.byte	'numBytes_u32',0,1,251,3,84
	.word	156
.L69:
	.byte	6,0
.L128:
	.byte	2
	.byte	'unsigned short int',0,2,7
.L132:
	.byte	7
	.byte	'Bfx_Prv_GetBit_u16u8_u8_Inl',0,3,2,207,2,22
	.word	134
	.byte	1,1
.L134:
	.byte	5
	.byte	'Data',0,2,207,2,57
	.word	264
.L136:
	.byte	5
	.byte	'BitPn',0,2,207,2,69
	.word	134
.L138:
	.byte	6,0,7
	.byte	'Bfx_Prv_GetBit_u32u8_u8_Inl',0,3,2,227,2,22
	.word	134
	.byte	1,1,5
	.byte	'Data',0,2,227,2,57
	.word	156
	.byte	5
	.byte	'BitPn',0,2,227,2,69
	.word	134
	.byte	6,0
.L167:
	.byte	7
	.byte	'Bfx_Prv_GetBit_u8u8_u8_Inl',0,3,2,247,2,22
	.word	134
	.byte	1,1
.L169:
	.byte	5
	.byte	'Data',0,2,247,2,55
	.word	134
.L171:
	.byte	5
	.byte	'BitPn',0,2,247,2,67
	.word	134
.L173:
	.byte	6,0
.L112:
	.byte	7
	.byte	'Bfx_Prv_GetBits_u8u8u8_u8_Inl',0,3,2,179,3,20
	.word	134
	.byte	1,1
.L114:
	.byte	5
	.byte	'Data',0,2,179,3,56
	.word	134
.L116:
	.byte	5
	.byte	'BitStartPn',0,2,179,3,68
	.word	134
.L118:
	.byte	5
	.byte	'BitLn',0,2,179,3,86
	.word	134
.L120:
	.byte	6,0,3
	.word	264
	.byte	4
	.byte	'Bfx_Prv_PutBit_u16u8u8_Inl',0,3,2,200,3,19,1,1,5
	.byte	'Data',0,2,200,3,54
	.word	591
	.byte	5
	.byte	'BitPn',0,2,200,3,66
	.word	134
	.byte	5
	.byte	'Value',0,2,200,3,81
	.word	134
	.byte	6,0,3
	.word	156
	.byte	4
	.byte	'Bfx_Prv_PutBit_u32u8u8_Inl',0,3,2,224,3,19,1,1,5
	.byte	'Data',0,2,224,3,54
	.word	677
	.byte	5
	.byte	'BitPn',0,2,224,3,66
	.word	134
	.byte	5
	.byte	'Value',0,2,224,3,81
	.word	134
	.byte	6,0
.L91:
	.byte	4
	.byte	'Bfx_Prv_PutBit_u8u8u8_Inl',0,3,2,248,3,19,1,1
.L94:
	.byte	5
	.byte	'Data',0,2,248,3,52
	.word	151
.L96:
	.byte	5
	.byte	'BitPn',0,2,248,3,64
	.word	134
.L98:
	.byte	5
	.byte	'Value',0,2,248,3,79
	.word	134
.L100:
	.byte	6,0
.L142:
	.byte	4
	.byte	'Bfx_Prv_PutBits_u8u8u8u8_Inl',0,3,2,193,4,19,1,1
.L144:
	.byte	5
	.byte	'Data',0,2,193,4,55
	.word	151
.L146:
	.byte	5
	.byte	'BitStartPn',0,2,193,4,67
	.word	134
.L148:
	.byte	5
	.byte	'BitLn',0,2,193,4,85
	.word	134
.L150:
	.byte	5
	.byte	'Pattern',0,2,193,4,98
	.word	134
.L152:
	.byte	6,0,7
	.byte	'Bfx_Prv_TstParityEven_u32_u8_Inl',0,3,2,143,10,22
	.word	134
	.byte	1,1,5
	.byte	'Data',0,2,143,10,62
	.word	156
	.byte	6,0,8,1,1,3
	.word	1009
	.byte	9,4,247,1,9,16,10
	.byte	'Notification_Cbk',0
	.word	1012
	.byte	4,2,35,0,10
	.byte	'Init_Val',0
	.word	156
	.byte	4,2,35,4,10
	.byte	'Bit_Pos',0
	.word	134
	.byte	1,2,35,8,10
	.byte	'SigBuff_Index',0
	.word	134
	.byte	1,2,35,9,10
	.byte	'BitSize',0
	.word	134
	.byte	1,2,35,10,10
	.byte	'IpduRef',0
	.word	134
	.byte	1,2,35,11,10
	.byte	'General',0
	.word	134
	.byte	1,2,35,12,10
	.byte	'rxSignalFields',0
	.word	134
	.byte	1,2,35,13,0,11
	.word	1017
	.byte	3
	.word	1183
.L81:
	.byte	12
	.byte	'Com_RxSigConstPtrType',0,4,180,2,68
	.word	1188
.L102:
	.byte	4
	.byte	'Com_UpdateRxSignalBuffer',0,3,3,199,2,22,1,1
.L104:
	.byte	5
	.byte	'RxSigConstPtr',0,3,200,2,69
	.word	1193
.L106:
	.byte	5
	.byte	'RxNewVal_Sig',0,3,201,2,69
	.word	156
.L108:
	.byte	5
	.byte	'RxMainFuncId',0,3,202,2,69
	.word	134
.L110:
	.byte	13,6,0,0,11
	.word	1017
	.byte	3
	.word	1328
.L174:
	.byte	4
	.byte	'Com_InitializePduBuffWithSignalInitValue',0,3,3,141,3,22,1,1
.L176:
	.byte	5
	.byte	'BuffPtr',0,3,142,3,73
	.word	151
.L178:
	.byte	5
	.byte	'SigInitVal',0,3,143,3,73
	.word	156
.L180:
	.byte	5
	.byte	'SigBitPos',0,3,144,3,73
	.word	134
.L182:
	.byte	5
	.byte	'SigBitSize',0,3,145,3,73
	.word	134
.L184:
	.byte	5
	.byte	'SigType',0,3,146,3,73
	.word	134
.L186:
	.byte	5
	.byte	'SigEndianess',0,3,147,3,73
	.word	134
.L188:
	.byte	13
.L189:
	.byte	6,0,0
.L74:
	.byte	4
	.byte	'Com_Prv_Init_Receive',0,3,5,210,1,35,1,1
.L76:
	.byte	13,6,6,0,0
.L121:
	.byte	4
	.byte	'Com_Prv_Init_Send',0,3,5,241,2,35,1,1
.L123:
	.byte	13,6,6,6,6,6,0,0
.L153:
	.byte	4
	.byte	'Com_Prv_Init_TxSignal',0,3,5,128,4,35,1,1
.L156:
	.byte	5
	.byte	'IpduId',0,5,128,4,83
	.word	264
.L158:
	.byte	13,6,6,6,0,0,14
	.byte	'void',0,11
	.word	1626
	.byte	3
	.word	1632
	.byte	9,7,206,1,9,8,10
	.byte	'vendorID',0
	.word	264
	.byte	2,2,35,0,10
	.byte	'moduleID',0
	.word	264
	.byte	2,2,35,2,10
	.byte	'sw_major_version',0
	.word	134
	.byte	1,2,35,4,10
	.byte	'sw_minor_version',0
	.word	134
	.byte	1,2,35,5,10
	.byte	'sw_patch_version',0
	.word	134
	.byte	1,2,35,6,0,11
	.word	1642
	.byte	3
	.word	1763
	.byte	9,6,203,2,9,8,10
	.byte	'Com_ConfigData',0
	.word	1637
	.byte	4,2,35,0,10
	.byte	'versionInfo',0
	.word	1768
	.byte	4,2,35,4,0,11
	.word	1773
.L59:
	.byte	3
	.word	1825
	.byte	9,4,218,9,9,6,10
	.byte	'RxIPduLength',0
	.word	264
	.byte	2,2,35,0,10
	.byte	'RxTicks_u16',0
	.word	264
	.byte	2,2,35,2,10
	.byte	'RxFlags',0
	.word	134
	.byte	1,2,35,4,0,3
	.word	1835
	.byte	3
	.word	1835
.L77:
	.byte	12
	.byte	'Com_RxIpduRamPtrType',0,4,254,9,62
	.word	1907
	.byte	9,4,137,7,9,20,10
	.byte	'BuffPtr',0
	.word	151
	.byte	4,2,35,0,10
	.byte	'TimeOutNotification_Cbk',0
	.word	1012
	.byte	4,2,35,4,10
	.byte	'Size',0
	.word	264
	.byte	2,2,35,8,10
	.byte	'FirstTimeout_Factor',0
	.word	264
	.byte	2,2,35,10,10
	.byte	'Timeout_Fact',0
	.word	264
	.byte	2,2,35,12,10
	.byte	'No_Of_Sig_Ref',0
	.word	264
	.byte	2,2,35,14,10
	.byte	'RxSigId_Index',0
	.word	134
	.byte	1,2,35,16,10
	.byte	'MainFunctionRef',0
	.word	134
	.byte	1,2,35,17,10
	.byte	'rxIPduFields',0
	.word	134
	.byte	1,2,35,18,0,11
	.word	1942
	.byte	3
	.word	2157
	.byte	11
	.word	1942
	.byte	3
	.word	2167
.L79:
	.byte	12
	.byte	'Com_RxIpduConstPtrType',0,4,206,7,72
	.word	2172
.L83:
	.byte	2
	.byte	'unsigned long int',0,4,7,9,4,167,8,9,1,10
	.byte	'rxSigRAMFields',0
	.word	134
	.byte	1,2,35,0,0,3
	.word	2230
	.byte	3
	.word	2230
.L86:
	.byte	12
	.byte	'Com_RxSigRamPtrType',0,4,180,8,65
	.word	2266
	.byte	9,4,76,9,8,10
	.byte	'TimePeriodFact',0
	.word	264
	.byte	2,2,35,0,10
	.byte	'TimeOffsetFact',0
	.word	264
	.byte	2,2,35,2,10
	.byte	'RepetitionPeriodFact',0
	.word	264
	.byte	2,2,35,4,10
	.byte	'NumOfRepetitions',0
	.word	134
	.byte	1,2,35,6,10
	.byte	'Mode',0
	.word	134
	.byte	1,2,35,7,0,11
	.word	2300
	.byte	3
	.word	2424
	.byte	12
	.byte	'Com_TMConstPtrType',0,4,103,65
	.word	2429
	.byte	9,4,135,9,9,16,10
	.byte	'CurrentTxModePtr',0
	.word	2434
	.byte	4,2,35,0,10
	.byte	'Com_MinDelayTick',0
	.word	264
	.byte	2,2,35,4,10
	.byte	'Com_Tick_Tx',0
	.word	264
	.byte	2,2,35,6,10
	.byte	'Com_n_Tick_Tx',0
	.word	264
	.byte	2,2,35,8,10
	.byte	'Com_TickTxTimeout',0
	.word	264
	.byte	2,2,35,10,10
	.byte	'Com_TxFlags',0
	.word	264
	.byte	2,2,35,12,10
	.byte	'Com_n',0
	.word	134
	.byte	1,2,35,14,10
	.byte	'Com_TransMode',0
	.word	134
	.byte	1,2,35,15,0,3
	.word	2461
	.byte	11
	.word	2300
	.byte	3
	.word	2655
	.byte	3
	.word	2461
.L124:
	.byte	12
	.byte	'Com_TxIpduRamPtrType',0,4,198,9,62
	.word	2665
	.byte	9,4,211,5,9,24,10
	.byte	'BuffPtr',0
	.word	151
	.byte	4,2,35,0,10
	.byte	'Com_TMConstPtr',0
	.word	2429
	.byte	4,2,35,4,10
	.byte	'Size',0
	.word	264
	.byte	2,2,35,8,10
	.byte	'Timeout_Fact',0
	.word	264
	.byte	2,2,35,10,10
	.byte	'Min_Delay_Time_Fact',0
	.word	264
	.byte	2,2,35,12,10
	.byte	'No_Of_Sig_Ref',0
	.word	264
	.byte	2,2,35,14,10
	.byte	'PdurId',0
	.word	264
	.byte	2,2,35,16,10
	.byte	'TxSigId_Index',0
	.word	134
	.byte	1,2,35,18,10
	.byte	'txIPduFields',0
	.word	264
	.byte	2,2,35,20,10
	.byte	'MainFunctionRef',0
	.word	134
	.byte	1,2,35,22,10
	.byte	'PaddingByte',0
	.word	134
	.byte	1,2,35,23,0,11
	.word	2700
	.byte	3
	.word	2943
	.byte	11
	.word	2700
	.byte	3
	.word	2953
.L126:
	.byte	12
	.byte	'Com_TxIpduConstPtrType',0,4,171,6,72
	.word	2958
	.byte	9,4,136,1,9,12,10
	.byte	'Init_Val',0
	.word	156
	.byte	4,2,35,0,10
	.byte	'txSignalFields',0
	.word	264
	.byte	2,2,35,4,10
	.byte	'Bit_Pos',0
	.word	134
	.byte	1,2,35,6,10
	.byte	'BitSize',0
	.word	134
	.byte	1,2,35,7,10
	.byte	'IpduRef',0
	.word	134
	.byte	1,2,35,8,10
	.byte	'General',0
	.word	134
	.byte	1,2,35,9,0,11
	.word	2995
	.byte	3
	.word	3112
	.byte	11
	.word	2995
	.byte	3
	.word	3122
.L160:
	.byte	12
	.byte	'Com_TxSigConstPtrType',0,4,209,1,68
	.word	3127
	.byte	15
	.word	172
	.byte	16
	.word	199
	.byte	16
	.word	218
	.byte	16
	.word	240
	.byte	6,0,15
	.word	286
	.byte	16
	.word	326
	.byte	16
	.word	340
	.byte	6,0,15
	.word	357
	.byte	16
	.word	397
	.byte	16
	.word	411
	.byte	6,0,15
	.word	428
	.byte	16
	.word	467
	.byte	16
	.word	481
	.byte	6,0,15
	.word	498
	.byte	16
	.word	540
	.byte	16
	.word	554
	.byte	16
	.word	574
	.byte	6,0,15
	.word	596
	.byte	16
	.word	631
	.byte	16
	.word	645
	.byte	16
	.word	660
	.byte	6,0,15
	.word	682
	.byte	16
	.word	717
	.byte	16
	.word	731
	.byte	16
	.word	746
	.byte	6,0,15
	.word	763
	.byte	16
	.word	797
	.byte	16
	.word	811
	.byte	16
	.word	826
	.byte	6,0,15
	.word	843
	.byte	16
	.word	880
	.byte	16
	.word	894
	.byte	16
	.word	914
	.byte	16
	.word	929
	.byte	6,0,15
	.word	948
	.byte	16
	.word	993
	.byte	6,0,17
	.byte	'Com_ByteCopyInit',0,8,130,21,22,1,1,1,1,5
	.byte	'dest',0,8,130,21,81
	.word	151
	.byte	5
	.byte	'Init_Val',0,8,131,21,81
	.word	156
	.byte	5
	.byte	'Len',0,8,132,21,81
	.word	156
	.byte	0,17
	.byte	'Com_PackSignal',0,8,150,21,22,1,1,1,1,5
	.byte	'Endianess',0,8,150,21,77
	.word	134
	.byte	5
	.byte	'Bit_Pos',0,8,151,21,77
	.word	134
	.byte	5
	.byte	'Bitsize',0,8,152,21,77
	.word	134
	.byte	5
	.byte	'Src_Buf',0,8,153,21,77
	.word	156
	.byte	5
	.byte	'Dest_Buf',0,8,154,21,77
	.word	151
	.byte	0,15
	.word	1224
	.byte	16
	.word	1257
	.byte	16
	.word	1280
	.byte	16
	.word	1302
	.byte	13,18
	.word	498
	.byte	16
	.word	540
	.byte	16
	.word	554
	.byte	16
	.word	574
	.byte	19
	.word	589
	.byte	0,6,0,0,15
	.word	1338
	.byte	16
	.word	1387
	.byte	16
	.word	1404
	.byte	16
	.word	1424
	.byte	16
	.word	1443
	.byte	16
	.word	1463
	.byte	16
	.word	1480
	.byte	13,6,0,0,15
	.word	1506
	.byte	13,18
	.word	763
	.byte	16
	.word	797
	.byte	16
	.word	811
	.byte	16
	.word	826
	.byte	19
	.word	841
	.byte	0,6,18
	.word	1224
	.byte	16
	.word	1257
	.byte	16
	.word	1280
	.byte	16
	.word	1302
	.byte	20
	.word	1324
	.byte	18
	.word	498
	.byte	16
	.word	540
	.byte	16
	.word	554
	.byte	16
	.word	574
	.byte	19
	.word	589
	.byte	0,19
	.word	1325
	.byte	0,0,6,0,0,15
	.word	1540
	.byte	13,18
	.word	286
	.byte	16
	.word	326
	.byte	16
	.word	340
	.byte	19
	.word	355
	.byte	0,6,18
	.word	172
	.byte	16
	.word	199
	.byte	16
	.word	218
	.byte	16
	.word	240
	.byte	19
	.word	262
	.byte	0,6,18
	.word	843
	.byte	16
	.word	880
	.byte	16
	.word	894
	.byte	16
	.word	914
	.byte	16
	.word	929
	.byte	19
	.word	946
	.byte	0,6,18
	.word	763
	.byte	16
	.word	797
	.byte	16
	.word	811
	.byte	16
	.word	826
	.byte	19
	.word	841
	.byte	0,6,18
	.word	1574
	.byte	16
	.word	1604
	.byte	20
	.word	1620
	.byte	18
	.word	428
	.byte	16
	.word	467
	.byte	16
	.word	481
	.byte	19
	.word	496
	.byte	0,19
	.word	1621
	.byte	18
	.word	498
	.byte	16
	.word	540
	.byte	16
	.word	554
	.byte	16
	.word	574
	.byte	19
	.word	589
	.byte	0,19
	.word	1622
	.byte	18
	.word	1338
	.byte	16
	.word	1387
	.byte	16
	.word	1404
	.byte	16
	.word	1424
	.byte	16
	.word	1443
	.byte	16
	.word	1463
	.byte	16
	.word	1480
	.byte	20
	.word	1502
	.byte	19
	.word	1503
	.byte	0,0,19
	.word	1623
	.byte	0,0,6,0,0,15
	.word	1574
	.byte	16
	.word	1604
	.byte	13,18
	.word	428
	.byte	16
	.word	467
	.byte	16
	.word	481
	.byte	19
	.word	496
	.byte	0,6,18
	.word	498
	.byte	16
	.word	540
	.byte	16
	.word	554
	.byte	16
	.word	574
	.byte	19
	.word	589
	.byte	0,6,18
	.word	1338
	.byte	16
	.word	1387
	.byte	16
	.word	1404
	.byte	16
	.word	1424
	.byte	16
	.word	1443
	.byte	16
	.word	1463
	.byte	16
	.word	1480
	.byte	20
	.word	1502
	.byte	19
	.word	1503
	.byte	0,0,6,0,0,21,1,3
	.word	4084
	.byte	12
	.byte	'__codeptr',0,5,1,1
	.word	4086
	.byte	2
	.byte	'char',0,1,6,12
	.byte	'sint8',0,9,76,25
	.word	4109
	.byte	12
	.byte	'uint8',0,9,81,25
	.word	134
	.byte	12
	.byte	'uint16',0,9,91,25
	.word	264
	.byte	12
	.byte	'uint32',0,9,106,24
	.word	156
	.byte	2
	.byte	'unsigned long long int',0,8,7,12
	.byte	'uint64',0,9,111,30
	.word	4175
	.byte	12
	.byte	'boolean',0,9,127,25
	.word	134
	.byte	12
	.byte	'StatusType',0,7,191,1,27
	.word	134
	.byte	12
	.byte	'Std_ReturnType',0,7,199,1,15
	.word	134
	.byte	12
	.byte	'Std_VersionInfoType',0,7,213,1,3
	.word	1642
	.byte	12
	.byte	'PduIdType',0,10,22,19
	.word	264
	.byte	12
	.byte	'PduLengthType',0,10,26,19
	.word	264
	.byte	22,11,113,9,4,23
	.byte	'TP_DATACONF',0,0,23
	.byte	'TP_DATARETRY',0,1,23
	.byte	'TP_CONFPENDING',0,2,0,12
	.byte	'TpDataStateType',0,11,118,3
	.word	4345
	.byte	12
	.byte	'Com_SignalIdType',0,12,100,16
	.word	264
	.byte	12
	.byte	'Com_SignalGroupIdType',0,12,102,16
	.word	264
	.byte	12
	.byte	'Com_IpduIdType',0,12,104,15
	.word	134
	.byte	12
	.byte	'Com_GrpSignalIdType',0,12,107,18
	.word	134
	.byte	24,1
	.word	134
	.byte	25,0,0,12
	.byte	'Com_IpduGroupVector',0,12,112,15
	.word	4527
.L191:
	.byte	22,12,117,9,4,23
	.byte	'COM_UNINIT',0,0,23
	.byte	'COM_INIT',0,1,0,12
	.byte	'Com_StatusType',0,12,121,2
	.word	4564
	.byte	12
	.byte	'Com_ConfigType',0,6,208,2,3
	.word	1773
	.byte	12
	.byte	'Com_TxIntSignalIdType',0,13,138,3,18
	.word	134
	.byte	12
	.byte	'Com_RxIntSignalIdType',0,13,139,3,18
	.word	134
	.byte	12
	.byte	'Com_BitsizeType',0,13,155,3,17
	.word	134
	.byte	12
	.byte	'Com_BitpositionType',0,13,156,3,15
	.word	134
	.byte	12
	.byte	'Com_RxGwQueueIndexType',0,13,161,3,15
	.word	134
	.byte	12
	.byte	'Com_SigBuffIndexType',0,13,164,3,15
	.word	134
	.byte	12
	.byte	'Com_SigMaxType',0,13,198,3,16
	.word	156
	.byte	12
	.byte	'Com_MainFuncType',0,13,231,3,16
	.word	134
	.byte	12
	.byte	'Com_NumOfIpdusType',0,13,233,3,15
	.word	134
	.byte	12
	.byte	'Com_TimeBaseType',0,13,235,3,15
	.word	134
	.byte	12
	.byte	'Can_IdType',0,14,32,16
	.word	156
	.byte	12
	.byte	'Can_HwHandleType',0,14,43,16
	.word	264
	.byte	9,15,93,9,8,10
	.byte	'Class',0
	.word	134
	.byte	1,2,35,0,10
	.byte	'TIN',0
	.word	134
	.byte	1,2,35,1,10
	.byte	'ReturnAddress',0
	.word	156
	.byte	4,2,35,4,0,12
	.byte	'OsTrapInfoType',0,15,97,3
	.word	4967
	.byte	24,68
	.word	156
	.byte	25,16,0,9,15,154,1,9,68,10
	.byte	'store',0
	.word	5047
	.byte	68,2,35,0,0,24,68
	.word	5056
	.byte	25,0,0,12
	.byte	'Os_JumpBufType',0,15,156,1,3
	.word	5078
	.byte	12
	.byte	'Os_StackTraceType',0,15,174,1,18
	.word	156
	.byte	9,15,175,1,9,8,10
	.byte	'sp',0
	.word	156
	.byte	4,2,35,0,10
	.byte	'ctx',0
	.word	156
	.byte	4,2,35,4,0,12
	.byte	'Os_StackValueType',0,15,175,1,63
	.word	5138
	.byte	12
	.byte	'Os_StackSizeType',0,15,176,1,27
	.word	5138
	.byte	12
	.byte	'Os_VoidVoidFunctionType',0,15,179,1,16
	.word	1012
	.byte	12
	.byte	'ApplicationType',0,15,193,1,23
	.word	134
	.byte	26
	.byte	'Os_ApplicationConfigurationType_s',0,15,198,1,16,2,10
	.byte	'app_id',0
	.word	134
	.byte	1,2,35,0,10
	.byte	'access',0
	.word	134
	.byte	1,2,35,1,0,12
	.byte	'Os_ApplicationConfigurationType',0,15,201,1,3
	.word	5281
	.byte	12
	.byte	'Os_CoreStateType',0,15,203,1,16
	.word	156
	.byte	12
	.byte	'AreaIdType',0,15,204,1,16
	.word	264
	.byte	12
	.byte	'Os_PeripheralAddressType',0,15,212,1,22
	.word	156
	.byte	12
	.byte	'TickType',0,15,221,1,22
	.word	156
	.byte	12
	.byte	'Os_StopwatchTickType',0,15,225,1,22
	.word	156
	.byte	12
	.byte	'Os_Lockable',0,15,234,1,18
	.word	677
	.byte	12
	.byte	'CoreIdType',0,15,236,1,16
	.word	264
	.byte	12
	.byte	'SpinlockIdType',0,15,237,1,16
	.word	264
	.byte	22,15,239,1,9,4,23
	.byte	'TRYTOGETSPINLOCK_SUCCESS',0,0,23
	.byte	'TRYTOGETSPINLOCK_NOSUCCESS',0,1,0,12
	.byte	'TryToGetSpinlockType',0,15,239,1,74
	.word	5588
	.byte	22,15,174,2,9,4,23
	.byte	'APPLICATION_ACCESSIBLE',0,0,23
	.byte	'APPLICATION_RESTARTING',0,1,23
	.byte	'APPLICATION_TERMINATED',0,2,0,12
	.byte	'ApplicationStateType',0,15,174,2,92
	.word	5681
	.byte	3
	.word	1626
	.byte	27,1,1,28
	.word	134
	.byte	28
	.word	5793
	.byte	0,3
	.word	5798
	.byte	12
	.byte	'Os_FunctionEntryType',0,15,183,2,16
	.word	5812
	.byte	26
	.byte	'Os_MeterInfoType_s',0,15,193,2,16,48,10
	.byte	'elapsed',0
	.word	156
	.byte	4,2,35,0,10
	.byte	'previous',0
	.word	156
	.byte	4,2,35,4,10
	.byte	'max',0
	.word	156
	.byte	4,2,35,8,10
	.byte	'cumulative',0
	.word	156
	.byte	4,2,35,12,10
	.byte	'stackbase',0
	.word	5138
	.byte	8,2,35,16,10
	.byte	'stackusage',0
	.word	5138
	.byte	8,2,35,24,10
	.byte	'stackmax',0
	.word	5138
	.byte	8,2,35,32,10
	.byte	'stackbudget',0
	.word	5138
	.byte	8,2,35,40,0,12
	.byte	'Os_MeterInfoType',0,15,202,2,3
	.word	5847
	.byte	3
	.word	5847
	.byte	12
	.byte	'Os_MeterInfoRefType',0,15,203,2,50
	.word	6045
	.byte	12
	.byte	'EventMaskType',0,15,206,2,15
	.word	134
	.byte	12
	.byte	'Os_imaskType',0,15,211,2,16
	.word	156
	.byte	26
	.byte	'Os_ISRDynType_s',0,15,213,2,16,48,10
	.byte	'meter',0
	.word	5847
	.byte	48,2,35,0,0,12
	.byte	'Os_ISRDynType',0,15,215,2,3
	.word	6124
	.byte	3
	.word	6124
	.byte	11
	.word	6185
	.byte	26
	.byte	'Os_ISRType_s',0,15,216,2,16,24,10
	.byte	'entry_function',0
	.word	5223
	.byte	4,2,35,0,10
	.byte	'dynamic',0
	.word	6190
	.byte	4,2,35,4,10
	.byte	'imask',0
	.word	156
	.byte	4,2,35,8,10
	.byte	'stackbudget',0
	.word	5138
	.byte	8,2,35,12,10
	.byte	'access',0
	.word	134
	.byte	1,2,35,20,10
	.byte	'application',0
	.word	134
	.byte	1,2,35,21,0,12
	.byte	'Os_ISRType',0,15,223,2,3
	.word	6195
	.byte	3
	.word	1009
	.byte	11
	.word	6195
	.byte	3
	.word	6354
	.byte	12
	.byte	'ISRType',0,15,224,2,46
	.word	6359
	.byte	12
	.byte	'Os_bitmask',0,15,239,2,22
	.word	156
	.byte	12
	.byte	'Os_pset0Type',0,15,240,2,20
	.word	156
	.byte	12
	.byte	'Os_pset1Type',0,15,241,2,20
	.word	156
	.byte	12
	.byte	'Os_pset2Type',0,15,242,2,20
	.word	156
	.byte	29,15,243,2,9,4,10
	.byte	'p0',0
	.word	156
	.byte	4,2,35,0,10
	.byte	'p1',0
	.word	156
	.byte	4,2,35,0,10
	.byte	'p2',0
	.word	156
	.byte	4,2,35,0,0,12
	.byte	'Os_psetType',0,15,247,2,3
	.word	6467
	.byte	29,15,249,2,9,4,10
	.byte	't0',0
	.word	156
	.byte	4,2,35,0,10
	.byte	't1',0
	.word	156
	.byte	4,2,35,0,10
	.byte	't2',0
	.word	156
	.byte	4,2,35,0,0,12
	.byte	'Os_tpmaskType',0,15,253,2,3
	.word	6531
	.byte	12
	.byte	'Os_ActivationCountType',0,15,254,2,23
	.word	134
	.byte	26
	.byte	'Os_TaskDynType_s',0,15,128,3,16,120,10
	.byte	'terminate_jump_buf',0
	.word	5087
	.byte	68,2,35,0,10
	.byte	'meter',0
	.word	5847
	.byte	48,2,35,68,10
	.byte	'activation_count',0
	.word	134
	.byte	1,2,35,116,0,12
	.byte	'Os_TaskDynType',0,15,132,3,3
	.word	6629
	.byte	24,68
	.word	5056
	.byte	25,0,0,3
	.word	6629
	.byte	11
	.word	6755
	.byte	26
	.byte	'Os_TaskType_s',0,15,134,3,16,40,10
	.byte	'dynamic',0
	.word	6760
	.byte	4,2,35,0,10
	.byte	'entry_function',0
	.word	5223
	.byte	4,2,35,4,10
	.byte	'pset',0
	.word	6467
	.byte	4,2,35,8,10
	.byte	'base_tpmask',0
	.word	6531
	.byte	4,2,35,12,10
	.byte	'tpmask',0
	.word	6531
	.byte	4,2,35,16,10
	.byte	'core_id',0
	.word	264
	.byte	2,2,35,20,10
	.byte	'index',0
	.word	156
	.byte	4,2,35,24,10
	.byte	'stackbudget',0
	.word	5138
	.byte	8,2,35,28,10
	.byte	'activation_count',0
	.word	134
	.byte	1,2,35,36,10
	.byte	'access',0
	.word	134
	.byte	1,2,35,37,10
	.byte	'application',0
	.word	134
	.byte	1,2,35,38,0,12
	.byte	'Os_TaskType',0,15,146,3,3
	.word	6765
	.byte	11
	.word	6765
	.byte	3
	.word	7015
	.byte	12
	.byte	'TaskType',0,15,147,3,47
	.word	7020
	.byte	30
	.byte	'Os_TaskStateType',0,15,155,3,6,4,23
	.byte	'SUSPENDED',0,0,23
	.byte	'READY',0,1,23
	.byte	'WAITING',0,2,23
	.byte	'RUNNING',0,3,0,12
	.byte	'TaskStateType',0,15,156,3,31
	.word	7043
	.byte	29,15,167,3,3,4,10
	.byte	'tpmask',0
	.word	6531
	.byte	4,2,35,0,0,26
	.byte	'Os_ResourceDynType_s',0,15,166,3,16,4,10
	.byte	'saved_priority',0
	.word	7130
	.byte	4,2,35,0,0,12
	.byte	'Os_ResourceDynType',0,15,170,3,3
	.word	7153
	.byte	3
	.word	7153
	.byte	11
	.word	7233
	.byte	26
	.byte	'Os_ResourceType_s',0,15,171,3,16,12,10
	.byte	'dynamic',0
	.word	7238
	.byte	4,2,35,0,10
	.byte	'tpmask',0
	.word	6531
	.byte	4,2,35,4,10
	.byte	'access',0
	.word	134
	.byte	1,2,35,8,0,12
	.byte	'Os_ResourceType',0,15,175,3,3
	.word	7243
	.byte	9,15,181,3,9,12,10
	.byte	'maxallowedvalue',0
	.word	156
	.byte	4,2,35,0,10
	.byte	'ticksperbase',0
	.word	156
	.byte	4,2,35,4,10
	.byte	'mincycle',0
	.word	156
	.byte	4,2,35,8,0,12
	.byte	'AlarmBaseType',0,15,185,3,3
	.word	7342
	.byte	9,15,206,3,9,8,10
	.byte	'Running',0
	.word	134
	.byte	1,2,35,0,10
	.byte	'Pending',0
	.word	134
	.byte	1,2,35,1,10
	.byte	'Delay',0
	.word	156
	.byte	4,2,35,4,0,12
	.byte	'Os_CounterStatusType',0,15,210,3,3
	.word	7437
	.byte	31
	.word	134
	.byte	1,1,3
	.word	7523
	.byte	12
	.byte	'Os_CounterIncrAdvType',0,15,217,3,22
	.word	7530
	.byte	26
	.byte	's_swd',0,15,222,3,12,4,10
	.byte	'count',0
	.word	156
	.byte	4,2,35,0,0,29,15,221,3,3,4,10
	.byte	'sw',0
	.word	7566
	.byte	4,2,35,0,0,26
	.byte	'Os_CounterDynType_s',0,15,220,3,16,4,10
	.byte	'type_dependent',0
	.word	7594
	.byte	4,2,35,0,0,12
	.byte	'Os_CounterDynType',0,15,226,3,3
	.word	7613
	.byte	3
	.word	7613
	.byte	11
	.word	7691
	.byte	26
	.byte	'Os_CounterType_s',0,15,227,3,16,28,10
	.byte	'dynamic',0
	.word	7696
	.byte	4,2,35,0,10
	.byte	'advincr',0
	.word	7535
	.byte	4,2,35,4,10
	.byte	'base',0
	.word	7342
	.byte	12,2,35,8,10
	.byte	'core',0
	.word	5793
	.byte	4,2,35,20,10
	.byte	'access',0
	.word	134
	.byte	1,2,35,24,10
	.byte	'application',0
	.word	134
	.byte	1,2,35,25,0,12
	.byte	'Os_CounterType',0,15,234,3,3
	.word	7701
	.byte	3
	.word	7523
	.byte	11
	.word	7701
	.byte	3
	.word	7853
	.byte	12
	.byte	'CounterType',0,15,235,3,52
	.word	7858
	.byte	30
	.byte	'Os_ScheduleTableStatusType',0,15,240,3,6,4,23
	.byte	'SCHEDULETABLE_STOPPED',0,0,23
	.byte	'SCHEDULETABLE_NEXT',0,1,23
	.byte	'SCHEDULETABLE_WAITING',0,2,23
	.byte	'SCHEDULETABLE_RUNNING',0,3,23
	.byte	'SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS',0,4,0,12
	.byte	'ScheduleTableStatusType',0,15,241,3,41
	.word	7884
	.byte	11
	.word	.L221-.L46
	.byte	3
	.word	8084
	.byte	12
	.byte	'ScheduleTableType',0,15,128,4,58
	.word	8089
	.byte	26
	.byte	'Os_ScheduleTableDynType_s',0,15,130,4,16,16,10
	.byte	'match',0
	.word	156
	.byte	4,2,35,0,10
	.byte	'next',0
	.word	8094
	.byte	4,2,35,4,10
	.byte	'state',0
	.word	7884
	.byte	4,2,35,8,10
	.byte	'config',0
	.word	264
	.byte	2,2,35,12,0,3
	.word	8121
	.byte	11
	.word	8214
.L221:
	.byte	26
	.byte	'Os_ScheduleTableType_s',0,15,247,3,16,16,10
	.byte	'dynamic',0
	.word	8219
	.byte	4,2,35,0,10
	.byte	'counter',0
	.word	7863
	.byte	4,2,35,4,10
	.byte	'repeat',0
	.word	134
	.byte	1,2,35,8,10
	.byte	'config',0
	.word	264
	.byte	2,2,35,10,10
	.byte	'initial',0
	.word	134
	.byte	1,2,35,12,10
	.byte	'access',0
	.word	134
	.byte	1,2,35,13,10
	.byte	'application',0
	.word	134
	.byte	1,2,35,14,0,12
	.byte	'Os_ScheduleTableType',0,15,255,3,3
	.word	8224
	.byte	11
	.word	8224
	.byte	3
	.word	8404
	.byte	11
	.word	7701
	.byte	3
	.word	8414
	.byte	32
	.word	5523
	.byte	32
	.word	6467
	.byte	32
	.word	6364
	.byte	32
	.word	7025
	.byte	32
	.word	6531
	.byte	32
	.word	134
	.byte	32
	.word	7025
	.byte	26
	.byte	'Os_ControlledCoreType_s',0,15,251,6,16,112,10
	.byte	'TrapInfo',0
	.word	4967
	.byte	8,2,35,0,10
	.byte	'lock_taskaccess',0
	.word	8424
	.byte	4,2,35,8,10
	.byte	'ReadyTasks',0
	.word	8429
	.byte	4,2,35,12,10
	.byte	'RunningISR',0
	.word	8434
	.byte	4,2,35,16,10
	.byte	'RunningTask',0
	.word	8439
	.byte	4,2,35,20,10
	.byte	'RunningTPMask',0
	.word	8444
	.byte	4,2,35,24,10
	.byte	'CurrentMeteredObject',0
	.word	6050
	.byte	4,2,35,28,10
	.byte	'IdleMeter',0
	.word	5847
	.byte	48,2,35,32,10
	.byte	'AppAccess',0
	.word	134
	.byte	1,2,35,80,10
	.byte	'AppOverride',0
	.word	8449
	.byte	1,2,35,81,10
	.byte	'GetStackValueAdjust',0
	.word	5138
	.byte	8,2,35,84,10
	.byte	'InErrorHook',0
	.word	134
	.byte	1,2,35,92,10
	.byte	'ChainTaskRef',0
	.word	8454
	.byte	4,2,35,96,10
	.byte	'GetStackUsageAdjust',0
	.word	5138
	.byte	8,2,35,100,10
	.byte	'InProtectionHook',0
	.word	134
	.byte	1,2,35,108,10
	.byte	'CoreIsActive',0
	.word	134
	.byte	1,2,35,109,10
	.byte	'InShutdownHook',0
	.word	134
	.byte	1,2,35,110,0,12
	.byte	'Os_ControlledCoreType',0,15,141,7,3
	.word	8459
	.byte	3
	.word	156
	.byte	11
	.word	6195
	.byte	3
	.word	8915
	.byte	11
	.word	6765
	.byte	3
	.word	8925
	.byte	3
	.word	5847
	.byte	26
	.byte	'Os_AnyCoreType_s',0,15,151,7,16,96,10
	.byte	'DisableAllImask',0
	.word	156
	.byte	4,2,35,0,10
	.byte	'SuspendAllImask',0
	.word	156
	.byte	4,2,35,4,10
	.byte	'SuspendOSImask',0
	.word	156
	.byte	4,2,35,8,10
	.byte	'DisableAllCount',0
	.word	156
	.byte	4,2,35,12,10
	.byte	'SuspendAllCount',0
	.word	156
	.byte	4,2,35,16,10
	.byte	'SuspendOSCount',0
	.word	156
	.byte	4,2,35,20,10
	.byte	'RestartJumpBuf',0
	.word	5087
	.byte	68,2,35,24,10
	.byte	'Restartable',0
	.word	134
	.byte	1,2,35,92,0,12
	.byte	'Os_AnyCoreType',0,15,160,7,3
	.word	8940
	.byte	12
	.byte	'Can_TxObjPriorityClassType',0,16,219,3,16
	.word	156
	.byte	26
	.byte	'Can_TxHwObjectConfigType',0,16,231,3,16,8,10
	.byte	'MsgObjId',0
	.word	134
	.byte	1,2,35,0,10
	.byte	'HwControllerId',0
	.word	134
	.byte	1,2,35,1,10
	.byte	'TxObjPriorityClass',0
	.word	156
	.byte	4,2,35,4,0,12
	.byte	'Can_TxHwObjectConfigType',0,16,252,3,3
	.word	9217
	.byte	26
	.byte	'Can_RxHwObjectConfigType',0,16,129,4,16,12,10
	.byte	'MaskRef',0
	.word	156
	.byte	4,2,35,0,10
	.byte	'MsgId',0
	.word	156
	.byte	4,2,35,4,10
	.byte	'MsgObjId',0
	.word	134
	.byte	1,2,35,8,10
	.byte	'HwControllerId',0
	.word	134
	.byte	1,2,35,9,0,12
	.byte	'Can_RxHwObjectConfigType',0,16,147,4,3
	.word	9353
	.byte	24,4
	.word	134
	.byte	25,3,0,26
	.byte	'Can_ControllerMOMapConfigType',0,16,181,4,16,4,10
	.byte	'ControllerMOMap',0
	.word	9493
	.byte	4,2,35,0,0,12
	.byte	'Can_ControllerMOMapConfigType',0,16,184,4,3
	.word	9502
	.byte	26
	.byte	'Can_NPCRValueType',0,16,188,4,16,2,10
	.byte	'Can_NPCRValue',0
	.word	264
	.byte	2,2,35,0,0,12
	.byte	'Can_NPCRValueType',0,16,191,4,3
	.word	9603
	.byte	26
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,16,194,4,16,8,10
	.byte	'CanControllerBaudrate',0
	.word	156
	.byte	4,2,35,0,10
	.byte	'CanControllerBaudrateCfg',0
	.word	264
	.byte	2,2,35,4,0,12
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,16,198,4,3
	.word	9678
	.byte	11
	.word	9678
	.byte	3
	.word	9843
	.byte	26
	.byte	'Can_BaudrateConfigPtrType',0,16,201,4,16,4,10
	.byte	'Can_kBaudrateConfigPtr',0
	.word	9848
	.byte	4,2,35,0,0,12
	.byte	'Can_BaudrateConfigPtrType',0,16,204,4,3
	.word	9853
	.byte	26
	.byte	'Can_EventHandlingType',0,16,226,4,16,4,10
	.byte	'CanEventType',0
	.word	9493
	.byte	4,2,35,0,0,12
	.byte	'Can_EventHandlingType',0,16,229,4,3
	.word	9953
	.byte	12
	.byte	'Rte_TransformerErrorCode',0,17,130,1,15
	.word	134
	.byte	12
	.byte	'Rte_TransformerClass',0,17,131,1,15
	.word	134
	.byte	9,17,168,1,9,12,10
	.byte	'in',0
	.word	5793
	.byte	4,2,35,0,10
	.byte	'out',0
	.word	5793
	.byte	4,2,35,4,10
	.byte	'used',0
	.word	264
	.byte	2,2,35,8,10
	.byte	'lost_data',0
	.word	134
	.byte	1,2,35,10,0,12
	.byte	'Rte_QDynType',0,17,173,1,3
	.word	10099
	.byte	22,17,175,1,9,4,23
	.byte	'RTE_DRA',0,0,23
	.byte	'RTE_WOWP',0,1,23
	.byte	'RTE_TASK',0,2,23
	.byte	'RTE_ARE',0,3,23
	.byte	'RTE_EV',0,4,23
	.byte	'RTE_MSI',0,5,0,12
	.byte	'Rte_NotificationType',0,17,182,1,3
	.word	10186
	.byte	3
	.word	10099
	.byte	26
	.byte	'Rte_QCmnType',0,17,184,1,16,24,10
	.byte	'dynamic',0
	.word	10284
	.byte	4,2,35,0,10
	.byte	'copy',0
	.word	134
	.byte	1,2,35,4,10
	.byte	'queue_size',0
	.word	264
	.byte	2,2,35,6,10
	.byte	'element_size',0
	.word	264
	.byte	2,2,35,8,10
	.byte	'buffer_start',0
	.word	5793
	.byte	4,2,35,12,10
	.byte	'buffer_end',0
	.word	5793
	.byte	4,2,35,16,10
	.byte	'notification_type',0
	.word	10186
	.byte	4,2,35,20,0,12
	.byte	'Rte_QCmnType',0,17,192,1,3
	.word	10289
	.byte	12
	.byte	'Rte_AlarmRefType',0,17,224,1,32
	.word	156
	.byte	12
	.byte	'Rte_AlarmIndexType',0,17,226,1,32
	.word	264
	.byte	24,128,8
	.word	134
	.byte	25,255,7,0,12
	.byte	'Impl_NVM_DstPtrType_1024',0,18,50,15
	.word	10527
	.byte	12
	.byte	'CanIf_u32_impl',0,18,69,16
	.word	156
	.byte	12
	.byte	'CanIf_u16_impl',0,18,71,16
	.word	264
	.byte	12
	.byte	'CanIf_u8_impl',0,18,73,15
	.word	134
	.byte	12
	.byte	'CanIf_ControllerModeType_Enum_impl',0,18,88,15
	.word	134
	.byte	12
	.byte	'CanIf_PduModeType_Enum_impl',0,18,90,15
	.word	134
	.byte	9,18,92,9,2,10
	.byte	'DeviceMode',0
	.word	134
	.byte	1,2,35,0,10
	.byte	'ChannelMode',0
	.word	134
	.byte	1,2,35,1,0,12
	.byte	'CanIf_ControllerStateType_struct_impl',0,18,95,3
	.word	10718
	.byte	12
	.byte	'CanIf_NotifStatusType_Enum_impl',0,18,100,15
	.word	134
	.byte	12
	.byte	'CanSM_boolean_Impl',0,18,120,15
	.word	134
	.byte	12
	.byte	'CanSM_u8_Impl',0,18,123,15
	.word	134
	.byte	12
	.byte	'CanSM_BusOffRecoveryStateType_Enum_impl',0,18,128,1,15
	.word	134
	.byte	12
	.byte	'CanSM_NetworkModeStateType_Enum_impl',0,18,132,1,15
	.word	134
	.byte	12
	.byte	'CanSM_u16_Impl',0,18,136,1,16
	.word	264
	.byte	12
	.byte	'CanSM_TimerStateType_Enum_impl',0,18,138,1,15
	.word	134
	.byte	9,18,140,1,9,4,10
	.byte	'cntTick_u16',0
	.word	264
	.byte	2,2,35,0,10
	.byte	'stTimer',0
	.word	134
	.byte	1,2,35,2,0,12
	.byte	'CanSM_TimerConfig_tst_struct_impl',0,18,143,1,3
	.word	11059
	.byte	12
	.byte	'Com_impl_u16',0,18,154,1,16
	.word	264
	.byte	12
	.byte	'Com_impl_u8',0,18,157,1,15
	.word	134
	.byte	12
	.byte	'ComM_uint32_Impl',0,18,173,1,16
	.word	156
	.byte	12
	.byte	'ComM_uint16_Impl',0,18,175,1,16
	.word	264
	.byte	12
	.byte	'ComM_uint8_Impl',0,18,177,1,15
	.word	134
	.byte	12
	.byte	'ComM_bool_Impl',0,18,179,1,15
	.word	134
	.byte	9,18,181,1,9,24,10
	.byte	'ChannelState_e',0
	.word	156
	.byte	4,2,35,0,10
	.byte	'LightTimeoutCtr_u32',0
	.word	156
	.byte	4,2,35,4,10
	.byte	'MinFullComTimeoutCtr_u16',0
	.word	264
	.byte	2,2,35,8,10
	.byte	'ChannelMode_u8',0
	.word	134
	.byte	1,2,35,10,10
	.byte	'BusSmMode_u8',0
	.word	134
	.byte	1,2,35,11,10
	.byte	'UserRequestCtr_u8',0
	.word	134
	.byte	1,2,35,12,10
	.byte	'PassiveRequestState_u8',0
	.word	134
	.byte	1,2,35,13,10
	.byte	'PncRequestCtr_u8',0
	.word	134
	.byte	1,2,35,14,10
	.byte	'InhibitionReqStatus_u8',0
	.word	134
	.byte	1,2,35,15,10
	.byte	'NmNetworkRequestStatus_b',0
	.word	134
	.byte	1,2,35,16,10
	.byte	'DiagnosticRequestState_b',0
	.word	134
	.byte	1,2,35,17,10
	.byte	'CommunicationAllowed_b',0
	.word	134
	.byte	1,2,35,18,10
	.byte	'NmBusSleepIndicationStatus_b',0
	.word	134
	.byte	1,2,35,19,10
	.byte	'NmPrepareBusSleepIndicationStatus_b',0
	.word	134
	.byte	1,2,35,20,10
	.byte	'NmNetworkModeStatus_b',0
	.word	134
	.byte	1,2,35,21,0,12
	.byte	'ComM_ChannelStruct_Impl',0,18,197,1,3
	.word	11291
	.byte	9,18,206,1,9,10,10
	.byte	'WakeUpInhibitionCtr_u16',0
	.word	264
	.byte	2,2,35,0,10
	.byte	'LimitToNoComCtr_u16',0
	.word	264
	.byte	2,2,35,2,10
	.byte	'RequestedUserMode_t',0
	.word	134
	.byte	1,2,35,4,10
	.byte	'IndicatedUserMode_t',0
	.word	134
	.byte	1,2,35,5,10
	.byte	'numChannelsInFullCom_u8',0
	.word	134
	.byte	1,2,35,6,10
	.byte	'numChannelsInSilentCom_u8',0
	.word	134
	.byte	1,2,35,7,10
	.byte	'numChannelsInNoCom_u8',0
	.word	134
	.byte	1,2,35,8,0,12
	.byte	'ComM_UserStruct_Impl',0,18,214,1,3
	.word	11795
	.byte	12
	.byte	'Dcm_IOOperationResponseType',0,18,252,1,15
	.word	134
	.byte	12
	.byte	'Dcm_RequestDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspRequestRoutineResultsOutSignal_0PrimitivType',0
	.byte	18,138,2,15
	.word	134
	.byte	12
	.byte	'Dcm_StartDataIn_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineInSignalPrimitivType',0,18,146,2,15
	.word	134
	.byte	12
	.byte	'Dcm_StartDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineOutSignalPrimitivType',0,18,150,2,15
	.word	134
	.byte	12
	.byte	'Dcm_StopDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStopRoutineOutSignalPrimitivType',0,18,154,2,15
	.word	134
	.byte	12
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockNative_1024_Type',0,18,243,3,34
	.word	10538
	.byte	24,128,8
	.word	134
	.byte	25,255,7,0,12
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockRedundant_1024_Type',0,18,246,3,34
	.word	10538
	.byte	12
	.byte	'Rte_TaskRefType',0,19,184,1,32
	.word	7025
	.byte	12
	.byte	'Rte_EventRefType',0,19,185,1,32
	.word	134
	.byte	12
	.byte	'Rte_EventType',0,19,186,1,32
	.word	156
	.byte	12
	.byte	'Rte_REActCounterType',0,19,252,1,15
	.word	134
	.byte	3
	.word	134
	.byte	12
	.byte	'Rte_REActCounterRefType',0,19,253,1,58
	.word	12717
	.byte	9,19,255,1,9,8,10
	.byte	'task',0
	.word	12613
	.byte	4,2,35,0,10
	.byte	'acnt',0
	.word	12722
	.byte	4,2,35,4,0,12
	.byte	'Rte_REContainerType',0,19,130,2,3
	.word	12755
	.byte	11
	.word	6765
	.byte	3
	.word	12819
	.byte	3
	.word	134
	.byte	11
	.word	12755
	.byte	3
	.word	12834
	.byte	12
	.byte	'Rte_REContainerRefType',0,19,132,2,60
	.word	12839
	.byte	12
	.byte	'Rte_MSICounterType',0,19,149,2,16
	.word	264
	.byte	3
	.word	264
	.byte	12
	.byte	'Rte_MSICounterRefType',0,19,150,2,56
	.word	12904
	.byte	12
	.byte	'Rte_MSIPendingFlagType',0,19,152,2,17
	.word	134
	.byte	3
	.word	134
	.byte	12
	.byte	'Rte_MSIPendingFlagRefType',0,19,153,2,60
	.word	12972
	.byte	9,19,163,2,9,24,10
	.byte	'counter',0
	.word	12909
	.byte	4,2,35,0,10
	.byte	'incCounter',0
	.word	134
	.byte	1,2,35,4,10
	.byte	'pending',0
	.word	12977
	.byte	4,2,35,8,10
	.byte	'osTask',0
	.word	12613
	.byte	4,2,35,12,10
	.byte	'acnt',0
	.word	12722
	.byte	4,2,35,16,10
	.byte	'osEvent',0
	.word	134
	.byte	1,2,35,20,10
	.byte	'MSIInit',0
	.word	264
	.byte	2,2,35,22,0,12
	.byte	'Rte_MSITableEntry',0,19,172,2,3
	.word	13012
	.byte	3
	.word	264
	.byte	3
	.word	134
	.byte	12
	.byte	'Rte_TaskArrayIndex',0,19,179,2,16
	.word	134
	.byte	12
	.byte	'Rte_NrWaitingTasks',0,19,180,2,16
	.word	134
	.byte	9,19,182,2,9,4,10
	.byte	'pending',0
	.word	134
	.byte	1,2,35,0,10
	.byte	'count',0
	.word	134
	.byte	1,2,35,1,10
	.byte	'firstWaitingTask',0
	.word	134
	.byte	1,2,35,2,0,12
	.byte	'Rte_WaitableDatum',0,19,186,2,3
	.word	13230
	.byte	3
	.word	13230
	.byte	9,19,226,2,9,12,10
	.byte	'event_id',0
	.word	156
	.byte	4,2,35,0,10
	.byte	'wd',0
	.word	13322
	.byte	4,2,35,4,10
	.byte	'timeout',0
	.word	156
	.byte	4,2,35,8,0,12
	.byte	'Rte_WOWP_NotificationType',0,19,230,2,3
	.word	13327
	.byte	11
	.word	13327
	.byte	3
	.word	13416
	.byte	12
	.byte	'Rte_WOWP_NotificationRefType',0,19,232,2,66
	.word	13421
	.byte	12
	.byte	'Rte_ARE_NotificationType',0,19,234,2,29
	.word	12755
	.byte	26
	.byte	'Rte_QTaskType',0,19,243,2,16,28,10
	.byte	'cmn',0
	.word	10289
	.byte	24,2,35,0,10
	.byte	'task',0
	.word	12613
	.byte	4,2,35,24,0,12
	.byte	'Rte_QTaskType',0,19,246,2,3
	.word	13498
	.byte	26
	.byte	'Rte_QREType',0,19,250,2,16,28,10
	.byte	'cmn',0
	.word	10289
	.byte	24,2,35,0,10
	.byte	're',0
	.word	12844
	.byte	4,2,35,24,0,12
	.byte	'Rte_QREType',0,19,253,2,3
	.word	13569
	.byte	11
	.word	12755
	.byte	3
	.word	13634
	.byte	26
	.byte	'Rte_QWWPType',0,19,129,3,16,28,10
	.byte	'cmn',0
	.word	10289
	.byte	24,2,35,0,10
	.byte	'wwp',0
	.word	13426
	.byte	4,2,35,24,0,12
	.byte	'Rte_QWWPType',0,19,132,3,3
	.word	13644
	.byte	11
	.word	13327
	.byte	3
	.word	13712
	.byte	26
	.byte	'Rte_QEvType',0,19,136,3,16,36,10
	.byte	'cmn',0
	.word	10289
	.byte	24,2,35,0,10
	.byte	'task',0
	.word	12613
	.byte	4,2,35,24,10
	.byte	'mask',0
	.word	134
	.byte	1,2,35,28,10
	.byte	'acnt',0
	.word	12722
	.byte	4,2,35,32,0,12
	.byte	'Rte_QEvType',0,19,141,3,3
	.word	13722
	.byte	26
	.byte	'Rte_QMSIType',0,19,145,3,16,48,10
	.byte	'cmn',0
	.word	10289
	.byte	24,2,35,0,10
	.byte	'task',0
	.word	12613
	.byte	4,2,35,24,10
	.byte	'mask',0
	.word	134
	.byte	1,2,35,28,10
	.byte	'acnt',0
	.word	12722
	.byte	4,2,35,32,10
	.byte	'msiCounter',0
	.word	12909
	.byte	4,2,35,36,10
	.byte	'msiPending',0
	.word	12977
	.byte	4,2,35,40,10
	.byte	'msiLimit',0
	.word	264
	.byte	2,2,35,44,0,12
	.byte	'Rte_QMSIType',0,19,153,3,3
	.word	13817
	.byte	9,4,52,9,1,33
	.byte	'isEventTrig',0,1
	.word	134
	.byte	1,7,2,35,0,33
	.byte	'isTriggerIpduSendWithMetadata',0,1
	.word	134
	.byte	1,6,2,35,0,33
	.byte	'isGwIpduSend',0,1
	.word	134
	.byte	1,5,2,35,0,33
	.byte	'isModeChangd',0,1
	.word	134
	.byte	1,4,2,35,0,33
	.byte	'sigTransProp',0,1
	.word	134
	.byte	1,3,2,35,0,33
	.byte	'isTimeoutReq',0,1
	.word	134
	.byte	1,2,2,35,0,33
	.byte	'ignoreRepetitions',0,1
	.word	134
	.byte	1,1,2,35,0,0,12
	.byte	'Com_SendIpduInfo',0,4,61,3
	.word	13972
	.byte	12
	.byte	'Com_TransModeInfo',0,4,93,2
	.word	2300
	.byte	12
	.byte	'Com_Prv_xTxSigCfg_tst',0,4,201,1,2
	.word	2995
	.byte	12
	.byte	'Com_Prv_xRxSigCfg_tst',0,4,171,2,2
	.word	1017
	.byte	12
	.byte	'Com_Prv_xTxIpduInfoCfg_tst',0,4,162,6,3
	.word	2700
	.byte	12
	.byte	'Com_Prv_xRxIpduInfoCfg_tst',0,4,197,7,3
	.word	1942
	.byte	9,4,219,7,9,4,10
	.byte	'FirstIpdu_Index',0
	.word	264
	.byte	2,2,35,0,10
	.byte	'NoOfRxPdus',0
	.word	264
	.byte	2,2,35,2,0,12
	.byte	'Com_Prv_xIpduGrpInfoCfg_tst',0,4,224,7,3
	.word	14352
	.byte	9,4,244,7,9,1,10
	.byte	'txSigRAMFields',0
	.word	134
	.byte	1,2,35,0,0,12
	.byte	'Com_TxSignalFlagType',0,4,248,7,2
	.word	14441
	.byte	12
	.byte	'Com_RxSignalFlagType',0,4,171,8,2
	.word	2230
	.byte	12
	.byte	'Com_TxIpduRamData',0,4,189,9,3
	.word	2461
	.byte	12
	.byte	'Com_RxIpduRamData',0,4,245,9,2
	.word	1835
	.byte	3
	.word	264
	.byte	9,4,128,10,9,8,10
	.byte	'RxGwQueuePtr',0
	.word	14586
	.byte	4,2,35,0,10
	.byte	'Com_RxGwQueueWrite_ux',0
	.word	134
	.byte	1,2,35,4,10
	.byte	'Com_RxGwQueueRead_ux',0
	.word	134
	.byte	1,2,35,5,0,12
	.byte	'Com_RxGwQueueRAMType',0,4,133,10,2
	.word	14591
	.byte	9,4,138,10,9,4,10
	.byte	'indexGwMapSigDestIdArray',0
	.word	264
	.byte	2,2,35,0,10
	.byte	'destCount',0
	.word	134
	.byte	1,2,35,2,0,12
	.byte	'Com_Prv_xGwMapSigCfg_tst',0,4,142,10,2
	.word	14711
	.byte	9,4,147,10,9,2,10
	.byte	'GwMap_DestId',0
	.word	264
	.byte	2,2,35,0,0,12
	.byte	'Com_Prv_xGwMapSigIdCfg_tst',0,4,150,10,2
	.word	14805
	.byte	9,4,183,10,9,4,10
	.byte	'StartIPduId',0
	.word	134
	.byte	1,2,35,0,10
	.byte	'NumOfIpdus',0
	.word	134
	.byte	1,2,35,1,10
	.byte	'TimeBaseInMs',0
	.word	134
	.byte	1,2,35,2,0,12
	.byte	'Com_MainFunctionCfgType',0,4,188,10,3
	.word	14870
	.byte	9,4,194,10,9,12,10
	.byte	'Com_SigType_pu8',0
	.word	151
	.byte	4,2,35,0,10
	.byte	'Com_SigType_pu16',0
	.word	591
	.byte	4,2,35,4,10
	.byte	'Com_SigType_pu32',0
	.word	677
	.byte	4,2,35,8,0,12
	.byte	'Com_Prv_xRxRamBuf_tst',0,4,253,10,3
	.word	14973
	.byte	11
	.word	264
	.byte	3
	.word	15088
	.byte	11
	.word	264
	.byte	3
	.word	15098
	.byte	11
	.word	14352
	.byte	3
	.word	15108
	.byte	11
	.word	264
	.byte	3
	.word	15118
	.byte	11
	.word	134
	.byte	3
	.word	15128
	.byte	11
	.word	14870
	.byte	3
	.word	15138
	.byte	11
	.word	14973
	.byte	3
	.word	15148
	.byte	3
	.word	14441
	.byte	11
	.word	264
	.byte	11
	.word	134
	.byte	11
	.word	264
	.byte	11
	.word	264
	.byte	11
	.word	264
	.byte	11
	.word	264
	.byte	11
	.word	134
	.byte	11
	.word	134
	.byte	11
	.word	134
	.byte	11
	.word	134
	.byte	11
	.word	264
	.byte	11
	.word	134
	.byte	11
	.word	134
	.byte	11
	.word	134
	.byte	9,4,154,11,9,100,10
	.byte	'Com_TxSig_pcst',0
	.word	3127
	.byte	4,2,35,0,10
	.byte	'Com_TxSignalMapping_pct',0
	.word	15093
	.byte	4,2,35,4,10
	.byte	'Com_RxSig_pcst',0
	.word	1188
	.byte	4,2,35,8,10
	.byte	'Com_RxSignalMapping_pct',0
	.word	15093
	.byte	4,2,35,12,10
	.byte	'Com_TxIpdu_pcst',0
	.word	2958
	.byte	4,2,35,16,10
	.byte	'Com_TxIpduMapping_pcst',0
	.word	15103
	.byte	4,2,35,20,10
	.byte	'Com_RxIpdu_pcst',0
	.word	2172
	.byte	4,2,35,24,10
	.byte	'Com_RxIpduMapping_pcst',0
	.word	15103
	.byte	4,2,35,28,10
	.byte	'Com_IpduGrp_pcst',0
	.word	15113
	.byte	4,2,35,32,10
	.byte	'Com_IpduGrpMapping_pcu16',0
	.word	15123
	.byte	4,2,35,36,10
	.byte	'Com_IPduGrp_IpduRef_pcst',0
	.word	15133
	.byte	4,2,35,40,10
	.byte	'Com_MainFunctionCfg_pcst',0
	.word	15143
	.byte	4,2,35,44,10
	.byte	'Com_RxRamBuf_pcst',0
	.word	15153
	.byte	4,2,35,48,10
	.byte	'Com_TxIpduRam_ps',0
	.word	2665
	.byte	4,2,35,52,10
	.byte	'Com_RxIpduRam_ps',0
	.word	1907
	.byte	4,2,35,56,10
	.byte	'Com_TxSignalFlag_ps',0
	.word	15158
	.byte	4,2,35,60,10
	.byte	'Com_RxSignalFlag_ps',0
	.word	2266
	.byte	4,2,35,64,10
	.byte	'Com_IpduCounter_ps',0
	.word	151
	.byte	4,2,35,68,10
	.byte	'Com_IpduCounter_DM_ps',0
	.word	151
	.byte	4,2,35,72,10
	.byte	'noOfIpduGroup',0
	.word	15163
	.byte	2,2,35,76,10
	.byte	'noOfIpdusInLastIpduGrp',0
	.word	15168
	.byte	1,2,35,78,10
	.byte	'noOfTxSignals',0
	.word	15173
	.byte	2,2,35,80,10
	.byte	'noOfRxSignals',0
	.word	15178
	.byte	2,2,35,82,10
	.byte	'noOfTxSignalGroup',0
	.word	15183
	.byte	2,2,35,84,10
	.byte	'noOfRxSignalGroup',0
	.word	15188
	.byte	2,2,35,86,10
	.byte	'noOfTxGroupSignal',0
	.word	15193
	.byte	1,2,35,88,10
	.byte	'noOfRxGroupSignal',0
	.word	15198
	.byte	1,2,35,89,10
	.byte	'noOfTxIpdu',0
	.word	15203
	.byte	1,2,35,90,10
	.byte	'noOfRxIpdu',0
	.word	15208
	.byte	1,2,35,91,10
	.byte	'noOfGwSrcSignals',0
	.word	15213
	.byte	2,2,35,92,10
	.byte	'noOfGwSrcGrpSignals',0
	.word	15218
	.byte	1,2,35,94,10
	.byte	'noOfGwSrcIpdu',0
	.word	15223
	.byte	1,2,35,95,10
	.byte	'noOfGrpSigNoGw',0
	.word	15228
	.byte	1,2,35,96,0,12
	.byte	'Com_ConfigData_tst',0,4,210,12,3
	.word	15233
	.byte	12
	.byte	'rba_BswSrv_uint64',0,1,66,28
	.word	4175
	.byte	34
	.word	1835
	.byte	35,0,36
	.byte	'Com_RxIpduRam_s',0,8,201,24,42
	.word	16197
	.byte	1,1,34
	.word	2461
	.byte	35,0,36
	.byte	'Com_TxIpduRam_s',0,8,211,24,42
	.word	16231
	.byte	1,1,34
	.word	2230
	.byte	35,0,36
	.byte	'Com_RxSignalFlag',0,8,231,24,44
	.word	16265
	.byte	1,1,34
	.word	134
	.byte	35,0,36
	.byte	'Com_IpduCounter_s',0,8,241,24,30
	.word	16300
	.byte	1,1,36
	.byte	'Com_IpduCounter_DM',0,8,251,24,30
	.word	16300
	.byte	1,1,36
	.byte	'Com_IpduGrpVector',0,8,136,25,42
	.word	4536
	.byte	1,1,24,1
	.word	134
	.byte	25,0,0,36
	.byte	'Com_IpduGrpVector_DM',0,8,148,25,42
	.word	4536
	.byte	1,1,11
	.word	15233
.L192:
	.byte	3
	.word	16436
	.byte	34
	.word	2995
	.byte	35,0,11
	.word	16446
	.byte	36
	.byte	'Com_Prv_xTxSigCfg_acst',0,8,253,25,55
	.word	16453
	.byte	1,1,34
	.word	1017
	.byte	35,0,11
	.word	16492
	.byte	36
	.byte	'Com_Prv_xRxSigCfg_acst',0,8,131,26,55
	.word	16499
	.byte	1,1,34
	.word	2700
	.byte	35,0,11
	.word	16538
	.byte	36
	.byte	'Com_Prv_xTxIpduCfg_acst',0,8,137,26,57
	.word	16545
	.byte	1,1,34
	.word	1942
	.byte	35,0,11
	.word	16585
	.byte	36
	.byte	'Com_Prv_xRxIpduCfg_acst',0,8,143,26,57
	.word	16592
	.byte	1,1,34
	.word	14973
	.byte	35,0,11
	.word	16632
	.byte	36
	.byte	'Com_Prv_xRxRamBuf_acst',0,8,235,26,48
	.word	16639
	.byte	1,1,0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L47:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,36,0,3,8,11,15,62,15,0,0,3,15,0,73,19,0,0,4,46,1,3,8,32
	.byte	13,58,15,59,15,57,15,54,15,39,12,0,0,5,5,0,3,8,58,15,59,15,57,15,73,19,0,0,6,11,0,0,0,7,46,1,3,8,32,13
	.byte	58,15,59,15,57,15,73,19,54,15,39,12,0,0,8,21,0,54,15,39,12,0,0,9,19,1,58,15,59,15,57,15,11,15,0,0,10,13
	.byte	0,3,8,73,19,11,15,56,9,0,0,11,38,0,73,19,0,0,12,22,0,3,8,58,15,59,15,57,15,73,19,0,0,13,11,1,0,0,14,59
	.byte	0,3,8,0,0,15,46,1,49,19,0,0,16,5,0,49,19,0,0,17,46,1,3,8,58,15,59,15,57,15,54,15,39,12,63,12,60,12,0,0
	.byte	18,29,1,49,19,0,0,19,11,0,49,19,0,0,20,11,1,49,19,0,0,21,21,0,54,15,0,0,22,4,1,58,15,59,15,57,15,11,15
	.byte	0,0,23,40,0,3,8,28,13,0,0,24,1,1,11,15,73,19,0,0,25,33,0,47,15,0,0,26,19,1,3,8,58,15,59,15,57,15,11,15
	.byte	0,0,27,21,1,54,15,39,12,0,0,28,5,0,73,19,0,0,29,23,1,58,15,59,15,57,15,11,15,0,0,30,4,1,3,8,58,15,59,15
	.byte	57,15,11,15,0,0,31,21,0,73,19,54,15,39,12,0,0,32,53,0,73,19,0,0,33,13,0,3,8,11,15,73,19,13,15,12,15,56
	.byte	9,0,0,34,1,1,73,19,0,0,35,33,0,0,0,36,52,0,3,8,58,15,59,15,57,15,73,19,63,12,60,12,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L48:
	.word	.L223-.L222
.L222:
	.half	3
	.word	.L225-.L224
.L224:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'.\\Integration\\BSW\\Include\\rba_BswSrv.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Bfx\\api\\Bfx_Bit_Inl.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv_Inl.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv_Types.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Init.c',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Com\\api\\Com.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Std_Types.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Platform\\Platform_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Com\\Com_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Com\\Com_Cfg_Internal.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Can_GeneralTypes.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\RTOS_T\\Gen\\inc\\Os.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Can_17_MCanP\\inc\\Can_17_MCanP.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Type.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Intl.h',0,0,0,0,0
.L225:
.L223:
	.sdecl	'.debug_info',debug,cluster('Com_Init')
	.sect	'.debug_info'
.L49:
	.word	1570
	.half	3
	.word	.L50
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Init.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L52,.L51
	.byte	2
	.word	.L45
	.byte	3
	.byte	'Com_Init',0,1,72,22,1,1,1
	.word	.L44,.L58,.L43
	.byte	4
	.byte	'config',0,1,72,81
	.word	.L59,.L60
	.byte	5
	.word	.L44,.L58
	.byte	6
	.word	.L61,.L62,.L4
	.byte	7
	.word	.L63,.L64
	.byte	7
	.word	.L65,.L66
	.byte	7
	.word	.L67,.L68
	.byte	8
	.word	.L69,.L62,.L4
	.byte	9
	.byte	'ctLoop_u32',0,2,253,3,12
	.word	.L70,.L71
	.byte	0,0,6
	.word	.L61,.L72,.L7
	.byte	7
	.word	.L63,.L64
	.byte	7
	.word	.L65,.L66
	.byte	7
	.word	.L67,.L68
	.byte	8
	.word	.L69,.L72,.L7
	.byte	9
	.byte	'ctLoop_u32',0,2,253,3,12
	.word	.L70,.L73
	.byte	0,0,6
	.word	.L74,.L7,.L75
	.byte	8
	.word	.L76,.L7,.L75
	.byte	9
	.byte	'RxIPduRamPtr',0,1,213,1,35
	.word	.L77,.L78
	.byte	9
	.byte	'RxIPduConstPtr',0,1,214,1,35
	.word	.L79,.L80
	.byte	9
	.byte	'RxSigConstPtr',0,1,215,1,35
	.word	.L81,.L82
	.byte	9
	.byte	'Idx_ui',0,1,216,1,35
	.word	.L83,.L84
	.byte	9
	.byte	'Idx_ByteNSig_ui',0,1,217,1,35
	.word	.L83,.L85
	.byte	9
	.byte	'RxSigRamPtr',0,1,224,1,41
	.word	.L86,.L87
	.byte	9
	.byte	'RxSigVal',0,1,225,1,41
	.word	.L70,.L88
	.byte	9
	.byte	'rxMainFuncId',0,1,226,1,41
	.word	.L89,.L90
	.byte	6
	.word	.L91,.L92,.L93
	.byte	7
	.word	.L94,.L95
	.byte	7
	.word	.L96,.L97
	.byte	7
	.word	.L98,.L99
	.byte	8
	.word	.L100,.L92,.L93
	.byte	9
	.byte	'tmp_u8',0,3,250,3,11
	.word	.L89,.L101
	.byte	0,0,6
	.word	.L102,.L103,.L21
	.byte	7
	.word	.L104,.L105
	.byte	7
	.word	.L106,.L107
	.byte	7
	.word	.L108,.L109
	.byte	8
	.word	.L110,.L103,.L21
	.byte	9
	.byte	'Type',0,4,205,2,29
	.word	.L89,.L111
	.byte	6
	.word	.L112,.L113,.L14
	.byte	7
	.word	.L114,.L115
	.byte	7
	.word	.L116,.L117
	.byte	7
	.word	.L118,.L119
	.byte	10
	.word	.L120,.L113,.L14
	.byte	0,0,0,0,0,6
	.word	.L121,.L75,.L122
	.byte	8
	.word	.L123,.L75,.L122
	.byte	9
	.byte	'TxIpduRamPtr',0,1,244,2,36
	.word	.L124,.L125
	.byte	9
	.byte	'TxIPduConstPtr',0,1,245,2,36
	.word	.L126,.L127
	.byte	9
	.byte	'Idx_ui',0,1,246,2,36
	.word	.L128,.L129
	.byte	6
	.word	.L61,.L130,.L30
	.byte	7
	.word	.L63,.L64
	.byte	7
	.word	.L65,.L66
	.byte	7
	.word	.L67,.L68
	.byte	8
	.word	.L69,.L130,.L30
	.byte	9
	.byte	'ctLoop_u32',0,2,253,3,12
	.word	.L70,.L131
	.byte	0,0,6
	.word	.L132,.L133,.L31
	.byte	7
	.word	.L134,.L135
	.byte	7
	.word	.L136,.L137
	.byte	10
	.word	.L138,.L133,.L31
	.byte	0,6
	.word	.L91,.L139,.L140
	.byte	7
	.word	.L94,.L95
	.byte	7
	.word	.L96,.L97
	.byte	7
	.word	.L98,.L99
	.byte	8
	.word	.L100,.L139,.L140
	.byte	9
	.byte	'tmp_u8',0,3,250,3,11
	.word	.L89,.L141
	.byte	0,0,6
	.word	.L142,.L143,.L32
	.byte	7
	.word	.L144,.L145
	.byte	7
	.word	.L146,.L147
	.byte	7
	.word	.L148,.L149
	.byte	7
	.word	.L150,.L151
	.byte	10
	.word	.L152,.L143,.L32
	.byte	0,6
	.word	.L153,.L154,.L155
	.byte	7
	.word	.L156,.L157
	.byte	8
	.word	.L158,.L154,.L155
	.byte	9
	.byte	'TxIPduConstPtr',0,1,131,4,36
	.word	.L126,.L159
	.byte	9
	.byte	'TxSigConstPtr',0,1,132,4,36
	.word	.L160,.L161
	.byte	9
	.byte	'TxSigNewVal',0,1,133,4,36
	.word	.L70,.L162
	.byte	9
	.byte	'Idx_ByteNSig_ui',0,1,143,4,36
	.word	.L83,.L163
	.byte	9
	.byte	'ConstByteValue_u8',0,1,148,4,36
	.word	.L89,.L164
	.byte	9
	.byte	'Type',0,1,149,4,36
	.word	.L89,.L165
	.byte	6
	.word	.L112,.L166,.L37
	.byte	7
	.word	.L114,.L115
	.byte	7
	.word	.L116,.L117
	.byte	7
	.word	.L118,.L119
	.byte	10
	.word	.L120,.L166,.L37
	.byte	0,6
	.word	.L167,.L168,.L38
	.byte	7
	.word	.L169,.L170
	.byte	7
	.word	.L171,.L172
	.byte	10
	.word	.L173,.L168,.L38
	.byte	0,6
	.word	.L174,.L175,.L42
	.byte	7
	.word	.L176,.L177
	.byte	7
	.word	.L178,.L179
	.byte	7
	.word	.L180,.L181
	.byte	7
	.word	.L182,.L183
	.byte	7
	.word	.L184,.L185
	.byte	7
	.word	.L186,.L187
	.byte	8
	.word	.L188,.L175,.L42
	.byte	8
	.word	.L189,.L41,.L42
	.byte	9
	.byte	'ByteOffset_uo',0,4,174,3,23
	.word	.L128,.L190
	.byte	0,0,0,0,0,0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('Com_Init')
	.sect	'.debug_abbrev'
.L50:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,29,1,49
	.byte	16,17,1,18,1,0,0,7,5,0,49,16,2,6,0,0,8,11,1,49,16,17,1,18,1,0,0,9,52,0,3,8,58,15,59,15,57,15,73,16,2,6
	.byte	0,0,10,11,0,49,16,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('Com_Init')
	.sect	'.debug_line'
.L51:
	.word	.L227-.L226
.L226:
	.half	3
	.word	.L229-.L228
.L228:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Init.c',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\rba_BswSrv.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Bfx\\api\\Bfx_Bit_Inl.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv_Inl.h',0,0,0,0,0
.L229:
	.byte	5,22,7,0,5,2
	.word	.L44
	.byte	3,199,0,1,5,25,9
	.half	.L193-.L44
	.byte	3,46,1,5,64,9
	.half	.L230-.L193
	.byte	1,4,2,5,20,9
	.half	.L62-.L230
	.byte	3,137,3,1,5,50,9
	.half	.L194-.L62
	.byte	1,5,20,9
	.half	.L3-.L194
	.byte	3,2,1,5,18,9
	.half	.L231-.L3
	.byte	3,1,1,5,62,9
	.half	.L232-.L231
	.byte	3,125,1,5,50,9
	.half	.L2-.L232
	.byte	1,5,5,7,9
	.half	.L233-.L2
	.byte	3,6,1,4,1,5,25,9
	.half	.L4-.L233
	.byte	3,242,124,1,5,64,9
	.half	.L234-.L4
	.byte	1,4,2,5,20,9
	.half	.L72-.L234
	.byte	3,136,3,1,5,50,9
	.half	.L195-.L72
	.byte	1,5,20,9
	.half	.L6-.L195
	.byte	3,2,1,5,18,9
	.half	.L235-.L6
	.byte	3,1,1,5,62,9
	.half	.L236-.L235
	.byte	3,125,1,5,50,9
	.half	.L5-.L236
	.byte	1,5,5,7,9
	.half	.L237-.L5
	.byte	3,6,1,4,1,5,23,9
	.half	.L7-.L237
	.byte	3,241,125,1,5,22,9
	.half	.L238-.L7
	.byte	3,2,1,5,16,9
	.half	.L239-.L238
	.byte	3,2,1,5,56,9
	.half	.L198-.L239
	.byte	1,5,9,9
	.half	.L9-.L198
	.byte	3,3,1,5,42,9
	.half	.L240-.L9
	.byte	1,5,40,9
	.half	.L241-.L240
	.byte	1,5,9,9
	.half	.L242-.L241
	.byte	3,1,1,5,42,9
	.half	.L243-.L242
	.byte	1,5,40,9
	.half	.L244-.L243
	.byte	1,5,39,9
	.half	.L245-.L244
	.byte	3,3,1,5,37,9
	.half	.L246-.L245
	.byte	1,5,39,9
	.half	.L247-.L246
	.byte	3,1,1,5,37,9
	.half	.L248-.L247
	.byte	1,5,9,9
	.half	.L249-.L248
	.byte	3,3,1,4,3,5,14,9
	.half	.L92-.L249
	.byte	3,246,1,1,5,26,9
	.half	.L199-.L92
	.byte	1,5,21,9
	.half	.L10-.L199
	.byte	1,5,15,9
	.half	.L11-.L10
	.byte	3,2,1,5,33,9
	.half	.L250-.L11
	.byte	1,5,37,9
	.half	.L251-.L250
	.byte	1,5,31,9
	.half	.L252-.L251
	.byte	1,5,21,9
	.half	.L253-.L252
	.byte	1,5,66,9
	.half	.L254-.L253
	.byte	1,5,48,9
	.half	.L203-.L254
	.byte	1,5,11,9
	.half	.L255-.L203
	.byte	1,4,1,5,28,9
	.half	.L93-.L255
	.byte	3,139,126,1,5,27,9
	.half	.L204-.L93
	.byte	3,1,1,5,41,9
	.half	.L205-.L204
	.byte	3,3,1,5,61,9
	.half	.L206-.L205
	.byte	3,2,1,5,119,9
	.half	.L207-.L206
	.byte	1,5,43,9
	.half	.L13-.L207
	.byte	3,3,1,5,41,9
	.half	.L256-.L13
	.byte	1,5,56,9
	.half	.L257-.L256
	.byte	3,4,1,4,4,5,12,9
	.half	.L103-.L257
	.byte	3,58,1,4,3,5,27,9
	.half	.L113-.L103
	.byte	3,230,0,1,5,45,9
	.half	.L258-.L113
	.byte	1,5,68,9
	.half	.L259-.L258
	.byte	1,5,60,9
	.half	.L260-.L259
	.byte	1,5,42,9
	.half	.L261-.L260
	.byte	1,5,5,9
	.half	.L262-.L261
	.byte	1,4,4,5,17,9
	.half	.L14-.L262
	.byte	3,156,127,1,5,10,9
	.half	.L263-.L14
	.byte	3,2,1,9
	.half	.L264-.L263
	.byte	3,5,1,9
	.half	.L265-.L264
	.byte	3,4,1,5,23,9
	.half	.L266-.L265
	.byte	3,120,1,5,10,9
	.half	.L267-.L266
	.byte	3,24,1,5,9,9
	.half	.L18-.L267
	.byte	3,105,1,5,78,9
	.half	.L268-.L18
	.byte	1,5,9,9
	.half	.L269-.L268
	.byte	3,1,1,9
	.half	.L16-.L269
	.byte	3,3,1,5,79,9
	.half	.L270-.L16
	.byte	1,5,9,9
	.half	.L271-.L270
	.byte	3,1,1,9
	.half	.L17-.L271
	.byte	3,9,1,5,79,9
	.half	.L272-.L17
	.byte	1,5,9,9
	.half	.L273-.L272
	.byte	3,1,1,5,27,9
	.half	.L19-.L273
	.byte	3,9,1,5,60,9
	.half	.L274-.L19
	.byte	3,1,1,5,9,9
	.half	.L208-.L274
	.byte	3,1,1,9
	.half	.L20-.L208
	.byte	3,6,1,4,1,5,24,9
	.half	.L21-.L20
	.byte	3,82,1,5,26,9
	.half	.L275-.L21
	.byte	3,1,1,5,136,1,9
	.half	.L276-.L275
	.byte	3,70,1,5,119,9
	.half	.L12-.L276
	.byte	1,5,21,7,9
	.half	.L277-.L12
	.byte	3,213,0,1,5,23,9
	.half	.L278-.L277
	.byte	3,1,1,5,64,9
	.half	.L279-.L278
	.byte	3,150,127,1,5,56,9
	.half	.L8-.L279
	.byte	1,5,23,7,9
	.half	.L75-.L8
	.byte	3,128,1,1,5,22,9
	.half	.L280-.L75
	.byte	3,2,1,5,16,9
	.half	.L281-.L280
	.byte	3,2,1,5,56,9
	.half	.L200-.L281
	.byte	1,5,43,9
	.half	.L27-.L200
	.byte	3,3,1,5,41,9
	.half	.L282-.L27
	.byte	1,5,57,9
	.half	.L283-.L282
	.byte	3,4,1,5,41,9
	.half	.L284-.L283
	.byte	1,5,43,9
	.half	.L285-.L284
	.byte	3,3,1,5,76,9
	.half	.L286-.L285
	.byte	1,5,113,9
	.half	.L287-.L286
	.byte	1,4,2,5,20,9
	.half	.L130-.L287
	.byte	3,247,0,1,5,50,9
	.half	.L209-.L130
	.byte	1,5,20,9
	.half	.L29-.L209
	.byte	3,2,1,5,18,9
	.half	.L288-.L29
	.byte	3,1,1,5,62,9
	.half	.L289-.L288
	.byte	3,125,1,5,50,9
	.half	.L28-.L289
	.byte	1,5,5,7,9
	.half	.L290-.L28
	.byte	3,6,1,4,1,5,12,9
	.half	.L30-.L290
	.byte	3,134,127,1,4,3,5,35,9
	.half	.L133-.L30
	.byte	3,70,1,5,39,9
	.half	.L291-.L133
	.byte	1,5,22,9
	.half	.L292-.L291
	.byte	1,5,51,9
	.half	.L293-.L292
	.byte	1,5,5,9
	.half	.L294-.L293
	.byte	1,4,1,5,9,9
	.half	.L31-.L294
	.byte	3,58,1,5,13,7,9
	.half	.L295-.L31
	.byte	3,2,1,5,67,9
	.half	.L296-.L295
	.byte	1,5,65,9
	.half	.L297-.L296
	.byte	1,5,13,9
	.half	.L298-.L297
	.byte	3,3,1,4,3,5,14,9
	.half	.L139-.L298
	.byte	3,235,0,1,5,26,9
	.half	.L210-.L139
	.byte	1,5,21,9
	.half	.L33-.L210
	.byte	1,5,15,9
	.half	.L34-.L33
	.byte	3,2,1,5,33,9
	.half	.L299-.L34
	.byte	1,5,37,9
	.half	.L300-.L299
	.byte	1,5,31,9
	.half	.L301-.L300
	.byte	1,5,21,9
	.half	.L302-.L301
	.byte	1,5,66,9
	.half	.L303-.L302
	.byte	1,5,48,9
	.half	.L212-.L303
	.byte	1,5,11,9
	.half	.L304-.L212
	.byte	1,4,1,5,13,9
	.half	.L140-.L304
	.byte	3,149,127,1,4,3,5,105,9
	.half	.L143-.L140
	.byte	3,178,1,1,5,13,9
	.half	.L305-.L143
	.byte	3,1,1,5,120,9
	.half	.L306-.L305
	.byte	3,127,1,5,67,9
	.half	.L307-.L306
	.byte	1,5,24,9
	.half	.L308-.L307
	.byte	1,5,86,9
	.half	.L309-.L308
	.byte	1,5,84,9
	.half	.L211-.L309
	.byte	1,5,23,9
	.half	.L310-.L211
	.byte	3,1,1,5,34,9
	.half	.L311-.L310
	.byte	1,5,93,9
	.half	.L312-.L311
	.byte	3,127,1,5,11,9
	.half	.L313-.L312
	.byte	1,4,1,5,47,9
	.half	.L32-.L313
	.byte	3,225,126,1,5,45,9
	.half	.L314-.L32
	.byte	1,5,47,9
	.half	.L315-.L314
	.byte	3,5,1,5,45,9
	.half	.L316-.L315
	.byte	1,5,47,9
	.half	.L317-.L316
	.byte	3,2,1,5,45,9
	.half	.L318-.L317
	.byte	1,5,27,9
	.half	.L154-.L318
	.byte	3,235,0,1,9
	.half	.L213-.L154
	.byte	3,4,1,5,41,9
	.half	.L214-.L213
	.byte	3,2,1,5,85,9
	.half	.L215-.L214
	.byte	1,5,44,9
	.half	.L36-.L215
	.byte	3,3,1,5,31,9
	.half	.L216-.L36
	.byte	3,2,1,4,3,5,27,9
	.half	.L166-.L216
	.byte	3,147,127,1,5,45,9
	.half	.L319-.L166
	.byte	1,5,68,9
	.half	.L320-.L319
	.byte	1,5,60,9
	.half	.L321-.L320
	.byte	1,5,42,9
	.half	.L218-.L321
	.byte	1,5,5,9
	.half	.L322-.L218
	.byte	1,4,1,5,60,9
	.half	.L37-.L322
	.byte	3,241,0,1,4,3,5,32,9
	.half	.L168-.L37
	.byte	3,211,126,1,5,36,9
	.half	.L323-.L168
	.byte	1,5,21,9
	.half	.L324-.L323
	.byte	1,5,48,9
	.half	.L217-.L324
	.byte	1,5,5,9
	.half	.L325-.L217
	.byte	1,4,1,5,51,9
	.half	.L38-.L325
	.byte	3,195,1,1,5,65,9
	.half	.L40-.L38
	.byte	3,124,1,5,64,9
	.half	.L326-.L40
	.byte	3,2,1,9
	.half	.L327-.L326
	.byte	3,1,1,4,4,5,21,9
	.half	.L175-.L327
	.byte	3,219,126,1,5,5,9
	.half	.L328-.L175
	.byte	1,5,78,7,9
	.half	.L329-.L328
	.byte	3,19,1,5,87,9
	.half	.L219-.L329
	.byte	1,5,54,9
	.half	.L41-.L219
	.byte	3,7,1,5,36,9
	.half	.L330-.L41
	.byte	3,3,1,5,74,9
	.half	.L331-.L330
	.byte	1,4,1,5,22,9
	.half	.L42-.L331
	.byte	3,183,1,1,5,102,9
	.half	.L332-.L42
	.byte	3,179,127,1,5,85,9
	.half	.L35-.L332
	.byte	1,5,23,7,9
	.half	.L155-.L35
	.byte	3,153,127,1,5,21,9
	.half	.L333-.L155
	.byte	3,1,1,5,64,9
	.half	.L334-.L333
	.byte	3,71,1,5,56,9
	.half	.L26-.L334
	.byte	1,5,5,7,9
	.half	.L122-.L26
	.byte	3,159,126,1,5,23,9
	.half	.L335-.L122
	.byte	1,5,21,9
	.half	.L336-.L335
	.byte	1,5,1,9
	.half	.L337-.L336
	.byte	3,2,1,7,9
	.half	.L53-.L337
	.byte	0,1,1
.L227:
	.sdecl	'.debug_ranges',debug,cluster('Com_Init')
	.sect	'.debug_ranges'
.L52:
	.word	-1,.L44,0,.L53-.L44,0,0
	.sdecl	'.debug_info',debug,cluster('Com_Uninit_Flag')
	.sect	'.debug_info'
.L54:
	.word	163
	.half	3
	.word	.L55
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Init.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1,2
	.word	.L45
	.byte	3
	.byte	'Com_Uninit_Flag',0,5,12,37
	.word	.L191
	.byte	1,5,3
	.word	Com_Uninit_Flag
	.byte	0
	.sdecl	'.debug_abbrev',debug,cluster('Com_Uninit_Flag')
	.sect	'.debug_abbrev'
.L55:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,0,0,2,61,0,24,16,0,0,3,52,0,3,8,58,15,59,15,57,15,73,16,63,12,2,9
	.byte	0,0,0
	.sdecl	'.debug_info',debug,cluster('Com_Prv_Config_pcst')
	.sect	'.debug_info'
.L56:
	.word	167
	.half	3
	.word	.L57
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Init.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1,2
	.word	.L45
	.byte	3
	.byte	'Com_Prv_Config_pcst',0,5,21,54
	.word	.L192
	.byte	1,5,3
	.word	Com_Prv_Config_pcst
	.byte	0
	.sdecl	'.debug_abbrev',debug,cluster('Com_Prv_Config_pcst')
	.sect	'.debug_abbrev'
.L57:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,0,0,2,61,0,24,16,0,0,3,52,0,3,8,58,15,59,15,57,15,73,16,63,12,2,9
	.byte	0,0,0
	.sdecl	'.debug_loc',debug,cluster('Com_Init')
	.sect	'.debug_loc'
.L119:
	.word	0,0
.L149:
	.word	0,0
.L137:
	.word	0,0
.L172:
	.word	0,0
.L97:
	.word	0,0
.L117:
	.word	0,0
.L147:
	.word	0,0
.L177:
	.word	0,0
.L190:
	.word	-1,.L44,.L41-.L44,.L220-.L44
	.half	1
	.byte	85
	.word	0,0
.L43:
	.word	-1,.L44,0,.L193-.L44
	.half	2
	.byte	138,0
	.word	.L193-.L44,.L58-.L44
	.half	2
	.byte	138,8
	.word	.L58-.L44,.L58-.L44
	.half	2
	.byte	138,0
	.word	0,0
.L164:
	.word	-1,.L44,.L216-.L44,.L217-.L44
	.half	1
	.byte	95
	.word	0,0
.L135:
	.word	0,0
.L170:
	.word	0,0
.L115:
	.word	0,0
.L95:
	.word	0,0
.L145:
	.word	0,0
.L85:
	.word	-1,.L44,.L207-.L44,.L8-.L44
	.half	1
	.byte	90
	.word	0,0
.L163:
	.word	-1,.L44,.L215-.L44,.L39-.L44
	.half	1
	.byte	89
	.word	.L40-.L44,.L26-.L44
	.half	1
	.byte	89
	.word	0,0
.L84:
	.word	-1,.L44,.L198-.L44,.L10-.L44
	.half	1
	.byte	88
	.word	.L11-.L44,.L200-.L44
	.half	1
	.byte	88
	.word	0,0
.L129:
	.word	-1,.L44,.L200-.L44,.L33-.L44
	.half	1
	.byte	88
	.word	.L34-.L44,.L39-.L44
	.half	1
	.byte	88
	.word	.L40-.L44,.L58-.L44
	.half	1
	.byte	88
	.word	0,0
.L157:
	.word	0,0
.L151:
	.word	0,0
.L80:
	.word	-1,.L44,.L197-.L44,.L10-.L44
	.half	1
	.byte	109
	.word	.L11-.L44,.L201-.L44
	.half	1
	.byte	109
	.word	0,0
.L78:
	.word	-1,.L44,.L196-.L44,.L10-.L44
	.half	1
	.byte	108
	.word	.L11-.L44,.L202-.L44
	.half	1
	.byte	108
	.word	0,0
.L109:
	.word	0,0
.L107:
	.word	0,0
.L82:
	.word	-1,.L44,.L205-.L44,.L8-.L44
	.half	1
	.byte	111
	.word	0,0
.L105:
	.word	0,0
.L87:
	.word	-1,.L44,.L204-.L44,.L8-.L44
	.half	1
	.byte	110
	.word	0,0
.L88:
	.word	-1,.L44,.L103-.L44,.L208-.L44
	.half	1
	.byte	84
	.word	.L20-.L44,.L21-.L44
	.half	1
	.byte	84
	.word	0,0
.L181:
	.word	0,0
.L183:
	.word	0,0
.L187:
	.word	0,0
.L179:
	.word	0,0
.L185:
	.word	0,0
.L127:
	.word	-1,.L44,.L201-.L44,.L33-.L44
	.half	1
	.byte	109
	.word	.L34-.L44,.L39-.L44
	.half	1
	.byte	109
	.word	.L40-.L44,.L58-.L44
	.half	1
	.byte	109
	.word	0,0
.L159:
	.word	-1,.L44,.L213-.L44,.L39-.L44
	.half	1
	.byte	110
	.word	.L40-.L44,.L26-.L44
	.half	1
	.byte	110
	.word	0,0
.L125:
	.word	-1,.L44,.L202-.L44,.L33-.L44
	.half	1
	.byte	108
	.word	.L34-.L44,.L39-.L44
	.half	1
	.byte	108
	.word	.L40-.L44,.L58-.L44
	.half	1
	.byte	108
	.word	0,0
.L161:
	.word	-1,.L44,.L214-.L44,.L39-.L44
	.half	1
	.byte	111
	.word	.L40-.L44,.L26-.L44
	.half	1
	.byte	111
	.word	0,0
.L162:
	.word	-1,.L44,.L168-.L44,.L39-.L44
	.half	1
	.byte	87
	.word	.L40-.L44,.L219-.L44
	.half	1
	.byte	87
	.word	.L41-.L44,.L42-.L44
	.half	1
	.byte	87
	.word	0,0
.L111:
	.word	0,0
.L165:
	.word	-1,.L44,.L218-.L44,.L39-.L44
	.half	5
	.byte	144,32,157,32,0
	.word	.L40-.L44,.L219-.L44
	.half	5
	.byte	144,32,157,32,0
	.word	.L41-.L44,.L42-.L44
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L99:
	.word	0,0
.L60:
	.word	-1,.L44,0,.L9-.L44
	.half	1
	.byte	100
	.word	0,0
.L71:
	.word	-1,.L44,.L194-.L44,.L195-.L44
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L73:
	.word	-1,.L44,.L195-.L44,.L9-.L44
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L131:
	.word	-1,.L44,.L209-.L44,.L33-.L44
	.half	1
	.byte	82
	.word	.L34-.L44,.L211-.L44
	.half	1
	.byte	82
	.word	0,0
.L68:
	.word	0,0
.L90:
	.word	-1,.L44,.L206-.L44,.L8-.L44
	.half	1
	.byte	89
	.word	0,0
.L141:
	.word	-1,.L44,.L210-.L44,.L33-.L44
	.half	1
	.byte	95
	.word	.L34-.L44,.L212-.L44
	.half	1
	.byte	95
	.word	0,0
.L101:
	.word	-1,.L44,.L199-.L44,.L10-.L44
	.half	5
	.byte	144,32,157,32,0
	.word	.L11-.L44,.L203-.L44
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L64:
	.word	0,0
.L66:
	.word	0,0
	.sdecl	'.debug_frame',debug
	.sect	'.debug_frame'
.L338:
	.word	48
	.word	-1
	.byte	3,0,2,1,27,12,26,0,8,27,8,26,8,28,8,29,8,30,8,31,8,34,8,35,8,32,8,33,8,16,8,17,8,24,8,25,8,36,8,37,8,38
	.byte	8,39
	.sdecl	'.debug_frame',debug,cluster('Com_Init')
	.sect	'.debug_frame'
	.word	36
	.word	.L338,.L44,.L58-.L44
	.byte	4
	.word	(.L193-.L44)/2
	.byte	19,8,22,26,3,19,138,8,4
	.word	(.L58-.L193)/2
	.byte	19,0,8,26,0,0

; BSW\src\BSW\Gen\Com\src\Com_Init.c	   619      }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   620  }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   621  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   622  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   623  /***************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   624   Function name    : Com_Prv_Init_TxSignalGroup
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   625   Syntax           : void Com_Prv_Init_TxSignalGroup(VAR(PduIdType, AUTOMATIC) IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   626   Description      : Service to initialize all configured signal Group at the sender side
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   627   Parameter        : IpduId  -> Index of the Ipdu
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   628   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   629   ***************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   630  LOCAL_INLINE FUNC(void, COM_CODE)   Com_Prv_Init_TxSignalGroup(VAR(PduIdType, AUTOMATIC) IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   631  {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   632  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   633      Com_TxIpduConstPtrType         TxIPduConstPtr; /* Local ptr to hold the address of Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   634      Com_TxSigGrpConstPtrType       TxSigGrpConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   635      VAR(uint16_least, AUTOMATIC)   Idx_ByteNSig_ui;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   636      VAR(uint16_least, AUTOMATIC)   Idx_SigGrp_ui;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   637      VAR(uint16_least, AUTOMATIC)    FirstTxSigGrp_Index;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   638  #if defined (COM_TxSigUpdateBit) || defined(COM_TxSigGrpUpdateBit)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   639      VAR(PduLengthType, AUTOMATIC)  ByteNo_u8;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   640  #endif /* #if defined (COM_TxSigUpdateBit) || defined(COM_TxSigGrpUpdateBit) */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   641  #ifdef COM_EffectiveSigGrpTOC
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   642      /* Variable to hold the Transfer Property of Signal Group */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   643      VAR(uint8, AUTOMATIC)          TxSigGrpTp_u8;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   644  #endif /* #ifdef COM_EffectiveSigGrpTOC */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   645      VAR(uint8, AUTOMATIC)          ConstByteValue_u8;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   646  #ifdef COM_TX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   647      boolean                        ConstIsSigGrpOfArrayType_b;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   648  #endif /* #ifdef COM_TX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   649  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   650      TxIPduConstPtr      = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   651  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   652      FirstTxSigGrp_Index = TxIPduConstPtr->FirstTxSigGrp_Index;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   653  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   654      Idx_ByteNSig_ui     = (uint16_least)FirstTxSigGrp_Index + (uint16_least)TxIPduConstPtr->No_Of_SigGrp_Ref;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   655  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   656      TxSigGrpConstPtr    = COM_GET_TXSIGGRP_CONSTDATA(FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   657  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   658      for(Idx_SigGrp_ui   = (uint16_least)FirstTxSigGrp_Index; Idx_SigGrp_ui < Idx_ByteNSig_ui;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   659                               Idx_SigGrp_ui++ )
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   660      {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   661  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   662  #ifdef COM_TX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   663          ConstIsSigGrpOfArrayType_b = Com_GetValue(TXSIGGRP,_ARRAYACCESS,TxSigGrpConstPtr->txSignalGrpFields);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   664  #endif /* #ifdef COM_TX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   665  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   666  #ifdef COM_SIGNALGROUPGATEWAY
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   667          /* Reset the SignalGroupGateway flag */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   668          Com_SetRamValue(TXSIGGRP,_ISGWUPDTD,COM_GET_TXSIGGRPFLAG(Idx_SigGrp_ui).txSigGrpRAMFields, COM_FALSE);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   669  #endif /* #ifdef COM_SIGNALGROUPGATEWAY */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   670  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   671          /* Call function to initialize configured transmission group signals */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   672          Com_Prv_Init_GroupSignal(TxIPduConstPtr, TxSigGrpConstPtr);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   673  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   674  #ifdef COM_EffectiveSigGrpTOC
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   675          /* Get the SignalGroup property */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   676          TxSigGrpTp_u8 = Com_GetValue(TXSIGGRP,_TP,TxSigGrpConstPtr->txSignalGrpFields);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   677          /* If SignalGroups TP is TriggeredOnChange or TriggeredOnChangeWithoutRepetition set the RAM value */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   678          if(COM_SIG_TP_IS_TRIGGERED_ON_CHANGE(TxSigGrpTp_u8))
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   679          {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   680              /* Reset TriggerredOnChange flag */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   681              Com_SetRamValue(TXSIGGRP,_TRIGONCHNG,COM_GET_TXSIGGRPFLAG(Idx_SigGrp_ui).txSigGrpRAMFields,COM_FALSE);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   682          }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   683  #endif /* #ifdef COM_EffectiveSigGrpTOC */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   684  #ifdef COM_TX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   685          /* Check if SignalGroupArray is enabled to copy the data to IPDU buffer else, do nothing
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   686           * GroupSignal's SignalInitValues are already updated into the IPduBuffer in
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   687           * Com_InitializePduBuffWithSignalInitValue() */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   688          if ( ConstIsSigGrpOfArrayType_b != COM_TRUE )
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   689  #endif /* #ifdef COM_TX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   690          {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   691              /* Copy the data which is present in Shadow buffer to IPDU buffer */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   692              Com_ShadowBuffToIpduBuff((Com_SignalGroupIdType)Idx_SigGrp_ui);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   693          }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   694  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   695  #ifdef COM_TxSigGrpUpdateBit
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   696          /* Only the first byte of txIPduFields is needed */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   697          ConstByteValue_u8 = (uint8)TxIPduConstPtr->txIPduFields;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   698          /* Clear Update bits*/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   699          /* MR12 RULE 13.5 VIOLATION: Below conditional statement reads signal field status.
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   700          * HIS-LEVEL parameter will be violated if more conditional statements are added.
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   701          * Hence the warning is suppressed. */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   702          if((Com_GetValue(TXIPDU,_CLRUPDBIT,ConstByteValue_u8) != (uint16)COM_CLRUPDATEBIT_NONE) &&
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   703                  (Com_GetValue(TXSIGGRP,_UPDBITCONF,TxSigGrpConstPtr->txSignalGrpFields)))
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   704          {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   705              /*Find the Byte No*/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   706              ByteNo_u8 = (PduLengthType)(TxSigGrpConstPtr ->Update_Bit_Pos>>3u);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   707  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   708              /*Update the Bit in IPDU Buffer*/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   709              Com_ClearUpdateBitValue(TxIPduConstPtr, TxSigGrpConstPtr->Update_Bit_Pos, ByteNo_u8)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   710          }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   711  #endif  /*COM_TxSigGrpUpdateBit*/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   712          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   713      }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   714  }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   715  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   716  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   717  /***************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   718   Function name    : Com_Prv_Init_GroupSignal
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   719   Syntax           : void Com_Prv_Init_GroupSignal(Com_TxIpduConstPtrType TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   720                                                                Com_TxSigGrpConstPtrType TxSigGrpConstPtr)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   721   Description      : Service to initialize all configured Groupsignal at the sender side
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   722   Parameter        : TxIPduConstPtr      -> Address to Tx IPdu
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   723                      TxSigGrpConstPtr    -> Address to SignalGroup
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   724   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   725   ***************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   726  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_Init_GroupSignal(Com_TxIpduConstPtrType TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   727                                                                Com_TxSigGrpConstPtrType TxSigGrpConstPtr)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   728  {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   729      /* Variable declaration */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   730      Com_TxGrpSigConstPtrType        TxGrpSigConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   731      VAR(Com_SigMaxType, AUTOMATIC)  TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   732      VAR(uint16_least, AUTOMATIC)    Idx_TxGrpSig_ui;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   733      VAR(uint8, AUTOMATIC)           ConstByteValue_u8;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   734      VAR(uint8, AUTOMATIC)           Type;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   735      VAR(Com_MainFuncType,AUTOMATIC) txMainFuncId;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   736  #ifdef COM_TX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   737      boolean                         ConstIsSigGrpOfArrayType_b;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   738      ConstIsSigGrpOfArrayType_b = Com_GetValue(TXSIGGRP,_ARRAYACCESS,TxSigGrpConstPtr->txSignalGrpFields);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   739  #endif /* #ifdef COM_TX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   740  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   741      txMainFuncId        = TxIPduConstPtr->MainFunctionRef;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   742  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   743      TxGrpSigConstPtr    = COM_GET_TXGRPSIG_CONSTDATA(TxSigGrpConstPtr-> FirstGrpSig_Index);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   744  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   745      for( Idx_TxGrpSig_ui  = (uint16_least)COM_ZERO; Idx_TxGrpSig_ui < (uint16_least)TxSigGrpConstPtr->No_Of_GrpSig;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   746                                                                            Idx_TxGrpSig_ui++)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   747      {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   748          /* Shadowbuffer of a signal Group(group signal buffers) on sender-side shall be initialized*/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   749          /* Sign extension to be performed on Init valu, when a signed value is assigned to a uint32 variable,
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   750           * it is sign extended by default*/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   751          TxGrpSig_NewVal     = (Com_SigMaxType)TxGrpSigConstPtr->Init_Val;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   752  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   753          /* Get the value of the ComSignaltype bit field */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   754          ConstByteValue_u8   = TxGrpSigConstPtr->txGrpSigFields;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   755          /* Get type of the signal */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   756          Type = Com_GetValue(TXGRPSIG,_TYPE,ConstByteValue_u8);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   757  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   758  #ifdef COM_TXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   759          /* [SWS_Com_00723] The AUTOSAR COM module shall extend the init value (ComSignalInitValue) of a
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   760           * signal to the size of its ComSignalType.
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   761           * Currently for COM_SINT64 signal type, ComSignalInitValue is supported for maximum 32bits.
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   762           * If negative values are configured, by default these values will be sign extended only till 32bits.
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   763           * so, for COM_SINT64, it is required to perform the sign extension till 64bits explicitly. */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   764          if ( Type == COM_SINT64 )
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   765          {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   766              TxGrpSig_NewVal = (Com_SigMaxType)((sint64)((sint32)TxGrpSig_NewVal));
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   767          }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   768          else
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   769          {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   770              /* do nothing for other signal types */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   771          }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   772  #endif /* #ifdef COM_TXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   773  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   774  #ifdef COM_TX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   775          if ( ConstIsSigGrpOfArrayType_b )
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   776          {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   777              Com_InitializePduBuffWithSignalInitValue( TxIPduConstPtr->BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   778                                                        TxGrpSig_NewVal,
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   779                                                        TxGrpSigConstPtr->Bit_Pos,
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   780                                                        TxGrpSigConstPtr->BitSize, Type,
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   781                                                        Com_GetValue(TXGRPSIG,_ENDIANESS,ConstByteValue_u8) );
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   782          }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   783          else
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   784  #endif /* #ifdef COM_TX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   785  #ifdef COM_TXGRPSIG_FLOAT64SUPP
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   786          if(Type == COM_FLOAT64)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   787          {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   788              /* FLOAT64 signal */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   789              /* For float64 signals, TxGrpSig_NewVal holds index to float array holding init values.*/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   790              COM_GET_TXGRPSIGTYPEFLOAT64_BUFF(txMainFuncId, TxGrpSigConstPtr->TxGrpSigBuff_Index) =
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   791                                                                               Com_getfloat64InitValue(TxGrpSig_NewVal);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   792          }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   793          else
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   794  #endif /* #ifdef COM_TXGRPSIG_FLOAT64SUPP */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   795          if(Type == COM_UINT8_N) /* UINT8_N signal */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   796          {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   797              Com_ByteCopyInit(&COM_GET_TXGRPSIGTYPEU8_BUFF(txMainFuncId, TxGrpSigConstPtr->TxGrpSigBuff_Index),
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   798                              (uint32)TxGrpSig_NewVal,(uint32)TxGrpSigConstPtr->BitSize);
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   799          }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   800          else
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   801          {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   802              Com_CopyTxGroupSignalData(
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   803                  ((Com_SignalIdType)(TxSigGrpConstPtr->FirstGrpSig_Index) + (Com_TxIntGrpSignalIdType)Idx_TxGrpSig_ui),
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   804                  TxGrpSig_NewVal, txMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   805                                       );
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   806          }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   807  
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   808          /*COM_230: The old value of the filter is set to Initial value */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   809  #if (defined(COM_TxFilters) && defined(COM_F_MASKEDNEWDIFFERSOLD))
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   810          if(TxGrpSigConstPtr->Filter_Algo == (uint8)COM_MASKED_NEW_DIFFERS_MASKED_OLD)
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   811          {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   812              COM_GET_F_OLDVALUE(TxGrpSigConstPtr->Filter_Index) = (uint32)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   813          }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   814  #endif /* #if (defined(COM_TxFilters) && defined(COM_F_MASKEDNEWDIFFERSOLD)) */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   815  #ifdef COM_EffectiveSigGrpTOC
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   816          /* Get transfer property of the group signal */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   817          if(Com_GetValue(TXGRPSIG,_TP,ConstByteValue_u8))
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   818          {
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   819              COM_GET_OLDVALTRIGONCHANGE(TxGrpSigConstPtr->OldValue_Index) = (Com_OldValTrigOnChngType)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   820          }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   821  #endif /* #ifdef COM_EffectiveSigGrpTOC */
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   822          TxGrpSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   823      }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   824  }
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   825  #endif  /*COM_TX_SIGNALGROUP*/
; BSW\src\BSW\Gen\Com\src\Com_Init.c	   826  

	; Module end
