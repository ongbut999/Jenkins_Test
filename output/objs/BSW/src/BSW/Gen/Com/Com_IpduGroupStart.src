	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 19053136 SN 09001910"
	.compiler_invocation	"ctc -f cc1448a -c99 --integer-enumeration -D__CPU__=tc27x -D__CPU_TC27X__ --core=tc1.6.x --eabi-compliant --fp-model=-float -D_TASKING_C_TRICORE_=1 -I.\\output\\inc -g2 -t4 --language=-comments,-gcc,+volatile,-strings --default-near-size=0 -O2ROPYGKLF-predict --default-a1-size=0 --default-a0-size=0 --source --switch=auto -o output\\objs\\BSW\\src\\BSW\\Gen\\Com\\Com_IpduGroupStart.src BSW\\src\\BSW\\Gen\\Com\\src\\Com_IpduGroupStart.c"
	.compiler_name		"ctc"
	;source	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_IpduGroupStart.c'

	
$TC16X
	
	.sdecl	'.text.Com_IpduGroupStart.Com_IpduGroupControl',code,cluster('Com_IpduGroupControl')
	.sect	'.text.Com_IpduGroupStart.Com_IpduGroupControl'
	.align	2
	
	.global	Com_IpduGroupControl

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	     1  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	     2  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	     3  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	     4   * Includes
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	     5   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	     6  #include "Com_Prv.h"
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	     7  #include "Com_Prv_Inl.h"
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	     8  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	     9  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    10   * Local Prototypes
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    11   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    12  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    13  static INLINE FUNC(void, COM_CODE) Com_RxIPduStart( VAR(Com_IpduIdType, AUTOMATIC)  IpduId,
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    14                                                      VAR(boolean, AUTOMATIC)         Initialize );
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    15  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    16  static INLINE FUNC(void, COM_CODE) Com_TxIPduStart( VAR(Com_IpduIdType, AUTOMATIC)  IpduId,
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    17                                                      VAR(boolean, AUTOMATIC)         Initialize );
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    18  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    19  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_ProcessIPduGroupVector(
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    20                                                      P2CONST(uint8, AUTOMATIC, COM_APPL_DATA) ipduGroupVector
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    21                                                              );
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    22  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    23  LOCAL_INLINE FUNC(void, COM_CODE)  Com_Prv_UpdateBitAndFilter(VAR(Com_IpduIdType, AUTOMATIC) IpduId);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    24  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    25  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    26  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    27   * Global functions (declared in header files)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    28   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    29  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    30  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    31   Function name    : Com_IpduGroupControl
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    32   Syntax           : void Com_IpduGroupControl( Com_IpduGroupVector ipduGroupVector, boolean initialize )
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    33   Description      : Service for controlling the Ipdu groups
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    34   Parameter        : Com_IpduGroupVector - I-PDU group vector containing the activation state (stopped = 0/started = 1)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    35                                            for all I-PDU groups.
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    36                    : Initialize          - flag to request initialization of the I-PDUs which are newly started
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    37   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    38   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    39  #define COM_START_SEC_CODE
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    40  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    41  /* HIS METRIC CALLS, VIOLATION IN Com_IpduGroupControl:
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    42     Com_IpduGroupControl function contains necessary function calls, "for" loops and simple "if" and "else if" statement.
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    43     HIS metric compliance would decrease readability and maintainability */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    44  FUNC(void, COM_CODE) Com_IpduGroupControl(
; Function Com_IpduGroupControl
.L90:
Com_IpduGroupControl:	.type	func
	mov.aa	a12,a4
.L266:
	mov	d8,d4
.L267:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    45                                  VAR(Com_IpduGroupVector, AUTOMATIC)  ipduGroupVector,
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    46                                  VAR(boolean, AUTOMATIC)              initialize
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    47                                           )
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    48  {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    49      Com_RxIpduRamPtrType            RxIPduRamPtr;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    50      Com_TxIpduRamPtrType            TxIPduRamPtr;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    51      VAR(uint16_least,AUTOMATIC)     Index_u16;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    52  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    53  #if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    54      if (Com_Prv_DETCheck_Ptr((ipduGroupVector == NULL_PTR), COMServiceId_IpduGroupControl))
	mov.a	a15,#0
.L343:
	eq.a	d15,a12,a15
.L344:
	mov	d6,#3
.L126:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     1  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     2  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     3  #ifndef COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     4  #define COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     5  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     6  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     7   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     8   * Includes
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     9   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    10  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    11  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    12  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    13  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    17  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    18  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    19  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    20  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    21   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    22   * Type definitions
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    23   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    24  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    25  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    26  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    27  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    28   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    29   * Variables
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    30   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    31  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    32  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    33  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    34  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    35   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    36   * Extern declarations
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    37   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    38  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    39  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    40   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    41   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    42   * Inline function sets TMS data in to be accessesd via CurrentTxModePtr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    43   * after evaluating TMS mode for the IPdu
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    44   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    45  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    46  FUNC(void, COM_CODE) Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    47                                  Com_TxIpduRamPtrType                TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    48                                  Com_TxIpduConstPtrType              TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    49                                  VAR(uint16,AUTOMATIC)               TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    50                                  VAR(boolean,AUTOMATIC)              ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    51                                              );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    52  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    53  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    54   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    55   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    56   * Inline function to update Rx-GroupSignal application buffers
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    57   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    58  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    59  FUNC(void, COM_CODE) Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    60                                  Com_RxSigConstPtrType               RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    61                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    62                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    63                                               );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    64  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    65  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    66   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    67   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    68   * Inline function to update Rx-GroupSignal secondary buffers
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    69   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    70  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    71  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    72  FUNC(void, COM_CODE) Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    73                                  Com_RxGrpSigConstPtrType            RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    74                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    75                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    76                                                          );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    77  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    78  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    79  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    80   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    81   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    82   * Inline function to initialize signal intial value into the provided IPdu buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    83   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    84  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    85  FUNC(void, COM_CODE) Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    86                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    87                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    88                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    89                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    90                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    91                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    92                                                              );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    93  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    94  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    95   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    96   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    97   * Inline function to initialize Rx-signal group with initial values
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    98   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    99  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   100  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   101  FUNC(void, COM_CODE) Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   102                                  Com_RxSigGrpConstPtrType            RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   103                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   104                                                  );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   105  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   106  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   107  #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   108  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxNotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   109  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxErrNotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   110  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxTONotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   111  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallRxTONotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   112  #endif /* #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   113  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   114  /* Inline function to check for the RxIPdu and TxIpdu status*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   115  LOCAL_INLINE boolean Com_CheckRxIPduStatus(PduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   116  LOCAL_INLINE boolean Com_CheckTxIPduStatus(PduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   117  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   118  #if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   119  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   120  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Void(uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   121  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   122  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Ptr(boolean isInValidPtr, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   123  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Param_Ptr(boolean isInValidParam, boolean isInValidPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   124                                                                  uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   125  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Ptr_Only(boolean isInValidPtr, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   126  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Param_Only(boolean isInValidParam, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   127  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   128  #endif /*  #if (COM_CONFIGURATION_USE_DET == STD_ON) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   129  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   130  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   131  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   132  LOCAL_INLINE FUNC(void, COM_CODE) Com_CopyTxGroupSignalData( Com_SignalIdType    GrpSignalId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   133                                                               Com_SigMaxType      TxGrpSig_NewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   134                                                               Com_MainFuncType    TxMainFuncId );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   135  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   136  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   137  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   138   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   139   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   140   * Inline function to handle gateway and non-gateway use-case for tx-signal/signalGroup
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   141   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   142  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_ProceedToSendIpdu(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   143                                                  VAR(Com_IpduIdType, AUTOMATIC)          ComTxPduId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   144                                                  VAR(Com_SendIpduInfo, AUTOMATIC)        sendIpduFlag_u16
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   145                                                             );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   146  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   147  #ifdef COM_TxFilters
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   148  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_CheckModeChange(VAR(Com_IpduIdType, AUTOMATIC) TxIpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   149  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   150  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   151  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   152  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   153   * Inline Function Definition
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   154   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   155  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   156  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   157   Function name    : Com_SetCurrentTxModePtr [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   158   Syntax           : void Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   159                                  Com_TxIpduRamPtrType    TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   160                                  Com_TxIpduConstPtrType  TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   161                                  uint16                  TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   162                                  boolean                 ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   163                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   164   Description      : Inline function sets TMS data in to be accessesd via CurrentTxModePtr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   165                      after evaluating TMS mode for the IPdu
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   166  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   167                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   168                       * Mode                  |    Configuration details                              | Value|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   169                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   170                       * COM_MODE_VALID        |    Both the TRUE and FALSE modes are configured.      |    00|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   171                       * COM_TRUEMODE_VALID    |    Only TRUE mode is configured                       |    01|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   172                       * COM_FALSEMODE_VALID   |    Only FALSE mode is configured                      |    10|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   173                       * COM_MODE_INVALID      |    Both the TRUE and FALSE mode are not configured    |    11|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   174                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   175                      This INLINE function checks the TMS generated values against the requested mode and performs action
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   176                      |-------------|--------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   177                      |ModeRequested|Configured Mode values   |         Description                                           :      Action to be taken                |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   178                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   179                      |    0       |      0        |      0   |  FALSE mode is requested and IPdu TMS is COM_MODE_VALID         : Increment to the false mode data     |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   180                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   181                      |    0       |      0        |      1   |  FALSE mode is requested and IPdu TMS is COM_TRUEMODE_VALID     : Point to NONE mode data              |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   182                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   183                      |    0       |      1        |      0   |  FALSE mode is requested and IPdu TMS is COM_FALSEMODE_VALID     : Do nothing                          |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   184                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   185                      |    0       |      1        |      1   |  FALSE mode is requested and IPdu TMS is COM_MODE_INVALID     : Do nothing                             |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   186                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   187                      |    1       |      0        |      0   |  TRUE mode is requested and IPdu TMS is COM_MODE_VALID         : Do nothing                            |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   188                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   189                      |    1       |      0        |      1   |  TRUE mode is requested and IPdu TMS is COM_TRUEMODE_VALID     : Do nothing                            |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   190                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   191                      |    1       |      1        |      0   |  TRUE mode is requested and IPdu TMS is COM_FALSEMODE_VALID     : Point to NONE mode data              |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   192                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   193                      |    1       |      1        |      1   |  TRUE mode is requested and IPdu TMS is COM_MODE_INVALID         : Do nothing                          |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   194                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   195  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   196                      where 0 in column 1 stands for FALSE mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   197                      and   1 in column 1 stands for TRUE mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   198  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   199   Parameter        : TxIpduRamPtr    - pointer to Txipdu ram data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   200                    : TxIPduConstPtr  - pointer to Txipdu Rom data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   201                    : TMSStatus       - pointer to transmission mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   202                    : ModeRequested   - mode requested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   203   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   204   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   205  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   206  FUNC(void, COM_CODE) Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   207                                  Com_TxIpduRamPtrType                TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   208                                  Com_TxIpduConstPtrType              TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   209                                  VAR(uint16,AUTOMATIC)               TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   210                                  VAR(boolean,AUTOMATIC)              ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   211                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   212  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   213      /* Get the latest TM pointer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   214      TxIpduRamPtr->CurrentTxModePtr = TxIPduConstPtr->Com_TMConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   215  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   216      if(ModeRequested == COM_FALSE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   217      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   218          if((TMSStatus) == COM_TRUEMODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   219          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   220              /*If yes,load NONE mode data */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   221              TxIpduRamPtr->CurrentTxModePtr = &Com_NONE_TransModeInfo ;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   222          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   223          if((TMSStatus) == COM_MODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   224          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   225              /*Increment to FALSE mode data, if the FALSE mode is configured */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   226              TxIpduRamPtr->CurrentTxModePtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   227          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   228      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   229      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   230      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   231          if((TMSStatus) == COM_FALSEMODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   232          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   233              TxIpduRamPtr->CurrentTxModePtr = &Com_NONE_TransModeInfo ;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   234          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   235      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   236  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   237  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   238  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   239   Function name    : Com_UpdateRxGroupSignalSecondBuffer [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   240   Syntax           : void Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   241                                  Com_RxGrpSigConstPtrType    RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   242                                  Com_SigMaxType              RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   243                                  Com_MainFuncType            RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   244                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   245   Description      : Inline function copy Group signal value into the Group signal Second buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   246   Parameter        : RxGrpSigConstPtr - pointer to RxGroupSignal configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   247                    : RxNewVal         - latest RxGroupSignal data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   248                    : RxMainFuncId     - Internally generated Rx-MainFunction-Id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   249   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   250   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   251  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   252  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   253  FUNC(void, COM_CODE) Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   254                                  Com_RxGrpSigConstPtrType            RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   255                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   256                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   257                                                          )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   258  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   259      VAR(uint8,AUTOMATIC)    Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   260  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   261      Type = Com_GetValue(RXGRPSIG,_TYPE,RxGrpSigConstPtr->rxGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   262  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   263      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   264      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   265      case 0x00u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   266          /* UINT08 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   267          COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint8)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   268          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   269  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   270      case 0x01u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   271          /* UINT16 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   272          COM_GET_SECRXGRPSIGTYPEU16_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint16)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   273          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   274  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   275      case 0x02u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   276          /* UINT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   277          /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   278      case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   279          /* FLOAT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   280          /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   281          COM_GET_SECRXGRPSIGTYPEU32_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint32)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   282          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   283  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   284  #ifdef COM_RXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   285      case 0x08u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   286          /* UINT64/SINT64 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   287          COM_GET_SECRXGRPSIGTYPEU64_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   288          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   289  #endif /* #ifdef COM_RXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   290  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   291      case 0x03u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   292          /*Boolean Signal*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   293          COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint8)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   294          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   295  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   296      case 0x04u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   297          /* UINT8_N signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   298          Com_ByteCopyInit(&COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index),
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   299                           (uint32)RxNewVal,RxGrpSigConstPtr->BitSize);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   300          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   301      default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   302          /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   303           * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are allowed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   304           * to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   305           */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   306          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   307  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   308      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   309  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   310  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   311  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   312  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   313   Function name    : Com_UpdateRxSignalBuffer [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   314   Syntax           : void Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   315                                  Com_RxSigConstPtrType   RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   316                                  Com_SigMaxType          RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   317                                  Com_MainFuncType        RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   318                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   319   Description      : Inline function to copy signal value into the signal buffer and
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   320                      is used when signal value as a variable is being passed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   321   Parameter        : RxSigConstPtr - pointer to RxSignal configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   322                    : RxNewVal_Sig  - latest RxSignal data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   323                    : RxMainFuncId  - Internally generated Rx-MainFunction-Id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   324   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   325   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   326  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   327  FUNC(void, COM_CODE) Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   328                                  Com_RxSigConstPtrType               RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   329                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   330                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   331                                               )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   332  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   333      VAR(uint8,AUTOMATIC)    Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   334  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   335      Type = Com_GetValue(GEN,_TYPE,RxSigConstPtr->General);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   336  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   337      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   338      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   339      case 0x00u:     /* COM_UINT8 & COM_SINT8 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   340      case (COM_BOOLEAN >> 1):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   341          COM_GET_SIGTYPEUINT8_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint8)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   342          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   343  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   344      case 0x01u:     /* COM_UINT16 & COM_SINT16 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   345          COM_GET_SIGTYPEUINT16_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint16)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   346          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   347  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   348      case 0x02u:     /* COM_UINT32 & COM_SINT32 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   349  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   350          /* COM_FLOAT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   351  #ifdef COM_FLOAT32SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   352      case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   353  #endif /* #ifdef COM_FLOAT32SUPP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   354  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   355          COM_GET_SIGTYPEUINT32_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint32)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   356          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   357  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   358  #ifdef COM_RXSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   359      case 0x08u:     /* COM_UINT64 & COM_SINT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   360          COM_GET_SIGTYPEUINT64_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   361          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   362  #endif /* #if defined(COM_RXSIG_INT64) && defined(COM_TXSIG_INT64) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   363  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   364      case 0x04u:     /* COM_UINT8_N */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   365          Com_ByteCopyInit(&COM_GET_SIGTYPEUINT8_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index),
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   366                           (uint32)RxNewVal_Sig,RxSigConstPtr->BitSize);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   367          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   368      default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   369          /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   370           * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are allowed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   371           * to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   372           */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   373          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   374      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   375  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   376  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   377  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   378   Function name    : Com_InitializePduBuffWithSignalInitValue [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   379   Syntax           : void Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   380                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   381                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   382                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   383                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   384                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   385                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   386                                                                   )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   387   Description      : Inline function to call required interface to pack signal data into Ipdu buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   388   Parameter        : BuffPtr     - pointer to (SignalGroup)IPdu Buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   389                    : SigInitVal  - (Group)Signal InitValue
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   390                    : SigBitPos   - (Group)Signal Bit Position
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   391                    : SigBitSize  - (Group)Signal Bit Size
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   392                    : SigType     - (Group)Signal Type
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   393                    : SigEndianess- (Group)Signal Endianness
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   394   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   395   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   396  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   397  FUNC(void, COM_CODE) Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   398                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   399                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   400                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   401                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   402                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   403                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   404                                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   405  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   406      if ( SigType != (uint8)COM_UINT8_N )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   407      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   408  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   409  #if (defined(COM_TXSIG_FLOAT64SUPP) || defined(COM_TXGRPSIG_FLOAT64SUPP) ||\ 
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   410      (defined(COM_RX_SIGNALGROUP_ARRAY) && defined(COM_RXGRPSIG_FLOAT64SUPP)))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   411          if ( SigType == COM_FLOAT64 )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   412          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   413              /* Convert the float value into 32 bit stream and then pack the value */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   414              /* Com_PackFloatSignal(TxSigConstPtr->General.Endianess,TxSigConstPtr->Bit_Pos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   415                                     Com_getfloat64InitValue(SigNewVal), TxIPduConstPtr->BuffPtr); */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   416              Com_PackFloatSignal( SigEndianess, SigBitPos, Com_getfloat64InitValue(SigInitVal), BuffPtr );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   417          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   418          else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   419  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   420  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   421          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   422              /* Pack the signal with Initial Value */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   423              /* Com_PackSignal(TxSigConstPtr->General.Endianess,TxSigConstPtr->Bit_Pos,TxSigConstPtr->BitSize,SigNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   424               *                TxIPduConstPtr->BuffPtr);*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   425              Com_PackSignal( SigEndianess, SigBitPos, SigBitSize, SigInitVal, BuffPtr );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   426          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   427      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   428      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   429      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   430          PduLengthType ByteOffset_uo;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   431          /* Find the starting byte position(ByteNo_uo) of Signal in the IPDU buffer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   432          ByteOffset_uo = ( PduLengthType )( SigBitPos >> 3 );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   433  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   434          /* Now copy the Signal into the IPDU buffer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   435          Com_ByteCopyInit( (BuffPtr + ByteOffset_uo), (uint32)SigInitVal, SigBitSize );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   436      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   437  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   438  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   439  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   440   Function name    : Com_Prv_SigGrpReplaceToInit
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   441   Syntax           : void Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   442                                          Com_RxSigGrpConstPtrType  RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   443                                          Com_MainFuncType          RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   444                                                      )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   445   Description      : If the SigGrp is enabled with ArrayAccess, RxSigGrpBuffer will be packed with
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   446                      GroupSignal Init Values OR else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   447                      GroupSignals Shadow buffers will be replaced with its Init Values
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   448   Parameter        : RxSigGrpConstPtr - pointer to RxSignalGroup configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   449                    : RxMainFuncId     - Internally generated RxMainFunction-ID
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   450   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   451   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   452  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   453  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   454                                                  Com_RxSigGrpConstPtrType        RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   455                                                  VAR(Com_MainFuncType,AUTOMATIC) RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   456                                                               )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   457  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   458      Com_RxGrpSigConstPtrType      RxGrpSigConstPtr;      /* Local pointer to Rx GroupSignal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   459  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   460      Com_RxSigGrpArrayConstPtrType RxSigGrpArrayConstPtr; /* Local pointer to Rx SignalGroup Array configuration  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   461      uint8                       * RxSigGrpArrayBufRamPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   462      PduLengthType                 SigGrpBitOffset;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   463  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   464      VAR(uint16_least, AUTOMATIC)  index_ui;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   465      VAR(Com_SigMaxType, AUTOMATIC) SigValue;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   466  # if (defined(COM_RX_SIGNALGROUP_ARRAY) || defined(COM_RXGRPSIG_FLOAT64SUPP) || defined(COM_RXGRPSIG_INT64))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   467      VAR(uint8, AUTOMATIC)         SigType;  /* Signal Type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   468  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   469  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   470      boolean                       ConstIsSigGrpOfArrayType_b;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   471  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   472      ConstIsSigGrpOfArrayType_b = Com_GetValue(RXSIGGRP,_ARRAYACCESS,RxSigGrpConstPtr->rxSignalGrpFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   473  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   474      if ( ConstIsSigGrpOfArrayType_b )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   475      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   476          RxSigGrpArrayConstPtr  = COM_GET_RXSIGGRP_ARRAY_CONSTDATA( RxSigGrpConstPtr->SigGrpArray_Index );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   477  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   478          RxSigGrpArrayBufRamPtr = &COM_GET_RXSIGGRP_ARRAY_BUFF(RxMainFuncId, RxSigGrpArrayConstPtr->RxSigGrpBuf_Index );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   479  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   480          SigGrpBitOffset        = ( RxSigGrpArrayConstPtr->FirstByteNo * 8u );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   481  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   482          SchM_Enter_Com_RxSigGrpArrayBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   483      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   484      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   485  # endif /* # ifdef COM_RX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   486      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   487          SchM_Enter_Com_RxGrpSigSecBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   488      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   489  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   490      RxGrpSigConstPtr = COM_GET_RXGRPSIG_CONSTDATA( RxSigGrpConstPtr->FirstGrpSig_Index );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   491  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   492      for ( index_ui = (uint16_least)RxSigGrpConstPtr->No_Of_GrpSig; index_ui != (uint16_least)0; index_ui-- )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   493      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   494  # if (defined(COM_RX_SIGNALGROUP_ARRAY) || defined(COM_RXGRPSIG_FLOAT64SUPP) || defined(COM_RXGRPSIG_INT64))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   495          SigType = Com_GetValue(RXGRPSIG,_TYPE,RxGrpSigConstPtr->rxGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   496  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   497  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   498          SigValue = (Com_SigMaxType)RxGrpSigConstPtr->Init_Val;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   499  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   500  #ifdef COM_RXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   501          /* [SWS_Com_00723] The AUTOSAR COM module shall extend the init value (ComSignalInitValue) of a signal
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   502           * to the size of its ComSignalType.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   503           * Currently for COM_SINT64 signal type, ComSignalInitValue is supported for maximum 32bits.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   504           * If negative values are configured, by default these values will be sign extended only till 32bits.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   505           * so, for COM_SINT64, it is required to perform the sign extension till 64bits explicity. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   506          SigValue = (SigType == COM_SINT64) ? (Com_SigMaxType)((sint64)((sint32)SigValue)) : SigValue;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   507  #endif /* #ifdef COM_RXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   508  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   509  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   510          if ( ConstIsSigGrpOfArrayType_b )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   511          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   512              Com_BitpositionType RelativeSigBitPos; /* Relative BitPosition in RxSignalGroup Array */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   513  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   514              /* The Buffer into which Signal Values needs to be packed will be available with starting address
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   515               * of the Rx-SignalGroup Array Buffer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   516               * But we have GroupSignal: Bit_Pos, i.e., Signal's actual LSB in the IPdu Buffer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   517               * So, Rx-SignalGroup BitOffset(SigGrpBitOffset) is removed from each of the GroupSignal and
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   518               * is used as BitPosition to pack its value into the Rx-SignalGroup Array Buffer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   519              RelativeSigBitPos = RxGrpSigConstPtr->Bit_Pos - ( Com_BitpositionType )SigGrpBitOffset;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   520  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   521              Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   522                                                RxSigGrpArrayBufRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   523                                                SigValue,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   524                                                RelativeSigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   525                                                RxGrpSigConstPtr->BitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   526                                                SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   527                                                Com_GetValue(RXGRPSIG,_ENDIANESS,RxGrpSigConstPtr->rxGrpSigFields) );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   528          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   529          else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   530  # endif /* #ifdef COM_RX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   531          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   532  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   533  # ifdef COM_RXGRPSIG_FLOAT64SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   534              if(SigType == COM_FLOAT64)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   535              {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   536                  COM_GET_SECRXGRPSIGTYPEFLOAT64_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) =
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   537                                                                        Com_getfloat64InitValue(SigValue);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   538              }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   539              else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   540  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   541  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   542              {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   543                  Com_UpdateRxGroupSignalSecondBuffer(RxGrpSigConstPtr, SigValue, RxMainFuncId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   544              }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   545          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   546  # if defined(COM_RxFilters) && defined(COM_F_MASKEDNEWDIFFERSOLD)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   547          /* [SWS_Com_00603] The AUTOSAR COM module shall set the old_value of the filtering mechanisms
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   548           * for each signal to the ComSignalInitValue during start-up */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   549          if ( ( COM_INIT != Com_Uninit_Flag ) && ( COM_MASKED_NEW_DIFFERS_MASKED_OLD == RxGrpSigConstPtr->Filter_Algo ) )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   550          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   551              COM_GET_F_OLDVALUE(RxGrpSigConstPtr->Filter_Index) = (uint32)SigValue;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   552          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   553  # endif /* # if defined(COM_RxFilters) && defined(COM_F_MASKEDNEWDIFFERSOLD) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   554  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   555          RxGrpSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   556      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   557  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   558  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   559      if ( ConstIsSigGrpOfArrayType_b )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   560      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   561          SchM_Exit_Com_RxSigGrpArrayBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   562      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   563      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   564  # endif /* # ifdef COM_RX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   565      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   566          SchM_Exit_Com_RxGrpSigSecBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   567      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   568  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   569  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   570  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   571  #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   572  #ifdef COM_TxIPduNotification
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   573  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxNotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   574          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   575      Com_TxIpduConstPtrType TxIPduConstPtr;    /* Local pointer to Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   576      Com_TxSigConstPtrType TxSigConstPtr;    /* Local pointer to Tx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   577  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   578      Com_TxSigGrpConstPtrType TxSigGrpConstPtr; /* Local pointer to hold the address of Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   579  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   580      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   581  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   582      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   583      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   584      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   585  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   586      IpduId = COM_GET_TX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   587      TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   588      TxSigConstPtr = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   589  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   590      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(TxIPduConstPtr->FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   591  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   592  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   593      for(index_u8 = TxIPduConstPtr->TxSigId_Index; index_u8 < (TxIPduConstPtr->TxSigId_Index + TxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   594      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   595          if(TxSigConstPtr->Notification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   596          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   597              TxSigConstPtr->Notification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   598          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   599          TxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   600      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   601  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   602      for(index_u8 = TxIPduConstPtr->FirstTxSigGrp_Index; index_u8 < (TxIPduConstPtr->FirstTxSigGrp_Index + TxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   603      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   604          if(TxSigGrpConstPtr->Notification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   605          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   606              TxSigGrpConstPtr->Notification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   607          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   608          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   609      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   610  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   611  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   612          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   613  #endif /* #ifdef COM_TxIPduNotification */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   614  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   615  #ifdef COM_ERRORNOTIFICATION
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   616  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxErrNotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   617  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   618  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   619      Com_TxIpduConstPtrType TxIPduConstPtr;    /* Local pointer to Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   620      Com_TxSigConstPtrType TxSigConstPtr;    /* Local pointer to Tx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   621  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   622      Com_TxSigGrpConstPtrType TxSigGrpConstPtr; /* Local pointer to hold the address of Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   623  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   624      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   625  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   626      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   627      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   628      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   629  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   630      IpduId = COM_GET_TX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   631      TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   632      TxSigConstPtr = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   633  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   634      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(TxIPduConstPtr->FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   635  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   636  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   637      for(index_u8 = TxIPduConstPtr->TxSigId_Index; index_u8 < (TxIPduConstPtr->TxSigId_Index + TxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   638      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   639          if(TxSigConstPtr->NotificationError_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   640          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   641              TxSigConstPtr->NotificationError_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   642          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   643          TxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   644      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   645  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   646      for(index_u8 = TxIPduConstPtr->FirstTxSigGrp_Index; index_u8 < (TxIPduConstPtr->FirstTxSigGrp_Index + TxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   647      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   648          if(TxSigGrpConstPtr->NotificationError_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   649          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   650              TxSigGrpConstPtr->NotificationError_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   651          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   652          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   653      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   654  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   655  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   656  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   657  #endif /* #ifdef COM_ERRORNOTIFICATION */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   658  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   659  #ifdef COM_TxIPduTimeOutNotify
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   660  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxTONotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   661  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   662  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   663      Com_TxIpduConstPtrType TxIPduConstPtr;    /* Local pointer to Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   664      Com_TxSigConstPtrType TxSigConstPtr;    /* Local pointer to Tx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   665  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   666      Com_TxSigGrpConstPtrType TxSigGrpConstPtr; /* Local pointer to hold the address of Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   667  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   668      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   669  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   670      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   671      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   672      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   673  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   674      IpduId = COM_GET_TX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   675      TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   676      TxSigConstPtr = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   677  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   678      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(TxIPduConstPtr->FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   679  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   680  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   681      for(index_u8 = TxIPduConstPtr->TxSigId_Index; index_u8 < (TxIPduConstPtr->TxSigId_Index + TxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   682      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   683          if(TxSigConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   684          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   685              TxSigConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   686          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   687          TxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   688      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   689  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   690      for(index_u8 = TxIPduConstPtr->FirstTxSigGrp_Index; index_u8 < (TxIPduConstPtr->FirstTxSigGrp_Index + TxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   691      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   692          if(TxSigGrpConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   693          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   694              TxSigGrpConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   695          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   696          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   697      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   698  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   699  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   700  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   701  #endif /* #ifdef COM_TxIPduTimeOutNotify */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   702  #ifdef COM_RxIPduTimeoutNotify
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   703  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallRxTONotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   704  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   705  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   706      Com_RxIpduConstPtrType RxIPduConstPtr;    /* Local pointer to Rx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   707      Com_RxSigConstPtrType RxSigConstPtr;    /* Local pointer to Rx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   708  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   709      Com_RxSigGrpConstPtrType RxSigGrpConstPtr; /* Local pointer to hold the address of Rx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   710  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   711      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   712  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   713      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   714      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   715      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   716  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   717      IpduId = COM_GET_RX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   718      RxIPduConstPtr = COM_GET_RX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   719      RxSigConstPtr = COM_GET_RXSIG_CONSTDATA(RxIPduConstPtr->RxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   720  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   721      RxSigGrpConstPtr = COM_GET_RXSIGGRP_CONSTDATA(RxIPduConstPtr->FirstRxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   722  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   723  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   724      for(index_u8 = RxIPduConstPtr->RxSigId_Index; index_u8 < (RxIPduConstPtr->RxSigId_Index + RxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   725      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   726          if(RxSigConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   727          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   728              RxSigConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   729          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   730          RxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   731      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   732  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   733      for(index_u8 = RxIPduConstPtr->FirstRxSigGrp_Index; index_u8 < (RxIPduConstPtr->FirstRxSigGrp_Index + RxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   734      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   735          if(RxSigGrpConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   736          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   737              RxSigGrpConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   738          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   739          RxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   740      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   741  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   742  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   743  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   744  #endif /* #ifdef COM_RxIPduTimeoutNotify */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   745  #endif /* #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   746  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   747  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   748  LOCAL_INLINE FUNC(void, COM_CODE) Com_CopyTxGroupSignalData( Com_SignalIdType    GrpSignalId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   749                                                               Com_SigMaxType      TxGrpSig_NewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   750                                                               Com_MainFuncType    TxMainFuncId )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   751  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   752      Com_TxGrpSigConstPtrType                   TxGrpSigConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   753      VAR(Com_TxGrpSigBuffIndexType, AUTOMATIC)  GrpSigBuff_Index;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   754      VAR(uint8, AUTOMATIC)                      Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   755  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   756      TxGrpSigConstPtr = COM_GET_TXGRPSIG_CONSTDATA(GrpSignalId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   757      GrpSigBuff_Index = TxGrpSigConstPtr->TxGrpSigBuff_Index;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   758      Type = Com_GetValue(TXGRPSIG,_TYPE,TxGrpSigConstPtr->txGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   759  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   760      SchM_Enter_Com_TxGrpSigBuffer();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   761      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   762      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   763  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   764          case 0x00u: /* UINT8 and SINT8 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   765          case 0x03u: /* Boolean type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   766              COM_GET_TXGRPSIGTYPEU8_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint8)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   767              break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   768  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   769          /* UINT16 and SINT16 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   770          case 0x01u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   771              COM_GET_TXGRPSIGTYPEU16_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint16)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   772              break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   773  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   774          /* UINT32,SINT32 and FLOAT32 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   775          case 0x02u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   776          /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   777  #ifdef COM_FLOAT32SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   778          case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   779  #endif /* #ifdef COM_FLOAT32SUPP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   780          /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   781              COM_GET_TXGRPSIGTYPEU32_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint32)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   782              break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   783  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   784          /* UINT64 and SINT64 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   785  #ifdef COM_TXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   786          case 0x08u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   787              COM_GET_TXGRPSIGTYPEU64_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint64)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   788          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   789  #endif /* #ifdef COM_TXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   790  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   791          default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   792              /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   793               * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   794               * allowed to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   795               */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   796          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   797     }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   798      SchM_Exit_Com_TxGrpSigBuffer();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   799  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   800  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   801  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   802  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   803  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   804  #if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   805  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   806  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   807   Function name    : Com_Prv_DETCheck_Void
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   808   Syntax           : boolean Com_Prv_DETCheck_Void(uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   809   Description      : Inline function to check for module initialization
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   810   Parameter        : ApiId - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   811   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   812                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   813   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   814  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Void(uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   815  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   816      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   817      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   818  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   819      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   820      Status  = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   821  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   822      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   823      if (Com_Uninit_Flag == COM_UNINIT)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   824      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   825          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   826          COM_REPORT_ERROR_CHECK(ApiId, COM_E_UNINIT);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   827          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   828          Status = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   829      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   830      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   831      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   832          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   833      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   834  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   835      return Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   836  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   837  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   838  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   839   Function name    : Com_Prv_DETCheck_Param
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   840   Syntax           : boolean Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   841   Description      : Inline function to check for module initialization and valid parameter value.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   842   Parameter        : isInValidParam - calling service is called with invalid parameter value
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   843                      ApiId          - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   844   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   845                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   846   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   847  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   848  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   849      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   850      uint8   ErrorId;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   851      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   852  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   853      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   854      ErrorId = COM_DET_NO_ERROR;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   855      Status  = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   856  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   857      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   858      if (Com_Uninit_Flag == COM_UNINIT)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   859      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   860          ErrorId = COM_E_UNINIT;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   861      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   862      else if (isInValidParam)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   863      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   864          ErrorId = COM_E_PARAM;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   865      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   866      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   867      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   868          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   869      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   870  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   871      /* Check if ErrorId has Error Code */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   872      if (ErrorId != COM_DET_NO_ERROR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   873      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   874          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   875          COM_REPORT_ERROR_CHECK(ApiId, ErrorId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   876          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   877          Status = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   878      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   879      return Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   880  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   881  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   882  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   883   Function name    : Com_Prv_DETCheck_Ptr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   884   Syntax           : boolean Com_Prv_DETCheck_Ptr(boolean isInValidPtr, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   885   Description      : Inline function to check for module initialization and valid pointer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   886   Parameter        : isInValidPtr - calling service is called with invalid pointer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   887                      ApiId        - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   888   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   889                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   890   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   891  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Ptr(boolean isInValidPtr, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   892  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   893      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   894      uint8   ErrorId;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   895      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   896  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   897      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   898      ErrorId = COM_DET_NO_ERROR;
	mov	d7,#255
.L268:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   899      Status  = COM_TRUE;
	mov	d0,#1
.L269:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   900  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   901      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   902      if (Com_Uninit_Flag == COM_UNINIT)
	movh.a	a15,#@his(Com_Uninit_Flag)
	lea	a15,[a15]@los(Com_Uninit_Flag)
	ld.w	d1,[a15]
.L345:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   902      if (Com_Uninit_Flag == COM_UNINIT)      (inlined)
	jne	d1,#0,.L2
.L346:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   903      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   904          ErrorId = COM_E_UNINIT;
	mov	d7,#2
.L347:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   904          ErrorId = COM_E_UNINIT;      (inlined)
	j	.L3

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   902      if (Com_Uninit_Flag == COM_UNINIT)      (inlined)
.L2:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   906      else if (isInValidPtr)      (inlined)
	jeq	d15,#0,.L4
.L348:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   905      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   906      else if (isInValidPtr)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   907      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   908          ErrorId = COM_E_PARAM_POINTER;
	mov	d7,#3
.L349:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   908          ErrorId = COM_E_PARAM_POINTER;      (inlined)
	j	.L5

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   906      else if (isInValidPtr)      (inlined)
.L4:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   910      else      (inlined)
.L5:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   906      else if (isInValidPtr)      (inlined)
.L3:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   909      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   910      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   911      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   912          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   913      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   914  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   915      /* Check if ErrorId has Error Code */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   916      if (ErrorId != COM_DET_NO_ERROR)
	mov	d15,#255
.L350:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   916      if (ErrorId != COM_DET_NO_ERROR)      (inlined)
	jeq	d15,d7,.L6
.L351:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   917      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   918          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   919          COM_REPORT_ERROR_CHECK(ApiId, ErrorId);
	mov	d4,#50
.L264:
	mov	d5,#0
	call	Det_ReportError
.L265:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   920          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   921          Status = COM_FALSE;
	mov	d0,#0

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   916      if (ErrorId != COM_DET_NO_ERROR)      (inlined)
.L6:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   923      return Status;      (inlined)
	j	.L7

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   924  }      (inlined)
.L7:
	jeq	d0,#0,.L8
.L127:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    55  #endif
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    56      {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    57          /* A call to the API Com_ReceptionDMControl is made to set the DM vector with the same value
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    58           * as that of the IPduGroupVector */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    59          Com_ReceptionDMControl(ipduGroupVector);
	mov.aa	a4,a12
.L270:
	call	Com_ReceptionDMControl
.L136:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    60  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    61          /* Extract ipduGroupVector and flag changed IpduGroups */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    62          Com_Prv_ProcessIPduGroupVector((P2CONST(uint8, AUTOMATIC, COM_APPL_DATA))ipduGroupVector);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    63  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    64          RxIPduRamPtr   = &COM_GET_RXPDURAM_S(0);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    65          for (Index_u16 = 0; Index_u16 < COM_GET_NUM_RX_IPDU; Index_u16++)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    66          {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    67              /* If any of the Ipdu Group containing the IPdu is active,
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    68               * i.e., counter will have non-zero value */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    69              if (COM_GET_IPDUCOUNTER_S(Index_u16) > 0)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    70              {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    71                  /* If the PDU state is changed from STOP to START */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    72                  if (Com_GetRamValue(RXIPDU,_PDUSTATUS,RxIPduRamPtr->RxFlags) == COM_STOP)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    73                  {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    74                      Com_RxIPduStart((Com_IpduIdType)Index_u16,initialize);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    75  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    76                      Com_SetRamValue(RXIPDU,_PDUSTATUS,RxIPduRamPtr->RxFlags,COM_START);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    77                  }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    78              }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    79              else
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    80              {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    81                  /* If the PDU state is changed from START to STOP */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    82                  if (Com_GetRamValue(RXIPDU,_PDUSTATUS,RxIPduRamPtr->RxFlags))
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    83                  {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    84                      Com_SetRamValue(RXIPDU,_INDICATION,RxIPduRamPtr->RxFlags,COM_FALSE);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    85  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    86                      Com_SetRamValue(RXIPDU,_PDUSTATUS,RxIPduRamPtr->RxFlags,COM_STOP);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    87                      /* Large Pdu Rx status is reset, No further calls for this reception are processed */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    88                      Com_SetRamValue(RXIPDU,_LARGEDATAINPROG,RxIPduRamPtr->RxFlags,COM_FALSE);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    89                  }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    90              }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    91  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    92              RxIPduRamPtr++;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    93          } /*End of RxIpdu for loop */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    94  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    95          TxIPduRamPtr   = &COM_GET_TXPDURAM_S(0);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    96          for (Index_u16 = 0; Index_u16 < COM_GET_NUM_TX_IPDU; Index_u16++)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    97          {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    98              /* If any of the Ipdu Group containing the IPdu is active,
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	    99               * i.e., counter will have non-zero value */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   100              if (COM_GET_IPDUCOUNTER_S(Index_u16 + COM_GET_NUM_RX_IPDU) > 0)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   101              {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   102                  /* If the PDU state is changed from STOP to START */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   103                  if (Com_GetRamValue(TXIPDU,_PDUSTATUS,TxIPduRamPtr->Com_TxFlags) == COM_STOP)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   104                  {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   105                      /* NOTE: This below order is to be maintained, to avoid any interrupt related race conditions.
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   106                       * REASON: If the below function call is interrupted, by any other API,
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   107                       * as the _PDUSTATUS is set after the function returns,
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   108                       * the interrupting API returns without any effect */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   109                      Com_TxIPduStart((Com_IpduIdType)Index_u16,initialize);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   110  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   111                      Com_SetRamValue(TXIPDU,_PDUSTATUS,TxIPduRamPtr->Com_TxFlags,COM_START);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   112                      /* By default release the large Ipdu buffer lock, which is acquired in Com_Prv_SendIpdu */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   113                      Com_SetRamValue(TXIPDU,_LARGEDATAINPROG,TxIPduRamPtr->Com_TxFlags,COM_FALSE);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   114                  }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   115              }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   116              else
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   117              {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   118                  /* If the PDU state is changed from START to STOP */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   119                  if (Com_GetRamValue(TXIPDU,_PDUSTATUS,TxIPduRamPtr->Com_TxFlags))
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   120                  {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   121                      /* NOTE: This below order is to be maintained, to avoid any interrupt related race conditions.
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   122                       * REASON: If the below function call is interrupted, by any other API,
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   123                       * as the _PDUSTATUS is set before the function call,
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   124                       * the interrupting API returns without any effect */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   125                      Com_SetRamValue(TXIPDU,_PDUSTATUS,TxIPduRamPtr->Com_TxFlags,COM_STOP);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   126                      Com_TxIPduStop((Com_IpduIdType)Index_u16);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   127                  }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   128              }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   129  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   130              TxIPduRamPtr++;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   131          } /*  End of TxIpdu for loop  */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   132      }/* End of DET Check */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   133  }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   134  #define COM_STOP_SEC_CODE
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   135  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   136  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   137  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   138  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   139   Function name    : Com_Prv_ProcessIPduGroupVector
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   140   Syntax           : void Com_Prv_ProcessIPduGroupVector( const uint8 * ipduGroupVector )
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   141   Description      : Service to process IPduGroupVector and to modify the local IPduGroups states as requested
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   142                      by the application.
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   143   Parameter        : ipduGroupVector - I-PDU group vector containing the latest activation state
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   144                                        (stopped = 0/started = 1) for all I-PDU groups.
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   145                    : Initialize      - flag to request initialization of the I-PDUs which are newly started
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   146   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   147   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   148  /* HIS METRIC LEVEL VIOLATION IN Com_Prv_ProcessIPduGroupVector:
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   149     Com_Prv_ProcessIPduGroupVector function contains necessary function calls statements.
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   150     HIS metric compliance would decrease readability and maintainability */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   151  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_ProcessIPduGroupVector(
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   152                                              P2CONST(uint8, AUTOMATIC, COM_APPL_DATA) ipduGroupVector
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   153                                                              )
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   154  {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   155      P2CONST(Com_IpduIdType,AUTOMATIC,COM_APPL_CONST)    IPduRefPtr;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   156      Com_IPduGrpConstPtrType                             IPduGrpConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   157      VAR(uint16,AUTOMATIC)                               Index_u16;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   158      VAR(uint16,AUTOMATIC)                               NoOfPdus_u16;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   159      VAR(Com_IpduGroupIdType,AUTOMATIC)                  IpduGrpId_u16;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   160      VAR(uint8,AUTOMATIC)                                ByteVal_u8;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   161      VAR(uint8,AUTOMATIC)                                BitOffset_u8;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   162      VAR(uint8,AUTOMATIC)                                PduCounterVal;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   163  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   164      for (Index_u16 = 0; Index_u16 < COM_NUM_ARR_IPDUGRPVECT; Index_u16++)
	mov	d4,#0
.L271:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   164      for (Index_u16 = 0; Index_u16 < COM_NUM_ARR_IPDUGRPVECT; Index_u16++)      (inlined)
	j	.L9
.L10:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   165      {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   166          if (Com_IpduGrpVector[Index_u16] != ipduGroupVector[Index_u16])
	mov.aa	a15,a12
.L352:
	add.a	a15,#0
	ld.bu	d0,[a15]
.L353:
	movh.a	a2,#@his(Com_IpduGrpVector)
	lea	a2,[a2]@los(Com_IpduGrpVector)
.L354:
	add.a	a2,#0
	ld.bu	d1,[a2]
.L355:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   166          if (Com_IpduGrpVector[Index_u16] != ipduGroupVector[Index_u16])      (inlined)
	jeq	d1,d0,.L11
.L272:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   167          {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   168              /* Perform an XOR to find the Ipdu Groups which have changed the states */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   169              ByteVal_u8   = (uint8)(Com_IpduGrpVector[Index_u16] ^ ipduGroupVector[Index_u16]);
	xor	d1,d0
.L356:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   170              BitOffset_u8 = 0u;
	mov	d5,#0

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   221              } while (ByteVal_u8 > 0u);      (inlined)
.L12:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   177                  if (COM_RESET != (ByteVal_u8 & 1u))      (inlined)
	jz.t	d1:0,.L13
.L357:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   171  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   172              /* If there are some Ipdu groups which have changed the status */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   173              do
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   174              {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   175                  /* Check for the status of the changed Ipdu groups and perform actions accordingly.
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   176                   * Check if any of the IPdu Group is changed by performing right bit shift */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   177                  if (COM_RESET != (ByteVal_u8 & 1u))
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   178                  {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   179                      /* Get the Ipdu group Id if the status is changed */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   180                      IpduGrpId_u16   = (8u * Index_u16) + BitOffset_u8;
	sh	d0,d4,#3
.L358:
	add	d15,d5,d0
.L274:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   181  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   182                      /* Convert external HandleId to internal HandleId.
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   183                       * IMP : ipduGroupVector will be set/reset based on the external ID.
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   184                       * It is required to convert the ID only when accessing the tables. For pre-compile,
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   185                       * conversion is not required. Access Macro will return the same ID, which is passed to it */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   186                      IpduGrpId_u16   = COM_GET_IPDUGRP_ID(IpduGrpId_u16);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   187  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   188                      /* Get the latest status of the IPdu group and store the any of the below value
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   189                       * 0x01u eq +1, to increment the IPDU_COUNTER
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   190                       * 0xFFu eq -1, to decrement the IPDU_COUNTER */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   191                      PduCounterVal   = ((((ipduGroupVector[Index_u16] >> BitOffset_u8) & 1u) != 0u) ? (0x1u) : (0xFFu));
	ld.bu	d0,[a15]
.L359:
	mov	d2,d5
.L275:
	rsub	d2,#0
.L273:
	sha	d0,d0,d2
.L360:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   191                      PduCounterVal   = ((((ipduGroupVector[Index_u16] >> BitOffset_u8) & 1u) != 0u) ? (0x1u) : (0xFFu));      (inlined)
	and	d0,d0,#1
.L361:
	mov	d2,#1
.L276:
	sel	d0,d0,d2,#255
.L277:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   191                      PduCounterVal   = ((((ipduGroupVector[Index_u16] >> BitOffset_u8) & 1u) != 0u) ? (0x1u) : (0xFFu));      (inlined)
	j	.L15
.L14:
	mov	d0,#255

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   191                      PduCounterVal   = ((((ipduGroupVector[Index_u16] >> BitOffset_u8) & 1u) != 0u) ? (0x1u) : (0xFFu));      (inlined)
.L15:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   192  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   193                      IPduGrpConstPtr = COM_GET_IPDUGRP_CONSTDATA(IpduGrpId_u16);
	movh.a	a4,#@his(Com_Prv_xIpduGrpCfg_acst)
	lea	a4,[a4]@los(Com_Prv_xIpduGrpCfg_acst)
	addsc.a	a4,a4,d15,#2
.L279:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   194                      IPduRefPtr      = COM_GET_IPDUGRP_IPDUREF_CONSTDATA(IPduGrpConstPtr->FirstIpdu_Index);
	ld.hu	d2,[a4]0
	movh.a	a5,#@his(Com_Prv_xIPduGrp_IpduRefCfg_au8)
	lea	a5,[a5]@los(Com_Prv_xIPduGrp_IpduRefCfg_au8)
	addsc.a	a5,a5,d2,#0
.L280:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   201                      NoOfPdus_u16 =  (IpduGrpId_u16 != (COM_GET_NUM_TOTAL_IPDU_GRP - 1u)) ?      (inlined)
	jeq	d15,#1,.L16
.L362:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   195  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   196                      /* Difference between the current IPduGroup Index to the next Index provides
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   197                       * the total number of Pdus referred to the IPduGroup.
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   198                       * In case, current IPduGroup is the last member in the generated table, then the total number of
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   199                       * Pdus are stored in the separate pre-processor directive[COM_GET_NUM_IPDUS_IN_LAST_IPDUGRP]
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   200                       */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   201                      NoOfPdus_u16 =  (IpduGrpId_u16 != (COM_GET_NUM_TOTAL_IPDU_GRP - 1u)) ?
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   202                                      ((IPduGrpConstPtr + 1)->FirstIpdu_Index - IPduGrpConstPtr->FirstIpdu_Index) :
	ld.hu	d3,[a4]4
.L363:
	sub	d3,d2
.L364:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   202                                      ((IPduGrpConstPtr + 1)->FirstIpdu_Index - IPduGrpConstPtr->FirstIpdu_Index) :      (inlined)
	j	.L17
.L16:
	mov	d3,#4

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   202                                      ((IPduGrpConstPtr + 1)->FirstIpdu_Index - IPduGrpConstPtr->FirstIpdu_Index) :      (inlined)
.L17:
	extr.u	d15,d3,#0,#16
.L278:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   205                      while (NoOfPdus_u16 > 0u)      (inlined)
	j	.L18
.L19:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   203                                      (COM_GET_NUM_IPDUS_IN_LAST_IPDUGRP);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   204  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   205                      while (NoOfPdus_u16 > 0u)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   206                      {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   207                          /* Below counter shall increment if the latest state is started otherwise decrement it. */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   208                           COM_GET_IPDUCOUNTER_S(*IPduRefPtr) = (uint8)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   209                          (COM_GET_IPDUCOUNTER_S(*IPduRefPtr) + PduCounterVal);
	ld.bu	d2,[a5]
	movh.a	a4,#@his(Com_IpduCounter_s)
	lea	a4,[a4]@los(Com_IpduCounter_s)
	addsc.a	a4,a4,d2,#0
	ld.bu	d2,[a4]
.L365:
	add	d2,d0
.L366:
	st.b	[a4],d2
.L367:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   210  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   211                          IPduRefPtr++;
	add.a	a5,#1
.L368:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   212                          NoOfPdus_u16--;
	add	d15,#-1

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   205                      while (NoOfPdus_u16 > 0u)      (inlined)
.L18:
	jne	d15,#0,.L19

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   177                  if (COM_RESET != (ByteVal_u8 & 1u))      (inlined)
.L13:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   213  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   214                      } /* while (NoOfPdus_u16 > 0u) */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   215  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   216                  } /* if (COM_RESET != (ByteVal_u8 & 1u)) */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   217  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   218                  BitOffset_u8++;
	add	d5,#1
	extr.u	d5,d5,#0,#8
.L281:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   219                  ByteVal_u8 >>= 1u;
	sha	d1,#-1
.L369:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   221              } while (ByteVal_u8 > 0u);      (inlined)
	jne	d1,#0,.L12
.L370:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   220  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   221              } while (ByteVal_u8 > 0u);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   222  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   223              /* update the status of the IPdu group */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   224              Com_IpduGrpVector[Index_u16] = ipduGroupVector[Index_u16];
	ld.bu	d15,[a15]
.L371:
	st.b	[a2],d15

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   166          if (Com_IpduGrpVector[Index_u16] != ipduGroupVector[Index_u16])      (inlined)
.L11:
	add	d4,#1

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   164      for (Index_u16 = 0; Index_u16 < COM_NUM_ARR_IPDUGRPVECT; Index_u16++)      (inlined)
.L9:
	jeq	d4,#0,.L10
.L137:
	movh.a	a15,#@his(Com_RxIpduRam_s)
.L282:
	lea	a15,[a15]@los(Com_RxIpduRam_s)
.L372:
	mov	d3,#0
.L283:
	j	.L20
.L21:
	ld.bu	d0,[a15]4
.L373:
	movh.a	a2,#@his(Com_IpduCounter_s)
	lea	a2,[a2]@los(Com_IpduCounter_s)
	addsc.a	a2,a2,d3,#0
	ld.bu	d15,[a2]
.L374:
	jeq	d15,#0,.L22
.L153:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
	mov	d1,#1
.L375:
	sh	d1,#0
.L376:
	and	d0,d1
.L377:
	ne	d15,d0,#0
.L378:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);      (inlined)
	j	.L23

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }      (inlined)
.L23:
	jne	d15,#0,.L24
.L379:
	mov.aa	a2,a15
	add.a	a2,#4
	mov	d0,#1
.L160:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;      (inlined)
	ne	d0,d0,#0
.L284:
	j	.L26
.L25:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   439  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   440  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   441  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   442   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   443   * Bfx_PutBit_u16u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   444   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   445   * \brief Sets or clears a bit at a given position Pos_u32 in the 16-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   446   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   447   * A priori, range [0,15] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   448   * Note, neither the given position BitPn nor the given value Value not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   449   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   450   * \param   uint16*  Data   pointer to a 16-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   451   * \param   uint8    BitPn  position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   452   * \param   boolean  Value  defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   453   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   454   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   455   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   456  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   457  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   458      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   460      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   461      *Data = ((*Data & ((uint16)~(1uL << BitPn))) | ((uint16)((uint16)tmp_u8 << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   462  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   463  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   464  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   465  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   466   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   467   * Bfx_PutBit_u32u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   468   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   469   * \brief Sets or clears a bit at a given position Pos_u32 in the 32-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   470   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   471   * A priori, range [0,31] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   472   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   473   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   474   * \param   uint32*     Data        pointer to a 32-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   475   * \param   uint8       BitPn       position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   476   * \param   boolean     Value       defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   477   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   478   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   479   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   480  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   481  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   482      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   483      tmp_u8 = (Value)? 1u : 0u;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   484      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   485      *Data = ((*Data & ((uint32)~(1uL << BitPn))) | ((uint32)((uint32)tmp_u8 << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   486  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   487  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   488  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   489  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   490   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   491   * Bfx_PutBit_u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   492   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   493   * \brief Sets or clears a bit at a given position BitPn in the 8-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   494   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   495   * A priori, range [0,7] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   496   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   497   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   498   * \param  uint8*   Data    pointer to a 8-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   499   * \param  uint8    BitPn   position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   500   * \param  boolean  Value   defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   501   * \return void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   502   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   503   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   504  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   505  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   506      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;
	mov	d0,#0

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;      (inlined)
.L26:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   508      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   509      *Data = ((*Data & ((uint8)~(1uL <<BitPn))) | ((uint8)(tmp_u8 << BitPn)));
	ld.bu	d1,[a2]
.L380:
	mov	d2,#1
.L381:
	sh	d2,#0
.L382:
	xor	d2,d2,#255
.L383:
	and	d1,d2
.L384:
	sha	d0,#0
.L285:
	or	d1,d0
.L385:
	st.b	[a2],d1
.L24:
	j	.L27
.L22:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
	mov	d15,#1
.L386:
	sh	d15,#0
.L387:
	and	d0,d15
.L388:
	ne	d15,d0,#0
.L389:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);      (inlined)
	j	.L28

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }      (inlined)
.L28:
	jeq	d15,#0,.L29
.L390:
	mov.aa	a2,a15
	add.a	a2,#4
	mov	d15,#0
.L169:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;      (inlined)
	ne	d15,d15,#0
.L286:
	j	.L31
.L30:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   439  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   440  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   441  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   442   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   443   * Bfx_PutBit_u16u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   444   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   445   * \brief Sets or clears a bit at a given position Pos_u32 in the 16-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   446   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   447   * A priori, range [0,15] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   448   * Note, neither the given position BitPn nor the given value Value not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   449   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   450   * \param   uint16*  Data   pointer to a 16-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   451   * \param   uint8    BitPn  position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   452   * \param   boolean  Value  defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   453   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   454   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   455   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   456  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   457  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   458      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   460      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   461      *Data = ((*Data & ((uint16)~(1uL << BitPn))) | ((uint16)((uint16)tmp_u8 << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   462  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   463  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   464  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   465  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   466   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   467   * Bfx_PutBit_u32u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   468   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   469   * \brief Sets or clears a bit at a given position Pos_u32 in the 32-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   470   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   471   * A priori, range [0,31] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   472   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   473   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   474   * \param   uint32*     Data        pointer to a 32-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   475   * \param   uint8       BitPn       position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   476   * \param   boolean     Value       defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   477   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   478   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   479   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   480  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   481  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   482      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   483      tmp_u8 = (Value)? 1u : 0u;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   484      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   485      *Data = ((*Data & ((uint32)~(1uL << BitPn))) | ((uint32)((uint32)tmp_u8 << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   486  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   487  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   488  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   489  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   490   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   491   * Bfx_PutBit_u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   492   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   493   * \brief Sets or clears a bit at a given position BitPn in the 8-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   494   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   495   * A priori, range [0,7] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   496   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   497   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   498   * \param  uint8*   Data    pointer to a 8-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   499   * \param  uint8    BitPn   position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   500   * \param  boolean  Value   defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   501   * \return void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   502   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   503   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   504  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   505  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   506      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;
	mov	d15,#0

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;      (inlined)
.L31:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   508      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   509      *Data = ((*Data & ((uint8)~(1uL <<BitPn))) | ((uint8)(tmp_u8 << BitPn)));
	ld.bu	d0,[a2]
.L391:
	mov	d1,#1
.L392:
	sh	d1,#2
.L393:
	xor	d1,d1,#255
.L394:
	and	d0,d1
.L395:
	sha	d15,#2
.L287:
	or	d0,d15
.L396:
	st.b	[a2],d0
.L170:
	mov.aa	a2,a15
	add.a	a2,#4
	mov	d15,#0
.L172:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;      (inlined)
	ne	d15,d15,#0
.L288:
	j	.L33
.L32:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   439  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   440  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   441  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   442   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   443   * Bfx_PutBit_u16u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   444   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   445   * \brief Sets or clears a bit at a given position Pos_u32 in the 16-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   446   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   447   * A priori, range [0,15] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   448   * Note, neither the given position BitPn nor the given value Value not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   449   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   450   * \param   uint16*  Data   pointer to a 16-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   451   * \param   uint8    BitPn  position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   452   * \param   boolean  Value  defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   453   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   454   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   455   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   456  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   457  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   458      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   460      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   461      *Data = ((*Data & ((uint16)~(1uL << BitPn))) | ((uint16)((uint16)tmp_u8 << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   462  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   463  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   464  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   465  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   466   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   467   * Bfx_PutBit_u32u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   468   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   469   * \brief Sets or clears a bit at a given position Pos_u32 in the 32-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   470   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   471   * A priori, range [0,31] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   472   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   473   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   474   * \param   uint32*     Data        pointer to a 32-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   475   * \param   uint8       BitPn       position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   476   * \param   boolean     Value       defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   477   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   478   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   479   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   480  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   481  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   482      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   483      tmp_u8 = (Value)? 1u : 0u;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   484      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   485      *Data = ((*Data & ((uint32)~(1uL << BitPn))) | ((uint32)((uint32)tmp_u8 << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   486  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   487  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   488  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   489  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   490   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   491   * Bfx_PutBit_u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   492   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   493   * \brief Sets or clears a bit at a given position BitPn in the 8-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   494   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   495   * A priori, range [0,7] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   496   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   497   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   498   * \param  uint8*   Data    pointer to a 8-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   499   * \param  uint8    BitPn   position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   500   * \param  boolean  Value   defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   501   * \return void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   502   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   503   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   504  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   505  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   506      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;
	mov	d15,#0

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;      (inlined)
.L33:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   508      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   509      *Data = ((*Data & ((uint8)~(1uL <<BitPn))) | ((uint8)(tmp_u8 << BitPn)));
	ld.bu	d0,[a2]
.L397:
	mov	d1,#1
.L398:
	sh	d1,#0
.L399:
	xor	d1,d1,#255
.L400:
	and	d0,d1
.L401:
	sha	d15,#0
.L289:
	or	d0,d15
.L402:
	st.b	[a2],d0
.L173:
	mov.aa	a2,a15
	add.a	a2,#4
	mov	d15,#0
.L175:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;      (inlined)
	ne	d15,d15,#0
.L290:
	j	.L35
.L34:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   439  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   440  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   441  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   442   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   443   * Bfx_PutBit_u16u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   444   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   445   * \brief Sets or clears a bit at a given position Pos_u32 in the 16-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   446   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   447   * A priori, range [0,15] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   448   * Note, neither the given position BitPn nor the given value Value not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   449   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   450   * \param   uint16*  Data   pointer to a 16-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   451   * \param   uint8    BitPn  position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   452   * \param   boolean  Value  defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   453   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   454   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   455   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   456  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   457  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   458      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   460      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   461      *Data = ((*Data & ((uint16)~(1uL << BitPn))) | ((uint16)((uint16)tmp_u8 << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   462  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   463  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   464  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   465  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   466   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   467   * Bfx_PutBit_u32u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   468   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   469   * \brief Sets or clears a bit at a given position Pos_u32 in the 32-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   470   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   471   * A priori, range [0,31] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   472   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   473   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   474   * \param   uint32*     Data        pointer to a 32-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   475   * \param   uint8       BitPn       position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   476   * \param   boolean     Value       defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   477   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   478   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   479   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   480  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   481  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   482      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   483      tmp_u8 = (Value)? 1u : 0u;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   484      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   485      *Data = ((*Data & ((uint32)~(1uL << BitPn))) | ((uint32)((uint32)tmp_u8 << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   486  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   487  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   488  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   489  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   490   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   491   * Bfx_PutBit_u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   492   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   493   * \brief Sets or clears a bit at a given position BitPn in the 8-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   494   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   495   * A priori, range [0,7] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   496   * Note, neither the given position P_u32 nor the given value Val_u32 not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   497   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   498   * \param  uint8*   Data    pointer to a 8-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   499   * \param  uint8    BitPn   position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   500   * \param  boolean  Value   defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   501   * \return void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   502   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   503   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   504  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   505  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   506      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;
	mov	d15,#0

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   507      tmp_u8 = (Value)? 1u : 0u;      (inlined)
.L35:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   508      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   509      *Data = ((*Data & ((uint8)~(1uL <<BitPn))) | ((uint8)(tmp_u8 << BitPn)));
	ld.bu	d0,[a2]
.L403:
	mov	d1,#1
.L404:
	sh	d1,#4
.L405:
	xor	d1,d1,#255
.L406:
	and	d0,d1
.L407:
	sha	d15,#4
.L293:
	or	d0,d15
.L408:
	st.b	[a2],d0
.L29:
.L27:
	add.a	a15,#6
.L409:
	add	d3,#1
.L20:
	jlt.u	d3,#5,.L21
.L410:
	movh.a	a12,#@his(Com_TxIpduRam_s)
.L292:
	lea	a12,[a12]@los(Com_TxIpduRam_s)
.L411:
	mov.aa	a13,a12
.L294:
	mov	d9,#0
.L291:
	j	.L36
.L37:
	ld.hu	d0,[a13]12
.L412:
	movh.a	a15,#@his(Com_IpduCounter_s)
	lea	a15,[a15]@los(Com_IpduCounter_s)
	addsc.a	a15,a15,d9,#0
	ld.bu	d15,[a15]5
.L413:
	jeq	d15,#0,.L38
.L178:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
	mov	d1,#1
.L414:
	sh	d1,#0
.L415:
	and	d0,d1
.L416:
	ne	d0,d0,#0
.L417:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));      (inlined)
	j	.L39

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }      (inlined)
.L39:
	jne	d0,#0,.L40
.L418:
	mov	d4,d9
.L185:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   225  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   226          } /* if (Com_IpduGrpVector[Index_u16] != ipduGroupVector[Index_u16] ) */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   227  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   228      } /* End of For loop */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   229  }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   230  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   231  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   232  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   233   Function name    : Com_ClearIpduGroupVector
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   234   Syntax           : void Com_ClearIpduGroupVector( Com_IpduGroupVector ipduGroupVector )
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   235   Description      : Service to clear Ipdu group vector
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   236   Parameter        : Com_IpduGroupVector - I-PDU group vector containing
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   237                      the activation state (stopped = 0/ started = 1) for all I-PDU groups.
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   238   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   239   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   240  #define COM_START_SEC_CODE
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   241  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   242  FUNC(void, COM_CODE) Com_ClearIpduGroupVector( VAR(Com_IpduGroupVector, AUTOMATIC) ipduGroupVector )
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   243  {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   244  #if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   245      if (Com_Prv_DETCheck_Ptr( (ipduGroupVector == NULL_PTR), COMServiceId_ClearIpduGroupVector ))
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   246  #endif
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   247      {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   248          VAR(uint16, AUTOMATIC) Index_u16;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   249  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   250          for (Index_u16 = 0u; Index_u16 < COM_NUM_ARR_IPDUGRPVECT; Index_u16++)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   251          {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   252              ipduGroupVector[Index_u16] = (uint8)0;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   253          }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   254      }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   255  }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   256  #define COM_STOP_SEC_CODE
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   257  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   258  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   259  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   260   Function name    : Com_SetIpduGroup
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   261   Syntax           : void Com_SetIpduGroup(
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   262                                  Com_IpduGroupVector ipduGroupVector,
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   263                                  Com_IpduGroupIdType IpduGroupId,
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   264                                  boolean             bitval
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   265                                           )
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   266   Description      : Service to set bit of the given Ipdu group vector that corresponds to the given I-PDU group.
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   267   Parameter        : ipduGroupVector - I-PDU group vector to be modified
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   268                    : IpduGroupId     - ipduGroup used to identify the corresponding bit in the I-PDU group vector
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   269                    : bitval          - New value of the corresponding bit
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   270   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   271   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   272  #define COM_START_SEC_CODE
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   273  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   274  FUNC(void, COM_CODE) Com_SetIpduGroup(
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   275                              VAR(Com_IpduGroupVector, AUTOMATIC)  ipduGroupVector,
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   276                              VAR(Com_IpduGroupIdType, AUTOMATIC)  IpduGroupId,
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   277                              VAR(boolean, AUTOMATIC)              bitval
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   278                                       )
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   279  {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   280  #if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   281      if (Com_Prv_DETCheck_Param_Ptr( (IpduGroupId >= COM_GET_NUM_TOTAL_IPDU_GRP),(ipduGroupVector == NULL_PTR),
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   282                                       COMServiceId_SetIpduGroup))
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   283  #endif
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   284      {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   285          VAR(uint16, AUTOMATIC)   Index_u16;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   286          VAR(uint8, AUTOMATIC)    BitOffset_u8;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   287  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   288          Index_u16     = (uint16)(IpduGroupId >> 3u);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   289          BitOffset_u8  = (uint8) (IpduGroupId % 8u);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   290  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   291          if (bitval)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   292          {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   293              ipduGroupVector[Index_u16] |= ((uint8)(1u << BitOffset_u8));
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   294          }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   295          else
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   296          {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   297              ipduGroupVector[Index_u16] &= ((uint8)(~(1u << BitOffset_u8)));
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   298          }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   299      }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   300  }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   301  #define COM_STOP_SEC_CODE
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   302  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   303  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   304  /***************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   305   Function name    : Com_TxIPduStart
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   306   Syntax           : void Com_TxIPduStart(Com_IpduIdType IpduId, boolean Initialize)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   307   Description      : Service to start the Tx ipdu
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   308   Parameter        : IpduId      -> Id of the ipdu
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   309                    : Initialize  -> flag to request initialization of the I-PDUs which are newly started
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   310   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   311   ***************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   312  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   313  static INLINE FUNC(void, COM_CODE) Com_TxIPduStart(VAR(Com_IpduIdType, AUTOMATIC) IpduId,
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   314                                                     VAR(boolean, AUTOMATIC) Initialize)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   315  {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   316  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   317      Com_TxIpduConstPtrType  TxIPduConstPtr; /* Local pointer to Tx ipdu static  configuration */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   318      Com_TxIpduRamPtrType    TxIpduRamPtr;   /* Local pointer to Tx ipdu dynamic configuration */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   319  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   320      VAR(uint8, AUTOMATIC)   LatestTransMode_u8;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   321  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   322      /* The below Initialize check should be only after Com_LatestTransMode is calculated */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   323      if(Initialize != COM_FALSE)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   324      {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   325          TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
	mul	d15,d4,#24
	movh.a	a15,#@his(Com_Prv_xTxIpduCfg_acst)
	lea	a15,[a15]@los(Com_Prv_xTxIpduCfg_acst)
	addsc.a	a14,a15,d15,#0
.L419:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   326  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   327          TxIpduRamPtr   = &COM_GET_TXPDURAM_S(IpduId);
	sha	d15,d4,#4
	addsc.a	a15,a12,d15,#0
.L295:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   323      if(Initialize != COM_FALSE)      (inlined)
	jeq	d8,#0,.L41
.L420:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   328  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   329          /* Call function to update bit   */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   330          Com_Prv_UpdateBitAndFilter(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   331  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   332          /* Call Com_TxChangeMode( ) to calculate the Com_LatestTransMode[i] */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   333          Com_TxChangeMode(IpduId);
	call	Com_TxChangeMode
.L421:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   334          /* Note: Even though if the Com_Tick_Tx is updated in Com_TxChangeMode(),
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   335                  it is once again updated in Ipdu Group Start i.e below */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   336          LatestTransMode_u8 = Com_GetRamValue(TXIPDU,_LATESTMODE,TxIpduRamPtr->Com_TransMode);
	ld.bu	d15,[a15]15
	mov	d1,#2
.L196:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
	sha	d0,d15,#0
.L422:
	mov	d15,#255
.L423:
	rsub	d1,d1,#8
.L424:
	rsub	d1,#0
	sh	d15,d15,d1
.L425:
	and	d0,d15
.L426:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));      (inlined)
	j	.L42

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }      (inlined)
.L42:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   337  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   338          /* Reset the global TMS status flag on the start of IPduGroup */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   339          Com_SetRamValue(TXIPDU,_GWIPDUTMSCHANGED,TxIpduRamPtr->Com_TxFlags,COM_FALSE);
	lea	a2,[a15]12
	mov	d15,#0
.L205:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;      (inlined)
	ne	d1,d15,#0
.L296:
	j	.L44
.L43:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   439  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   440  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   441  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   442   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   443   * Bfx_PutBit_u16u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   444   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   445   * \brief Sets or clears a bit at a given position Pos_u32 in the 16-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   446   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   447   * A priori, range [0,15] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   448   * Note, neither the given position BitPn nor the given value Value not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   449   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   450   * \param   uint16*  Data   pointer to a 16-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   451   * \param   uint8    BitPn  position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   452   * \param   boolean  Value  defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   453   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   454   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   455   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   456  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   457  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   458      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;
	mov	d1,#0

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;      (inlined)
.L44:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   460      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   461      *Data = ((*Data & ((uint16)~(1uL << BitPn))) | ((uint16)((uint16)tmp_u8 << BitPn)));
	mov.u	d3,#65535
.L427:
	ld.hu	d15,[a15]12
.L428:
	mov	d2,#1
.L429:
	sh	d2,d2,#8
.L430:
	xor	d2,d3
.L431:
	and	d15,d2
.L432:
	sha	d1,d1,#8
.L297:
	or	d15,d1
.L433:
	st.h	[a2],d15
.L206:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   343          if( COM_RESET != ( LatestTransMode_u8 & COM_TXMODE_MIXED ) )      (inlined)
	jz.t	d0:0,.L45
.L434:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   340  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   341          /* time period and offset attributes of IPDUs in Periodic or Mixed Transmission Mode */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   342          /* The CurrentTxModePtr points to the structure information of the current TxModeState */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   343          if( COM_RESET != ( LatestTransMode_u8 & COM_TXMODE_MIXED ) )
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   344          {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   345              /* I.e Load the TxTimeOffset for cyclic type Pdu's(PERIODIC or MIXED) */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   346              /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   347  #ifdef COM_TXPDU_TIMEOFFSET_VIA_CALIBRATION
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   348              TxIpduRamPtr->Com_Tick_Tx = Com_GetTxIPduTimeOffsetCalibration((PduIdType)IpduId);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   349  #else
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   350              /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   351              TxIpduRamPtr->Com_Tick_Tx = TxIpduRamPtr->CurrentTxModePtr->TimeOffsetFact;
	ld.a	a2,[a15]
.L435:
	ld.hu	d15,[a2]2
.L436:
	st.h	[a15]6,d15

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   343          if( COM_RESET != ( LatestTransMode_u8 & COM_TXMODE_MIXED ) )      (inlined)
.L45:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   352              /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   353  #endif /* COM_TXPDU_TIMEOFFSET_VIA_CALIBRATION */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   354              /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   355          }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   356          /* the minimum delay time attribute of IPDUs in
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   357                         Direct/N-Times or Mixed Transmission Mode */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   358          /*Reset it to Zero i.e No Min delay check as soon as IpduGroup is started */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   359          TxIpduRamPtr->Com_MinDelayTick = 0;
	mov	d15,#0
.L437:
	st.h	[a15]4,d15
.L438:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   360  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   361          /*RESET all the Tx Confirmation and Tx timeout variables*/
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   362          /*Reset it to Stop, Note: This Flag has to be set
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   363                             to START only in SendIpdu() i,e just before Sending the IPDU*/
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   364          Com_SetRamValue(TXIPDU,_TICKTXTO,TxIpduRamPtr->Com_TxFlags,COM_STOP);
	lea	a2,[a15]12
	mov	d15,#0
.L216:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;      (inlined)
	ne	d15,d15,#0
.L298:
	j	.L47
.L46:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   439  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   440  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   441  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   442   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   443   * Bfx_PutBit_u16u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   444   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   445   * \brief Sets or clears a bit at a given position Pos_u32 in the 16-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   446   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   447   * A priori, range [0,15] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   448   * Note, neither the given position BitPn nor the given value Value not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   449   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   450   * \param   uint16*  Data   pointer to a 16-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   451   * \param   uint8    BitPn  position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   452   * \param   boolean  Value  defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   453   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   454   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   455   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   456  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   457  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   458      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;
	mov	d15,#0

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;      (inlined)
.L47:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   460      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   461      *Data = ((*Data & ((uint16)~(1uL << BitPn))) | ((uint16)((uint16)tmp_u8 << BitPn)));
	ld.hu	d0,[a15]12
.L439:
	mov	d1,#1
.L440:
	sh	d1,#2
.L441:
	xor	d1,d3
.L442:
	and	d0,d1
.L443:
	sha	d15,#2
.L299:
	or	d0,d15
.L444:
	st.h	[a2],d0
.L217:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   365          /*Reset it to RESET*/
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   366  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   367          /* The AUTOSAR COM module shall start the transmission deadline monitoring timer
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   368           ** for this I-PDU upon the start of the I-PDU group to which the I-PDU belongs to*/
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   369  #ifdef COM_TxIPduTimeOut
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   370          if(Com_GetValue(TXIPDU,_NONETOSTATUS,TxIPduConstPtr->txIPduFields))
	ld.hu	d15,[a14]20
.L219:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
	mov	d0,#1
.L445:
	sh	d0,#3
.L446:
	and	d15,d0
.L447:
	ne	d15,d15,#0
.L448:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));      (inlined)
	j	.L48

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }      (inlined)
.L48:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   370          if(Com_GetValue(TXIPDU,_NONETOSTATUS,TxIPduConstPtr->txIPduFields))      (inlined)
	jeq	d15,#0,.L49
.L449:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   371          {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   372              Com_SetRamValue(TXIPDU,_TICKTXTO,TxIpduRamPtr->Com_TxFlags,COM_START);
	lea	a2,[a15]12
	mov	d15,#1
.L220:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;      (inlined)
	ne	d15,d15,#0
.L300:
	j	.L51
.L50:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   439  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   440  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   441  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   442   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   443   * Bfx_PutBit_u16u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   444   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   445   * \brief Sets or clears a bit at a given position Pos_u32 in the 16-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   446   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   447   * A priori, range [0,15] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   448   * Note, neither the given position BitPn nor the given value Value not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   449   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   450   * \param   uint16*  Data   pointer to a 16-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   451   * \param   uint8    BitPn  position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   452   * \param   boolean  Value  defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   453   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   454   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   455   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   456  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   457  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   458      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;
	mov	d15,#0

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;      (inlined)
.L51:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   460      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   461      *Data = ((*Data & ((uint16)~(1uL << BitPn))) | ((uint16)((uint16)tmp_u8 << BitPn)));
	ld.hu	d0,[a15]12
.L450:
	mov	d1,#1
.L451:
	sh	d1,#2
.L452:
	xor	d1,d3
.L453:
	and	d0,d1
.L454:
	sha	d15,#2
.L301:
	or	d0,d15
.L455:
	st.h	[a2],d0
.L221:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   373              TxIpduRamPtr->Com_TickTxTimeout = TxIPduConstPtr->Timeout_Fact;
	ld.hu	d15,[a14]10
.L456:
	st.h	[a15]10,d15
.L457:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   372              Com_SetRamValue(TXIPDU,_TICKTXTO,TxIpduRamPtr->Com_TxFlags,COM_START);      (inlined)
	j	.L52

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   370          if(Com_GetValue(TXIPDU,_NONETOSTATUS,TxIPduConstPtr->txIPduFields))      (inlined)
.L49:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   374          }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   375          else
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   376  #endif/* #ifdef COM_TxIPduTimeOut */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   377          {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   378              /*Reset the timer to Zero */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   379  #ifdef COM_TxIPduTimeOut
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   380              TxIpduRamPtr->Com_TickTxTimeout = 0;
	mov	d15,#0
.L458:
	st.h	[a15]10,d15
.L459:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   381  #endif/* #ifdef COM_TxIPduTimeOut */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   382              Com_SetRamValue(TXIPDU,_CONFIR,TxIpduRamPtr->Com_TxFlags,COM_FALSE);
	lea	a2,[a15]12
	mov	d15,#0
.L223:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;      (inlined)
	ne	d15,d15,#0
.L302:
	j	.L54
.L53:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   439  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   440  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   441  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   442   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   443   * Bfx_PutBit_u16u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   444   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   445   * \brief Sets or clears a bit at a given position Pos_u32 in the 16-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   446   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   447   * A priori, range [0,15] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   448   * Note, neither the given position BitPn nor the given value Value not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   449   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   450   * \param   uint16*  Data   pointer to a 16-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   451   * \param   uint8    BitPn  position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   452   * \param   boolean  Value  defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   453   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   454   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   455   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   456  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   457  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   458      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;
	mov	d15,#0

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;      (inlined)
.L54:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   460      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   461      *Data = ((*Data & ((uint16)~(1uL << BitPn))) | ((uint16)((uint16)tmp_u8 << BitPn)));
	ld.hu	d0,[a15]12
.L460:
	mov	d1,#1
.L461:
	sh	d1,#1
.L462:
	xor	d1,d3
.L463:
	and	d0,d1
.L464:
	sha	d15,#1
.L303:
	or	d0,d15
.L465:
	st.h	[a2],d0

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   375          else      (inlined)
.L52:
	j	.L55

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   323      if(Initialize != COM_FALSE)      (inlined)
.L41:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   383          }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   384      }/*End of If(INITIALIZE)*/
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   385      else
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   386      {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   387  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   388          /* Check if IPDU group is TX group
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   389           * Cyclic IPDU's will be sent out cyclically after the call of this API
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   390           */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   391          TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   392  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   393  #ifdef COM_TxIPduTimeOut
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   394          TxIpduRamPtr = &COM_GET_TXPDURAM_S(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   395  #endif
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   396          /* Call Com_TxChangeMode() to calculate the Com_LatestTransMode[i] */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   397          Com_TxChangeMode((Com_IpduIdType)IpduId);
	call	Com_TxChangeMode
.L466:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   398          /* Note: Eventhough if the Com_Tick_Tx is updated in Com_TxChangeMode(),
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   399                  it is once again updated in Ipdu Group Start i.e below */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   400  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   401          /* The AUTOSAR COM module shall start the transmission deadline monitoring timer
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   402           * for this I-PDU upon the start of the I-PDU group to which the I-PDU belongs to*/
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   403  #ifdef COM_TxIPduTimeOut
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   404          if(Com_GetValue(TXIPDU,_NONETOSTATUS,TxIPduConstPtr->txIPduFields))
	ld.hu	d15,[a14]20
.L225:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
	mov	d0,#1
.L467:
	sh	d0,#3
.L468:
	and	d15,d0
.L469:
	ne	d15,d15,#0
.L470:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));      (inlined)
	j	.L56

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }      (inlined)
.L56:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   404          if(Com_GetValue(TXIPDU,_NONETOSTATUS,TxIPduConstPtr->txIPduFields))      (inlined)
	jeq	d15,#0,.L57
.L471:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   405          {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   406              Com_SetRamValue(TXIPDU,_TICKTXTO,TxIpduRamPtr->Com_TxFlags,COM_START);
	lea	a2,[a15]12
	mov	d15,#1
.L226:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;      (inlined)
	ne	d15,d15,#0
.L304:
	j	.L59
.L58:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   439  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   440  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   441  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   442   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   443   * Bfx_PutBit_u16u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   444   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   445   * \brief Sets or clears a bit at a given position Pos_u32 in the 16-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   446   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   447   * A priori, range [0,15] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   448   * Note, neither the given position BitPn nor the given value Value not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   449   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   450   * \param   uint16*  Data   pointer to a 16-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   451   * \param   uint8    BitPn  position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   452   * \param   boolean  Value  defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   453   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   454   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   455   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   456  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   457  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   458      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;
	mov	d15,#0

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;      (inlined)
.L59:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   460      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   461      *Data = ((*Data & ((uint16)~(1uL << BitPn))) | ((uint16)((uint16)tmp_u8 << BitPn)));
	mov.u	d0,#65535
.L472:
	ld.hu	d1,[a15]12
.L473:
	mov	d2,#1
.L474:
	sh	d2,#2
.L475:
	xor	d0,d2
.L476:
	and	d1,d0
.L477:
	sha	d15,#2
.L306:
	or	d1,d15
.L478:
	st.h	[a2],d1
.L227:

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   407              TxIpduRamPtr->Com_TickTxTimeout = TxIPduConstPtr->Timeout_Fact;
	ld.hu	d15,[a14]10
.L479:
	st.h	[a15]10,d15

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   404          if(Com_GetValue(TXIPDU,_NONETOSTATUS,TxIPduConstPtr->txIPduFields))      (inlined)
.L57:
	mov.u	d3,#65535

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   385      else      (inlined)
.L55:
	lea	a15,[a13]12
.L305:
	mov	d15,#1
.L229:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;      (inlined)
	ne	d15,d15,#0
.L307:
	j	.L61
.L60:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   439  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   440  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   441  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   442   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   443   * Bfx_PutBit_u16u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   444   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   445   * \brief Sets or clears a bit at a given position Pos_u32 in the 16-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   446   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   447   * A priori, range [0,15] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   448   * Note, neither the given position BitPn nor the given value Value not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   449   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   450   * \param   uint16*  Data   pointer to a 16-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   451   * \param   uint8    BitPn  position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   452   * \param   boolean  Value  defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   453   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   454   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   455   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   456  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   457  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   458      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;
	mov	d15,#0

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;      (inlined)
.L61:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   460      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   461      *Data = ((*Data & ((uint16)~(1uL << BitPn))) | ((uint16)((uint16)tmp_u8 << BitPn)));
	ld.hu	d0,[a13]12
.L480:
	mov	d1,#1
.L481:
	sh	d1,#0
.L482:
	xor	d1,d3
.L483:
	and	d0,d1
.L484:
	sha	d15,#0
.L308:
	or	d0,d15
.L485:
	st.h	[a15],d0
.L230:
	lea	a15,[a13]12
	mov	d15,#0
.L232:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;      (inlined)
	ne	d15,d15,#0
.L309:
	j	.L63
.L62:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   439  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   440  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   441  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   442   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   443   * Bfx_PutBit_u16u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   444   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   445   * \brief Sets or clears a bit at a given position Pos_u32 in the 16-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   446   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   447   * A priori, range [0,15] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   448   * Note, neither the given position BitPn nor the given value Value not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   449   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   450   * \param   uint16*  Data   pointer to a 16-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   451   * \param   uint8    BitPn  position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   452   * \param   boolean  Value  defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   453   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   454   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   455   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   456  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   457  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   458      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;
	mov	d15,#0

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;      (inlined)
.L63:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   460      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   461      *Data = ((*Data & ((uint16)~(1uL << BitPn))) | ((uint16)((uint16)tmp_u8 << BitPn)));
	ld.hu	d0,[a13]12
.L486:
	mov	d1,#1
.L487:
	sh	d1,#7
.L488:
	xor	d3,d1
.L489:
	and	d0,d3
.L490:
	sha	d15,#7
.L310:
	or	d0,d15
.L491:
	st.h	[a15],d0
.L40:
	j	.L64
.L38:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
	mov	d15,#1
.L492:
	sh	d15,#0
.L493:
	and	d0,d15
.L494:
	ne	d15,d0,#0
.L495:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));      (inlined)
	j	.L65

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }      (inlined)
.L65:
	jeq	d15,#0,.L66
.L496:
	lea	a15,[a13]12
	mov	d15,#0
.L234:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;      (inlined)
	ne	d15,d15,#0
.L311:
	j	.L68
.L67:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   439  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   440  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   441  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   442   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   443   * Bfx_PutBit_u16u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   444   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   445   * \brief Sets or clears a bit at a given position Pos_u32 in the 16-bit variable Data.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   446   * A priori, range [0,1] is valid for Value, case 0: the bit is cleared, case 1 the bit is set.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   447   * A priori, range [0,15] is valid for BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   448   * Note, neither the given position BitPn nor the given value Value not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   449   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   450   * \param   uint16*  Data   pointer to a 16-bit variable, where a bit schould be modified
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   451   * \param   uint8    BitPn  position of the bit, to be set
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   452   * \param   boolean  Value  defines the new bit, 0 clears the bit and 1 sets the bit
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   453   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   454   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   455   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   456  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   457  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   458      uint8 tmp_u8;
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;
	mov	d15,#0

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   459      tmp_u8 = (Value)? 1u : 0u;      (inlined)
.L68:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   460      /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   461      *Data = ((*Data & ((uint16)~(1uL << BitPn))) | ((uint16)((uint16)tmp_u8 << BitPn)));
	mov.u	d0,#65535
.L497:
	ld.hu	d1,[a13]12
.L498:
	mov	d2,#1
.L499:
	sh	d2,#0
.L500:
	xor	d0,d2
.L501:
	and	d1,d0
.L502:
	sha	d15,#0
.L312:
	or	d1,d15
.L503:
	st.h	[a15],d1
.L235:
	mov	d4,d9
.L313:
	call	Com_TxIPduStop
.L66:
.L64:
	lea	a13,[a13]16
.L504:
	add	d9,#1
.L36:
	jlt.u	d9,#4,.L37
.L8:
	ret
.L114:
	
__Com_IpduGroupControl_function_end:
	.size	Com_IpduGroupControl,__Com_IpduGroupControl_function_end-Com_IpduGroupControl
.L103:
	; End of function
	
	.sdecl	'.text.Com_IpduGroupStart.Com_ClearIpduGroupVector',code,cluster('Com_ClearIpduGroupVector')
	.sect	'.text.Com_IpduGroupStart.Com_ClearIpduGroupVector'
	.align	2
	
	.global	Com_ClearIpduGroupVector
; Function Com_ClearIpduGroupVector
.L92:
Com_ClearIpduGroupVector:	.type	func
	mov.aa	a15,a4
.L315:
	mov.a	a2,#0
.L509:
	eq.a	d0,a15,a2
.L510:
	mov	d6,#28
.L239:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     1  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     2  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     3  #ifndef COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     4  #define COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     5  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     6  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     7   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     8   * Includes
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     9   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    10  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    11  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    12  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    13  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    17  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    18  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    19  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    20  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    21   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    22   * Type definitions
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    23   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    24  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    25  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    26  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    27  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    28   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    29   * Variables
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    30   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    31  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    32  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    33  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    34  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    35   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    36   * Extern declarations
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    37   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    38  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    39  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    40   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    41   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    42   * Inline function sets TMS data in to be accessesd via CurrentTxModePtr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    43   * after evaluating TMS mode for the IPdu
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    44   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    45  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    46  FUNC(void, COM_CODE) Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    47                                  Com_TxIpduRamPtrType                TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    48                                  Com_TxIpduConstPtrType              TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    49                                  VAR(uint16,AUTOMATIC)               TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    50                                  VAR(boolean,AUTOMATIC)              ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    51                                              );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    52  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    53  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    54   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    55   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    56   * Inline function to update Rx-GroupSignal application buffers
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    57   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    58  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    59  FUNC(void, COM_CODE) Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    60                                  Com_RxSigConstPtrType               RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    61                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    62                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    63                                               );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    64  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    65  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    66   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    67   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    68   * Inline function to update Rx-GroupSignal secondary buffers
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    69   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    70  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    71  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    72  FUNC(void, COM_CODE) Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    73                                  Com_RxGrpSigConstPtrType            RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    74                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    75                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    76                                                          );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    77  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    78  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    79  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    80   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    81   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    82   * Inline function to initialize signal intial value into the provided IPdu buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    83   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    84  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    85  FUNC(void, COM_CODE) Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    86                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    87                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    88                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    89                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    90                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    91                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    92                                                              );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    93  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    94  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    95   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    96   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    97   * Inline function to initialize Rx-signal group with initial values
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    98   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    99  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   100  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   101  FUNC(void, COM_CODE) Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   102                                  Com_RxSigGrpConstPtrType            RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   103                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   104                                                  );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   105  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   106  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   107  #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   108  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxNotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   109  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxErrNotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   110  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxTONotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   111  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallRxTONotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   112  #endif /* #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   113  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   114  /* Inline function to check for the RxIPdu and TxIpdu status*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   115  LOCAL_INLINE boolean Com_CheckRxIPduStatus(PduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   116  LOCAL_INLINE boolean Com_CheckTxIPduStatus(PduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   117  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   118  #if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   119  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   120  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Void(uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   121  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   122  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Ptr(boolean isInValidPtr, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   123  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Param_Ptr(boolean isInValidParam, boolean isInValidPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   124                                                                  uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   125  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Ptr_Only(boolean isInValidPtr, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   126  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Param_Only(boolean isInValidParam, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   127  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   128  #endif /*  #if (COM_CONFIGURATION_USE_DET == STD_ON) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   129  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   130  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   131  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   132  LOCAL_INLINE FUNC(void, COM_CODE) Com_CopyTxGroupSignalData( Com_SignalIdType    GrpSignalId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   133                                                               Com_SigMaxType      TxGrpSig_NewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   134                                                               Com_MainFuncType    TxMainFuncId );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   135  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   136  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   137  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   138   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   139   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   140   * Inline function to handle gateway and non-gateway use-case for tx-signal/signalGroup
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   141   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   142  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_ProceedToSendIpdu(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   143                                                  VAR(Com_IpduIdType, AUTOMATIC)          ComTxPduId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   144                                                  VAR(Com_SendIpduInfo, AUTOMATIC)        sendIpduFlag_u16
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   145                                                             );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   146  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   147  #ifdef COM_TxFilters
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   148  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_CheckModeChange(VAR(Com_IpduIdType, AUTOMATIC) TxIpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   149  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   150  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   151  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   152  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   153   * Inline Function Definition
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   154   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   155  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   156  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   157   Function name    : Com_SetCurrentTxModePtr [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   158   Syntax           : void Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   159                                  Com_TxIpduRamPtrType    TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   160                                  Com_TxIpduConstPtrType  TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   161                                  uint16                  TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   162                                  boolean                 ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   163                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   164   Description      : Inline function sets TMS data in to be accessesd via CurrentTxModePtr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   165                      after evaluating TMS mode for the IPdu
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   166  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   167                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   168                       * Mode                  |    Configuration details                              | Value|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   169                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   170                       * COM_MODE_VALID        |    Both the TRUE and FALSE modes are configured.      |    00|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   171                       * COM_TRUEMODE_VALID    |    Only TRUE mode is configured                       |    01|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   172                       * COM_FALSEMODE_VALID   |    Only FALSE mode is configured                      |    10|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   173                       * COM_MODE_INVALID      |    Both the TRUE and FALSE mode are not configured    |    11|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   174                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   175                      This INLINE function checks the TMS generated values against the requested mode and performs action
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   176                      |-------------|--------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   177                      |ModeRequested|Configured Mode values   |         Description                                           :      Action to be taken                |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   178                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   179                      |    0       |      0        |      0   |  FALSE mode is requested and IPdu TMS is COM_MODE_VALID         : Increment to the false mode data     |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   180                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   181                      |    0       |      0        |      1   |  FALSE mode is requested and IPdu TMS is COM_TRUEMODE_VALID     : Point to NONE mode data              |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   182                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   183                      |    0       |      1        |      0   |  FALSE mode is requested and IPdu TMS is COM_FALSEMODE_VALID     : Do nothing                          |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   184                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   185                      |    0       |      1        |      1   |  FALSE mode is requested and IPdu TMS is COM_MODE_INVALID     : Do nothing                             |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   186                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   187                      |    1       |      0        |      0   |  TRUE mode is requested and IPdu TMS is COM_MODE_VALID         : Do nothing                            |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   188                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   189                      |    1       |      0        |      1   |  TRUE mode is requested and IPdu TMS is COM_TRUEMODE_VALID     : Do nothing                            |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   190                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   191                      |    1       |      1        |      0   |  TRUE mode is requested and IPdu TMS is COM_FALSEMODE_VALID     : Point to NONE mode data              |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   192                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   193                      |    1       |      1        |      1   |  TRUE mode is requested and IPdu TMS is COM_MODE_INVALID         : Do nothing                          |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   194                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   195  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   196                      where 0 in column 1 stands for FALSE mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   197                      and   1 in column 1 stands for TRUE mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   198  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   199   Parameter        : TxIpduRamPtr    - pointer to Txipdu ram data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   200                    : TxIPduConstPtr  - pointer to Txipdu Rom data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   201                    : TMSStatus       - pointer to transmission mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   202                    : ModeRequested   - mode requested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   203   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   204   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   205  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   206  FUNC(void, COM_CODE) Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   207                                  Com_TxIpduRamPtrType                TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   208                                  Com_TxIpduConstPtrType              TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   209                                  VAR(uint16,AUTOMATIC)               TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   210                                  VAR(boolean,AUTOMATIC)              ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   211                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   212  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   213      /* Get the latest TM pointer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   214      TxIpduRamPtr->CurrentTxModePtr = TxIPduConstPtr->Com_TMConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   215  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   216      if(ModeRequested == COM_FALSE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   217      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   218          if((TMSStatus) == COM_TRUEMODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   219          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   220              /*If yes,load NONE mode data */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   221              TxIpduRamPtr->CurrentTxModePtr = &Com_NONE_TransModeInfo ;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   222          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   223          if((TMSStatus) == COM_MODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   224          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   225              /*Increment to FALSE mode data, if the FALSE mode is configured */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   226              TxIpduRamPtr->CurrentTxModePtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   227          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   228      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   229      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   230      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   231          if((TMSStatus) == COM_FALSEMODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   232          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   233              TxIpduRamPtr->CurrentTxModePtr = &Com_NONE_TransModeInfo ;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   234          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   235      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   236  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   237  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   238  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   239   Function name    : Com_UpdateRxGroupSignalSecondBuffer [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   240   Syntax           : void Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   241                                  Com_RxGrpSigConstPtrType    RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   242                                  Com_SigMaxType              RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   243                                  Com_MainFuncType            RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   244                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   245   Description      : Inline function copy Group signal value into the Group signal Second buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   246   Parameter        : RxGrpSigConstPtr - pointer to RxGroupSignal configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   247                    : RxNewVal         - latest RxGroupSignal data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   248                    : RxMainFuncId     - Internally generated Rx-MainFunction-Id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   249   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   250   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   251  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   252  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   253  FUNC(void, COM_CODE) Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   254                                  Com_RxGrpSigConstPtrType            RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   255                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   256                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   257                                                          )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   258  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   259      VAR(uint8,AUTOMATIC)    Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   260  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   261      Type = Com_GetValue(RXGRPSIG,_TYPE,RxGrpSigConstPtr->rxGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   262  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   263      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   264      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   265      case 0x00u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   266          /* UINT08 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   267          COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint8)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   268          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   269  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   270      case 0x01u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   271          /* UINT16 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   272          COM_GET_SECRXGRPSIGTYPEU16_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint16)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   273          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   274  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   275      case 0x02u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   276          /* UINT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   277          /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   278      case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   279          /* FLOAT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   280          /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   281          COM_GET_SECRXGRPSIGTYPEU32_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint32)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   282          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   283  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   284  #ifdef COM_RXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   285      case 0x08u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   286          /* UINT64/SINT64 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   287          COM_GET_SECRXGRPSIGTYPEU64_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   288          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   289  #endif /* #ifdef COM_RXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   290  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   291      case 0x03u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   292          /*Boolean Signal*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   293          COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint8)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   294          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   295  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   296      case 0x04u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   297          /* UINT8_N signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   298          Com_ByteCopyInit(&COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index),
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   299                           (uint32)RxNewVal,RxGrpSigConstPtr->BitSize);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   300          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   301      default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   302          /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   303           * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are allowed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   304           * to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   305           */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   306          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   307  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   308      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   309  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   310  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   311  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   312  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   313   Function name    : Com_UpdateRxSignalBuffer [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   314   Syntax           : void Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   315                                  Com_RxSigConstPtrType   RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   316                                  Com_SigMaxType          RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   317                                  Com_MainFuncType        RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   318                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   319   Description      : Inline function to copy signal value into the signal buffer and
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   320                      is used when signal value as a variable is being passed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   321   Parameter        : RxSigConstPtr - pointer to RxSignal configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   322                    : RxNewVal_Sig  - latest RxSignal data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   323                    : RxMainFuncId  - Internally generated Rx-MainFunction-Id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   324   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   325   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   326  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   327  FUNC(void, COM_CODE) Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   328                                  Com_RxSigConstPtrType               RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   329                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   330                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   331                                               )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   332  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   333      VAR(uint8,AUTOMATIC)    Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   334  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   335      Type = Com_GetValue(GEN,_TYPE,RxSigConstPtr->General);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   336  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   337      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   338      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   339      case 0x00u:     /* COM_UINT8 & COM_SINT8 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   340      case (COM_BOOLEAN >> 1):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   341          COM_GET_SIGTYPEUINT8_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint8)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   342          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   343  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   344      case 0x01u:     /* COM_UINT16 & COM_SINT16 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   345          COM_GET_SIGTYPEUINT16_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint16)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   346          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   347  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   348      case 0x02u:     /* COM_UINT32 & COM_SINT32 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   349  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   350          /* COM_FLOAT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   351  #ifdef COM_FLOAT32SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   352      case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   353  #endif /* #ifdef COM_FLOAT32SUPP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   354  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   355          COM_GET_SIGTYPEUINT32_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint32)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   356          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   357  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   358  #ifdef COM_RXSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   359      case 0x08u:     /* COM_UINT64 & COM_SINT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   360          COM_GET_SIGTYPEUINT64_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   361          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   362  #endif /* #if defined(COM_RXSIG_INT64) && defined(COM_TXSIG_INT64) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   363  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   364      case 0x04u:     /* COM_UINT8_N */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   365          Com_ByteCopyInit(&COM_GET_SIGTYPEUINT8_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index),
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   366                           (uint32)RxNewVal_Sig,RxSigConstPtr->BitSize);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   367          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   368      default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   369          /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   370           * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are allowed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   371           * to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   372           */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   373          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   374      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   375  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   376  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   377  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   378   Function name    : Com_InitializePduBuffWithSignalInitValue [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   379   Syntax           : void Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   380                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   381                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   382                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   383                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   384                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   385                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   386                                                                   )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   387   Description      : Inline function to call required interface to pack signal data into Ipdu buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   388   Parameter        : BuffPtr     - pointer to (SignalGroup)IPdu Buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   389                    : SigInitVal  - (Group)Signal InitValue
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   390                    : SigBitPos   - (Group)Signal Bit Position
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   391                    : SigBitSize  - (Group)Signal Bit Size
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   392                    : SigType     - (Group)Signal Type
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   393                    : SigEndianess- (Group)Signal Endianness
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   394   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   395   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   396  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   397  FUNC(void, COM_CODE) Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   398                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   399                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   400                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   401                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   402                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   403                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   404                                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   405  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   406      if ( SigType != (uint8)COM_UINT8_N )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   407      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   408  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   409  #if (defined(COM_TXSIG_FLOAT64SUPP) || defined(COM_TXGRPSIG_FLOAT64SUPP) ||\ 
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   410      (defined(COM_RX_SIGNALGROUP_ARRAY) && defined(COM_RXGRPSIG_FLOAT64SUPP)))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   411          if ( SigType == COM_FLOAT64 )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   412          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   413              /* Convert the float value into 32 bit stream and then pack the value */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   414              /* Com_PackFloatSignal(TxSigConstPtr->General.Endianess,TxSigConstPtr->Bit_Pos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   415                                     Com_getfloat64InitValue(SigNewVal), TxIPduConstPtr->BuffPtr); */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   416              Com_PackFloatSignal( SigEndianess, SigBitPos, Com_getfloat64InitValue(SigInitVal), BuffPtr );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   417          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   418          else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   419  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   420  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   421          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   422              /* Pack the signal with Initial Value */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   423              /* Com_PackSignal(TxSigConstPtr->General.Endianess,TxSigConstPtr->Bit_Pos,TxSigConstPtr->BitSize,SigNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   424               *                TxIPduConstPtr->BuffPtr);*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   425              Com_PackSignal( SigEndianess, SigBitPos, SigBitSize, SigInitVal, BuffPtr );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   426          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   427      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   428      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   429      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   430          PduLengthType ByteOffset_uo;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   431          /* Find the starting byte position(ByteNo_uo) of Signal in the IPDU buffer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   432          ByteOffset_uo = ( PduLengthType )( SigBitPos >> 3 );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   433  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   434          /* Now copy the Signal into the IPDU buffer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   435          Com_ByteCopyInit( (BuffPtr + ByteOffset_uo), (uint32)SigInitVal, SigBitSize );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   436      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   437  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   438  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   439  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   440   Function name    : Com_Prv_SigGrpReplaceToInit
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   441   Syntax           : void Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   442                                          Com_RxSigGrpConstPtrType  RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   443                                          Com_MainFuncType          RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   444                                                      )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   445   Description      : If the SigGrp is enabled with ArrayAccess, RxSigGrpBuffer will be packed with
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   446                      GroupSignal Init Values OR else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   447                      GroupSignals Shadow buffers will be replaced with its Init Values
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   448   Parameter        : RxSigGrpConstPtr - pointer to RxSignalGroup configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   449                    : RxMainFuncId     - Internally generated RxMainFunction-ID
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   450   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   451   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   452  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   453  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   454                                                  Com_RxSigGrpConstPtrType        RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   455                                                  VAR(Com_MainFuncType,AUTOMATIC) RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   456                                                               )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   457  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   458      Com_RxGrpSigConstPtrType      RxGrpSigConstPtr;      /* Local pointer to Rx GroupSignal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   459  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   460      Com_RxSigGrpArrayConstPtrType RxSigGrpArrayConstPtr; /* Local pointer to Rx SignalGroup Array configuration  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   461      uint8                       * RxSigGrpArrayBufRamPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   462      PduLengthType                 SigGrpBitOffset;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   463  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   464      VAR(uint16_least, AUTOMATIC)  index_ui;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   465      VAR(Com_SigMaxType, AUTOMATIC) SigValue;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   466  # if (defined(COM_RX_SIGNALGROUP_ARRAY) || defined(COM_RXGRPSIG_FLOAT64SUPP) || defined(COM_RXGRPSIG_INT64))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   467      VAR(uint8, AUTOMATIC)         SigType;  /* Signal Type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   468  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   469  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   470      boolean                       ConstIsSigGrpOfArrayType_b;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   471  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   472      ConstIsSigGrpOfArrayType_b = Com_GetValue(RXSIGGRP,_ARRAYACCESS,RxSigGrpConstPtr->rxSignalGrpFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   473  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   474      if ( ConstIsSigGrpOfArrayType_b )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   475      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   476          RxSigGrpArrayConstPtr  = COM_GET_RXSIGGRP_ARRAY_CONSTDATA( RxSigGrpConstPtr->SigGrpArray_Index );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   477  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   478          RxSigGrpArrayBufRamPtr = &COM_GET_RXSIGGRP_ARRAY_BUFF(RxMainFuncId, RxSigGrpArrayConstPtr->RxSigGrpBuf_Index );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   479  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   480          SigGrpBitOffset        = ( RxSigGrpArrayConstPtr->FirstByteNo * 8u );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   481  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   482          SchM_Enter_Com_RxSigGrpArrayBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   483      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   484      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   485  # endif /* # ifdef COM_RX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   486      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   487          SchM_Enter_Com_RxGrpSigSecBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   488      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   489  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   490      RxGrpSigConstPtr = COM_GET_RXGRPSIG_CONSTDATA( RxSigGrpConstPtr->FirstGrpSig_Index );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   491  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   492      for ( index_ui = (uint16_least)RxSigGrpConstPtr->No_Of_GrpSig; index_ui != (uint16_least)0; index_ui-- )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   493      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   494  # if (defined(COM_RX_SIGNALGROUP_ARRAY) || defined(COM_RXGRPSIG_FLOAT64SUPP) || defined(COM_RXGRPSIG_INT64))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   495          SigType = Com_GetValue(RXGRPSIG,_TYPE,RxGrpSigConstPtr->rxGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   496  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   497  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   498          SigValue = (Com_SigMaxType)RxGrpSigConstPtr->Init_Val;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   499  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   500  #ifdef COM_RXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   501          /* [SWS_Com_00723] The AUTOSAR COM module shall extend the init value (ComSignalInitValue) of a signal
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   502           * to the size of its ComSignalType.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   503           * Currently for COM_SINT64 signal type, ComSignalInitValue is supported for maximum 32bits.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   504           * If negative values are configured, by default these values will be sign extended only till 32bits.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   505           * so, for COM_SINT64, it is required to perform the sign extension till 64bits explicity. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   506          SigValue = (SigType == COM_SINT64) ? (Com_SigMaxType)((sint64)((sint32)SigValue)) : SigValue;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   507  #endif /* #ifdef COM_RXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   508  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   509  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   510          if ( ConstIsSigGrpOfArrayType_b )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   511          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   512              Com_BitpositionType RelativeSigBitPos; /* Relative BitPosition in RxSignalGroup Array */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   513  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   514              /* The Buffer into which Signal Values needs to be packed will be available with starting address
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   515               * of the Rx-SignalGroup Array Buffer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   516               * But we have GroupSignal: Bit_Pos, i.e., Signal's actual LSB in the IPdu Buffer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   517               * So, Rx-SignalGroup BitOffset(SigGrpBitOffset) is removed from each of the GroupSignal and
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   518               * is used as BitPosition to pack its value into the Rx-SignalGroup Array Buffer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   519              RelativeSigBitPos = RxGrpSigConstPtr->Bit_Pos - ( Com_BitpositionType )SigGrpBitOffset;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   520  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   521              Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   522                                                RxSigGrpArrayBufRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   523                                                SigValue,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   524                                                RelativeSigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   525                                                RxGrpSigConstPtr->BitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   526                                                SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   527                                                Com_GetValue(RXGRPSIG,_ENDIANESS,RxGrpSigConstPtr->rxGrpSigFields) );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   528          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   529          else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   530  # endif /* #ifdef COM_RX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   531          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   532  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   533  # ifdef COM_RXGRPSIG_FLOAT64SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   534              if(SigType == COM_FLOAT64)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   535              {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   536                  COM_GET_SECRXGRPSIGTYPEFLOAT64_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) =
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   537                                                                        Com_getfloat64InitValue(SigValue);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   538              }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   539              else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   540  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   541  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   542              {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   543                  Com_UpdateRxGroupSignalSecondBuffer(RxGrpSigConstPtr, SigValue, RxMainFuncId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   544              }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   545          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   546  # if defined(COM_RxFilters) && defined(COM_F_MASKEDNEWDIFFERSOLD)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   547          /* [SWS_Com_00603] The AUTOSAR COM module shall set the old_value of the filtering mechanisms
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   548           * for each signal to the ComSignalInitValue during start-up */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   549          if ( ( COM_INIT != Com_Uninit_Flag ) && ( COM_MASKED_NEW_DIFFERS_MASKED_OLD == RxGrpSigConstPtr->Filter_Algo ) )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   550          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   551              COM_GET_F_OLDVALUE(RxGrpSigConstPtr->Filter_Index) = (uint32)SigValue;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   552          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   553  # endif /* # if defined(COM_RxFilters) && defined(COM_F_MASKEDNEWDIFFERSOLD) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   554  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   555          RxGrpSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   556      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   557  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   558  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   559      if ( ConstIsSigGrpOfArrayType_b )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   560      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   561          SchM_Exit_Com_RxSigGrpArrayBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   562      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   563      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   564  # endif /* # ifdef COM_RX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   565      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   566          SchM_Exit_Com_RxGrpSigSecBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   567      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   568  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   569  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   570  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   571  #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   572  #ifdef COM_TxIPduNotification
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   573  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxNotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   574          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   575      Com_TxIpduConstPtrType TxIPduConstPtr;    /* Local pointer to Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   576      Com_TxSigConstPtrType TxSigConstPtr;    /* Local pointer to Tx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   577  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   578      Com_TxSigGrpConstPtrType TxSigGrpConstPtr; /* Local pointer to hold the address of Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   579  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   580      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   581  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   582      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   583      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   584      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   585  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   586      IpduId = COM_GET_TX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   587      TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   588      TxSigConstPtr = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   589  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   590      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(TxIPduConstPtr->FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   591  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   592  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   593      for(index_u8 = TxIPduConstPtr->TxSigId_Index; index_u8 < (TxIPduConstPtr->TxSigId_Index + TxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   594      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   595          if(TxSigConstPtr->Notification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   596          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   597              TxSigConstPtr->Notification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   598          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   599          TxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   600      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   601  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   602      for(index_u8 = TxIPduConstPtr->FirstTxSigGrp_Index; index_u8 < (TxIPduConstPtr->FirstTxSigGrp_Index + TxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   603      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   604          if(TxSigGrpConstPtr->Notification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   605          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   606              TxSigGrpConstPtr->Notification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   607          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   608          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   609      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   610  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   611  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   612          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   613  #endif /* #ifdef COM_TxIPduNotification */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   614  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   615  #ifdef COM_ERRORNOTIFICATION
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   616  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxErrNotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   617  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   618  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   619      Com_TxIpduConstPtrType TxIPduConstPtr;    /* Local pointer to Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   620      Com_TxSigConstPtrType TxSigConstPtr;    /* Local pointer to Tx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   621  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   622      Com_TxSigGrpConstPtrType TxSigGrpConstPtr; /* Local pointer to hold the address of Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   623  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   624      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   625  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   626      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   627      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   628      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   629  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   630      IpduId = COM_GET_TX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   631      TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   632      TxSigConstPtr = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   633  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   634      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(TxIPduConstPtr->FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   635  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   636  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   637      for(index_u8 = TxIPduConstPtr->TxSigId_Index; index_u8 < (TxIPduConstPtr->TxSigId_Index + TxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   638      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   639          if(TxSigConstPtr->NotificationError_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   640          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   641              TxSigConstPtr->NotificationError_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   642          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   643          TxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   644      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   645  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   646      for(index_u8 = TxIPduConstPtr->FirstTxSigGrp_Index; index_u8 < (TxIPduConstPtr->FirstTxSigGrp_Index + TxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   647      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   648          if(TxSigGrpConstPtr->NotificationError_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   649          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   650              TxSigGrpConstPtr->NotificationError_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   651          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   652          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   653      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   654  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   655  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   656  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   657  #endif /* #ifdef COM_ERRORNOTIFICATION */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   658  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   659  #ifdef COM_TxIPduTimeOutNotify
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   660  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxTONotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   661  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   662  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   663      Com_TxIpduConstPtrType TxIPduConstPtr;    /* Local pointer to Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   664      Com_TxSigConstPtrType TxSigConstPtr;    /* Local pointer to Tx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   665  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   666      Com_TxSigGrpConstPtrType TxSigGrpConstPtr; /* Local pointer to hold the address of Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   667  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   668      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   669  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   670      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   671      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   672      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   673  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   674      IpduId = COM_GET_TX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   675      TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   676      TxSigConstPtr = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   677  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   678      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(TxIPduConstPtr->FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   679  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   680  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   681      for(index_u8 = TxIPduConstPtr->TxSigId_Index; index_u8 < (TxIPduConstPtr->TxSigId_Index + TxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   682      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   683          if(TxSigConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   684          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   685              TxSigConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   686          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   687          TxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   688      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   689  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   690      for(index_u8 = TxIPduConstPtr->FirstTxSigGrp_Index; index_u8 < (TxIPduConstPtr->FirstTxSigGrp_Index + TxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   691      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   692          if(TxSigGrpConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   693          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   694              TxSigGrpConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   695          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   696          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   697      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   698  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   699  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   700  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   701  #endif /* #ifdef COM_TxIPduTimeOutNotify */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   702  #ifdef COM_RxIPduTimeoutNotify
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   703  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallRxTONotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   704  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   705  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   706      Com_RxIpduConstPtrType RxIPduConstPtr;    /* Local pointer to Rx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   707      Com_RxSigConstPtrType RxSigConstPtr;    /* Local pointer to Rx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   708  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   709      Com_RxSigGrpConstPtrType RxSigGrpConstPtr; /* Local pointer to hold the address of Rx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   710  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   711      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   712  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   713      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   714      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   715      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   716  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   717      IpduId = COM_GET_RX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   718      RxIPduConstPtr = COM_GET_RX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   719      RxSigConstPtr = COM_GET_RXSIG_CONSTDATA(RxIPduConstPtr->RxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   720  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   721      RxSigGrpConstPtr = COM_GET_RXSIGGRP_CONSTDATA(RxIPduConstPtr->FirstRxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   722  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   723  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   724      for(index_u8 = RxIPduConstPtr->RxSigId_Index; index_u8 < (RxIPduConstPtr->RxSigId_Index + RxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   725      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   726          if(RxSigConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   727          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   728              RxSigConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   729          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   730          RxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   731      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   732  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   733      for(index_u8 = RxIPduConstPtr->FirstRxSigGrp_Index; index_u8 < (RxIPduConstPtr->FirstRxSigGrp_Index + RxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   734      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   735          if(RxSigGrpConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   736          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   737              RxSigGrpConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   738          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   739          RxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   740      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   741  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   742  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   743  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   744  #endif /* #ifdef COM_RxIPduTimeoutNotify */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   745  #endif /* #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   746  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   747  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   748  LOCAL_INLINE FUNC(void, COM_CODE) Com_CopyTxGroupSignalData( Com_SignalIdType    GrpSignalId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   749                                                               Com_SigMaxType      TxGrpSig_NewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   750                                                               Com_MainFuncType    TxMainFuncId )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   751  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   752      Com_TxGrpSigConstPtrType                   TxGrpSigConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   753      VAR(Com_TxGrpSigBuffIndexType, AUTOMATIC)  GrpSigBuff_Index;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   754      VAR(uint8, AUTOMATIC)                      Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   755  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   756      TxGrpSigConstPtr = COM_GET_TXGRPSIG_CONSTDATA(GrpSignalId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   757      GrpSigBuff_Index = TxGrpSigConstPtr->TxGrpSigBuff_Index;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   758      Type = Com_GetValue(TXGRPSIG,_TYPE,TxGrpSigConstPtr->txGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   759  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   760      SchM_Enter_Com_TxGrpSigBuffer();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   761      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   762      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   763  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   764          case 0x00u: /* UINT8 and SINT8 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   765          case 0x03u: /* Boolean type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   766              COM_GET_TXGRPSIGTYPEU8_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint8)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   767              break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   768  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   769          /* UINT16 and SINT16 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   770          case 0x01u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   771              COM_GET_TXGRPSIGTYPEU16_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint16)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   772              break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   773  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   774          /* UINT32,SINT32 and FLOAT32 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   775          case 0x02u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   776          /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   777  #ifdef COM_FLOAT32SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   778          case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   779  #endif /* #ifdef COM_FLOAT32SUPP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   780          /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   781              COM_GET_TXGRPSIGTYPEU32_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint32)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   782              break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   783  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   784          /* UINT64 and SINT64 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   785  #ifdef COM_TXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   786          case 0x08u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   787              COM_GET_TXGRPSIGTYPEU64_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint64)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   788          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   789  #endif /* #ifdef COM_TXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   790  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   791          default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   792              /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   793               * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   794               * allowed to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   795               */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   796          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   797     }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   798      SchM_Exit_Com_TxGrpSigBuffer();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   799  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   800  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   801  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   802  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   803  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   804  #if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   805  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   806  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   807   Function name    : Com_Prv_DETCheck_Void
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   808   Syntax           : boolean Com_Prv_DETCheck_Void(uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   809   Description      : Inline function to check for module initialization
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   810   Parameter        : ApiId - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   811   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   812                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   813   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   814  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Void(uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   815  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   816      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   817      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   818  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   819      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   820      Status  = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   821  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   822      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   823      if (Com_Uninit_Flag == COM_UNINIT)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   824      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   825          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   826          COM_REPORT_ERROR_CHECK(ApiId, COM_E_UNINIT);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   827          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   828          Status = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   829      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   830      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   831      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   832          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   833      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   834  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   835      return Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   836  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   837  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   838  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   839   Function name    : Com_Prv_DETCheck_Param
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   840   Syntax           : boolean Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   841   Description      : Inline function to check for module initialization and valid parameter value.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   842   Parameter        : isInValidParam - calling service is called with invalid parameter value
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   843                      ApiId          - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   844   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   845                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   846   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   847  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   848  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   849      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   850      uint8   ErrorId;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   851      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   852  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   853      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   854      ErrorId = COM_DET_NO_ERROR;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   855      Status  = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   856  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   857      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   858      if (Com_Uninit_Flag == COM_UNINIT)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   859      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   860          ErrorId = COM_E_UNINIT;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   861      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   862      else if (isInValidParam)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   863      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   864          ErrorId = COM_E_PARAM;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   865      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   866      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   867      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   868          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   869      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   870  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   871      /* Check if ErrorId has Error Code */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   872      if (ErrorId != COM_DET_NO_ERROR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   873      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   874          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   875          COM_REPORT_ERROR_CHECK(ApiId, ErrorId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   876          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   877          Status = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   878      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   879      return Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   880  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   881  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   882  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   883   Function name    : Com_Prv_DETCheck_Ptr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   884   Syntax           : boolean Com_Prv_DETCheck_Ptr(boolean isInValidPtr, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   885   Description      : Inline function to check for module initialization and valid pointer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   886   Parameter        : isInValidPtr - calling service is called with invalid pointer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   887                      ApiId        - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   888   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   889                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   890   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   891  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Ptr(boolean isInValidPtr, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   892  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   893      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   894      uint8   ErrorId;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   895      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   896  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   897      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   898      ErrorId = COM_DET_NO_ERROR;
	mov	d7,#255
.L317:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   899      Status  = COM_TRUE;
	mov	d1,#1
.L318:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   900  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   901      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   902      if (Com_Uninit_Flag == COM_UNINIT)
	movh.a	a2,#@his(Com_Uninit_Flag)
	lea	a2,[a2]@los(Com_Uninit_Flag)
	ld.w	d15,[a2]
.L511:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   902      if (Com_Uninit_Flag == COM_UNINIT)      (inlined)
	jne	d15,#0,.L69
.L512:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   903      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   904          ErrorId = COM_E_UNINIT;
	mov	d7,#2
.L513:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   904          ErrorId = COM_E_UNINIT;      (inlined)
	j	.L70

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   902      if (Com_Uninit_Flag == COM_UNINIT)      (inlined)
.L69:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   906      else if (isInValidPtr)      (inlined)
	jeq	d0,#0,.L71
.L514:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   905      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   906      else if (isInValidPtr)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   907      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   908          ErrorId = COM_E_PARAM_POINTER;
	mov	d7,#3
.L515:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   908          ErrorId = COM_E_PARAM_POINTER;      (inlined)
	j	.L72

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   906      else if (isInValidPtr)      (inlined)
.L71:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   910      else      (inlined)
.L72:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   906      else if (isInValidPtr)      (inlined)
.L70:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   909      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   910      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   911      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   912          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   913      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   914  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   915      /* Check if ErrorId has Error Code */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   916      if (ErrorId != COM_DET_NO_ERROR)
	mov	d15,#255
.L516:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   916      if (ErrorId != COM_DET_NO_ERROR)      (inlined)
	jeq	d15,d7,.L73
.L517:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   917      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   918          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   919          COM_REPORT_ERROR_CHECK(ApiId, ErrorId);
	mov	d4,#50
	mov	d5,#0
	call	Det_ReportError
.L314:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   920          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   921          Status = COM_FALSE;
	mov	d1,#0

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   916      if (ErrorId != COM_DET_NO_ERROR)      (inlined)
.L73:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   923      return Status;      (inlined)
	j	.L74

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   924  }      (inlined)
.L74:
	jeq	d1,#0,.L75
.L240:
	mov	d15,#0
.L319:
	j	.L76
.L77:
	mov.aa	a2,a15
.L316:
	add.a	a2,#0
.L518:
	mov	d0,#0
.L519:
	st.b	[a2],d0
.L520:
	add	d15,#1
.L76:
	jeq	d15,#0,.L77
.L75:
	ret
.L237:
	
__Com_ClearIpduGroupVector_function_end:
	.size	Com_ClearIpduGroupVector,__Com_ClearIpduGroupVector_function_end-Com_ClearIpduGroupVector
.L108:
	; End of function
	
	.sdecl	'.text.Com_IpduGroupStart.Com_SetIpduGroup',code,cluster('Com_SetIpduGroup')
	.sect	'.text.Com_IpduGroupStart.Com_SetIpduGroup'
	.align	2
	
	.global	Com_SetIpduGroup
; Function Com_SetIpduGroup
.L94:
Com_SetIpduGroup:	.type	func
	mov.aa	a15,a4
.L323:
	mov	e8,d5,d4
.L325:
	ge.u	d0,d8,#2
.L326:
	mov.a	a2,#0
.L525:
	eq.a	d1,a15,a2
.L526:
	mov	d6,#29
.L251:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     1  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     2  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     3  #ifndef COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     4  #define COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     5  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     6  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     7   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     8   * Includes
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     9   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    10  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    11  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    12  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    13  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    17  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    18  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    19  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    20  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    21   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    22   * Type definitions
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    23   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    24  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    25  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    26  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    27  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    28   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    29   * Variables
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    30   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    31  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    32  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    33  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    34  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    35   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    36   * Extern declarations
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    37   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    38  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    39  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    40   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    41   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    42   * Inline function sets TMS data in to be accessesd via CurrentTxModePtr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    43   * after evaluating TMS mode for the IPdu
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    44   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    45  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    46  FUNC(void, COM_CODE) Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    47                                  Com_TxIpduRamPtrType                TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    48                                  Com_TxIpduConstPtrType              TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    49                                  VAR(uint16,AUTOMATIC)               TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    50                                  VAR(boolean,AUTOMATIC)              ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    51                                              );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    52  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    53  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    54   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    55   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    56   * Inline function to update Rx-GroupSignal application buffers
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    57   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    58  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    59  FUNC(void, COM_CODE) Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    60                                  Com_RxSigConstPtrType               RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    61                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    62                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    63                                               );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    64  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    65  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    66   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    67   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    68   * Inline function to update Rx-GroupSignal secondary buffers
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    69   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    70  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    71  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    72  FUNC(void, COM_CODE) Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    73                                  Com_RxGrpSigConstPtrType            RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    74                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    75                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    76                                                          );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    77  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    78  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    79  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    80   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    81   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    82   * Inline function to initialize signal intial value into the provided IPdu buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    83   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    84  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    85  FUNC(void, COM_CODE) Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    86                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    87                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    88                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    89                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    90                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    91                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    92                                                              );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    93  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    94  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    95   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    96   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    97   * Inline function to initialize Rx-signal group with initial values
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    98   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    99  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   100  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   101  FUNC(void, COM_CODE) Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   102                                  Com_RxSigGrpConstPtrType            RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   103                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   104                                                  );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   105  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   106  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   107  #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   108  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxNotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   109  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxErrNotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   110  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxTONotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   111  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallRxTONotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   112  #endif /* #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   113  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   114  /* Inline function to check for the RxIPdu and TxIpdu status*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   115  LOCAL_INLINE boolean Com_CheckRxIPduStatus(PduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   116  LOCAL_INLINE boolean Com_CheckTxIPduStatus(PduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   117  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   118  #if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   119  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   120  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Void(uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   121  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   122  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Ptr(boolean isInValidPtr, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   123  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Param_Ptr(boolean isInValidParam, boolean isInValidPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   124                                                                  uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   125  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Ptr_Only(boolean isInValidPtr, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   126  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Param_Only(boolean isInValidParam, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   127  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   128  #endif /*  #if (COM_CONFIGURATION_USE_DET == STD_ON) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   129  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   130  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   131  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   132  LOCAL_INLINE FUNC(void, COM_CODE) Com_CopyTxGroupSignalData( Com_SignalIdType    GrpSignalId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   133                                                               Com_SigMaxType      TxGrpSig_NewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   134                                                               Com_MainFuncType    TxMainFuncId );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   135  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   136  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   137  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   138   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   139   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   140   * Inline function to handle gateway and non-gateway use-case for tx-signal/signalGroup
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   141   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   142  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_ProceedToSendIpdu(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   143                                                  VAR(Com_IpduIdType, AUTOMATIC)          ComTxPduId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   144                                                  VAR(Com_SendIpduInfo, AUTOMATIC)        sendIpduFlag_u16
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   145                                                             );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   146  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   147  #ifdef COM_TxFilters
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   148  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_CheckModeChange(VAR(Com_IpduIdType, AUTOMATIC) TxIpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   149  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   150  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   151  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   152  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   153   * Inline Function Definition
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   154   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   155  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   156  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   157   Function name    : Com_SetCurrentTxModePtr [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   158   Syntax           : void Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   159                                  Com_TxIpduRamPtrType    TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   160                                  Com_TxIpduConstPtrType  TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   161                                  uint16                  TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   162                                  boolean                 ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   163                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   164   Description      : Inline function sets TMS data in to be accessesd via CurrentTxModePtr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   165                      after evaluating TMS mode for the IPdu
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   166  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   167                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   168                       * Mode                  |    Configuration details                              | Value|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   169                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   170                       * COM_MODE_VALID        |    Both the TRUE and FALSE modes are configured.      |    00|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   171                       * COM_TRUEMODE_VALID    |    Only TRUE mode is configured                       |    01|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   172                       * COM_FALSEMODE_VALID   |    Only FALSE mode is configured                      |    10|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   173                       * COM_MODE_INVALID      |    Both the TRUE and FALSE mode are not configured    |    11|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   174                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   175                      This INLINE function checks the TMS generated values against the requested mode and performs action
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   176                      |-------------|--------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   177                      |ModeRequested|Configured Mode values   |         Description                                           :      Action to be taken                |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   178                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   179                      |    0       |      0        |      0   |  FALSE mode is requested and IPdu TMS is COM_MODE_VALID         : Increment to the false mode data     |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   180                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   181                      |    0       |      0        |      1   |  FALSE mode is requested and IPdu TMS is COM_TRUEMODE_VALID     : Point to NONE mode data              |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   182                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   183                      |    0       |      1        |      0   |  FALSE mode is requested and IPdu TMS is COM_FALSEMODE_VALID     : Do nothing                          |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   184                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   185                      |    0       |      1        |      1   |  FALSE mode is requested and IPdu TMS is COM_MODE_INVALID     : Do nothing                             |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   186                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   187                      |    1       |      0        |      0   |  TRUE mode is requested and IPdu TMS is COM_MODE_VALID         : Do nothing                            |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   188                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   189                      |    1       |      0        |      1   |  TRUE mode is requested and IPdu TMS is COM_TRUEMODE_VALID     : Do nothing                            |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   190                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   191                      |    1       |      1        |      0   |  TRUE mode is requested and IPdu TMS is COM_FALSEMODE_VALID     : Point to NONE mode data              |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   192                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   193                      |    1       |      1        |      1   |  TRUE mode is requested and IPdu TMS is COM_MODE_INVALID         : Do nothing                          |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   194                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   195  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   196                      where 0 in column 1 stands for FALSE mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   197                      and   1 in column 1 stands for TRUE mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   198  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   199   Parameter        : TxIpduRamPtr    - pointer to Txipdu ram data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   200                    : TxIPduConstPtr  - pointer to Txipdu Rom data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   201                    : TMSStatus       - pointer to transmission mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   202                    : ModeRequested   - mode requested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   203   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   204   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   205  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   206  FUNC(void, COM_CODE) Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   207                                  Com_TxIpduRamPtrType                TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   208                                  Com_TxIpduConstPtrType              TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   209                                  VAR(uint16,AUTOMATIC)               TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   210                                  VAR(boolean,AUTOMATIC)              ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   211                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   212  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   213      /* Get the latest TM pointer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   214      TxIpduRamPtr->CurrentTxModePtr = TxIPduConstPtr->Com_TMConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   215  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   216      if(ModeRequested == COM_FALSE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   217      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   218          if((TMSStatus) == COM_TRUEMODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   219          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   220              /*If yes,load NONE mode data */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   221              TxIpduRamPtr->CurrentTxModePtr = &Com_NONE_TransModeInfo ;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   222          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   223          if((TMSStatus) == COM_MODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   224          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   225              /*Increment to FALSE mode data, if the FALSE mode is configured */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   226              TxIpduRamPtr->CurrentTxModePtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   227          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   228      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   229      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   230      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   231          if((TMSStatus) == COM_FALSEMODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   232          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   233              TxIpduRamPtr->CurrentTxModePtr = &Com_NONE_TransModeInfo ;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   234          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   235      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   236  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   237  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   238  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   239   Function name    : Com_UpdateRxGroupSignalSecondBuffer [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   240   Syntax           : void Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   241                                  Com_RxGrpSigConstPtrType    RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   242                                  Com_SigMaxType              RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   243                                  Com_MainFuncType            RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   244                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   245   Description      : Inline function copy Group signal value into the Group signal Second buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   246   Parameter        : RxGrpSigConstPtr - pointer to RxGroupSignal configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   247                    : RxNewVal         - latest RxGroupSignal data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   248                    : RxMainFuncId     - Internally generated Rx-MainFunction-Id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   249   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   250   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   251  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   252  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   253  FUNC(void, COM_CODE) Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   254                                  Com_RxGrpSigConstPtrType            RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   255                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   256                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   257                                                          )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   258  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   259      VAR(uint8,AUTOMATIC)    Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   260  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   261      Type = Com_GetValue(RXGRPSIG,_TYPE,RxGrpSigConstPtr->rxGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   262  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   263      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   264      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   265      case 0x00u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   266          /* UINT08 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   267          COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint8)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   268          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   269  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   270      case 0x01u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   271          /* UINT16 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   272          COM_GET_SECRXGRPSIGTYPEU16_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint16)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   273          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   274  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   275      case 0x02u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   276          /* UINT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   277          /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   278      case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   279          /* FLOAT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   280          /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   281          COM_GET_SECRXGRPSIGTYPEU32_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint32)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   282          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   283  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   284  #ifdef COM_RXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   285      case 0x08u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   286          /* UINT64/SINT64 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   287          COM_GET_SECRXGRPSIGTYPEU64_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   288          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   289  #endif /* #ifdef COM_RXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   290  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   291      case 0x03u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   292          /*Boolean Signal*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   293          COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint8)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   294          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   295  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   296      case 0x04u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   297          /* UINT8_N signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   298          Com_ByteCopyInit(&COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index),
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   299                           (uint32)RxNewVal,RxGrpSigConstPtr->BitSize);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   300          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   301      default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   302          /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   303           * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are allowed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   304           * to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   305           */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   306          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   307  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   308      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   309  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   310  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   311  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   312  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   313   Function name    : Com_UpdateRxSignalBuffer [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   314   Syntax           : void Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   315                                  Com_RxSigConstPtrType   RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   316                                  Com_SigMaxType          RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   317                                  Com_MainFuncType        RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   318                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   319   Description      : Inline function to copy signal value into the signal buffer and
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   320                      is used when signal value as a variable is being passed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   321   Parameter        : RxSigConstPtr - pointer to RxSignal configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   322                    : RxNewVal_Sig  - latest RxSignal data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   323                    : RxMainFuncId  - Internally generated Rx-MainFunction-Id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   324   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   325   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   326  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   327  FUNC(void, COM_CODE) Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   328                                  Com_RxSigConstPtrType               RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   329                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   330                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   331                                               )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   332  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   333      VAR(uint8,AUTOMATIC)    Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   334  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   335      Type = Com_GetValue(GEN,_TYPE,RxSigConstPtr->General);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   336  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   337      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   338      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   339      case 0x00u:     /* COM_UINT8 & COM_SINT8 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   340      case (COM_BOOLEAN >> 1):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   341          COM_GET_SIGTYPEUINT8_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint8)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   342          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   343  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   344      case 0x01u:     /* COM_UINT16 & COM_SINT16 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   345          COM_GET_SIGTYPEUINT16_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint16)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   346          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   347  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   348      case 0x02u:     /* COM_UINT32 & COM_SINT32 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   349  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   350          /* COM_FLOAT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   351  #ifdef COM_FLOAT32SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   352      case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   353  #endif /* #ifdef COM_FLOAT32SUPP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   354  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   355          COM_GET_SIGTYPEUINT32_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint32)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   356          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   357  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   358  #ifdef COM_RXSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   359      case 0x08u:     /* COM_UINT64 & COM_SINT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   360          COM_GET_SIGTYPEUINT64_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   361          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   362  #endif /* #if defined(COM_RXSIG_INT64) && defined(COM_TXSIG_INT64) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   363  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   364      case 0x04u:     /* COM_UINT8_N */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   365          Com_ByteCopyInit(&COM_GET_SIGTYPEUINT8_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index),
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   366                           (uint32)RxNewVal_Sig,RxSigConstPtr->BitSize);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   367          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   368      default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   369          /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   370           * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are allowed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   371           * to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   372           */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   373          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   374      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   375  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   376  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   377  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   378   Function name    : Com_InitializePduBuffWithSignalInitValue [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   379   Syntax           : void Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   380                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   381                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   382                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   383                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   384                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   385                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   386                                                                   )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   387   Description      : Inline function to call required interface to pack signal data into Ipdu buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   388   Parameter        : BuffPtr     - pointer to (SignalGroup)IPdu Buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   389                    : SigInitVal  - (Group)Signal InitValue
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   390                    : SigBitPos   - (Group)Signal Bit Position
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   391                    : SigBitSize  - (Group)Signal Bit Size
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   392                    : SigType     - (Group)Signal Type
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   393                    : SigEndianess- (Group)Signal Endianness
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   394   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   395   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   396  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   397  FUNC(void, COM_CODE) Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   398                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   399                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   400                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   401                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   402                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   403                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   404                                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   405  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   406      if ( SigType != (uint8)COM_UINT8_N )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   407      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   408  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   409  #if (defined(COM_TXSIG_FLOAT64SUPP) || defined(COM_TXGRPSIG_FLOAT64SUPP) ||\ 
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   410      (defined(COM_RX_SIGNALGROUP_ARRAY) && defined(COM_RXGRPSIG_FLOAT64SUPP)))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   411          if ( SigType == COM_FLOAT64 )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   412          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   413              /* Convert the float value into 32 bit stream and then pack the value */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   414              /* Com_PackFloatSignal(TxSigConstPtr->General.Endianess,TxSigConstPtr->Bit_Pos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   415                                     Com_getfloat64InitValue(SigNewVal), TxIPduConstPtr->BuffPtr); */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   416              Com_PackFloatSignal( SigEndianess, SigBitPos, Com_getfloat64InitValue(SigInitVal), BuffPtr );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   417          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   418          else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   419  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   420  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   421          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   422              /* Pack the signal with Initial Value */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   423              /* Com_PackSignal(TxSigConstPtr->General.Endianess,TxSigConstPtr->Bit_Pos,TxSigConstPtr->BitSize,SigNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   424               *                TxIPduConstPtr->BuffPtr);*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   425              Com_PackSignal( SigEndianess, SigBitPos, SigBitSize, SigInitVal, BuffPtr );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   426          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   427      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   428      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   429      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   430          PduLengthType ByteOffset_uo;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   431          /* Find the starting byte position(ByteNo_uo) of Signal in the IPDU buffer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   432          ByteOffset_uo = ( PduLengthType )( SigBitPos >> 3 );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   433  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   434          /* Now copy the Signal into the IPDU buffer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   435          Com_ByteCopyInit( (BuffPtr + ByteOffset_uo), (uint32)SigInitVal, SigBitSize );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   436      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   437  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   438  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   439  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   440   Function name    : Com_Prv_SigGrpReplaceToInit
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   441   Syntax           : void Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   442                                          Com_RxSigGrpConstPtrType  RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   443                                          Com_MainFuncType          RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   444                                                      )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   445   Description      : If the SigGrp is enabled with ArrayAccess, RxSigGrpBuffer will be packed with
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   446                      GroupSignal Init Values OR else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   447                      GroupSignals Shadow buffers will be replaced with its Init Values
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   448   Parameter        : RxSigGrpConstPtr - pointer to RxSignalGroup configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   449                    : RxMainFuncId     - Internally generated RxMainFunction-ID
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   450   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   451   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   452  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   453  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   454                                                  Com_RxSigGrpConstPtrType        RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   455                                                  VAR(Com_MainFuncType,AUTOMATIC) RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   456                                                               )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   457  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   458      Com_RxGrpSigConstPtrType      RxGrpSigConstPtr;      /* Local pointer to Rx GroupSignal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   459  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   460      Com_RxSigGrpArrayConstPtrType RxSigGrpArrayConstPtr; /* Local pointer to Rx SignalGroup Array configuration  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   461      uint8                       * RxSigGrpArrayBufRamPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   462      PduLengthType                 SigGrpBitOffset;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   463  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   464      VAR(uint16_least, AUTOMATIC)  index_ui;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   465      VAR(Com_SigMaxType, AUTOMATIC) SigValue;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   466  # if (defined(COM_RX_SIGNALGROUP_ARRAY) || defined(COM_RXGRPSIG_FLOAT64SUPP) || defined(COM_RXGRPSIG_INT64))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   467      VAR(uint8, AUTOMATIC)         SigType;  /* Signal Type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   468  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   469  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   470      boolean                       ConstIsSigGrpOfArrayType_b;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   471  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   472      ConstIsSigGrpOfArrayType_b = Com_GetValue(RXSIGGRP,_ARRAYACCESS,RxSigGrpConstPtr->rxSignalGrpFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   473  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   474      if ( ConstIsSigGrpOfArrayType_b )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   475      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   476          RxSigGrpArrayConstPtr  = COM_GET_RXSIGGRP_ARRAY_CONSTDATA( RxSigGrpConstPtr->SigGrpArray_Index );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   477  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   478          RxSigGrpArrayBufRamPtr = &COM_GET_RXSIGGRP_ARRAY_BUFF(RxMainFuncId, RxSigGrpArrayConstPtr->RxSigGrpBuf_Index );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   479  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   480          SigGrpBitOffset        = ( RxSigGrpArrayConstPtr->FirstByteNo * 8u );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   481  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   482          SchM_Enter_Com_RxSigGrpArrayBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   483      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   484      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   485  # endif /* # ifdef COM_RX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   486      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   487          SchM_Enter_Com_RxGrpSigSecBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   488      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   489  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   490      RxGrpSigConstPtr = COM_GET_RXGRPSIG_CONSTDATA( RxSigGrpConstPtr->FirstGrpSig_Index );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   491  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   492      for ( index_ui = (uint16_least)RxSigGrpConstPtr->No_Of_GrpSig; index_ui != (uint16_least)0; index_ui-- )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   493      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   494  # if (defined(COM_RX_SIGNALGROUP_ARRAY) || defined(COM_RXGRPSIG_FLOAT64SUPP) || defined(COM_RXGRPSIG_INT64))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   495          SigType = Com_GetValue(RXGRPSIG,_TYPE,RxGrpSigConstPtr->rxGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   496  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   497  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   498          SigValue = (Com_SigMaxType)RxGrpSigConstPtr->Init_Val;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   499  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   500  #ifdef COM_RXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   501          /* [SWS_Com_00723] The AUTOSAR COM module shall extend the init value (ComSignalInitValue) of a signal
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   502           * to the size of its ComSignalType.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   503           * Currently for COM_SINT64 signal type, ComSignalInitValue is supported for maximum 32bits.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   504           * If negative values are configured, by default these values will be sign extended only till 32bits.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   505           * so, for COM_SINT64, it is required to perform the sign extension till 64bits explicity. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   506          SigValue = (SigType == COM_SINT64) ? (Com_SigMaxType)((sint64)((sint32)SigValue)) : SigValue;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   507  #endif /* #ifdef COM_RXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   508  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   509  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   510          if ( ConstIsSigGrpOfArrayType_b )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   511          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   512              Com_BitpositionType RelativeSigBitPos; /* Relative BitPosition in RxSignalGroup Array */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   513  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   514              /* The Buffer into which Signal Values needs to be packed will be available with starting address
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   515               * of the Rx-SignalGroup Array Buffer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   516               * But we have GroupSignal: Bit_Pos, i.e., Signal's actual LSB in the IPdu Buffer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   517               * So, Rx-SignalGroup BitOffset(SigGrpBitOffset) is removed from each of the GroupSignal and
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   518               * is used as BitPosition to pack its value into the Rx-SignalGroup Array Buffer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   519              RelativeSigBitPos = RxGrpSigConstPtr->Bit_Pos - ( Com_BitpositionType )SigGrpBitOffset;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   520  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   521              Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   522                                                RxSigGrpArrayBufRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   523                                                SigValue,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   524                                                RelativeSigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   525                                                RxGrpSigConstPtr->BitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   526                                                SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   527                                                Com_GetValue(RXGRPSIG,_ENDIANESS,RxGrpSigConstPtr->rxGrpSigFields) );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   528          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   529          else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   530  # endif /* #ifdef COM_RX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   531          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   532  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   533  # ifdef COM_RXGRPSIG_FLOAT64SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   534              if(SigType == COM_FLOAT64)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   535              {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   536                  COM_GET_SECRXGRPSIGTYPEFLOAT64_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) =
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   537                                                                        Com_getfloat64InitValue(SigValue);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   538              }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   539              else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   540  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   541  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   542              {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   543                  Com_UpdateRxGroupSignalSecondBuffer(RxGrpSigConstPtr, SigValue, RxMainFuncId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   544              }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   545          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   546  # if defined(COM_RxFilters) && defined(COM_F_MASKEDNEWDIFFERSOLD)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   547          /* [SWS_Com_00603] The AUTOSAR COM module shall set the old_value of the filtering mechanisms
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   548           * for each signal to the ComSignalInitValue during start-up */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   549          if ( ( COM_INIT != Com_Uninit_Flag ) && ( COM_MASKED_NEW_DIFFERS_MASKED_OLD == RxGrpSigConstPtr->Filter_Algo ) )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   550          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   551              COM_GET_F_OLDVALUE(RxGrpSigConstPtr->Filter_Index) = (uint32)SigValue;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   552          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   553  # endif /* # if defined(COM_RxFilters) && defined(COM_F_MASKEDNEWDIFFERSOLD) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   554  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   555          RxGrpSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   556      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   557  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   558  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   559      if ( ConstIsSigGrpOfArrayType_b )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   560      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   561          SchM_Exit_Com_RxSigGrpArrayBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   562      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   563      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   564  # endif /* # ifdef COM_RX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   565      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   566          SchM_Exit_Com_RxGrpSigSecBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   567      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   568  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   569  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   570  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   571  #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   572  #ifdef COM_TxIPduNotification
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   573  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxNotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   574          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   575      Com_TxIpduConstPtrType TxIPduConstPtr;    /* Local pointer to Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   576      Com_TxSigConstPtrType TxSigConstPtr;    /* Local pointer to Tx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   577  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   578      Com_TxSigGrpConstPtrType TxSigGrpConstPtr; /* Local pointer to hold the address of Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   579  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   580      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   581  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   582      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   583      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   584      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   585  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   586      IpduId = COM_GET_TX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   587      TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   588      TxSigConstPtr = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   589  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   590      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(TxIPduConstPtr->FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   591  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   592  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   593      for(index_u8 = TxIPduConstPtr->TxSigId_Index; index_u8 < (TxIPduConstPtr->TxSigId_Index + TxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   594      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   595          if(TxSigConstPtr->Notification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   596          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   597              TxSigConstPtr->Notification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   598          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   599          TxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   600      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   601  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   602      for(index_u8 = TxIPduConstPtr->FirstTxSigGrp_Index; index_u8 < (TxIPduConstPtr->FirstTxSigGrp_Index + TxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   603      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   604          if(TxSigGrpConstPtr->Notification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   605          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   606              TxSigGrpConstPtr->Notification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   607          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   608          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   609      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   610  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   611  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   612          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   613  #endif /* #ifdef COM_TxIPduNotification */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   614  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   615  #ifdef COM_ERRORNOTIFICATION
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   616  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxErrNotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   617  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   618  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   619      Com_TxIpduConstPtrType TxIPduConstPtr;    /* Local pointer to Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   620      Com_TxSigConstPtrType TxSigConstPtr;    /* Local pointer to Tx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   621  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   622      Com_TxSigGrpConstPtrType TxSigGrpConstPtr; /* Local pointer to hold the address of Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   623  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   624      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   625  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   626      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   627      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   628      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   629  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   630      IpduId = COM_GET_TX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   631      TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   632      TxSigConstPtr = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   633  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   634      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(TxIPduConstPtr->FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   635  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   636  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   637      for(index_u8 = TxIPduConstPtr->TxSigId_Index; index_u8 < (TxIPduConstPtr->TxSigId_Index + TxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   638      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   639          if(TxSigConstPtr->NotificationError_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   640          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   641              TxSigConstPtr->NotificationError_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   642          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   643          TxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   644      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   645  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   646      for(index_u8 = TxIPduConstPtr->FirstTxSigGrp_Index; index_u8 < (TxIPduConstPtr->FirstTxSigGrp_Index + TxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   647      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   648          if(TxSigGrpConstPtr->NotificationError_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   649          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   650              TxSigGrpConstPtr->NotificationError_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   651          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   652          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   653      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   654  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   655  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   656  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   657  #endif /* #ifdef COM_ERRORNOTIFICATION */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   658  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   659  #ifdef COM_TxIPduTimeOutNotify
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   660  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxTONotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   661  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   662  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   663      Com_TxIpduConstPtrType TxIPduConstPtr;    /* Local pointer to Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   664      Com_TxSigConstPtrType TxSigConstPtr;    /* Local pointer to Tx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   665  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   666      Com_TxSigGrpConstPtrType TxSigGrpConstPtr; /* Local pointer to hold the address of Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   667  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   668      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   669  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   670      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   671      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   672      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   673  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   674      IpduId = COM_GET_TX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   675      TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   676      TxSigConstPtr = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   677  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   678      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(TxIPduConstPtr->FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   679  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   680  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   681      for(index_u8 = TxIPduConstPtr->TxSigId_Index; index_u8 < (TxIPduConstPtr->TxSigId_Index + TxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   682      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   683          if(TxSigConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   684          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   685              TxSigConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   686          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   687          TxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   688      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   689  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   690      for(index_u8 = TxIPduConstPtr->FirstTxSigGrp_Index; index_u8 < (TxIPduConstPtr->FirstTxSigGrp_Index + TxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   691      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   692          if(TxSigGrpConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   693          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   694              TxSigGrpConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   695          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   696          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   697      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   698  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   699  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   700  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   701  #endif /* #ifdef COM_TxIPduTimeOutNotify */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   702  #ifdef COM_RxIPduTimeoutNotify
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   703  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallRxTONotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   704  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   705  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   706      Com_RxIpduConstPtrType RxIPduConstPtr;    /* Local pointer to Rx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   707      Com_RxSigConstPtrType RxSigConstPtr;    /* Local pointer to Rx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   708  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   709      Com_RxSigGrpConstPtrType RxSigGrpConstPtr; /* Local pointer to hold the address of Rx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   710  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   711      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   712  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   713      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   714      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   715      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   716  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   717      IpduId = COM_GET_RX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   718      RxIPduConstPtr = COM_GET_RX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   719      RxSigConstPtr = COM_GET_RXSIG_CONSTDATA(RxIPduConstPtr->RxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   720  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   721      RxSigGrpConstPtr = COM_GET_RXSIGGRP_CONSTDATA(RxIPduConstPtr->FirstRxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   722  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   723  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   724      for(index_u8 = RxIPduConstPtr->RxSigId_Index; index_u8 < (RxIPduConstPtr->RxSigId_Index + RxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   725      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   726          if(RxSigConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   727          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   728              RxSigConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   729          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   730          RxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   731      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   732  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   733      for(index_u8 = RxIPduConstPtr->FirstRxSigGrp_Index; index_u8 < (RxIPduConstPtr->FirstRxSigGrp_Index + RxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   734      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   735          if(RxSigGrpConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   736          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   737              RxSigGrpConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   738          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   739          RxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   740      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   741  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   742  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   743  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   744  #endif /* #ifdef COM_RxIPduTimeoutNotify */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   745  #endif /* #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   746  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   747  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   748  LOCAL_INLINE FUNC(void, COM_CODE) Com_CopyTxGroupSignalData( Com_SignalIdType    GrpSignalId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   749                                                               Com_SigMaxType      TxGrpSig_NewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   750                                                               Com_MainFuncType    TxMainFuncId )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   751  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   752      Com_TxGrpSigConstPtrType                   TxGrpSigConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   753      VAR(Com_TxGrpSigBuffIndexType, AUTOMATIC)  GrpSigBuff_Index;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   754      VAR(uint8, AUTOMATIC)                      Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   755  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   756      TxGrpSigConstPtr = COM_GET_TXGRPSIG_CONSTDATA(GrpSignalId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   757      GrpSigBuff_Index = TxGrpSigConstPtr->TxGrpSigBuff_Index;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   758      Type = Com_GetValue(TXGRPSIG,_TYPE,TxGrpSigConstPtr->txGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   759  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   760      SchM_Enter_Com_TxGrpSigBuffer();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   761      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   762      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   763  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   764          case 0x00u: /* UINT8 and SINT8 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   765          case 0x03u: /* Boolean type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   766              COM_GET_TXGRPSIGTYPEU8_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint8)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   767              break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   768  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   769          /* UINT16 and SINT16 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   770          case 0x01u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   771              COM_GET_TXGRPSIGTYPEU16_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint16)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   772              break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   773  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   774          /* UINT32,SINT32 and FLOAT32 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   775          case 0x02u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   776          /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   777  #ifdef COM_FLOAT32SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   778          case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   779  #endif /* #ifdef COM_FLOAT32SUPP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   780          /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   781              COM_GET_TXGRPSIGTYPEU32_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint32)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   782              break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   783  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   784          /* UINT64 and SINT64 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   785  #ifdef COM_TXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   786          case 0x08u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   787              COM_GET_TXGRPSIGTYPEU64_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint64)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   788          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   789  #endif /* #ifdef COM_TXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   790  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   791          default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   792              /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   793               * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   794               * allowed to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   795               */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   796          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   797     }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   798      SchM_Exit_Com_TxGrpSigBuffer();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   799  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   800  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   801  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   802  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   803  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   804  #if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   805  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   806  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   807   Function name    : Com_Prv_DETCheck_Void
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   808   Syntax           : boolean Com_Prv_DETCheck_Void(uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   809   Description      : Inline function to check for module initialization
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   810   Parameter        : ApiId - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   811   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   812                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   813   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   814  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Void(uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   815  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   816      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   817      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   818  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   819      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   820      Status  = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   821  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   822      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   823      if (Com_Uninit_Flag == COM_UNINIT)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   824      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   825          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   826          COM_REPORT_ERROR_CHECK(ApiId, COM_E_UNINIT);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   827          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   828          Status = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   829      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   830      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   831      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   832          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   833      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   834  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   835      return Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   836  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   837  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   838  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   839   Function name    : Com_Prv_DETCheck_Param
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   840   Syntax           : boolean Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   841   Description      : Inline function to check for module initialization and valid parameter value.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   842   Parameter        : isInValidParam - calling service is called with invalid parameter value
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   843                      ApiId          - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   844   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   845                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   846   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   847  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   848  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   849      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   850      uint8   ErrorId;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   851      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   852  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   853      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   854      ErrorId = COM_DET_NO_ERROR;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   855      Status  = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   856  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   857      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   858      if (Com_Uninit_Flag == COM_UNINIT)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   859      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   860          ErrorId = COM_E_UNINIT;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   861      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   862      else if (isInValidParam)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   863      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   864          ErrorId = COM_E_PARAM;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   865      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   866      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   867      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   868          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   869      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   870  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   871      /* Check if ErrorId has Error Code */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   872      if (ErrorId != COM_DET_NO_ERROR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   873      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   874          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   875          COM_REPORT_ERROR_CHECK(ApiId, ErrorId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   876          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   877          Status = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   878      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   879      return Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   880  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   881  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   882  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   883   Function name    : Com_Prv_DETCheck_Ptr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   884   Syntax           : boolean Com_Prv_DETCheck_Ptr(boolean isInValidPtr, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   885   Description      : Inline function to check for module initialization and valid pointer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   886   Parameter        : isInValidPtr - calling service is called with invalid pointer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   887                      ApiId        - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   888   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   889                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   890   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   891  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Ptr(boolean isInValidPtr, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   892  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   893      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   894      uint8   ErrorId;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   895      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   896  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   897      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   898      ErrorId = COM_DET_NO_ERROR;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   899      Status  = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   900  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   901      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   902      if (Com_Uninit_Flag == COM_UNINIT)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   903      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   904          ErrorId = COM_E_UNINIT;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   905      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   906      else if (isInValidPtr)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   907      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   908          ErrorId = COM_E_PARAM_POINTER;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   909      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   910      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   911      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   912          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   913      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   914  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   915      /* Check if ErrorId has Error Code */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   916      if (ErrorId != COM_DET_NO_ERROR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   917      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   918          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   919          COM_REPORT_ERROR_CHECK(ApiId, ErrorId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   920          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   921          Status = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   922      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   923      return Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   924  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   925  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   926  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   927   Function name    : Com_Prv_DETCheck_Param_Ptr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   928   Syntax           : boolean Com_Prv_DETCheck_Param_Ptr(boolean isInValidParam, boolean isInValidPtr, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   929   Description      : Inline function to check for module initialization, valid parameter value and valid pointer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   930   Parameter        : isInValidParam - calling service is called with invalid parameter value
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   931                      isInValidPtr   - calling service is called with invalid pointer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   932                      ApiId          - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   933   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   934                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   935   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   936  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Param_Ptr(boolean isInValidParam, boolean isInValidPtr, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   937  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   938      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   939      uint8   ErrorId;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   940      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   941  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   942      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   943      ErrorId = COM_DET_NO_ERROR;
	mov	d7,#255
.L327:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   944      Status  = COM_TRUE;
	mov	d2,#1
.L328:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   945  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   946      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   947      if (Com_Uninit_Flag == COM_UNINIT)
	movh.a	a2,#@his(Com_Uninit_Flag)
	lea	a2,[a2]@los(Com_Uninit_Flag)
	ld.w	d15,[a2]
.L527:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   947      if (Com_Uninit_Flag == COM_UNINIT)      (inlined)
	jne	d15,#0,.L78
.L528:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   948      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   949          ErrorId = COM_E_UNINIT;
	mov	d7,#2
.L529:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   949          ErrorId = COM_E_UNINIT;      (inlined)
	j	.L79

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   947      if (Com_Uninit_Flag == COM_UNINIT)      (inlined)
.L78:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   951      else if (isInValidParam)      (inlined)
	jeq	d0,#0,.L80
.L530:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   950      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   951      else if (isInValidParam)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   952      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   953          ErrorId = COM_E_PARAM;
	mov	d7,#1
.L531:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   953          ErrorId = COM_E_PARAM;      (inlined)
	j	.L81

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   951      else if (isInValidParam)      (inlined)
.L80:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   955      else if (isInValidPtr)      (inlined)
	jeq	d1,#0,.L82
.L532:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   954      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   955      else if (isInValidPtr)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   956      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   957          ErrorId = COM_E_PARAM_POINTER;
	mov	d7,#3
.L533:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   957          ErrorId = COM_E_PARAM_POINTER;      (inlined)
	j	.L83

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   955      else if (isInValidPtr)      (inlined)
.L82:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   959      else      (inlined)
.L83:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   955      else if (isInValidPtr)      (inlined)
.L81:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   951      else if (isInValidParam)      (inlined)
.L79:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   958      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   959      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   960      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   961          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   962      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   963  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   964      /* Check if ErrorId has Error Code */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   965      if (ErrorId != COM_DET_NO_ERROR)
	mov	d15,#255
.L534:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   965      if (ErrorId != COM_DET_NO_ERROR)      (inlined)
	jeq	d15,d7,.L84
.L535:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   966      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   967          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   968          COM_REPORT_ERROR_CHECK(ApiId, ErrorId);
	mov	d4,#50
.L320:
	mov	d5,#0
.L321:
	call	Det_ReportError
.L322:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   969          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   970          Status = COM_FALSE;
	mov	d2,#0

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   965      if (ErrorId != COM_DET_NO_ERROR)      (inlined)
.L84:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   972      return Status;      (inlined)
	j	.L85

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   973  }      (inlined)
.L85:
	jeq	d2,#0,.L86
.L252:
	sha	d0,d8,#-3
.L330:
	extr.u	d15,d8,#0,#8
.L329:
	and	d15,#7
.L536:
	mov	d1,#1
.L537:
	sh	d1,d1,d15
.L538:
	addsc.a	a15,a15,d0,#0
.L324:
	ld.bu	d15,[a15]
.L332:
	jeq	d9,#0,.L87
.L333:
	or	d15,d1
	st.b	[a15],d15
.L539:
	j	.L88
.L87:
	xor	d0,d1,#255
.L331:
	and	d15,d0
	st.b	[a15],d15
.L88:
.L86:
	ret
.L246:
	
__Com_SetIpduGroup_function_end:
	.size	Com_SetIpduGroup,__Com_SetIpduGroup_function_end-Com_SetIpduGroup
.L113:
	; End of function
	
	.calls	'Com_IpduGroupControl','Det_ReportError'
	.calls	'Com_IpduGroupControl','Com_ReceptionDMControl'
	.calls	'Com_IpduGroupControl','Com_TxChangeMode'
	.calls	'Com_IpduGroupControl','Com_TxIPduStop'
	.calls	'Com_ClearIpduGroupVector','Det_ReportError'
	.calls	'Com_SetIpduGroup','Det_ReportError'
	.calls	'Com_IpduGroupControl','',0
	.calls	'Com_ClearIpduGroupVector','',0
	.extern	Com_ReceptionDMControl
	.extern	Det_ReportError
	.extern	Com_TxChangeMode
	.extern	Com_TxIPduStop
	.extern	Com_Uninit_Flag
	.extern	Com_RxIpduRam_s
	.extern	Com_TxIpduRam_s
	.extern	Com_IpduCounter_s
	.extern	Com_IpduGrpVector
	.extern	Com_Prv_xTxIpduCfg_acst
	.extern	Com_Prv_xIpduGrpCfg_acst
	.extern	Com_Prv_xIPduGrp_IpduRefCfg_au8
	.calls	'Com_SetIpduGroup','',0
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L96:
	.word	14754
	.half	3
	.word	.L97
	.byte	4
.L95:
	.byte	1
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_IpduGroupStart.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L98
.L117:
	.byte	2
	.byte	'unsigned char',0,1,8
.L145:
	.byte	2
	.byte	'unsigned short int',0,2,7
.L177:
	.byte	3
	.byte	'Bfx_Prv_GetBit_u16u8_u8_Inl',0,3,1,207,2,22
	.word	144
	.byte	1,1
.L179:
	.byte	4
	.byte	'Data',0,1,207,2,57
	.word	161
.L181:
	.byte	4
	.byte	'BitPn',0,1,207,2,69
	.word	144
.L183:
	.byte	5,0,2
	.byte	'unsigned int',0,4,7,3
	.byte	'Bfx_Prv_GetBit_u32u8_u8_Inl',0,3,1,227,2,22
	.word	144
	.byte	1,1,4
	.byte	'Data',0,1,227,2,57
	.word	254
	.byte	4
	.byte	'BitPn',0,1,227,2,69
	.word	144
	.byte	5,0
.L152:
	.byte	3
	.byte	'Bfx_Prv_GetBit_u8u8_u8_Inl',0,3,1,247,2,22
	.word	144
	.byte	1,1
.L154:
	.byte	4
	.byte	'Data',0,1,247,2,55
	.word	144
.L156:
	.byte	4
	.byte	'BitPn',0,1,247,2,67
	.word	144
.L158:
	.byte	5,0
.L195:
	.byte	3
	.byte	'Bfx_Prv_GetBits_u8u8u8_u8_Inl',0,3,1,179,3,20
	.word	144
	.byte	1,1
.L197:
	.byte	4
	.byte	'Data',0,1,179,3,56
	.word	144
.L199:
	.byte	4
	.byte	'BitStartPn',0,1,179,3,68
	.word	144
.L201:
	.byte	4
	.byte	'BitLn',0,1,179,3,86
	.word	144
.L203:
	.byte	5,0,6
	.word	161
.L204:
	.byte	7
	.byte	'Bfx_Prv_PutBit_u16u8u8_Inl',0,3,1,200,3,19,1,1
.L207:
	.byte	4
	.byte	'Data',0,1,200,3,54
	.word	504
.L209:
	.byte	4
	.byte	'BitPn',0,1,200,3,66
	.word	144
.L211:
	.byte	4
	.byte	'Value',0,1,200,3,81
	.word	144
.L213:
	.byte	5,0,6
	.word	254
	.byte	7
	.byte	'Bfx_Prv_PutBit_u32u8u8_Inl',0,3,1,224,3,19,1,1,4
	.byte	'Data',0,1,224,3,54
	.word	590
	.byte	4
	.byte	'BitPn',0,1,224,3,66
	.word	144
	.byte	4
	.byte	'Value',0,1,224,3,81
	.word	144
	.byte	5,0,6
	.word	144
.L159:
	.byte	7
	.byte	'Bfx_Prv_PutBit_u8u8u8_Inl',0,3,1,248,3,19,1,1
.L161:
	.byte	4
	.byte	'Data',0,1,248,3,52
	.word	676
.L163:
	.byte	4
	.byte	'BitPn',0,1,248,3,64
	.word	144
.L165:
	.byte	4
	.byte	'Value',0,1,248,3,79
	.word	144
.L167:
	.byte	5,0,3
	.byte	'Bfx_Prv_TstParityEven_u32_u8_Inl',0,3,1,143,10,22
	.word	144
	.byte	1,1,4
	.byte	'Data',0,1,143,10,62
	.word	254
	.byte	5,0
.L125:
	.byte	3
	.byte	'Com_Prv_DETCheck_Ptr',0,3,2,251,6,37
	.word	144
	.byte	1,1
.L128:
	.byte	4
	.byte	'isInValidPtr',0,2,251,6,66
	.word	144
.L130:
	.byte	4
	.byte	'ApiId',0,2,251,6,86
	.word	144
.L132:
	.byte	5,0
.L250:
	.byte	3
	.byte	'Com_Prv_DETCheck_Param_Ptr',0,3,2,168,7,37
	.word	144
	.byte	1,1
.L253:
	.byte	4
	.byte	'isInValidParam',0,2,168,7,72
	.word	144
.L255:
	.byte	4
	.byte	'isInValidPtr',0,2,168,7,96
	.word	144
.L257:
	.byte	4
	.byte	'ApiId',0,2,168,7,116
	.word	144
.L259:
	.byte	5,0
.L184:
	.byte	7
	.byte	'Com_TxIPduStart',0,3,3,185,2,36,1,1
.L186:
	.byte	4
	.byte	'IpduId',0,3,185,2,83
	.word	144
.L188:
	.byte	4
	.byte	'Initialize',0,3,186,2,76
	.word	144
.L190:
	.byte	8,5,5,5,5,5,5,5,5,0,0,9
	.word	144
	.byte	6
	.word	1067
.L135:
	.byte	7
	.byte	'Com_Prv_ProcessIPduGroupVector',0,3,3,151,1,35,1,1
.L138:
	.byte	4
	.byte	'ipduGroupVector',0,3,152,1,86
	.word	1072
.L140:
	.byte	5,0
.L115:
	.byte	6
	.word	144
	.byte	10,4,218,9,9,6,11
	.byte	'RxIPduLength',0
	.word	161
	.byte	2,2,35,0,11
	.byte	'RxTicks_u16',0
	.word	161
	.byte	2,2,35,2,11
	.byte	'RxFlags',0
	.word	144
	.byte	1,2,35,4,0,6
	.word	1148
	.byte	6
	.word	1148
.L119:
	.byte	12
	.byte	'Com_RxIpduRamPtrType',0,4,254,9,62
	.word	1220
	.byte	10,4,76,9,8,11
	.byte	'TimePeriodFact',0
	.word	161
	.byte	2,2,35,0,11
	.byte	'TimeOffsetFact',0
	.word	161
	.byte	2,2,35,2,11
	.byte	'RepetitionPeriodFact',0
	.word	161
	.byte	2,2,35,4,11
	.byte	'NumOfRepetitions',0
	.word	144
	.byte	1,2,35,6,11
	.byte	'Mode',0
	.word	144
	.byte	1,2,35,7,0,9
	.word	1255
	.byte	6
	.word	1379
	.byte	12
	.byte	'Com_TMConstPtrType',0,4,103,65
	.word	1384
	.byte	10,4,135,9,9,16,11
	.byte	'CurrentTxModePtr',0
	.word	1389
	.byte	4,2,35,0,11
	.byte	'Com_MinDelayTick',0
	.word	161
	.byte	2,2,35,4,11
	.byte	'Com_Tick_Tx',0
	.word	161
	.byte	2,2,35,6,11
	.byte	'Com_n_Tick_Tx',0
	.word	161
	.byte	2,2,35,8,11
	.byte	'Com_TickTxTimeout',0
	.word	161
	.byte	2,2,35,10,11
	.byte	'Com_TxFlags',0
	.word	161
	.byte	2,2,35,12,11
	.byte	'Com_n',0
	.word	144
	.byte	1,2,35,14,11
	.byte	'Com_TransMode',0
	.word	144
	.byte	1,2,35,15,0,6
	.word	1416
	.byte	9
	.word	1255
	.byte	6
	.word	1610
	.byte	6
	.word	1416
.L121:
	.byte	12
	.byte	'Com_TxIpduRamPtrType',0,4,198,9,62
	.word	1620
.L123:
	.byte	2
	.byte	'unsigned long int',0,4,7,9
	.word	144
.L141:
	.byte	6
	.word	1676
	.byte	10,4,219,7,9,4,11
	.byte	'FirstIpdu_Index',0
	.word	161
	.byte	2,2,35,0,11
	.byte	'NoOfRxPdus',0
	.word	161
	.byte	2,2,35,2,0,9
	.word	1686
	.byte	6
	.word	1738
	.byte	9
	.word	1686
	.byte	6
	.word	1748
.L143:
	.byte	12
	.byte	'Com_IPduGrpConstPtrType',0,4,233,7,73
	.word	1753
	.byte	10,4,211,5,9,24,11
	.byte	'BuffPtr',0
	.word	676
	.byte	4,2,35,0,11
	.byte	'Com_TMConstPtr',0
	.word	1384
	.byte	4,2,35,4,11
	.byte	'Size',0
	.word	161
	.byte	2,2,35,8,11
	.byte	'Timeout_Fact',0
	.word	161
	.byte	2,2,35,10,11
	.byte	'Min_Delay_Time_Fact',0
	.word	161
	.byte	2,2,35,12,11
	.byte	'No_Of_Sig_Ref',0
	.word	161
	.byte	2,2,35,14,11
	.byte	'PdurId',0
	.word	161
	.byte	2,2,35,16,11
	.byte	'TxSigId_Index',0
	.word	144
	.byte	1,2,35,18,11
	.byte	'txIPduFields',0
	.word	161
	.byte	2,2,35,20,11
	.byte	'MainFunctionRef',0
	.word	144
	.byte	1,2,35,22,11
	.byte	'PaddingByte',0
	.word	144
	.byte	1,2,35,23,0,9
	.word	1791
	.byte	6
	.word	2034
	.byte	9
	.word	1791
	.byte	6
	.word	2044
.L191:
	.byte	12
	.byte	'Com_TxIpduConstPtrType',0,4,171,6,72
	.word	2049
	.byte	13
	.byte	'Com_ReceptionDMControl',0,5,197,3,29,1,1,1,1,4
	.byte	'ipduGroupVector',0,5,197,3,89
	.word	1143
	.byte	0,14
	.byte	'Det_ReportError',0,6,112,16
	.word	144
	.byte	1,1,1,1,4
	.byte	'ModuleId',0,6,112,39
	.word	161
	.byte	4
	.byte	'InstanceId',0,6,112,55
	.word	144
	.byte	4
	.byte	'ApiId',0,6,112,73
	.word	144
	.byte	4
	.byte	'ErrorId',0,6,112,86
	.word	144
	.byte	0,15
	.word	183
	.byte	16
	.word	223
	.byte	16
	.word	237
	.byte	5,0,15
	.word	270
	.byte	16
	.word	310
	.byte	16
	.word	324
	.byte	5,0,15
	.word	341
	.byte	16
	.word	380
	.byte	16
	.word	394
	.byte	5,0,15
	.word	411
	.byte	16
	.word	453
	.byte	16
	.word	467
	.byte	16
	.word	487
	.byte	5,0,15
	.word	509
	.byte	16
	.word	544
	.byte	16
	.word	558
	.byte	16
	.word	573
	.byte	5,0,15
	.word	595
	.byte	16
	.word	630
	.byte	16
	.word	644
	.byte	16
	.word	659
	.byte	5,0,15
	.word	681
	.byte	16
	.word	715
	.byte	16
	.word	729
	.byte	16
	.word	744
	.byte	5,0,15
	.word	761
	.byte	16
	.word	806
	.byte	5,0,13
	.byte	'Com_TxChangeMode',0,7,142,22,21,1,1,1,1,4
	.byte	'TxIpduId',0,7,142,22,69
	.word	144
	.byte	0,13
	.byte	'Com_TxIPduStop',0,7,239,22,22,1,1,1,1,4
	.byte	'IpduId',0,7,239,22,68
	.word	144
	.byte	0,15
	.word	822
	.byte	16
	.word	855
	.byte	16
	.word	877
	.byte	5,0,15
	.word	894
	.byte	16
	.word	933
	.byte	16
	.word	957
	.byte	16
	.word	979
	.byte	5,0,15
	.word	996
	.byte	16
	.word	1020
	.byte	16
	.word	1036
	.byte	8,17
	.word	183
	.byte	16
	.word	223
	.byte	16
	.word	237
	.byte	18
	.word	252
	.byte	0,5,17
	.word	183
	.byte	16
	.word	223
	.byte	16
	.word	237
	.byte	18
	.word	252
	.byte	0,5,17
	.word	411
	.byte	16
	.word	453
	.byte	16
	.word	467
	.byte	16
	.word	487
	.byte	18
	.word	502
	.byte	0,5,17
	.word	509
	.byte	16
	.word	544
	.byte	16
	.word	558
	.byte	16
	.word	573
	.byte	18
	.word	588
	.byte	0,5,17
	.word	509
	.byte	16
	.word	544
	.byte	16
	.word	558
	.byte	16
	.word	573
	.byte	18
	.word	588
	.byte	0,5,17
	.word	509
	.byte	16
	.word	544
	.byte	16
	.word	558
	.byte	16
	.word	573
	.byte	18
	.word	588
	.byte	0,5,17
	.word	509
	.byte	16
	.word	544
	.byte	16
	.word	558
	.byte	16
	.word	573
	.byte	18
	.word	588
	.byte	0,5,17
	.word	509
	.byte	16
	.word	544
	.byte	16
	.word	558
	.byte	16
	.word	573
	.byte	18
	.word	588
	.byte	0,5,0,0,15
	.word	1077
	.byte	16
	.word	1116
	.byte	5,0,19,1,6
	.word	2751
	.byte	12
	.byte	'__codeptr',0,3,1,1
	.word	2753
	.byte	2
	.byte	'char',0,1,6,12
	.byte	'sint8',0,8,76,25
	.word	2776
	.byte	12
	.byte	'uint8',0,8,81,25
	.word	144
	.byte	12
	.byte	'uint16',0,8,91,25
	.word	161
	.byte	12
	.byte	'uint32',0,8,106,24
	.word	254
	.byte	2
	.byte	'unsigned long long int',0,8,7,12
	.byte	'uint64',0,8,111,30
	.word	2842
	.byte	12
	.byte	'boolean',0,8,127,25
	.word	144
	.byte	12
	.byte	'StatusType',0,9,191,1,27
	.word	144
	.byte	12
	.byte	'Std_ReturnType',0,9,199,1,15
	.word	144
	.byte	10,9,206,1,9,8,11
	.byte	'vendorID',0
	.word	161
	.byte	2,2,35,0,11
	.byte	'moduleID',0
	.word	161
	.byte	2,2,35,2,11
	.byte	'sw_major_version',0
	.word	144
	.byte	1,2,35,4,11
	.byte	'sw_minor_version',0
	.word	144
	.byte	1,2,35,5,11
	.byte	'sw_patch_version',0
	.word	144
	.byte	1,2,35,6,0,12
	.byte	'Std_VersionInfoType',0,9,213,1,3
	.word	2943
	.byte	12
	.byte	'PduIdType',0,10,22,19
	.word	161
	.byte	12
	.byte	'PduLengthType',0,10,26,19
	.word	161
	.byte	20,11,113,9,4,21
	.byte	'TP_DATACONF',0,0,21
	.byte	'TP_DATARETRY',0,1,21
	.byte	'TP_CONFPENDING',0,2,0,12
	.byte	'TpDataStateType',0,11,118,3
	.word	3133
	.byte	12
	.byte	'Com_SignalIdType',0,12,100,16
	.word	161
	.byte	12
	.byte	'Com_SignalGroupIdType',0,12,102,16
	.word	161
	.byte	12
	.byte	'Com_IpduIdType',0,12,104,15
	.word	144
	.byte	12
	.byte	'Com_GrpSignalIdType',0,12,107,18
	.word	144
	.byte	12
	.byte	'Com_IpduGroupIdType',0,12,110,16
	.word	161
	.byte	22,1
	.word	144
	.byte	23,0,0,12
	.byte	'Com_IpduGroupVector',0,12,112,15
	.word	3343
	.byte	20,12,117,9,4,21
	.byte	'COM_UNINIT',0,0,21
	.byte	'COM_INIT',0,1,0,12
	.byte	'Com_StatusType',0,12,121,2
	.word	3380
	.byte	12
	.byte	'Com_TxIntSignalIdType',0,13,138,3,18
	.word	144
	.byte	12
	.byte	'Com_RxIntSignalIdType',0,13,139,3,18
	.word	144
	.byte	12
	.byte	'Com_BitsizeType',0,13,155,3,17
	.word	144
	.byte	12
	.byte	'Com_BitpositionType',0,13,156,3,15
	.word	144
	.byte	12
	.byte	'Com_RxGwQueueIndexType',0,13,161,3,15
	.word	144
	.byte	12
	.byte	'Com_SigBuffIndexType',0,13,164,3,15
	.word	144
	.byte	12
	.byte	'Com_SigMaxType',0,13,198,3,16
	.word	254
	.byte	12
	.byte	'Com_MainFuncType',0,13,231,3,16
	.word	144
	.byte	12
	.byte	'Com_NumOfIpdusType',0,13,233,3,15
	.word	144
	.byte	12
	.byte	'Com_TimeBaseType',0,13,235,3,15
	.word	144
	.byte	12
	.byte	'Can_IdType',0,14,32,16
	.word	254
	.byte	12
	.byte	'Can_HwHandleType',0,14,43,16
	.word	161
	.byte	10,15,93,9,8,11
	.byte	'Class',0
	.word	144
	.byte	1,2,35,0,11
	.byte	'TIN',0
	.word	144
	.byte	1,2,35,1,11
	.byte	'ReturnAddress',0
	.word	254
	.byte	4,2,35,4,0,12
	.byte	'OsTrapInfoType',0,15,97,3
	.word	3759
	.byte	22,68
	.word	254
	.byte	23,16,0,10,15,154,1,9,68,11
	.byte	'store',0
	.word	3839
	.byte	68,2,35,0,0,22,68
	.word	3848
	.byte	23,0,0,12
	.byte	'Os_JumpBufType',0,15,156,1,3
	.word	3870
	.byte	12
	.byte	'Os_StackTraceType',0,15,174,1,18
	.word	254
	.byte	10,15,175,1,9,8,11
	.byte	'sp',0
	.word	254
	.byte	4,2,35,0,11
	.byte	'ctx',0
	.word	254
	.byte	4,2,35,4,0,12
	.byte	'Os_StackValueType',0,15,175,1,63
	.word	3930
	.byte	12
	.byte	'Os_StackSizeType',0,15,176,1,27
	.word	3930
	.byte	24,1,1,6
	.word	4015
	.byte	12
	.byte	'Os_VoidVoidFunctionType',0,15,179,1,16
	.word	4018
	.byte	12
	.byte	'ApplicationType',0,15,193,1,23
	.word	144
	.byte	25
	.byte	'Os_ApplicationConfigurationType_s',0,15,198,1,16,2,11
	.byte	'app_id',0
	.word	144
	.byte	1,2,35,0,11
	.byte	'access',0
	.word	144
	.byte	1,2,35,1,0,12
	.byte	'Os_ApplicationConfigurationType',0,15,201,1,3
	.word	4081
	.byte	12
	.byte	'Os_CoreStateType',0,15,203,1,16
	.word	254
	.byte	12
	.byte	'AreaIdType',0,15,204,1,16
	.word	161
	.byte	12
	.byte	'Os_PeripheralAddressType',0,15,212,1,22
	.word	254
	.byte	12
	.byte	'TickType',0,15,221,1,22
	.word	254
	.byte	12
	.byte	'Os_StopwatchTickType',0,15,225,1,22
	.word	254
	.byte	12
	.byte	'Os_Lockable',0,15,234,1,18
	.word	590
	.byte	12
	.byte	'CoreIdType',0,15,236,1,16
	.word	161
	.byte	12
	.byte	'SpinlockIdType',0,15,237,1,16
	.word	161
	.byte	20,15,239,1,9,4,21
	.byte	'TRYTOGETSPINLOCK_SUCCESS',0,0,21
	.byte	'TRYTOGETSPINLOCK_NOSUCCESS',0,1,0,12
	.byte	'TryToGetSpinlockType',0,15,239,1,74
	.word	4388
	.byte	20,15,174,2,9,4,21
	.byte	'APPLICATION_ACCESSIBLE',0,0,21
	.byte	'APPLICATION_RESTARTING',0,1,21
	.byte	'APPLICATION_TERMINATED',0,2,0,12
	.byte	'ApplicationStateType',0,15,174,2,92
	.word	4481
	.byte	26
	.byte	'void',0,6
	.word	4593
	.byte	27,1,1,28
	.word	144
	.byte	28
	.word	4599
	.byte	0,6
	.word	4604
	.byte	12
	.byte	'Os_FunctionEntryType',0,15,183,2,16
	.word	4618
	.byte	25
	.byte	'Os_MeterInfoType_s',0,15,193,2,16,48,11
	.byte	'elapsed',0
	.word	254
	.byte	4,2,35,0,11
	.byte	'previous',0
	.word	254
	.byte	4,2,35,4,11
	.byte	'max',0
	.word	254
	.byte	4,2,35,8,11
	.byte	'cumulative',0
	.word	254
	.byte	4,2,35,12,11
	.byte	'stackbase',0
	.word	3930
	.byte	8,2,35,16,11
	.byte	'stackusage',0
	.word	3930
	.byte	8,2,35,24,11
	.byte	'stackmax',0
	.word	3930
	.byte	8,2,35,32,11
	.byte	'stackbudget',0
	.word	3930
	.byte	8,2,35,40,0,12
	.byte	'Os_MeterInfoType',0,15,202,2,3
	.word	4653
	.byte	6
	.word	4653
	.byte	12
	.byte	'Os_MeterInfoRefType',0,15,203,2,50
	.word	4851
	.byte	12
	.byte	'EventMaskType',0,15,206,2,15
	.word	144
	.byte	12
	.byte	'Os_imaskType',0,15,211,2,16
	.word	254
	.byte	25
	.byte	'Os_ISRDynType_s',0,15,213,2,16,48,11
	.byte	'meter',0
	.word	4653
	.byte	48,2,35,0,0,12
	.byte	'Os_ISRDynType',0,15,215,2,3
	.word	4930
	.byte	6
	.word	4930
	.byte	9
	.word	4991
	.byte	25
	.byte	'Os_ISRType_s',0,15,216,2,16,24,11
	.byte	'entry_function',0
	.word	4023
	.byte	4,2,35,0,11
	.byte	'dynamic',0
	.word	4996
	.byte	4,2,35,4,11
	.byte	'imask',0
	.word	254
	.byte	4,2,35,8,11
	.byte	'stackbudget',0
	.word	3930
	.byte	8,2,35,12,11
	.byte	'access',0
	.word	144
	.byte	1,2,35,20,11
	.byte	'application',0
	.word	144
	.byte	1,2,35,21,0,12
	.byte	'Os_ISRType',0,15,223,2,3
	.word	5001
	.byte	6
	.word	4015
	.byte	9
	.word	5001
	.byte	6
	.word	5160
	.byte	12
	.byte	'ISRType',0,15,224,2,46
	.word	5165
	.byte	12
	.byte	'Os_bitmask',0,15,239,2,22
	.word	254
	.byte	12
	.byte	'Os_pset0Type',0,15,240,2,20
	.word	254
	.byte	12
	.byte	'Os_pset1Type',0,15,241,2,20
	.word	254
	.byte	12
	.byte	'Os_pset2Type',0,15,242,2,20
	.word	254
	.byte	29,15,243,2,9,4,11
	.byte	'p0',0
	.word	254
	.byte	4,2,35,0,11
	.byte	'p1',0
	.word	254
	.byte	4,2,35,0,11
	.byte	'p2',0
	.word	254
	.byte	4,2,35,0,0,12
	.byte	'Os_psetType',0,15,247,2,3
	.word	5273
	.byte	29,15,249,2,9,4,11
	.byte	't0',0
	.word	254
	.byte	4,2,35,0,11
	.byte	't1',0
	.word	254
	.byte	4,2,35,0,11
	.byte	't2',0
	.word	254
	.byte	4,2,35,0,0,12
	.byte	'Os_tpmaskType',0,15,253,2,3
	.word	5337
	.byte	12
	.byte	'Os_ActivationCountType',0,15,254,2,23
	.word	144
	.byte	25
	.byte	'Os_TaskDynType_s',0,15,128,3,16,120,11
	.byte	'terminate_jump_buf',0
	.word	3879
	.byte	68,2,35,0,11
	.byte	'meter',0
	.word	4653
	.byte	48,2,35,68,11
	.byte	'activation_count',0
	.word	144
	.byte	1,2,35,116,0,12
	.byte	'Os_TaskDynType',0,15,132,3,3
	.word	5435
	.byte	22,68
	.word	3848
	.byte	23,0,0,6
	.word	5435
	.byte	9
	.word	5561
	.byte	25
	.byte	'Os_TaskType_s',0,15,134,3,16,40,11
	.byte	'dynamic',0
	.word	5566
	.byte	4,2,35,0,11
	.byte	'entry_function',0
	.word	4023
	.byte	4,2,35,4,11
	.byte	'pset',0
	.word	5273
	.byte	4,2,35,8,11
	.byte	'base_tpmask',0
	.word	5337
	.byte	4,2,35,12,11
	.byte	'tpmask',0
	.word	5337
	.byte	4,2,35,16,11
	.byte	'core_id',0
	.word	161
	.byte	2,2,35,20,11
	.byte	'index',0
	.word	254
	.byte	4,2,35,24,11
	.byte	'stackbudget',0
	.word	3930
	.byte	8,2,35,28,11
	.byte	'activation_count',0
	.word	144
	.byte	1,2,35,36,11
	.byte	'access',0
	.word	144
	.byte	1,2,35,37,11
	.byte	'application',0
	.word	144
	.byte	1,2,35,38,0,12
	.byte	'Os_TaskType',0,15,146,3,3
	.word	5571
	.byte	9
	.word	5571
	.byte	6
	.word	5821
	.byte	12
	.byte	'TaskType',0,15,147,3,47
	.word	5826
	.byte	30
	.byte	'Os_TaskStateType',0,15,155,3,6,4,21
	.byte	'SUSPENDED',0,0,21
	.byte	'READY',0,1,21
	.byte	'WAITING',0,2,21
	.byte	'RUNNING',0,3,0,12
	.byte	'TaskStateType',0,15,156,3,31
	.word	5849
	.byte	29,15,167,3,3,4,11
	.byte	'tpmask',0
	.word	5337
	.byte	4,2,35,0,0,25
	.byte	'Os_ResourceDynType_s',0,15,166,3,16,4,11
	.byte	'saved_priority',0
	.word	5936
	.byte	4,2,35,0,0,12
	.byte	'Os_ResourceDynType',0,15,170,3,3
	.word	5959
	.byte	6
	.word	5959
	.byte	9
	.word	6039
	.byte	25
	.byte	'Os_ResourceType_s',0,15,171,3,16,12,11
	.byte	'dynamic',0
	.word	6044
	.byte	4,2,35,0,11
	.byte	'tpmask',0
	.word	5337
	.byte	4,2,35,4,11
	.byte	'access',0
	.word	144
	.byte	1,2,35,8,0,12
	.byte	'Os_ResourceType',0,15,175,3,3
	.word	6049
	.byte	10,15,181,3,9,12,11
	.byte	'maxallowedvalue',0
	.word	254
	.byte	4,2,35,0,11
	.byte	'ticksperbase',0
	.word	254
	.byte	4,2,35,4,11
	.byte	'mincycle',0
	.word	254
	.byte	4,2,35,8,0,12
	.byte	'AlarmBaseType',0,15,185,3,3
	.word	6148
	.byte	10,15,206,3,9,8,11
	.byte	'Running',0
	.word	144
	.byte	1,2,35,0,11
	.byte	'Pending',0
	.word	144
	.byte	1,2,35,1,11
	.byte	'Delay',0
	.word	254
	.byte	4,2,35,4,0,12
	.byte	'Os_CounterStatusType',0,15,210,3,3
	.word	6243
	.byte	31
	.word	144
	.byte	1,1,6
	.word	6329
	.byte	12
	.byte	'Os_CounterIncrAdvType',0,15,217,3,22
	.word	6336
	.byte	25
	.byte	's_swd',0,15,222,3,12,4,11
	.byte	'count',0
	.word	254
	.byte	4,2,35,0,0,29,15,221,3,3,4,11
	.byte	'sw',0
	.word	6372
	.byte	4,2,35,0,0,25
	.byte	'Os_CounterDynType_s',0,15,220,3,16,4,11
	.byte	'type_dependent',0
	.word	6400
	.byte	4,2,35,0,0,12
	.byte	'Os_CounterDynType',0,15,226,3,3
	.word	6419
	.byte	6
	.word	6419
	.byte	9
	.word	6497
	.byte	25
	.byte	'Os_CounterType_s',0,15,227,3,16,28,11
	.byte	'dynamic',0
	.word	6502
	.byte	4,2,35,0,11
	.byte	'advincr',0
	.word	6341
	.byte	4,2,35,4,11
	.byte	'base',0
	.word	6148
	.byte	12,2,35,8,11
	.byte	'core',0
	.word	4599
	.byte	4,2,35,20,11
	.byte	'access',0
	.word	144
	.byte	1,2,35,24,11
	.byte	'application',0
	.word	144
	.byte	1,2,35,25,0,12
	.byte	'Os_CounterType',0,15,234,3,3
	.word	6507
	.byte	6
	.word	6329
	.byte	9
	.word	6507
	.byte	6
	.word	6659
	.byte	12
	.byte	'CounterType',0,15,235,3,52
	.word	6664
	.byte	30
	.byte	'Os_ScheduleTableStatusType',0,15,240,3,6,4,21
	.byte	'SCHEDULETABLE_STOPPED',0,0,21
	.byte	'SCHEDULETABLE_NEXT',0,1,21
	.byte	'SCHEDULETABLE_WAITING',0,2,21
	.byte	'SCHEDULETABLE_RUNNING',0,3,21
	.byte	'SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS',0,4,0,12
	.byte	'ScheduleTableStatusType',0,15,241,3,41
	.word	6690
	.byte	9
	.word	.L334-.L96
	.byte	6
	.word	6890
	.byte	12
	.byte	'ScheduleTableType',0,15,128,4,58
	.word	6895
	.byte	25
	.byte	'Os_ScheduleTableDynType_s',0,15,130,4,16,16,11
	.byte	'match',0
	.word	254
	.byte	4,2,35,0,11
	.byte	'next',0
	.word	6900
	.byte	4,2,35,4,11
	.byte	'state',0
	.word	6690
	.byte	4,2,35,8,11
	.byte	'config',0
	.word	161
	.byte	2,2,35,12,0,6
	.word	6927
	.byte	9
	.word	7020
.L334:
	.byte	25
	.byte	'Os_ScheduleTableType_s',0,15,247,3,16,16,11
	.byte	'dynamic',0
	.word	7025
	.byte	4,2,35,0,11
	.byte	'counter',0
	.word	6669
	.byte	4,2,35,4,11
	.byte	'repeat',0
	.word	144
	.byte	1,2,35,8,11
	.byte	'config',0
	.word	161
	.byte	2,2,35,10,11
	.byte	'initial',0
	.word	144
	.byte	1,2,35,12,11
	.byte	'access',0
	.word	144
	.byte	1,2,35,13,11
	.byte	'application',0
	.word	144
	.byte	1,2,35,14,0,12
	.byte	'Os_ScheduleTableType',0,15,255,3,3
	.word	7030
	.byte	9
	.word	7030
	.byte	6
	.word	7210
	.byte	9
	.word	6507
	.byte	6
	.word	7220
	.byte	32
	.word	4323
	.byte	32
	.word	5273
	.byte	32
	.word	5170
	.byte	32
	.word	5831
	.byte	32
	.word	5337
	.byte	32
	.word	144
	.byte	32
	.word	5831
	.byte	25
	.byte	'Os_ControlledCoreType_s',0,15,251,6,16,112,11
	.byte	'TrapInfo',0
	.word	3759
	.byte	8,2,35,0,11
	.byte	'lock_taskaccess',0
	.word	7230
	.byte	4,2,35,8,11
	.byte	'ReadyTasks',0
	.word	7235
	.byte	4,2,35,12,11
	.byte	'RunningISR',0
	.word	7240
	.byte	4,2,35,16,11
	.byte	'RunningTask',0
	.word	7245
	.byte	4,2,35,20,11
	.byte	'RunningTPMask',0
	.word	7250
	.byte	4,2,35,24,11
	.byte	'CurrentMeteredObject',0
	.word	4856
	.byte	4,2,35,28,11
	.byte	'IdleMeter',0
	.word	4653
	.byte	48,2,35,32,11
	.byte	'AppAccess',0
	.word	144
	.byte	1,2,35,80,11
	.byte	'AppOverride',0
	.word	7255
	.byte	1,2,35,81,11
	.byte	'GetStackValueAdjust',0
	.word	3930
	.byte	8,2,35,84,11
	.byte	'InErrorHook',0
	.word	144
	.byte	1,2,35,92,11
	.byte	'ChainTaskRef',0
	.word	7260
	.byte	4,2,35,96,11
	.byte	'GetStackUsageAdjust',0
	.word	3930
	.byte	8,2,35,100,11
	.byte	'InProtectionHook',0
	.word	144
	.byte	1,2,35,108,11
	.byte	'CoreIsActive',0
	.word	144
	.byte	1,2,35,109,11
	.byte	'InShutdownHook',0
	.word	144
	.byte	1,2,35,110,0,12
	.byte	'Os_ControlledCoreType',0,15,141,7,3
	.word	7265
	.byte	6
	.word	254
	.byte	9
	.word	5001
	.byte	6
	.word	7721
	.byte	9
	.word	5571
	.byte	6
	.word	7731
	.byte	6
	.word	4653
	.byte	25
	.byte	'Os_AnyCoreType_s',0,15,151,7,16,96,11
	.byte	'DisableAllImask',0
	.word	254
	.byte	4,2,35,0,11
	.byte	'SuspendAllImask',0
	.word	254
	.byte	4,2,35,4,11
	.byte	'SuspendOSImask',0
	.word	254
	.byte	4,2,35,8,11
	.byte	'DisableAllCount',0
	.word	254
	.byte	4,2,35,12,11
	.byte	'SuspendAllCount',0
	.word	254
	.byte	4,2,35,16,11
	.byte	'SuspendOSCount',0
	.word	254
	.byte	4,2,35,20,11
	.byte	'RestartJumpBuf',0
	.word	3879
	.byte	68,2,35,24,11
	.byte	'Restartable',0
	.word	144
	.byte	1,2,35,92,0,12
	.byte	'Os_AnyCoreType',0,15,160,7,3
	.word	7746
	.byte	12
	.byte	'Can_TxObjPriorityClassType',0,16,219,3,16
	.word	254
	.byte	25
	.byte	'Can_TxHwObjectConfigType',0,16,231,3,16,8,11
	.byte	'MsgObjId',0
	.word	144
	.byte	1,2,35,0,11
	.byte	'HwControllerId',0
	.word	144
	.byte	1,2,35,1,11
	.byte	'TxObjPriorityClass',0
	.word	254
	.byte	4,2,35,4,0,12
	.byte	'Can_TxHwObjectConfigType',0,16,252,3,3
	.word	8023
	.byte	25
	.byte	'Can_RxHwObjectConfigType',0,16,129,4,16,12,11
	.byte	'MaskRef',0
	.word	254
	.byte	4,2,35,0,11
	.byte	'MsgId',0
	.word	254
	.byte	4,2,35,4,11
	.byte	'MsgObjId',0
	.word	144
	.byte	1,2,35,8,11
	.byte	'HwControllerId',0
	.word	144
	.byte	1,2,35,9,0,12
	.byte	'Can_RxHwObjectConfigType',0,16,147,4,3
	.word	8159
	.byte	22,4
	.word	144
	.byte	23,3,0,25
	.byte	'Can_ControllerMOMapConfigType',0,16,181,4,16,4,11
	.byte	'ControllerMOMap',0
	.word	8299
	.byte	4,2,35,0,0,12
	.byte	'Can_ControllerMOMapConfigType',0,16,184,4,3
	.word	8308
	.byte	25
	.byte	'Can_NPCRValueType',0,16,188,4,16,2,11
	.byte	'Can_NPCRValue',0
	.word	161
	.byte	2,2,35,0,0,12
	.byte	'Can_NPCRValueType',0,16,191,4,3
	.word	8409
	.byte	25
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,16,194,4,16,8,11
	.byte	'CanControllerBaudrate',0
	.word	254
	.byte	4,2,35,0,11
	.byte	'CanControllerBaudrateCfg',0
	.word	161
	.byte	2,2,35,4,0,12
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,16,198,4,3
	.word	8484
	.byte	9
	.word	8484
	.byte	6
	.word	8649
	.byte	25
	.byte	'Can_BaudrateConfigPtrType',0,16,201,4,16,4,11
	.byte	'Can_kBaudrateConfigPtr',0
	.word	8654
	.byte	4,2,35,0,0,12
	.byte	'Can_BaudrateConfigPtrType',0,16,204,4,3
	.word	8659
	.byte	25
	.byte	'Can_EventHandlingType',0,16,226,4,16,4,11
	.byte	'CanEventType',0
	.word	8299
	.byte	4,2,35,0,0,12
	.byte	'Can_EventHandlingType',0,16,229,4,3
	.word	8759
	.byte	12
	.byte	'Rte_TransformerErrorCode',0,17,130,1,15
	.word	144
	.byte	12
	.byte	'Rte_TransformerClass',0,17,131,1,15
	.word	144
	.byte	10,17,168,1,9,12,11
	.byte	'in',0
	.word	4599
	.byte	4,2,35,0,11
	.byte	'out',0
	.word	4599
	.byte	4,2,35,4,11
	.byte	'used',0
	.word	161
	.byte	2,2,35,8,11
	.byte	'lost_data',0
	.word	144
	.byte	1,2,35,10,0,12
	.byte	'Rte_QDynType',0,17,173,1,3
	.word	8905
	.byte	20,17,175,1,9,4,21
	.byte	'RTE_DRA',0,0,21
	.byte	'RTE_WOWP',0,1,21
	.byte	'RTE_TASK',0,2,21
	.byte	'RTE_ARE',0,3,21
	.byte	'RTE_EV',0,4,21
	.byte	'RTE_MSI',0,5,0,12
	.byte	'Rte_NotificationType',0,17,182,1,3
	.word	8992
	.byte	6
	.word	8905
	.byte	25
	.byte	'Rte_QCmnType',0,17,184,1,16,24,11
	.byte	'dynamic',0
	.word	9090
	.byte	4,2,35,0,11
	.byte	'copy',0
	.word	144
	.byte	1,2,35,4,11
	.byte	'queue_size',0
	.word	161
	.byte	2,2,35,6,11
	.byte	'element_size',0
	.word	161
	.byte	2,2,35,8,11
	.byte	'buffer_start',0
	.word	4599
	.byte	4,2,35,12,11
	.byte	'buffer_end',0
	.word	4599
	.byte	4,2,35,16,11
	.byte	'notification_type',0
	.word	8992
	.byte	4,2,35,20,0,12
	.byte	'Rte_QCmnType',0,17,192,1,3
	.word	9095
	.byte	12
	.byte	'Rte_AlarmRefType',0,17,224,1,32
	.word	254
	.byte	12
	.byte	'Rte_AlarmIndexType',0,17,226,1,32
	.word	161
	.byte	22,128,8
	.word	144
	.byte	23,255,7,0,12
	.byte	'Impl_NVM_DstPtrType_1024',0,18,50,15
	.word	9333
	.byte	12
	.byte	'CanIf_u32_impl',0,18,69,16
	.word	254
	.byte	12
	.byte	'CanIf_u16_impl',0,18,71,16
	.word	161
	.byte	12
	.byte	'CanIf_u8_impl',0,18,73,15
	.word	144
	.byte	12
	.byte	'CanIf_ControllerModeType_Enum_impl',0,18,88,15
	.word	144
	.byte	12
	.byte	'CanIf_PduModeType_Enum_impl',0,18,90,15
	.word	144
	.byte	10,18,92,9,2,11
	.byte	'DeviceMode',0
	.word	144
	.byte	1,2,35,0,11
	.byte	'ChannelMode',0
	.word	144
	.byte	1,2,35,1,0,12
	.byte	'CanIf_ControllerStateType_struct_impl',0,18,95,3
	.word	9524
	.byte	12
	.byte	'CanIf_NotifStatusType_Enum_impl',0,18,100,15
	.word	144
	.byte	12
	.byte	'CanSM_boolean_Impl',0,18,120,15
	.word	144
	.byte	12
	.byte	'CanSM_u8_Impl',0,18,123,15
	.word	144
	.byte	12
	.byte	'CanSM_BusOffRecoveryStateType_Enum_impl',0,18,128,1,15
	.word	144
	.byte	12
	.byte	'CanSM_NetworkModeStateType_Enum_impl',0,18,132,1,15
	.word	144
	.byte	12
	.byte	'CanSM_u16_Impl',0,18,136,1,16
	.word	161
	.byte	12
	.byte	'CanSM_TimerStateType_Enum_impl',0,18,138,1,15
	.word	144
	.byte	10,18,140,1,9,4,11
	.byte	'cntTick_u16',0
	.word	161
	.byte	2,2,35,0,11
	.byte	'stTimer',0
	.word	144
	.byte	1,2,35,2,0,12
	.byte	'CanSM_TimerConfig_tst_struct_impl',0,18,143,1,3
	.word	9865
	.byte	12
	.byte	'Com_impl_u16',0,18,154,1,16
	.word	161
	.byte	12
	.byte	'Com_impl_u8',0,18,157,1,15
	.word	144
	.byte	12
	.byte	'ComM_uint32_Impl',0,18,173,1,16
	.word	254
	.byte	12
	.byte	'ComM_uint16_Impl',0,18,175,1,16
	.word	161
	.byte	12
	.byte	'ComM_uint8_Impl',0,18,177,1,15
	.word	144
	.byte	12
	.byte	'ComM_bool_Impl',0,18,179,1,15
	.word	144
	.byte	10,18,181,1,9,24,11
	.byte	'ChannelState_e',0
	.word	254
	.byte	4,2,35,0,11
	.byte	'LightTimeoutCtr_u32',0
	.word	254
	.byte	4,2,35,4,11
	.byte	'MinFullComTimeoutCtr_u16',0
	.word	161
	.byte	2,2,35,8,11
	.byte	'ChannelMode_u8',0
	.word	144
	.byte	1,2,35,10,11
	.byte	'BusSmMode_u8',0
	.word	144
	.byte	1,2,35,11,11
	.byte	'UserRequestCtr_u8',0
	.word	144
	.byte	1,2,35,12,11
	.byte	'PassiveRequestState_u8',0
	.word	144
	.byte	1,2,35,13,11
	.byte	'PncRequestCtr_u8',0
	.word	144
	.byte	1,2,35,14,11
	.byte	'InhibitionReqStatus_u8',0
	.word	144
	.byte	1,2,35,15,11
	.byte	'NmNetworkRequestStatus_b',0
	.word	144
	.byte	1,2,35,16,11
	.byte	'DiagnosticRequestState_b',0
	.word	144
	.byte	1,2,35,17,11
	.byte	'CommunicationAllowed_b',0
	.word	144
	.byte	1,2,35,18,11
	.byte	'NmBusSleepIndicationStatus_b',0
	.word	144
	.byte	1,2,35,19,11
	.byte	'NmPrepareBusSleepIndicationStatus_b',0
	.word	144
	.byte	1,2,35,20,11
	.byte	'NmNetworkModeStatus_b',0
	.word	144
	.byte	1,2,35,21,0,12
	.byte	'ComM_ChannelStruct_Impl',0,18,197,1,3
	.word	10097
	.byte	10,18,206,1,9,10,11
	.byte	'WakeUpInhibitionCtr_u16',0
	.word	161
	.byte	2,2,35,0,11
	.byte	'LimitToNoComCtr_u16',0
	.word	161
	.byte	2,2,35,2,11
	.byte	'RequestedUserMode_t',0
	.word	144
	.byte	1,2,35,4,11
	.byte	'IndicatedUserMode_t',0
	.word	144
	.byte	1,2,35,5,11
	.byte	'numChannelsInFullCom_u8',0
	.word	144
	.byte	1,2,35,6,11
	.byte	'numChannelsInSilentCom_u8',0
	.word	144
	.byte	1,2,35,7,11
	.byte	'numChannelsInNoCom_u8',0
	.word	144
	.byte	1,2,35,8,0,12
	.byte	'ComM_UserStruct_Impl',0,18,214,1,3
	.word	10601
	.byte	12
	.byte	'Dcm_IOOperationResponseType',0,18,252,1,15
	.word	144
	.byte	12
	.byte	'Dcm_RequestDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspRequestRoutineResultsOutSignal_0PrimitivType',0
	.byte	18,138,2,15
	.word	144
	.byte	12
	.byte	'Dcm_StartDataIn_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineInSignalPrimitivType',0,18,146,2,15
	.word	144
	.byte	12
	.byte	'Dcm_StartDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineOutSignalPrimitivType',0,18,150,2,15
	.word	144
	.byte	12
	.byte	'Dcm_StopDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStopRoutineOutSignalPrimitivType',0,18,154,2,15
	.word	144
	.byte	12
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockNative_1024_Type',0,18,243,3,34
	.word	9344
	.byte	22,128,8
	.word	144
	.byte	23,255,7,0,12
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockRedundant_1024_Type',0,18,246,3,34
	.word	9344
	.byte	12
	.byte	'Rte_TaskRefType',0,19,184,1,32
	.word	5831
	.byte	12
	.byte	'Rte_EventRefType',0,19,185,1,32
	.word	144
	.byte	12
	.byte	'Rte_EventType',0,19,186,1,32
	.word	254
	.byte	12
	.byte	'Rte_REActCounterType',0,19,252,1,15
	.word	144
	.byte	6
	.word	144
	.byte	12
	.byte	'Rte_REActCounterRefType',0,19,253,1,58
	.word	11523
	.byte	10,19,255,1,9,8,11
	.byte	'task',0
	.word	11419
	.byte	4,2,35,0,11
	.byte	'acnt',0
	.word	11528
	.byte	4,2,35,4,0,12
	.byte	'Rte_REContainerType',0,19,130,2,3
	.word	11561
	.byte	9
	.word	5571
	.byte	6
	.word	11625
	.byte	6
	.word	144
	.byte	9
	.word	11561
	.byte	6
	.word	11640
	.byte	12
	.byte	'Rte_REContainerRefType',0,19,132,2,60
	.word	11645
	.byte	12
	.byte	'Rte_MSICounterType',0,19,149,2,16
	.word	161
	.byte	6
	.word	161
	.byte	12
	.byte	'Rte_MSICounterRefType',0,19,150,2,56
	.word	11710
	.byte	12
	.byte	'Rte_MSIPendingFlagType',0,19,152,2,17
	.word	144
	.byte	6
	.word	144
	.byte	12
	.byte	'Rte_MSIPendingFlagRefType',0,19,153,2,60
	.word	11778
	.byte	10,19,163,2,9,24,11
	.byte	'counter',0
	.word	11715
	.byte	4,2,35,0,11
	.byte	'incCounter',0
	.word	144
	.byte	1,2,35,4,11
	.byte	'pending',0
	.word	11783
	.byte	4,2,35,8,11
	.byte	'osTask',0
	.word	11419
	.byte	4,2,35,12,11
	.byte	'acnt',0
	.word	11528
	.byte	4,2,35,16,11
	.byte	'osEvent',0
	.word	144
	.byte	1,2,35,20,11
	.byte	'MSIInit',0
	.word	161
	.byte	2,2,35,22,0,12
	.byte	'Rte_MSITableEntry',0,19,172,2,3
	.word	11818
	.byte	6
	.word	161
	.byte	6
	.word	144
	.byte	12
	.byte	'Rte_TaskArrayIndex',0,19,179,2,16
	.word	144
	.byte	12
	.byte	'Rte_NrWaitingTasks',0,19,180,2,16
	.word	144
	.byte	10,19,182,2,9,4,11
	.byte	'pending',0
	.word	144
	.byte	1,2,35,0,11
	.byte	'count',0
	.word	144
	.byte	1,2,35,1,11
	.byte	'firstWaitingTask',0
	.word	144
	.byte	1,2,35,2,0,12
	.byte	'Rte_WaitableDatum',0,19,186,2,3
	.word	12036
	.byte	6
	.word	12036
	.byte	10,19,226,2,9,12,11
	.byte	'event_id',0
	.word	254
	.byte	4,2,35,0,11
	.byte	'wd',0
	.word	12128
	.byte	4,2,35,4,11
	.byte	'timeout',0
	.word	254
	.byte	4,2,35,8,0,12
	.byte	'Rte_WOWP_NotificationType',0,19,230,2,3
	.word	12133
	.byte	9
	.word	12133
	.byte	6
	.word	12222
	.byte	12
	.byte	'Rte_WOWP_NotificationRefType',0,19,232,2,66
	.word	12227
	.byte	12
	.byte	'Rte_ARE_NotificationType',0,19,234,2,29
	.word	11561
	.byte	25
	.byte	'Rte_QTaskType',0,19,243,2,16,28,11
	.byte	'cmn',0
	.word	9095
	.byte	24,2,35,0,11
	.byte	'task',0
	.word	11419
	.byte	4,2,35,24,0,12
	.byte	'Rte_QTaskType',0,19,246,2,3
	.word	12304
	.byte	25
	.byte	'Rte_QREType',0,19,250,2,16,28,11
	.byte	'cmn',0
	.word	9095
	.byte	24,2,35,0,11
	.byte	're',0
	.word	11650
	.byte	4,2,35,24,0,12
	.byte	'Rte_QREType',0,19,253,2,3
	.word	12375
	.byte	9
	.word	11561
	.byte	6
	.word	12440
	.byte	25
	.byte	'Rte_QWWPType',0,19,129,3,16,28,11
	.byte	'cmn',0
	.word	9095
	.byte	24,2,35,0,11
	.byte	'wwp',0
	.word	12232
	.byte	4,2,35,24,0,12
	.byte	'Rte_QWWPType',0,19,132,3,3
	.word	12450
	.byte	9
	.word	12133
	.byte	6
	.word	12518
	.byte	25
	.byte	'Rte_QEvType',0,19,136,3,16,36,11
	.byte	'cmn',0
	.word	9095
	.byte	24,2,35,0,11
	.byte	'task',0
	.word	11419
	.byte	4,2,35,24,11
	.byte	'mask',0
	.word	144
	.byte	1,2,35,28,11
	.byte	'acnt',0
	.word	11528
	.byte	4,2,35,32,0,12
	.byte	'Rte_QEvType',0,19,141,3,3
	.word	12528
	.byte	25
	.byte	'Rte_QMSIType',0,19,145,3,16,48,11
	.byte	'cmn',0
	.word	9095
	.byte	24,2,35,0,11
	.byte	'task',0
	.word	11419
	.byte	4,2,35,24,11
	.byte	'mask',0
	.word	144
	.byte	1,2,35,28,11
	.byte	'acnt',0
	.word	11528
	.byte	4,2,35,32,11
	.byte	'msiCounter',0
	.word	11715
	.byte	4,2,35,36,11
	.byte	'msiPending',0
	.word	11783
	.byte	4,2,35,40,11
	.byte	'msiLimit',0
	.word	161
	.byte	2,2,35,44,0,12
	.byte	'Rte_QMSIType',0,19,153,3,3
	.word	12623
	.byte	10,4,52,9,1,33
	.byte	'isEventTrig',0,1
	.word	144
	.byte	1,7,2,35,0,33
	.byte	'isTriggerIpduSendWithMetadata',0,1
	.word	144
	.byte	1,6,2,35,0,33
	.byte	'isGwIpduSend',0,1
	.word	144
	.byte	1,5,2,35,0,33
	.byte	'isModeChangd',0,1
	.word	144
	.byte	1,4,2,35,0,33
	.byte	'sigTransProp',0,1
	.word	144
	.byte	1,3,2,35,0,33
	.byte	'isTimeoutReq',0,1
	.word	144
	.byte	1,2,2,35,0,33
	.byte	'ignoreRepetitions',0,1
	.word	144
	.byte	1,1,2,35,0,0,12
	.byte	'Com_SendIpduInfo',0,4,61,3
	.word	12778
	.byte	12
	.byte	'Com_TransModeInfo',0,4,93,2
	.word	1255
	.byte	10,4,136,1,9,12,11
	.byte	'Init_Val',0
	.word	254
	.byte	4,2,35,0,11
	.byte	'txSignalFields',0
	.word	161
	.byte	2,2,35,4,11
	.byte	'Bit_Pos',0
	.word	144
	.byte	1,2,35,6,11
	.byte	'BitSize',0
	.word	144
	.byte	1,2,35,7,11
	.byte	'IpduRef',0
	.word	144
	.byte	1,2,35,8,11
	.byte	'General',0
	.word	144
	.byte	1,2,35,9,0,12
	.byte	'Com_Prv_xTxSigCfg_tst',0,4,201,1,2
	.word	13024
	.byte	10,4,247,1,9,16,11
	.byte	'Notification_Cbk',0
	.word	4018
	.byte	4,2,35,0,11
	.byte	'Init_Val',0
	.word	254
	.byte	4,2,35,4,11
	.byte	'Bit_Pos',0
	.word	144
	.byte	1,2,35,8,11
	.byte	'SigBuff_Index',0
	.word	144
	.byte	1,2,35,9,11
	.byte	'BitSize',0
	.word	144
	.byte	1,2,35,10,11
	.byte	'IpduRef',0
	.word	144
	.byte	1,2,35,11,11
	.byte	'General',0
	.word	144
	.byte	1,2,35,12,11
	.byte	'rxSignalFields',0
	.word	144
	.byte	1,2,35,13,0,12
	.byte	'Com_Prv_xRxSigCfg_tst',0,4,171,2,2
	.word	13172
	.byte	9
	.word	13172
	.byte	6
	.word	13369
	.byte	12
	.byte	'Com_RxSigConstPtrType',0,4,180,2,68
	.word	13374
	.byte	12
	.byte	'Com_Prv_xTxIpduInfoCfg_tst',0,4,162,6,3
	.word	1791
	.byte	10,4,137,7,9,20,11
	.byte	'BuffPtr',0
	.word	676
	.byte	4,2,35,0,11
	.byte	'TimeOutNotification_Cbk',0
	.word	4018
	.byte	4,2,35,4,11
	.byte	'Size',0
	.word	161
	.byte	2,2,35,8,11
	.byte	'FirstTimeout_Factor',0
	.word	161
	.byte	2,2,35,10,11
	.byte	'Timeout_Fact',0
	.word	161
	.byte	2,2,35,12,11
	.byte	'No_Of_Sig_Ref',0
	.word	161
	.byte	2,2,35,14,11
	.byte	'RxSigId_Index',0
	.word	144
	.byte	1,2,35,16,11
	.byte	'MainFunctionRef',0
	.word	144
	.byte	1,2,35,17,11
	.byte	'rxIPduFields',0
	.word	144
	.byte	1,2,35,18,0,12
	.byte	'Com_Prv_xRxIpduInfoCfg_tst',0,4,197,7,3
	.word	13446
	.byte	12
	.byte	'Com_Prv_xIpduGrpInfoCfg_tst',0,4,224,7,3
	.word	1686
	.byte	10,4,244,7,9,1,11
	.byte	'txSigRAMFields',0
	.word	144
	.byte	1,2,35,0,0,12
	.byte	'Com_TxSignalFlagType',0,4,248,7,2
	.word	13734
	.byte	10,4,167,8,9,1,11
	.byte	'rxSigRAMFields',0
	.word	144
	.byte	1,2,35,0,0,12
	.byte	'Com_RxSignalFlagType',0,4,171,8,2
	.word	13795
	.byte	12
	.byte	'Com_TxIpduRamData',0,4,189,9,3
	.word	1416
	.byte	12
	.byte	'Com_RxIpduRamData',0,4,245,9,2
	.word	1148
	.byte	6
	.word	161
	.byte	10,4,128,10,9,8,11
	.byte	'RxGwQueuePtr',0
	.word	13910
	.byte	4,2,35,0,11
	.byte	'Com_RxGwQueueWrite_ux',0
	.word	144
	.byte	1,2,35,4,11
	.byte	'Com_RxGwQueueRead_ux',0
	.word	144
	.byte	1,2,35,5,0,12
	.byte	'Com_RxGwQueueRAMType',0,4,133,10,2
	.word	13915
	.byte	10,4,138,10,9,4,11
	.byte	'indexGwMapSigDestIdArray',0
	.word	161
	.byte	2,2,35,0,11
	.byte	'destCount',0
	.word	144
	.byte	1,2,35,2,0,12
	.byte	'Com_Prv_xGwMapSigCfg_tst',0,4,142,10,2
	.word	14035
	.byte	10,4,147,10,9,2,11
	.byte	'GwMap_DestId',0
	.word	161
	.byte	2,2,35,0,0,12
	.byte	'Com_Prv_xGwMapSigIdCfg_tst',0,4,150,10,2
	.word	14129
	.byte	10,4,183,10,9,4,11
	.byte	'StartIPduId',0
	.word	144
	.byte	1,2,35,0,11
	.byte	'NumOfIpdus',0
	.word	144
	.byte	1,2,35,1,11
	.byte	'TimeBaseInMs',0
	.word	144
	.byte	1,2,35,2,0,12
	.byte	'Com_MainFunctionCfgType',0,4,188,10,3
	.word	14194
	.byte	10,4,194,10,9,12,11
	.byte	'Com_SigType_pu8',0
	.word	676
	.byte	4,2,35,0,11
	.byte	'Com_SigType_pu16',0
	.word	504
	.byte	4,2,35,4,11
	.byte	'Com_SigType_pu32',0
	.word	590
	.byte	4,2,35,8,0,12
	.byte	'Com_Prv_xRxRamBuf_tst',0,4,253,10,3
	.word	14297
	.byte	12
	.byte	'rba_BswSrv_uint64',0,20,66,28
	.word	2842
	.byte	34
	.byte	'Com_Uninit_Flag',0,7,139,24,45
	.word	3380
	.byte	1,1,35
	.word	1148
	.byte	36,0,34
	.byte	'Com_RxIpduRam_s',0,7,201,24,42
	.word	14465
	.byte	1,1,35
	.word	1416
	.byte	36,0,34
	.byte	'Com_TxIpduRam_s',0,7,211,24,42
	.word	14499
	.byte	1,1,35
	.word	144
	.byte	36,0,34
	.byte	'Com_IpduCounter_s',0,7,241,24,30
	.word	14533
	.byte	1,1,34
	.byte	'Com_IpduGrpVector',0,7,136,25,42
	.word	3352
	.byte	1,1,22,1
	.word	144
	.byte	23,0,0,35
	.word	1791
	.byte	36,0,9
	.word	14607
	.byte	34
	.byte	'Com_Prv_xTxIpduCfg_acst',0,7,137,26,57
	.word	14614
	.byte	1,1,35
	.word	1686
	.byte	36,0,9
	.word	14654
	.byte	34
	.byte	'Com_Prv_xIpduGrpCfg_acst',0,7,149,26,57
	.word	14661
	.byte	1,1,35
	.word	144
	.byte	36,0,9
	.word	14702
	.byte	34
	.byte	'Com_Prv_xIPduGrp_IpduRefCfg_au8',0,7,164,26,41
	.word	14709
	.byte	1,1,0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L97:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,36,0,3,8,11,15,62,15,0,0,3,46,1,3,8,32,13,58,15,59,15
	.byte	57,15,73,19,54,15,39,12,0,0,4,5,0,3,8,58,15,59,15,57,15,73,19,0,0,5,11,0,0,0,6,15,0,73,19,0,0,7,46,1,3
	.byte	8,32,13,58,15,59,15,57,15,54,15,39,12,0,0,8,11,1,0,0,9,38,0,73,19,0,0,10,19,1,58,15,59,15,57,15,11,15
	.byte	0,0,11,13,0,3,8,73,19,11,15,56,9,0,0,12,22,0,3,8,58,15,59,15,57,15,73,19,0,0,13,46,1,3,8,58,15,59,15,57
	.byte	15,54,15,39,12,63,12,60,12,0,0,14,46,1,3,8,58,15,59,15,57,15,73,19,54,15,39,12,63,12,60,12,0,0,15,46,1
	.byte	49,19,0,0,16,5,0,49,19,0,0,17,29,1,49,19,0,0,18,11,0,49,19,0,0,19,21,0,54,15,0,0,20,4,1,58,15,59,15,57
	.byte	15,11,15,0,0,21,40,0,3,8,28,13,0,0,22,1,1,11,15,73,19,0,0,23,33,0,47,15,0,0,24,21,0,54,15,39,12,0,0,25
	.byte	19,1,3,8,58,15,59,15,57,15,11,15,0,0,26,59,0,3,8,0,0,27,21,1,54,15,39,12,0,0,28,5,0,73,19,0,0,29,23,1
	.byte	58,15,59,15,57,15,11,15,0,0,30,4,1,3,8,58,15,59,15,57,15,11,15,0,0,31,21,0,73,19,54,15,39,12,0,0,32,53
	.byte	0,73,19,0,0,33,13,0,3,8,11,15,73,19,13,15,12,15,56,9,0,0,34,52,0,3,8,58,15,59,15,57,15,73,19,63,12,60
	.byte	12,0,0,35,1,1,73,19,0,0,36,33,0,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L98:
	.word	.L336-.L335
.L335:
	.half	3
	.word	.L338-.L337
.L337:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Bfx\\api\\Bfx_Bit_Inl.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv_Inl.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_IpduGroupStart.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Com\\api\\Com.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Det\\api\\Det.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Platform\\Platform_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Std_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Com\\Com_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Com\\Com_Cfg_Internal.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Can_GeneralTypes.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\RTOS_T\\Gen\\inc\\Os.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Can_17_MCanP\\inc\\Can_17_MCanP.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Type.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Intl.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\rba_BswSrv.h',0,0,0,0,0
.L338:
.L336:
	.sdecl	'.debug_info',debug,cluster('Com_IpduGroupControl')
	.sect	'.debug_info'
.L99:
	.word	2047
	.half	3
	.word	.L100
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_IpduGroupStart.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L102,.L101
	.byte	2
	.word	.L95
	.byte	3
	.byte	'Com_IpduGroupControl',0,1,44,22,1,1,1
	.word	.L90,.L114,.L89
	.byte	4
	.byte	'ipduGroupVector',0,1,45,70
	.word	.L115,.L116
	.byte	4
	.byte	'initialize',0,1,46,70
	.word	.L117,.L118
	.byte	5
	.word	.L90,.L114
	.byte	6
	.byte	'RxIPduRamPtr',0,1,49,37
	.word	.L119,.L120
	.byte	6
	.byte	'TxIPduRamPtr',0,1,50,37
	.word	.L121,.L122
	.byte	6
	.byte	'Index_u16',0,1,51,37
	.word	.L123,.L124
	.byte	7
	.word	.L125,.L126,.L127
	.byte	8
	.word	.L128,.L129
	.byte	8
	.word	.L130,.L131
	.byte	9
	.word	.L132,.L126,.L127
	.byte	6
	.byte	'ErrorId',0,2,254,6,13
	.word	.L117,.L133
	.byte	6
	.byte	'Status',0,2,255,6,13
	.word	.L117,.L134
	.byte	0,0,7
	.word	.L135,.L136,.L137
	.byte	8
	.word	.L138,.L139
	.byte	9
	.word	.L140,.L136,.L137
	.byte	6
	.byte	'IPduRefPtr',0,1,155,1,57
	.word	.L141,.L142
	.byte	6
	.byte	'IPduGrpConstPtr',0,1,156,1,57
	.word	.L143,.L144
	.byte	6
	.byte	'Index_u16',0,1,157,1,57
	.word	.L145,.L146
	.byte	6
	.byte	'NoOfPdus_u16',0,1,158,1,57
	.word	.L145,.L147
	.byte	6
	.byte	'IpduGrpId_u16',0,1,159,1,57
	.word	.L145,.L148
	.byte	6
	.byte	'ByteVal_u8',0,1,160,1,57
	.word	.L117,.L149
	.byte	6
	.byte	'BitOffset_u8',0,1,161,1,57
	.word	.L117,.L150
	.byte	6
	.byte	'PduCounterVal',0,1,162,1,57
	.word	.L117,.L151
	.byte	0,0,7
	.word	.L152,.L153,.L23
	.byte	8
	.word	.L154,.L155
	.byte	8
	.word	.L156,.L157
	.byte	10
	.word	.L158,.L153,.L23
	.byte	0,7
	.word	.L159,.L160,.L24
	.byte	8
	.word	.L161,.L162
	.byte	8
	.word	.L163,.L164
	.byte	8
	.word	.L165,.L166
	.byte	9
	.word	.L167,.L160,.L24
	.byte	6
	.byte	'tmp_u8',0,3,250,3,11
	.word	.L117,.L168
	.byte	0,0,7
	.word	.L152,.L22,.L28
	.byte	8
	.word	.L154,.L155
	.byte	8
	.word	.L156,.L157
	.byte	10
	.word	.L158,.L22,.L28
	.byte	0,7
	.word	.L159,.L169,.L170
	.byte	8
	.word	.L161,.L162
	.byte	8
	.word	.L163,.L164
	.byte	8
	.word	.L165,.L166
	.byte	9
	.word	.L167,.L169,.L170
	.byte	6
	.byte	'tmp_u8',0,3,250,3,11
	.word	.L117,.L171
	.byte	0,0,7
	.word	.L159,.L172,.L173
	.byte	8
	.word	.L161,.L162
	.byte	8
	.word	.L163,.L164
	.byte	8
	.word	.L165,.L166
	.byte	9
	.word	.L167,.L172,.L173
	.byte	6
	.byte	'tmp_u8',0,3,250,3,11
	.word	.L117,.L174
	.byte	0,0,7
	.word	.L159,.L175,.L27
	.byte	8
	.word	.L161,.L162
	.byte	8
	.word	.L163,.L164
	.byte	8
	.word	.L165,.L166
	.byte	9
	.word	.L167,.L175,.L27
	.byte	6
	.byte	'tmp_u8',0,3,250,3,11
	.word	.L117,.L176
	.byte	0,0,7
	.word	.L177,.L178,.L39
	.byte	8
	.word	.L179,.L180
	.byte	8
	.word	.L181,.L182
	.byte	10
	.word	.L183,.L178,.L39
	.byte	0,7
	.word	.L184,.L185,.L55
	.byte	8
	.word	.L186,.L187
	.byte	8
	.word	.L188,.L189
	.byte	9
	.word	.L190,.L185,.L55
	.byte	6
	.byte	'TxIPduConstPtr',0,1,189,2,29
	.word	.L191,.L192
	.byte	6
	.byte	'TxIpduRamPtr',0,1,190,2,29
	.word	.L121,.L193
	.byte	6
	.byte	'LatestTransMode_u8',0,1,192,2,29
	.word	.L117,.L194
	.byte	7
	.word	.L195,.L196,.L42
	.byte	8
	.word	.L197,.L198
	.byte	8
	.word	.L199,.L200
	.byte	8
	.word	.L201,.L202
	.byte	10
	.word	.L203,.L196,.L42
	.byte	0,7
	.word	.L204,.L205,.L206
	.byte	8
	.word	.L207,.L208
	.byte	8
	.word	.L209,.L210
	.byte	8
	.word	.L211,.L212
	.byte	11
	.word	.L213,.L214
	.byte	6
	.byte	'tmp_u8',0,3,202,3,11
	.word	.L117,.L215
	.byte	0,0,7
	.word	.L204,.L216,.L217
	.byte	8
	.word	.L207,.L208
	.byte	8
	.word	.L209,.L210
	.byte	8
	.word	.L211,.L212
	.byte	9
	.word	.L213,.L216,.L217
	.byte	6
	.byte	'tmp_u8',0,3,202,3,11
	.word	.L117,.L218
	.byte	0,0,7
	.word	.L177,.L219,.L48
	.byte	8
	.word	.L179,.L180
	.byte	8
	.word	.L181,.L182
	.byte	10
	.word	.L183,.L219,.L48
	.byte	0,7
	.word	.L204,.L220,.L221
	.byte	8
	.word	.L207,.L208
	.byte	8
	.word	.L209,.L210
	.byte	8
	.word	.L211,.L212
	.byte	9
	.word	.L213,.L220,.L221
	.byte	6
	.byte	'tmp_u8',0,3,202,3,11
	.word	.L117,.L222
	.byte	0,0,7
	.word	.L204,.L223,.L52
	.byte	8
	.word	.L207,.L208
	.byte	8
	.word	.L209,.L210
	.byte	8
	.word	.L211,.L212
	.byte	9
	.word	.L213,.L223,.L52
	.byte	6
	.byte	'tmp_u8',0,3,202,3,11
	.word	.L117,.L224
	.byte	0,0,7
	.word	.L177,.L225,.L56
	.byte	8
	.word	.L179,.L180
	.byte	8
	.word	.L181,.L182
	.byte	10
	.word	.L183,.L225,.L56
	.byte	0,7
	.word	.L204,.L226,.L227
	.byte	8
	.word	.L207,.L208
	.byte	8
	.word	.L209,.L210
	.byte	8
	.word	.L211,.L212
	.byte	9
	.word	.L213,.L226,.L227
	.byte	6
	.byte	'tmp_u8',0,3,202,3,11
	.word	.L117,.L228
	.byte	0,0,7
	.word	.L204,.L57,.L55
	.byte	8
	.word	.L207,.L208
	.byte	8
	.word	.L209,.L210
	.byte	8
	.word	.L211,.L212
	.byte	0,0,0,7
	.word	.L204,.L229,.L230
	.byte	8
	.word	.L207,.L208
	.byte	8
	.word	.L209,.L210
	.byte	8
	.word	.L211,.L212
	.byte	9
	.word	.L213,.L229,.L230
	.byte	6
	.byte	'tmp_u8',0,3,202,3,11
	.word	.L117,.L231
	.byte	0,0,7
	.word	.L204,.L232,.L40
	.byte	8
	.word	.L207,.L208
	.byte	8
	.word	.L209,.L210
	.byte	8
	.word	.L211,.L212
	.byte	9
	.word	.L213,.L232,.L40
	.byte	6
	.byte	'tmp_u8',0,3,202,3,11
	.word	.L117,.L233
	.byte	0,0,7
	.word	.L177,.L38,.L65
	.byte	8
	.word	.L179,.L180
	.byte	8
	.word	.L181,.L182
	.byte	10
	.word	.L183,.L38,.L65
	.byte	0,7
	.word	.L204,.L234,.L235
	.byte	8
	.word	.L207,.L208
	.byte	8
	.word	.L209,.L210
	.byte	8
	.word	.L211,.L212
	.byte	9
	.word	.L213,.L234,.L235
	.byte	6
	.byte	'tmp_u8',0,3,202,3,11
	.word	.L117,.L236
	.byte	0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('Com_IpduGroupControl')
	.sect	'.debug_abbrev'
.L100:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,52,0,3
	.byte	8,58,15,59,15,57,15,73,16,2,6,0,0,7,29,1,49,16,17,1,18,1,0,0,8,5,0,49,16,2,6,0,0,9,11,1,49,16,17,1,18
	.byte	1,0,0,10,11,0,49,16,17,1,18,1,0,0,11,11,1,49,16,85,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('Com_IpduGroupControl')
	.sect	'.debug_line'
.L101:
	.word	.L340-.L339
.L339:
	.half	3
	.word	.L342-.L341
.L341:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_IpduGroupStart.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv_Inl.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Bfx\\api\\Bfx_Bit_Inl.h',0,0,0,0,0
.L342:
	.byte	5,22,7,0,5,2
	.word	.L90
	.byte	3,43,1,5,50,9
	.half	.L267-.L90
	.byte	3,10,1,5,47,9
	.half	.L343-.L267
	.byte	1,5,61,9
	.half	.L344-.L343
	.byte	1,4,2,5,13,9
	.half	.L126-.L344
	.byte	3,204,6,1,9
	.half	.L268-.L126
	.byte	3,1,1,5,9,9
	.half	.L269-.L268
	.byte	3,3,1,5,5,9
	.half	.L345-.L269
	.byte	1,5,17,7,9
	.half	.L346-.L345
	.byte	3,2,1,5,31,9
	.half	.L347-.L346
	.byte	1,5,10,9
	.half	.L2-.L347
	.byte	3,2,1,5,17,7,9
	.half	.L348-.L2
	.byte	3,2,1,5,38,9
	.half	.L349-.L348
	.byte	1,5,20,9
	.half	.L3-.L349
	.byte	3,8,1,5,5,9
	.half	.L350-.L3
	.byte	1,5,9,7,9
	.half	.L351-.L350
	.byte	3,3,1,5,16,9
	.half	.L265-.L351
	.byte	3,2,1,5,5,9
	.half	.L6-.L265
	.byte	3,2,1,4,1,9
	.half	.L7-.L6
	.byte	3,155,121,1,5,32,7,9
	.half	.L127-.L7
	.byte	3,5,1,5,20,9
	.half	.L136-.L127
	.byte	3,233,0,1,5,60,9
	.half	.L271-.L136
	.byte	1,5,61,9
	.half	.L10-.L271
	.byte	3,2,1,5,60,9
	.half	.L352-.L10
	.byte	1,5,13,9
	.half	.L353-.L352
	.byte	1,5,30,9
	.half	.L354-.L353
	.byte	1,5,9,9
	.half	.L355-.L354
	.byte	1,5,65,7,9
	.half	.L272-.L355
	.byte	3,3,1,5,26,9
	.half	.L356-.L272
	.byte	3,1,1,5,17,9
	.half	.L12-.L356
	.byte	3,7,1,5,45,7,9
	.half	.L357-.L12
	.byte	3,3,1,5,56,9
	.half	.L358-.L357
	.byte	1,5,58,9
	.half	.L274-.L358
	.byte	3,11,1,5,70,9
	.half	.L359-.L274
	.byte	1,5,40,9
	.half	.L360-.L359
	.byte	1,5,100,9
	.half	.L361-.L360
	.byte	1,5,109,9
	.half	.L277-.L361
	.byte	1,5,100,9
	.half	.L14-.L277
	.byte	1,5,39,9
	.half	.L15-.L14
	.byte	3,2,1,9
	.half	.L279-.L15
	.byte	3,1,1,5,37,9
	.half	.L280-.L279
	.byte	3,7,1,5,59,7,9
	.half	.L362-.L280
	.byte	3,1,1,5,77,9
	.half	.L363-.L362
	.byte	1,5,113,9
	.half	.L364-.L363
	.byte	1,5,90,9
	.half	.L16-.L364
	.byte	3,127,1,5,45,9
	.half	.L278-.L16
	.byte	3,4,1,5,26,9
	.half	.L19-.L278
	.byte	3,4,1,5,61,9
	.half	.L365-.L19
	.byte	1,9
	.half	.L366-.L365
	.byte	3,127,1,5,35,9
	.half	.L367-.L366
	.byte	3,3,1,5,37,9
	.half	.L368-.L367
	.byte	3,1,1,5,45,9
	.half	.L18-.L368
	.byte	3,121,1,5,29,7,9
	.half	.L13-.L18
	.byte	3,13,1,5,28,9
	.half	.L281-.L13
	.byte	3,1,1,5,38,9
	.half	.L369-.L281
	.byte	3,2,1,5,59,7,9
	.half	.L370-.L369
	.byte	3,3,1,5,42,9
	.half	.L371-.L370
	.byte	1,5,71,9
	.half	.L11-.L371
	.byte	3,68,1,5,60,9
	.half	.L9-.L11
	.byte	1,5,27,7,9
	.half	.L137-.L9
	.byte	3,156,127,1,5,24,9
	.half	.L372-.L137
	.byte	3,1,1,5,60,9
	.half	.L283-.L372
	.byte	1,5,21,9
	.half	.L21-.L283
	.byte	3,7,1,5,17,9
	.half	.L373-.L21
	.byte	3,125,1,5,13,9
	.half	.L374-.L373
	.byte	1,4,3,5,32,7,9
	.half	.L153-.L374
	.byte	3,180,2,1,5,36,9
	.half	.L375-.L153
	.byte	1,5,21,9
	.half	.L376-.L375
	.byte	1,5,48,9
	.half	.L377-.L376
	.byte	1,5,5,9
	.half	.L378-.L377
	.byte	1,4,1,5,17,9
	.half	.L23-.L378
	.byte	3,207,125,1,5,21,7,9
	.half	.L379-.L23
	.byte	3,4,1,4,3,5,14,9
	.half	.L160-.L379
	.byte	3,175,3,1,5,26,9
	.half	.L284-.L160
	.byte	1,5,21,9
	.half	.L25-.L284
	.byte	1,5,15,9
	.half	.L26-.L25
	.byte	3,2,1,5,33,9
	.half	.L380-.L26
	.byte	1,5,37,9
	.half	.L381-.L380
	.byte	1,5,31,9
	.half	.L382-.L381
	.byte	1,5,21,9
	.half	.L383-.L382
	.byte	1,5,66,9
	.half	.L384-.L383
	.byte	1,5,48,9
	.half	.L285-.L384
	.byte	1,5,11,9
	.half	.L385-.L285
	.byte	1,4,1,5,17,9
	.half	.L24-.L385
	.byte	3,203,124,1,4,3,5,32,9
	.half	.L22-.L24
	.byte	3,177,2,1,5,36,9
	.half	.L386-.L22
	.byte	1,5,21,9
	.half	.L387-.L386
	.byte	1,5,48,9
	.half	.L388-.L387
	.byte	1,5,5,9
	.half	.L389-.L388
	.byte	1,4,1,5,17,9
	.half	.L28-.L389
	.byte	3,217,125,1,5,21,7,9
	.half	.L390-.L28
	.byte	3,2,1,4,3,5,14,9
	.half	.L169-.L390
	.byte	3,167,3,1,5,26,9
	.half	.L286-.L169
	.byte	1,5,21,9
	.half	.L30-.L286
	.byte	1,5,15,9
	.half	.L31-.L30
	.byte	3,2,1,5,33,9
	.half	.L391-.L31
	.byte	1,5,37,9
	.half	.L392-.L391
	.byte	1,5,31,9
	.half	.L393-.L392
	.byte	1,5,21,9
	.half	.L394-.L393
	.byte	1,5,66,9
	.half	.L395-.L394
	.byte	1,5,48,9
	.half	.L287-.L395
	.byte	1,5,11,9
	.half	.L396-.L287
	.byte	1,4,1,5,21,9
	.half	.L170-.L396
	.byte	3,217,124,1,4,3,5,14,9
	.half	.L172-.L170
	.byte	3,165,3,1,5,26,9
	.half	.L288-.L172
	.byte	1,5,21,9
	.half	.L32-.L288
	.byte	1,5,15,9
	.half	.L33-.L32
	.byte	3,2,1,5,33,9
	.half	.L397-.L33
	.byte	1,5,37,9
	.half	.L398-.L397
	.byte	1,5,31,9
	.half	.L399-.L398
	.byte	1,5,21,9
	.half	.L400-.L399
	.byte	1,5,66,9
	.half	.L401-.L400
	.byte	1,5,48,9
	.half	.L289-.L401
	.byte	1,5,11,9
	.half	.L402-.L289
	.byte	1,4,1,5,21,9
	.half	.L173-.L402
	.byte	3,219,124,1,4,3,5,14,9
	.half	.L175-.L173
	.byte	3,163,3,1,5,26,9
	.half	.L290-.L175
	.byte	1,5,21,9
	.half	.L34-.L290
	.byte	1,5,15,9
	.half	.L35-.L34
	.byte	3,2,1,5,33,9
	.half	.L403-.L35
	.byte	1,5,37,9
	.half	.L404-.L403
	.byte	1,5,31,9
	.half	.L405-.L404
	.byte	1,5,21,9
	.half	.L406-.L405
	.byte	1,5,66,9
	.half	.L407-.L406
	.byte	1,5,48,9
	.half	.L293-.L407
	.byte	1,5,11,9
	.half	.L408-.L293
	.byte	1,4,1,5,25,9
	.half	.L27-.L408
	.byte	3,223,124,1,5,71,9
	.half	.L409-.L27
	.byte	3,101,1,5,60,9
	.half	.L20-.L409
	.byte	1,5,27,7,9
	.half	.L410-.L20
	.byte	3,30,1,5,24,9
	.half	.L411-.L410
	.byte	1,9
	.half	.L294-.L411
	.byte	3,1,1,5,60,9
	.half	.L291-.L294
	.byte	1,5,21,9
	.half	.L37-.L291
	.byte	3,7,1,5,17,9
	.half	.L412-.L37
	.byte	3,125,1,5,13,9
	.half	.L413-.L412
	.byte	1,4,3,5,35,7,9
	.half	.L178-.L413
	.byte	3,237,1,1,5,39,9
	.half	.L414-.L178
	.byte	1,5,22,9
	.half	.L415-.L414
	.byte	1,5,51,9
	.half	.L416-.L415
	.byte	1,5,5,9
	.half	.L417-.L416
	.byte	1,4,1,5,17,9
	.half	.L39-.L417
	.byte	3,150,126,1,5,37,7,9
	.half	.L418-.L39
	.byte	3,6,1,5,26,9
	.half	.L185-.L418
	.byte	3,216,1,1,5,27,9
	.half	.L419-.L185
	.byte	3,2,1,5,5,9
	.half	.L295-.L419
	.byte	3,124,1,5,26,7,9
	.half	.L420-.L295
	.byte	3,10,1,5,30,9
	.half	.L421-.L420
	.byte	3,3,1,4,3,5,27,9
	.half	.L196-.L421
	.byte	3,229,0,1,5,45,9
	.half	.L422-.L196
	.byte	1,5,68,9
	.half	.L423-.L422
	.byte	1,5,60,9
	.half	.L424-.L423
	.byte	1,5,42,9
	.half	.L425-.L424
	.byte	1,5,5,9
	.half	.L426-.L425
	.byte	1,4,1,5,9,9
	.half	.L42-.L426
	.byte	3,158,127,1,4,3,5,14,9
	.half	.L205-.L42
	.byte	3,248,0,1,5,26,9
	.half	.L296-.L205
	.byte	1,5,21,9
	.half	.L43-.L296
	.byte	1,5,32,9
	.half	.L44-.L43
	.byte	3,2,1,5,15,9
	.half	.L427-.L44
	.byte	1,5,34,9
	.half	.L428-.L427
	.byte	1,5,38,9
	.half	.L429-.L428
	.byte	1,5,32,9
	.half	.L430-.L429
	.byte	1,5,21,9
	.half	.L431-.L430
	.byte	1,5,77,9
	.half	.L432-.L431
	.byte	1,5,50,9
	.half	.L297-.L432
	.byte	1,5,11,9
	.half	.L433-.L297
	.byte	1,4,1,5,9,9
	.half	.L206-.L433
	.byte	3,138,127,1,5,53,7,9
	.half	.L434-.L206
	.byte	3,8,1,5,71,9
	.half	.L435-.L434
	.byte	1,5,39,9
	.half	.L436-.L435
	.byte	1,5,42,9
	.half	.L45-.L436
	.byte	3,8,1,5,40,9
	.half	.L437-.L45
	.byte	1,5,9,9
	.half	.L438-.L437
	.byte	3,5,1,4,3,5,14,9
	.half	.L216-.L438
	.byte	3,223,0,1,5,26,9
	.half	.L298-.L216
	.byte	1,5,21,9
	.half	.L46-.L298
	.byte	1,5,15,9
	.half	.L47-.L46
	.byte	3,2,1,5,34,9
	.half	.L439-.L47
	.byte	1,5,38,9
	.half	.L440-.L439
	.byte	1,5,32,9
	.half	.L441-.L440
	.byte	1,5,21,9
	.half	.L442-.L441
	.byte	1,5,77,9
	.half	.L443-.L442
	.byte	1,5,50,9
	.half	.L299-.L443
	.byte	1,5,11,9
	.half	.L444-.L299
	.byte	1,4,1,5,12,9
	.half	.L217-.L444
	.byte	3,165,127,1,4,3,5,35,9
	.half	.L219-.L217
	.byte	3,95,1,5,39,9
	.half	.L445-.L219
	.byte	1,5,22,9
	.half	.L446-.L445
	.byte	1,5,51,9
	.half	.L447-.L446
	.byte	1,5,5,9
	.half	.L448-.L447
	.byte	1,4,1,5,9,9
	.half	.L48-.L448
	.byte	3,33,1,5,13,7,9
	.half	.L449-.L48
	.byte	3,2,1,4,3,5,14,9
	.half	.L220-.L449
	.byte	3,215,0,1,5,26,9
	.half	.L300-.L220
	.byte	1,5,21,9
	.half	.L50-.L300
	.byte	1,5,15,9
	.half	.L51-.L50
	.byte	3,2,1,5,34,9
	.half	.L450-.L51
	.byte	1,5,38,9
	.half	.L451-.L450
	.byte	1,5,32,9
	.half	.L452-.L451
	.byte	1,5,21,9
	.half	.L453-.L452
	.byte	1,5,77,9
	.half	.L454-.L453
	.byte	1,5,50,9
	.half	.L301-.L454
	.byte	1,5,11,9
	.half	.L455-.L301
	.byte	1,4,1,5,61,9
	.half	.L221-.L455
	.byte	3,168,127,1,5,45,9
	.half	.L456-.L221
	.byte	1,5,82,9
	.half	.L457-.L456
	.byte	3,127,1,5,47,9
	.half	.L49-.L457
	.byte	3,8,1,5,45,9
	.half	.L458-.L49
	.byte	1,5,13,9
	.half	.L459-.L458
	.byte	3,2,1,4,3,5,14,9
	.half	.L223-.L459
	.byte	3,205,0,1,5,26,9
	.half	.L302-.L223
	.byte	1,5,21,9
	.half	.L53-.L302
	.byte	1,5,15,9
	.half	.L54-.L53
	.byte	3,2,1,5,34,9
	.half	.L460-.L54
	.byte	1,5,38,9
	.half	.L461-.L460
	.byte	1,5,32,9
	.half	.L462-.L461
	.byte	1,5,21,9
	.half	.L463-.L462
	.byte	1,5,77,9
	.half	.L464-.L463
	.byte	1,5,50,9
	.half	.L303-.L464
	.byte	1,5,11,9
	.half	.L465-.L303
	.byte	1,4,1,5,9,9
	.half	.L52-.L465
	.byte	3,170,127,1,5,42,9
	.half	.L41-.L52
	.byte	3,22,1,5,12,9
	.half	.L466-.L41
	.byte	3,7,1,4,3,5,35,9
	.half	.L225-.L466
	.byte	3,189,127,1,5,39,9
	.half	.L467-.L225
	.byte	1,5,22,9
	.half	.L468-.L467
	.byte	1,5,51,9
	.half	.L469-.L468
	.byte	1,5,5,9
	.half	.L470-.L469
	.byte	1,4,1,5,9,9
	.half	.L56-.L470
	.byte	3,195,0,1,5,13,7,9
	.half	.L471-.L56
	.byte	3,2,1,4,3,5,14,9
	.half	.L226-.L471
	.byte	3,53,1,5,26,9
	.half	.L304-.L226
	.byte	1,5,21,9
	.half	.L58-.L304
	.byte	1,5,32,9
	.half	.L59-.L58
	.byte	3,2,1,5,15,9
	.half	.L472-.L59
	.byte	1,5,34,9
	.half	.L473-.L472
	.byte	1,5,38,9
	.half	.L474-.L473
	.byte	1,5,32,9
	.half	.L475-.L474
	.byte	1,5,21,9
	.half	.L476-.L475
	.byte	1,5,77,9
	.half	.L477-.L476
	.byte	1,5,50,9
	.half	.L306-.L477
	.byte	1,5,11,9
	.half	.L478-.L306
	.byte	1,4,1,5,61,9
	.half	.L227-.L478
	.byte	3,74,1,5,45,9
	.half	.L479-.L227
	.byte	1,5,9,9
	.half	.L57-.L479
	.byte	3,125,1,5,21,9
	.half	.L55-.L57
	.byte	3,219,125,1,4,3,5,14,9
	.half	.L229-.L55
	.byte	3,220,2,1,5,26,9
	.half	.L307-.L229
	.byte	1,5,21,9
	.half	.L60-.L307
	.byte	1,5,15,9
	.half	.L61-.L60
	.byte	3,2,1,5,34,9
	.half	.L480-.L61
	.byte	1,5,38,9
	.half	.L481-.L480
	.byte	1,5,32,9
	.half	.L482-.L481
	.byte	1,5,21,9
	.half	.L483-.L482
	.byte	1,5,77,9
	.half	.L484-.L483
	.byte	1,5,50,9
	.half	.L308-.L484
	.byte	1,5,11,9
	.half	.L485-.L308
	.byte	1,4,1,5,21,9
	.half	.L230-.L485
	.byte	3,164,125,1,4,3,5,14,9
	.half	.L232-.L230
	.byte	3,218,2,1,5,26,9
	.half	.L309-.L232
	.byte	1,5,21,9
	.half	.L62-.L309
	.byte	1,5,15,9
	.half	.L63-.L62
	.byte	3,2,1,5,34,9
	.half	.L486-.L63
	.byte	1,5,38,9
	.half	.L487-.L486
	.byte	1,5,32,9
	.half	.L488-.L487
	.byte	1,5,21,9
	.half	.L489-.L488
	.byte	1,5,77,9
	.half	.L490-.L489
	.byte	1,5,50,9
	.half	.L310-.L490
	.byte	1,5,11,9
	.half	.L491-.L310
	.byte	1,4,1,5,17,9
	.half	.L40-.L491
	.byte	3,154,125,1,4,3,5,35,9
	.half	.L38-.L40
	.byte	3,234,1,1,5,39,9
	.half	.L492-.L38
	.byte	1,5,22,9
	.half	.L493-.L492
	.byte	1,5,51,9
	.half	.L494-.L493
	.byte	1,5,5,9
	.half	.L495-.L494
	.byte	1,4,1,5,17,9
	.half	.L65-.L495
	.byte	3,166,126,1,5,21,7,9
	.half	.L496-.L65
	.byte	3,6,1,4,3,5,14,9
	.half	.L234-.L496
	.byte	3,206,2,1,5,26,9
	.half	.L311-.L234
	.byte	1,5,21,9
	.half	.L67-.L311
	.byte	1,5,32,9
	.half	.L68-.L67
	.byte	3,2,1,5,15,9
	.half	.L497-.L68
	.byte	1,5,34,9
	.half	.L498-.L497
	.byte	1,5,38,9
	.half	.L499-.L498
	.byte	1,5,32,9
	.half	.L500-.L499
	.byte	1,5,21,9
	.half	.L501-.L500
	.byte	1,5,77,9
	.half	.L502-.L501
	.byte	1,5,50,9
	.half	.L312-.L502
	.byte	1,5,11,9
	.half	.L503-.L312
	.byte	1,4,1,5,36,9
	.half	.L235-.L503
	.byte	3,177,125,1,5,25,9
	.half	.L64-.L235
	.byte	3,4,1,5,71,9
	.half	.L504-.L64
	.byte	3,94,1,5,60,9
	.half	.L36-.L504
	.byte	1,5,1,7,9
	.half	.L8-.L36
	.byte	3,37,1,7,9
	.half	.L103-.L8
	.byte	0,1,1
.L340:
	.sdecl	'.debug_ranges',debug,cluster('Com_IpduGroupControl')
	.sect	'.debug_ranges'
.L102:
	.word	-1,.L90,0,.L103-.L90,0,0
.L214:
	.word	-1,.L90,.L205-.L90,.L206-.L90,.L57-.L90,.L55-.L90,0,0
	.sdecl	'.debug_info',debug,cluster('Com_ClearIpduGroupVector')
	.sect	'.debug_info'
.L104:
	.word	355
	.half	3
	.word	.L105
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_IpduGroupStart.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L107,.L106
	.byte	2
	.word	.L95
	.byte	3
	.byte	'Com_ClearIpduGroupVector',0,1,242,1,22,1,1,1
	.word	.L92,.L237,.L91
	.byte	4
	.byte	'ipduGroupVector',0,1,242,1,84
	.word	.L115,.L238
	.byte	5
	.word	.L92,.L237
	.byte	6
	.word	.L125,.L239,.L240
	.byte	7
	.word	.L128,.L241
	.byte	7
	.word	.L130,.L242
	.byte	8
	.word	.L132,.L239,.L240
	.byte	9
	.byte	'ErrorId',0,2,254,6,13
	.word	.L117,.L243
	.byte	9
	.byte	'Status',0,2,255,6,13
	.word	.L117,.L244
	.byte	0,0,5
	.word	.L240,.L75
	.byte	9
	.byte	'Index_u16',0,1,248,1,32
	.word	.L145,.L245
	.byte	0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('Com_ClearIpduGroupVector')
	.sect	'.debug_abbrev'
.L105:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,29,1,49
	.byte	16,17,1,18,1,0,0,7,5,0,49,16,2,6,0,0,8,11,1,49,16,17,1,18,1,0,0,9,52,0,3,8,58,15,59,15,57,15,73,16,2,6
	.byte	0,0,0
	.sdecl	'.debug_line',debug,cluster('Com_ClearIpduGroupVector')
	.sect	'.debug_line'
.L106:
	.word	.L506-.L505
.L505:
	.half	3
	.word	.L508-.L507
.L507:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_IpduGroupStart.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv_Inl.h',0,0,0,0,0
.L508:
	.byte	5,22,7,0,5,2
	.word	.L92
	.byte	3,241,1,1,5,51,9
	.half	.L315-.L92
	.byte	3,3,1,5,48,9
	.half	.L509-.L315
	.byte	1,5,62,9
	.half	.L510-.L509
	.byte	1,4,2,5,13,9
	.half	.L239-.L510
	.byte	3,141,5,1,9
	.half	.L317-.L239
	.byte	3,1,1,5,9,9
	.half	.L318-.L317
	.byte	3,3,1,5,5,9
	.half	.L511-.L318
	.byte	1,5,17,7,9
	.half	.L512-.L511
	.byte	3,2,1,5,31,9
	.half	.L513-.L512
	.byte	1,5,10,9
	.half	.L69-.L513
	.byte	3,2,1,5,17,7,9
	.half	.L514-.L69
	.byte	3,2,1,5,38,9
	.half	.L515-.L514
	.byte	1,5,20,9
	.half	.L70-.L515
	.byte	3,8,1,5,5,9
	.half	.L516-.L70
	.byte	1,5,9,7,9
	.half	.L517-.L516
	.byte	3,3,1,5,16,9
	.half	.L314-.L517
	.byte	3,2,1,5,5,9
	.half	.L73-.L314
	.byte	3,2,1,4,1,9
	.half	.L74-.L73
	.byte	3,218,122,1,5,24,7,9
	.half	.L240-.L74
	.byte	3,5,1,5,65,9
	.half	.L319-.L240
	.byte	1,5,29,9
	.half	.L77-.L319
	.byte	3,2,1,5,28,9
	.half	.L316-.L77
	.byte	1,5,42,9
	.half	.L518-.L316
	.byte	1,5,40,9
	.half	.L519-.L518
	.byte	1,5,76,9
	.half	.L520-.L519
	.byte	3,126,1,5,65,9
	.half	.L76-.L520
	.byte	1,5,1,7,9
	.half	.L75-.L76
	.byte	3,5,1,7,9
	.half	.L108-.L75
	.byte	0,1,1
.L506:
	.sdecl	'.debug_ranges',debug,cluster('Com_ClearIpduGroupVector')
	.sect	'.debug_ranges'
.L107:
	.word	-1,.L92,0,.L108-.L92,0,0
	.sdecl	'.debug_info',debug,cluster('Com_SetIpduGroup')
	.sect	'.debug_info'
.L109:
	.word	427
	.half	3
	.word	.L110
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_IpduGroupStart.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L112,.L111
	.byte	2
	.word	.L95
	.byte	3
	.byte	'Com_SetIpduGroup',0,1,146,2,22,1,1,1
	.word	.L94,.L246,.L93
	.byte	4
	.byte	'ipduGroupVector',0,1,147,2,66
	.word	.L115,.L247
	.byte	4
	.byte	'IpduGroupId',0,1,148,2,66
	.word	.L145,.L248
	.byte	4
	.byte	'bitval',0,1,149,2,66
	.word	.L117,.L249
	.byte	5
	.word	.L94,.L246
	.byte	6
	.word	.L250,.L251,.L252
	.byte	7
	.word	.L253,.L254
	.byte	7
	.word	.L255,.L256
	.byte	7
	.word	.L257,.L258
	.byte	8
	.word	.L259,.L251,.L252
	.byte	9
	.byte	'ErrorId',0,2,171,7,13
	.word	.L117,.L260
	.byte	9
	.byte	'Status',0,2,172,7,13
	.word	.L117,.L261
	.byte	0,0,5
	.word	.L252,.L86
	.byte	9
	.byte	'Index_u16',0,1,157,2,34
	.word	.L145,.L262
	.byte	9
	.byte	'BitOffset_u8',0,1,158,2,34
	.word	.L117,.L263
	.byte	0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('Com_SetIpduGroup')
	.sect	'.debug_abbrev'
.L110:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,29,1,49
	.byte	16,17,1,18,1,0,0,7,5,0,49,16,2,6,0,0,8,11,1,49,16,17,1,18,1,0,0,9,52,0,3,8,58,15,59,15,57,15,73,16,2,6
	.byte	0,0,0
	.sdecl	'.debug_line',debug,cluster('Com_SetIpduGroup')
	.sect	'.debug_line'
.L111:
	.word	.L522-.L521
.L521:
	.half	3
	.word	.L524-.L523
.L523:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_IpduGroupStart.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv_Inl.h',0,0,0,0,0
.L524:
	.byte	5,22,7,0,5,2
	.word	.L94
	.byte	3,145,2,1,5,50,9
	.half	.L325-.L94
	.byte	3,7,1,5,101,9
	.half	.L326-.L325
	.byte	1,5,98,9
	.half	.L525-.L326
	.byte	1,5,38,9
	.half	.L526-.L525
	.byte	3,1,1,4,2,5,13,9
	.half	.L251-.L526
	.byte	3,149,5,1,9
	.half	.L327-.L251
	.byte	3,1,1,5,9,9
	.half	.L328-.L327
	.byte	3,3,1,5,5,9
	.half	.L527-.L328
	.byte	1,5,17,7,9
	.half	.L528-.L527
	.byte	3,2,1,5,31,9
	.half	.L529-.L528
	.byte	1,5,10,9
	.half	.L78-.L529
	.byte	3,2,1,5,17,7,9
	.half	.L530-.L78
	.byte	3,2,1,5,30,9
	.half	.L531-.L530
	.byte	1,5,10,9
	.half	.L80-.L531
	.byte	3,2,1,5,17,7,9
	.half	.L532-.L80
	.byte	3,2,1,5,38,9
	.half	.L533-.L532
	.byte	1,5,20,9
	.half	.L79-.L533
	.byte	3,8,1,5,5,9
	.half	.L534-.L79
	.byte	1,5,9,7,9
	.half	.L535-.L534
	.byte	3,3,1,5,16,9
	.half	.L322-.L535
	.byte	3,2,1,5,5,9
	.half	.L84-.L322
	.byte	3,2,1,4,1,9
	.half	.L85-.L84
	.byte	3,205,122,1,5,46,7,9
	.half	.L252-.L85
	.byte	3,7,1,5,34,9
	.half	.L330-.L252
	.byte	3,1,1,5,52,9
	.half	.L536-.L330
	.byte	3,4,1,5,55,9
	.half	.L537-.L536
	.byte	1,5,28,9
	.half	.L538-.L537
	.byte	1,5,9,9
	.half	.L332-.L538
	.byte	3,126,1,5,40,7,9
	.half	.L333-.L332
	.byte	3,2,1,5,72,9
	.half	.L539-.L333
	.byte	1,5,52,9
	.half	.L87-.L539
	.byte	3,4,1,5,40,9
	.half	.L331-.L87
	.byte	1,5,1,9
	.half	.L86-.L331
	.byte	3,3,1,7,9
	.half	.L113-.L86
	.byte	0,1,1
.L522:
	.sdecl	'.debug_ranges',debug,cluster('Com_SetIpduGroup')
	.sect	'.debug_ranges'
.L112:
	.word	-1,.L94,0,.L113-.L94,0,0
	.sdecl	'.debug_loc',debug,cluster('Com_ClearIpduGroupVector')
	.sect	'.debug_loc'
.L242:
	.word	0,0
.L91:
	.word	-1,.L92,0,.L237-.L92
	.half	2
	.byte	138,0
	.word	0,0
.L243:
	.word	-1,.L92,.L317-.L92,.L314-.L92
	.half	1
	.byte	87
	.word	0,0
.L245:
	.word	-1,.L92,.L319-.L92,.L75-.L92
	.half	1
	.byte	95
	.word	0,0
.L244:
	.word	-1,.L92,.L318-.L92,.L314-.L92
	.half	1
	.byte	81
	.word	.L73-.L92,.L237-.L92
	.half	1
	.byte	81
	.word	0,0
.L238:
	.word	-1,.L92,0,.L314-.L92
	.half	1
	.byte	100
	.word	.L315-.L92,.L316-.L92
	.half	1
	.byte	111
	.word	.L316-.L92,.L76-.L92
	.half	1
	.byte	98
	.word	0,0
.L241:
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('Com_IpduGroupControl')
	.sect	'.debug_loc'
.L131:
	.word	0,0
.L202:
	.word	0,0
.L150:
	.word	-1,.L90,.L12-.L90,.L273-.L90
	.half	1
	.byte	85
	.word	.L275-.L90,.L276-.L90
	.half	1
	.byte	82
	.word	.L281-.L90,.L11-.L90
	.half	1
	.byte	85
	.word	0,0
.L182:
	.word	0,0
.L157:
	.word	0,0
.L210:
	.word	0,0
.L164:
	.word	0,0
.L200:
	.word	0,0
.L149:
	.word	-1,.L90,.L272-.L90,.L14-.L90
	.half	1
	.byte	81
	.word	.L15-.L90,.L11-.L90
	.half	1
	.byte	81
	.word	0,0
.L89:
	.word	-1,.L90,0,.L114-.L90
	.half	2
	.byte	138,0
	.word	0,0
.L180:
	.word	0,0
.L155:
	.word	0,0
.L198:
	.word	0,0
.L208:
	.word	0,0
.L162:
	.word	0,0
.L133:
	.word	-1,.L90,.L268-.L90,.L265-.L90
	.half	1
	.byte	87
	.word	0,0
.L144:
	.word	-1,.L90,.L279-.L90,.L19-.L90
	.half	1
	.byte	100
	.word	0,0
.L142:
	.word	-1,.L90,.L280-.L90,.L13-.L90
	.half	1
	.byte	101
	.word	0,0
.L124:
	.word	-1,.L90,.L283-.L90,.L25-.L90
	.half	1
	.byte	83
	.word	.L26-.L90,.L30-.L90
	.half	1
	.byte	83
	.word	.L31-.L90,.L32-.L90
	.half	1
	.byte	83
	.word	.L33-.L90,.L34-.L90
	.half	1
	.byte	83
	.word	.L35-.L90,.L291-.L90
	.half	1
	.byte	83
	.word	.L291-.L90,.L43-.L90
	.half	1
	.byte	89
	.word	.L44-.L90,.L46-.L90
	.half	1
	.byte	89
	.word	.L47-.L90,.L50-.L90
	.half	1
	.byte	89
	.word	.L51-.L90,.L53-.L90
	.half	1
	.byte	89
	.word	.L54-.L90,.L58-.L90
	.half	1
	.byte	89
	.word	.L59-.L90,.L60-.L90
	.half	1
	.byte	89
	.word	.L61-.L90,.L62-.L90
	.half	1
	.byte	89
	.word	.L63-.L90,.L67-.L90
	.half	1
	.byte	89
	.word	.L68-.L90,.L8-.L90
	.half	1
	.byte	89
	.word	.L313-.L90,.L64-.L90
	.half	1
	.byte	84
	.word	0,0
.L146:
	.word	-1,.L90,.L271-.L90,.L14-.L90
	.half	1
	.byte	84
	.word	.L15-.L90,.L25-.L90
	.half	1
	.byte	84
	.word	.L26-.L90,.L30-.L90
	.half	1
	.byte	84
	.word	.L31-.L90,.L32-.L90
	.half	1
	.byte	84
	.word	.L33-.L90,.L34-.L90
	.half	1
	.byte	84
	.word	.L35-.L90,.L37-.L90
	.half	1
	.byte	84
	.word	0,0
.L189:
	.word	0,0
.L148:
	.word	-1,.L90,.L274-.L90,.L14-.L90
	.half	1
	.byte	95
	.word	.L15-.L90,.L278-.L90
	.half	1
	.byte	95
	.word	0,0
.L187:
	.word	0,0
.L194:
	.word	0,0
.L147:
	.word	-1,.L90,.L278-.L90,.L13-.L90
	.half	1
	.byte	95
	.word	0,0
.L151:
	.word	-1,.L90,.L277-.L90,.L14-.L90
	.half	5
	.byte	144,32,157,32,0
	.word	.L15-.L90,.L13-.L90
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L120:
	.word	-1,.L90,.L282-.L90,.L25-.L90
	.half	1
	.byte	111
	.word	.L26-.L90,.L30-.L90
	.half	1
	.byte	111
	.word	.L31-.L90,.L32-.L90
	.half	1
	.byte	111
	.word	.L33-.L90,.L34-.L90
	.half	1
	.byte	111
	.word	.L35-.L90,.L37-.L90
	.half	1
	.byte	111
	.word	0,0
.L134:
	.word	-1,.L90,.L269-.L90,.L265-.L90
	.half	5
	.byte	144,32,157,32,0
	.word	.L6-.L90,.L136-.L90
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L192:
	.word	0,0
.L122:
	.word	-1,.L90,.L294-.L90,.L43-.L90
	.half	1
	.byte	109
	.word	.L44-.L90,.L46-.L90
	.half	1
	.byte	109
	.word	.L47-.L90,.L50-.L90
	.half	1
	.byte	109
	.word	.L51-.L90,.L53-.L90
	.half	1
	.byte	109
	.word	.L54-.L90,.L58-.L90
	.half	1
	.byte	109
	.word	.L59-.L90,.L60-.L90
	.half	1
	.byte	109
	.word	.L61-.L90,.L62-.L90
	.half	1
	.byte	109
	.word	.L63-.L90,.L67-.L90
	.half	1
	.byte	109
	.word	.L68-.L90,.L8-.L90
	.half	1
	.byte	109
	.word	0,0
.L193:
	.word	-1,.L90,.L295-.L90,.L43-.L90
	.half	1
	.byte	111
	.word	.L44-.L90,.L46-.L90
	.half	1
	.byte	111
	.word	.L47-.L90,.L50-.L90
	.half	1
	.byte	111
	.word	.L51-.L90,.L53-.L90
	.half	1
	.byte	111
	.word	.L54-.L90,.L58-.L90
	.half	1
	.byte	111
	.word	.L59-.L90,.L305-.L90
	.half	1
	.byte	111
	.word	0,0
.L212:
	.word	0,0
.L166:
	.word	0,0
.L118:
	.word	-1,.L90,0,.L264-.L90
	.half	1
	.byte	84
	.word	.L267-.L90,.L14-.L90
	.half	1
	.byte	88
	.word	.L15-.L90,.L25-.L90
	.half	1
	.byte	88
	.word	.L26-.L90,.L30-.L90
	.half	1
	.byte	88
	.word	.L31-.L90,.L32-.L90
	.half	1
	.byte	88
	.word	.L33-.L90,.L34-.L90
	.half	1
	.byte	88
	.word	.L35-.L90,.L43-.L90
	.half	1
	.byte	88
	.word	.L44-.L90,.L46-.L90
	.half	1
	.byte	88
	.word	.L47-.L90,.L50-.L90
	.half	1
	.byte	88
	.word	.L51-.L90,.L53-.L90
	.half	1
	.byte	88
	.word	.L54-.L90,.L58-.L90
	.half	1
	.byte	88
	.word	.L59-.L90,.L60-.L90
	.half	1
	.byte	88
	.word	.L61-.L90,.L62-.L90
	.half	1
	.byte	88
	.word	.L63-.L90,.L67-.L90
	.half	1
	.byte	88
	.word	.L68-.L90,.L114-.L90
	.half	1
	.byte	88
	.word	0,0
.L116:
	.word	-1,.L90,0,.L265-.L90
	.half	1
	.byte	100
	.word	.L266-.L90,.L14-.L90
	.half	1
	.byte	108
	.word	.L270-.L90,.L136-.L90
	.half	1
	.byte	100
	.word	.L15-.L90,.L25-.L90
	.half	1
	.byte	108
	.word	.L26-.L90,.L30-.L90
	.half	1
	.byte	108
	.word	.L31-.L90,.L32-.L90
	.half	1
	.byte	108
	.word	.L33-.L90,.L34-.L90
	.half	1
	.byte	108
	.word	.L35-.L90,.L292-.L90
	.half	1
	.byte	108
	.word	0,0
.L139:
	.word	0,0
.L129:
	.word	0,0
.L233:
	.word	-1,.L90,.L309-.L90,.L62-.L90
	.half	1
	.byte	95
	.word	.L63-.L90,.L310-.L90
	.half	1
	.byte	95
	.word	0,0
.L224:
	.word	-1,.L90,.L302-.L90,.L53-.L90
	.half	1
	.byte	95
	.word	.L54-.L90,.L303-.L90
	.half	1
	.byte	95
	.word	0,0
.L215:
	.word	-1,.L90,.L296-.L90,.L43-.L90
	.half	1
	.byte	81
	.word	.L44-.L90,.L297-.L90
	.half	1
	.byte	81
	.word	0,0
.L218:
	.word	-1,.L90,.L298-.L90,.L46-.L90
	.half	1
	.byte	95
	.word	.L47-.L90,.L299-.L90
	.half	1
	.byte	95
	.word	0,0
.L228:
	.word	-1,.L90,.L304-.L90,.L58-.L90
	.half	1
	.byte	95
	.word	.L59-.L90,.L306-.L90
	.half	1
	.byte	95
	.word	0,0
.L222:
	.word	-1,.L90,.L300-.L90,.L50-.L90
	.half	1
	.byte	95
	.word	.L51-.L90,.L301-.L90
	.half	1
	.byte	95
	.word	0,0
.L236:
	.word	-1,.L90,.L311-.L90,.L67-.L90
	.half	1
	.byte	95
	.word	.L68-.L90,.L312-.L90
	.half	1
	.byte	95
	.word	0,0
.L231:
	.word	-1,.L90,.L307-.L90,.L60-.L90
	.half	1
	.byte	95
	.word	.L61-.L90,.L308-.L90
	.half	1
	.byte	95
	.word	0,0
.L168:
	.word	-1,.L90,.L284-.L90,.L25-.L90
	.half	5
	.byte	144,32,157,32,0
	.word	.L26-.L90,.L285-.L90
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L174:
	.word	-1,.L90,.L288-.L90,.L32-.L90
	.half	1
	.byte	95
	.word	.L33-.L90,.L289-.L90
	.half	1
	.byte	95
	.word	0,0
.L176:
	.word	-1,.L90,.L290-.L90,.L34-.L90
	.half	1
	.byte	95
	.word	.L35-.L90,.L293-.L90
	.half	1
	.byte	95
	.word	0,0
.L171:
	.word	-1,.L90,.L286-.L90,.L30-.L90
	.half	1
	.byte	95
	.word	.L31-.L90,.L287-.L90
	.half	1
	.byte	95
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('Com_SetIpduGroup')
	.sect	'.debug_loc'
.L258:
	.word	0,0
.L263:
	.word	-1,.L94,.L329-.L94,.L332-.L94
	.half	1
	.byte	95
	.word	0,0
.L93:
	.word	-1,.L94,0,.L246-.L94
	.half	2
	.byte	138,0
	.word	0,0
.L260:
	.word	-1,.L94,.L327-.L94,.L322-.L94
	.half	1
	.byte	87
	.word	0,0
.L262:
	.word	-1,.L94,.L330-.L94,.L331-.L94
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L248:
	.word	-1,.L94,0,.L320-.L94
	.half	1
	.byte	84
	.word	.L325-.L94,.L326-.L94
	.half	1
	.byte	88
	.word	.L252-.L94,.L329-.L94
	.half	1
	.byte	88
	.word	0,0
.L261:
	.word	-1,.L94,.L328-.L94,.L322-.L94
	.half	1
	.byte	82
	.word	.L84-.L94,.L246-.L94
	.half	1
	.byte	82
	.word	0,0
.L249:
	.word	-1,.L94,0,.L321-.L94
	.half	1
	.byte	85
	.word	.L332-.L94,.L333-.L94
	.half	1
	.byte	89
	.word	0,0
.L247:
	.word	-1,.L94,0,.L322-.L94
	.half	1
	.byte	100
	.word	.L323-.L94,.L324-.L94
	.half	1
	.byte	111
	.word	0,0
.L254:
	.word	0,0
.L256:
	.word	0,0
	.sdecl	'.debug_frame',debug
	.sect	'.debug_frame'
.L540:
	.word	48
	.word	-1
	.byte	3,0,2,1,27,12,26,0,8,27,8,26,8,28,8,29,8,30,8,31,8,34,8,35,8,32,8,33,8,16,8,17,8,24,8,25,8,36,8,37,8,38
	.byte	8,39
	.sdecl	'.debug_frame',debug,cluster('Com_IpduGroupControl')
	.sect	'.debug_frame'
	.word	12
	.word	.L540,.L90,.L114-.L90
	.sdecl	'.debug_frame',debug,cluster('Com_ClearIpduGroupVector')
	.sect	'.debug_frame'
	.word	12
	.word	.L540,.L92,.L237-.L92
	.sdecl	'.debug_frame',debug,cluster('Com_SetIpduGroup')
	.sect	'.debug_frame'
	.word	12
	.word	.L540,.L94,.L246-.L94

; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   408          }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   409  #endif
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   410      }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   411  }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   412  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   413  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   414   Function name    : Com_RxIPduStart
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   415   Syntax           : void Com_RxIPduStart(Com_IpduIdType IpduId, boolean Initialize)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   416   Description      : Service to start the Rx-IPDU
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   417   Parameter        : IpduId     - Id of the Rx-IPDU
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   418                    : Initialize - flag to request initialization of the I-PDUs which are newly started
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   419   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   420   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   421  static INLINE FUNC(void, COM_CODE) Com_RxIPduStart(
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   422                                              VAR(Com_IpduIdType, AUTOMATIC)  IpduId,
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   423                                              VAR(boolean, AUTOMATIC)         Initialize
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   424                                                    )
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   425  {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   426  #if (defined(COM_RxFilters) && defined(COM_F_ONEEVERYN))
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   427      Com_RxIpduConstPtrType           RxIPduConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   428      Com_RxSigConstPtrType            RxSigConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   429      VAR(uint16_least, AUTOMATIC)     Idx_Sig_Grp_ui; /* Index for both Rx-SignalGroup and Rx-Signal */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   430  # ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   431      Com_RxSigGrpConstPtrType         RxSigGrpConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   432      Com_RxGrpSigConstPtrType         RxGrpSigConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   433      VAR(uint16_least, AUTOMATIC)     Idx_GrpSig_ui; /* Index for Rx-GroupSignal */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   434  # endif
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   435  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   436      RxIPduConstPtr   = COM_GET_RX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   437  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   438      /* Rx-SignalGroup */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   439  # ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   440      RxSigGrpConstPtr = COM_GET_RXSIGGRP_CONSTDATA(RxIPduConstPtr->FirstRxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   441  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   442      for (Idx_Sig_Grp_ui = (uint16_least)RxIPduConstPtr->No_Of_SigGrp_Ref; Idx_Sig_Grp_ui != 0u; Idx_Sig_Grp_ui--)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   443      {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   444          if (Com_GetValue(RXSIGGRP,_FILTEREVALREQ,RxSigGrpConstPtr->rxSignalGrpFields))
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   445          {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   446              RxGrpSigConstPtr = COM_GET_RXGRPSIG_CONSTDATA(RxSigGrpConstPtr->FirstGrpSig_Index);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   447  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   448              for (Idx_GrpSig_ui = (uint16_least)RxSigGrpConstPtr->No_Of_GrpSig; Idx_GrpSig_ui != 0u; Idx_GrpSig_ui--)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   449              {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   450                  if (RxGrpSigConstPtr->Filter_Algo == (uint8)COM_ONE_EVERY_N)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   451                  {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   452                      /* [SWS_Com_00787] reset OCCURRENCE of filter with ComFilterAlgorithm ONE_EVERY_N */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   453                      COM_GET_ONEEVERYN(RxGrpSigConstPtr->Filter_Index).Occurrence = 0;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   454                  }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   455                  RxGrpSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   456              }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   457          }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   458          RxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   459      }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   460  # endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   461  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   462      /* Rx-Signal */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   463      RxSigConstPtr    = COM_GET_RXSIG_CONSTDATA(RxIPduConstPtr->RxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   464  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   465      for (Idx_Sig_Grp_ui = (uint16_least)RxIPduConstPtr->No_Of_Sig_Ref; Idx_Sig_Grp_ui != 0u; Idx_Sig_Grp_ui--)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   466      {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   467          if (Com_GetValue(RXSIG,_FILTRALG,RxSigConstPtr->rxSignalFields) == (uint8)COM_ONE_EVERY_N)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   468          {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   469              /* [SWS_Com_00787] reset OCCURRENCE of filter with ComFilterAlgorithm ONE_EVERY_N */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   470              COM_GET_ONEEVERYN(RxSigConstPtr->Filter_Index).Occurrence = 0;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   471          }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   472          RxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   473      }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   474  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   475  #else
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   476      /*  Misra warning removal for unused parameter */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   477      (void)IpduId;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   478  #endif/* #if (defined(COM_RxFilters) && defined(COM_F_ONEEVERYN)) */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   479  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   480      (void)Initialize; /* This variable is retained for future use */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   481  }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   482  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   483  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   484   Function name    : Com_Prv_UpdateBitAndFilter
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   485   Syntax           : Com_Prv_UpdateBitAndFilter(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   486   Description      : Service to clear update bit if configured for all the configured signal and signalgroup
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   487   Parameter        : IpduId      -> Id of the ipdu
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   488   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   489   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   490  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   491  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_UpdateBitAndFilter(VAR(Com_IpduIdType, AUTOMATIC) IpduId)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   492  {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   493  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   494      Com_TxSigConstPtrType   TxSigConstPtr;  /* Local pointer to Tx Signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   495      Com_TxIpduConstPtrType  TxIPduConstPtr; /* Local pointer to Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   496  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   497      VAR(uint16_least, AUTOMATIC) Index_Sig_ui;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   498  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   499      Com_TxSigGrpConstPtrType     TxSigGrpConstPtr;    /* Local pointer to Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   500      VAR(uint16_least, AUTOMATIC) Index_SigGrp_ui;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   501  #endif
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   502  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   503  #if defined (COM_TX_SIGNALGROUP) && defined(COM_TxFilters) && defined (COM_F_ONEEVERYN)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   504      Com_TxGrpSigConstPtrType      TxGrpSigConstPtr;  /* Local pointer to Tx GroupSignal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   505  #endif
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   506  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   507  #if defined (COM_TxSigUpdateBit) || defined(COM_TxSigGrpUpdateBit)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   508      VAR(PduLengthType, AUTOMATIC) ByteNo_u8;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   509      VAR(uint8, AUTOMATIC)         ConstByteValue_u8;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   510  #endif
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   511  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   512      TxIPduConstPtr      = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   513  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   514      TxSigConstPtr       = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   515  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   516      for(Index_Sig_ui = TxIPduConstPtr->No_Of_Sig_Ref;Index_Sig_ui != 0u;Index_Sig_ui--)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   517      {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   518  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   519          #ifdef COM_TxSigUpdateBit
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   520          /* Only the first byte of txIPduFields is needed */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   521          ConstByteValue_u8 = (uint8)TxIPduConstPtr->txIPduFields;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   522  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   523          /* Get ClearBit and Update Bit */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   524          /* MR12 RULE 13.5 VIOLATION: Below conditional statement reads flag status. Evaluation(or no evaluation)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   525           * of the 2nd or 3rd operands does not impact the system behaviour even though of volatile-qualified,
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   526           * moreover HIS-LEVEL parameter will be violated if more conditional statements are added.
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   527           * Hence the warning is suppressed. */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   528          if((Com_GetValue(TXIPDU,_CLRUPDBIT,ConstByteValue_u8) != (uint16)COM_CLRUPDATEBIT_NONE) &&
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   529             (Com_GetValue(GEN,_UPDBITCONF,TxSigConstPtr->General)))
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   530          {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   531  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   532              /* Find the Byte No, where the Update bit lies */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   533              ByteNo_u8 = (PduLengthType)((TxSigConstPtr->Update_Bit_Pos)>>3u);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   534              /* This macro clears the update bit value at the Update bit position */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   535              Com_ClearUpdateBitValue(TxIPduConstPtr,TxSigConstPtr->Update_Bit_Pos,ByteNo_u8)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   536          }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   537          #endif/*COM_TxSigUpdateBit*/
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   538  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   539              /* OCCURRENCE shall be set to zero by Com_IpduGroupStart*/
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   540          #ifdef COM_TxFilters
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   541          # ifdef COM_F_ONEEVERYN
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   542          if(Com_GetValue(TXSIG,_FILTRALG,TxSigConstPtr->txSignalFields) == (uint16)COM_ONE_EVERY_N)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   543          {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   544              COM_GET_ONEEVERYN(TxSigConstPtr->Filter_Index).Occurrence = COM_ZERO;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   545          }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   546          # endif
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   547          #endif
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   548  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   549          TxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   550      }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   551  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   552      #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   553  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   554      TxSigGrpConstPtr   = COM_GET_TXSIGGRP_CONSTDATA(TxIPduConstPtr->FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   555  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   556      for(Index_SigGrp_ui=(uint16_least)TxIPduConstPtr ->No_Of_SigGrp_Ref;Index_SigGrp_ui != 0u;Index_SigGrp_ui--)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   557      {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   558  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   559          # if defined(COM_TxFilters) && defined (COM_F_ONEEVERYN)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   560  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   561          TxGrpSigConstPtr = COM_GET_TXGRPSIG_CONSTDATA(TxSigGrpConstPtr ->FirstGrpSig_Index);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   562  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   563          for(Index_Sig_ui = TxSigGrpConstPtr ->No_Of_GrpSig;Index_Sig_ui !=0u;Index_Sig_ui--)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   564          {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   565  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   566              /* OCCURRENCE shall be set to zero by Com_IpduGroupStart*/
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   567              if( TxGrpSigConstPtr->Filter_Algo == (uint8)COM_ONE_EVERY_N)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   568              {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   569                  COM_GET_ONEEVERYN(TxGrpSigConstPtr->Filter_Index).Occurrence = COM_ZERO;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   570              }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   571              TxGrpSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   572          }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   573          # endif /* #if defined(COM_TxFilters) && defined (COM_F_ONEEVERYN) */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   574  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   575              /* Clear Update bits*/
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   576          # ifdef COM_TxSigGrpUpdateBit
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   577          /* Only the first byte of txIPduFields is needed */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   578          ConstByteValue_u8 = (uint8)TxIPduConstPtr->txIPduFields;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   579  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   580          /* Get ClearBit and Update Bit */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   581          /* MR12 RULE 13.5 VIOLATION: Below conditional statement reads flag status. Evaluation(or no evaluation)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   582           * of the 2nd or 3rd operands does not impact the system behaviour even though of volatile-qualified,
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   583           * moreover HIS-LEVEL parameter will be violated if more conditional statements are added.
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   584           * Hence the warning is suppressed. */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   585          if((Com_GetValue(TXIPDU,_CLRUPDBIT,ConstByteValue_u8) != (uint16)COM_CLRUPDATEBIT_NONE) &&
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   586             (Com_GetValue(TXSIGGRP,_UPDBITCONF,TxSigGrpConstPtr->txSignalGrpFields)))
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   587          {
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   588  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   589              /*Find the Byte No, where the Update bit lies */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   590              ByteNo_u8 = (PduLengthType)((TxSigGrpConstPtr ->Update_Bit_Pos)>>3u);
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   591              /* This macro clears the update bit value at the Update bit position */
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   592              Com_ClearUpdateBitValue(TxIPduConstPtr,TxSigGrpConstPtr ->Update_Bit_Pos,ByteNo_u8)
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   593          }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   594          # endif  /*COM_TxSigGrpUpdateBit*/
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   595  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   596          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   597      }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   598      #endif
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   599  }
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   600  
; BSW\src\BSW\Gen\Com\src\Com_IpduGroupStart.c	   601  

	; Module end
