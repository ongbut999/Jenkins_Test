	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 19053136 SN 09001910"
	.compiler_invocation	"ctc -f cc13372a -c99 --integer-enumeration -D__CPU__=tc27x -D__CPU_TC27X__ --core=tc1.6.x --eabi-compliant --fp-model=-float -D_TASKING_C_TRICORE_=1 -I.\\output\\inc -g2 -t4 --language=-comments,-gcc,+volatile,-strings --default-near-size=0 -O2ROPYGKLF-predict --default-a1-size=0 --default-a0-size=0 --source --switch=auto -o output\\objs\\BSW\\src\\BSW\\Gen\\Com\\Com_ReceiveSignal.src BSW\\src\\BSW\\Gen\\Com\\src\\Com_ReceiveSignal.c"
	.compiler_name		"ctc"
	;source	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_ReceiveSignal.c'

	
$TC16X
	
	.sdecl	'.text.Com_ReceiveSignal.Com_ReceiveSignal',code,cluster('Com_ReceiveSignal')
	.sect	'.text.Com_ReceiveSignal.Com_ReceiveSignal'
	.align	2
	
	.global	Com_ReceiveSignal

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	     1  
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	     2  
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	     3  /**************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	     4  /* Preprocessor includes                                                                          */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	     5  /**************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	     6  #include "Com_Prv.h"
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	     7  #include "Com_Prv_Inl.h"
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	     8  
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	     9  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_CopyData_UnsignedType (VAR(Com_SignalIdType, AUTOMATIC) SignalId,
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    10                                                                   P2VAR(void, AUTOMATIC, COM_APPL_DATA) SignalDataPtr);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    11  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_CopyData_signedType   (VAR(Com_SignalIdType, AUTOMATIC) SignalId,
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    12                                                                   P2VAR(void, AUTOMATIC, COM_APPL_DATA) SignalDataPtr);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    13  /**************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    14  /* Global functions (declared in header files )                                                   */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    15  /**************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    16  /***************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    17   Function name    : Com_ReceiveSignal
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    18   Syntax           : uint8 Com_ReceiveSignal(Com_SignalIdType SignalId,Com_ApplicationDataRefType   SignalDataPtr)
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    19   Description      : Service for receiving the signal, This API copies the data to the application buffer
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    20   Parameter        : SignalId -> Id of the Signal
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    21                    : SignalDataPtr -> Pointer to the address where signal data needs to be copied.
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    22   Return value     : E_OK/COM_SERVICE_NOT_AVAILABLE
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    23  ***************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    24  #define COM_START_SEC_CODE
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    25  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    26  FUNC(uint8, COM_CODE) Com_ReceiveSignal(VAR(Com_SignalIdType, AUTOMATIC) SignalId,
; Function Com_ReceiveSignal
.L41:
Com_ReceiveSignal:	.type	func
	mov	d8,d4
.L123:
	mov.aa	a12,a4
.L125:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    27                                          P2VAR(void, AUTOMATIC, COM_APPL_DATA) SignalDataPtr)
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    28  {
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    29      /* Local pointer holds the address of Rx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    30      Com_RxSigConstPtrType                       RxSigConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    31      VAR(uint8, AUTOMATIC)                       Status;  /* Return status */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    32      /* Local variable holds the signal type */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    33      VAR(uint8, AUTOMATIC)                       SigType;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    34  
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    35      Status = COM_SERVICE_NOT_AVAILABLE;
	mov	d9,#128
.L126:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    36  
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    37  #if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    38      if (Com_Prv_DETCheck_Param_Ptr((SignalId >= COM_GET_NUM_RX_SIGNALS), (SignalDataPtr == NULL_PTR),
	ge.u	d0,d8,#13
.L165:
	mov.a	a15,#0
.L166:
	eq.a	d1,a12,a15
.L167:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    39                                                                                              COMServiceId_ReceiveSignal))
	mov	d6,#11
.L62:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     1  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     2  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     3  #ifndef COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     4  #define COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     5  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     6  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     7   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     8   * Includes
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     9   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    10  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    11  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    12  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    13  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    17  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    18  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    19  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    20  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    21   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    22   * Type definitions
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    23   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    24  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    25  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    26  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    27  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    28   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    29   * Variables
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    30   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    31  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    32  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    33  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    34  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    35   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    36   * Extern declarations
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    37   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    38  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    39  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    40   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    41   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    42   * Inline function sets TMS data in to be accessesd via CurrentTxModePtr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    43   * after evaluating TMS mode for the IPdu
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    44   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    45  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    46  FUNC(void, COM_CODE) Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    47                                  Com_TxIpduRamPtrType                TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    48                                  Com_TxIpduConstPtrType              TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    49                                  VAR(uint16,AUTOMATIC)               TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    50                                  VAR(boolean,AUTOMATIC)              ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    51                                              );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    52  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    53  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    54   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    55   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    56   * Inline function to update Rx-GroupSignal application buffers
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    57   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    58  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    59  FUNC(void, COM_CODE) Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    60                                  Com_RxSigConstPtrType               RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    61                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    62                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    63                                               );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    64  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    65  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    66   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    67   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    68   * Inline function to update Rx-GroupSignal secondary buffers
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    69   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    70  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    71  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    72  FUNC(void, COM_CODE) Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    73                                  Com_RxGrpSigConstPtrType            RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    74                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    75                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    76                                                          );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    77  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    78  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    79  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    80   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    81   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    82   * Inline function to initialize signal intial value into the provided IPdu buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    83   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    84  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    85  FUNC(void, COM_CODE) Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    86                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    87                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    88                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    89                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    90                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    91                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    92                                                              );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    93  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    94  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    95   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    96   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    97   * Inline function to initialize Rx-signal group with initial values
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    98   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    99  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   100  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   101  FUNC(void, COM_CODE) Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   102                                  Com_RxSigGrpConstPtrType            RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   103                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   104                                                  );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   105  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   106  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   107  #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   108  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxNotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   109  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxErrNotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   110  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxTONotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   111  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallRxTONotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   112  #endif /* #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   113  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   114  /* Inline function to check for the RxIPdu and TxIpdu status*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   115  LOCAL_INLINE boolean Com_CheckRxIPduStatus(PduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   116  LOCAL_INLINE boolean Com_CheckTxIPduStatus(PduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   117  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   118  #if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   119  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   120  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Void(uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   121  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   122  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Ptr(boolean isInValidPtr, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   123  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Param_Ptr(boolean isInValidParam, boolean isInValidPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   124                                                                  uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   125  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Ptr_Only(boolean isInValidPtr, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   126  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Param_Only(boolean isInValidParam, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   127  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   128  #endif /*  #if (COM_CONFIGURATION_USE_DET == STD_ON) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   129  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   130  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   131  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   132  LOCAL_INLINE FUNC(void, COM_CODE) Com_CopyTxGroupSignalData( Com_SignalIdType    GrpSignalId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   133                                                               Com_SigMaxType      TxGrpSig_NewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   134                                                               Com_MainFuncType    TxMainFuncId );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   135  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   136  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   137  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   138   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   139   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   140   * Inline function to handle gateway and non-gateway use-case for tx-signal/signalGroup
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   141   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   142  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_ProceedToSendIpdu(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   143                                                  VAR(Com_IpduIdType, AUTOMATIC)          ComTxPduId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   144                                                  VAR(Com_SendIpduInfo, AUTOMATIC)        sendIpduFlag_u16
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   145                                                             );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   146  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   147  #ifdef COM_TxFilters
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   148  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_CheckModeChange(VAR(Com_IpduIdType, AUTOMATIC) TxIpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   149  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   150  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   151  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   152  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   153   * Inline Function Definition
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   154   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   155  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   156  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   157   Function name    : Com_SetCurrentTxModePtr [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   158   Syntax           : void Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   159                                  Com_TxIpduRamPtrType    TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   160                                  Com_TxIpduConstPtrType  TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   161                                  uint16                  TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   162                                  boolean                 ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   163                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   164   Description      : Inline function sets TMS data in to be accessesd via CurrentTxModePtr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   165                      after evaluating TMS mode for the IPdu
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   166  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   167                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   168                       * Mode                  |    Configuration details                              | Value|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   169                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   170                       * COM_MODE_VALID        |    Both the TRUE and FALSE modes are configured.      |    00|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   171                       * COM_TRUEMODE_VALID    |    Only TRUE mode is configured                       |    01|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   172                       * COM_FALSEMODE_VALID   |    Only FALSE mode is configured                      |    10|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   173                       * COM_MODE_INVALID      |    Both the TRUE and FALSE mode are not configured    |    11|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   174                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   175                      This INLINE function checks the TMS generated values against the requested mode and performs action
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   176                      |-------------|--------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   177                      |ModeRequested|Configured Mode values   |         Description                                           :      Action to be taken                |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   178                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   179                      |    0       |      0        |      0   |  FALSE mode is requested and IPdu TMS is COM_MODE_VALID         : Increment to the false mode data     |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   180                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   181                      |    0       |      0        |      1   |  FALSE mode is requested and IPdu TMS is COM_TRUEMODE_VALID     : Point to NONE mode data              |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   182                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   183                      |    0       |      1        |      0   |  FALSE mode is requested and IPdu TMS is COM_FALSEMODE_VALID     : Do nothing                          |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   184                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   185                      |    0       |      1        |      1   |  FALSE mode is requested and IPdu TMS is COM_MODE_INVALID     : Do nothing                             |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   186                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   187                      |    1       |      0        |      0   |  TRUE mode is requested and IPdu TMS is COM_MODE_VALID         : Do nothing                            |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   188                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   189                      |    1       |      0        |      1   |  TRUE mode is requested and IPdu TMS is COM_TRUEMODE_VALID     : Do nothing                            |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   190                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   191                      |    1       |      1        |      0   |  TRUE mode is requested and IPdu TMS is COM_FALSEMODE_VALID     : Point to NONE mode data              |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   192                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   193                      |    1       |      1        |      1   |  TRUE mode is requested and IPdu TMS is COM_MODE_INVALID         : Do nothing                          |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   194                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   195  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   196                      where 0 in column 1 stands for FALSE mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   197                      and   1 in column 1 stands for TRUE mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   198  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   199   Parameter        : TxIpduRamPtr    - pointer to Txipdu ram data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   200                    : TxIPduConstPtr  - pointer to Txipdu Rom data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   201                    : TMSStatus       - pointer to transmission mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   202                    : ModeRequested   - mode requested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   203   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   204   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   205  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   206  FUNC(void, COM_CODE) Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   207                                  Com_TxIpduRamPtrType                TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   208                                  Com_TxIpduConstPtrType              TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   209                                  VAR(uint16,AUTOMATIC)               TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   210                                  VAR(boolean,AUTOMATIC)              ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   211                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   212  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   213      /* Get the latest TM pointer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   214      TxIpduRamPtr->CurrentTxModePtr = TxIPduConstPtr->Com_TMConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   215  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   216      if(ModeRequested == COM_FALSE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   217      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   218          if((TMSStatus) == COM_TRUEMODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   219          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   220              /*If yes,load NONE mode data */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   221              TxIpduRamPtr->CurrentTxModePtr = &Com_NONE_TransModeInfo ;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   222          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   223          if((TMSStatus) == COM_MODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   224          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   225              /*Increment to FALSE mode data, if the FALSE mode is configured */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   226              TxIpduRamPtr->CurrentTxModePtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   227          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   228      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   229      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   230      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   231          if((TMSStatus) == COM_FALSEMODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   232          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   233              TxIpduRamPtr->CurrentTxModePtr = &Com_NONE_TransModeInfo ;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   234          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   235      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   236  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   237  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   238  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   239   Function name    : Com_UpdateRxGroupSignalSecondBuffer [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   240   Syntax           : void Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   241                                  Com_RxGrpSigConstPtrType    RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   242                                  Com_SigMaxType              RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   243                                  Com_MainFuncType            RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   244                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   245   Description      : Inline function copy Group signal value into the Group signal Second buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   246   Parameter        : RxGrpSigConstPtr - pointer to RxGroupSignal configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   247                    : RxNewVal         - latest RxGroupSignal data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   248                    : RxMainFuncId     - Internally generated Rx-MainFunction-Id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   249   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   250   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   251  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   252  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   253  FUNC(void, COM_CODE) Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   254                                  Com_RxGrpSigConstPtrType            RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   255                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   256                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   257                                                          )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   258  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   259      VAR(uint8,AUTOMATIC)    Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   260  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   261      Type = Com_GetValue(RXGRPSIG,_TYPE,RxGrpSigConstPtr->rxGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   262  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   263      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   264      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   265      case 0x00u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   266          /* UINT08 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   267          COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint8)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   268          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   269  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   270      case 0x01u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   271          /* UINT16 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   272          COM_GET_SECRXGRPSIGTYPEU16_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint16)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   273          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   274  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   275      case 0x02u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   276          /* UINT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   277          /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   278      case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   279          /* FLOAT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   280          /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   281          COM_GET_SECRXGRPSIGTYPEU32_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint32)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   282          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   283  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   284  #ifdef COM_RXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   285      case 0x08u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   286          /* UINT64/SINT64 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   287          COM_GET_SECRXGRPSIGTYPEU64_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   288          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   289  #endif /* #ifdef COM_RXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   290  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   291      case 0x03u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   292          /*Boolean Signal*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   293          COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint8)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   294          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   295  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   296      case 0x04u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   297          /* UINT8_N signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   298          Com_ByteCopyInit(&COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index),
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   299                           (uint32)RxNewVal,RxGrpSigConstPtr->BitSize);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   300          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   301      default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   302          /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   303           * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are allowed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   304           * to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   305           */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   306          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   307  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   308      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   309  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   310  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   311  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   312  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   313   Function name    : Com_UpdateRxSignalBuffer [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   314   Syntax           : void Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   315                                  Com_RxSigConstPtrType   RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   316                                  Com_SigMaxType          RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   317                                  Com_MainFuncType        RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   318                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   319   Description      : Inline function to copy signal value into the signal buffer and
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   320                      is used when signal value as a variable is being passed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   321   Parameter        : RxSigConstPtr - pointer to RxSignal configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   322                    : RxNewVal_Sig  - latest RxSignal data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   323                    : RxMainFuncId  - Internally generated Rx-MainFunction-Id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   324   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   325   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   326  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   327  FUNC(void, COM_CODE) Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   328                                  Com_RxSigConstPtrType               RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   329                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   330                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   331                                               )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   332  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   333      VAR(uint8,AUTOMATIC)    Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   334  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   335      Type = Com_GetValue(GEN,_TYPE,RxSigConstPtr->General);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   336  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   337      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   338      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   339      case 0x00u:     /* COM_UINT8 & COM_SINT8 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   340      case (COM_BOOLEAN >> 1):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   341          COM_GET_SIGTYPEUINT8_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint8)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   342          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   343  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   344      case 0x01u:     /* COM_UINT16 & COM_SINT16 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   345          COM_GET_SIGTYPEUINT16_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint16)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   346          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   347  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   348      case 0x02u:     /* COM_UINT32 & COM_SINT32 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   349  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   350          /* COM_FLOAT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   351  #ifdef COM_FLOAT32SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   352      case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   353  #endif /* #ifdef COM_FLOAT32SUPP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   354  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   355          COM_GET_SIGTYPEUINT32_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint32)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   356          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   357  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   358  #ifdef COM_RXSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   359      case 0x08u:     /* COM_UINT64 & COM_SINT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   360          COM_GET_SIGTYPEUINT64_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   361          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   362  #endif /* #if defined(COM_RXSIG_INT64) && defined(COM_TXSIG_INT64) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   363  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   364      case 0x04u:     /* COM_UINT8_N */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   365          Com_ByteCopyInit(&COM_GET_SIGTYPEUINT8_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index),
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   366                           (uint32)RxNewVal_Sig,RxSigConstPtr->BitSize);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   367          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   368      default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   369          /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   370           * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are allowed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   371           * to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   372           */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   373          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   374      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   375  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   376  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   377  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   378   Function name    : Com_InitializePduBuffWithSignalInitValue [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   379   Syntax           : void Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   380                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   381                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   382                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   383                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   384                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   385                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   386                                                                   )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   387   Description      : Inline function to call required interface to pack signal data into Ipdu buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   388   Parameter        : BuffPtr     - pointer to (SignalGroup)IPdu Buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   389                    : SigInitVal  - (Group)Signal InitValue
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   390                    : SigBitPos   - (Group)Signal Bit Position
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   391                    : SigBitSize  - (Group)Signal Bit Size
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   392                    : SigType     - (Group)Signal Type
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   393                    : SigEndianess- (Group)Signal Endianness
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   394   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   395   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   396  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   397  FUNC(void, COM_CODE) Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   398                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   399                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   400                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   401                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   402                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   403                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   404                                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   405  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   406      if ( SigType != (uint8)COM_UINT8_N )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   407      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   408  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   409  #if (defined(COM_TXSIG_FLOAT64SUPP) || defined(COM_TXGRPSIG_FLOAT64SUPP) ||\ 
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   410      (defined(COM_RX_SIGNALGROUP_ARRAY) && defined(COM_RXGRPSIG_FLOAT64SUPP)))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   411          if ( SigType == COM_FLOAT64 )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   412          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   413              /* Convert the float value into 32 bit stream and then pack the value */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   414              /* Com_PackFloatSignal(TxSigConstPtr->General.Endianess,TxSigConstPtr->Bit_Pos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   415                                     Com_getfloat64InitValue(SigNewVal), TxIPduConstPtr->BuffPtr); */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   416              Com_PackFloatSignal( SigEndianess, SigBitPos, Com_getfloat64InitValue(SigInitVal), BuffPtr );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   417          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   418          else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   419  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   420  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   421          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   422              /* Pack the signal with Initial Value */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   423              /* Com_PackSignal(TxSigConstPtr->General.Endianess,TxSigConstPtr->Bit_Pos,TxSigConstPtr->BitSize,SigNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   424               *                TxIPduConstPtr->BuffPtr);*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   425              Com_PackSignal( SigEndianess, SigBitPos, SigBitSize, SigInitVal, BuffPtr );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   426          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   427      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   428      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   429      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   430          PduLengthType ByteOffset_uo;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   431          /* Find the starting byte position(ByteNo_uo) of Signal in the IPDU buffer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   432          ByteOffset_uo = ( PduLengthType )( SigBitPos >> 3 );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   433  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   434          /* Now copy the Signal into the IPDU buffer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   435          Com_ByteCopyInit( (BuffPtr + ByteOffset_uo), (uint32)SigInitVal, SigBitSize );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   436      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   437  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   438  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   439  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   440   Function name    : Com_Prv_SigGrpReplaceToInit
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   441   Syntax           : void Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   442                                          Com_RxSigGrpConstPtrType  RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   443                                          Com_MainFuncType          RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   444                                                      )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   445   Description      : If the SigGrp is enabled with ArrayAccess, RxSigGrpBuffer will be packed with
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   446                      GroupSignal Init Values OR else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   447                      GroupSignals Shadow buffers will be replaced with its Init Values
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   448   Parameter        : RxSigGrpConstPtr - pointer to RxSignalGroup configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   449                    : RxMainFuncId     - Internally generated RxMainFunction-ID
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   450   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   451   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   452  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   453  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   454                                                  Com_RxSigGrpConstPtrType        RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   455                                                  VAR(Com_MainFuncType,AUTOMATIC) RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   456                                                               )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   457  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   458      Com_RxGrpSigConstPtrType      RxGrpSigConstPtr;      /* Local pointer to Rx GroupSignal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   459  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   460      Com_RxSigGrpArrayConstPtrType RxSigGrpArrayConstPtr; /* Local pointer to Rx SignalGroup Array configuration  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   461      uint8                       * RxSigGrpArrayBufRamPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   462      PduLengthType                 SigGrpBitOffset;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   463  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   464      VAR(uint16_least, AUTOMATIC)  index_ui;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   465      VAR(Com_SigMaxType, AUTOMATIC) SigValue;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   466  # if (defined(COM_RX_SIGNALGROUP_ARRAY) || defined(COM_RXGRPSIG_FLOAT64SUPP) || defined(COM_RXGRPSIG_INT64))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   467      VAR(uint8, AUTOMATIC)         SigType;  /* Signal Type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   468  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   469  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   470      boolean                       ConstIsSigGrpOfArrayType_b;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   471  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   472      ConstIsSigGrpOfArrayType_b = Com_GetValue(RXSIGGRP,_ARRAYACCESS,RxSigGrpConstPtr->rxSignalGrpFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   473  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   474      if ( ConstIsSigGrpOfArrayType_b )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   475      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   476          RxSigGrpArrayConstPtr  = COM_GET_RXSIGGRP_ARRAY_CONSTDATA( RxSigGrpConstPtr->SigGrpArray_Index );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   477  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   478          RxSigGrpArrayBufRamPtr = &COM_GET_RXSIGGRP_ARRAY_BUFF(RxMainFuncId, RxSigGrpArrayConstPtr->RxSigGrpBuf_Index );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   479  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   480          SigGrpBitOffset        = ( RxSigGrpArrayConstPtr->FirstByteNo * 8u );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   481  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   482          SchM_Enter_Com_RxSigGrpArrayBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   483      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   484      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   485  # endif /* # ifdef COM_RX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   486      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   487          SchM_Enter_Com_RxGrpSigSecBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   488      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   489  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   490      RxGrpSigConstPtr = COM_GET_RXGRPSIG_CONSTDATA( RxSigGrpConstPtr->FirstGrpSig_Index );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   491  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   492      for ( index_ui = (uint16_least)RxSigGrpConstPtr->No_Of_GrpSig; index_ui != (uint16_least)0; index_ui-- )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   493      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   494  # if (defined(COM_RX_SIGNALGROUP_ARRAY) || defined(COM_RXGRPSIG_FLOAT64SUPP) || defined(COM_RXGRPSIG_INT64))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   495          SigType = Com_GetValue(RXGRPSIG,_TYPE,RxGrpSigConstPtr->rxGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   496  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   497  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   498          SigValue = (Com_SigMaxType)RxGrpSigConstPtr->Init_Val;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   499  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   500  #ifdef COM_RXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   501          /* [SWS_Com_00723] The AUTOSAR COM module shall extend the init value (ComSignalInitValue) of a signal
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   502           * to the size of its ComSignalType.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   503           * Currently for COM_SINT64 signal type, ComSignalInitValue is supported for maximum 32bits.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   504           * If negative values are configured, by default these values will be sign extended only till 32bits.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   505           * so, for COM_SINT64, it is required to perform the sign extension till 64bits explicity. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   506          SigValue = (SigType == COM_SINT64) ? (Com_SigMaxType)((sint64)((sint32)SigValue)) : SigValue;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   507  #endif /* #ifdef COM_RXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   508  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   509  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   510          if ( ConstIsSigGrpOfArrayType_b )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   511          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   512              Com_BitpositionType RelativeSigBitPos; /* Relative BitPosition in RxSignalGroup Array */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   513  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   514              /* The Buffer into which Signal Values needs to be packed will be available with starting address
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   515               * of the Rx-SignalGroup Array Buffer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   516               * But we have GroupSignal: Bit_Pos, i.e., Signal's actual LSB in the IPdu Buffer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   517               * So, Rx-SignalGroup BitOffset(SigGrpBitOffset) is removed from each of the GroupSignal and
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   518               * is used as BitPosition to pack its value into the Rx-SignalGroup Array Buffer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   519              RelativeSigBitPos = RxGrpSigConstPtr->Bit_Pos - ( Com_BitpositionType )SigGrpBitOffset;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   520  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   521              Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   522                                                RxSigGrpArrayBufRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   523                                                SigValue,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   524                                                RelativeSigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   525                                                RxGrpSigConstPtr->BitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   526                                                SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   527                                                Com_GetValue(RXGRPSIG,_ENDIANESS,RxGrpSigConstPtr->rxGrpSigFields) );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   528          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   529          else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   530  # endif /* #ifdef COM_RX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   531          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   532  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   533  # ifdef COM_RXGRPSIG_FLOAT64SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   534              if(SigType == COM_FLOAT64)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   535              {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   536                  COM_GET_SECRXGRPSIGTYPEFLOAT64_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) =
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   537                                                                        Com_getfloat64InitValue(SigValue);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   538              }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   539              else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   540  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   541  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   542              {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   543                  Com_UpdateRxGroupSignalSecondBuffer(RxGrpSigConstPtr, SigValue, RxMainFuncId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   544              }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   545          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   546  # if defined(COM_RxFilters) && defined(COM_F_MASKEDNEWDIFFERSOLD)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   547          /* [SWS_Com_00603] The AUTOSAR COM module shall set the old_value of the filtering mechanisms
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   548           * for each signal to the ComSignalInitValue during start-up */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   549          if ( ( COM_INIT != Com_Uninit_Flag ) && ( COM_MASKED_NEW_DIFFERS_MASKED_OLD == RxGrpSigConstPtr->Filter_Algo ) )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   550          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   551              COM_GET_F_OLDVALUE(RxGrpSigConstPtr->Filter_Index) = (uint32)SigValue;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   552          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   553  # endif /* # if defined(COM_RxFilters) && defined(COM_F_MASKEDNEWDIFFERSOLD) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   554  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   555          RxGrpSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   556      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   557  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   558  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   559      if ( ConstIsSigGrpOfArrayType_b )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   560      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   561          SchM_Exit_Com_RxSigGrpArrayBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   562      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   563      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   564  # endif /* # ifdef COM_RX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   565      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   566          SchM_Exit_Com_RxGrpSigSecBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   567      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   568  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   569  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   570  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   571  #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   572  #ifdef COM_TxIPduNotification
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   573  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxNotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   574          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   575      Com_TxIpduConstPtrType TxIPduConstPtr;    /* Local pointer to Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   576      Com_TxSigConstPtrType TxSigConstPtr;    /* Local pointer to Tx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   577  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   578      Com_TxSigGrpConstPtrType TxSigGrpConstPtr; /* Local pointer to hold the address of Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   579  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   580      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   581  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   582      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   583      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   584      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   585  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   586      IpduId = COM_GET_TX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   587      TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   588      TxSigConstPtr = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   589  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   590      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(TxIPduConstPtr->FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   591  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   592  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   593      for(index_u8 = TxIPduConstPtr->TxSigId_Index; index_u8 < (TxIPduConstPtr->TxSigId_Index + TxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   594      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   595          if(TxSigConstPtr->Notification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   596          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   597              TxSigConstPtr->Notification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   598          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   599          TxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   600      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   601  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   602      for(index_u8 = TxIPduConstPtr->FirstTxSigGrp_Index; index_u8 < (TxIPduConstPtr->FirstTxSigGrp_Index + TxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   603      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   604          if(TxSigGrpConstPtr->Notification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   605          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   606              TxSigGrpConstPtr->Notification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   607          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   608          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   609      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   610  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   611  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   612          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   613  #endif /* #ifdef COM_TxIPduNotification */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   614  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   615  #ifdef COM_ERRORNOTIFICATION
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   616  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxErrNotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   617  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   618  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   619      Com_TxIpduConstPtrType TxIPduConstPtr;    /* Local pointer to Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   620      Com_TxSigConstPtrType TxSigConstPtr;    /* Local pointer to Tx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   621  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   622      Com_TxSigGrpConstPtrType TxSigGrpConstPtr; /* Local pointer to hold the address of Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   623  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   624      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   625  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   626      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   627      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   628      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   629  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   630      IpduId = COM_GET_TX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   631      TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   632      TxSigConstPtr = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   633  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   634      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(TxIPduConstPtr->FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   635  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   636  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   637      for(index_u8 = TxIPduConstPtr->TxSigId_Index; index_u8 < (TxIPduConstPtr->TxSigId_Index + TxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   638      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   639          if(TxSigConstPtr->NotificationError_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   640          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   641              TxSigConstPtr->NotificationError_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   642          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   643          TxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   644      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   645  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   646      for(index_u8 = TxIPduConstPtr->FirstTxSigGrp_Index; index_u8 < (TxIPduConstPtr->FirstTxSigGrp_Index + TxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   647      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   648          if(TxSigGrpConstPtr->NotificationError_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   649          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   650              TxSigGrpConstPtr->NotificationError_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   651          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   652          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   653      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   654  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   655  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   656  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   657  #endif /* #ifdef COM_ERRORNOTIFICATION */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   658  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   659  #ifdef COM_TxIPduTimeOutNotify
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   660  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxTONotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   661  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   662  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   663      Com_TxIpduConstPtrType TxIPduConstPtr;    /* Local pointer to Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   664      Com_TxSigConstPtrType TxSigConstPtr;    /* Local pointer to Tx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   665  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   666      Com_TxSigGrpConstPtrType TxSigGrpConstPtr; /* Local pointer to hold the address of Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   667  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   668      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   669  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   670      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   671      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   672      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   673  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   674      IpduId = COM_GET_TX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   675      TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   676      TxSigConstPtr = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   677  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   678      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(TxIPduConstPtr->FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   679  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   680  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   681      for(index_u8 = TxIPduConstPtr->TxSigId_Index; index_u8 < (TxIPduConstPtr->TxSigId_Index + TxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   682      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   683          if(TxSigConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   684          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   685              TxSigConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   686          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   687          TxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   688      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   689  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   690      for(index_u8 = TxIPduConstPtr->FirstTxSigGrp_Index; index_u8 < (TxIPduConstPtr->FirstTxSigGrp_Index + TxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   691      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   692          if(TxSigGrpConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   693          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   694              TxSigGrpConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   695          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   696          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   697      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   698  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   699  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   700  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   701  #endif /* #ifdef COM_TxIPduTimeOutNotify */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   702  #ifdef COM_RxIPduTimeoutNotify
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   703  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallRxTONotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   704  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   705  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   706      Com_RxIpduConstPtrType RxIPduConstPtr;    /* Local pointer to Rx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   707      Com_RxSigConstPtrType RxSigConstPtr;    /* Local pointer to Rx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   708  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   709      Com_RxSigGrpConstPtrType RxSigGrpConstPtr; /* Local pointer to hold the address of Rx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   710  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   711      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   712  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   713      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   714      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   715      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   716  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   717      IpduId = COM_GET_RX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   718      RxIPduConstPtr = COM_GET_RX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   719      RxSigConstPtr = COM_GET_RXSIG_CONSTDATA(RxIPduConstPtr->RxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   720  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   721      RxSigGrpConstPtr = COM_GET_RXSIGGRP_CONSTDATA(RxIPduConstPtr->FirstRxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   722  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   723  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   724      for(index_u8 = RxIPduConstPtr->RxSigId_Index; index_u8 < (RxIPduConstPtr->RxSigId_Index + RxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   725      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   726          if(RxSigConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   727          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   728              RxSigConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   729          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   730          RxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   731      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   732  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   733      for(index_u8 = RxIPduConstPtr->FirstRxSigGrp_Index; index_u8 < (RxIPduConstPtr->FirstRxSigGrp_Index + RxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   734      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   735          if(RxSigGrpConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   736          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   737              RxSigGrpConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   738          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   739          RxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   740      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   741  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   742  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   743  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   744  #endif /* #ifdef COM_RxIPduTimeoutNotify */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   745  #endif /* #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   746  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   747  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   748  LOCAL_INLINE FUNC(void, COM_CODE) Com_CopyTxGroupSignalData( Com_SignalIdType    GrpSignalId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   749                                                               Com_SigMaxType      TxGrpSig_NewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   750                                                               Com_MainFuncType    TxMainFuncId )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   751  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   752      Com_TxGrpSigConstPtrType                   TxGrpSigConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   753      VAR(Com_TxGrpSigBuffIndexType, AUTOMATIC)  GrpSigBuff_Index;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   754      VAR(uint8, AUTOMATIC)                      Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   755  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   756      TxGrpSigConstPtr = COM_GET_TXGRPSIG_CONSTDATA(GrpSignalId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   757      GrpSigBuff_Index = TxGrpSigConstPtr->TxGrpSigBuff_Index;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   758      Type = Com_GetValue(TXGRPSIG,_TYPE,TxGrpSigConstPtr->txGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   759  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   760      SchM_Enter_Com_TxGrpSigBuffer();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   761      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   762      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   763  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   764          case 0x00u: /* UINT8 and SINT8 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   765          case 0x03u: /* Boolean type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   766              COM_GET_TXGRPSIGTYPEU8_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint8)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   767              break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   768  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   769          /* UINT16 and SINT16 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   770          case 0x01u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   771              COM_GET_TXGRPSIGTYPEU16_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint16)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   772              break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   773  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   774          /* UINT32,SINT32 and FLOAT32 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   775          case 0x02u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   776          /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   777  #ifdef COM_FLOAT32SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   778          case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   779  #endif /* #ifdef COM_FLOAT32SUPP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   780          /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   781              COM_GET_TXGRPSIGTYPEU32_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint32)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   782              break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   783  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   784          /* UINT64 and SINT64 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   785  #ifdef COM_TXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   786          case 0x08u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   787              COM_GET_TXGRPSIGTYPEU64_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint64)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   788          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   789  #endif /* #ifdef COM_TXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   790  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   791          default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   792              /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   793               * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   794               * allowed to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   795               */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   796          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   797     }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   798      SchM_Exit_Com_TxGrpSigBuffer();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   799  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   800  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   801  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   802  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   803  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   804  #if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   805  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   806  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   807   Function name    : Com_Prv_DETCheck_Void
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   808   Syntax           : boolean Com_Prv_DETCheck_Void(uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   809   Description      : Inline function to check for module initialization
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   810   Parameter        : ApiId - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   811   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   812                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   813   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   814  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Void(uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   815  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   816      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   817      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   818  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   819      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   820      Status  = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   821  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   822      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   823      if (Com_Uninit_Flag == COM_UNINIT)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   824      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   825          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   826          COM_REPORT_ERROR_CHECK(ApiId, COM_E_UNINIT);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   827          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   828          Status = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   829      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   830      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   831      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   832          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   833      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   834  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   835      return Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   836  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   837  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   838  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   839   Function name    : Com_Prv_DETCheck_Param
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   840   Syntax           : boolean Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   841   Description      : Inline function to check for module initialization and valid parameter value.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   842   Parameter        : isInValidParam - calling service is called with invalid parameter value
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   843                      ApiId          - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   844   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   845                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   846   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   847  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   848  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   849      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   850      uint8   ErrorId;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   851      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   852  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   853      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   854      ErrorId = COM_DET_NO_ERROR;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   855      Status  = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   856  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   857      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   858      if (Com_Uninit_Flag == COM_UNINIT)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   859      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   860          ErrorId = COM_E_UNINIT;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   861      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   862      else if (isInValidParam)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   863      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   864          ErrorId = COM_E_PARAM;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   865      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   866      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   867      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   868          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   869      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   870  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   871      /* Check if ErrorId has Error Code */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   872      if (ErrorId != COM_DET_NO_ERROR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   873      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   874          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   875          COM_REPORT_ERROR_CHECK(ApiId, ErrorId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   876          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   877          Status = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   878      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   879      return Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   880  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   881  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   882  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   883   Function name    : Com_Prv_DETCheck_Ptr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   884   Syntax           : boolean Com_Prv_DETCheck_Ptr(boolean isInValidPtr, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   885   Description      : Inline function to check for module initialization and valid pointer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   886   Parameter        : isInValidPtr - calling service is called with invalid pointer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   887                      ApiId        - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   888   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   889                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   890   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   891  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Ptr(boolean isInValidPtr, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   892  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   893      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   894      uint8   ErrorId;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   895      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   896  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   897      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   898      ErrorId = COM_DET_NO_ERROR;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   899      Status  = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   900  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   901      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   902      if (Com_Uninit_Flag == COM_UNINIT)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   903      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   904          ErrorId = COM_E_UNINIT;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   905      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   906      else if (isInValidPtr)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   907      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   908          ErrorId = COM_E_PARAM_POINTER;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   909      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   910      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   911      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   912          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   913      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   914  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   915      /* Check if ErrorId has Error Code */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   916      if (ErrorId != COM_DET_NO_ERROR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   917      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   918          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   919          COM_REPORT_ERROR_CHECK(ApiId, ErrorId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   920          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   921          Status = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   922      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   923      return Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   924  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   925  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   926  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   927   Function name    : Com_Prv_DETCheck_Param_Ptr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   928   Syntax           : boolean Com_Prv_DETCheck_Param_Ptr(boolean isInValidParam, boolean isInValidPtr, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   929   Description      : Inline function to check for module initialization, valid parameter value and valid pointer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   930   Parameter        : isInValidParam - calling service is called with invalid parameter value
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   931                      isInValidPtr   - calling service is called with invalid pointer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   932                      ApiId          - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   933   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   934                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   935   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   936  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Param_Ptr(boolean isInValidParam, boolean isInValidPtr, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   937  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   938      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   939      uint8   ErrorId;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   940      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   941  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   942      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   943      ErrorId = COM_DET_NO_ERROR;
	mov	d7,#255
.L127:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   944      Status  = COM_TRUE;
	mov	d2,#1
.L128:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   945  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   946      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   947      if (Com_Uninit_Flag == COM_UNINIT)
	movh.a	a15,#@his(Com_Uninit_Flag)
	lea	a15,[a15]@los(Com_Uninit_Flag)
	ld.w	d15,[a15]
.L168:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   947      if (Com_Uninit_Flag == COM_UNINIT)      (inlined)
	jne	d15,#0,.L2
.L169:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   948      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   949          ErrorId = COM_E_UNINIT;
	mov	d7,#2
.L170:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   949          ErrorId = COM_E_UNINIT;      (inlined)
	j	.L3

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   947      if (Com_Uninit_Flag == COM_UNINIT)      (inlined)
.L2:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   951      else if (isInValidParam)      (inlined)
	jeq	d0,#0,.L4
.L171:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   950      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   951      else if (isInValidParam)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   952      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   953          ErrorId = COM_E_PARAM;
	mov	d7,#1
.L172:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   953          ErrorId = COM_E_PARAM;      (inlined)
	j	.L5

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   951      else if (isInValidParam)      (inlined)
.L4:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   955      else if (isInValidPtr)      (inlined)
	jeq	d1,#0,.L6
.L173:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   954      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   955      else if (isInValidPtr)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   956      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   957          ErrorId = COM_E_PARAM_POINTER;
	mov	d7,#3
.L174:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   957          ErrorId = COM_E_PARAM_POINTER;      (inlined)
	j	.L7

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   955      else if (isInValidPtr)      (inlined)
.L6:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   959      else      (inlined)
.L7:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   955      else if (isInValidPtr)      (inlined)
.L5:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   951      else if (isInValidParam)      (inlined)
.L3:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   958      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   959      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   960      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   961          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   962      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   963  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   964      /* Check if ErrorId has Error Code */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   965      if (ErrorId != COM_DET_NO_ERROR)
	mov	d15,#255
.L175:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   965      if (ErrorId != COM_DET_NO_ERROR)      (inlined)
	jeq	d15,d7,.L8
.L176:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   966      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   967          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   968          COM_REPORT_ERROR_CHECK(ApiId, ErrorId);
	mov	d4,#50
.L122:
	mov	d5,#0
	call	Det_ReportError
.L121:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   969          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   970          Status = COM_FALSE;
	mov	d2,#0

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   965      if (ErrorId != COM_DET_NO_ERROR)      (inlined)
.L8:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   972      return Status;      (inlined)
	j	.L9

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   973  }      (inlined)
.L9:
	jeq	d2,#0,.L10
.L63:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    40  #endif
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    41      {
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    42          /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    43           * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    44           * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    45  
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    46          SignalId = COM_GET_RXSIGNAL_ID(SignalId);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    47  
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    48          RxSigConstPtr = COM_GET_RXSIG_CONSTDATA(SignalId);
	movh.a	a2,#@his(Com_Prv_xRxSigCfg_acst)
	lea	a2,[a2]@los(Com_Prv_xRxSigCfg_acst)
	sha	d15,d8,#4
	addsc.a	a15,a2,d15,#0
.L130:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    49  
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    50          SigType = Com_GetValue(GEN,_TYPE,RxSigConstPtr->General);
	ld.bu	d15,[a15]12
	mov	d1,#5
.L74:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
	sha	d0,d15,#0
.L177:
	mov	d15,#255
.L178:
	rsub	d1,d1,#8
.L179:
	rsub	d1,#0
	sh	d15,d15,d1
.L180:
	and	d0,d15
.L181:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));      (inlined)
	j	.L11

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }      (inlined)
.L11:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    51          /*Check if Ipdu Group is started*/
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    52          /* MR12 RULE 13.5 VIOLATION: Below conditional statement reads flag status. Evaluation(or no evaluation)
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    53           * of the 2nd or 3rd operands does not impact the system behaviour even though of volatile-qualified,
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    54           * moreover HIS-LEVEL parameter will be violated if more conditional statements are added.
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    55           * Hence the warning is suppressed. */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    56          if(Com_CheckRxIPduStatus((PduIdType)RxSigConstPtr->IpduRef))
	ld.bu	d15,[a15]11
.L83:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     1  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     2  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     3  #ifndef COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     4  #define COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     5  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     6  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     7   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     8   * Includes
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	     9   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    10  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    11  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    12  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    13  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    15   * Defines/Macros
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    16   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    17  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    18  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    19  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    20  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    21   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    22   * Type definitions
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    23   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    24  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    25  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    26  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    27  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    28   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    29   * Variables
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    30   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    31  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    32  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    33  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    34  /*
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    35   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    36   * Extern declarations
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    37   **********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    38  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    39  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    40   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    41   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    42   * Inline function sets TMS data in to be accessesd via CurrentTxModePtr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    43   * after evaluating TMS mode for the IPdu
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    44   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    45  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    46  FUNC(void, COM_CODE) Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    47                                  Com_TxIpduRamPtrType                TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    48                                  Com_TxIpduConstPtrType              TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    49                                  VAR(uint16,AUTOMATIC)               TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    50                                  VAR(boolean,AUTOMATIC)              ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    51                                              );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    52  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    53  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    54   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    55   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    56   * Inline function to update Rx-GroupSignal application buffers
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    57   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    58  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    59  FUNC(void, COM_CODE) Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    60                                  Com_RxSigConstPtrType               RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    61                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    62                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    63                                               );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    64  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    65  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    66   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    67   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    68   * Inline function to update Rx-GroupSignal secondary buffers
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    69   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    70  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    71  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    72  FUNC(void, COM_CODE) Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    73                                  Com_RxGrpSigConstPtrType            RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    74                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    75                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    76                                                          );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    77  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    78  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    79  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    80   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    81   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    82   * Inline function to initialize signal intial value into the provided IPdu buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    83   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    84  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    85  FUNC(void, COM_CODE) Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    86                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    87                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    88                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    89                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    90                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    91                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    92                                                              );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    93  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    94  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    95   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    96   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    97   * Inline function to initialize Rx-signal group with initial values
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    98   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	    99  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   100  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   101  FUNC(void, COM_CODE) Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   102                                  Com_RxSigGrpConstPtrType            RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   103                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   104                                                  );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   105  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   106  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   107  #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   108  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxNotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   109  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxErrNotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   110  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxTONotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   111  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallRxTONotifyCallback(Com_IpduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   112  #endif /* #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   113  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   114  /* Inline function to check for the RxIPdu and TxIpdu status*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   115  LOCAL_INLINE boolean Com_CheckRxIPduStatus(PduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   116  LOCAL_INLINE boolean Com_CheckTxIPduStatus(PduIdType IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   117  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   118  #if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   119  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   120  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Void(uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   121  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   122  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Ptr(boolean isInValidPtr, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   123  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_DETCheck_Param_Ptr(boolean isInValidParam, boolean isInValidPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   124                                                                  uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   125  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Ptr_Only(boolean isInValidPtr, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   126  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Param_Only(boolean isInValidParam, uint8 ApiId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   127  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   128  #endif /*  #if (COM_CONFIGURATION_USE_DET == STD_ON) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   129  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   130  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   131  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   132  LOCAL_INLINE FUNC(void, COM_CODE) Com_CopyTxGroupSignalData( Com_SignalIdType    GrpSignalId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   133                                                               Com_SigMaxType      TxGrpSig_NewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   134                                                               Com_MainFuncType    TxMainFuncId );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   135  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   136  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   137  /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   138   * @ingroup COM_PRV_INL_H
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   139   *
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   140   * Inline function to handle gateway and non-gateway use-case for tx-signal/signalGroup
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   141   */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   142  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_ProceedToSendIpdu(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   143                                                  VAR(Com_IpduIdType, AUTOMATIC)          ComTxPduId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   144                                                  VAR(Com_SendIpduInfo, AUTOMATIC)        sendIpduFlag_u16
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   145                                                             );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   146  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   147  #ifdef COM_TxFilters
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   148  LOCAL_INLINE FUNC(boolean, COM_CODE) Com_Prv_CheckModeChange(VAR(Com_IpduIdType, AUTOMATIC) TxIpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   149  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   150  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   151  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   152  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   153   * Inline Function Definition
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   154   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   155  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   156  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   157   Function name    : Com_SetCurrentTxModePtr [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   158   Syntax           : void Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   159                                  Com_TxIpduRamPtrType    TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   160                                  Com_TxIpduConstPtrType  TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   161                                  uint16                  TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   162                                  boolean                 ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   163                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   164   Description      : Inline function sets TMS data in to be accessesd via CurrentTxModePtr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   165                      after evaluating TMS mode for the IPdu
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   166  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   167                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   168                       * Mode                  |    Configuration details                              | Value|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   169                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   170                       * COM_MODE_VALID        |    Both the TRUE and FALSE modes are configured.      |    00|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   171                       * COM_TRUEMODE_VALID    |    Only TRUE mode is configured                       |    01|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   172                       * COM_FALSEMODE_VALID   |    Only FALSE mode is configured                      |    10|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   173                       * COM_MODE_INVALID      |    Both the TRUE and FALSE mode are not configured    |    11|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   174                      ----------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   175                      This INLINE function checks the TMS generated values against the requested mode and performs action
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   176                      |-------------|--------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   177                      |ModeRequested|Configured Mode values   |         Description                                           :      Action to be taken                |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   178                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   179                      |    0       |      0        |      0   |  FALSE mode is requested and IPdu TMS is COM_MODE_VALID         : Increment to the false mode data     |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   180                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   181                      |    0       |      0        |      1   |  FALSE mode is requested and IPdu TMS is COM_TRUEMODE_VALID     : Point to NONE mode data              |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   182                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   183                      |    0       |      1        |      0   |  FALSE mode is requested and IPdu TMS is COM_FALSEMODE_VALID     : Do nothing                          |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   184                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   185                      |    0       |      1        |      1   |  FALSE mode is requested and IPdu TMS is COM_MODE_INVALID     : Do nothing                             |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   186                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   187                      |    1       |      0        |      0   |  TRUE mode is requested and IPdu TMS is COM_MODE_VALID         : Do nothing                            |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   188                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   189                      |    1       |      0        |      1   |  TRUE mode is requested and IPdu TMS is COM_TRUEMODE_VALID     : Do nothing                            |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   190                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   191                      |    1       |      1        |      0   |  TRUE mode is requested and IPdu TMS is COM_FALSEMODE_VALID     : Point to NONE mode data              |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   192                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   193                      |    1       |      1        |      1   |  TRUE mode is requested and IPdu TMS is COM_MODE_INVALID         : Do nothing                          |
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   194                      |------------|---------------|----------|--------------------------------------------------------------------------------------------------------|
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   195  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   196                      where 0 in column 1 stands for FALSE mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   197                      and   1 in column 1 stands for TRUE mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   198  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   199   Parameter        : TxIpduRamPtr    - pointer to Txipdu ram data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   200                    : TxIPduConstPtr  - pointer to Txipdu Rom data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   201                    : TMSStatus       - pointer to transmission mode
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   202                    : ModeRequested   - mode requested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   203   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   204   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   205  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   206  FUNC(void, COM_CODE) Com_SetCurrentTxModePtr(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   207                                  Com_TxIpduRamPtrType                TxIpduRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   208                                  Com_TxIpduConstPtrType              TxIPduConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   209                                  VAR(uint16,AUTOMATIC)               TMSStatus,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   210                                  VAR(boolean,AUTOMATIC)              ModeRequested
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   211                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   212  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   213      /* Get the latest TM pointer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   214      TxIpduRamPtr->CurrentTxModePtr = TxIPduConstPtr->Com_TMConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   215  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   216      if(ModeRequested == COM_FALSE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   217      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   218          if((TMSStatus) == COM_TRUEMODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   219          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   220              /*If yes,load NONE mode data */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   221              TxIpduRamPtr->CurrentTxModePtr = &Com_NONE_TransModeInfo ;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   222          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   223          if((TMSStatus) == COM_MODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   224          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   225              /*Increment to FALSE mode data, if the FALSE mode is configured */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   226              TxIpduRamPtr->CurrentTxModePtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   227          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   228      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   229      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   230      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   231          if((TMSStatus) == COM_FALSEMODE_VALID)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   232          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   233              TxIpduRamPtr->CurrentTxModePtr = &Com_NONE_TransModeInfo ;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   234          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   235      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   236  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   237  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   238  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   239   Function name    : Com_UpdateRxGroupSignalSecondBuffer [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   240   Syntax           : void Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   241                                  Com_RxGrpSigConstPtrType    RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   242                                  Com_SigMaxType              RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   243                                  Com_MainFuncType            RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   244                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   245   Description      : Inline function copy Group signal value into the Group signal Second buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   246   Parameter        : RxGrpSigConstPtr - pointer to RxGroupSignal configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   247                    : RxNewVal         - latest RxGroupSignal data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   248                    : RxMainFuncId     - Internally generated Rx-MainFunction-Id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   249   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   250   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   251  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   252  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   253  FUNC(void, COM_CODE) Com_UpdateRxGroupSignalSecondBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   254                                  Com_RxGrpSigConstPtrType            RxGrpSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   255                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   256                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   257                                                          )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   258  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   259      VAR(uint8,AUTOMATIC)    Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   260  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   261      Type = Com_GetValue(RXGRPSIG,_TYPE,RxGrpSigConstPtr->rxGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   262  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   263      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   264      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   265      case 0x00u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   266          /* UINT08 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   267          COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint8)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   268          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   269  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   270      case 0x01u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   271          /* UINT16 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   272          COM_GET_SECRXGRPSIGTYPEU16_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint16)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   273          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   274  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   275      case 0x02u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   276          /* UINT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   277          /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   278      case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   279          /* FLOAT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   280          /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   281          COM_GET_SECRXGRPSIGTYPEU32_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint32)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   282          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   283  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   284  #ifdef COM_RXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   285      case 0x08u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   286          /* UINT64/SINT64 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   287          COM_GET_SECRXGRPSIGTYPEU64_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   288          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   289  #endif /* #ifdef COM_RXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   290  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   291      case 0x03u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   292          /*Boolean Signal*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   293          COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) = (uint8)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   294          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   295  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   296      case 0x04u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   297          /* UINT8_N signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   298          Com_ByteCopyInit(&COM_GET_SECRXGRPSIGTYPEU8_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index),
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   299                           (uint32)RxNewVal,RxGrpSigConstPtr->BitSize);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   300          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   301      default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   302          /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   303           * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are allowed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   304           * to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   305           */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   306          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   307  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   308      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   309  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   310  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   311  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   312  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   313   Function name    : Com_UpdateRxSignalBuffer [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   314   Syntax           : void Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   315                                  Com_RxSigConstPtrType   RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   316                                  Com_SigMaxType          RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   317                                  Com_MainFuncType        RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   318                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   319   Description      : Inline function to copy signal value into the signal buffer and
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   320                      is used when signal value as a variable is being passed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   321   Parameter        : RxSigConstPtr - pointer to RxSignal configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   322                    : RxNewVal_Sig  - latest RxSignal data
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   323                    : RxMainFuncId  - Internally generated Rx-MainFunction-Id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   324   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   325   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   326  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   327  FUNC(void, COM_CODE) Com_UpdateRxSignalBuffer(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   328                                  Com_RxSigConstPtrType               RxSigConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   329                                  VAR(Com_SigMaxType, AUTOMATIC)      RxNewVal_Sig,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   330                                  VAR(Com_MainFuncType,AUTOMATIC)     RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   331                                               )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   332  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   333      VAR(uint8,AUTOMATIC)    Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   334  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   335      Type = Com_GetValue(GEN,_TYPE,RxSigConstPtr->General);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   336  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   337      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   338      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   339      case 0x00u:     /* COM_UINT8 & COM_SINT8 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   340      case (COM_BOOLEAN >> 1):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   341          COM_GET_SIGTYPEUINT8_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint8)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   342          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   343  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   344      case 0x01u:     /* COM_UINT16 & COM_SINT16 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   345          COM_GET_SIGTYPEUINT16_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint16)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   346          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   347  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   348      case 0x02u:     /* COM_UINT32 & COM_SINT32 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   349  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   350          /* COM_FLOAT32 signal */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   351  #ifdef COM_FLOAT32SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   352      case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   353  #endif /* #ifdef COM_FLOAT32SUPP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   354  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   355          COM_GET_SIGTYPEUINT32_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = (uint32)RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   356          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   357  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   358  #ifdef COM_RXSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   359      case 0x08u:     /* COM_UINT64 & COM_SINT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   360          COM_GET_SIGTYPEUINT64_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index) = RxNewVal_Sig;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   361          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   362  #endif /* #if defined(COM_RXSIG_INT64) && defined(COM_TXSIG_INT64) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   363  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   364      case 0x04u:     /* COM_UINT8_N */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   365          Com_ByteCopyInit(&COM_GET_SIGTYPEUINT8_BUFF(RxMainFuncId,RxSigConstPtr->SigBuff_Index),
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   366                           (uint32)RxNewVal_Sig,RxSigConstPtr->BitSize);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   367          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   368      default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   369          /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   370           * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are allowed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   371           * to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   372           */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   373          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   374      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   375  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   376  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   377  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   378   Function name    : Com_InitializePduBuffWithSignalInitValue [Non-AUTOSAR]
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   379   Syntax           : void Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   380                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   381                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   382                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   383                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   384                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   385                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   386                                                                   )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   387   Description      : Inline function to call required interface to pack signal data into Ipdu buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   388   Parameter        : BuffPtr     - pointer to (SignalGroup)IPdu Buffer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   389                    : SigInitVal  - (Group)Signal InitValue
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   390                    : SigBitPos   - (Group)Signal Bit Position
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   391                    : SigBitSize  - (Group)Signal Bit Size
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   392                    : SigType     - (Group)Signal Type
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   393                    : SigEndianess- (Group)Signal Endianness
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   394   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   395   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   396  LOCAL_INLINE
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   397  FUNC(void, COM_CODE) Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   398                                  P2VAR(uint8,AUTOMATIC,COM_APPL_DATA)    BuffPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   399                                  VAR(Com_SigMaxType,AUTOMATIC)           SigInitVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   400                                  VAR(Com_BitpositionType,AUTOMATIC)      SigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   401                                  VAR(Com_BitsizeType,AUTOMATIC)          SigBitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   402                                  VAR(uint8,AUTOMATIC)                    SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   403                                  VAR(uint8,AUTOMATIC)                    SigEndianess
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   404                                                              )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   405  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   406      if ( SigType != (uint8)COM_UINT8_N )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   407      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   408  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   409  #if (defined(COM_TXSIG_FLOAT64SUPP) || defined(COM_TXGRPSIG_FLOAT64SUPP) ||\ 
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   410      (defined(COM_RX_SIGNALGROUP_ARRAY) && defined(COM_RXGRPSIG_FLOAT64SUPP)))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   411          if ( SigType == COM_FLOAT64 )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   412          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   413              /* Convert the float value into 32 bit stream and then pack the value */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   414              /* Com_PackFloatSignal(TxSigConstPtr->General.Endianess,TxSigConstPtr->Bit_Pos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   415                                     Com_getfloat64InitValue(SigNewVal), TxIPduConstPtr->BuffPtr); */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   416              Com_PackFloatSignal( SigEndianess, SigBitPos, Com_getfloat64InitValue(SigInitVal), BuffPtr );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   417          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   418          else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   419  #endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   420  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   421          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   422              /* Pack the signal with Initial Value */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   423              /* Com_PackSignal(TxSigConstPtr->General.Endianess,TxSigConstPtr->Bit_Pos,TxSigConstPtr->BitSize,SigNewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   424               *                TxIPduConstPtr->BuffPtr);*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   425              Com_PackSignal( SigEndianess, SigBitPos, SigBitSize, SigInitVal, BuffPtr );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   426          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   427      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   428      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   429      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   430          PduLengthType ByteOffset_uo;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   431          /* Find the starting byte position(ByteNo_uo) of Signal in the IPDU buffer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   432          ByteOffset_uo = ( PduLengthType )( SigBitPos >> 3 );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   433  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   434          /* Now copy the Signal into the IPDU buffer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   435          Com_ByteCopyInit( (BuffPtr + ByteOffset_uo), (uint32)SigInitVal, SigBitSize );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   436      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   437  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   438  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   439  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   440   Function name    : Com_Prv_SigGrpReplaceToInit
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   441   Syntax           : void Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   442                                          Com_RxSigGrpConstPtrType  RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   443                                          Com_MainFuncType          RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   444                                                      )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   445   Description      : If the SigGrp is enabled with ArrayAccess, RxSigGrpBuffer will be packed with
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   446                      GroupSignal Init Values OR else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   447                      GroupSignals Shadow buffers will be replaced with its Init Values
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   448   Parameter        : RxSigGrpConstPtr - pointer to RxSignalGroup configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   449                    : RxMainFuncId     - Internally generated RxMainFunction-ID
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   450   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   451   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   452  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   453  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_SigGrpReplaceToInit(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   454                                                  Com_RxSigGrpConstPtrType        RxSigGrpConstPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   455                                                  VAR(Com_MainFuncType,AUTOMATIC) RxMainFuncId
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   456                                                               )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   457  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   458      Com_RxGrpSigConstPtrType      RxGrpSigConstPtr;      /* Local pointer to Rx GroupSignal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   459  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   460      Com_RxSigGrpArrayConstPtrType RxSigGrpArrayConstPtr; /* Local pointer to Rx SignalGroup Array configuration  */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   461      uint8                       * RxSigGrpArrayBufRamPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   462      PduLengthType                 SigGrpBitOffset;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   463  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   464      VAR(uint16_least, AUTOMATIC)  index_ui;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   465      VAR(Com_SigMaxType, AUTOMATIC) SigValue;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   466  # if (defined(COM_RX_SIGNALGROUP_ARRAY) || defined(COM_RXGRPSIG_FLOAT64SUPP) || defined(COM_RXGRPSIG_INT64))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   467      VAR(uint8, AUTOMATIC)         SigType;  /* Signal Type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   468  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   469  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   470      boolean                       ConstIsSigGrpOfArrayType_b;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   471  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   472      ConstIsSigGrpOfArrayType_b = Com_GetValue(RXSIGGRP,_ARRAYACCESS,RxSigGrpConstPtr->rxSignalGrpFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   473  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   474      if ( ConstIsSigGrpOfArrayType_b )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   475      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   476          RxSigGrpArrayConstPtr  = COM_GET_RXSIGGRP_ARRAY_CONSTDATA( RxSigGrpConstPtr->SigGrpArray_Index );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   477  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   478          RxSigGrpArrayBufRamPtr = &COM_GET_RXSIGGRP_ARRAY_BUFF(RxMainFuncId, RxSigGrpArrayConstPtr->RxSigGrpBuf_Index );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   479  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   480          SigGrpBitOffset        = ( RxSigGrpArrayConstPtr->FirstByteNo * 8u );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   481  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   482          SchM_Enter_Com_RxSigGrpArrayBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   483      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   484      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   485  # endif /* # ifdef COM_RX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   486      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   487          SchM_Enter_Com_RxGrpSigSecBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   488      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   489  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   490      RxGrpSigConstPtr = COM_GET_RXGRPSIG_CONSTDATA( RxSigGrpConstPtr->FirstGrpSig_Index );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   491  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   492      for ( index_ui = (uint16_least)RxSigGrpConstPtr->No_Of_GrpSig; index_ui != (uint16_least)0; index_ui-- )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   493      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   494  # if (defined(COM_RX_SIGNALGROUP_ARRAY) || defined(COM_RXGRPSIG_FLOAT64SUPP) || defined(COM_RXGRPSIG_INT64))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   495          SigType = Com_GetValue(RXGRPSIG,_TYPE,RxGrpSigConstPtr->rxGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   496  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   497  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   498          SigValue = (Com_SigMaxType)RxGrpSigConstPtr->Init_Val;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   499  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   500  #ifdef COM_RXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   501          /* [SWS_Com_00723] The AUTOSAR COM module shall extend the init value (ComSignalInitValue) of a signal
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   502           * to the size of its ComSignalType.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   503           * Currently for COM_SINT64 signal type, ComSignalInitValue is supported for maximum 32bits.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   504           * If negative values are configured, by default these values will be sign extended only till 32bits.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   505           * so, for COM_SINT64, it is required to perform the sign extension till 64bits explicity. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   506          SigValue = (SigType == COM_SINT64) ? (Com_SigMaxType)((sint64)((sint32)SigValue)) : SigValue;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   507  #endif /* #ifdef COM_RXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   508  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   509  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   510          if ( ConstIsSigGrpOfArrayType_b )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   511          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   512              Com_BitpositionType RelativeSigBitPos; /* Relative BitPosition in RxSignalGroup Array */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   513  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   514              /* The Buffer into which Signal Values needs to be packed will be available with starting address
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   515               * of the Rx-SignalGroup Array Buffer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   516               * But we have GroupSignal: Bit_Pos, i.e., Signal's actual LSB in the IPdu Buffer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   517               * So, Rx-SignalGroup BitOffset(SigGrpBitOffset) is removed from each of the GroupSignal and
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   518               * is used as BitPosition to pack its value into the Rx-SignalGroup Array Buffer */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   519              RelativeSigBitPos = RxGrpSigConstPtr->Bit_Pos - ( Com_BitpositionType )SigGrpBitOffset;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   520  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   521              Com_InitializePduBuffWithSignalInitValue(
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   522                                                RxSigGrpArrayBufRamPtr,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   523                                                SigValue,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   524                                                RelativeSigBitPos,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   525                                                RxGrpSigConstPtr->BitSize,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   526                                                SigType,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   527                                                Com_GetValue(RXGRPSIG,_ENDIANESS,RxGrpSigConstPtr->rxGrpSigFields) );
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   528          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   529          else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   530  # endif /* #ifdef COM_RX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   531          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   532  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   533  # ifdef COM_RXGRPSIG_FLOAT64SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   534              if(SigType == COM_FLOAT64)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   535              {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   536                  COM_GET_SECRXGRPSIGTYPEFLOAT64_BUFF(RxMainFuncId,RxGrpSigConstPtr->RxGrpSigBuff_Index) =
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   537                                                                        Com_getfloat64InitValue(SigValue);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   538              }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   539              else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   540  # endif
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   541  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   542              {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   543                  Com_UpdateRxGroupSignalSecondBuffer(RxGrpSigConstPtr, SigValue, RxMainFuncId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   544              }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   545          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   546  # if defined(COM_RxFilters) && defined(COM_F_MASKEDNEWDIFFERSOLD)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   547          /* [SWS_Com_00603] The AUTOSAR COM module shall set the old_value of the filtering mechanisms
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   548           * for each signal to the ComSignalInitValue during start-up */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   549          if ( ( COM_INIT != Com_Uninit_Flag ) && ( COM_MASKED_NEW_DIFFERS_MASKED_OLD == RxGrpSigConstPtr->Filter_Algo ) )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   550          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   551              COM_GET_F_OLDVALUE(RxGrpSigConstPtr->Filter_Index) = (uint32)SigValue;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   552          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   553  # endif /* # if defined(COM_RxFilters) && defined(COM_F_MASKEDNEWDIFFERSOLD) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   554  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   555          RxGrpSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   556      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   557  # ifdef COM_RX_SIGNALGROUP_ARRAY
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   558  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   559      if ( ConstIsSigGrpOfArrayType_b )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   560      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   561          SchM_Exit_Com_RxSigGrpArrayBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   562      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   563      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   564  # endif /* # ifdef COM_RX_SIGNALGROUP_ARRAY */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   565      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   566          SchM_Exit_Com_RxGrpSigSecBuff();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   567      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   568  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   569  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   570  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   571  #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   572  #ifdef COM_TxIPduNotification
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   573  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxNotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   574          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   575      Com_TxIpduConstPtrType TxIPduConstPtr;    /* Local pointer to Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   576      Com_TxSigConstPtrType TxSigConstPtr;    /* Local pointer to Tx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   577  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   578      Com_TxSigGrpConstPtrType TxSigGrpConstPtr; /* Local pointer to hold the address of Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   579  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   580      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   581  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   582      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   583      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   584      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   585  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   586      IpduId = COM_GET_TX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   587      TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   588      TxSigConstPtr = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   589  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   590      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(TxIPduConstPtr->FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   591  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   592  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   593      for(index_u8 = TxIPduConstPtr->TxSigId_Index; index_u8 < (TxIPduConstPtr->TxSigId_Index + TxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   594      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   595          if(TxSigConstPtr->Notification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   596          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   597              TxSigConstPtr->Notification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   598          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   599          TxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   600      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   601  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   602      for(index_u8 = TxIPduConstPtr->FirstTxSigGrp_Index; index_u8 < (TxIPduConstPtr->FirstTxSigGrp_Index + TxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   603      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   604          if(TxSigGrpConstPtr->Notification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   605          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   606              TxSigGrpConstPtr->Notification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   607          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   608          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   609      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   610  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   611  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   612          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   613  #endif /* #ifdef COM_TxIPduNotification */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   614  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   615  #ifdef COM_ERRORNOTIFICATION
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   616  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxErrNotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   617  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   618  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   619      Com_TxIpduConstPtrType TxIPduConstPtr;    /* Local pointer to Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   620      Com_TxSigConstPtrType TxSigConstPtr;    /* Local pointer to Tx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   621  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   622      Com_TxSigGrpConstPtrType TxSigGrpConstPtr; /* Local pointer to hold the address of Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   623  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   624      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   625  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   626      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   627      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   628      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   629  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   630      IpduId = COM_GET_TX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   631      TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   632      TxSigConstPtr = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   633  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   634      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(TxIPduConstPtr->FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   635  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   636  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   637      for(index_u8 = TxIPduConstPtr->TxSigId_Index; index_u8 < (TxIPduConstPtr->TxSigId_Index + TxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   638      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   639          if(TxSigConstPtr->NotificationError_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   640          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   641              TxSigConstPtr->NotificationError_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   642          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   643          TxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   644      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   645  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   646      for(index_u8 = TxIPduConstPtr->FirstTxSigGrp_Index; index_u8 < (TxIPduConstPtr->FirstTxSigGrp_Index + TxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   647      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   648          if(TxSigGrpConstPtr->NotificationError_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   649          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   650              TxSigGrpConstPtr->NotificationError_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   651          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   652          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   653      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   654  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   655  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   656  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   657  #endif /* #ifdef COM_ERRORNOTIFICATION */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   658  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   659  #ifdef COM_TxIPduTimeOutNotify
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   660  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallTxTONotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   661  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   662  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   663      Com_TxIpduConstPtrType TxIPduConstPtr;    /* Local pointer to Tx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   664      Com_TxSigConstPtrType TxSigConstPtr;    /* Local pointer to Tx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   665  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   666      Com_TxSigGrpConstPtrType TxSigGrpConstPtr; /* Local pointer to hold the address of Tx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   667  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   668      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   669  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   670      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   671      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   672      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   673  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   674      IpduId = COM_GET_TX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   675      TxIPduConstPtr = COM_GET_TX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   676      TxSigConstPtr = COM_GET_TXSIG_CONSTDATA(TxIPduConstPtr->TxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   677  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   678      TxSigGrpConstPtr = COM_GET_TXSIGGRP_CONSTDATA(TxIPduConstPtr->FirstTxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   679  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   680  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   681      for(index_u8 = TxIPduConstPtr->TxSigId_Index; index_u8 < (TxIPduConstPtr->TxSigId_Index + TxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   682      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   683          if(TxSigConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   684          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   685              TxSigConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   686          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   687          TxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   688      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   689  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   690      for(index_u8 = TxIPduConstPtr->FirstTxSigGrp_Index; index_u8 < (TxIPduConstPtr->FirstTxSigGrp_Index + TxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   691      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   692          if(TxSigGrpConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   693          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   694              TxSigGrpConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   695          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   696          TxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   697      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   698  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   699  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   700  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   701  #endif /* #ifdef COM_TxIPduTimeOutNotify */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   702  #ifdef COM_RxIPduTimeoutNotify
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   703  LOCAL_INLINE FUNC(void, COM_CODE) Com_CallRxTONotifyCallback(Com_IpduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   704  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   705  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   706      Com_RxIpduConstPtrType RxIPduConstPtr;    /* Local pointer to Rx ipdu static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   707      Com_RxSigConstPtrType RxSigConstPtr;    /* Local pointer to Rx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   708  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   709      Com_RxSigGrpConstPtrType RxSigGrpConstPtr; /* Local pointer to hold the address of Rx SignalGroup static configuration */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   710  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   711      uint8_least index_u8;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   712  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   713      /* If PB variant is selected, then PduId which is passed to this function will be changed
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   714      * to internal Id which is generated through configuration
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   715      * If PC variant is selected, then no mapping table will be used. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   716  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   717      IpduId = COM_GET_RX_IPDU_ID(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   718      RxIPduConstPtr = COM_GET_RX_IPDU_CONSTDATA(IpduId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   719      RxSigConstPtr = COM_GET_RXSIG_CONSTDATA(RxIPduConstPtr->RxSigId_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   720  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   721      RxSigGrpConstPtr = COM_GET_RXSIGGRP_CONSTDATA(RxIPduConstPtr->FirstRxSigGrp_Index);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   722  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   723  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   724      for(index_u8 = RxIPduConstPtr->RxSigId_Index; index_u8 < (RxIPduConstPtr->RxSigId_Index + RxIPduConstPtr->No_Of_Sig_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   725      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   726          if(RxSigConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   727          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   728              RxSigConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   729          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   730          RxSigConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   731      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   732  #ifdef COM_RX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   733      for(index_u8 = RxIPduConstPtr->FirstRxSigGrp_Index; index_u8 < (RxIPduConstPtr->FirstRxSigGrp_Index + RxIPduConstPtr->No_Of_SigGrp_Ref); index_u8++)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   734      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   735          if(RxSigGrpConstPtr->TimeOutNotification_Cbk != NULL_PTR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   736          {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   737              RxSigGrpConstPtr->TimeOutNotification_Cbk();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   738          }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   739          RxSigGrpConstPtr++;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   740      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   741  #endif /* #ifdef COM_RX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   742  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   743  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   744  #endif /* #ifdef COM_RxIPduTimeoutNotify */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   745  #endif /* #if (COM_CONFIGURATION_VARIANT != COM_VARIANT_PRE_COMPILE) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   746  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   747  #ifdef COM_TX_SIGNALGROUP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   748  LOCAL_INLINE FUNC(void, COM_CODE) Com_CopyTxGroupSignalData( Com_SignalIdType    GrpSignalId,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   749                                                               Com_SigMaxType      TxGrpSig_NewVal,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   750                                                               Com_MainFuncType    TxMainFuncId )
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   751  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   752      Com_TxGrpSigConstPtrType                   TxGrpSigConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   753      VAR(Com_TxGrpSigBuffIndexType, AUTOMATIC)  GrpSigBuff_Index;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   754      VAR(uint8, AUTOMATIC)                      Type;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   755  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   756      TxGrpSigConstPtr = COM_GET_TXGRPSIG_CONSTDATA(GrpSignalId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   757      GrpSigBuff_Index = TxGrpSigConstPtr->TxGrpSigBuff_Index;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   758      Type = Com_GetValue(TXGRPSIG,_TYPE,TxGrpSigConstPtr->txGrpSigFields);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   759  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   760      SchM_Enter_Com_TxGrpSigBuffer();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   761      switch(Type >> 1u)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   762      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   763  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   764          case 0x00u: /* UINT8 and SINT8 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   765          case 0x03u: /* Boolean type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   766              COM_GET_TXGRPSIGTYPEU8_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint8)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   767              break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   768  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   769          /* UINT16 and SINT16 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   770          case 0x01u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   771              COM_GET_TXGRPSIGTYPEU16_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint16)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   772              break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   773  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   774          /* UINT32,SINT32 and FLOAT32 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   775          case 0x02u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   776          /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   777  #ifdef COM_FLOAT32SUPP
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   778          case (COM_FLOAT32 >> 1u):
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   779  #endif /* #ifdef COM_FLOAT32SUPP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   780          /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   781              COM_GET_TXGRPSIGTYPEU32_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint32)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   782              break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   783  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   784          /* UINT64 and SINT64 type */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   785  #ifdef COM_TXGRPSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   786          case 0x08u:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   787              COM_GET_TXGRPSIGTYPEU64_BUFF(TxMainFuncId, GrpSigBuff_Index) = (uint64)TxGrpSig_NewVal;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   788          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   789  #endif /* #ifdef COM_TXGRPSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   790  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   791          default:
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   792              /**
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   793               * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   794               * allowed to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   795               */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   796          break;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   797     }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   798      SchM_Exit_Com_TxGrpSigBuffer();
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   799  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   800  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   801  #endif /* #ifdef COM_TX_SIGNALGROUP */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   802  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   803  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   804  #if(COM_CONFIGURATION_USE_DET == STD_ON)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   805  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   806  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   807   Function name    : Com_Prv_DETCheck_Void
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   808   Syntax           : boolean Com_Prv_DETCheck_Void(uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   809   Description      : Inline function to check for module initialization
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   810   Parameter        : ApiId - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   811   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   812                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   813   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   814  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Void(uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   815  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   816      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   817      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   818  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   819      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   820      Status  = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   821  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   822      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   823      if (Com_Uninit_Flag == COM_UNINIT)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   824      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   825          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   826          COM_REPORT_ERROR_CHECK(ApiId, COM_E_UNINIT);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   827          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   828          Status = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   829      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   830      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   831      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   832          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   833      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   834  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   835      return Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   836  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   837  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   838  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   839   Function name    : Com_Prv_DETCheck_Param
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   840   Syntax           : boolean Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   841   Description      : Inline function to check for module initialization and valid parameter value.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   842   Parameter        : isInValidParam - calling service is called with invalid parameter value
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   843                      ApiId          - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   844   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   845                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   846   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   847  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Param(boolean isInValidParam, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   848  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   849      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   850      uint8   ErrorId;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   851      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   852  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   853      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   854      ErrorId = COM_DET_NO_ERROR;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   855      Status  = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   856  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   857      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   858      if (Com_Uninit_Flag == COM_UNINIT)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   859      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   860          ErrorId = COM_E_UNINIT;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   861      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   862      else if (isInValidParam)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   863      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   864          ErrorId = COM_E_PARAM;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   865      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   866      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   867      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   868          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   869      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   870  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   871      /* Check if ErrorId has Error Code */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   872      if (ErrorId != COM_DET_NO_ERROR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   873      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   874          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   875          COM_REPORT_ERROR_CHECK(ApiId, ErrorId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   876          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   877          Status = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   878      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   879      return Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   880  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   881  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   882  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   883   Function name    : Com_Prv_DETCheck_Ptr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   884   Syntax           : boolean Com_Prv_DETCheck_Ptr(boolean isInValidPtr, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   885   Description      : Inline function to check for module initialization and valid pointer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   886   Parameter        : isInValidPtr - calling service is called with invalid pointer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   887                      ApiId        - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   888   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   889                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   890   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   891  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Ptr(boolean isInValidPtr, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   892  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   893      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   894      uint8   ErrorId;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   895      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   896  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   897      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   898      ErrorId = COM_DET_NO_ERROR;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   899      Status  = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   900  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   901      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   902      if (Com_Uninit_Flag == COM_UNINIT)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   903      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   904          ErrorId = COM_E_UNINIT;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   905      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   906      else if (isInValidPtr)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   907      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   908          ErrorId = COM_E_PARAM_POINTER;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   909      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   910      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   911      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   912          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   913      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   914  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   915      /* Check if ErrorId has Error Code */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   916      if (ErrorId != COM_DET_NO_ERROR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   917      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   918          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   919          COM_REPORT_ERROR_CHECK(ApiId, ErrorId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   920          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   921          Status = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   922      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   923      return Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   924  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   925  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   926  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   927   Function name    : Com_Prv_DETCheck_Param_Ptr
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   928   Syntax           : boolean Com_Prv_DETCheck_Param_Ptr(boolean isInValidParam, boolean isInValidPtr, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   929   Description      : Inline function to check for module initialization, valid parameter value and valid pointer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   930   Parameter        : isInValidParam - calling service is called with invalid parameter value
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   931                      isInValidPtr   - calling service is called with invalid pointer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   932                      ApiId          - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   933   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   934                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   935   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   936  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Param_Ptr(boolean isInValidParam, boolean isInValidPtr, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   937  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   938      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   939      uint8   ErrorId;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   940      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   941  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   942      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   943      ErrorId = COM_DET_NO_ERROR;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   944      Status  = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   945  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   946      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   947      if (Com_Uninit_Flag == COM_UNINIT)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   948      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   949          ErrorId = COM_E_UNINIT;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   950      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   951      else if (isInValidParam)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   952      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   953          ErrorId = COM_E_PARAM;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   954      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   955      else if (isInValidPtr)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   956      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   957          ErrorId = COM_E_PARAM_POINTER;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   958      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   959      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   960      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   961          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   962      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   963  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   964      /* Check if ErrorId has Error Code */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   965      if (ErrorId != COM_DET_NO_ERROR)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   966      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   967          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   968          COM_REPORT_ERROR_CHECK(ApiId, ErrorId);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   969          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   970          Status = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   971      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   972      return Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   973  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   974  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   975  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   976  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   977   Function name    : Com_Prv_DETCheck_Ptr_Only
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   978   Syntax           : boolean Com_Prv_DETCheck_Ptr_Only(boolean isInValidPtr, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   979   Description      : Inline function to check for valid pointer.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   980   Parameter        : isInValidPtr - calling service is called with invalid pointer
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   981                      ApiId        - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   982   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   983                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   984   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   985  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Ptr_Only(boolean isInValidPtr, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   986  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   987      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   988      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   989  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   990      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   991      Status = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   992  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   993      /* Check if Com is initialized or not */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   994      if (isInValidPtr)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   995      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   996          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   997          COM_REPORT_ERROR_CHECK(ApiId, COM_E_PARAM_POINTER);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   998          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	   999          Status = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1000      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1001      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1002      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1003          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1004      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1005  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1006      return Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1007  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1008  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1009  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1010  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1011   Function name    : Com_Prv_DETCheck_Param_Only
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1012   Syntax           : boolean Com_Prv_DETCheck_Param_Only(boolean isInValidParam, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1013   Description      : Inline function to check for module initialization and valid parameter value.
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1014   Parameter        : isInValidParam - calling service is called with invalid parameter value
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1015                      ApiId          - Com service id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1016   Return value     : COM_TRUE  - No development error
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1017                      COM_FALSE - development error is detected, same is reported to DET
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1018   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1019  LOCAL_INLINE FUNC(boolean,COM_CODE) Com_Prv_DETCheck_Param_Only(boolean isInValidParam, uint8 ApiId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1020  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1021      /* Local variable*/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1022      boolean Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1023  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1024      /* Initialization of local variable */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1025      Status = COM_TRUE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1026  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1027      if (isInValidParam)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1028      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1029          /* Report DET Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1030          COM_REPORT_ERROR_CHECK(ApiId, COM_E_PARAM);
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1031          /* Update the status */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1032          Status = COM_FALSE;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1033      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1034      else
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1035      {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1036          /* No Error */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1037      }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1038  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1039      return Status;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1040  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1041  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1042  #endif /* #if(COM_CONFIGURATION_USE_DET == STD_ON) */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1043  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1044  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1045   Function name    : Com_CheckTxIPduStatus
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1046   Syntax           : boolean Com_CheckTxIPduStatus(PduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1047   Description      : Inline function to check TxIPdu status
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1048   Parameter        : IpduId - TxIPdu Id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1049   Return value     : COM_TRUE  - TxIPdu is started
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1050                      COM_FALSE - TxIPdu is stopped
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1051   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1052  LOCAL_INLINE boolean Com_CheckTxIPduStatus(PduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1053  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1054      VAR(boolean, AUTOMATIC) TxIPduStatus;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1055  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1056      TxIPduStatus =  Com_GetRamValue(TXIPDU,_PDUSTATUS,COM_GET_TXPDURAM_S(IpduId).Com_TxFlags)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1057                  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1058                  /* MR12 RULE 13.5 VIOLATION: Below conditional statement reads flag status. Evaluation(or no evaluation)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1059                   * of operands does not impact the system behaviour even though of volatile-qualified,
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1060                   * Hence the warning is suppressed. */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1061  #ifdef COM_TX_IPDUCONTROL_VIA_CALIBRATION
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1062                  && (COM_CheckTxIPduCalibrationVarStatus((PduIdType)(IpduId)))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1063  #endif /* #ifdef COM_TX_IPDUCONTROL_VIA_CALIBRATION */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1064  #ifdef COM_TXIPDUCONTROL_VIA_RBA_NDS_ECUVARIANT
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1065                  && (Com_CheckTxIPduControlViaRbaNdsEcuVariant((PduIdType)(IpduId)))
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1066  #endif /* #ifdef COM_TXIPDUCONTROL_VIA_RBA_NDS_ECUVARIANT */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1067                  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1068                           ;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1069  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1070      return TxIPduStatus;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1071  }
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1072  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1073  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1074   Function name    : Com_CheckRxIPduStatus
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1075   Syntax           : boolean Com_CheckRxIPduStatus(PduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1076   Description      : Inline function to check RxIPdu status
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1077   Parameter        : IpduId - RxIPdu Id
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1078   Return value     : COM_TRUE  - RxIPdu is started
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1079                      COM_FALSE - RxIPdu is stopped
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1080   *********************************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1081  LOCAL_INLINE boolean Com_CheckRxIPduStatus(PduIdType IpduId)
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1082  {
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1083      VAR(boolean, AUTOMATIC) RxIPduStatus;
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1084  
; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1085      RxIPduStatus = Com_GetRamValue(RXIPDU,_PDUSTATUS,COM_GET_RXPDURAM_S(IpduId).RxFlags)
	mul	d15,d15,#6
	movh.a	a15,#@his(Com_RxIpduRam_s)
.L131:
	lea	a15,[a15]@los(Com_RxIpduRam_s)
	addsc.a	a15,a15,d15,#0
	ld.bu	d15,[a15]4
.L89:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
	mov	d1,#1
.L182:
	sh	d1,#0
.L183:
	and	d15,d1
.L184:
	ne	d15,d15,#0
.L185:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);      (inlined)
	j	.L12

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }      (inlined)
.L12:

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1099      return RxIPduStatus;      (inlined)
	j	.L13

; BSW\src\BSW\Gen\Com\src\Com_Prv_Inl.h	  1100  }      (inlined)
.L13:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    57          {
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    58              Status = E_OK;
	cmov	d9,d15,#0
.L14:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    59          }
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    60  
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    61          if((SigType % COM_TWO) == COM_ZERO)
	jnz.t	d0:0,.L15
.L96:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    62          {
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    63              /* Copy Data of Unsigned Signal Types */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    64              Com_Prv_CopyData_UnsignedType(SignalId, SignalDataPtr);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    65          }
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    66          else
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    67          {
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    68              /* Copy Data of Signed Signal Types */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    69              Com_Prv_CopyData_signedType(SignalId, SignalDataPtr);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    70          }
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    71      }
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    72      return(Status);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    73  }
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    74  
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    75  #define COM_STOP_SEC_CODE
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    76  #include "Com_MemMap.h"
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    77  
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    78  /***************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    79   Function name    : Com_Prv_CopyData_UnsignedType
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    80   Syntax           : void Com_Prv_CopyData_UnsignedType(VAR(Com_SignalIdType, AUTOMATIC) SignalId,
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    81                                                         P2VAR(void, AUTOMATIC, COM_APPL_DATA) SignalDataPtr)
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    82   Description      : Service to copy the data for UnSigned Signal type
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    83   Parameter        : SignalId      -> Id of the signal
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    84                    : SignalDataPtr -> Pointer to the the signal data
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    85   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    86   ***************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    87  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_CopyData_UnsignedType(VAR(Com_SignalIdType, AUTOMATIC) SignalId,
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    88                                                                  P2VAR(void, AUTOMATIC, COM_APPL_DATA) SignalDataPtr)
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    89  {
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    90      /* Local pointer holds the address of Rx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    91      Com_RxSigConstPtrType                       RxSigConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    92      VAR(Com_SigMaxType, AUTOMATIC)              RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    93      VAR(Com_SigBuffIndexType, AUTOMATIC)        SigBuff_Index;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    94      /* Local variable holds internal Rx-MainFunction Id */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    95      VAR(Com_MainFuncType, AUTOMATIC)            rxMainFuncId;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    96      /* Local variable holds the signal type */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    97      VAR(uint8, AUTOMATIC)                       Type;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    98  
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	    99      RxSigConstPtr       = COM_GET_RXSIG_CONSTDATA(SignalId);
	sha	d8,#4
.L124:
	addsc.a	a15,a2,d8,#0
.L132:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   100      SigBuff_Index       = RxSigConstPtr->SigBuff_Index;
	ld.bu	d3,[a15]9
.L134:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   101      /* Type = RxSigConstPtr->General.Type */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   102      Type                = Com_GetValue(GEN,_TYPE,RxSigConstPtr->General);
	ld.bu	d15,[a15]12
	mov	d1,#5
.L108:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
	sha	d0,d15,#0
.L186:
	mov	d15,#255
.L187:
	rsub	d1,d1,#8
.L188:
	rsub	d1,#0
	sh	d1,d15,d1
.L189:
	and	d0,d1
.L190:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));      (inlined)
	j	.L16

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }      (inlined)
.L16:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   103      rxMainFuncId        = (COM_GET_RX_IPDU_CONSTDATA(RxSigConstPtr->IpduRef))->MainFunctionRef;
	ld.bu	d15,[a15]11
	mul	d15,d15,#20
	movh.a	a2,#@his(Com_Prv_xRxIpduCfg_acst)
	lea	a2,[a2]@los(Com_Prv_xRxIpduCfg_acst)
	addsc.a	a2,a2,d15,#0
.L191:
	ld.bu	d1,[a2]17
.L136:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   104  
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   105      /* Copy the SigBuffer data into SignalDataPtr*/
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   106      switch(Type)
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   107      {
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   108          /* MR12 RULE 11.5 VIOLATION: For SignalDataPtr is defined as void pointer in the
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   109             AUTOSAR specification, so suppressing warning "Cast from a pointer to void to a pointer to object". */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   110          /* Locks are required here, as the signal buffer may be updated in Com_RxIndication(),
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   111             which may be called in interrupt context. */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   112          case COM_UINT8:
	mov	d15,#0
	jeq	d15,d0,.L17
.L192:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   113              {
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   114              RxNewVal = (Com_SigMaxType)COM_GET_SIGTYPEUINT8_BUFF(rxMainFuncId, SigBuff_Index);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   115               *(uint8*)SignalDataPtr =  (uint8)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   116              }
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   117              break;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   118          case COM_UINT16:
	mov	d15,#2
	jeq	d15,d0,.L18
.L193:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   119              {
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   120                  #if (CPU_TYPE == CPU_TYPE_8)
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   121                  SchM_Enter_Com_RxSigBuff(RECEIVESIGNAL);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   122                  #endif
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   123                  RxNewVal = (Com_SigMaxType)COM_GET_SIGTYPEUINT16_BUFF(rxMainFuncId, SigBuff_Index);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   124                  #if (CPU_TYPE == CPU_TYPE_8)
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   125                  SchM_Exit_Com_RxSigBuff(RECEIVESIGNAL);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   126                  #endif
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   127                  *(uint16*)SignalDataPtr =  (uint16)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   128              }
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   129              break;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   130          case COM_UINT32:
	mov	d2,#4
.L129:
	jeq	d2,d0,.L19
.L194:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   131              {
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   132                  #if (CPU_TYPE != CPU_TYPE_32)
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   133                  SchM_Enter_Com_RxSigBuff(RECEIVESIGNAL);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   134                  #endif
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   135                  RxNewVal = (Com_SigMaxType)COM_GET_SIGTYPEUINT32_BUFF(rxMainFuncId, SigBuff_Index);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   136                  #if (CPU_TYPE != CPU_TYPE_32)
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   137                  SchM_Exit_Com_RxSigBuff(RECEIVESIGNAL);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   138                  #endif
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   139                  *(uint32*)SignalDataPtr =  (uint32)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   140              }
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   141              break;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   142  #ifdef COM_RXSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   143          case COM_UINT64:
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   144              {
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   145                  SchM_Enter_Com_RxSigBuff(RECEIVESIGNAL);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   146                  RxNewVal = COM_GET_SIGTYPEUINT64_BUFF(rxMainFuncId, SigBuff_Index);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   147                  SchM_Exit_Com_RxSigBuff(RECEIVESIGNAL);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   148                  *(uint64*)SignalDataPtr =  (uint64)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   149              }
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   150              break;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   151  #endif /* #ifdef COM_RXSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   152          case COM_BOOLEAN:
	mov	d2,#6
	jeq	d2,d0,.L20
.L195:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   153              {
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   154                  RxNewVal = (uint32)COM_GET_SIGTYPEUINT8_BUFF(rxMainFuncId, SigBuff_Index);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   155                  *(boolean*)SignalDataPtr =  (boolean)(RxNewVal != 0u);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   156              }
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   157              break;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   158          case COM_UINT8_N:
	mov	d15,#8
	jeq	d15,d0,.L21
	j	.L22

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   112          case COM_UINT8:      (inlined)
.L17:
	mul	d15,d1,#12
	movh.a	a15,#@his(Com_Prv_xRxRamBuf_acst)
.L133:
	lea	a15,[a15]@los(Com_Prv_xRxRamBuf_acst)
	addsc.a	a15,a15,d15,#0
	ld.a	a15,[a15]
	addsc.a	a15,a15,d3,#0
	ld.bu	d15,[a15]
.L137:
	st.b	[a12],d15
.L196:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   117              break;      (inlined)
	j	.L23

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   118          case COM_UINT16:      (inlined)
.L18:
	mul	d15,d1,#12
	movh.a	a15,#@his(Com_Prv_xRxRamBuf_acst)
.L138:
	lea	a15,[a15]@los(Com_Prv_xRxRamBuf_acst)
	addsc.a	a15,a15,d15,#0
	ld.a	a15,[a15]4
	addsc.a	a15,a15,d3,#1
	ld.hu	d15,[a15]0
.L139:
	st.h	[a12],d15
.L197:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   129              break;      (inlined)
	j	.L24

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   130          case COM_UINT32:      (inlined)
.L19:
	mul	d15,d1,#12
	movh.a	a15,#@his(Com_Prv_xRxRamBuf_acst)
.L140:
	lea	a15,[a15]@los(Com_Prv_xRxRamBuf_acst)
	addsc.a	a15,a15,d15,#0
	ld.a	a15,[a15]8
	addsc.a	a15,a15,d3,#2
	ld.w	d15,[a15]
.L141:
	st.w	[a12],d15
.L198:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   141              break;      (inlined)
	j	.L25

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   152          case COM_BOOLEAN:      (inlined)
.L20:
	mul	d15,d1,#12
	movh.a	a15,#@his(Com_Prv_xRxRamBuf_acst)
.L142:
	lea	a15,[a15]@los(Com_Prv_xRxRamBuf_acst)
	addsc.a	a15,a15,d15,#0
	ld.a	a15,[a15]
	addsc.a	a15,a15,d3,#0
	ld.bu	d15,[a15]
.L143:
	ne	d15,d15,#0
.L144:
	st.b	[a12],d15
.L199:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   157              break;      (inlined)
	j	.L26

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   158          case COM_UINT8_N:      (inlined)
.L21:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   159              {
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   160                  /*Copy each byte into the SignalDataPtr from Signal buffer  */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   161                  /* The locks inside the function Com_ByteCopy() are removed.
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   162                   * Hence locks are used here
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   163                   */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   164                  SchM_Enter_Com_RxSigBuff(RECEIVESIGNAL);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   165                  Com_ByteCopy((uint8*)SignalDataPtr,&COM_GET_SIGTYPEUINT8_BUFF(rxMainFuncId, SigBuff_Index),
	mul	d15,d1,#12
	movh.a	a2,#@his(Com_Prv_xRxRamBuf_acst)
	lea	a2,[a2]@los(Com_Prv_xRxRamBuf_acst)
	addsc.a	a2,a2,d15,#0
	ld.a	a2,[a2]
	addsc.a	a5,a2,d3,#0
.L200:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   166                               (uint32)RxSigConstPtr->BitSize);
	ld.bu	d4,[a15]10
.L201:
	mov.aa	a4,a12
.L145:
	call	Com_ByteCopy
.L135:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   169              break;      (inlined)
	j	.L27

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   210          default:      (inlined)
.L22:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   215              break;      (inlined)
	j	.L28

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   217  }      (inlined)
.L28:
.L27:
.L26:
.L25:
.L24:
.L23:
	j	.L29
.L15:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   167                  SchM_Exit_Com_RxSigBuff(RECEIVESIGNAL);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   168              }
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   169              break;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   170  
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   171  /* FC_VariationPoint_START */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   172  #ifdef COM_FLOAT32SUPP
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   173          case COM_FLOAT32:
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   174              {
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   175                  #if (CPU_TYPE != CPU_TYPE_32)
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   176                  SchM_Enter_Com_RxSigBuff(RECEIVESIGNAL);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   177                  #endif
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   178                  RxNewVal = (Com_SigMaxType)COM_GET_SIGTYPEUINT32_BUFF(rxMainFuncId, SigBuff_Index);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   179                  #if (CPU_TYPE != CPU_TYPE_32)
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   180                  SchM_Exit_Com_RxSigBuff(RECEIVESIGNAL);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   181                  #endif
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   182                  /* Convert the 32 bit stream  into float value */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   183                  /* MR12 DIR 1.1 VIOLATION: Explicit cast is provided in line with rba_BswSrv_MemCopy() definition.
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   184                     But the void pointer is always deferenced to a type, based on the pointers alignment.
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   185                     Hence the alignment warning can safely be ignored. */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   186                  (void)rba_BswSrv_MemCopy( SignalDataPtr, (const void *)&RxNewVal, 4 );
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   187  
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   188              }
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   189              break;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   190  #endif /* #ifdef COM_FLOAT32SUPP */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   191  
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   192  #ifdef COM_RXSIG_FLOAT64SUPP
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   193          case COM_FLOAT64:
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   194              /* FLOAT64 signal */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   195              {
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   196                  float64 RxNewVal_f64;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   197                  SchM_Enter_Com_RxSigBuff(RECEIVESIGNAL);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   198                  RxNewVal_f64 = COM_GET_SIGTYPEFLOAT64_BUFF(rxMainFuncId, SigBuff_Index);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   199                  SchM_Exit_Com_RxSigBuff(RECEIVESIGNAL);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   200  
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   201                  /* MR12 RULE 11.5 VIOLATION: For SignalDataPtr is defined as void pointer in the AUTOSAR specification,
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   202                     so suppressing warning "Cast from a pointer to void to a pointer to object". */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   203                  *(float64*)SignalDataPtr =  (float64)RxNewVal_f64;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   204  
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   205              }
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   206              break;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   207  #endif
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   208  /* FC_VariationPoint_END */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   209  
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   210          default:
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   211              /**
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   212               * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are allowed
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   213               * to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   214               */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   215              break;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   216      }
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   217  }
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   218  
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   219  /***************************************************************************************************
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   220   Function name    : Com_Prv_CopyData_SignedType
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   221   Syntax           : void Com_Prv_CopyData_SignedType(VAR(Com_SignalIdType, AUTOMATIC) SignalId,
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   222                                                       P2VAR(void, AUTOMATIC, COM_APPL_DATA) SignalDataPtr)
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   223   Description      : Service to copy the data for Signed Signal type
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   224   Parameter        : SignalId      -> Id of the signal
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   225                    : SignalDataPtr -> Pointer to the the signal data
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   226   Return value     : None
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   227   ***************************************************************************************************/
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   228  LOCAL_INLINE FUNC(void, COM_CODE) Com_Prv_CopyData_signedType(VAR(Com_SignalIdType, AUTOMATIC) SignalId,
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   229                                                                P2VAR(void, AUTOMATIC, COM_APPL_DATA) SignalDataPtr)
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   230  {
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   231      /* Local pointer holds the address of Rx signal static configuration */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   232      Com_RxSigConstPtrType                       RxSigConstPtr;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   233      VAR(Com_SigMaxType, AUTOMATIC)              RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   234      VAR(Com_SigBuffIndexType, AUTOMATIC)        SigBuff_Index;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   235      /* Local variable holds internal Rx-MainFunction Id */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   236      VAR(Com_MainFuncType, AUTOMATIC)            rxMainFuncId;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   237      /* Local variable holds the signal type */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   238      VAR(uint8, AUTOMATIC)                       Type;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   239  
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   240      RxSigConstPtr       = COM_GET_RXSIG_CONSTDATA(SignalId);
	sha	d8,#4
.L146:
	addsc.a	a15,a2,d8,#0
.L148:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   241      SigBuff_Index       = RxSigConstPtr->SigBuff_Index;
	ld.bu	d3,[a15]9
.L150:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   242      /* Type = RxSigConstPtr->General.Type */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   243      Type                = Com_GetValue(GEN,_TYPE,RxSigConstPtr->General);
	ld.bu	d15,[a15]12
	mov	d1,#5
.L120:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     1  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     2  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     3  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     4  #ifndef BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     5  #define BFX_BIT_INL_H
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     6  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     7  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     8  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    10   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    11   * List of services
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    12   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    13   * Bfx_Prv_ClrBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    14   * Bfx_Prv_ClrBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    15   * Bfx_Prv_ClrBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    16   * Bfx_Prv_ClrBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    17   * Bfx_Prv_ClrBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    18   * Bfx_Prv_ClrBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    19   * Bfx_Prv_CopyBit_u16u8u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    20   * Bfx_Prv_CopyBit_u32u8u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    21   * Bfx_Prv_CopyBit_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    22   * Bfx_Prv_GetBit_u16u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    23   * Bfx_Prv_GetBit_u32u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    24   * Bfx_Prv_GetBit_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    25   * Bfx_Prv_GetBits_u16u8u8_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    26   * Bfx_Prv_GetBits_u32u8u8_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    27   * Bfx_Prv_GetBits_u8u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    28   * Bfx_Prv_PutBit_u16u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    29   * Bfx_Prv_PutBit_u32u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    30   * Bfx_Prv_PutBit_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    31   * Bfx_Prv_PutBits_u16u8u8u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    32   * Bfx_Prv_PutBits_u32u8u8u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    33   * Bfx_Prv_PutBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    34   * Bfx_Prv_PutBitsMask_u16u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    35   * Bfx_Prv_PutBitsMask_u32u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    36   * Bfx_Prv_PutBitsMask_u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    37   * Bfx_Prv_RotBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    38   * Bfx_Prv_RotBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    39   * Bfx_Prv_RotBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    40   * Bfx_Prv_RotBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    41   * Bfx_Prv_RotBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    42   * Bfx_Prv_RotBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    43   * Bfx_Prv_SetBit_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    44   * Bfx_Prv_SetBit_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    45   * Bfx_Prv_SetBit_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    46   * Bfx_Prv_SetBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    47   * Bfx_Prv_SetBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    48   * Bfx_Prv_SetBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    49   * Bfx_Prv_SetBits_u16u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    50   * Bfx_Prv_SetBits_u32u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    51   * Bfx_Prv_SetBits_u8u8u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    52   * Bfx_Prv_ShiftBitLt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    53   * Bfx_Prv_ShiftBitLt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    54   * Bfx_Prv_ShiftBitLt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    55   * Bfx_Prv_ShiftBitRt_u16u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    56   * Bfx_Prv_ShiftBitRt_u32u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    57   * Bfx_Prv_ShiftBitRt_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    58   * Bfx_Prv_ToggleBitMask_u16u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    59   * Bfx_Prv_ToggleBitMask_u32u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    60   * Bfx_Prv_ToggleBitMask_u8u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    61   * Bfx_Prv_ToggleBits_u16_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    62   * Bfx_Prv_ToggleBits_u32_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    63   * Bfx_Prv_ToggleBits_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    64   * Bfx_Prv_TstBitLnMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    65   * Bfx_Prv_TstBitLnMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    66   * Bfx_Prv_TstBitLnMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    67   * Bfx_Prv_TstBitMask_u16u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    68   * Bfx_Prv_TstBitMask_u32u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    69   * Bfx_Prv_TstBitMask_u8u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    70   * Bfx_Prv_TstParityEven_u16_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    71   * Bfx_Prv_TstParityEven_u32_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    72   * Bfx_Prv_TstParityEven_u8_u8_Inl
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    73   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    74   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    75   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    76  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    77  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    78   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    79   * Prototypes
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    80   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    81   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    82  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    83  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    84  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    85  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    86  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    87  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    88  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    89  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    90  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    91  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    92  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    93  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    94  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    95  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    96  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    97  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    98  LOCAL_INLINE void Bfx_Prv_PutBit_u16u8u8_Inl(uint16* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	    99  LOCAL_INLINE void Bfx_Prv_PutBit_u32u8u8_Inl(uint32* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   100  LOCAL_INLINE void Bfx_Prv_PutBit_u8u8u8_Inl(uint8* Data, uint8 BitPn, boolean Value);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   101  LOCAL_INLINE void Bfx_Prv_PutBits_u16u8u8u16_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint16 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   102  LOCAL_INLINE void Bfx_Prv_PutBits_u32u8u8u32_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint32 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   103  LOCAL_INLINE void Bfx_Prv_PutBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Pattern);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   104  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u16u16u16_Inl(uint16* Data, uint16 Pattern, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   105  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u32u32u32_Inl(uint32* Data, uint32 Pattern, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   106  LOCAL_INLINE void Bfx_Prv_PutBitsMask_u8u8u8_Inl(uint8* Data, uint8 Pattern, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   107  LOCAL_INLINE void Bfx_Prv_RotBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   108  LOCAL_INLINE void Bfx_Prv_RotBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   109  LOCAL_INLINE void Bfx_Prv_RotBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   110  LOCAL_INLINE void Bfx_Prv_RotBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   111  LOCAL_INLINE void Bfx_Prv_RotBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   112  LOCAL_INLINE void Bfx_Prv_RotBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   113  LOCAL_INLINE void Bfx_Prv_SetBit_u16u8_Inl(uint16* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   114  LOCAL_INLINE void Bfx_Prv_SetBit_u32u8_Inl(uint32* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   115  LOCAL_INLINE void Bfx_Prv_SetBit_u8u8_Inl(uint8* Data, uint8 BitPn);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   116  LOCAL_INLINE void Bfx_Prv_SetBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   117  LOCAL_INLINE void Bfx_Prv_SetBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   118  LOCAL_INLINE void Bfx_Prv_SetBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   119  LOCAL_INLINE void Bfx_Prv_SetBits_u16u8u8u8_Inl(uint16* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   120  LOCAL_INLINE void Bfx_Prv_SetBits_u32u8u8u8_Inl(uint32* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   121  LOCAL_INLINE void Bfx_Prv_SetBits_u8u8u8u8_Inl(uint8* Data, uint8 BitStartPn, uint8 BitLn, uint8 Status);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   122  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   123  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   124  LOCAL_INLINE void Bfx_Prv_ShiftBitLt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   125  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u16u8_Inl(uint16* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   126  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u32u8_Inl(uint32* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   127  LOCAL_INLINE void Bfx_Prv_ShiftBitRt_u8u8_Inl(uint8* Data, uint8 ShiftCnt);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   128  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u16u16_Inl(uint16* Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   129  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u32u32_Inl(uint32* Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   130  LOCAL_INLINE void Bfx_Prv_ToggleBitMask_u8u8_Inl(uint8* Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   131  LOCAL_INLINE void Bfx_Prv_ToggleBits_u16_Inl(uint16* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   132  LOCAL_INLINE void Bfx_Prv_ToggleBits_u32_Inl(uint32* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   133  LOCAL_INLINE void Bfx_Prv_ToggleBits_u8_Inl(uint8* Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   134  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   135  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   136  LOCAL_INLINE boolean Bfx_Prv_TstBitLnMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   137  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u16u16_u8_Inl(uint16 Data, uint16 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   138  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u32u32_u8_Inl(uint32 Data, uint32 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   139  LOCAL_INLINE boolean Bfx_Prv_TstBitMask_u8u8_u8_Inl(uint8 Data, uint8 Mask);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   140  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u16_u8_Inl(uint16 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   141  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u32_u8_Inl(uint32 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   142  LOCAL_INLINE boolean Bfx_Prv_TstParityEven_u8_u8_Inl(uint8 Data);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   143  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   144  /*
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   145   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   146   * Implementations
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   147   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   148   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   149  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   150  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   151   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   152   * Bfx_ClrBit_u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   153   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   154   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   155   * BitPn. A priori, range [0,15] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   156   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   157   * \param   uint16*   Data    pointer to the 16-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   158   * \param   uint8     BitPn   position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   159   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   160   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   161   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   162  LOCAL_INLINE void Bfx_Prv_ClrBit_u16u8_Inl(uint16* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   163  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   164  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   165      *Data &= ((uint16)(~(uint16)(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   166  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   167  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   168  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   169  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   170   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   171   * Bfx_ClrBit_u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   172   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   173   * \brief Clears a bit at the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   174   * BitPn. A priori, range [0,31] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   175   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   176   * \param   uint32*   Data     pointer to the 32-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   177   * \param   uint8     BitPn    position of the bit, to be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   178   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   179   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   180   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   181  LOCAL_INLINE void Bfx_Prv_ClrBit_u32u8_Inl(uint32* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   182  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   183  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   184      *Data &= ((uint32)(~(1uL << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   185  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   186  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   187  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   188  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   189   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   190   * Bfx_ClrBit_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   191   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   192   * \brief Clears a bit in the variable Data to "0". The position of the cleared bit is described by the variable
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   193   * BitPn. A priori, range [0,7] is valid for BitPn. Note, the given position is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   194   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   195   * \param   uint8*   Data     pointer to the 8-bit variable, which should be modified.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   196   * \param   uint8    BitPn    position which bit shall be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   197   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   198   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   199   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   200  LOCAL_INLINE void Bfx_Prv_ClrBit_u8u8_Inl(uint8* Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   201  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   202  /* Additional typecast is required to remove the MISRA 12 warning */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   203      *Data &= ((uint8)(~(uint8)(1u << BitPn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   204  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   205  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   206  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   207  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   208   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   209   * Bfx_ClrBitMask_u16u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   210   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   211   * \brief Clears bits in the 16-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   212   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   213   * \param   uint16*     Data   pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   214   * \param   uint16      Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   215   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   216   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   217   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   218  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u16u16_Inl(uint16* Data, uint16 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   219  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   220      *Data &= ((uint16)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   221  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   222  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   223  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   224  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   225   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   226   * Bfx_ClrBitMask_u32u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   227   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   228   * \brief Clears bits in the 32-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   229   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   230   * \param   uint32*   Data   pointer to the variable, where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   231   * \param   uint32    Mask   bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   232   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   233   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   234   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   235  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u32u32_Inl(uint32* Data, uint32 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   236  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   237      *Data &= ((uint32)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   238  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   239  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   240  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   241  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   242   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   243   * Bfx_ClrBitMask_u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   244   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   245   * \brief Clears bits in the 8-bit variable Data. Every bit, set in Mask, will be cleared.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   246   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   247   * \param   uint8* Data   Pointer to the variable where the bits should be cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   248   * \param   uint8  Mask   Bitmask that defines which bits are cleared
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   249   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   250   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   251   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   252  LOCAL_INLINE void Bfx_Prv_ClrBitMask_u8u8_Inl(uint8* Data, uint8 Mask)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   253  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   254      *Data &= ((uint8)(~Mask));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   255  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   256  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   257  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   258  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   259  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   260   * Bfx_CopyBit_u16u8u16u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   261   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   262   * \brief Copys a bit form a 16-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   263   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   264   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   265   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   266   * \param   uint16*    DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   267   * \param   uint8      DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   268   * \param   uint16     SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   269   * \param   uint8      SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   270   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   271   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   272   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   273  LOCAL_INLINE void Bfx_Prv_CopyBit_u16u8u16u8_Inl(uint16* DestData, uint8 DestPn, uint16 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   274  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   275      Bfx_Prv_PutBit_u16u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u16u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   276  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   277  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   278  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   279  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   280   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   281   * Bfx_CopyBit_u32u8u32u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   282   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   283   * \brief Copys a bit form a 32-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   284   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   285   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   286   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   287   * \param   uint32* DestData    Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   288   * \param   uint8   DestPn      Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   289   * \param   uint32  SrcData     Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   290   * \param   uint8   SrcPn       Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   291   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   292   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   293   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   294  LOCAL_INLINE void Bfx_Prv_CopyBit_u32u8u32u8_Inl(uint32* DestData, uint8 DestPn, uint32 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   295  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   296      Bfx_Prv_PutBit_u32u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u32u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   297  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   298  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   299  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   300  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   301  **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   302   * Bfx_CopyBit_u8u8u8u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   303   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   304   * \brief Copys a bit form a 8-bit variable to an other
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   305   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   306   * Copys a bit from Src[SrcData] to Dest[DestData]
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   307   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   308   * \param   uint8*      DestData     Pointer to bitfield where bit should be copied to.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   309   * \param   uint8       DestPn       Position within the destionation.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   310   * \param   uint8       SrcData      Value of the bitfield to copy from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   311   * \param   uint8       SrcPn        Position within the Source.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   312   * \return  void
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   313   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   314   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   315  LOCAL_INLINE void Bfx_Prv_CopyBit_u8u8u8u8_Inl(uint8* DestData, uint8 DestPn, uint8 SrcData, uint8 SrcPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   316  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   317      Bfx_Prv_PutBit_u8u8u8_Inl(DestData, DestPn, Bfx_Prv_GetBit_u8u8_u8_Inl(SrcData, SrcPn));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   318  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   319  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   320  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   321  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   322   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   323   * Bfx_GetBit_u16u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   324   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   325   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   326   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   327   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   328   * \param   uint16  Data      16-bit variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   329   * \param   uint32  BitPn     Position which bit shall be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   330   * \return  boolean           Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   331   * \retval          TRUE      If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   332   * \retval          FALSE     If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   333   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   334   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   335  LOCAL_INLINE boolean Bfx_Prv_GetBit_u16u8_u8_Inl(uint16 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   336  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   337      return ((((Data) & ((uint16) (1uL << BitPn))) != 0u));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   338  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   339  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   340  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   341  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   342   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   343   * Bfx_GetBit_u32u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   344   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   345   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   346   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   347   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   348   * \param   uint32   Data      32-bit Base variable, where should be read from
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   349   * \param   uint32   BitPn     position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   350   * \return  boolean            returns the bit value from address Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   351   * \retval           TRUE      if the bit at BitPn is one (set)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   352   * \retval           FALSE     if the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   353   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   354   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   355  LOCAL_INLINE boolean Bfx_Prv_GetBit_u32u8_u8_Inl(uint32 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   356  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   357      return (((Data) & ((uint32)(1uL << BitPn))) != 0uL);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   358  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   359  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   360  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   361  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   362   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   363   * Bfx_GetBit_u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   364   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   365   * \brief Gets a bit at the variable Data at a described position BitPn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   366   * Returns TRUE in case, the bit at position BitPn in variable Data is set, otherwise returns FALSE.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   367   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   368   * \param   uint8   Data     8-bit Base variable, where should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   369   * \param   uint32  BitPn    Position which bit shall be read
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   370   * \return  boolean          Returns the bit value from Data at position BitPn
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   371   * \retval          TRUE     If the bit at BitPn is not zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   372   * \retval          FALSE    If the bit at BitPn is zero
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   373   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   374   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   375  LOCAL_INLINE boolean Bfx_Prv_GetBit_u8u8_u8_Inl(uint8 Data, uint8 BitPn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   376  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   377      return (((Data) & ((uint8)(1uL << BitPn))) != 0u);
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   378  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   379  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   380  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   381  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   382   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   383   * Bfx_GetBits_u16u8u8_u16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   384   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   385   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   386   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   387   * The sum of (BitLn + BitStartPn) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   388   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   389   * \param   uint16  Data         16-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   390   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   391   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   392   * \return  uint16               Selected bitfield sequence as uint16
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   393   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   394   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   395  LOCAL_INLINE uint16 Bfx_Prv_GetBits_u16u8u8_u16_Inl(uint16 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   396  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   397      return ((uint16)((Data >> BitStartPn) & (BFX_MAXUINT16_U >> (16uL - BitLn))));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   398  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   399  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   400  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   401  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   402   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   403   * Bfx_GetBits_u32u8u8_u32
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   404   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   405   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   406   * The bitfield starts at the position BitStartPn and has the bit-length BitLn.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   407   * The sum of (BitLn + BitStartPn) has to be smaller than 32. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   408   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   409   * \param   uint32  Data         32-bit variable, where the bit sequence should be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   410   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   411   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   412   * \return  uint32               Selected bitfield sequence as uint32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   413   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   414  */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   415  LOCAL_INLINE uint32 Bfx_Prv_GetBits_u32u8u8_u32_Inl(uint32 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   416  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   417      return ((Data >> BitStartPn) & (BFX_MAXUINT32_U >> (32uL - BitLn)));
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   418  }
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   419  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   420  
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   421  /**
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   422   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   423   * Bfx_GetBits_u8u8u8_u8
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   424   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   425   * \brief Returns a sequence of the variable Data in form of a bitfield.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   426   * The bitfield starts at the position Pos_u32 and has the bit-length Len_u32.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   427   * The sum of (Len_u32 + Pos_u32) has to be smaller than 16. Note, these sum is not monitored.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   428   *
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   429   * \param   uint32  Data         8-bit variable, where the bit sequence shouLd be read from.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   430   * \param   uint8   BitStartPn   Position of the first bit to be read out.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   431   * \param   uint8   BitLn        Length of the section, which should be read.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   432   * \return  uint8                Selected bitfield sequence as uint8.
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   433   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   434   */
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   435  LOCAL_INLINE uint8 Bfx_Prv_GetBits_u8u8u8_u8_Inl(uint8 Data, uint8 BitStartPn, uint8 BitLn)
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   436  {
; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));
	sha	d0,d15,#0
.L202:
	mov	d15,#255
.L203:
	rsub	d1,d1,#8
.L204:
	rsub	d1,#0
	sh	d1,d15,d1
.L205:
	and	d0,d1
.L206:

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   437      return ((uint8)((Data >> BitStartPn) & (BFX_MAXUINT8_U >> (8uL - BitLn))));      (inlined)
	j	.L30

; .\BSW\src\BSW\Gen\Bfx\api\Bfx_Bit_Inl.h	   438  }      (inlined)
.L30:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   244      rxMainFuncId        = (COM_GET_RX_IPDU_CONSTDATA(RxSigConstPtr->IpduRef))->MainFunctionRef;
	ld.bu	d15,[a15]11
	mul	d15,d15,#20
	movh.a	a15,#@his(Com_Prv_xRxIpduCfg_acst)
.L149:
	lea	a15,[a15]@los(Com_Prv_xRxIpduCfg_acst)
	addsc.a	a15,a15,d15,#0
.L207:
	ld.bu	d1,[a15]17
.L151:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   245  
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   246      /* Copy the SigBuffer data into SignalDataPtr*/
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   247      switch(Type)
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   248      {
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   249          /* MR12 RULE 11.5 VIOLATION: For SignalDataPtr is defined as void pointer in the
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   250             AUTOSAR specification, so suppressing warning "Cast from a pointer to void to a pointer to object". */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   251          /* Locks are required here, as the signal buffer may be updated in Com_RxIndication(),
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   252             which may be called in interrupt context. */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   253          case COM_SINT8:
	mov	d15,#1
	jeq	d15,d0,.L31
.L208:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   254              {
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   255                  RxNewVal = (Com_SigMaxType)COM_GET_SIGTYPEUINT8_BUFF(rxMainFuncId, SigBuff_Index);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   256                  *(sint8*)SignalDataPtr =  (sint8)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   257              }
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   258              break;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   259          case COM_SINT16:
	mov	d15,#3
	jeq	d15,d0,.L32
.L209:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   260              {
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   261                  #if (CPU_TYPE == CPU_TYPE_8)
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   262                  SchM_Enter_Com_RxSigBuff(RECEIVESIGNAL);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   263                  #endif
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   264                  RxNewVal = (Com_SigMaxType)COM_GET_SIGTYPEUINT16_BUFF(rxMainFuncId, SigBuff_Index);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   265                  #if (CPU_TYPE == CPU_TYPE_8)
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   266                  SchM_Exit_Com_RxSigBuff(RECEIVESIGNAL);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   267                  #endif
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   268                  *(sint16*)SignalDataPtr =  (sint16)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   269              }
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   270              break;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   271          case COM_SINT32:
	mov	d2,#5
.L147:
	jeq	d2,d0,.L33
	j	.L34

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   253          case COM_SINT8:      (inlined)
.L31:
	mul	d15,d1,#12
	movh.a	a15,#@his(Com_Prv_xRxRamBuf_acst)
	lea	a15,[a15]@los(Com_Prv_xRxRamBuf_acst)
	addsc.a	a15,a15,d15,#0
	ld.a	a15,[a15]
	addsc.a	a15,a15,d3,#0
	ld.bu	d15,[a15]
.L152:
	st.b	[a12],d15
.L210:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   258              break;      (inlined)
	j	.L35

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   259          case COM_SINT16:      (inlined)
.L32:
	mul	d15,d1,#12
	movh.a	a15,#@his(Com_Prv_xRxRamBuf_acst)
	lea	a15,[a15]@los(Com_Prv_xRxRamBuf_acst)
	addsc.a	a15,a15,d15,#0
	ld.a	a15,[a15]4
	addsc.a	a15,a15,d3,#1
	ld.hu	d15,[a15]0
.L153:
	st.h	[a12],d15
.L211:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   270              break;      (inlined)
	j	.L36

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   271          case COM_SINT32:      (inlined)
.L33:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   272              {
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   273                  #if (CPU_TYPE != CPU_TYPE_32)
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   274                  SchM_Enter_Com_RxSigBuff(RECEIVESIGNAL);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   275                  #endif
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   276                  RxNewVal = (Com_SigMaxType)COM_GET_SIGTYPEUINT32_BUFF(rxMainFuncId, SigBuff_Index);
	mul	d15,d1,#12
	movh.a	a15,#@his(Com_Prv_xRxRamBuf_acst)
	lea	a15,[a15]@los(Com_Prv_xRxRamBuf_acst)
	addsc.a	a15,a15,d15,#0
	ld.a	a15,[a15]8
	addsc.a	a15,a15,d3,#2
	ld.w	d15,[a15]
.L154:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   277                  #if (CPU_TYPE != CPU_TYPE_32)
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   278                  SchM_Exit_Com_RxSigBuff(RECEIVESIGNAL);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   279                  #endif
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   280                  *(sint32*)SignalDataPtr =  (sint32)RxNewVal;
	st.w	[a12],d15
.L212:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   282              break;      (inlined)
	j	.L37

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   294          default:      (inlined)
.L34:

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   299              break;      (inlined)
	j	.L38

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   301  }      (inlined)
.L38:
.L37:
.L36:
.L35:
.L29:
.L10:
	mov	d2,d9
.L155:
	j	.L39
.L39:
	ret
.L52:
	
__Com_ReceiveSignal_function_end:
	.size	Com_ReceiveSignal,__Com_ReceiveSignal_function_end-Com_ReceiveSignal
.L50:
	; End of function
	
	.calls	'Com_ReceiveSignal','Det_ReportError'
	.calls	'Com_ReceiveSignal','Com_ByteCopy'
	.extern	Det_ReportError
	.extern	Com_ByteCopy
	.extern	Com_Uninit_Flag
	.extern	Com_RxIpduRam_s
	.extern	Com_Prv_xRxSigCfg_acst
	.extern	Com_Prv_xRxIpduCfg_acst
	.extern	Com_Prv_xRxRamBuf_acst
	.calls	'Com_ReceiveSignal','',0
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L43:
	.word	14232
	.half	3
	.word	.L44
	.byte	4
.L42:
	.byte	1
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_ReceiveSignal.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L45
.L51:
	.byte	2
	.byte	'unsigned char',0,1,8
.L53:
	.byte	2
	.byte	'unsigned short int',0,2,7,3
	.byte	'Bfx_Prv_GetBit_u16u8_u8_Inl',0,3,1,207,2,22
	.word	143
	.byte	1,1,4
	.byte	'Data',0,1,207,2,57
	.word	160
	.byte	4
	.byte	'BitPn',0,1,207,2,69
	.word	143
	.byte	5,0
.L103:
	.byte	2
	.byte	'unsigned int',0,4,7,3
	.byte	'Bfx_Prv_GetBit_u32u8_u8_Inl',0,3,1,227,2,22
	.word	143
	.byte	1,1,4
	.byte	'Data',0,1,227,2,57
	.word	253
	.byte	4
	.byte	'BitPn',0,1,227,2,69
	.word	143
	.byte	5,0
.L88:
	.byte	3
	.byte	'Bfx_Prv_GetBit_u8u8_u8_Inl',0,3,1,247,2,22
	.word	143
	.byte	1,1
.L90:
	.byte	4
	.byte	'Data',0,1,247,2,55
	.word	143
.L92:
	.byte	4
	.byte	'BitPn',0,1,247,2,67
	.word	143
.L94:
	.byte	5,0
.L73:
	.byte	3
	.byte	'Bfx_Prv_GetBits_u8u8u8_u8_Inl',0,3,1,179,3,20
	.word	143
	.byte	1,1
.L75:
	.byte	4
	.byte	'Data',0,1,179,3,56
	.word	143
.L77:
	.byte	4
	.byte	'BitStartPn',0,1,179,3,68
	.word	143
.L79:
	.byte	4
	.byte	'BitLn',0,1,179,3,86
	.word	143
.L81:
	.byte	5,0,6
	.word	160
	.byte	7
	.byte	'Bfx_Prv_PutBit_u16u8u8_Inl',0,3,1,200,3,19,1,1,4
	.byte	'Data',0,1,200,3,54
	.word	503
	.byte	4
	.byte	'BitPn',0,1,200,3,66
	.word	143
	.byte	4
	.byte	'Value',0,1,200,3,81
	.word	143
	.byte	5,0,6
	.word	253
	.byte	7
	.byte	'Bfx_Prv_PutBit_u32u8u8_Inl',0,3,1,224,3,19,1,1,4
	.byte	'Data',0,1,224,3,54
	.word	589
	.byte	4
	.byte	'BitPn',0,1,224,3,66
	.word	143
	.byte	4
	.byte	'Value',0,1,224,3,81
	.word	143
	.byte	5,0,6
	.word	143
	.byte	7
	.byte	'Bfx_Prv_PutBit_u8u8u8_Inl',0,3,1,248,3,19,1,1,4
	.byte	'Data',0,1,248,3,52
	.word	675
	.byte	4
	.byte	'BitPn',0,1,248,3,64
	.word	143
	.byte	4
	.byte	'Value',0,1,248,3,79
	.word	143
	.byte	5,0,3
	.byte	'Bfx_Prv_TstParityEven_u32_u8_Inl',0,3,1,143,10,22
	.word	143
	.byte	1,1,4
	.byte	'Data',0,1,143,10,62
	.word	253
	.byte	5,0
.L82:
	.byte	3
	.byte	'Com_CheckRxIPduStatus',0,3,2,185,8,22
	.word	143
	.byte	1,1
.L84:
	.byte	4
	.byte	'IpduId',0,2,185,8,54
	.word	160
.L86:
	.byte	8,5,0,0
.L61:
	.byte	3
	.byte	'Com_Prv_DETCheck_Param_Ptr',0,3,2,168,7,37
	.word	143
	.byte	1,1
.L64:
	.byte	4
	.byte	'isInValidParam',0,2,168,7,72
	.word	143
.L66:
	.byte	4
	.byte	'isInValidPtr',0,2,168,7,96
	.word	143
.L68:
	.byte	4
	.byte	'ApiId',0,2,168,7,116
	.word	143
.L70:
	.byte	5,0,9
	.byte	'void',0
.L55:
	.byte	6
	.word	977
.L95:
	.byte	7
	.byte	'Com_Prv_CopyData_UnsignedType',0,3,3,87,35,1,1
.L97:
	.byte	4
	.byte	'SignalId',0,3,87,98
	.word	160
.L99:
	.byte	4
	.byte	'SignalDataPtr',0,3,88,103
	.word	983
.L101:
	.byte	8,5,0,0
.L109:
	.byte	7
	.byte	'Com_Prv_CopyData_signedType',0,3,3,228,1,35,1,1
.L110:
	.byte	4
	.byte	'SignalId',0,3,228,1,96
	.word	160
.L112:
	.byte	4
	.byte	'SignalDataPtr',0,3,229,1,101
	.word	983
.L114:
	.byte	8,5,0,0,10,1,1,6
	.word	1149
	.byte	11,4,247,1,9,16,12
	.byte	'Notification_Cbk',0
	.word	1152
	.byte	4,2,35,0,12
	.byte	'Init_Val',0
	.word	253
	.byte	4,2,35,4,12
	.byte	'Bit_Pos',0
	.word	143
	.byte	1,2,35,8,12
	.byte	'SigBuff_Index',0
	.word	143
	.byte	1,2,35,9,12
	.byte	'BitSize',0
	.word	143
	.byte	1,2,35,10,12
	.byte	'IpduRef',0
	.word	143
	.byte	1,2,35,11,12
	.byte	'General',0
	.word	143
	.byte	1,2,35,12,12
	.byte	'rxSignalFields',0
	.word	143
	.byte	1,2,35,13,0,13
	.word	1157
	.byte	6
	.word	1323
	.byte	13
	.word	1157
	.byte	6
	.word	1333
.L57:
	.byte	14
	.byte	'Com_RxSigConstPtrType',0,4,180,2,68
	.word	1338
	.byte	15
	.byte	'Det_ReportError',0,5,112,16
	.word	143
	.byte	1,1,1,1,4
	.byte	'ModuleId',0,5,112,39
	.word	160
	.byte	4
	.byte	'InstanceId',0,5,112,55
	.word	143
	.byte	4
	.byte	'ApiId',0,5,112,73
	.word	143
	.byte	4
	.byte	'ErrorId',0,5,112,86
	.word	143
	.byte	0,16
	.word	182
	.byte	17
	.word	222
	.byte	17
	.word	236
	.byte	5,0,16
	.word	269
	.byte	17
	.word	309
	.byte	17
	.word	323
	.byte	5,0,16
	.word	340
	.byte	17
	.word	379
	.byte	17
	.word	393
	.byte	5,0,16
	.word	410
	.byte	17
	.word	452
	.byte	17
	.word	466
	.byte	17
	.word	486
	.byte	5,0,16
	.word	508
	.byte	17
	.word	543
	.byte	17
	.word	557
	.byte	17
	.word	572
	.byte	5,0,16
	.word	594
	.byte	17
	.word	629
	.byte	17
	.word	643
	.byte	17
	.word	658
	.byte	5,0,16
	.word	680
	.byte	17
	.word	714
	.byte	17
	.word	728
	.byte	17
	.word	743
	.byte	5,0,16
	.word	760
	.byte	17
	.word	805
	.byte	5,0,13
	.word	143
	.byte	6
	.word	1620
	.byte	18
	.byte	'Com_ByteCopy',0,6,240,20,22,1,1,1,1,4
	.byte	'dest',0,6,240,20,77
	.word	675
	.byte	4
	.byte	'src',0,6,241,20,77
	.word	1625
	.byte	4
	.byte	'Len',0,6,242,20,77
	.word	253
	.byte	0,16
	.word	821
	.byte	17
	.word	855
	.byte	8,19
	.word	340
	.byte	17
	.word	379
	.byte	17
	.word	393
	.byte	20
	.word	408
	.byte	0,5,0,0,16
	.word	875
	.byte	17
	.word	914
	.byte	17
	.word	938
	.byte	17
	.word	960
	.byte	5,0,16
	.word	988
	.byte	17
	.word	1025
	.byte	17
	.word	1042
	.byte	8,19
	.word	410
	.byte	17
	.word	452
	.byte	17
	.word	466
	.byte	17
	.word	486
	.byte	20
	.word	501
	.byte	0,5,0,0,16
	.word	1068
	.byte	17
	.word	1104
	.byte	17
	.word	1122
	.byte	8,19
	.word	410
	.byte	17
	.word	452
	.byte	17
	.word	466
	.byte	17
	.word	486
	.byte	20
	.word	501
	.byte	0,5,0,0,21,1,6
	.word	1840
	.byte	14
	.byte	'__codeptr',0,3,1,1
	.word	1842
	.byte	2
	.byte	'char',0,1,6,14
	.byte	'sint8',0,7,76,25
	.word	1865
	.byte	14
	.byte	'uint8',0,7,81,25
	.word	143
	.byte	14
	.byte	'uint16',0,7,91,25
	.word	160
	.byte	14
	.byte	'uint32',0,7,106,24
	.word	253
	.byte	2
	.byte	'unsigned long long int',0,8,7,14
	.byte	'uint64',0,7,111,30
	.word	1931
	.byte	14
	.byte	'boolean',0,7,127,25
	.word	143
	.byte	14
	.byte	'StatusType',0,8,191,1,27
	.word	143
	.byte	14
	.byte	'Std_ReturnType',0,8,199,1,15
	.word	143
	.byte	11,8,206,1,9,8,12
	.byte	'vendorID',0
	.word	160
	.byte	2,2,35,0,12
	.byte	'moduleID',0
	.word	160
	.byte	2,2,35,2,12
	.byte	'sw_major_version',0
	.word	143
	.byte	1,2,35,4,12
	.byte	'sw_minor_version',0
	.word	143
	.byte	1,2,35,5,12
	.byte	'sw_patch_version',0
	.word	143
	.byte	1,2,35,6,0,14
	.byte	'Std_VersionInfoType',0,8,213,1,3
	.word	2032
	.byte	14
	.byte	'PduIdType',0,9,22,19
	.word	160
	.byte	14
	.byte	'PduLengthType',0,9,26,19
	.word	160
	.byte	22,10,113,9,4,23
	.byte	'TP_DATACONF',0,0,23
	.byte	'TP_DATARETRY',0,1,23
	.byte	'TP_CONFPENDING',0,2,0,14
	.byte	'TpDataStateType',0,10,118,3
	.word	2222
	.byte	14
	.byte	'Com_SignalIdType',0,11,100,16
	.word	160
	.byte	14
	.byte	'Com_SignalGroupIdType',0,11,102,16
	.word	160
	.byte	14
	.byte	'Com_IpduIdType',0,11,104,15
	.word	143
	.byte	14
	.byte	'Com_GrpSignalIdType',0,11,107,18
	.word	143
	.byte	22,11,117,9,4,23
	.byte	'COM_UNINIT',0,0,23
	.byte	'COM_INIT',0,1,0,14
	.byte	'Com_StatusType',0,11,121,2
	.word	2404
	.byte	14
	.byte	'Com_TxIntSignalIdType',0,12,138,3,18
	.word	143
	.byte	14
	.byte	'Com_RxIntSignalIdType',0,12,139,3,18
	.word	143
	.byte	14
	.byte	'Com_BitsizeType',0,12,155,3,17
	.word	143
	.byte	14
	.byte	'Com_BitpositionType',0,12,156,3,15
	.word	143
	.byte	14
	.byte	'Com_RxGwQueueIndexType',0,12,161,3,15
	.word	143
	.byte	14
	.byte	'Com_SigBuffIndexType',0,12,164,3,15
	.word	143
	.byte	14
	.byte	'Com_SigMaxType',0,12,198,3,16
	.word	253
	.byte	14
	.byte	'Com_MainFuncType',0,12,231,3,16
	.word	143
	.byte	14
	.byte	'Com_NumOfIpdusType',0,12,233,3,15
	.word	143
	.byte	14
	.byte	'Com_TimeBaseType',0,12,235,3,15
	.word	143
	.byte	14
	.byte	'Can_IdType',0,13,32,16
	.word	253
	.byte	14
	.byte	'Can_HwHandleType',0,13,43,16
	.word	160
	.byte	11,14,93,9,8,12
	.byte	'Class',0
	.word	143
	.byte	1,2,35,0,12
	.byte	'TIN',0
	.word	143
	.byte	1,2,35,1,12
	.byte	'ReturnAddress',0
	.word	253
	.byte	4,2,35,4,0,14
	.byte	'OsTrapInfoType',0,14,97,3
	.word	2783
	.byte	24,68
	.word	253
	.byte	25,16,0,11,14,154,1,9,68,12
	.byte	'store',0
	.word	2863
	.byte	68,2,35,0,0,24,68
	.word	2872
	.byte	25,0,0,14
	.byte	'Os_JumpBufType',0,14,156,1,3
	.word	2894
	.byte	14
	.byte	'Os_StackTraceType',0,14,174,1,18
	.word	253
	.byte	11,14,175,1,9,8,12
	.byte	'sp',0
	.word	253
	.byte	4,2,35,0,12
	.byte	'ctx',0
	.word	253
	.byte	4,2,35,4,0,14
	.byte	'Os_StackValueType',0,14,175,1,63
	.word	2954
	.byte	14
	.byte	'Os_StackSizeType',0,14,176,1,27
	.word	2954
	.byte	14
	.byte	'Os_VoidVoidFunctionType',0,14,179,1,16
	.word	1152
	.byte	14
	.byte	'ApplicationType',0,14,193,1,23
	.word	143
	.byte	26
	.byte	'Os_ApplicationConfigurationType_s',0,14,198,1,16,2,12
	.byte	'app_id',0
	.word	143
	.byte	1,2,35,0,12
	.byte	'access',0
	.word	143
	.byte	1,2,35,1,0,14
	.byte	'Os_ApplicationConfigurationType',0,14,201,1,3
	.word	3097
	.byte	14
	.byte	'Os_CoreStateType',0,14,203,1,16
	.word	253
	.byte	14
	.byte	'AreaIdType',0,14,204,1,16
	.word	160
	.byte	14
	.byte	'Os_PeripheralAddressType',0,14,212,1,22
	.word	253
	.byte	14
	.byte	'TickType',0,14,221,1,22
	.word	253
	.byte	14
	.byte	'Os_StopwatchTickType',0,14,225,1,22
	.word	253
	.byte	14
	.byte	'Os_Lockable',0,14,234,1,18
	.word	589
	.byte	14
	.byte	'CoreIdType',0,14,236,1,16
	.word	160
	.byte	14
	.byte	'SpinlockIdType',0,14,237,1,16
	.word	160
	.byte	22,14,239,1,9,4,23
	.byte	'TRYTOGETSPINLOCK_SUCCESS',0,0,23
	.byte	'TRYTOGETSPINLOCK_NOSUCCESS',0,1,0,14
	.byte	'TryToGetSpinlockType',0,14,239,1,74
	.word	3404
	.byte	22,14,174,2,9,4,23
	.byte	'APPLICATION_ACCESSIBLE',0,0,23
	.byte	'APPLICATION_RESTARTING',0,1,23
	.byte	'APPLICATION_TERMINATED',0,2,0,14
	.byte	'ApplicationStateType',0,14,174,2,92
	.word	3497
	.byte	27,1,1,28
	.word	143
	.byte	28
	.word	983
	.byte	0,6
	.word	3609
	.byte	14
	.byte	'Os_FunctionEntryType',0,14,183,2,16
	.word	3623
	.byte	26
	.byte	'Os_MeterInfoType_s',0,14,193,2,16,48,12
	.byte	'elapsed',0
	.word	253
	.byte	4,2,35,0,12
	.byte	'previous',0
	.word	253
	.byte	4,2,35,4,12
	.byte	'max',0
	.word	253
	.byte	4,2,35,8,12
	.byte	'cumulative',0
	.word	253
	.byte	4,2,35,12,12
	.byte	'stackbase',0
	.word	2954
	.byte	8,2,35,16,12
	.byte	'stackusage',0
	.word	2954
	.byte	8,2,35,24,12
	.byte	'stackmax',0
	.word	2954
	.byte	8,2,35,32,12
	.byte	'stackbudget',0
	.word	2954
	.byte	8,2,35,40,0,14
	.byte	'Os_MeterInfoType',0,14,202,2,3
	.word	3658
	.byte	6
	.word	3658
	.byte	14
	.byte	'Os_MeterInfoRefType',0,14,203,2,50
	.word	3856
	.byte	14
	.byte	'EventMaskType',0,14,206,2,15
	.word	143
	.byte	14
	.byte	'Os_imaskType',0,14,211,2,16
	.word	253
	.byte	26
	.byte	'Os_ISRDynType_s',0,14,213,2,16,48,12
	.byte	'meter',0
	.word	3658
	.byte	48,2,35,0,0,14
	.byte	'Os_ISRDynType',0,14,215,2,3
	.word	3935
	.byte	6
	.word	3935
	.byte	13
	.word	3996
	.byte	26
	.byte	'Os_ISRType_s',0,14,216,2,16,24,12
	.byte	'entry_function',0
	.word	3039
	.byte	4,2,35,0,12
	.byte	'dynamic',0
	.word	4001
	.byte	4,2,35,4,12
	.byte	'imask',0
	.word	253
	.byte	4,2,35,8,12
	.byte	'stackbudget',0
	.word	2954
	.byte	8,2,35,12,12
	.byte	'access',0
	.word	143
	.byte	1,2,35,20,12
	.byte	'application',0
	.word	143
	.byte	1,2,35,21,0,14
	.byte	'Os_ISRType',0,14,223,2,3
	.word	4006
	.byte	6
	.word	1149
	.byte	13
	.word	4006
	.byte	6
	.word	4165
	.byte	14
	.byte	'ISRType',0,14,224,2,46
	.word	4170
	.byte	14
	.byte	'Os_bitmask',0,14,239,2,22
	.word	253
	.byte	14
	.byte	'Os_pset0Type',0,14,240,2,20
	.word	253
	.byte	14
	.byte	'Os_pset1Type',0,14,241,2,20
	.word	253
	.byte	14
	.byte	'Os_pset2Type',0,14,242,2,20
	.word	253
	.byte	29,14,243,2,9,4,12
	.byte	'p0',0
	.word	253
	.byte	4,2,35,0,12
	.byte	'p1',0
	.word	253
	.byte	4,2,35,0,12
	.byte	'p2',0
	.word	253
	.byte	4,2,35,0,0,14
	.byte	'Os_psetType',0,14,247,2,3
	.word	4278
	.byte	29,14,249,2,9,4,12
	.byte	't0',0
	.word	253
	.byte	4,2,35,0,12
	.byte	't1',0
	.word	253
	.byte	4,2,35,0,12
	.byte	't2',0
	.word	253
	.byte	4,2,35,0,0,14
	.byte	'Os_tpmaskType',0,14,253,2,3
	.word	4342
	.byte	14
	.byte	'Os_ActivationCountType',0,14,254,2,23
	.word	143
	.byte	26
	.byte	'Os_TaskDynType_s',0,14,128,3,16,120,12
	.byte	'terminate_jump_buf',0
	.word	2903
	.byte	68,2,35,0,12
	.byte	'meter',0
	.word	3658
	.byte	48,2,35,68,12
	.byte	'activation_count',0
	.word	143
	.byte	1,2,35,116,0,14
	.byte	'Os_TaskDynType',0,14,132,3,3
	.word	4440
	.byte	24,68
	.word	2872
	.byte	25,0,0,6
	.word	4440
	.byte	13
	.word	4566
	.byte	26
	.byte	'Os_TaskType_s',0,14,134,3,16,40,12
	.byte	'dynamic',0
	.word	4571
	.byte	4,2,35,0,12
	.byte	'entry_function',0
	.word	3039
	.byte	4,2,35,4,12
	.byte	'pset',0
	.word	4278
	.byte	4,2,35,8,12
	.byte	'base_tpmask',0
	.word	4342
	.byte	4,2,35,12,12
	.byte	'tpmask',0
	.word	4342
	.byte	4,2,35,16,12
	.byte	'core_id',0
	.word	160
	.byte	2,2,35,20,12
	.byte	'index',0
	.word	253
	.byte	4,2,35,24,12
	.byte	'stackbudget',0
	.word	2954
	.byte	8,2,35,28,12
	.byte	'activation_count',0
	.word	143
	.byte	1,2,35,36,12
	.byte	'access',0
	.word	143
	.byte	1,2,35,37,12
	.byte	'application',0
	.word	143
	.byte	1,2,35,38,0,14
	.byte	'Os_TaskType',0,14,146,3,3
	.word	4576
	.byte	13
	.word	4576
	.byte	6
	.word	4826
	.byte	14
	.byte	'TaskType',0,14,147,3,47
	.word	4831
	.byte	30
	.byte	'Os_TaskStateType',0,14,155,3,6,4,23
	.byte	'SUSPENDED',0,0,23
	.byte	'READY',0,1,23
	.byte	'WAITING',0,2,23
	.byte	'RUNNING',0,3,0,14
	.byte	'TaskStateType',0,14,156,3,31
	.word	4854
	.byte	29,14,167,3,3,4,12
	.byte	'tpmask',0
	.word	4342
	.byte	4,2,35,0,0,26
	.byte	'Os_ResourceDynType_s',0,14,166,3,16,4,12
	.byte	'saved_priority',0
	.word	4941
	.byte	4,2,35,0,0,14
	.byte	'Os_ResourceDynType',0,14,170,3,3
	.word	4964
	.byte	6
	.word	4964
	.byte	13
	.word	5044
	.byte	26
	.byte	'Os_ResourceType_s',0,14,171,3,16,12,12
	.byte	'dynamic',0
	.word	5049
	.byte	4,2,35,0,12
	.byte	'tpmask',0
	.word	4342
	.byte	4,2,35,4,12
	.byte	'access',0
	.word	143
	.byte	1,2,35,8,0,14
	.byte	'Os_ResourceType',0,14,175,3,3
	.word	5054
	.byte	11,14,181,3,9,12,12
	.byte	'maxallowedvalue',0
	.word	253
	.byte	4,2,35,0,12
	.byte	'ticksperbase',0
	.word	253
	.byte	4,2,35,4,12
	.byte	'mincycle',0
	.word	253
	.byte	4,2,35,8,0,14
	.byte	'AlarmBaseType',0,14,185,3,3
	.word	5153
	.byte	11,14,206,3,9,8,12
	.byte	'Running',0
	.word	143
	.byte	1,2,35,0,12
	.byte	'Pending',0
	.word	143
	.byte	1,2,35,1,12
	.byte	'Delay',0
	.word	253
	.byte	4,2,35,4,0,14
	.byte	'Os_CounterStatusType',0,14,210,3,3
	.word	5248
	.byte	31
	.word	143
	.byte	1,1,6
	.word	5334
	.byte	14
	.byte	'Os_CounterIncrAdvType',0,14,217,3,22
	.word	5341
	.byte	26
	.byte	's_swd',0,14,222,3,12,4,12
	.byte	'count',0
	.word	253
	.byte	4,2,35,0,0,29,14,221,3,3,4,12
	.byte	'sw',0
	.word	5377
	.byte	4,2,35,0,0,26
	.byte	'Os_CounterDynType_s',0,14,220,3,16,4,12
	.byte	'type_dependent',0
	.word	5405
	.byte	4,2,35,0,0,14
	.byte	'Os_CounterDynType',0,14,226,3,3
	.word	5424
	.byte	6
	.word	5424
	.byte	13
	.word	5502
	.byte	26
	.byte	'Os_CounterType_s',0,14,227,3,16,28,12
	.byte	'dynamic',0
	.word	5507
	.byte	4,2,35,0,12
	.byte	'advincr',0
	.word	5346
	.byte	4,2,35,4,12
	.byte	'base',0
	.word	5153
	.byte	12,2,35,8,12
	.byte	'core',0
	.word	983
	.byte	4,2,35,20,12
	.byte	'access',0
	.word	143
	.byte	1,2,35,24,12
	.byte	'application',0
	.word	143
	.byte	1,2,35,25,0,14
	.byte	'Os_CounterType',0,14,234,3,3
	.word	5512
	.byte	6
	.word	5334
	.byte	13
	.word	5512
	.byte	6
	.word	5664
	.byte	14
	.byte	'CounterType',0,14,235,3,52
	.word	5669
	.byte	30
	.byte	'Os_ScheduleTableStatusType',0,14,240,3,6,4,23
	.byte	'SCHEDULETABLE_STOPPED',0,0,23
	.byte	'SCHEDULETABLE_NEXT',0,1,23
	.byte	'SCHEDULETABLE_WAITING',0,2,23
	.byte	'SCHEDULETABLE_RUNNING',0,3,23
	.byte	'SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS',0,4,0,14
	.byte	'ScheduleTableStatusType',0,14,241,3,41
	.word	5695
	.byte	13
	.word	.L156-.L43
	.byte	6
	.word	5895
	.byte	14
	.byte	'ScheduleTableType',0,14,128,4,58
	.word	5900
	.byte	26
	.byte	'Os_ScheduleTableDynType_s',0,14,130,4,16,16,12
	.byte	'match',0
	.word	253
	.byte	4,2,35,0,12
	.byte	'next',0
	.word	5905
	.byte	4,2,35,4,12
	.byte	'state',0
	.word	5695
	.byte	4,2,35,8,12
	.byte	'config',0
	.word	160
	.byte	2,2,35,12,0,6
	.word	5932
	.byte	13
	.word	6025
.L156:
	.byte	26
	.byte	'Os_ScheduleTableType_s',0,14,247,3,16,16,12
	.byte	'dynamic',0
	.word	6030
	.byte	4,2,35,0,12
	.byte	'counter',0
	.word	5674
	.byte	4,2,35,4,12
	.byte	'repeat',0
	.word	143
	.byte	1,2,35,8,12
	.byte	'config',0
	.word	160
	.byte	2,2,35,10,12
	.byte	'initial',0
	.word	143
	.byte	1,2,35,12,12
	.byte	'access',0
	.word	143
	.byte	1,2,35,13,12
	.byte	'application',0
	.word	143
	.byte	1,2,35,14,0,14
	.byte	'Os_ScheduleTableType',0,14,255,3,3
	.word	6035
	.byte	13
	.word	6035
	.byte	6
	.word	6215
	.byte	13
	.word	5512
	.byte	6
	.word	6225
	.byte	32
	.word	3339
	.byte	32
	.word	4278
	.byte	32
	.word	4175
	.byte	32
	.word	4836
	.byte	32
	.word	4342
	.byte	32
	.word	143
	.byte	32
	.word	4836
	.byte	26
	.byte	'Os_ControlledCoreType_s',0,14,251,6,16,112,12
	.byte	'TrapInfo',0
	.word	2783
	.byte	8,2,35,0,12
	.byte	'lock_taskaccess',0
	.word	6235
	.byte	4,2,35,8,12
	.byte	'ReadyTasks',0
	.word	6240
	.byte	4,2,35,12,12
	.byte	'RunningISR',0
	.word	6245
	.byte	4,2,35,16,12
	.byte	'RunningTask',0
	.word	6250
	.byte	4,2,35,20,12
	.byte	'RunningTPMask',0
	.word	6255
	.byte	4,2,35,24,12
	.byte	'CurrentMeteredObject',0
	.word	3861
	.byte	4,2,35,28,12
	.byte	'IdleMeter',0
	.word	3658
	.byte	48,2,35,32,12
	.byte	'AppAccess',0
	.word	143
	.byte	1,2,35,80,12
	.byte	'AppOverride',0
	.word	6260
	.byte	1,2,35,81,12
	.byte	'GetStackValueAdjust',0
	.word	2954
	.byte	8,2,35,84,12
	.byte	'InErrorHook',0
	.word	143
	.byte	1,2,35,92,12
	.byte	'ChainTaskRef',0
	.word	6265
	.byte	4,2,35,96,12
	.byte	'GetStackUsageAdjust',0
	.word	2954
	.byte	8,2,35,100,12
	.byte	'InProtectionHook',0
	.word	143
	.byte	1,2,35,108,12
	.byte	'CoreIsActive',0
	.word	143
	.byte	1,2,35,109,12
	.byte	'InShutdownHook',0
	.word	143
	.byte	1,2,35,110,0,14
	.byte	'Os_ControlledCoreType',0,14,141,7,3
	.word	6270
	.byte	6
	.word	253
	.byte	13
	.word	4006
	.byte	6
	.word	6726
	.byte	13
	.word	4576
	.byte	6
	.word	6736
	.byte	6
	.word	3658
	.byte	26
	.byte	'Os_AnyCoreType_s',0,14,151,7,16,96,12
	.byte	'DisableAllImask',0
	.word	253
	.byte	4,2,35,0,12
	.byte	'SuspendAllImask',0
	.word	253
	.byte	4,2,35,4,12
	.byte	'SuspendOSImask',0
	.word	253
	.byte	4,2,35,8,12
	.byte	'DisableAllCount',0
	.word	253
	.byte	4,2,35,12,12
	.byte	'SuspendAllCount',0
	.word	253
	.byte	4,2,35,16,12
	.byte	'SuspendOSCount',0
	.word	253
	.byte	4,2,35,20,12
	.byte	'RestartJumpBuf',0
	.word	2903
	.byte	68,2,35,24,12
	.byte	'Restartable',0
	.word	143
	.byte	1,2,35,92,0,14
	.byte	'Os_AnyCoreType',0,14,160,7,3
	.word	6751
	.byte	14
	.byte	'Can_TxObjPriorityClassType',0,15,219,3,16
	.word	253
	.byte	26
	.byte	'Can_TxHwObjectConfigType',0,15,231,3,16,8,12
	.byte	'MsgObjId',0
	.word	143
	.byte	1,2,35,0,12
	.byte	'HwControllerId',0
	.word	143
	.byte	1,2,35,1,12
	.byte	'TxObjPriorityClass',0
	.word	253
	.byte	4,2,35,4,0,14
	.byte	'Can_TxHwObjectConfigType',0,15,252,3,3
	.word	7028
	.byte	26
	.byte	'Can_RxHwObjectConfigType',0,15,129,4,16,12,12
	.byte	'MaskRef',0
	.word	253
	.byte	4,2,35,0,12
	.byte	'MsgId',0
	.word	253
	.byte	4,2,35,4,12
	.byte	'MsgObjId',0
	.word	143
	.byte	1,2,35,8,12
	.byte	'HwControllerId',0
	.word	143
	.byte	1,2,35,9,0,14
	.byte	'Can_RxHwObjectConfigType',0,15,147,4,3
	.word	7164
	.byte	24,4
	.word	143
	.byte	25,3,0,26
	.byte	'Can_ControllerMOMapConfigType',0,15,181,4,16,4,12
	.byte	'ControllerMOMap',0
	.word	7304
	.byte	4,2,35,0,0,14
	.byte	'Can_ControllerMOMapConfigType',0,15,184,4,3
	.word	7313
	.byte	26
	.byte	'Can_NPCRValueType',0,15,188,4,16,2,12
	.byte	'Can_NPCRValue',0
	.word	160
	.byte	2,2,35,0,0,14
	.byte	'Can_NPCRValueType',0,15,191,4,3
	.word	7414
	.byte	26
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,15,194,4,16,8,12
	.byte	'CanControllerBaudrate',0
	.word	253
	.byte	4,2,35,0,12
	.byte	'CanControllerBaudrateCfg',0
	.word	160
	.byte	2,2,35,4,0,14
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,15,198,4,3
	.word	7489
	.byte	13
	.word	7489
	.byte	6
	.word	7654
	.byte	26
	.byte	'Can_BaudrateConfigPtrType',0,15,201,4,16,4,12
	.byte	'Can_kBaudrateConfigPtr',0
	.word	7659
	.byte	4,2,35,0,0,14
	.byte	'Can_BaudrateConfigPtrType',0,15,204,4,3
	.word	7664
	.byte	26
	.byte	'Can_EventHandlingType',0,15,226,4,16,4,12
	.byte	'CanEventType',0
	.word	7304
	.byte	4,2,35,0,0,14
	.byte	'Can_EventHandlingType',0,15,229,4,3
	.word	7764
	.byte	14
	.byte	'Rte_TransformerErrorCode',0,16,130,1,15
	.word	143
	.byte	14
	.byte	'Rte_TransformerClass',0,16,131,1,15
	.word	143
	.byte	11,16,168,1,9,12,12
	.byte	'in',0
	.word	983
	.byte	4,2,35,0,12
	.byte	'out',0
	.word	983
	.byte	4,2,35,4,12
	.byte	'used',0
	.word	160
	.byte	2,2,35,8,12
	.byte	'lost_data',0
	.word	143
	.byte	1,2,35,10,0,14
	.byte	'Rte_QDynType',0,16,173,1,3
	.word	7910
	.byte	22,16,175,1,9,4,23
	.byte	'RTE_DRA',0,0,23
	.byte	'RTE_WOWP',0,1,23
	.byte	'RTE_TASK',0,2,23
	.byte	'RTE_ARE',0,3,23
	.byte	'RTE_EV',0,4,23
	.byte	'RTE_MSI',0,5,0,14
	.byte	'Rte_NotificationType',0,16,182,1,3
	.word	7997
	.byte	6
	.word	7910
	.byte	26
	.byte	'Rte_QCmnType',0,16,184,1,16,24,12
	.byte	'dynamic',0
	.word	8095
	.byte	4,2,35,0,12
	.byte	'copy',0
	.word	143
	.byte	1,2,35,4,12
	.byte	'queue_size',0
	.word	160
	.byte	2,2,35,6,12
	.byte	'element_size',0
	.word	160
	.byte	2,2,35,8,12
	.byte	'buffer_start',0
	.word	983
	.byte	4,2,35,12,12
	.byte	'buffer_end',0
	.word	983
	.byte	4,2,35,16,12
	.byte	'notification_type',0
	.word	7997
	.byte	4,2,35,20,0,14
	.byte	'Rte_QCmnType',0,16,192,1,3
	.word	8100
	.byte	14
	.byte	'Rte_AlarmRefType',0,16,224,1,32
	.word	253
	.byte	14
	.byte	'Rte_AlarmIndexType',0,16,226,1,32
	.word	160
	.byte	24,128,8
	.word	143
	.byte	25,255,7,0,14
	.byte	'Impl_NVM_DstPtrType_1024',0,17,50,15
	.word	8338
	.byte	14
	.byte	'CanIf_u32_impl',0,17,69,16
	.word	253
	.byte	14
	.byte	'CanIf_u16_impl',0,17,71,16
	.word	160
	.byte	14
	.byte	'CanIf_u8_impl',0,17,73,15
	.word	143
	.byte	14
	.byte	'CanIf_ControllerModeType_Enum_impl',0,17,88,15
	.word	143
	.byte	14
	.byte	'CanIf_PduModeType_Enum_impl',0,17,90,15
	.word	143
	.byte	11,17,92,9,2,12
	.byte	'DeviceMode',0
	.word	143
	.byte	1,2,35,0,12
	.byte	'ChannelMode',0
	.word	143
	.byte	1,2,35,1,0,14
	.byte	'CanIf_ControllerStateType_struct_impl',0,17,95,3
	.word	8529
	.byte	14
	.byte	'CanIf_NotifStatusType_Enum_impl',0,17,100,15
	.word	143
	.byte	14
	.byte	'CanSM_boolean_Impl',0,17,120,15
	.word	143
	.byte	14
	.byte	'CanSM_u8_Impl',0,17,123,15
	.word	143
	.byte	14
	.byte	'CanSM_BusOffRecoveryStateType_Enum_impl',0,17,128,1,15
	.word	143
	.byte	14
	.byte	'CanSM_NetworkModeStateType_Enum_impl',0,17,132,1,15
	.word	143
	.byte	14
	.byte	'CanSM_u16_Impl',0,17,136,1,16
	.word	160
	.byte	14
	.byte	'CanSM_TimerStateType_Enum_impl',0,17,138,1,15
	.word	143
	.byte	11,17,140,1,9,4,12
	.byte	'cntTick_u16',0
	.word	160
	.byte	2,2,35,0,12
	.byte	'stTimer',0
	.word	143
	.byte	1,2,35,2,0,14
	.byte	'CanSM_TimerConfig_tst_struct_impl',0,17,143,1,3
	.word	8870
	.byte	14
	.byte	'Com_impl_u16',0,17,154,1,16
	.word	160
	.byte	14
	.byte	'Com_impl_u8',0,17,157,1,15
	.word	143
	.byte	14
	.byte	'ComM_uint32_Impl',0,17,173,1,16
	.word	253
	.byte	14
	.byte	'ComM_uint16_Impl',0,17,175,1,16
	.word	160
	.byte	14
	.byte	'ComM_uint8_Impl',0,17,177,1,15
	.word	143
	.byte	14
	.byte	'ComM_bool_Impl',0,17,179,1,15
	.word	143
	.byte	11,17,181,1,9,24,12
	.byte	'ChannelState_e',0
	.word	253
	.byte	4,2,35,0,12
	.byte	'LightTimeoutCtr_u32',0
	.word	253
	.byte	4,2,35,4,12
	.byte	'MinFullComTimeoutCtr_u16',0
	.word	160
	.byte	2,2,35,8,12
	.byte	'ChannelMode_u8',0
	.word	143
	.byte	1,2,35,10,12
	.byte	'BusSmMode_u8',0
	.word	143
	.byte	1,2,35,11,12
	.byte	'UserRequestCtr_u8',0
	.word	143
	.byte	1,2,35,12,12
	.byte	'PassiveRequestState_u8',0
	.word	143
	.byte	1,2,35,13,12
	.byte	'PncRequestCtr_u8',0
	.word	143
	.byte	1,2,35,14,12
	.byte	'InhibitionReqStatus_u8',0
	.word	143
	.byte	1,2,35,15,12
	.byte	'NmNetworkRequestStatus_b',0
	.word	143
	.byte	1,2,35,16,12
	.byte	'DiagnosticRequestState_b',0
	.word	143
	.byte	1,2,35,17,12
	.byte	'CommunicationAllowed_b',0
	.word	143
	.byte	1,2,35,18,12
	.byte	'NmBusSleepIndicationStatus_b',0
	.word	143
	.byte	1,2,35,19,12
	.byte	'NmPrepareBusSleepIndicationStatus_b',0
	.word	143
	.byte	1,2,35,20,12
	.byte	'NmNetworkModeStatus_b',0
	.word	143
	.byte	1,2,35,21,0,14
	.byte	'ComM_ChannelStruct_Impl',0,17,197,1,3
	.word	9102
	.byte	11,17,206,1,9,10,12
	.byte	'WakeUpInhibitionCtr_u16',0
	.word	160
	.byte	2,2,35,0,12
	.byte	'LimitToNoComCtr_u16',0
	.word	160
	.byte	2,2,35,2,12
	.byte	'RequestedUserMode_t',0
	.word	143
	.byte	1,2,35,4,12
	.byte	'IndicatedUserMode_t',0
	.word	143
	.byte	1,2,35,5,12
	.byte	'numChannelsInFullCom_u8',0
	.word	143
	.byte	1,2,35,6,12
	.byte	'numChannelsInSilentCom_u8',0
	.word	143
	.byte	1,2,35,7,12
	.byte	'numChannelsInNoCom_u8',0
	.word	143
	.byte	1,2,35,8,0,14
	.byte	'ComM_UserStruct_Impl',0,17,214,1,3
	.word	9606
	.byte	14
	.byte	'Dcm_IOOperationResponseType',0,17,252,1,15
	.word	143
	.byte	14
	.byte	'Dcm_RequestDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspRequestRoutineResultsOutSignal_0PrimitivType',0
	.byte	17,138,2,15
	.word	143
	.byte	14
	.byte	'Dcm_StartDataIn_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineInSignalPrimitivType',0,17,146,2,15
	.word	143
	.byte	14
	.byte	'Dcm_StartDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineOutSignalPrimitivType',0,17,150,2,15
	.word	143
	.byte	14
	.byte	'Dcm_StopDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStopRoutineOutSignalPrimitivType',0,17,154,2,15
	.word	143
	.byte	14
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockNative_1024_Type',0,17,243,3,34
	.word	8349
	.byte	24,128,8
	.word	143
	.byte	25,255,7,0,14
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockRedundant_1024_Type',0,17,246,3,34
	.word	8349
	.byte	14
	.byte	'Rte_TaskRefType',0,18,184,1,32
	.word	4836
	.byte	14
	.byte	'Rte_EventRefType',0,18,185,1,32
	.word	143
	.byte	14
	.byte	'Rte_EventType',0,18,186,1,32
	.word	253
	.byte	14
	.byte	'Rte_REActCounterType',0,18,252,1,15
	.word	143
	.byte	6
	.word	143
	.byte	14
	.byte	'Rte_REActCounterRefType',0,18,253,1,58
	.word	10528
	.byte	11,18,255,1,9,8,12
	.byte	'task',0
	.word	10424
	.byte	4,2,35,0,12
	.byte	'acnt',0
	.word	10533
	.byte	4,2,35,4,0,14
	.byte	'Rte_REContainerType',0,18,130,2,3
	.word	10566
	.byte	13
	.word	4576
	.byte	6
	.word	10630
	.byte	6
	.word	143
	.byte	13
	.word	10566
	.byte	6
	.word	10645
	.byte	14
	.byte	'Rte_REContainerRefType',0,18,132,2,60
	.word	10650
	.byte	14
	.byte	'Rte_MSICounterType',0,18,149,2,16
	.word	160
	.byte	6
	.word	160
	.byte	14
	.byte	'Rte_MSICounterRefType',0,18,150,2,56
	.word	10715
	.byte	14
	.byte	'Rte_MSIPendingFlagType',0,18,152,2,17
	.word	143
	.byte	6
	.word	143
	.byte	14
	.byte	'Rte_MSIPendingFlagRefType',0,18,153,2,60
	.word	10783
	.byte	11,18,163,2,9,24,12
	.byte	'counter',0
	.word	10720
	.byte	4,2,35,0,12
	.byte	'incCounter',0
	.word	143
	.byte	1,2,35,4,12
	.byte	'pending',0
	.word	10788
	.byte	4,2,35,8,12
	.byte	'osTask',0
	.word	10424
	.byte	4,2,35,12,12
	.byte	'acnt',0
	.word	10533
	.byte	4,2,35,16,12
	.byte	'osEvent',0
	.word	143
	.byte	1,2,35,20,12
	.byte	'MSIInit',0
	.word	160
	.byte	2,2,35,22,0,14
	.byte	'Rte_MSITableEntry',0,18,172,2,3
	.word	10823
	.byte	6
	.word	160
	.byte	6
	.word	143
	.byte	14
	.byte	'Rte_TaskArrayIndex',0,18,179,2,16
	.word	143
	.byte	14
	.byte	'Rte_NrWaitingTasks',0,18,180,2,16
	.word	143
	.byte	11,18,182,2,9,4,12
	.byte	'pending',0
	.word	143
	.byte	1,2,35,0,12
	.byte	'count',0
	.word	143
	.byte	1,2,35,1,12
	.byte	'firstWaitingTask',0
	.word	143
	.byte	1,2,35,2,0,14
	.byte	'Rte_WaitableDatum',0,18,186,2,3
	.word	11041
	.byte	6
	.word	11041
	.byte	11,18,226,2,9,12,12
	.byte	'event_id',0
	.word	253
	.byte	4,2,35,0,12
	.byte	'wd',0
	.word	11133
	.byte	4,2,35,4,12
	.byte	'timeout',0
	.word	253
	.byte	4,2,35,8,0,14
	.byte	'Rte_WOWP_NotificationType',0,18,230,2,3
	.word	11138
	.byte	13
	.word	11138
	.byte	6
	.word	11227
	.byte	14
	.byte	'Rte_WOWP_NotificationRefType',0,18,232,2,66
	.word	11232
	.byte	14
	.byte	'Rte_ARE_NotificationType',0,18,234,2,29
	.word	10566
	.byte	26
	.byte	'Rte_QTaskType',0,18,243,2,16,28,12
	.byte	'cmn',0
	.word	8100
	.byte	24,2,35,0,12
	.byte	'task',0
	.word	10424
	.byte	4,2,35,24,0,14
	.byte	'Rte_QTaskType',0,18,246,2,3
	.word	11309
	.byte	26
	.byte	'Rte_QREType',0,18,250,2,16,28,12
	.byte	'cmn',0
	.word	8100
	.byte	24,2,35,0,12
	.byte	're',0
	.word	10655
	.byte	4,2,35,24,0,14
	.byte	'Rte_QREType',0,18,253,2,3
	.word	11380
	.byte	13
	.word	10566
	.byte	6
	.word	11445
	.byte	26
	.byte	'Rte_QWWPType',0,18,129,3,16,28,12
	.byte	'cmn',0
	.word	8100
	.byte	24,2,35,0,12
	.byte	'wwp',0
	.word	11237
	.byte	4,2,35,24,0,14
	.byte	'Rte_QWWPType',0,18,132,3,3
	.word	11455
	.byte	13
	.word	11138
	.byte	6
	.word	11523
	.byte	26
	.byte	'Rte_QEvType',0,18,136,3,16,36,12
	.byte	'cmn',0
	.word	8100
	.byte	24,2,35,0,12
	.byte	'task',0
	.word	10424
	.byte	4,2,35,24,12
	.byte	'mask',0
	.word	143
	.byte	1,2,35,28,12
	.byte	'acnt',0
	.word	10533
	.byte	4,2,35,32,0,14
	.byte	'Rte_QEvType',0,18,141,3,3
	.word	11533
	.byte	26
	.byte	'Rte_QMSIType',0,18,145,3,16,48,12
	.byte	'cmn',0
	.word	8100
	.byte	24,2,35,0,12
	.byte	'task',0
	.word	10424
	.byte	4,2,35,24,12
	.byte	'mask',0
	.word	143
	.byte	1,2,35,28,12
	.byte	'acnt',0
	.word	10533
	.byte	4,2,35,32,12
	.byte	'msiCounter',0
	.word	10720
	.byte	4,2,35,36,12
	.byte	'msiPending',0
	.word	10788
	.byte	4,2,35,40,12
	.byte	'msiLimit',0
	.word	160
	.byte	2,2,35,44,0,14
	.byte	'Rte_QMSIType',0,18,153,3,3
	.word	11628
	.byte	11,4,52,9,1,33
	.byte	'isEventTrig',0,1
	.word	143
	.byte	1,7,2,35,0,33
	.byte	'isTriggerIpduSendWithMetadata',0,1
	.word	143
	.byte	1,6,2,35,0,33
	.byte	'isGwIpduSend',0,1
	.word	143
	.byte	1,5,2,35,0,33
	.byte	'isModeChangd',0,1
	.word	143
	.byte	1,4,2,35,0,33
	.byte	'sigTransProp',0,1
	.word	143
	.byte	1,3,2,35,0,33
	.byte	'isTimeoutReq',0,1
	.word	143
	.byte	1,2,2,35,0,33
	.byte	'ignoreRepetitions',0,1
	.word	143
	.byte	1,1,2,35,0,0,14
	.byte	'Com_SendIpduInfo',0,4,61,3
	.word	11783
	.byte	11,4,76,9,8,12
	.byte	'TimePeriodFact',0
	.word	160
	.byte	2,2,35,0,12
	.byte	'TimeOffsetFact',0
	.word	160
	.byte	2,2,35,2,12
	.byte	'RepetitionPeriodFact',0
	.word	160
	.byte	2,2,35,4,12
	.byte	'NumOfRepetitions',0
	.word	143
	.byte	1,2,35,6,12
	.byte	'Mode',0
	.word	143
	.byte	1,2,35,7,0,14
	.byte	'Com_TransModeInfo',0,4,93,2
	.word	12003
	.byte	13
	.word	12003
	.byte	6
	.word	12153
	.byte	14
	.byte	'Com_TMConstPtrType',0,4,103,65
	.word	12158
	.byte	11,4,136,1,9,12,12
	.byte	'Init_Val',0
	.word	253
	.byte	4,2,35,0,12
	.byte	'txSignalFields',0
	.word	160
	.byte	2,2,35,4,12
	.byte	'Bit_Pos',0
	.word	143
	.byte	1,2,35,6,12
	.byte	'BitSize',0
	.word	143
	.byte	1,2,35,7,12
	.byte	'IpduRef',0
	.word	143
	.byte	1,2,35,8,12
	.byte	'General',0
	.word	143
	.byte	1,2,35,9,0,14
	.byte	'Com_Prv_xTxSigCfg_tst',0,4,201,1,2
	.word	12190
	.byte	14
	.byte	'Com_Prv_xRxSigCfg_tst',0,4,171,2,2
	.word	1157
	.byte	11,4,211,5,9,24,12
	.byte	'BuffPtr',0
	.word	675
	.byte	4,2,35,0,12
	.byte	'Com_TMConstPtr',0
	.word	12158
	.byte	4,2,35,4,12
	.byte	'Size',0
	.word	160
	.byte	2,2,35,8,12
	.byte	'Timeout_Fact',0
	.word	160
	.byte	2,2,35,10,12
	.byte	'Min_Delay_Time_Fact',0
	.word	160
	.byte	2,2,35,12,12
	.byte	'No_Of_Sig_Ref',0
	.word	160
	.byte	2,2,35,14,12
	.byte	'PdurId',0
	.word	160
	.byte	2,2,35,16,12
	.byte	'TxSigId_Index',0
	.word	143
	.byte	1,2,35,18,12
	.byte	'txIPduFields',0
	.word	160
	.byte	2,2,35,20,12
	.byte	'MainFunctionRef',0
	.word	143
	.byte	1,2,35,22,12
	.byte	'PaddingByte',0
	.word	143
	.byte	1,2,35,23,0,14
	.byte	'Com_Prv_xTxIpduInfoCfg_tst',0,4,162,6,3
	.word	12369
	.byte	13
	.word	12369
	.byte	6
	.word	12648
	.byte	14
	.byte	'Com_TxIpduConstPtrType',0,4,171,6,72
	.word	12653
	.byte	11,4,137,7,9,20,12
	.byte	'BuffPtr',0
	.word	675
	.byte	4,2,35,0,12
	.byte	'TimeOutNotification_Cbk',0
	.word	1152
	.byte	4,2,35,4,12
	.byte	'Size',0
	.word	160
	.byte	2,2,35,8,12
	.byte	'FirstTimeout_Factor',0
	.word	160
	.byte	2,2,35,10,12
	.byte	'Timeout_Fact',0
	.word	160
	.byte	2,2,35,12,12
	.byte	'No_Of_Sig_Ref',0
	.word	160
	.byte	2,2,35,14,12
	.byte	'RxSigId_Index',0
	.word	143
	.byte	1,2,35,16,12
	.byte	'MainFunctionRef',0
	.word	143
	.byte	1,2,35,17,12
	.byte	'rxIPduFields',0
	.word	143
	.byte	1,2,35,18,0,14
	.byte	'Com_Prv_xRxIpduInfoCfg_tst',0,4,197,7,3
	.word	12690
	.byte	11,4,219,7,9,4,12
	.byte	'FirstIpdu_Index',0
	.word	160
	.byte	2,2,35,0,12
	.byte	'NoOfRxPdus',0
	.word	160
	.byte	2,2,35,2,0,14
	.byte	'Com_Prv_xIpduGrpInfoCfg_tst',0,4,224,7,3
	.word	12941
	.byte	11,4,244,7,9,1,12
	.byte	'txSigRAMFields',0
	.word	143
	.byte	1,2,35,0,0,14
	.byte	'Com_TxSignalFlagType',0,4,248,7,2
	.word	13030
	.byte	11,4,167,8,9,1,12
	.byte	'rxSigRAMFields',0
	.word	143
	.byte	1,2,35,0,0,14
	.byte	'Com_RxSignalFlagType',0,4,171,8,2
	.word	13091
	.byte	11,4,135,9,9,16,12
	.byte	'CurrentTxModePtr',0
	.word	12163
	.byte	4,2,35,0,12
	.byte	'Com_MinDelayTick',0
	.word	160
	.byte	2,2,35,4,12
	.byte	'Com_Tick_Tx',0
	.word	160
	.byte	2,2,35,6,12
	.byte	'Com_n_Tick_Tx',0
	.word	160
	.byte	2,2,35,8,12
	.byte	'Com_TickTxTimeout',0
	.word	160
	.byte	2,2,35,10,12
	.byte	'Com_TxFlags',0
	.word	160
	.byte	2,2,35,12,12
	.byte	'Com_n',0
	.word	143
	.byte	1,2,35,14,12
	.byte	'Com_TransMode',0
	.word	143
	.byte	1,2,35,15,0,14
	.byte	'Com_TxIpduRamData',0,4,189,9,3
	.word	13152
	.byte	13
	.word	12003
	.byte	6
	.word	13368
	.byte	6
	.word	13152
	.byte	14
	.byte	'Com_TxIpduRamPtrType',0,4,198,9,62
	.word	13378
	.byte	11,4,218,9,9,6,12
	.byte	'RxIPduLength',0
	.word	160
	.byte	2,2,35,0,12
	.byte	'RxTicks_u16',0
	.word	160
	.byte	2,2,35,2,12
	.byte	'RxFlags',0
	.word	143
	.byte	1,2,35,4,0,14
	.byte	'Com_RxIpduRamData',0,4,245,9,2
	.word	13413
	.byte	6
	.word	160
	.byte	11,4,128,10,9,8,12
	.byte	'RxGwQueuePtr',0
	.word	13507
	.byte	4,2,35,0,12
	.byte	'Com_RxGwQueueWrite_ux',0
	.word	143
	.byte	1,2,35,4,12
	.byte	'Com_RxGwQueueRead_ux',0
	.word	143
	.byte	1,2,35,5,0,14
	.byte	'Com_RxGwQueueRAMType',0,4,133,10,2
	.word	13512
	.byte	11,4,138,10,9,4,12
	.byte	'indexGwMapSigDestIdArray',0
	.word	160
	.byte	2,2,35,0,12
	.byte	'destCount',0
	.word	143
	.byte	1,2,35,2,0,14
	.byte	'Com_Prv_xGwMapSigCfg_tst',0,4,142,10,2
	.word	13632
	.byte	11,4,147,10,9,2,12
	.byte	'GwMap_DestId',0
	.word	160
	.byte	2,2,35,0,0,14
	.byte	'Com_Prv_xGwMapSigIdCfg_tst',0,4,150,10,2
	.word	13726
	.byte	11,4,183,10,9,4,12
	.byte	'StartIPduId',0
	.word	143
	.byte	1,2,35,0,12
	.byte	'NumOfIpdus',0
	.word	143
	.byte	1,2,35,1,12
	.byte	'TimeBaseInMs',0
	.word	143
	.byte	1,2,35,2,0,14
	.byte	'Com_MainFunctionCfgType',0,4,188,10,3
	.word	13791
	.byte	11,4,194,10,9,12,12
	.byte	'Com_SigType_pu8',0
	.word	675
	.byte	4,2,35,0,12
	.byte	'Com_SigType_pu16',0
	.word	503
	.byte	4,2,35,4,12
	.byte	'Com_SigType_pu32',0
	.word	589
	.byte	4,2,35,8,0,14
	.byte	'Com_Prv_xRxRamBuf_tst',0,4,253,10,3
	.word	13894
	.byte	14
	.byte	'rba_BswSrv_uint64',0,19,66,28
	.word	1931
	.byte	34
	.byte	'Com_Uninit_Flag',0,6,139,24,45
	.word	2404
	.byte	1,1,35
	.word	13413
	.byte	36,0,34
	.byte	'Com_RxIpduRam_s',0,6,201,24,42
	.word	14062
	.byte	1,1,35
	.word	1157
	.byte	36,0,13
	.word	14096
	.byte	34
	.byte	'Com_Prv_xRxSigCfg_acst',0,6,131,26,55
	.word	14103
	.byte	1,1,35
	.word	12690
	.byte	36,0,13
	.word	14142
	.byte	34
	.byte	'Com_Prv_xRxIpduCfg_acst',0,6,143,26,57
	.word	14149
	.byte	1,1,35
	.word	13894
	.byte	36,0,13
	.word	14189
	.byte	34
	.byte	'Com_Prv_xRxRamBuf_acst',0,6,235,26,48
	.word	14196
	.byte	1,1,0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L44:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,36,0,3,8,11,15,62,15,0,0,3,46,1,3,8,32,13,58,15,59,15
	.byte	57,15,73,19,54,15,39,12,0,0,4,5,0,3,8,58,15,59,15,57,15,73,19,0,0,5,11,0,0,0,6,15,0,73,19,0,0,7,46,1,3
	.byte	8,32,13,58,15,59,15,57,15,54,15,39,12,0,0,8,11,1,0,0,9,59,0,3,8,0,0,10,21,0,54,15,39,12,0,0,11,19,1,58
	.byte	15,59,15,57,15,11,15,0,0,12,13,0,3,8,73,19,11,15,56,9,0,0,13,38,0,73,19,0,0,14,22,0,3,8,58,15,59,15,57
	.byte	15,73,19,0,0,15,46,1,3,8,58,15,59,15,57,15,73,19,54,15,39,12,63,12,60,12,0,0,16,46,1,49,19,0,0,17,5,0
	.byte	49,19,0,0,18,46,1,3,8,58,15,59,15,57,15,54,15,39,12,63,12,60,12,0,0,19,29,1,49,19,0,0,20,11,0,49,19,0
	.byte	0,21,21,0,54,15,0,0,22,4,1,58,15,59,15,57,15,11,15,0,0,23,40,0,3,8,28,13,0,0,24,1,1,11,15,73,19,0,0,25
	.byte	33,0,47,15,0,0,26,19,1,3,8,58,15,59,15,57,15,11,15,0,0,27,21,1,54,15,39,12,0,0,28,5,0,73,19,0,0,29,23
	.byte	1,58,15,59,15,57,15,11,15,0,0,30,4,1,3,8,58,15,59,15,57,15,11,15,0,0,31,21,0,73,19,54,15,39,12,0,0,32
	.byte	53,0,73,19,0,0,33,13,0,3,8,11,15,73,19,13,15,12,15,56,9,0,0,34,52,0,3,8,58,15,59,15,57,15,73,19,63,12
	.byte	60,12,0,0,35,1,1,73,19,0,0,36,33,0,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L45:
	.word	.L158-.L157
.L157:
	.half	3
	.word	.L160-.L159
.L159:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Bfx\\api\\Bfx_Bit_Inl.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv_Inl.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_ReceiveSignal.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Det\\api\\Det.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Platform\\Platform_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Std_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Com\\Com_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Com\\Com_Cfg_Internal.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Can_GeneralTypes.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\RTOS_T\\Gen\\inc\\Os.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Can_17_MCanP\\inc\\Can_17_MCanP.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Type.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Intl.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\rba_BswSrv.h',0,0,0,0,0
.L160:
.L158:
	.sdecl	'.debug_info',debug,cluster('Com_ReceiveSignal')
	.sect	'.debug_info'
.L46:
	.word	1006
	.half	3
	.word	.L47
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_ReceiveSignal.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L49,.L48
	.byte	2
	.word	.L42
	.byte	3
	.byte	'Com_ReceiveSignal',0,1,26,23
	.word	.L51
	.byte	1,1,1
	.word	.L41,.L52,.L40
	.byte	4
	.byte	'SignalId',0,1,26,74
	.word	.L53,.L54
	.byte	4
	.byte	'SignalDataPtr',0,1,27,79
	.word	.L55,.L56
	.byte	5
	.word	.L41,.L52
	.byte	6
	.byte	'RxSigConstPtr',0,1,30,49
	.word	.L57,.L58
	.byte	6
	.byte	'Status',0,1,31,49
	.word	.L51,.L59
	.byte	6
	.byte	'SigType',0,1,33,49
	.word	.L51,.L60
	.byte	7
	.word	.L61,.L62,.L63
	.byte	8
	.word	.L64,.L65
	.byte	8
	.word	.L66,.L67
	.byte	8
	.word	.L68,.L69
	.byte	9
	.word	.L70,.L62,.L63
	.byte	6
	.byte	'ErrorId',0,2,171,7,13
	.word	.L51,.L71
	.byte	6
	.byte	'Status',0,2,172,7,13
	.word	.L51,.L72
	.byte	0,0,7
	.word	.L73,.L74,.L11
	.byte	8
	.word	.L75,.L76
	.byte	8
	.word	.L77,.L78
	.byte	8
	.word	.L79,.L80
	.byte	10
	.word	.L81,.L74,.L11
	.byte	0,7
	.word	.L82,.L83,.L14
	.byte	8
	.word	.L84,.L85
	.byte	9
	.word	.L86,.L83,.L14
	.byte	6
	.byte	'RxIPduStatus',0,2,187,8,29
	.word	.L51,.L87
	.byte	7
	.word	.L88,.L89,.L12
	.byte	8
	.word	.L90,.L91
	.byte	8
	.word	.L92,.L93
	.byte	10
	.word	.L94,.L89,.L12
	.byte	0,0,0,7
	.word	.L95,.L96,.L23
	.byte	8
	.word	.L97,.L98
	.byte	8
	.word	.L99,.L100
	.byte	9
	.word	.L101,.L96,.L23
	.byte	6
	.byte	'RxSigConstPtr',0,1,91,49
	.word	.L57,.L102
	.byte	6
	.byte	'RxNewVal',0,1,92,49
	.word	.L103,.L104
	.byte	6
	.byte	'SigBuff_Index',0,1,93,49
	.word	.L51,.L105
	.byte	6
	.byte	'rxMainFuncId',0,1,95,49
	.word	.L51,.L106
	.byte	6
	.byte	'Type',0,1,97,49
	.word	.L51,.L107
	.byte	7
	.word	.L73,.L108,.L16
	.byte	8
	.word	.L75,.L76
	.byte	8
	.word	.L77,.L78
	.byte	8
	.word	.L79,.L80
	.byte	10
	.word	.L81,.L108,.L16
	.byte	0,0,0,7
	.word	.L109,.L15,.L10
	.byte	8
	.word	.L110,.L111
	.byte	8
	.word	.L112,.L113
	.byte	9
	.word	.L114,.L15,.L10
	.byte	6
	.byte	'RxSigConstPtr',0,1,232,1,49
	.word	.L57,.L115
	.byte	6
	.byte	'RxNewVal',0,1,233,1,49
	.word	.L103,.L116
	.byte	6
	.byte	'SigBuff_Index',0,1,234,1,49
	.word	.L51,.L117
	.byte	6
	.byte	'rxMainFuncId',0,1,236,1,49
	.word	.L51,.L118
	.byte	6
	.byte	'Type',0,1,238,1,49
	.word	.L51,.L119
	.byte	7
	.word	.L73,.L120,.L30
	.byte	8
	.word	.L75,.L76
	.byte	8
	.word	.L77,.L78
	.byte	8
	.word	.L79,.L80
	.byte	10
	.word	.L81,.L120,.L30
	.byte	0,0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('Com_ReceiveSignal')
	.sect	'.debug_abbrev'
.L47:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,7,29,1,49,16,17,1,18,1,0,0,8,5,0,49,16,2,6,0,0,9,11,1,49,16,17
	.byte	1,18,1,0,0,10,11,0,49,16,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('Com_ReceiveSignal')
	.sect	'.debug_line'
.L48:
	.word	.L162-.L161
.L161:
	.half	3
	.word	.L164-.L163
.L163:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_ReceiveSignal.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Com\\src\\Com_Prv_Inl.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Bfx\\api\\Bfx_Bit_Inl.h',0,0,0,0,0
.L164:
	.byte	5,23,7,0,5,2
	.word	.L41
	.byte	3,25,1,5,12,9
	.half	.L125-.L41
	.byte	3,9,1,5,46,9
	.half	.L126-.L125
	.byte	3,3,1,5,92,9
	.half	.L165-.L126
	.byte	1,5,89,9
	.half	.L166-.L165
	.byte	1,5,93,9
	.half	.L167-.L166
	.byte	3,1,1,4,2,5,13,9
	.half	.L62-.L167
	.byte	3,136,7,1,9
	.half	.L127-.L62
	.byte	3,1,1,5,9,9
	.half	.L128-.L127
	.byte	3,3,1,5,5,9
	.half	.L168-.L128
	.byte	1,5,17,7,9
	.half	.L169-.L168
	.byte	3,2,1,5,31,9
	.half	.L170-.L169
	.byte	1,5,10,9
	.half	.L2-.L170
	.byte	3,2,1,5,17,7,9
	.half	.L171-.L2
	.byte	3,2,1,5,30,9
	.half	.L172-.L171
	.byte	1,5,10,9
	.half	.L4-.L172
	.byte	3,2,1,5,17,7,9
	.half	.L173-.L4
	.byte	3,2,1,5,38,9
	.half	.L174-.L173
	.byte	1,5,20,9
	.half	.L3-.L174
	.byte	3,8,1,5,5,9
	.half	.L175-.L3
	.byte	1,5,9,7,9
	.half	.L176-.L175
	.byte	3,3,1,5,16,9
	.half	.L121-.L176
	.byte	3,2,1,5,5,9
	.half	.L8-.L121
	.byte	3,2,1,4,1,9
	.half	.L9-.L8
	.byte	3,218,120,1,5,25,7,9
	.half	.L63-.L9
	.byte	3,10,1,5,19,9
	.half	.L130-.L63
	.byte	3,2,1,4,3,5,27,9
	.half	.L74-.L130
	.byte	3,131,3,1,5,45,9
	.half	.L177-.L74
	.byte	1,5,68,9
	.half	.L178-.L177
	.byte	1,5,60,9
	.half	.L179-.L178
	.byte	1,5,42,9
	.half	.L180-.L179
	.byte	1,5,5,9
	.half	.L181-.L180
	.byte	1,4,1,5,58,9
	.half	.L11-.L181
	.byte	3,131,125,1,4,2,5,20,9
	.half	.L83-.L11
	.byte	3,133,8,1,4,3,5,32,9
	.half	.L89-.L83
	.byte	3,188,122,1,5,36,9
	.half	.L182-.L89
	.byte	1,5,21,9
	.half	.L183-.L182
	.byte	1,5,48,9
	.half	.L184-.L183
	.byte	1,5,5,9
	.half	.L185-.L184
	.byte	1,4,2,9
	.half	.L12-.L185
	.byte	3,210,5,1,4,1,5,20,9
	.half	.L13-.L12
	.byte	3,239,119,1,5,9,9
	.half	.L14-.L13
	.byte	3,3,1,5,27,7,9
	.half	.L96-.L14
	.byte	3,38,1,5,40,9
	.half	.L132-.L96
	.byte	3,1,1,5,27,9
	.half	.L134-.L132
	.byte	3,2,1,4,3,9
	.half	.L108-.L134
	.byte	3,207,2,1,5,45,9
	.half	.L186-.L108
	.byte	1,5,68,9
	.half	.L187-.L186
	.byte	1,5,60,9
	.half	.L188-.L187
	.byte	1,5,42,9
	.half	.L189-.L188
	.byte	1,5,5,9
	.half	.L190-.L189
	.byte	1,4,1,5,28,9
	.half	.L16-.L190
	.byte	3,178,125,1,5,78,9
	.half	.L191-.L16
	.byte	1,5,14,9
	.half	.L136-.L191
	.byte	3,9,1,9
	.half	.L192-.L136
	.byte	3,6,1,9
	.half	.L193-.L192
	.byte	3,12,1,9
	.half	.L194-.L193
	.byte	3,22,1,9
	.half	.L195-.L194
	.byte	3,6,1,5,40,9
	.half	.L17-.L195
	.byte	3,84,1,5,37,9
	.half	.L137-.L17
	.byte	3,1,1,5,13,9
	.half	.L196-.L137
	.byte	3,2,1,5,44,9
	.half	.L18-.L196
	.byte	3,6,1,5,41,9
	.half	.L139-.L18
	.byte	3,4,1,5,13,9
	.half	.L197-.L139
	.byte	3,2,1,5,44,9
	.half	.L19-.L197
	.byte	3,6,1,5,41,9
	.half	.L141-.L19
	.byte	3,4,1,5,13,9
	.half	.L198-.L141
	.byte	3,2,1,5,36,9
	.half	.L20-.L198
	.byte	3,13,1,5,64,9
	.half	.L143-.L20
	.byte	3,1,1,5,42,9
	.half	.L144-.L143
	.byte	1,5,13,9
	.half	.L199-.L144
	.byte	3,2,1,5,53,9
	.half	.L21-.L199
	.byte	3,8,1,5,51,9
	.half	.L200-.L21
	.byte	3,1,1,5,30,9
	.half	.L201-.L200
	.byte	1,5,13,9
	.half	.L135-.L201
	.byte	3,3,1,9
	.half	.L22-.L135
	.byte	3,46,1,5,67,9
	.half	.L23-.L22
	.byte	3,233,126,1,5,27,9
	.half	.L15-.L23
	.byte	3,176,1,1,5,40,9
	.half	.L148-.L15
	.byte	3,1,1,5,27,9
	.half	.L150-.L148
	.byte	3,2,1,4,3,9
	.half	.L120-.L150
	.byte	3,194,1,1,5,45,9
	.half	.L202-.L120
	.byte	1,5,68,9
	.half	.L203-.L202
	.byte	1,5,60,9
	.half	.L204-.L203
	.byte	1,5,42,9
	.half	.L205-.L204
	.byte	1,5,5,9
	.half	.L206-.L205
	.byte	1,4,1,5,28,9
	.half	.L30-.L206
	.byte	3,191,126,1,5,78,9
	.half	.L207-.L30
	.byte	1,5,14,9
	.half	.L151-.L207
	.byte	3,9,1,9
	.half	.L208-.L151
	.byte	3,6,1,9
	.half	.L209-.L208
	.byte	3,12,1,5,44,9
	.half	.L31-.L209
	.byte	3,112,1,5,40,9
	.half	.L152-.L31
	.byte	3,1,1,5,13,9
	.half	.L210-.L152
	.byte	3,2,1,5,44,9
	.half	.L32-.L210
	.byte	3,6,1,5,41,9
	.half	.L153-.L32
	.byte	3,4,1,5,13,9
	.half	.L211-.L153
	.byte	3,2,1,5,44,9
	.half	.L33-.L211
	.byte	3,6,1,5,41,9
	.half	.L154-.L33
	.byte	3,4,1,5,13,9
	.half	.L212-.L154
	.byte	3,2,1,9
	.half	.L34-.L212
	.byte	3,17,1,5,5,9
	.half	.L10-.L34
	.byte	3,157,126,1,5,1,9
	.half	.L39-.L10
	.byte	3,1,1,7,9
	.half	.L50-.L39
	.byte	0,1,1
.L162:
	.sdecl	'.debug_ranges',debug,cluster('Com_ReceiveSignal')
	.sect	'.debug_ranges'
.L49:
	.word	-1,.L41,0,.L50-.L41,0,0
	.sdecl	'.debug_loc',debug,cluster('Com_ReceiveSignal')
	.sect	'.debug_loc'
.L69:
	.word	0,0
.L80:
	.word	0,0
.L93:
	.word	0,0
.L78:
	.word	0,0
.L40:
	.word	-1,.L41,0,.L52-.L41
	.half	2
	.byte	138,0
	.word	0,0
.L91:
	.word	0,0
.L76:
	.word	0,0
.L71:
	.word	-1,.L41,.L127-.L41,.L121-.L41
	.half	1
	.byte	87
	.word	0,0
.L85:
	.word	0,0
.L87:
	.word	0,0
.L104:
	.word	-1,.L41,.L137-.L41,.L18-.L41
	.half	1
	.byte	95
	.word	.L139-.L41,.L19-.L41
	.half	1
	.byte	95
	.word	.L141-.L41,.L20-.L41
	.half	1
	.byte	95
	.word	.L143-.L41,.L144-.L41
	.half	1
	.byte	95
	.word	0,0
.L116:
	.word	-1,.L41,.L152-.L41,.L32-.L41
	.half	1
	.byte	95
	.word	.L153-.L41,.L33-.L41
	.half	1
	.byte	95
	.word	.L154-.L41,.L34-.L41
	.half	1
	.byte	95
	.word	0,0
.L58:
	.word	-1,.L41,.L130-.L41,.L131-.L41
	.half	1
	.byte	111
	.word	0,0
.L102:
	.word	-1,.L41,.L132-.L41,.L133-.L41
	.half	1
	.byte	111
	.word	.L18-.L41,.L138-.L41
	.half	1
	.byte	111
	.word	.L19-.L41,.L140-.L41
	.half	1
	.byte	111
	.word	.L20-.L41,.L142-.L41
	.half	1
	.byte	111
	.word	.L21-.L41,.L23-.L41
	.half	1
	.byte	111
	.word	0,0
.L115:
	.word	-1,.L41,.L148-.L41,.L149-.L41
	.half	1
	.byte	111
	.word	0,0
.L105:
	.word	-1,.L41,.L134-.L41,.L135-.L41
	.half	1
	.byte	83
	.word	.L22-.L41,.L23-.L41
	.half	1
	.byte	83
	.word	0,0
.L117:
	.word	-1,.L41,.L150-.L41,.L10-.L41
	.half	1
	.byte	83
	.word	0,0
.L60:
	.word	0,0
.L56:
	.word	-1,.L41,0,.L121-.L41
	.half	1
	.byte	100
	.word	.L125-.L41,.L52-.L41
	.half	1
	.byte	108
	.word	.L145-.L41,.L135-.L41
	.half	1
	.byte	100
	.word	0,0
.L100:
	.word	0,0
.L113:
	.word	0,0
.L54:
	.word	-1,.L41,0,.L122-.L41
	.half	1
	.byte	84
	.word	.L123-.L41,.L124-.L41
	.half	1
	.byte	88
	.word	.L15-.L41,.L146-.L41
	.half	1
	.byte	88
	.word	0,0
.L98:
	.word	0,0
.L111:
	.word	0,0
.L59:
	.word	-1,.L41,.L126-.L41,.L52-.L41
	.half	1
	.byte	89
	.word	.L155-.L41,.L52-.L41
	.half	1
	.byte	82
	.word	0,0
.L72:
	.word	-1,.L41,.L128-.L41,.L121-.L41
	.half	1
	.byte	82
	.word	.L8-.L41,.L129-.L41
	.half	1
	.byte	82
	.word	.L17-.L41,.L19-.L41
	.half	1
	.byte	82
	.word	.L15-.L41,.L147-.L41
	.half	1
	.byte	82
	.word	.L31-.L41,.L33-.L41
	.half	1
	.byte	82
	.word	0,0
.L107:
	.word	0,0
.L119:
	.word	0,0
.L65:
	.word	0,0
.L67:
	.word	0,0
.L106:
	.word	-1,.L41,.L136-.L41,.L135-.L41
	.half	1
	.byte	81
	.word	.L22-.L41,.L23-.L41
	.half	1
	.byte	81
	.word	0,0
.L118:
	.word	-1,.L41,.L151-.L41,.L10-.L41
	.half	1
	.byte	81
	.word	0,0
	.sdecl	'.debug_frame',debug
	.sect	'.debug_frame'
.L213:
	.word	48
	.word	-1
	.byte	3,0,2,1,27,12,26,0,8,27,8,26,8,28,8,29,8,30,8,31,8,34,8,35,8,32,8,33,8,16,8,17,8,24,8,25,8,36,8,37,8,38
	.byte	8,39
	.sdecl	'.debug_frame',debug,cluster('Com_ReceiveSignal')
	.sect	'.debug_frame'
	.word	12
	.word	.L213,.L41,.L52-.L41

; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   281              }
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   282              break;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   283  #ifdef COM_RXSIG_INT64
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   284          case COM_SINT64:
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   285              {
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   286                  SchM_Enter_Com_RxSigBuff(RECEIVESIGNAL);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   287                  RxNewVal = COM_GET_SIGTYPEUINT64_BUFF(rxMainFuncId, SigBuff_Index);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   288                  SchM_Exit_Com_RxSigBuff(RECEIVESIGNAL);
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   289                  *(sint64*)SignalDataPtr =  (sint64)RxNewVal;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   290              }
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   291              break;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   292  #endif /* #ifdef COM_RXSIG_INT64 */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   293  
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   294          default:
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   295              /**
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   296               * Default case is mandatory in switch syntax. Moreover only AUTOSAR Com defined signal types are allowed
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   297               * to be configured, hence default case is intentionally left empty.
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   298               */
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   299              break;
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   300      }
; BSW\src\BSW\Gen\Com\src\Com_ReceiveSignal.c	   301  }

	; Module end
