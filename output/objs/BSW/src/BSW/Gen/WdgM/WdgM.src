	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 19053136 SN 09001910"
	.compiler_invocation	"ctc -f cc17064a -c99 --integer-enumeration -D__CPU__=tc27x -D__CPU_TC27X__ --core=tc1.6.x --eabi-compliant --fp-model=-float -D_TASKING_C_TRICORE_=1 -I.\\output\\inc -g2 -t4 --language=-comments,-gcc,+volatile,-strings --default-near-size=0 -O2ROPYGKLF-predict --default-a1-size=0 --default-a0-size=0 --source --switch=auto -o output\\objs\\BSW\\src\\BSW\\Gen\\WdgM\\WdgM.src BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM.c"
	.compiler_name		"ctc"
	;source	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM.c'

	
$TC16X
	
	.sdecl	'.text.WdgM.WdgM_Init',code,cluster('WdgM_Init')
	.sect	'.text.WdgM.WdgM_Init'
	.align	2
	
	.global	WdgM_Init

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	     1  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	     2  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	     3  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	     4   **********************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	     5   * Includes
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	     6   **********************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	     7  */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	     8  #include "WdgM_Prv.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	     9  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    10  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    11   ***************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    12   * Variables
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    13   ***************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    14   */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    15  #define WDGM_START_SEC_VAR_FAST_INIT_8
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    16  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    17  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    18  /* TRACE[WDGM213] Only one global supervision Status for the whole WdgM */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    19  /*WDGM_DBG_TST_ENA macro can be defined only for testing purpose.
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    20   *It is used to change the scope of the variable from static to extern.
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    21   *If we define it as global(extern) variable then, there is a chance that it is written outside WdgM module,
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    22   *which can lead to unexpected behavior.
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    23   *Hence, caution: WDGM_DBG_TST_ENA macro should not be defined for Production software.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    24  #ifdef WDGM_DBG_TST_ENA
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    25  VAR(WdgM_GlobalStatusType, WDGM_VAR_FAST_INIT_8)  WdgM_GlobalStatus = WDGM_GLOBAL_STATUS_DEACTIVATED;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    26  #else
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    27      static VAR(WdgM_GlobalStatusType, WDGM_VAR_FAST_INIT_8)  WdgM_GlobalStatus = WDGM_GLOBAL_STATUS_DEACTIVATED;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    28  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    29  static VAR(WdgM_GlobalStatusType, WDGM_VAR_FAST_INIT_8)  WdgM_Prv_SetMode_GlobalStatus = WDGM_GLOBAL_STATUS_DEACTIVATED;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    30  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    31  #define WDGM_STOP_SEC_VAR_FAST_INIT_8
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    32  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    33  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    34  #define WDGM_START_SEC_CODE_SLOW
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    35  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    36  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    37   ***************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    38   * Public Function Definations
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    39   ***************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    40   */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    41  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    42  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    43  /****************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    44  * Name                :    WdgM_Init
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    45  * Description        :    Intilize the Watchdog Manager as per Configurations
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    46  * Parameters[in]    :   ConfigPtr
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    47  * Limitations        :    Care has to be taken while calling this function as it is not reentrant.
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    48  * ReturnType        :    Void
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    49  *****************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    50  /* TRACE[WDGM151] Implementation of WdgM_Init*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    51  /* TODO: TRACE[WDGM298] WdgMDeadlineStartRef will be set to 0 */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    52  /* TODO: TRACE[WDGM225] Partial Shutdown pending due to lack of support from BswM*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    53  /* TODO: TRACE[WDGM002] The watchdog shall support mutilple watchdog*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    54  FUNC(void, WDGM_CODE_SLOW) WdgM_Init(P2CONST(WdgM_ConfigType, AUTOMATIC, WDGM_APPL_CONST)ConfigPtr)
; Function WdgM_Init
.L139:
WdgM_Init:	.type	func

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    55  {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    56  #if((WDGM_OFF_MODE_ENABLED)  == (STD_OFF))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    57      VAR(uint8, AUTOMATIC) TriggerIdx;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    58      P2CONST(WdgM_TriggerType, AUTOMATIC, WDGM_APPL_CONST) TriggerPtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    59  #endif /*((WDGM_OFF_MODE_ENABLED)  == (STD_OFF))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    60      VAR(WdgM_SupervisedEntityIdType, AUTOMATIC) SEID;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    61  #if ((WDGM_MAX_DEADLINE_SUPERVISIONS) > (WDGM_PRV_C_ZERO))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    62      VAR(uint16, AUTOMATIC) DeadlineSupervisionIdx;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    63  #endif /*((WDGM_MAX_DEADLINE_SUPERVISIONS) > (WDGM_PRV_C_ZERO)) */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    64      VAR(Std_ReturnType, AUTOMATIC) ReturnStatus;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    65  #if((WDGM_RTE_DISABLED) == (STD_OFF))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    66      VAR(Rte_PortHandle_WdgM_IndividualMode_P,AUTOMATIC) PortHandle = Rte_Ports_WdgM_IndividualMode_P();
	movh.a	a12,#@his(Rte_Inst_WdgM)
.L303:
	lea	a12,[a12]@los(Rte_Inst_WdgM)
.L569:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    67  #endif /*(WDGM_RTE_DISABLED == STD_OFF)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    68  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    69      /* TODO: Check whether BSW00406(AUTOSAR_SRS_BSWGeneral.pdf) is really required even if
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    70       * we can detect WdgM initialized or not, without explicit static status variable...!! */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    71  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    72  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    73      WdgM_MainFunction_Cnt_u32 = WDGM_PRV_C_ZERO;
	movh.a	a15,#@his(WdgM_MainFunction_Cnt_u32)
	lea	a15,[a15]@los(WdgM_MainFunction_Cnt_u32)
.L570:
	mov	d15,#0
.L571:
	st.w	[a15],d15
.L572:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    74  #endif /*((WDGM_DEV_ERROR_DETECT) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    75  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    76      /*
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    77       * WdgM_ConfigSetPtr is assigned according to the variants
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    78       * If WdgM_ConfigSet is configured at precompile then the sanity checks are done via the script.
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    79       * Hence in this case no more sanity checking
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    80       */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    81  #if (defined(WDGM_VARIANT_PRE_COMPILE))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    82      /* The parameter "ConfigPtr" is void casted, as it is unused during Precompile*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    83          (void)ConfigPtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    84          WdgM_ConfigSetPtr = &WdgM_Config;
	movh.a	a13,#@his(WdgM_ConfigSetPtr)
	lea	a13,[a13]@los(WdgM_ConfigSetPtr)
.L573:
	movh.a	a15,#@his(WdgM_Config)
	lea	a15,[a15]@los(WdgM_Config)
.L574:
	st.a	[a13],a15
.L575:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    85      /* Else if not Precompile ie POST build hence perform sanity check on ConfigSet*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    86  #else /*defined(WDGM_VARIANT_PRE_COMPILE)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    87  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    88      /* TRACE[WDGM255] Check for NULL_PTR*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    89      if (ConfigPtr == NULL_PTR)
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    90      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    91          /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored, and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    92          (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_INIT_APIID, WDGM_E_INV_POINTER);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    93          return;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    94      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    95      else
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    96      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    97          /* TRACE[WDGM010] Perform Sanity Check fo the ConfigData and load the values */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    98          ReturnStatus = WdgM_Prv_PbCfgCheck_tu8_Inl(ConfigPtr);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	    99          if(ReturnStatus != E_OK)
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   100          {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   101              /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored, and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   102              (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_INIT_APIID, WDGM_E_PARAM_CONFIG);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   103              return;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   104          }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   105      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   106  #endif /*((WDGM_DEV_ERROR_DETECT) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   107      WdgM_ConfigSetPtr = ConfigPtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   108  #endif /*defined(WDGM_VARIANT_PRE_COMPILE)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   109  #if((WDGM_OFF_MODE_ENABLED)  == (STD_OFF))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   110      TriggerPtr = WdgM_ConfigSetPtr->PtrToMode[WdgM_ConfigSetPtr->InitialMode].PtrToTrigger;
	ld.a	a2,[a13]
.L576:
	ld.a	a15,[a2]16
.L577:
	ld.bu	d15,[a2]
	sha	d15,#5
.L578:
	addsc.a	a15,a15,d15,#0
.L579:
	ld.a	a4,[a15]28
.L302:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   111      for(TriggerIdx = WDGM_PRV_C_ZERO;
	mov	d0,#0
.L305:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   112              TriggerIdx < WdgM_ConfigSetPtr->PtrToMode[WdgM_ConfigSetPtr->InitialMode].NoOfTrigger;
	j	.L2

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   113              TriggerIdx++)
.L3:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   114      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   115          if (TriggerPtr[TriggerIdx].WdgMode == WDGIF_OFF_MODE)
	addsc.a	a15,a4,d0,#3
.L580:
	ld.w	d15,[a15]4
.L581:
	jne	d15,#0,.L4
.L582:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   116          {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   117              /* TRACE[WDGM030] Since WdgM Mode is in Off Mode Do not intilize the WdgM*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   118  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   119              /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored, and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   120              (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_INIT_APIID, WDGM_E_DISABLE_NOT_ALLOWED);
	mov	d4,#13
.L583:
	mov	d5,#0
.L584:
	mov	d6,#0
.L585:
	mov	d7,#21
	call	Det_ReportError
.L304:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   121  #endif /*((WDGM_DEV_ERROR_DETECT) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   122              return;
	j	.L5
.L4:
	add	d0,#1
.L306:
	extr.u	d0,d0,#0,#8
.L2:
	ld.a	a15,[a2]16
.L586:
	ld.bu	d15,[a2]
	sha	d15,#5
.L587:
	addsc.a	a15,a15,d15,#0
.L588:
	ld.bu	d15,[a15]14
.L589:
	jlt.u	d0,d15,.L3
.L590:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   123          }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   124      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   125  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   126      /*TRACE[WDGM269]: Transition: 11: Initally all local SE are DEACTIVATED */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   127      for(SEID = WDGM_PRV_C_ZERO; SEID < WDGM_NO_OF_SUPERVISED_ENTITIES; SEID++)
	mov	d8,#0
.L307:
	j	.L6
.L7:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   128      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   129          WdgM_SupervisedEntityDyn[SEID].OldLocalStatus = WDGM_LOCAL_STATUS_DEACTIVATED;
	movh.a	a15,#@his(WdgM_SupervisedEntityDyn)
	lea	a15,[a15]@los(WdgM_SupervisedEntityDyn)
.L591:
	mul	d15,d8,#12
	addsc.a	a15,a15,d15,#0
.L592:
	mov	d15,#4
.L593:
	st.b	[a15]11,d15
.L594:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   130          WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WDGM_LOCAL_STATUS_DEACTIVATED;
	mov	d15,#4
.L595:
	st.b	[a15]10,d15
.L596:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   131          /* TRACE[SWS_WdgM_00296] Init flgActivity to FALSE and idLastReachedCheckpoint to zero
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   132           * for all WdgM_SupervisedEntityDyn Entries of Internal Graph*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   133  #if (WDGM_INTERNAL_GRAPH_CONFIGURED == STD_ON)
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   134          WdgM_SupervisedEntityDyn[SEID].flgActivity = FALSE;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   135          WdgM_SupervisedEntityDyn[SEID].idLastReachedCheckpoint = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   136  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   137  #if((WDGM_RTE_DISABLED) == (STD_OFF))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   138          PortHandle[SEID].Switch_currentMode(RTE_MODE_WdgM_Mode_SUPERVISION_DEACTIVATED);
	addsc.a	a15,a12,d8,#3
.L597:
	ld.a	a15,[a15]4
.L598:
	mov	d4,#4
	calli	a15
.L599:
	add	d8,#1
.L6:
	jeq	d8,#0,.L7
.L600:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   139  #endif/*(WDGM_RTE_DISABLED == STD_OFF)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   140      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   141      WdgM_Prv_SetMode_GlobalStatus = WDGM_GLOBAL_STATUS_DEACTIVATED;
	movh.a	a15,#@his(WdgM_Prv_SetMode_GlobalStatus)
	lea	a15,[a15]@los(WdgM_Prv_SetMode_GlobalStatus)
.L601:
	mov	d15,#4
.L602:
	st.b	[a15],d15
.L603:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   142      /* User sets many modes via WdgMMode[].
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   143       * He will configure one of the Modes as the Initial Mode fro WdgM.
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   144       * Here the user set user set Initial Mode is as WdgM Inital Mode*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   145      /* TRACE[WDGM135] Set the Initial Mode of the WdgM*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   146      ReturnStatus = WdgM_SetMode(WdgM_ConfigSetPtr->InitialMode, WDGM_MODULE_ID);
	ld.a	a15,[a13]
.L604:
	ld.bu	d4,[a15]
.L605:
	mov	d5,#13
	call	WdgM_SetMode
.L308:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   147      /* Configure the Supervision ENtities to be used its LOCAL_STATUS to ACTIVE*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   148      if(ReturnStatus == E_OK)
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   149      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   150          /* TRACE [WDGM350] Clear the Complementary Entries of SEID at Init*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   151          WdgM_FirstExpiredSupervisedEntityId = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   152          /* Wrong complement is given to detect first expired Supervision */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   153          WdgM_FirstExpiredSupervisedEntityId_Comp = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   154          WdgM_ExpiredSupervisionCycleCtr = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   155  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   156  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   157          if(WdgM_Rb_FirstExpiredEntity_Cnt_u8 == WDGM_PRV_C_ZERO)
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   158          {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   159              WdgM_Rb_DebugVariables_Init_v_Inl();
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   160          }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   161  #endif/*(WDGM_RB_DEBUG_OPTION_ENABLED == STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   162  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   163          /* Alive supervision */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   164          /* Nothing to do. Already values are set in WdgM_SetMode */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   165  #if ((WDGM_MAX_DEADLINE_SUPERVISIONS) > (WDGM_PRV_C_ZERO))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   166          /* Deadline supervision */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   167          /* TRACE[WDGM298] All Deadline Start Checkpoints set their timestamps to 0  */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   168          for(DeadlineSupervisionIdx = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   169                  DeadlineSupervisionIdx < WDGM_MAX_DEADLINE_SUPERVISIONS;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   170                  DeadlineSupervisionIdx++)
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   171          {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   172              if(WdgM_ConfigSetPtr->PtrToRunningCounterValue != NULL_PTR)
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   173              {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   174                  WdgM_ConfigSetPtr->PtrToRunningCounterValue[DeadlineSupervisionIdx] = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   175              }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   176          }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   177  #endif /*((WDGM_MAX_DEADLINE_SUPERVISIONS) > (WDGM_PRV_C_ZERO)) */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   178          /* TRACE[WDGM285] Init Complete Set GLobal Status To OK  */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   179          WdgM_GlobalStatus = WDGM_GLOBAL_STATUS_OK;
	movh.a	a15,#@his(WdgM_GlobalStatus)
	lea	a15,[a15]@los(WdgM_GlobalStatus)
.L606:
	jne	d2,#0,.L8
.L607:
	movh.a	a2,#@his(WdgM_FirstExpiredSupervisedEntityId)
	lea	a2,[a2]@los(WdgM_FirstExpiredSupervisedEntityId)
.L608:
	mov	d15,#0
.L609:
	st.b	[a2],d15
.L610:
	movh.a	a2,#@his(WdgM_FirstExpiredSupervisedEntityId_Comp)
	lea	a2,[a2]@los(WdgM_FirstExpiredSupervisedEntityId_Comp)
.L611:
	mov	d15,#0
.L612:
	st.b	[a2],d15
.L613:
	movh.a	a2,#@his(WdgM_ExpiredSupervisionCycleCtr)
	lea	a2,[a2]@los(WdgM_ExpiredSupervisionCycleCtr)
.L614:
	mov	d15,#0
.L615:
	st.h	[a2],d15
.L616:
	mov	d15,#0
.L617:
	st.b	[a15],d15
.L618:
	j	.L9
.L8:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   180  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   181      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   182      else
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   183      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   184          /*TRACE[WDGM139] WdgIf_SetMode is being called from WdgM_SetMode
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   185           *If SetMode fails then set the GlobalStatus to STOPPED */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   186          WdgM_GlobalStatus = WDGM_GLOBAL_STATUS_STOPPED;
	mov	d15,#3
.L619:
	st.b	[a15],d15
.L9:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   187      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   188  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   189      return;
	j	.L10

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   190  }
.L10:
.L5:
	ret
.L261:
	
__WdgM_Init_function_end:
	.size	WdgM_Init,__WdgM_Init_function_end-WdgM_Init
.L191:
	; End of function
	
	.sdecl	'.text.WdgM.WdgM_DeInit',code,cluster('WdgM_DeInit')
	.sect	'.text.WdgM.WdgM_DeInit'
	.align	2
	
	.global	WdgM_DeInit

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   191  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   192  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   193  /*******************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   194  * Name              :   WdgM_DeInit
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   195  * Description       :   DeIntilize the Watchdog Manager.
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   196  * Parameters[in]    :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   197  * Limitations       :   Care has to be taken while calling this function as it is not reentrant.
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   198  * ReturnType        :   Void
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   199  *******************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   200  /* TRACE[WDGM261] Implementation of WdgM_DeInit*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   201  FUNC(void, WDGM_CODE_SLOW) WdgM_DeInit(void)
; Function WdgM_DeInit
.L141:
WdgM_DeInit:	.type	func

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   202  {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   203  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   204  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   205      /* TRACE[WDGM288] To check if WdgM is Initilized if not then log error in Det. */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   206      if (WdgM_GlobalStatus == WDGM_GLOBAL_STATUS_DEACTIVATED)
	movh.a	a15,#@his(WdgM_GlobalStatus)
	lea	a15,[a15]@los(WdgM_GlobalStatus)
	ld.bu	d15,[a15]
.L624:
	jne	d15,#4,.L11
.L625:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   207      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   208          /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored, and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   209          (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_DE_INIT_APIID , WDGM_E_NO_INIT);
	mov	d4,#13
.L626:
	mov	d5,#0
.L627:
	mov	d6,#1
.L628:
	mov	d7,#16
	call	Det_ReportError
.L629:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   210          return;
	j	.L12
.L11:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   211      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   212  #endif /*((WDGM_DEV_ERROR_DETECT) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   213  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   214      if(WdgM_GlobalStatus == WDGM_GLOBAL_STATUS_OK)
	jne	d15,#0,.L13
.L630:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   215      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   216          SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   217          /* TRACE[WDGM286] Set global status to Deactivated, if Wdg global status is OK*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   218          WdgM_GlobalStatus = WDGM_GLOBAL_STATUS_DEACTIVATED;
	mov	d15,#4
.L631:
	st.b	[a15],d15
.L13:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   219          SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   220      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   221      return;
	j	.L14

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   222  }
.L14:
.L12:
	ret
.L270:
	
__WdgM_DeInit_function_end:
	.size	WdgM_DeInit,__WdgM_DeInit_function_end-WdgM_DeInit
.L196:
	; End of function
	
	.sdecl	'.text.WdgM.WdgM_SetMode',code,cluster('WdgM_SetMode')
	.sect	'.text.WdgM.WdgM_SetMode'
	.align	2
	
	.global	WdgM_SetMode

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   223  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   224  #if( (WDGM_VERSION_INFO_API) == (STD_ON) )
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   225  /*******************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   226  * Name              :   WdgM_GetVersionInfo
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   227  * Description       :   Returns the version information of this module.
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   228  * Parameters[out]   :   VersionInfo
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   229  * Limitations       :   Care has to be taken while calling this function as it is not reentrant.
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   230  * ReturnType        :   Void
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   231  *******************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   232  /* TRACE[WDGM110] Implementation of WDGM_GetVersionInfo whcih can be disabled at preCompile time*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   233  FUNC(void, WDGM_CODE_SLOW) WdgM_GetVersionInfo (P2VAR(Std_VersionInfoType, AUTOMATIC, WDGM_APPL_DATA)VersionInfo)
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   234  {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   235  #if ((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   236      /* TRACE[WDGM256]  Perform sanity checks on VersionInfo*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   237      if (VersionInfo == NULL_PTR)
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   238      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   239          /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored, and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   240          (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_GET_VERSION_INFO_APIID, WDGM_E_INV_POINTER);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   241          return;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   242      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   243  #endif /*((WDGM_DEV_ERROR_DETECT) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   244  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   245      VersionInfo->vendorID   = WDGM_VENDOR_ID;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   246      VersionInfo->moduleID   = WDGM_MODULE_ID;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   247      VersionInfo->sw_major_version = WDGM_SW_MAJOR_VERSION;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   248      VersionInfo->sw_minor_version = WDGM_SW_MINOR_VERSION;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   249      VersionInfo->sw_patch_version = WDGM_SW_PATCH_VERSION;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   250      return;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   251  }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   252  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   253  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   254  #define WDGM_STOP_SEC_CODE_SLOW
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   255  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   256  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   257  #define WDGM_START_SEC_CODE_FAST
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   258  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   259  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   260  /*******************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   261  * Name              :   WdgM_SetMode
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   262  * Description       :   Sets the current mode of Watchdog Manager.
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   263  * Parameters[in]    :   Mode, CallerID
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   264  * Limitations       :   Care has to be taken while calling this function as it is not reentrant.
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   265  * ReturnType        :   void
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   266  *******************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   267  FUNC(Std_ReturnType, WDGM_CODE_FAST) WdgM_SetMode(VAR(WdgM_ModeType,AUTOMATIC) Mode, VAR(uint16,AUTOMATIC) CallerID)
; Function WdgM_SetMode
.L143:
WdgM_SetMode:	.type	func
	sub.a	a10,#8
.L309:
	mov	d8,d4
.L312:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   268  /*TRACE[WDGM154] Implementation of WdgM_SetMode*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   269  /* TODO: Check whether voilation is possible for AUTOSAR_SRS_BSWGeneral.pdf: WDGM345: BSW00433, BSW00429 */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   270  {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   271  /*Generated only when one or more Caller Id is configured or WDGM_OFF_MODE is disabled*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   272  /* Variable is not needed if DET is ON, Defensive Behavior is ON and No of Caller ID is 0 */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   273  #if (((WDGM_DEV_ERROR_DETECT == STD_ON) && (WDGM_DEFENSIVE_BEHAVIOR == STD_ON) && (WDGM_NO_OF_EXTERNAL_CALLER_IDENTIFIERS == WDGM_PRV_C_ZERO)) == FALSE)
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   274  #if(((WDGM_DEV_ERROR_DETECT == STD_ON) && (WDGM_DEFENSIVE_BEHAVIOR == STD_ON) && (WDGM_NO_OF_EXTERNAL_CALLER_IDENTIFIERS > WDGM_PRV_C_ZERO)) || (WDGM_OFF_MODE_ENABLED  == STD_OFF))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   275      VAR(uint8, AUTOMATIC) ctr;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   276  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   277  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   278  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   279      VAR(Std_ReturnType, AUTOMATIC) ReturnStatus;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   280  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   281  /*Generated only when WDGM_OFF_MODE is disabled*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   282  /* Variable is not needed if DET is ON, Defensive Behavior is ON and No of Caller ID is 0 */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   283  #if (((WDGM_DEV_ERROR_DETECT == STD_ON) && (WDGM_DEFENSIVE_BEHAVIOR == STD_ON) && (WDGM_NO_OF_EXTERNAL_CALLER_IDENTIFIERS == WDGM_PRV_C_ZERO)) == FALSE)
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   284  #if((WDGM_OFF_MODE_ENABLED)  == (STD_OFF))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   285      P2CONST(WdgM_TriggerType, AUTOMATIC, WDGM_APPL_CONST) TriggerPtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   286  #endif /*(WDGM_OFF_MODE_ENABLED)  == (STD_OFF)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   287  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   288  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   289      /*If non configured modules are accessing the SetMode then Error*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   290      ReturnStatus = E_NOT_OK;
	mov	d15,#1
.L387:
	st.b	[a10],d15
.L388:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   291      /* TRACE[WDGM338] Watchdog Manager Service*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   292      /* Enter here for Set Mode access from a Non WatchDog functions*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   293      if(CallerID != (uint16)WDGM_MODULE_ID)
	mov	d15,#13
.L389:
	jeq	d15,d5,.L15
.L390:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   294      {/* CallerID check is required to allow WdgM_SetMode to be called from WdgM_Init even when WdgM is not initialized */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   295  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   296  #if((WDGM_DEFENSIVE_BEHAVIOR) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   297  #if((WDGM_NO_OF_EXTERNAL_CALLER_IDENTIFIERS > WDGM_PRV_C_ZERO)) /* When one or more called Id is configured */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   298          /*IF match found within the allowed limit then break */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   299          for(ctr= WDGM_PRV_C_ZERO; ctr<WDGM_NO_OF_EXTERNAL_CALLER_IDENTIFIERS; ctr++)
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   300          {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   301              if (WdgM_CallerIds[ctr] == CallerID)
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   302              {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   303                  break;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   304              }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   305          }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   306          /*TRACE [WDGM245] Check if the caller Id is from the given list of caller Id's*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   307          if(ctr == WDGM_NO_OF_EXTERNAL_CALLER_IDENTIFIERS) /* It means CallerID not found */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   308          {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   309  #if((WDGM_DEM_ALIVE_SUPERVISION_REPORT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   310              Dem_ReportErrorStatus(WdgM_ConfigSetPtr->ErrorImproperCaller, DEM_EVENT_STATUS_FAILED);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   311  #endif /*((WDGM_DEM_ALIVE_SUPERVISION_REPORT) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   312                  return E_NOT_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   313          }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   314  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   315  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   316  #if(WDGM_NO_OF_EXTERNAL_CALLER_IDENTIFIERS == WDGM_PRV_C_ZERO) /* When no called Id is configured */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   317  #if((WDGM_DEM_ALIVE_SUPERVISION_REPORT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   318               Dem_ReportErrorStatus(WdgM_ConfigSetPtr->ErrorImproperCaller, DEM_EVENT_STATUS_FAILED);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   319  #endif /*((WDGM_DEM_ALIVE_SUPERVISION_REPORT) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   320               return E_NOT_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   321  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   322  #endif /*WDGM_DEFENSIVE_BEHAVIOR == STD_ON*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   323  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   324  /* Below checks are not needed in case DET is ON, Defensive Behavior is ON and No of Caller ID is 0,
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   325   * as in this case unconditionally return statement is invoked above */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   326  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   327  #if ( ((WDGM_DEFENSIVE_BEHAVIOR == STD_ON) && (WDGM_NO_OF_EXTERNAL_CALLER_IDENTIFIERS == WDGM_PRV_C_ZERO)) == FALSE)
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   328          /* TRACE[WDGM021] Check if WdgM is initilized if not then log DET */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   329          if (WdgM_GlobalStatus == WDGM_GLOBAL_STATUS_DEACTIVATED)
	movh.a	a15,#@his(WdgM_GlobalStatus)
	lea	a15,[a15]@los(WdgM_GlobalStatus)
	ld.bu	d15,[a15]
.L391:
	jne	d15,#4,.L16
.L392:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   330          {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   331              /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored, and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   332              (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_SET_MODE_APIID , WDGM_E_NO_INIT);
	mov	d4,#13
.L311:
	mov	d5,#0
.L310:
	mov	d6,#3
.L393:
	mov	d7,#16
	call	Det_ReportError
.L394:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   333              return E_NOT_OK;
	mov	d2,#1
.L395:
	j	.L17
.L16:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   334          }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   335          /* TRACE[WDGM020] If the mode is not a valid Mode*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   336          if (Mode >= WdgM_ConfigSetPtr->NoOfMode)
	movh.a	a2,#@his(WdgM_ConfigSetPtr)
	lea	a2,[a2]@los(WdgM_ConfigSetPtr)
	ld.a	a15,[a2]
.L396:
	ld.bu	d15,[a15]1
.L397:
	jlt.u	d8,d15,.L18
.L398:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   337          {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   338              /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored, and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   339              (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_SET_MODE_APIID, WDGM_E_PARAM_MODE);
	mov	d4,#13
.L315:
	mov	d5,#0
.L314:
	mov	d6,#3
.L399:
	mov	d7,#18
	call	Det_ReportError
.L400:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   340              return E_NOT_OK;
	mov	d2,#1
.L401:
	j	.L19
.L18:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   341          }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   342  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   343  #endif /*((WDGM_DEV_ERROR_DETECT) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   344  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   345  /* Below checks are not needed in case DET is ON, Defensive Behavior is ON and No of Caller ID is 0,
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   346   * as in this case unconditionally return statement is invoked above */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   347  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   348  #if (((WDGM_DEV_ERROR_DETECT == STD_ON) && (WDGM_DEFENSIVE_BEHAVIOR == STD_ON) && (WDGM_NO_OF_EXTERNAL_CALLER_IDENTIFIERS == WDGM_PRV_C_ZERO)) == FALSE)
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   349          /* TRACE [WDGM031] WdgM Disable Mode is not enabled and if off_Mode has been requested then log error */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   350  #if((WDGM_OFF_MODE_ENABLED)  == (STD_OFF))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   351          TriggerPtr = WdgM_ConfigSetPtr->PtrToMode[Mode].PtrToTrigger;
	sha	d0,d8,#5
.L402:
	ld.a	a15,[a15]16
.L403:
	addsc.a	a15,a15,d0,#0
.L404:
	ld.a	a4,[a15]28
.L318:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   352          for(ctr= WDGM_PRV_C_ZERO; ctr < WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfTrigger; ctr++)
	mov	d1,#0
.L320:
	j	.L20
.L21:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   353          {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   354              if (TriggerPtr[ctr].WdgMode == WDGIF_OFF_MODE)
	addsc.a	a15,a4,d1,#3
.L405:
	ld.w	d15,[a15]4
.L406:
	jne	d15,#0,.L22
.L407:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   355              {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   356  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   357                  /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored, and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   358                  (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_SET_MODE_APIID , WDGM_E_DISABLE_NOT_ALLOWED);
	mov	d4,#13
.L317:
	mov	d5,#0
.L316:
	mov	d6,#3
.L408:
	mov	d7,#21
	call	Det_ReportError
.L319:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   359  #endif /*((WDGM_DEV_ERROR_DETECT) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   360                  return E_NOT_OK;
	mov	d2,#1
.L409:
	j	.L23
.L22:
	add	d1,#1
.L321:
	extr.u	d1,d1,#0,#8
.L20:
	ld.a	a15,[a2]
.L410:
	ld.a	a15,[a15]16
.L411:
	addsc.a	a15,a15,d0,#0
.L412:
	ld.bu	d15,[a15]14
.L413:
	jlt.u	d1,d15,.L21
.L15:
	movh.a	a12,#@his(WdgM_ConfigSetPtr)
	lea	a12,[a12]@los(WdgM_ConfigSetPtr)
.L414:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   361              }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   362          }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   363  #endif /*((WDGM_OFF_MODE_ENABLED)  == (STD_OFF))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   364  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   365      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   366  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   367      /* Enter here for Set Mode access from WatchDog functions*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   368      /*TRACE[WDGM145] perform SetMode only if the Global status is OK or FAILED*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   369      #if ((WDGM_DEV_ERROR_DETECT == STD_ON) && (WDGM_DEFENSIVE_BEHAVIOR == STD_ON) && (WDGM_NO_OF_EXTERNAL_CALLER_IDENTIFIERS == WDGM_PRV_C_ZERO))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   370      /* Under this condition, code execution can reach here only if CallerID = WDGM_MODULE_ID. i.e, WdgM_SetMode() is called by WdgM_Init */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   371      if(Mode < WdgM_ConfigSetPtr->NoOfMode)
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   372      #else
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   373      if((Mode < WdgM_ConfigSetPtr->NoOfMode)&&((WdgM_GlobalStatus == WDGM_GLOBAL_STATUS_OK)||
	ld.a	a15,[a12]
.L415:
	ld.bu	d15,[a15]1
.L416:
	jge.u	d8,d15,.L24
.L417:
	movh.a	a15,#@his(WdgM_GlobalStatus)
	lea	a15,[a15]@los(WdgM_GlobalStatus)
	ld.bu	d15,[a15]
.L418:
	jeq	d15,#0,.L25
.L419:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   374      (WdgM_GlobalStatus == WDGM_GLOBAL_STATUS_FAILED)||(CallerID == WDGM_MODULE_ID)))
	jeq	d15,#1,.L26
.L420:
	mov	d15,#13
.L421:
	jne	d15,d5,.L27
.L26:
.L25:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   375      #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   376      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   377          /* Trigger Condition */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   378          WdgM_Prv_UpdateTriggerDyn_v_Inl(Mode, &ReturnStatus);
	lea	a13,[a10]0
.L226:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     1  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     2  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     3  #ifndef WDGM_PRV_H
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     4  #define WDGM_PRV_H
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     5  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     6  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     7   **********************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     8   * Includes
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     9   **********************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    10  */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    11  #define WDGM_PRV_AVOID_RTE_PROVIDED_FUNC_DECLARATION
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    12  #include "WdgM.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    13  #undef WDGM_PRV_AVOID_RTE_PROVIDED_FUNC_DECLARATION
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    14  #if((WDGM_RTE_DISABLED) == (STD_OFF))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    15  #include "SchM_WdgM.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    16  #include "WdgM_Cfg_SchM.h" /* TODO: To be removed when RTE supports Exclusive Area. */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    17  #include "Rte_WdgM.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    18  #else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    19  #include "WdgM_Cfg_SchM.h" /* It is mandatory if RTE is disabled. */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    20  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    21  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    22  #include "WdgIf.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    23  #if (!defined(WDGIF_AR_RELEASE_MAJOR_VERSION) || (WDGIF_AR_RELEASE_MAJOR_VERSION != 4))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    24  #error “AUTOSAR major version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    25  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    26  #if (!defined(WDGIF_AR_RELEASE_MINOR_VERSION) || (WDGIF_AR_RELEASE_MINOR_VERSION != 2))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    27  #error “AUTOSAR minor version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    28  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    29  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    30  #if (((WDGM_IMMEDIATE_RESET) == (STD_ON)) || ((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_MCU)))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    31  #include "Mcu.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    32  #if (!defined(MCU_AR_RELEASE_MAJOR_VERSION) || (MCU_AR_RELEASE_MAJOR_VERSION != 4))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    33  #error “AUTOSAR major version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    34  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    35  #if (!defined(MCU_AR_RELEASE_MINOR_VERSION) || (MCU_AR_RELEASE_MINOR_VERSION != 2))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    36  #error “AUTOSAR minor version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    37  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    38  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    39  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    40  #include "BswM_WdgM.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    41  #if (!defined(BSWM_AR_RELEASE_MAJOR_VERSION) || (BSWM_AR_RELEASE_MAJOR_VERSION != 4))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    42  #error “AUTOSAR major version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    43  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    44  #if (!defined(BSWM_AR_RELEASE_MINOR_VERSION) || (BSWM_AR_RELEASE_MINOR_VERSION != 2))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    45  #error “AUTOSAR minor version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    46  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    47  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    48  #include "Os.h" /* specified in SWS. required for GetElapsedCounterValue Api */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    49  #if (!defined(OS_AR_RELEASE_MAJOR_VERSION) || (OS_AR_RELEASE_MAJOR_VERSION != 4))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    50  #error “AUTOSAR major version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    51  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    52  #if (!defined(OS_AR_RELEASE_MINOR_VERSION) || (OS_AR_RELEASE_MINOR_VERSION != 2))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    53  #error “AUTOSAR minor version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    54  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    55  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    56  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    57   *********************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    58   * Defines/Macros
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    59   *********************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    60  */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    61  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    62  /* For debugging */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    63  #if ((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    64  #define WDGM_RB_FAILED_IN_ALIVE_MAINFUNCTION                            ((uint8)(1))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    65  #define WDGM_RB_FAILED_IN_DEADLINE_MAINFUNCTION                         ((uint8)(2))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    66  #define WDGM_RB_FAILED_IN_DEADLINE_CHECKPOINTREACHED                    ((uint8)(3))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    67  #define WDGM_RB_FAILED_IN_LOGICAL_INTGRAPH_CPREACHED_GRAPHNOTSTARTED    ((uint8)(4))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    68  #define WDGM_RB_FAILED_IN_LOGICAL_INTGRAPH_CPREACHED_GRAPHSTARTED       ((uint8)(5))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    69  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    70  typedef struct
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    71  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    72  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    73      VAR(TickType,WDGM_VAR_FAST_POWER_ON_CLEARED_UNSPECIFIED)                    FirstElapsedCounterValue;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    74      VAR(uint16,WDGM_VAR_FAST_POWER_ON_CLEARED_16)                               FirstExpiredCheckpointId_t;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    75      VAR(uint16,WDGM_VAR_FAST_POWER_ON_CLEARED_16)                               FirstExpiredAdditionalCheckpointId;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    76      VAR(WdgM_SupervisedEntityIdType,WDGM_VAR_FAST_POWER_ON_CLEARED_UNSPECIFIED) FirstExpiredSupervisedEntityId_t;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    77      VAR(uint8,WDGM_VAR_FAST_POWER_ON_CLEARED_8)                                 FirstExpiredLocation_t;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    78      VAR(WdgM_ModeType,AUTOMATIC)                                                FirstExpiredModeId;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    79  }WdgM_Rb_FirstExpiredEntityInfo_tst;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    80  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    81  #endif /*WDGM_RB_DEBUG_OPTION_ENABLED*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    82  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    83  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    84   **********************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    85   * Extern declarations
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    86   **********************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    87  */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    88  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    89  #define WDGM_START_SEC_VAR_FAST_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    90  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    91  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    92  extern P2CONST(WdgM_ConfigType, WDGM_VAR_FAST_CLEARED_UNSPECIFIED, WDGM_APPL_CONST)WdgM_ConfigSetPtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    93  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    94  #define WDGM_STOP_SEC_VAR_FAST_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    95  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    96  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    97  #define WDGM_START_SEC_VAR_FAST_CLEARED_BOOLEAN
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    98  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    99  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   100  extern VAR(boolean, WDGM_VAR_FAST_CLEARED_BOOLEAN) WdgM_AliveSupervisionActive;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   101  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   102  #define WDGM_STOP_SEC_VAR_FAST_CLEARED_BOOLEAN
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   103  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   104  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   105  #define WDGM_START_SEC_VAR_FAST_CLEARED_8
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   106  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   107  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   108  extern VAR(uint8, WDGM_VAR_FAST_CLEARED_8) WdgM_Mode;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   109  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   110  #define WDGM_STOP_SEC_VAR_FAST_CLEARED_8
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   111  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   112  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   113  #define WDGM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   114  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   115  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   116  extern VAR(uint16, WDGM_VAR_CLEARED_16) WdgM_ExpiredSupervisionCycleCtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   117  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   118  #define WDGM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   119  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   120  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   121  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   122  #define WDGM_START_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   123  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   124  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   125  extern VAR(uint32, WDGM_VAR_CLEARED_32) WdgM_MainFunction_Cnt_u32;  /* This variable is used only for debug purpose. */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   126  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   127  #define WDGM_STOP_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   128  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   129  #endif /*((WDGM_DEV_ERROR_DETECT) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   130  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   131  #define WDGM_START_SEC_VAR_SLOW_INIT_BOOLEAN
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   132  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   133  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   134  extern VAR(boolean, WDGM_VAR_SLOW_INIT_BOOLEAN) WdgM_Prv_FirstDeactivation_b;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   135  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   136  #define WDGM_STOP_SEC_VAR_SLOW_INIT_BOOLEAN
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   137  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   138  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   139  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   140  #define WDGM_START_SEC_VAR_FAST_POWER_ON_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   141  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   142  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   143  extern VAR(WdgM_Rb_FirstExpiredEntityInfo_tst, WDGM_VAR_FAST_POWER_ON_CLEARED_UNSPECIFIED) WdgM_Rb_FirstExpiredEntityInfo_st;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   144  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   145  #define WDGM_STOP_SEC_VAR_FAST_POWER_ON_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   146  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   147  #endif /*(WDGM_RB_DEBUG_OPTION_ENABLED == STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   148  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   149  #define WDGM_START_SEC_VAR_POWER_ON_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   150  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   151  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   152  /* TRACE[WDGM349] Implementation of non-initialized RAM location, stored as a double-inverse value */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   153  extern VAR(WdgM_SupervisedEntityIdType, WDGM_VAR_POWER_ON_CLEARED_UNSPECIFIED) WdgM_FirstExpiredSupervisedEntityId;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   154  extern VAR(WdgM_SupervisedEntityIdType, WDGM_VAR_POWER_ON_CLEARED_UNSPECIFIED) WdgM_FirstExpiredSupervisedEntityId_Comp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   155  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   156  #define WDGM_STOP_SEC_VAR_POWER_ON_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   157  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   158  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   159  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   160  #define WDGM_START_SEC_VAR_FAST_POWER_ON_CLEARED_8
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   161  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   162  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   163  extern VAR(uint8, WDGM_VAR_FAST_POWER_ON_CLEARED_8) WdgM_Rb_FirstExpiredEntity_Cnt_u8;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   164  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   165  #define WDGM_STOP_SEC_VAR_FAST_POWER_ON_CLEARED_8
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   166  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   167  #endif /*(WDGM_RB_DEBUG_OPTION_ENABLED == STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   168  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   169  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   170   ***********************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   171   * Private Function Declaration
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   172   ***********************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   173  */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   174  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   175  #define WDGM_START_SEC_CODE
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   176  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   177  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   178  extern FUNC(void, WDGM_CODE) WdgM_Prv_SetTriggerCondition(VAR(WdgM_GlobalStatusType, AUTOMATIC)globalStatus_tu8);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   179  extern FUNC(void,WDGM_CODE) WdgM_Prv_LocalStatusMainFunction(void);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   180  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   181  #define WDGM_STOP_SEC_CODE
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   182  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   183  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   184  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   185  #define WDGM_START_SEC_CODE_FAST
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   186  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   187  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   188  extern FUNC(void, WDGM_CODE_FAST) WdgM_Rb_FirstExpiredEntity(VAR(TickType,AUTOMATIC) ElapsedCounterValue, VAR(uint16,AUTOMATIC) CheckpointID,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   189          VAR(uint16,AUTOMATIC) AdditionalCheckpointID, VAR(WdgM_SupervisedEntityIdType,AUTOMATIC) SEID,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   190          VAR(uint8,AUTOMATIC) ExpiredLocation, VAR(WdgM_ModeType,AUTOMATIC) ModeId);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   191  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   192  #define WDGM_STOP_SEC_CODE_FAST
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   193  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   194  #endif/*(WDGM_RB_DEBUG_OPTION_ENABLED == STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   195  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   196  LOCAL_INLINE void WdgM_Prv_AliveSupervisionMainFunction_v_Inl(void);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   197  LOCAL_INLINE void WdgM_Prv_UpdateAliveSupervisionDyn_v_Inl(void);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   198  LOCAL_INLINE void WdgM_Prv_UpdateTriggerDyn_v_Inl(VAR(WdgM_ModeType,AUTOMATIC) Mode, P2VAR(Std_ReturnType,AUTOMATIC,WDGM_APPL_DATA)ReturnStatus);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   199  LOCAL_INLINE void WdgM_Prv_UpdateSupervisedEntityDyn_v_Inl(VAR(WdgM_ModeType,AUTOMATIC) Mode);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   200  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   201  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   202  LOCAL_INLINE void WdgM_Rb_DebugVariables_Init_v_Inl(void);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   203  #endif/*(WDGM_RB_DEBUG_OPTION_ENABLED == STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   204  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   205  #if((WDGM_DEADLINE_TIMEOUT_DETECT == STD_ON) && ((WDGM_MAX_DEADLINE_SUPERVISIONS) > (WDGM_PRV_C_ZERO)))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   206  LOCAL_INLINE void WdgM_Prv_DeadlineSupervisionMainFunction_v_Inl(void);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   207  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   208  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   209  #if ((WDGM_MAX_DEADLINE_SUPERVISIONS) > (WDGM_PRV_C_ZERO))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   210  LOCAL_INLINE void WdgM_Prv_DeadlineSupervisionCheckpointReached_v_Inl(VAR(WdgM_SupervisedEntityIdType,AUTOMATIC) SEID,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   211  VAR(WdgM_CheckpointIdType,AUTOMATIC) CheckpointID, P2VAR(Std_ReturnType,AUTOMATIC,WDGM_APPL_DATA)ReturnStatus);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   212  LOCAL_INLINE void WdgM_Prv_UpdateDeadlineSupervisionDyn_v_Inl(VAR(WdgM_ModeType,AUTOMATIC) Mode);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   213  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   214  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   215  #if (WDGM_INTERNAL_GRAPH_CONFIGURED == STD_ON)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   216  LOCAL_INLINE Std_ReturnType WdgM_Prv_LogicalSupervisionCheckpointReached_v_Inl(VAR(WdgM_SupervisedEntityIdType,AUTOMATIC) SEID,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   217  VAR(WdgM_CheckpointIdType,AUTOMATIC) CheckpointID);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   218  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   219  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   220   ************************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   221   * Inline Function Definitions
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   222   ************************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   223   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   224  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   225  /************************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   226   * Name              :   WdgM_Rb_DebugVariables_Init_v_Inl
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   227   * Description       :   Initialises the debug Variables
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   228   * Parameters[in]    :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   229   * Limitations       :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   230   * Return Value      :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   231   ************************************************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   232  LOCAL_INLINE void WdgM_Rb_DebugVariables_Init_v_Inl(void)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   233  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   234      WdgM_Rb_FirstExpiredEntityInfo_st.FirstElapsedCounterValue          = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   235      WdgM_Rb_FirstExpiredEntityInfo_st.FirstExpiredCheckpointId_t        = WDGM_RB_MAX_CHECKPOINTID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   236      WdgM_Rb_FirstExpiredEntityInfo_st.FirstExpiredAdditionalCheckpointId= WDGM_RB_MAX_CHECKPOINTID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   237      WdgM_Rb_FirstExpiredEntityInfo_st.FirstExpiredSupervisedEntityId_t  = WDGM_RB_MAX_SUPERVISEDENTITYID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   238      WdgM_Rb_FirstExpiredEntityInfo_st.FirstExpiredLocation_t            = WDGM_RB_DEFAULT_EXPIREDLOCATION;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   239      WdgM_Rb_FirstExpiredEntityInfo_st.FirstExpiredModeId                = WDGM_RB_MAX_MODEID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   240  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   241        WdgM_Rb_FirstExpiredEntity_Cnt_u8 = WDGM_PRV_C_ONE;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   242  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   243  #endif/*(WDGM_RB_DEBUG_OPTION_ENABLED == STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   244  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   245  /************************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   246   * Name              :   WdgM_Prv_AliveSupervisionMainFunction_v_Inl
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   247   * Description       :   Update the Alive Supervision in WdgM_MainFunction
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   248   * Parameters[in]    :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   249   * Limitations       :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   250   * Return Value      :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   251   ************************************************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   252  LOCAL_INLINE void WdgM_Prv_AliveSupervisionMainFunction_v_Inl(void)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   253  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   254      VAR(WdgM_SupervisedEntityIdType, AUTOMATIC) SEID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   255      VAR(uint16, AUTOMATIC) AliveSupervisionIdx;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   256      P2CONST(WdgM_AliveSupervisionType, AUTOMATIC, WDGM_APPL_CONST) AliveSupervisionPtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   257      VAR(uint32,AUTOMATIC) IndividualAliveUpdateCtrCache = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   258      AliveSupervisionPtr = WdgM_ConfigSetPtr->PtrToMode[WdgM_Mode].PtrToAliveSupervision;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   259  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   260      for(AliveSupervisionIdx= WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   261      AliveSupervisionIdx < WdgM_ConfigSetPtr->PtrToMode[WdgM_Mode].NoOfAliveSupervision;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   262      AliveSupervisionIdx++)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   263      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   264          SEID = AliveSupervisionPtr[AliveSupervisionIdx].SupervisedEntityId;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   265          /* TRACE[WDGM208] If SE was in local state deactivated then leave those SE
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   266           * in that state and start processing of supervision for other SE's  */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   267          /* TRACE[WDGM083] Check for Alive Supervison config, If NO then do not
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   268           * perform Alive counter examination*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   269          if(((WdgM_SupervisedEntityDyn[SEID].NewLocalStatus & WDGM_LOCAL_STATUS_DEACTIVATED)!= WDGM_LOCAL_STATUS_DEACTIVATED)&&
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   270                  (WdgM_AliveSupervisionActive == TRUE))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   271          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   272              WdgM_SupervisedEntityDyn[SEID].IndividualSupervisionCycleCtr++;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   273              /*TRACE[WDGM098] Perform checking only at the configured Supervision Reference Cycle*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   274              if (WdgM_SupervisedEntityDyn[SEID].IndividualSupervisionCycleCtr ==
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   275                      AliveSupervisionPtr[AliveSupervisionIdx].SupervisionReferenceCycle)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   276              {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   277                  /*Interrupt lock to cache IndividualAliveUpdateCtr for calculation. Reset alive Counter here*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   278                  /*Interrupt Lock:
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   279                   * 1. Cache and set to 0 should be an atomic operation so as to capture new CP.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   280                   * If no Lock then after caching we can get CPR and the counter is incremented coming back to mainFunction
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   281                   * we will set the IndividualAliveUpdateCtr to 0. Hence One count will be lost.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   282                   * */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   283  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   284                  SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   285  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   286                  IndividualAliveUpdateCtrCache = WdgM_SupervisedEntityDyn[SEID].IndividualAliveUpdateCtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   287                  WdgM_SupervisedEntityDyn[SEID].IndividualAliveUpdateCtr = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   288  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   289                  SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   290  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   291                  /*[WDGM074] Check if AliveCounter is within limit*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   292                  /*Check for if Alive counter is within the range hence "correct" state*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   293                  if (((IndividualAliveUpdateCtrCache )>=
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   294                  ((uint32)AliveSupervisionPtr[AliveSupervisionIdx].ExpectedAliveIndications - (uint32)AliveSupervisionPtr[AliveSupervisionIdx].MinMargin))&&
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   295                  ((IndividualAliveUpdateCtrCache) <=
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   296                  ((uint32)AliveSupervisionPtr[AliveSupervisionIdx].ExpectedAliveIndications + (uint32)AliveSupervisionPtr[AliveSupervisionIdx].MaxMargin)))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   297                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   298                      /* TRACE[WDGM300] If SE is in LS status FAILED and results of
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   299                       * AS are correct  and the counter for failed supervision reference cycle is >1 */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   300                      if(WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr > WDGM_PRV_C_ONE)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   301                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   302                          /*Lock Enabled: Lock required because when preempted by CRP then the newly modified value will be replaced by MainFunction here*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   303  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   304                          SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   305  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   306                          WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus | WDGM_LOCAL_STATUS_FAILED;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   307  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   308                          SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   309  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   310                          WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr--;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   311                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   312                      /* TRACE[WDGM205] If SE is in LS status FAILED and results of AS
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   313                       * are correct and the counter for failed supervision
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   314                       * reference cycle is equal 1 */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   315                      else if(WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr == WDGM_PRV_C_ONE)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   316                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   317                          /*Lock Enabled: Lock required because when preempted by CRP then the newly modified value will be replaced by MainFunction here*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   318  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   319                          SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   320  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   321                          WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus & ((WdgM_LocalStatusType)(~WDGM_LOCAL_STATUS_FAILED));
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   322  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   323                          SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   324  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   325                          WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   326                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   327                      else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   328                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   329                          /*Lock Enabled: Lock required because when preempted by CRP then the newly modified value will be replaced by MainFunction here*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   330  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   331                          SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   332  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   333                          WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus & ((WdgM_LocalStatusType)(~WDGM_LOCAL_STATUS_FAILED));
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   334  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   335                          SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   336  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   337                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   338                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   339                  /*[WDGM115] If alive indiaction not within tolerance the incorrect*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   340                  /*Else since Alive counter is  not within the range hence "incorrect" state*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   341                  else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   342                  {   /* TRACE[WDGM202] If SE was in LS status OK and results of
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   343                       * atleast one AS is incorrect and the fault tolerence == 0*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   344                      /* TRACE[WDGM203] If SE was in LS status OK and results of
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   345                       * atleast one AS is incorrect and the failure fault tolerence > 0*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   346                      /* TRACE[WDGM204] If SE was in LS status FAILURE and results of
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   347                      * atleast one AS is incorrect and the failure supervision refrence cycle < tolerence*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   348                      /*Lock Enabled: Lock required because when preempted by CRP then the newly modified value will be replaced by MainFunction here*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   349  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   350                      SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   351  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   352                      WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus | WDGM_LOCAL_STATUS_FAILED;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   353  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   354                      SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   355  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   356                      WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr++;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   357                      /* TRACE[WDGM206] If SE was in LS status FAILED and results of
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   358                       * atleast one AS is incorrect and the counter for failed supervision reference cycle > Ref Cycle*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   359                      if (WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr > WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleTol)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   360                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   361                          /*Lock Enabled: Lock required because when preempted by CRP then the newly modified value will be replaced by MainFunction here*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   362  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   363                          SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   364  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   365                          WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus | WDGM_LOCAL_STATUS_EXPIRED;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   366  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   367                          SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   368  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   369  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   370                          WdgM_Rb_FirstExpiredEntity(WDGM_PRV_C_ZERO, (uint16)AliveSupervisionPtr[AliveSupervisionIdx].AliveSupervisionCheckpointId,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   371                                                     WDGM_RB_MAX_CHECKPOINTID, SEID, WDGM_RB_FAILED_IN_ALIVE_MAINFUNCTION, WdgM_Mode);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   372  #endif/*(WDGM_RB_DEBUG_OPTION_ENABLED == STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   373                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   374                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   375                  WdgM_SupervisedEntityDyn[SEID].IndividualSupervisionCycleCtr = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   376              }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   377          }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   378          else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   379          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   380              /* This is required to do the syncronization of different Alive Supervisions after Mode change happens
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   381                 When mode change occurs the counters have to be reset to 0 */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   382  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   383              /*Lock Placed:
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   384                Any modification operation(Eg:incrementing the counter value) on WdgM_SupervisedEntityDyn[SEID].IndividualAliveUpdateCtr
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   385                variable is done in atomic in other places[WdgM_CheckpointReached()]. So here also modification(setting to 0) should be done in atomic.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   386                So that modification operation is not preempted by each other
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   387              */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   388  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   389  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   390              SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   391  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   392  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   393              WdgM_SupervisedEntityDyn[SEID].IndividualAliveUpdateCtr = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   394  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   395  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   396              SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   397  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   398  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   399              /*Clear IndividualSupervisionCycleCtr and FailedAliveSupervisionRefCycleCtr When Mode change happens  */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   400              WdgM_SupervisedEntityDyn[SEID].IndividualSupervisionCycleCtr = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   401              WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   402  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   403          }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   404      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   405  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   406      if(WdgM_AliveSupervisionActive == FALSE)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   407      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   408          WdgM_AliveSupervisionActive = TRUE;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   409      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   410  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   411  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   412  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   413  #if((WDGM_DEADLINE_TIMEOUT_DETECT == STD_ON) && ((WDGM_MAX_DEADLINE_SUPERVISIONS) > (WDGM_PRV_C_ZERO)))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   414  /************************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   415   * Name              :   WdgM_Prv_DeadlineSupervisionMainFunction_v_Inl
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   416   * Description       :   Update the Deadline Supervision in WdgM_MainFunction for the checkpoints for which Start checkpoint
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   417   *                       has been reached but the stop checkpoint has not been reached and it has expired.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   418   *                       New RFC request in AutoSAR bugzilla Id : 56735
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   419   * Parameters[in]    :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   420   * Limitations       :   This update will be done only for Timers accessible from WdgM_MainFunction calling TASK context....!!
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   421   * Return Value      :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   422   ************************************************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   423  LOCAL_INLINE void WdgM_Prv_DeadlineSupervisionMainFunction_v_Inl(void)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   424  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   425      VAR(WdgM_SupervisedEntityIdType, AUTOMATIC) SEID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   426      VAR(uint16, AUTOMATIC)  DeadlineIdx;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   427      VAR(TickType, AUTOMATIC) RunningCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   428      VAR(TickType, AUTOMATIC) ElapsedCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   429      P2CONST(WdgM_DeadlineSupervisionType, AUTOMATIC, WDGM_APPL_CONST) DeadlineSupervisionPtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   430      VAR(StatusType, AUTOMATIC)  returnStatus = E_NOT_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   431      DeadlineSupervisionPtr = WdgM_ConfigSetPtr->PtrToMode[WdgM_Mode].PtrToDeadlineSupervision;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   432  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   433  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   434      for(DeadlineIdx = WDGM_PRV_C_ZERO; DeadlineIdx < WdgM_ConfigSetPtr->PtrToMode[WdgM_Mode].NoOfDeadlineSupervision; DeadlineIdx++)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   435      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   436          RunningCounterValueTemp = WdgM_ConfigSetPtr->PtrToRunningCounterValue[DeadlineIdx];
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   437  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   438          /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   439           * No need to do the evaluation to update or not to update NewLocalStatus if Deadline supervision is not
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   440           * running or Deadline supervision is running but Stop checkpoint has already reached.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   441           */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   442          if(RunningCounterValueTemp != ((TickType)WDGM_PRV_C_ZERO))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   443          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   444              SEID = DeadlineSupervisionPtr[DeadlineIdx].SupervisedEntityId;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   445  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   446   * If the WdgM_Prv_DeadlineSupervisionMainFunction_v_Inl is not called under lock in WdgM_MainFunction
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   447   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   448  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   449                  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   450                   * Set variable ElapsedCounterValueTemp as 0(WDGM_PRV_C_ZERO), so that NewLocalStatus will not be updated
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   451                   * if RunningCounterValueTemp is 0.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   452                   * RunningCounterValueTemp is 0 mean either Deadline supervision is not running or Deadline supervision
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   453                   * is running but Stop checkpoint has already reached.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   454                   *
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   455                   * Info: ElapsedCounterValueTemp will also have non zero value only when RunningCounterValueTemp will have
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   456                   * no zero value, otherwise ElapsedCounterValueTemp will have value 0 .
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   457                   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   458                  ElapsedCounterValueTemp = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   459  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   460                  /* Lock Placed:
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   461                   * Reading of captured running counter value and then calculation of elapsed counter value w.r.t current running
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   462                   * counter value should not be pre-empted by other task(WdgM_CheckpointReached). So these operations are done under lock.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   463                   * For more information refer Errata 4077.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   464                   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   465                  SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   466  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   467                  /* Read once again Running Counter to have latest value for comparison.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   468                   * This is required if function WdgM_Prv_DeadlineSupervisionMainFunction_v_Inl is
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   469                   * not called under lock.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   470                   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   471                  RunningCounterValueTemp = WdgM_ConfigSetPtr->PtrToRunningCounterValue[DeadlineIdx];
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   472  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   473                  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   474                   * Get the Elapsed counter value if Start checkpoint is reached but End checkpoint is not yet reached
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   475                   * (that is, when Deadline Supervision is running)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   476                  */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   477                  if(RunningCounterValueTemp != ((TickType)WDGM_PRV_C_ZERO))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   478                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   479  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   480  #if((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_OS))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   481                      returnStatus = GetElapsedCounterValue(WdgM_SupervisedEntity[SEID].TimerId, &RunningCounterValueTemp, &ElapsedCounterValueTemp);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   482  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   483  #if((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_MCU))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   484                      ElapsedCounterValueTemp = RunningCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   485                      RunningCounterValueTemp = (TickType)Mcu_Rb_GetSysTicks();
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   486                      ElapsedCounterValueTemp = RunningCounterValueTemp - ElapsedCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   487                      returnStatus = E_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   488  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   489                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   490                  else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   491                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   492                      returnStatus = E_NOT_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   493                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   494  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   495                  SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   496  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   497   * If the WdgM_Prv_DeadlineSupervisionMainFunction_v_Inl is called under lock in WdgM_MainFunction
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   498   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   499  #else /*(WDGM_LOCK_DISABLE_FOR_DGS) == (STD_OFF) */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   500  #if((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_OS))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   501                  returnStatus = GetElapsedCounterValue(WdgM_SupervisedEntity[SEID].TimerId, &RunningCounterValueTemp, &ElapsedCounterValueTemp);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   502  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   503  #if((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_MCU))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   504                  ElapsedCounterValueTemp = RunningCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   505                  RunningCounterValueTemp = (TickType)Mcu_Rb_GetSysTicks();
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   506                  ElapsedCounterValueTemp = RunningCounterValueTemp - ElapsedCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   507                  returnStatus = E_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   508  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   509  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   510  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   511  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   512                  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   513                   * 1. Update the NewLocalStatus value as expired if
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   514                   * Elapsed Counter value is obtained successfully and
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   515                   * Elapsed Counter value is greater than Deadline max time
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   516                   *
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   517                   * 2. NewLocalStatus will not get updated if either Deadline supervision is not running or Deadline supervision
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   518                   * is running but Stop checkpoint has already reached
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   519                   * (In case WDGM_LOCK_DISABLE_FOR_DGS is STD_ON, ElapsedCounterValueTemp will be 0. Thereby taken care)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   520                   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   521  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   522                  if((returnStatus == E_OK) && (ElapsedCounterValueTemp > DeadlineSupervisionPtr[DeadlineIdx].DeadlineMax))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   523                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   524                      /*Lock Not required since CPR will at worst modify local to EXPIRED which is done here anyway*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   525                      WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus | WDGM_LOCAL_STATUS_EXPIRED;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   526  # if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   527                      WdgM_Rb_FirstExpiredEntity(ElapsedCounterValueTemp, DeadlineSupervisionPtr[DeadlineIdx].StartCheckpointId,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   528                                                 DeadlineSupervisionPtr[DeadlineIdx].StopCheckpointId, SEID, WDGM_RB_FAILED_IN_DEADLINE_MAINFUNCTION, WdgM_Mode);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   529  # endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   530                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   531          }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   532      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   533  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   534  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   535  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   536  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   537  #if ((WDGM_MAX_DEADLINE_SUPERVISIONS) > (WDGM_PRV_C_ZERO))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   538  /*******************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   539  * Name              :   WdgM_Prv_DeadlineSupervisionCheckpointReached_v_Inl
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   540  * Description       :   Does the Deadline Monitoring part of WdgM_CheckpointReached().
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   541  * Parameters[in]    :   SEID, CheckpointID
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   542  * Parameters[inout] :   ReturnStatus
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   543  * Limitations       :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   544  * ReturnType        :   Std_ReturnType
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   545  *******************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   546  LOCAL_INLINE void WdgM_Prv_DeadlineSupervisionCheckpointReached_v_Inl(VAR(WdgM_SupervisedEntityIdType,AUTOMATIC) SEID,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   547  VAR(WdgM_CheckpointIdType,AUTOMATIC) CheckpointID, P2VAR(Std_ReturnType,AUTOMATIC,WDGM_APPL_DATA)ReturnStatus)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   548  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   549      VAR(uint16,AUTOMATIC) SvIdx;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   550      VAR(uint16,AUTOMATIC) DeadlineIdx;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   551      VAR(TickType,AUTOMATIC) RunningCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   552      VAR(TickType,AUTOMATIC) ElapsedCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   553      P2CONST(WdgM_DeadlineSupervisionType, AUTOMATIC, WDGM_APPL_CONST)DeadlineSupervisionPtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   554      P2VAR(uint16, AUTOMATIC, WDGM_APPL_DATA)DeadlineIdxPtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   555  #if((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_OS))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   556  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   557      VAR(boolean, AUTOMATIC) Report_E_OsCounter_Det;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   558      Report_E_OsCounter_Det = FALSE;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   559  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   560  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   561  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   562      *ReturnStatus = E_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   563  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   564      /* TRACE[WDGM322] Perform Deadline supervision*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   565  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   566      SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   567      if ((WdgM_SupervisedEntityDyn[SEID].NewLocalStatus & WDGM_LOCAL_STATUS_DEACTIVATED) != WDGM_LOCAL_STATUS_DEACTIVATED)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   568      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   569          DeadlineIdxPtr = WdgM_SupervisedEntity[SEID].PtrToCheckpoint[CheckpointID].PtrToCheckpointDyn->PtrToDeadlineIndices;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   570          DeadlineSupervisionPtr = WdgM_ConfigSetPtr->PtrToMode[WdgM_Mode].PtrToDeadlineSupervision;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   571          /* TRACE[WDGM299] Perform check if deadline active or inactive */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   572          for(SvIdx = WDGM_PRV_C_ZERO;  SvIdx < WdgM_SupervisedEntity[SEID].PtrToCheckpoint[CheckpointID].PtrToCheckpointDyn->NoOfDeadlineSupervision; SvIdx++)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   573          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   574              DeadlineIdx = DeadlineIdxPtr[SvIdx];
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   575              RunningCounterValueTemp = WdgM_ConfigSetPtr->PtrToRunningCounterValue[DeadlineIdx];
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   576  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   577              if ((CheckpointID == DeadlineSupervisionPtr[DeadlineIdx].StopCheckpointId)&&
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   578                          (RunningCounterValueTemp != ((TickType)WDGM_PRV_C_ZERO)))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   579              {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   580  #if((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_OS))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   581                  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   582                   * Evaluation should be done only if return value of GetElapsedCounterValue is E_OK.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   583                   * Running counter value (timestamp) should be cleared if return value of GetElapsedCounterValue
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   584                   * is other than E_OK. And report error to DET if DET is enabled
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   585                   * TRACE[BSW_SWS_AR4_0_R2_WatchDogManager_Ext-2820]
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   586                   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   587                  if(E_OK == (GetElapsedCounterValue(WdgM_SupervisedEntity[SEID].TimerId, &RunningCounterValueTemp, &ElapsedCounterValueTemp)))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   588                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   589                      /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   590                       * TRACE[BSW_SWS_AR4_0_R2_WatchDogManager_Ext-2819]
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   591                       */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   592                      /* TRACE[WDGM229] Perform checking when deadline endpoint reached*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   593                      if ((ElapsedCounterValueTemp >= DeadlineSupervisionPtr[DeadlineIdx].DeadlineMin) &&
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   594                              (ElapsedCounterValueTemp <= DeadlineSupervisionPtr[DeadlineIdx].DeadlineMax))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   595                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   596                          /* Update of Local supervision status (WdgM_SupervisedEntityDyn[SEID].NewLocalStatus) not needed */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   597                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   598                      /*TRACE [WDGM294] Since the time diffrence is not within range the deadline result is
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   599                       * incorrect */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   600                      else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   601                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   602                          WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus | WDGM_LOCAL_STATUS_EXPIRED;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   603  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   604                          WdgM_Rb_FirstExpiredEntity(ElapsedCounterValueTemp, DeadlineSupervisionPtr[DeadlineIdx].StartCheckpointId,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   605                                                     DeadlineSupervisionPtr[DeadlineIdx].StopCheckpointId, SEID, WDGM_RB_FAILED_IN_DEADLINE_CHECKPOINTREACHED, WdgM_Mode);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   606  #endif /*(WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   607                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   608                      /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   609                       * Clear the RunningCounterValueTemp if start and stop checkpoints are not same
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   610                       * If start and stop checkpoints are same then no need to clear the RunningCounterValueTemp
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   611                       */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   612                      if(DeadlineSupervisionPtr[DeadlineIdx].StopCheckpointId != DeadlineSupervisionPtr[DeadlineIdx].StartCheckpointId)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   613                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   614                          RunningCounterValueTemp = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   615                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   616                      else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   617                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   618                          /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   619                           * This is to avoid not to detect already started Deadline Supervision exactly at 0.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   620                           * Anyway the resolution of RunningCounterValueTemp (of type TickType) is very high, impact of addition of 1, w.r.t Seconds
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   621                           * is very less.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   622                           */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   623                          if(RunningCounterValueTemp == ((TickType)WDGM_PRV_C_ZERO))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   624                          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   625  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   626                              RunningCounterValueTemp = (TickType)WDGM_PRV_C_ONE;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   627                          }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   628                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   629                      WdgM_ConfigSetPtr->PtrToRunningCounterValue[DeadlineIdx] = RunningCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   630                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   631                  else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   632                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   633                      /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   634                       * TRACE[BSW_SWS_AR4_0_R2_WatchDogManager_Ext-2860]
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   635                       */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   636  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   637                      Report_E_OsCounter_Det = TRUE;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   638  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   639                      WdgM_ConfigSetPtr->PtrToRunningCounterValue[DeadlineIdx] = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   640                      *ReturnStatus = E_NOT_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   641                   }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   642  #endif /*((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_OS)) */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   643  #if((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_MCU))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   644                  ElapsedCounterValueTemp = RunningCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   645                  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   646                   * TRACE[BSW_SWS_AR4_0_R2_WatchDogManager_Ext-2821]
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   647                   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   648                  RunningCounterValueTemp = (TickType)Mcu_Rb_GetSysTicks();
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   649                  ElapsedCounterValueTemp = RunningCounterValueTemp - ElapsedCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   650                  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   651                   * TRACE[BSW_SWS_AR4_0_R2_WatchDogManager_Ext-2861]
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   652                   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   653                  /* TRACE[WDGM229] Perform checking when deadline endpoint reached*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   654                  if ((ElapsedCounterValueTemp >= DeadlineSupervisionPtr[DeadlineIdx].DeadlineMin) &&
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   655                          (ElapsedCounterValueTemp <= DeadlineSupervisionPtr[DeadlineIdx].DeadlineMax))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   656                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   657                      /* Update of Local supervision status (WdgM_SupervisedEntityDyn[SEID].NewLocalStatus) not needed */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   658                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   659                  /*TRACE [WDGM294] Since the time diffrence is not within range the deadline result is
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   660                   * incorrect */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   661                  else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   662                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   663                      WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus | WDGM_LOCAL_STATUS_EXPIRED;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   664  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   665                      WdgM_Rb_FirstExpiredEntity(ElapsedCounterValueTemp, DeadlineSupervisionPtr[DeadlineIdx].StartCheckpointId,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   666                                                 DeadlineSupervisionPtr[DeadlineIdx].StopCheckpointId, SEID, WDGM_RB_FAILED_IN_DEADLINE_CHECKPOINTREACHED, WdgM_Mode);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   667  #endif /*(WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   668                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   669                  if(DeadlineSupervisionPtr[DeadlineIdx].StopCheckpointId != DeadlineSupervisionPtr[DeadlineIdx].StartCheckpointId)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   670                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   671                      WdgM_ConfigSetPtr->PtrToRunningCounterValue[DeadlineIdx] = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   672                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   673                  else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   674                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   675                      if(RunningCounterValueTemp == ((TickType)WDGM_PRV_C_ZERO))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   676                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   677                          /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   678                           * This is to avoid not to detect already started Deadline Supervision exactly at 0.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   679                           * Anyway the resolution of RunningCounterValueTemp (of type TickType) is very high, impact of addition of 1, w.r.t Seconds
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   680                           * is very less.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   681                           */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   682                          RunningCounterValueTemp = (TickType)WDGM_PRV_C_ONE;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   683                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   684                      /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   685                       * This is for the special case to detect Start of Deadline Supervision, where for cyclic
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   686                       * Task Deadline Start and destination Checkpoints are configured same.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   687                       */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   688                      WdgM_ConfigSetPtr->PtrToRunningCounterValue[DeadlineIdx] = RunningCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   689                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   690  #endif /* ((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_MCU)) */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   691              }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   692              else if (CheckpointID == DeadlineSupervisionPtr[DeadlineIdx].StartCheckpointId)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   693              {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   694                  /* Reference: OS384 */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   695                  /* TRACE[WDGM228] Record the time stamp if deadline started*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   696                  /* Note : SWS_WdgM_00228 means that it is not considered as an error by Deadline Supervision if
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   697                   * a given Deadline Start Checkpoint is reached several times without reaching the corresponding
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   698                   * Deadline End Checkpoint (each time the timestamp is just updated)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   699  #if((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_OS))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   700                  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   701                   * Running counter value should be captured/stored only if GetElapsedCounterValue returns E_OK.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   702                   * If the return value is other than E_OK then set *ReturnStatus as E_NOT_OK. If DET is enabled
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   703                   * then report error to DET.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   704                   *TRACE[BSW_SWS_AR4_0_R2_WatchDogManager_Ext-2820]
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   705                   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   706                  if(E_OK == (GetElapsedCounterValue(WdgM_SupervisedEntity[SEID].TimerId, &RunningCounterValueTemp, &ElapsedCounterValueTemp)))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   707                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   708                      if(RunningCounterValueTemp == ((TickType)WDGM_PRV_C_ZERO))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   709                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   710                          /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   711                           * This is to avoid not to detect already started Deadline Supervision exactly at 0.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   712                           * Anyway the resolution of RunningCounterValueTemp (of type TickType) is very high,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   713                           * impact of addition of 1, w.r.t Seconds is very less.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   714                           */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   715                          RunningCounterValueTemp = (TickType)WDGM_PRV_C_ONE;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   716                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   717                      /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   718                       * TRACE[BSW_SWS_AR4_0_R2_WatchDogManager_Ext-2818]
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   719                       */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   720                      WdgM_ConfigSetPtr->PtrToRunningCounterValue[DeadlineIdx] = RunningCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   721                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   722                  else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   723                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   724                      /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   725                       * Running Counter will not be modified. It will remain as 0
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   726                       * TRACE[BSW_SWS_AR4_0_R2_WatchDogManager_Ext-2858]
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   727                       */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   728  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   729                      Report_E_OsCounter_Det = TRUE;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   730  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   731                      WdgM_ConfigSetPtr->PtrToRunningCounterValue[DeadlineIdx] = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   732                      *ReturnStatus = E_NOT_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   733                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   734  #endif /* ((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_OS)) */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   735  #if((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_MCU))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   736                  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   737                   * TRACE[BSW_SWS_AR4_0_R2_WatchDogManager_Ext-2821]
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   738                   * TRACE[BSW_SWS_AR4_0_R2_WatchDogManager_Ext-2859]
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   739                   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   740                  RunningCounterValueTemp = (TickType)Mcu_Rb_GetSysTicks();
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   741                  if(RunningCounterValueTemp == ((TickType)WDGM_PRV_C_ZERO))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   742                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   743                      /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   744                       * This is to avoid not to detect already started Deadline Supervision exactly at 0.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   745                       * Anyway the resolution of RunningCounterValueTemp (of type TickType) is very high, impact of
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   746                       * addition of 1, w.r.t Seconds is very less.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   747                       */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   748                      RunningCounterValueTemp = (TickType)WDGM_PRV_C_ONE;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   749                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   750                  WdgM_ConfigSetPtr->PtrToRunningCounterValue[DeadlineIdx] = RunningCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   751  #endif /* ((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_MCU)) */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   752              }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   753              else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   754              {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   755                  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   756                   * ReturnStatus should be ok for following condition
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   757                   * TRACE[SWS_WdgM_00354]Do not consider it as error when End Check point reached before Start check point or
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   758                   * when Deadline End Checkpoint is reached several times in a sequence.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   759                   * Running counter value == 0 & check point == stop
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   760                   * ReturnStatus = E_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   761                   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   762              }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   763          }/* End of for loop */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   764          SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   765  #if((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_OS))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   766  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   767          /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   768          * TRACE[BSW_SWS_AR4_0_R2_WatchDogManager_Ext-2862]
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   769          */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   770          if(Report_E_OsCounter_Det == TRUE)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   771          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   772              /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored, and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   773              (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_CHECKPOINT_REACHED_APIID, WDGM_E_OS_COUNTER);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   774          }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   775  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   776  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   777      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   778      else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   779      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   780          SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   781  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   782          /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored, and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   783          (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_CHECKPOINT_REACHED_APIID, WDGM_E_SEDEACTIVATED);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   784          *ReturnStatus = E_NOT_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   785  #endif /* ((WDGM_DEV_ERROR_DETECT) == (STD_ON)) */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   786      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   787  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   788  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   789  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   790  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   791  #if (WDGM_INTERNAL_GRAPH_CONFIGURED == STD_ON)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   792  /*******************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   793  * Name              :   WdgM_Prv_LogicalSupervisionCheckpointReached_v_Inl
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   794  * Description       :   Does the Internal Graph Logical Monitoring part of WdgM_CheckpointReached().
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   795  * Parameters[in]    :   SEID, CheckpointID
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   796  * Parameters[inout] :   ReturnStatus
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   797  * Limitations       :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   798  * ReturnType        :   Std_ReturnType
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   799  *******************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   800  LOCAL_INLINE Std_ReturnType WdgM_Prv_LogicalSupervisionCheckpointReached_v_Inl(VAR(WdgM_SupervisedEntityIdType,AUTOMATIC) SEID,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   801  VAR(WdgM_CheckpointIdType,AUTOMATIC) CheckpointID)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   802  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   803      VAR(uint16,AUTOMATIC) cntrDestCPs;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   804      VAR(uint16,AUTOMATIC) idxStartDestCPs;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   805      VAR(uint16,AUTOMATIC) idxCPProperty_givenCP;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   806      VAR(WdgM_PositionInGraph_ten,AUTOMATIC) posnInGraph_en;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   807      VAR(uint16,AUTOMATIC)  nrDestCheckpoints;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   808      VAR(Std_ReturnType,AUTOMATIC)  ReturnStatus;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   809  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   810      VAR(uint8,AUTOMATIC) ExpiredLocation;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   811      VAR(WdgM_CheckpointIdType,AUTOMATIC)  idLastReachedCheckpoint;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   812      VAR(WdgM_ModeType,AUTOMATIC)  Mode;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   813  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   814      ExpiredLocation = WDGM_RB_DEFAULT_EXPIREDLOCATION;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   815      idLastReachedCheckpoint = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   816      Mode = WDGM_RB_MAX_MODEID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   817  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   818      ReturnStatus = E_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   819  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   820      if(WdgM_SupervisedEntity[SEID].hasInternalGraph == TRUE)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   821      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   822          idxCPProperty_givenCP = WdgM_SupervisedEntity[SEID].idxInternalGraphCPProperty + CheckpointID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   823          posnInGraph_en = WdgM_InternalGraph_CPProperty[idxCPProperty_givenCP].posnInGraph_en;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   824          /*When reported CPID which do not belong to the current Internal graph no action should be taken hence this check is done
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   825           *TRACE[SWS_WdgM_00297]For any reported Checkpoint that does not belong to any Graph, then it
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   826           * shall be ignore and not update the result of the Logical Supervision for the Supervised Entity.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   827          if(posnInGraph_en != WDGM_POSNGRAPH_NONE_E)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   828          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   829  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   830              /* Lock introduced:
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   831               * 1.In WdgM_SupervisedEntityDyn we check for Local status deactivated,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   832               * if mode changes here and the reported Supervised entity becomes deactivated in the new mode then,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   833               * the reported checkpoint shall not be processed.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   834              /*TRACE[SWS_WdgM_00208] Since SEActive is False for DEACTIVATED, no supervision process is performed*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   835              SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   836              if ((WdgM_SupervisedEntityDyn[SEID].NewLocalStatus & WDGM_LOCAL_STATUS_DEACTIVATED) != WDGM_LOCAL_STATUS_DEACTIVATED)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   837              {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   838  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   839                  /* TRACE[SWS_WdgM_00332 and SWS_WdgM_00273] If the function WdgM_CheckpointReached the result correct, and
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   840                   * the Checkpoint is defined as a initial one, then the function WdgM_CheckpointReached shall set the
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   841                   * Activity Flag of the corresponding graph to true.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   842                  if(WdgM_SupervisedEntityDyn[SEID].flgActivity == FALSE)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   843                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   844                      if(posnInGraph_en == WDGM_POSNGRAPH_INITIAL_E)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   845                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   846                          WdgM_SupervisedEntityDyn[SEID].idLastReachedCheckpoint = CheckpointID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   847                          WdgM_SupervisedEntityDyn[SEID].flgActivity = TRUE;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   848                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   849                      /*Update the NewLocalStatus value as expired if
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   850                       * Reported Checkpoint is not an Initial Checkpoint and
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   851                       * Internal Graph is not active*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   852                      else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   853                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   854                          WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus | WDGM_LOCAL_STATUS_EXPIRED;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   855                          #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   856                              ExpiredLocation = WDGM_RB_FAILED_IN_LOGICAL_INTGRAPH_CPREACHED_GRAPHNOTSTARTED;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   857                              idLastReachedCheckpoint = WdgM_SupervisedEntityDyn[SEID].idLastReachedCheckpoint;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   858                              Mode = WdgM_Mode;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   859                          #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   860                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   861                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   862  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   863                  else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   864                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   865                      /* TRACE[SWS_WdgM_00246 and SWS_WdgM_00274] Iterate through all the transition
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   866                       * to find Reported checkpoint has valid transition
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   867                       * (i.e. Is it Successor of perviously reported Checkpoint) */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   868                      idxCPProperty_givenCP = WdgM_SupervisedEntity[SEID].idxInternalGraphCPProperty + WdgM_SupervisedEntityDyn[SEID].idLastReachedCheckpoint;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   869                      idxStartDestCPs = WdgM_InternalGraph_CPProperty[idxCPProperty_givenCP].idxDestCheckpoints;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   870                      nrDestCheckpoints = WdgM_InternalGraph_CPProperty[idxCPProperty_givenCP].nrDestCheckpoints;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   871                      for(cntrDestCPs=0;cntrDestCPs<nrDestCheckpoints;cntrDestCPs++)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   872                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   873                          if(WdgM_InternalGraph_DestCheckpoints[idxStartDestCPs + cntrDestCPs] == CheckpointID)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   874                          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   875                              WdgM_SupervisedEntityDyn[SEID].idLastReachedCheckpoint = CheckpointID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   876                              break;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   877                          }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   878                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   879                      /*Update the NewLocalStatus value as expired if
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   880                      * Reported Checkpoint has no valid transition and Internal Graph is active*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   881                      if(cntrDestCPs == nrDestCheckpoints)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   882                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   883                          WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus | WDGM_LOCAL_STATUS_EXPIRED;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   884                          #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   885                              ExpiredLocation = WDGM_RB_FAILED_IN_LOGICAL_INTGRAPH_CPREACHED_GRAPHSTARTED;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   886                              idLastReachedCheckpoint = WdgM_SupervisedEntityDyn[SEID].idLastReachedCheckpoint;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   887                              Mode = WdgM_Mode;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   888                          #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   889                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   890                      /* TRACE[SWS_WdgM_00331 and SWS_WdgM_00274] When the reported checkpoint is a final
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   891                       * checkpoint then deactivate corresponding Internal graph
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   892                       * (i.e. by setting SEID Activity Flag to false), hence this check is done.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   893                      else if (posnInGraph_en == WDGM_POSNGRAPH_FINAL_E)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   894                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   895                          WdgM_SupervisedEntityDyn[SEID].flgActivity = FALSE;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   896                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   897                      else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   898                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   899                          /*TRACE[SWS_WdgM_00274]If the reported Checkpoint is a successor of the stored Checkpoint within
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   900                           * the Graph, then the result of the Logical Supervision of the Supervised Entity is correct.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   901                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   902                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   903                  SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   904                  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   905                  if((ExpiredLocation == WDGM_RB_FAILED_IN_LOGICAL_INTGRAPH_CPREACHED_GRAPHNOTSTARTED) ||
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   906                          (ExpiredLocation == WDGM_RB_FAILED_IN_LOGICAL_INTGRAPH_CPREACHED_GRAPHSTARTED))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   907                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   908                      WdgM_Rb_FirstExpiredEntity(WDGM_PRV_C_ZERO, CheckpointID, idLastReachedCheckpoint,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   909                                                 SEID, ExpiredLocation, Mode);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   910                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   911                  #endif /*(WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   912              }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   913              else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   914              {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   915                  SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   916                  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   917                      /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   918                       * and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   919                      (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_CHECKPOINT_REACHED_APIID, WDGM_E_SEDEACTIVATED);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   920                      ReturnStatus = E_NOT_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   921                  #endif /* ((WDGM_DEV_ERROR_DETECT) == (STD_ON)) */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   922              }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   923          }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   924      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   925      return ReturnStatus;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   926  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   927  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   928  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   929  /************************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   930   * Name              :   WdgM_Prv_UpdateAliveSupervisionDyn_v_Inl
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   931   * Description       :   Update the AliveSupervision Variables at mode change
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   932   * Parameters[in]    :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   933   * Limitations       :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   934   * Return Value      :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   935   ************************************************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   936  LOCAL_INLINE void WdgM_Prv_UpdateAliveSupervisionDyn_v_Inl(void)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   937  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   938  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   939      /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   940       * Disable the Alive Supervision upto next WdgM_MainFunction call to synchronise the expected indication and
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   941       * the new Supervision Cycle. Other variables are not required to be reset here as anyway in WdgM_MainFunction
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   942       * it will be reinitialized at the time of start of Alive Supervision, when WdgM_AliveSupervisionActive
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   943       * becomes true.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   944       *
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   945       */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   946      WdgM_AliveSupervisionActive = FALSE;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   947  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   948  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   949  #if ((WDGM_MAX_DEADLINE_SUPERVISIONS) > (WDGM_PRV_C_ZERO))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   950  /************************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   951   * Name              :   WdgM_Prv_UpdateDeadlineSupervisionDyn_v_Inl
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   952   * Description       :   Update the Checkpoint Linking to the different Deadline Supervisions in current mode
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   953   * Parameters[in]    :   Mode
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   954   * Limitations       :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   955   * Return Value      :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   956   ************************************************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   957  LOCAL_INLINE void WdgM_Prv_UpdateDeadlineSupervisionDyn_v_Inl(VAR(WdgM_ModeType,AUTOMATIC) Mode)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   958  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   959      VAR(uint16, AUTOMATIC) OldIdx;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   960      VAR(uint16, AUTOMATIC)NewIdx;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   961      VAR(uint16, AUTOMATIC)DeadlineIdx;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   962      VAR(uint16, AUTOMATIC)Offset;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   963      VAR(uint16, AUTOMATIC)SingleCheckpointDeadlineSupervisionSize;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   964      VAR(WdgM_SupervisedEntityIdType, AUTOMATIC) SEID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   965      VAR(WdgM_CheckpointIdType, AUTOMATIC) CheckpointID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   966  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   967      VAR(TickType, AUTOMATIC)   RunningCounterValueTemp[WDGM_MAX_DEADLINE_SUPERVISIONS];
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   968      P2CONST(WdgM_DeadlineSupervisionType, AUTOMATIC, WDGM_APPL_CONST) OldDeadlineSupervisionPtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   969      P2CONST(WdgM_DeadlineSupervisionType, AUTOMATIC, WDGM_APPL_CONST) NewDeadlineSupervisionPtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   970  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   971      /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   972       * Transfer all the Running Counter values for the start checkpoints from previous Mode to
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   973       * current mode for all Deadline supervisions which were active in previous mode and are active
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   974       * in current mode also.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   975       */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   976  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   977      OldDeadlineSupervisionPtr = WdgM_ConfigSetPtr->PtrToMode[WdgM_Mode].PtrToDeadlineSupervision;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   978      NewDeadlineSupervisionPtr = WdgM_ConfigSetPtr->PtrToMode[Mode].PtrToDeadlineSupervision;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   979  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   980      for(OldIdx = WDGM_PRV_C_ZERO; OldIdx < WdgM_ConfigSetPtr->PtrToMode[WdgM_Mode].NoOfDeadlineSupervision; OldIdx++)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   981      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   982          RunningCounterValueTemp[OldIdx] = WdgM_ConfigSetPtr->PtrToRunningCounterValue[OldIdx];
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   983          WdgM_ConfigSetPtr->PtrToRunningCounterValue[OldIdx] = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   984      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   985  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   986      for(NewIdx = WDGM_PRV_C_ZERO; NewIdx < WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfDeadlineSupervision; NewIdx++)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   987      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   988          for(OldIdx = WDGM_PRV_C_ZERO; OldIdx < WdgM_ConfigSetPtr->PtrToMode[WdgM_Mode].NoOfDeadlineSupervision; OldIdx++)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   989          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   990              if((OldDeadlineSupervisionPtr[OldIdx].StartCheckpointId == NewDeadlineSupervisionPtr[NewIdx].StartCheckpointId)&&
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   991                  (OldDeadlineSupervisionPtr[OldIdx].StopCheckpointId == NewDeadlineSupervisionPtr[NewIdx].StopCheckpointId)&&
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   992                  (OldDeadlineSupervisionPtr[OldIdx].SupervisedEntityId == NewDeadlineSupervisionPtr[NewIdx].SupervisedEntityId))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   993              {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   994                  /* MR12 RULE 9.1 VIOLATION: Unset Values are not used in the range NoOfDeadlineSupervision to "WDGM_MAX_DEADLINE_SUPERVISIONS". */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   995                  WdgM_ConfigSetPtr->PtrToRunningCounterValue[NewIdx] = RunningCounterValueTemp[OldIdx];
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   996              }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   997          }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   998      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   999  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1000      Offset = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1001      NewDeadlineSupervisionPtr = WdgM_ConfigSetPtr->PtrToMode[Mode].PtrToDeadlineSupervision;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1002  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1003      for(SEID = WDGM_PRV_C_ZERO; SEID < WDGM_NO_OF_SUPERVISED_ENTITIES; SEID++)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1004      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1005          for(CheckpointID = WDGM_PRV_C_ZERO; CheckpointID < WdgM_SupervisedEntity[SEID].NoOfCheckpoint; CheckpointID++)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1006          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1007              SingleCheckpointDeadlineSupervisionSize = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1008              WdgM_SupervisedEntity[SEID].PtrToCheckpoint[CheckpointID].PtrToCheckpointDyn->PtrToDeadlineIndices =
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1009                      &WdgM_ConfigSetPtr->PtrToDeadlineIndices[Offset];
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1010  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1011              for(DeadlineIdx = WDGM_PRV_C_ZERO; DeadlineIdx < WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfDeadlineSupervision; DeadlineIdx++)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1012              {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1013  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1014                  if(((NewDeadlineSupervisionPtr[DeadlineIdx].StartCheckpointId == CheckpointID)||
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1015                          (NewDeadlineSupervisionPtr[DeadlineIdx].StopCheckpointId == CheckpointID))&&
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1016                          (NewDeadlineSupervisionPtr[DeadlineIdx].SupervisedEntityId == SEID))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1017                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1018                      WdgM_ConfigSetPtr->PtrToDeadlineIndices[Offset] = DeadlineIdx; /* Store this DeadlineIdx (valid)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1019                      Offset++;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1020                      SingleCheckpointDeadlineSupervisionSize++;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1021                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1022              }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1023  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1024              WdgM_SupervisedEntity[SEID].PtrToCheckpoint[CheckpointID].PtrToCheckpointDyn->NoOfDeadlineSupervision = SingleCheckpointDeadlineSupervisionSize;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1025          }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1026      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1027  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1028  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1029  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1030  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1031  /************************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1032   * Name              :   WdgM_Prv_UpdateTriggerDyn_v_Inl
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1033   * Description       :   Update the Trigger condition and Wdg Mode in current mode
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1034   * Parameters[in]    :   Mode
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1035   * Parameters[inout] :   ReturnStatus
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1036   * Limitations       :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1037   * Return Value      :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1038   ************************************************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1039  LOCAL_INLINE void WdgM_Prv_UpdateTriggerDyn_v_Inl(VAR(WdgM_ModeType,AUTOMATIC) Mode, P2VAR(Std_ReturnType,AUTOMATIC,WDGM_APPL_DATA)ReturnStatus)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1040  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1041      VAR(uint8, AUTOMATIC) triggerIdx_u8;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1042      P2CONST(WdgM_TriggerType, AUTOMATIC, WDGM_APPL_CONST) TriggerPtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1043      *ReturnStatus = E_OK;
	mov	d15,#0
.L422:
	st.b	[a13],d15
.L423:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1044      /* Trigger the Watchdogs for new trigger conditionvalue */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1045  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1046      for(triggerIdx_u8 = WDGM_PRV_C_ZERO; triggerIdx_u8 < WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfTrigger; triggerIdx_u8++)
	mov	d9,#0
.L322:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1047      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1048          if(WdgM_ConfigSetPtr->PtrToMode[Mode].PtrToTrigger[triggerIdx_u8].WdgMode != WDGIF_OFF_MODE)
	sha	d10,d8,#5
.L424:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1046      for(triggerIdx_u8 = WDGM_PRV_C_ZERO; triggerIdx_u8 < WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfTrigger; triggerIdx_u8++)      (inlined)
	j	.L28
.L29:
	ld.a	a15,[a12]
.L425:
	ld.a	a15,[a15]16
.L426:
	addsc.a	a15,a15,d10,#0
.L427:
	ld.a	a15,[a15]28
.L428:
	addsc.a	a15,a15,d9,#3
.L429:
	ld.w	d15,[a15]4
.L430:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1048          if(WdgM_ConfigSetPtr->PtrToMode[Mode].PtrToTrigger[triggerIdx_u8].WdgMode != WDGIF_OFF_MODE)      (inlined)
	jeq	d15,#0,.L30
.L431:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1049          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1050              WdgIf_SetTriggerCondition(WdgM_ConfigSetPtr->PtrToMode[Mode].PtrToTrigger[triggerIdx_u8].DeviceIdx,
	ld.hu	d4,[a15]0
	call	Wdg_SetTriggerCondition

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1048          if(WdgM_ConfigSetPtr->PtrToMode[Mode].PtrToTrigger[triggerIdx_u8].WdgMode != WDGIF_OFF_MODE)      (inlined)
.L30:
	add	d9,#1
.L323:
	extr.u	d9,d9,#0,#8

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1046      for(triggerIdx_u8 = WDGM_PRV_C_ZERO; triggerIdx_u8 < WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfTrigger; triggerIdx_u8++)      (inlined)
.L28:
	ld.a	a15,[a12]
.L432:
	ld.a	a15,[a15]16
.L433:
	addsc.a	a15,a15,d10,#0
.L434:
	ld.bu	d15,[a15]14
.L435:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1046      for(triggerIdx_u8 = WDGM_PRV_C_ZERO; triggerIdx_u8 < WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfTrigger; triggerIdx_u8++)      (inlined)
	jlt.u	d9,d15,.L29
.L436:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1051                      WdgM_ConfigSetPtr->PtrToMode[Mode].PtrToTrigger[triggerIdx_u8].TriggerConditionValue);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1052          }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1053      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1054  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1055      /* Setting the Wdg driver Modes */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1056      TriggerPtr = WdgM_ConfigSetPtr->PtrToMode[Mode].PtrToTrigger;
	ld.a	a15,[a12]
.L437:
	ld.a	a15,[a15]16
.L438:
	addsc.a	a15,a15,d10,#0
.L439:
	ld.a	a14,[a15]28
.L325:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1057      for(triggerIdx_u8= WDGM_PRV_C_ZERO; triggerIdx_u8<WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfTrigger; triggerIdx_u8++)
	mov	d9,#0
.L440:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1057      for(triggerIdx_u8= WDGM_PRV_C_ZERO; triggerIdx_u8<WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfTrigger; triggerIdx_u8++)      (inlined)
	j	.L31
.L32:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1058      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1059          *ReturnStatus = WdgIf_SetMode(TriggerPtr[triggerIdx_u8].DeviceIdx, TriggerPtr[triggerIdx_u8].WdgMode);
	addsc.a	a15,a14,d9,#3
	ld.w	d4,[a15]4
	call	Wdg_SetMode
.L441:
	st.b	[a13],d2
.L442:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1060          if (*ReturnStatus != E_OK)
	ld.bu	d15,[a13]
.L443:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1060          if (*ReturnStatus != E_OK)      (inlined)
	jeq	d15,#0,.L33
.L444:
	ld.a	a2,[a12]
.L445:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1062              break;      (inlined)
	j	.L34

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1060          if (*ReturnStatus != E_OK)      (inlined)
.L33:
	add	d9,#1
.L324:
	extr.u	d9,d9,#0,#8

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1057      for(triggerIdx_u8= WDGM_PRV_C_ZERO; triggerIdx_u8<WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfTrigger; triggerIdx_u8++)      (inlined)
.L31:
	ld.a	a2,[a12]
.L446:
	lea	a15,[a2]16
	ld.a	a15,[a15]
.L447:
	addsc.a	a15,a15,d10,#0
.L448:
	ld.bu	d15,[a15]14
.L449:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1057      for(triggerIdx_u8= WDGM_PRV_C_ZERO; triggerIdx_u8<WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfTrigger; triggerIdx_u8++)      (inlined)
	jlt.u	d9,d15,.L32

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1065  }      (inlined)
.L34:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   379          if(ReturnStatus == E_OK)
	ld.bu	d15,[a10]
.L450:
	jne	d15,#0,.L35
.L235:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     1  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     2  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     3  #ifndef WDGM_PRV_H
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     4  #define WDGM_PRV_H
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     5  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     6  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     7   **********************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     8   * Includes
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     9   **********************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    10  */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    11  #define WDGM_PRV_AVOID_RTE_PROVIDED_FUNC_DECLARATION
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    12  #include "WdgM.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    13  #undef WDGM_PRV_AVOID_RTE_PROVIDED_FUNC_DECLARATION
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    14  #if((WDGM_RTE_DISABLED) == (STD_OFF))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    15  #include "SchM_WdgM.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    16  #include "WdgM_Cfg_SchM.h" /* TODO: To be removed when RTE supports Exclusive Area. */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    17  #include "Rte_WdgM.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    18  #else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    19  #include "WdgM_Cfg_SchM.h" /* It is mandatory if RTE is disabled. */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    20  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    21  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    22  #include "WdgIf.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    23  #if (!defined(WDGIF_AR_RELEASE_MAJOR_VERSION) || (WDGIF_AR_RELEASE_MAJOR_VERSION != 4))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    24  #error “AUTOSAR major version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    25  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    26  #if (!defined(WDGIF_AR_RELEASE_MINOR_VERSION) || (WDGIF_AR_RELEASE_MINOR_VERSION != 2))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    27  #error “AUTOSAR minor version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    28  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    29  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    30  #if (((WDGM_IMMEDIATE_RESET) == (STD_ON)) || ((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_MCU)))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    31  #include "Mcu.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    32  #if (!defined(MCU_AR_RELEASE_MAJOR_VERSION) || (MCU_AR_RELEASE_MAJOR_VERSION != 4))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    33  #error “AUTOSAR major version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    34  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    35  #if (!defined(MCU_AR_RELEASE_MINOR_VERSION) || (MCU_AR_RELEASE_MINOR_VERSION != 2))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    36  #error “AUTOSAR minor version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    37  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    38  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    39  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    40  #include "BswM_WdgM.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    41  #if (!defined(BSWM_AR_RELEASE_MAJOR_VERSION) || (BSWM_AR_RELEASE_MAJOR_VERSION != 4))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    42  #error “AUTOSAR major version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    43  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    44  #if (!defined(BSWM_AR_RELEASE_MINOR_VERSION) || (BSWM_AR_RELEASE_MINOR_VERSION != 2))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    45  #error “AUTOSAR minor version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    46  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    47  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    48  #include "Os.h" /* specified in SWS. required for GetElapsedCounterValue Api */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    49  #if (!defined(OS_AR_RELEASE_MAJOR_VERSION) || (OS_AR_RELEASE_MAJOR_VERSION != 4))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    50  #error “AUTOSAR major version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    51  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    52  #if (!defined(OS_AR_RELEASE_MINOR_VERSION) || (OS_AR_RELEASE_MINOR_VERSION != 2))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    53  #error “AUTOSAR minor version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    54  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    55  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    56  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    57   *********************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    58   * Defines/Macros
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    59   *********************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    60  */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    61  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    62  /* For debugging */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    63  #if ((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    64  #define WDGM_RB_FAILED_IN_ALIVE_MAINFUNCTION                            ((uint8)(1))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    65  #define WDGM_RB_FAILED_IN_DEADLINE_MAINFUNCTION                         ((uint8)(2))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    66  #define WDGM_RB_FAILED_IN_DEADLINE_CHECKPOINTREACHED                    ((uint8)(3))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    67  #define WDGM_RB_FAILED_IN_LOGICAL_INTGRAPH_CPREACHED_GRAPHNOTSTARTED    ((uint8)(4))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    68  #define WDGM_RB_FAILED_IN_LOGICAL_INTGRAPH_CPREACHED_GRAPHSTARTED       ((uint8)(5))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    69  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    70  typedef struct
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    71  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    72  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    73      VAR(TickType,WDGM_VAR_FAST_POWER_ON_CLEARED_UNSPECIFIED)                    FirstElapsedCounterValue;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    74      VAR(uint16,WDGM_VAR_FAST_POWER_ON_CLEARED_16)                               FirstExpiredCheckpointId_t;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    75      VAR(uint16,WDGM_VAR_FAST_POWER_ON_CLEARED_16)                               FirstExpiredAdditionalCheckpointId;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    76      VAR(WdgM_SupervisedEntityIdType,WDGM_VAR_FAST_POWER_ON_CLEARED_UNSPECIFIED) FirstExpiredSupervisedEntityId_t;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    77      VAR(uint8,WDGM_VAR_FAST_POWER_ON_CLEARED_8)                                 FirstExpiredLocation_t;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    78      VAR(WdgM_ModeType,AUTOMATIC)                                                FirstExpiredModeId;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    79  }WdgM_Rb_FirstExpiredEntityInfo_tst;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    80  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    81  #endif /*WDGM_RB_DEBUG_OPTION_ENABLED*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    82  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    83  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    84   **********************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    85   * Extern declarations
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    86   **********************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    87  */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    88  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    89  #define WDGM_START_SEC_VAR_FAST_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    90  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    91  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    92  extern P2CONST(WdgM_ConfigType, WDGM_VAR_FAST_CLEARED_UNSPECIFIED, WDGM_APPL_CONST)WdgM_ConfigSetPtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    93  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    94  #define WDGM_STOP_SEC_VAR_FAST_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    95  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    96  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    97  #define WDGM_START_SEC_VAR_FAST_CLEARED_BOOLEAN
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    98  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    99  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   100  extern VAR(boolean, WDGM_VAR_FAST_CLEARED_BOOLEAN) WdgM_AliveSupervisionActive;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   101  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   102  #define WDGM_STOP_SEC_VAR_FAST_CLEARED_BOOLEAN
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   103  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   104  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   105  #define WDGM_START_SEC_VAR_FAST_CLEARED_8
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   106  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   107  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   108  extern VAR(uint8, WDGM_VAR_FAST_CLEARED_8) WdgM_Mode;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   109  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   110  #define WDGM_STOP_SEC_VAR_FAST_CLEARED_8
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   111  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   112  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   113  #define WDGM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   114  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   115  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   116  extern VAR(uint16, WDGM_VAR_CLEARED_16) WdgM_ExpiredSupervisionCycleCtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   117  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   118  #define WDGM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   119  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   120  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   121  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   122  #define WDGM_START_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   123  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   124  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   125  extern VAR(uint32, WDGM_VAR_CLEARED_32) WdgM_MainFunction_Cnt_u32;  /* This variable is used only for debug purpose. */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   126  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   127  #define WDGM_STOP_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   128  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   129  #endif /*((WDGM_DEV_ERROR_DETECT) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   130  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   131  #define WDGM_START_SEC_VAR_SLOW_INIT_BOOLEAN
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   132  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   133  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   134  extern VAR(boolean, WDGM_VAR_SLOW_INIT_BOOLEAN) WdgM_Prv_FirstDeactivation_b;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   135  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   136  #define WDGM_STOP_SEC_VAR_SLOW_INIT_BOOLEAN
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   137  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   138  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   139  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   140  #define WDGM_START_SEC_VAR_FAST_POWER_ON_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   141  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   142  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   143  extern VAR(WdgM_Rb_FirstExpiredEntityInfo_tst, WDGM_VAR_FAST_POWER_ON_CLEARED_UNSPECIFIED) WdgM_Rb_FirstExpiredEntityInfo_st;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   144  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   145  #define WDGM_STOP_SEC_VAR_FAST_POWER_ON_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   146  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   147  #endif /*(WDGM_RB_DEBUG_OPTION_ENABLED == STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   148  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   149  #define WDGM_START_SEC_VAR_POWER_ON_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   150  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   151  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   152  /* TRACE[WDGM349] Implementation of non-initialized RAM location, stored as a double-inverse value */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   153  extern VAR(WdgM_SupervisedEntityIdType, WDGM_VAR_POWER_ON_CLEARED_UNSPECIFIED) WdgM_FirstExpiredSupervisedEntityId;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   154  extern VAR(WdgM_SupervisedEntityIdType, WDGM_VAR_POWER_ON_CLEARED_UNSPECIFIED) WdgM_FirstExpiredSupervisedEntityId_Comp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   155  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   156  #define WDGM_STOP_SEC_VAR_POWER_ON_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   157  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   158  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   159  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   160  #define WDGM_START_SEC_VAR_FAST_POWER_ON_CLEARED_8
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   161  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   162  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   163  extern VAR(uint8, WDGM_VAR_FAST_POWER_ON_CLEARED_8) WdgM_Rb_FirstExpiredEntity_Cnt_u8;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   164  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   165  #define WDGM_STOP_SEC_VAR_FAST_POWER_ON_CLEARED_8
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   166  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   167  #endif /*(WDGM_RB_DEBUG_OPTION_ENABLED == STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   168  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   169  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   170   ***********************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   171   * Private Function Declaration
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   172   ***********************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   173  */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   174  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   175  #define WDGM_START_SEC_CODE
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   176  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   177  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   178  extern FUNC(void, WDGM_CODE) WdgM_Prv_SetTriggerCondition(VAR(WdgM_GlobalStatusType, AUTOMATIC)globalStatus_tu8);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   179  extern FUNC(void,WDGM_CODE) WdgM_Prv_LocalStatusMainFunction(void);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   180  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   181  #define WDGM_STOP_SEC_CODE
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   182  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   183  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   184  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   185  #define WDGM_START_SEC_CODE_FAST
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   186  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   187  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   188  extern FUNC(void, WDGM_CODE_FAST) WdgM_Rb_FirstExpiredEntity(VAR(TickType,AUTOMATIC) ElapsedCounterValue, VAR(uint16,AUTOMATIC) CheckpointID,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   189          VAR(uint16,AUTOMATIC) AdditionalCheckpointID, VAR(WdgM_SupervisedEntityIdType,AUTOMATIC) SEID,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   190          VAR(uint8,AUTOMATIC) ExpiredLocation, VAR(WdgM_ModeType,AUTOMATIC) ModeId);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   191  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   192  #define WDGM_STOP_SEC_CODE_FAST
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   193  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   194  #endif/*(WDGM_RB_DEBUG_OPTION_ENABLED == STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   195  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   196  LOCAL_INLINE void WdgM_Prv_AliveSupervisionMainFunction_v_Inl(void);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   197  LOCAL_INLINE void WdgM_Prv_UpdateAliveSupervisionDyn_v_Inl(void);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   198  LOCAL_INLINE void WdgM_Prv_UpdateTriggerDyn_v_Inl(VAR(WdgM_ModeType,AUTOMATIC) Mode, P2VAR(Std_ReturnType,AUTOMATIC,WDGM_APPL_DATA)ReturnStatus);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   199  LOCAL_INLINE void WdgM_Prv_UpdateSupervisedEntityDyn_v_Inl(VAR(WdgM_ModeType,AUTOMATIC) Mode);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   200  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   201  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   202  LOCAL_INLINE void WdgM_Rb_DebugVariables_Init_v_Inl(void);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   203  #endif/*(WDGM_RB_DEBUG_OPTION_ENABLED == STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   204  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   205  #if((WDGM_DEADLINE_TIMEOUT_DETECT == STD_ON) && ((WDGM_MAX_DEADLINE_SUPERVISIONS) > (WDGM_PRV_C_ZERO)))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   206  LOCAL_INLINE void WdgM_Prv_DeadlineSupervisionMainFunction_v_Inl(void);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   207  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   208  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   209  #if ((WDGM_MAX_DEADLINE_SUPERVISIONS) > (WDGM_PRV_C_ZERO))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   210  LOCAL_INLINE void WdgM_Prv_DeadlineSupervisionCheckpointReached_v_Inl(VAR(WdgM_SupervisedEntityIdType,AUTOMATIC) SEID,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   211  VAR(WdgM_CheckpointIdType,AUTOMATIC) CheckpointID, P2VAR(Std_ReturnType,AUTOMATIC,WDGM_APPL_DATA)ReturnStatus);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   212  LOCAL_INLINE void WdgM_Prv_UpdateDeadlineSupervisionDyn_v_Inl(VAR(WdgM_ModeType,AUTOMATIC) Mode);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   213  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   214  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   215  #if (WDGM_INTERNAL_GRAPH_CONFIGURED == STD_ON)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   216  LOCAL_INLINE Std_ReturnType WdgM_Prv_LogicalSupervisionCheckpointReached_v_Inl(VAR(WdgM_SupervisedEntityIdType,AUTOMATIC) SEID,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   217  VAR(WdgM_CheckpointIdType,AUTOMATIC) CheckpointID);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   218  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   219  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   220   ************************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   221   * Inline Function Definitions
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   222   ************************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   223   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   224  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   225  /************************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   226   * Name              :   WdgM_Rb_DebugVariables_Init_v_Inl
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   227   * Description       :   Initialises the debug Variables
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   228   * Parameters[in]    :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   229   * Limitations       :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   230   * Return Value      :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   231   ************************************************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   232  LOCAL_INLINE void WdgM_Rb_DebugVariables_Init_v_Inl(void)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   233  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   234      WdgM_Rb_FirstExpiredEntityInfo_st.FirstElapsedCounterValue          = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   235      WdgM_Rb_FirstExpiredEntityInfo_st.FirstExpiredCheckpointId_t        = WDGM_RB_MAX_CHECKPOINTID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   236      WdgM_Rb_FirstExpiredEntityInfo_st.FirstExpiredAdditionalCheckpointId= WDGM_RB_MAX_CHECKPOINTID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   237      WdgM_Rb_FirstExpiredEntityInfo_st.FirstExpiredSupervisedEntityId_t  = WDGM_RB_MAX_SUPERVISEDENTITYID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   238      WdgM_Rb_FirstExpiredEntityInfo_st.FirstExpiredLocation_t            = WDGM_RB_DEFAULT_EXPIREDLOCATION;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   239      WdgM_Rb_FirstExpiredEntityInfo_st.FirstExpiredModeId                = WDGM_RB_MAX_MODEID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   240  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   241        WdgM_Rb_FirstExpiredEntity_Cnt_u8 = WDGM_PRV_C_ONE;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   242  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   243  #endif/*(WDGM_RB_DEBUG_OPTION_ENABLED == STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   244  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   245  /************************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   246   * Name              :   WdgM_Prv_AliveSupervisionMainFunction_v_Inl
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   247   * Description       :   Update the Alive Supervision in WdgM_MainFunction
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   248   * Parameters[in]    :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   249   * Limitations       :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   250   * Return Value      :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   251   ************************************************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   252  LOCAL_INLINE void WdgM_Prv_AliveSupervisionMainFunction_v_Inl(void)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   253  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   254      VAR(WdgM_SupervisedEntityIdType, AUTOMATIC) SEID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   255      VAR(uint16, AUTOMATIC) AliveSupervisionIdx;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   256      P2CONST(WdgM_AliveSupervisionType, AUTOMATIC, WDGM_APPL_CONST) AliveSupervisionPtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   257      VAR(uint32,AUTOMATIC) IndividualAliveUpdateCtrCache = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   258      AliveSupervisionPtr = WdgM_ConfigSetPtr->PtrToMode[WdgM_Mode].PtrToAliveSupervision;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   259  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   260      for(AliveSupervisionIdx= WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   261      AliveSupervisionIdx < WdgM_ConfigSetPtr->PtrToMode[WdgM_Mode].NoOfAliveSupervision;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   262      AliveSupervisionIdx++)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   263      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   264          SEID = AliveSupervisionPtr[AliveSupervisionIdx].SupervisedEntityId;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   265          /* TRACE[WDGM208] If SE was in local state deactivated then leave those SE
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   266           * in that state and start processing of supervision for other SE's  */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   267          /* TRACE[WDGM083] Check for Alive Supervison config, If NO then do not
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   268           * perform Alive counter examination*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   269          if(((WdgM_SupervisedEntityDyn[SEID].NewLocalStatus & WDGM_LOCAL_STATUS_DEACTIVATED)!= WDGM_LOCAL_STATUS_DEACTIVATED)&&
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   270                  (WdgM_AliveSupervisionActive == TRUE))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   271          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   272              WdgM_SupervisedEntityDyn[SEID].IndividualSupervisionCycleCtr++;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   273              /*TRACE[WDGM098] Perform checking only at the configured Supervision Reference Cycle*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   274              if (WdgM_SupervisedEntityDyn[SEID].IndividualSupervisionCycleCtr ==
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   275                      AliveSupervisionPtr[AliveSupervisionIdx].SupervisionReferenceCycle)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   276              {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   277                  /*Interrupt lock to cache IndividualAliveUpdateCtr for calculation. Reset alive Counter here*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   278                  /*Interrupt Lock:
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   279                   * 1. Cache and set to 0 should be an atomic operation so as to capture new CP.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   280                   * If no Lock then after caching we can get CPR and the counter is incremented coming back to mainFunction
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   281                   * we will set the IndividualAliveUpdateCtr to 0. Hence One count will be lost.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   282                   * */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   283  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   284                  SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   285  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   286                  IndividualAliveUpdateCtrCache = WdgM_SupervisedEntityDyn[SEID].IndividualAliveUpdateCtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   287                  WdgM_SupervisedEntityDyn[SEID].IndividualAliveUpdateCtr = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   288  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   289                  SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   290  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   291                  /*[WDGM074] Check if AliveCounter is within limit*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   292                  /*Check for if Alive counter is within the range hence "correct" state*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   293                  if (((IndividualAliveUpdateCtrCache )>=
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   294                  ((uint32)AliveSupervisionPtr[AliveSupervisionIdx].ExpectedAliveIndications - (uint32)AliveSupervisionPtr[AliveSupervisionIdx].MinMargin))&&
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   295                  ((IndividualAliveUpdateCtrCache) <=
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   296                  ((uint32)AliveSupervisionPtr[AliveSupervisionIdx].ExpectedAliveIndications + (uint32)AliveSupervisionPtr[AliveSupervisionIdx].MaxMargin)))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   297                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   298                      /* TRACE[WDGM300] If SE is in LS status FAILED and results of
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   299                       * AS are correct  and the counter for failed supervision reference cycle is >1 */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   300                      if(WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr > WDGM_PRV_C_ONE)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   301                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   302                          /*Lock Enabled: Lock required because when preempted by CRP then the newly modified value will be replaced by MainFunction here*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   303  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   304                          SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   305  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   306                          WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus | WDGM_LOCAL_STATUS_FAILED;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   307  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   308                          SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   309  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   310                          WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr--;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   311                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   312                      /* TRACE[WDGM205] If SE is in LS status FAILED and results of AS
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   313                       * are correct and the counter for failed supervision
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   314                       * reference cycle is equal 1 */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   315                      else if(WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr == WDGM_PRV_C_ONE)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   316                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   317                          /*Lock Enabled: Lock required because when preempted by CRP then the newly modified value will be replaced by MainFunction here*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   318  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   319                          SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   320  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   321                          WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus & ((WdgM_LocalStatusType)(~WDGM_LOCAL_STATUS_FAILED));
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   322  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   323                          SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   324  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   325                          WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   326                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   327                      else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   328                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   329                          /*Lock Enabled: Lock required because when preempted by CRP then the newly modified value will be replaced by MainFunction here*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   330  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   331                          SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   332  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   333                          WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus & ((WdgM_LocalStatusType)(~WDGM_LOCAL_STATUS_FAILED));
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   334  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   335                          SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   336  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   337                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   338                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   339                  /*[WDGM115] If alive indiaction not within tolerance the incorrect*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   340                  /*Else since Alive counter is  not within the range hence "incorrect" state*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   341                  else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   342                  {   /* TRACE[WDGM202] If SE was in LS status OK and results of
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   343                       * atleast one AS is incorrect and the fault tolerence == 0*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   344                      /* TRACE[WDGM203] If SE was in LS status OK and results of
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   345                       * atleast one AS is incorrect and the failure fault tolerence > 0*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   346                      /* TRACE[WDGM204] If SE was in LS status FAILURE and results of
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   347                      * atleast one AS is incorrect and the failure supervision refrence cycle < tolerence*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   348                      /*Lock Enabled: Lock required because when preempted by CRP then the newly modified value will be replaced by MainFunction here*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   349  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   350                      SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   351  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   352                      WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus | WDGM_LOCAL_STATUS_FAILED;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   353  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   354                      SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   355  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   356                      WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr++;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   357                      /* TRACE[WDGM206] If SE was in LS status FAILED and results of
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   358                       * atleast one AS is incorrect and the counter for failed supervision reference cycle > Ref Cycle*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   359                      if (WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr > WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleTol)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   360                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   361                          /*Lock Enabled: Lock required because when preempted by CRP then the newly modified value will be replaced by MainFunction here*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   362  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   363                          SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   364  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   365                          WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus | WDGM_LOCAL_STATUS_EXPIRED;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   366  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   367                          SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   368  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   369  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   370                          WdgM_Rb_FirstExpiredEntity(WDGM_PRV_C_ZERO, (uint16)AliveSupervisionPtr[AliveSupervisionIdx].AliveSupervisionCheckpointId,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   371                                                     WDGM_RB_MAX_CHECKPOINTID, SEID, WDGM_RB_FAILED_IN_ALIVE_MAINFUNCTION, WdgM_Mode);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   372  #endif/*(WDGM_RB_DEBUG_OPTION_ENABLED == STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   373                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   374                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   375                  WdgM_SupervisedEntityDyn[SEID].IndividualSupervisionCycleCtr = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   376              }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   377          }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   378          else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   379          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   380              /* This is required to do the syncronization of different Alive Supervisions after Mode change happens
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   381                 When mode change occurs the counters have to be reset to 0 */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   382  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   383              /*Lock Placed:
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   384                Any modification operation(Eg:incrementing the counter value) on WdgM_SupervisedEntityDyn[SEID].IndividualAliveUpdateCtr
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   385                variable is done in atomic in other places[WdgM_CheckpointReached()]. So here also modification(setting to 0) should be done in atomic.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   386                So that modification operation is not preempted by each other
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   387              */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   388  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   389  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   390              SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   391  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   392  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   393              WdgM_SupervisedEntityDyn[SEID].IndividualAliveUpdateCtr = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   394  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   395  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   396              SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   397  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   398  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   399              /*Clear IndividualSupervisionCycleCtr and FailedAliveSupervisionRefCycleCtr When Mode change happens  */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   400              WdgM_SupervisedEntityDyn[SEID].IndividualSupervisionCycleCtr = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   401              WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   402  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   403          }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   404      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   405  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   406      if(WdgM_AliveSupervisionActive == FALSE)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   407      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   408          WdgM_AliveSupervisionActive = TRUE;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   409      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   410  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   411  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   412  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   413  #if((WDGM_DEADLINE_TIMEOUT_DETECT == STD_ON) && ((WDGM_MAX_DEADLINE_SUPERVISIONS) > (WDGM_PRV_C_ZERO)))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   414  /************************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   415   * Name              :   WdgM_Prv_DeadlineSupervisionMainFunction_v_Inl
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   416   * Description       :   Update the Deadline Supervision in WdgM_MainFunction for the checkpoints for which Start checkpoint
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   417   *                       has been reached but the stop checkpoint has not been reached and it has expired.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   418   *                       New RFC request in AutoSAR bugzilla Id : 56735
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   419   * Parameters[in]    :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   420   * Limitations       :   This update will be done only for Timers accessible from WdgM_MainFunction calling TASK context....!!
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   421   * Return Value      :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   422   ************************************************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   423  LOCAL_INLINE void WdgM_Prv_DeadlineSupervisionMainFunction_v_Inl(void)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   424  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   425      VAR(WdgM_SupervisedEntityIdType, AUTOMATIC) SEID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   426      VAR(uint16, AUTOMATIC)  DeadlineIdx;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   427      VAR(TickType, AUTOMATIC) RunningCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   428      VAR(TickType, AUTOMATIC) ElapsedCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   429      P2CONST(WdgM_DeadlineSupervisionType, AUTOMATIC, WDGM_APPL_CONST) DeadlineSupervisionPtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   430      VAR(StatusType, AUTOMATIC)  returnStatus = E_NOT_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   431      DeadlineSupervisionPtr = WdgM_ConfigSetPtr->PtrToMode[WdgM_Mode].PtrToDeadlineSupervision;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   432  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   433  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   434      for(DeadlineIdx = WDGM_PRV_C_ZERO; DeadlineIdx < WdgM_ConfigSetPtr->PtrToMode[WdgM_Mode].NoOfDeadlineSupervision; DeadlineIdx++)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   435      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   436          RunningCounterValueTemp = WdgM_ConfigSetPtr->PtrToRunningCounterValue[DeadlineIdx];
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   437  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   438          /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   439           * No need to do the evaluation to update or not to update NewLocalStatus if Deadline supervision is not
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   440           * running or Deadline supervision is running but Stop checkpoint has already reached.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   441           */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   442          if(RunningCounterValueTemp != ((TickType)WDGM_PRV_C_ZERO))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   443          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   444              SEID = DeadlineSupervisionPtr[DeadlineIdx].SupervisedEntityId;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   445  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   446   * If the WdgM_Prv_DeadlineSupervisionMainFunction_v_Inl is not called under lock in WdgM_MainFunction
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   447   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   448  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   449                  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   450                   * Set variable ElapsedCounterValueTemp as 0(WDGM_PRV_C_ZERO), so that NewLocalStatus will not be updated
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   451                   * if RunningCounterValueTemp is 0.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   452                   * RunningCounterValueTemp is 0 mean either Deadline supervision is not running or Deadline supervision
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   453                   * is running but Stop checkpoint has already reached.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   454                   *
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   455                   * Info: ElapsedCounterValueTemp will also have non zero value only when RunningCounterValueTemp will have
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   456                   * no zero value, otherwise ElapsedCounterValueTemp will have value 0 .
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   457                   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   458                  ElapsedCounterValueTemp = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   459  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   460                  /* Lock Placed:
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   461                   * Reading of captured running counter value and then calculation of elapsed counter value w.r.t current running
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   462                   * counter value should not be pre-empted by other task(WdgM_CheckpointReached). So these operations are done under lock.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   463                   * For more information refer Errata 4077.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   464                   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   465                  SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   466  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   467                  /* Read once again Running Counter to have latest value for comparison.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   468                   * This is required if function WdgM_Prv_DeadlineSupervisionMainFunction_v_Inl is
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   469                   * not called under lock.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   470                   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   471                  RunningCounterValueTemp = WdgM_ConfigSetPtr->PtrToRunningCounterValue[DeadlineIdx];
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   472  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   473                  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   474                   * Get the Elapsed counter value if Start checkpoint is reached but End checkpoint is not yet reached
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   475                   * (that is, when Deadline Supervision is running)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   476                  */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   477                  if(RunningCounterValueTemp != ((TickType)WDGM_PRV_C_ZERO))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   478                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   479  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   480  #if((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_OS))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   481                      returnStatus = GetElapsedCounterValue(WdgM_SupervisedEntity[SEID].TimerId, &RunningCounterValueTemp, &ElapsedCounterValueTemp);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   482  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   483  #if((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_MCU))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   484                      ElapsedCounterValueTemp = RunningCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   485                      RunningCounterValueTemp = (TickType)Mcu_Rb_GetSysTicks();
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   486                      ElapsedCounterValueTemp = RunningCounterValueTemp - ElapsedCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   487                      returnStatus = E_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   488  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   489                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   490                  else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   491                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   492                      returnStatus = E_NOT_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   493                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   494  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   495                  SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   496  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   497   * If the WdgM_Prv_DeadlineSupervisionMainFunction_v_Inl is called under lock in WdgM_MainFunction
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   498   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   499  #else /*(WDGM_LOCK_DISABLE_FOR_DGS) == (STD_OFF) */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   500  #if((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_OS))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   501                  returnStatus = GetElapsedCounterValue(WdgM_SupervisedEntity[SEID].TimerId, &RunningCounterValueTemp, &ElapsedCounterValueTemp);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   502  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   503  #if((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_MCU))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   504                  ElapsedCounterValueTemp = RunningCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   505                  RunningCounterValueTemp = (TickType)Mcu_Rb_GetSysTicks();
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   506                  ElapsedCounterValueTemp = RunningCounterValueTemp - ElapsedCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   507                  returnStatus = E_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   508  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   509  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   510  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   511  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   512                  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   513                   * 1. Update the NewLocalStatus value as expired if
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   514                   * Elapsed Counter value is obtained successfully and
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   515                   * Elapsed Counter value is greater than Deadline max time
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   516                   *
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   517                   * 2. NewLocalStatus will not get updated if either Deadline supervision is not running or Deadline supervision
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   518                   * is running but Stop checkpoint has already reached
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   519                   * (In case WDGM_LOCK_DISABLE_FOR_DGS is STD_ON, ElapsedCounterValueTemp will be 0. Thereby taken care)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   520                   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   521  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   522                  if((returnStatus == E_OK) && (ElapsedCounterValueTemp > DeadlineSupervisionPtr[DeadlineIdx].DeadlineMax))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   523                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   524                      /*Lock Not required since CPR will at worst modify local to EXPIRED which is done here anyway*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   525                      WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus | WDGM_LOCAL_STATUS_EXPIRED;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   526  # if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   527                      WdgM_Rb_FirstExpiredEntity(ElapsedCounterValueTemp, DeadlineSupervisionPtr[DeadlineIdx].StartCheckpointId,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   528                                                 DeadlineSupervisionPtr[DeadlineIdx].StopCheckpointId, SEID, WDGM_RB_FAILED_IN_DEADLINE_MAINFUNCTION, WdgM_Mode);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   529  # endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   530                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   531          }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   532      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   533  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   534  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   535  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   536  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   537  #if ((WDGM_MAX_DEADLINE_SUPERVISIONS) > (WDGM_PRV_C_ZERO))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   538  /*******************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   539  * Name              :   WdgM_Prv_DeadlineSupervisionCheckpointReached_v_Inl
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   540  * Description       :   Does the Deadline Monitoring part of WdgM_CheckpointReached().
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   541  * Parameters[in]    :   SEID, CheckpointID
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   542  * Parameters[inout] :   ReturnStatus
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   543  * Limitations       :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   544  * ReturnType        :   Std_ReturnType
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   545  *******************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   546  LOCAL_INLINE void WdgM_Prv_DeadlineSupervisionCheckpointReached_v_Inl(VAR(WdgM_SupervisedEntityIdType,AUTOMATIC) SEID,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   547  VAR(WdgM_CheckpointIdType,AUTOMATIC) CheckpointID, P2VAR(Std_ReturnType,AUTOMATIC,WDGM_APPL_DATA)ReturnStatus)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   548  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   549      VAR(uint16,AUTOMATIC) SvIdx;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   550      VAR(uint16,AUTOMATIC) DeadlineIdx;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   551      VAR(TickType,AUTOMATIC) RunningCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   552      VAR(TickType,AUTOMATIC) ElapsedCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   553      P2CONST(WdgM_DeadlineSupervisionType, AUTOMATIC, WDGM_APPL_CONST)DeadlineSupervisionPtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   554      P2VAR(uint16, AUTOMATIC, WDGM_APPL_DATA)DeadlineIdxPtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   555  #if((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_OS))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   556  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   557      VAR(boolean, AUTOMATIC) Report_E_OsCounter_Det;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   558      Report_E_OsCounter_Det = FALSE;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   559  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   560  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   561  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   562      *ReturnStatus = E_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   563  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   564      /* TRACE[WDGM322] Perform Deadline supervision*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   565  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   566      SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   567      if ((WdgM_SupervisedEntityDyn[SEID].NewLocalStatus & WDGM_LOCAL_STATUS_DEACTIVATED) != WDGM_LOCAL_STATUS_DEACTIVATED)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   568      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   569          DeadlineIdxPtr = WdgM_SupervisedEntity[SEID].PtrToCheckpoint[CheckpointID].PtrToCheckpointDyn->PtrToDeadlineIndices;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   570          DeadlineSupervisionPtr = WdgM_ConfigSetPtr->PtrToMode[WdgM_Mode].PtrToDeadlineSupervision;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   571          /* TRACE[WDGM299] Perform check if deadline active or inactive */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   572          for(SvIdx = WDGM_PRV_C_ZERO;  SvIdx < WdgM_SupervisedEntity[SEID].PtrToCheckpoint[CheckpointID].PtrToCheckpointDyn->NoOfDeadlineSupervision; SvIdx++)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   573          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   574              DeadlineIdx = DeadlineIdxPtr[SvIdx];
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   575              RunningCounterValueTemp = WdgM_ConfigSetPtr->PtrToRunningCounterValue[DeadlineIdx];
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   576  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   577              if ((CheckpointID == DeadlineSupervisionPtr[DeadlineIdx].StopCheckpointId)&&
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   578                          (RunningCounterValueTemp != ((TickType)WDGM_PRV_C_ZERO)))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   579              {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   580  #if((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_OS))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   581                  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   582                   * Evaluation should be done only if return value of GetElapsedCounterValue is E_OK.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   583                   * Running counter value (timestamp) should be cleared if return value of GetElapsedCounterValue
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   584                   * is other than E_OK. And report error to DET if DET is enabled
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   585                   * TRACE[BSW_SWS_AR4_0_R2_WatchDogManager_Ext-2820]
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   586                   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   587                  if(E_OK == (GetElapsedCounterValue(WdgM_SupervisedEntity[SEID].TimerId, &RunningCounterValueTemp, &ElapsedCounterValueTemp)))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   588                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   589                      /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   590                       * TRACE[BSW_SWS_AR4_0_R2_WatchDogManager_Ext-2819]
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   591                       */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   592                      /* TRACE[WDGM229] Perform checking when deadline endpoint reached*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   593                      if ((ElapsedCounterValueTemp >= DeadlineSupervisionPtr[DeadlineIdx].DeadlineMin) &&
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   594                              (ElapsedCounterValueTemp <= DeadlineSupervisionPtr[DeadlineIdx].DeadlineMax))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   595                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   596                          /* Update of Local supervision status (WdgM_SupervisedEntityDyn[SEID].NewLocalStatus) not needed */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   597                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   598                      /*TRACE [WDGM294] Since the time diffrence is not within range the deadline result is
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   599                       * incorrect */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   600                      else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   601                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   602                          WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus | WDGM_LOCAL_STATUS_EXPIRED;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   603  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   604                          WdgM_Rb_FirstExpiredEntity(ElapsedCounterValueTemp, DeadlineSupervisionPtr[DeadlineIdx].StartCheckpointId,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   605                                                     DeadlineSupervisionPtr[DeadlineIdx].StopCheckpointId, SEID, WDGM_RB_FAILED_IN_DEADLINE_CHECKPOINTREACHED, WdgM_Mode);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   606  #endif /*(WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   607                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   608                      /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   609                       * Clear the RunningCounterValueTemp if start and stop checkpoints are not same
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   610                       * If start and stop checkpoints are same then no need to clear the RunningCounterValueTemp
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   611                       */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   612                      if(DeadlineSupervisionPtr[DeadlineIdx].StopCheckpointId != DeadlineSupervisionPtr[DeadlineIdx].StartCheckpointId)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   613                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   614                          RunningCounterValueTemp = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   615                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   616                      else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   617                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   618                          /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   619                           * This is to avoid not to detect already started Deadline Supervision exactly at 0.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   620                           * Anyway the resolution of RunningCounterValueTemp (of type TickType) is very high, impact of addition of 1, w.r.t Seconds
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   621                           * is very less.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   622                           */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   623                          if(RunningCounterValueTemp == ((TickType)WDGM_PRV_C_ZERO))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   624                          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   625  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   626                              RunningCounterValueTemp = (TickType)WDGM_PRV_C_ONE;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   627                          }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   628                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   629                      WdgM_ConfigSetPtr->PtrToRunningCounterValue[DeadlineIdx] = RunningCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   630                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   631                  else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   632                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   633                      /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   634                       * TRACE[BSW_SWS_AR4_0_R2_WatchDogManager_Ext-2860]
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   635                       */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   636  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   637                      Report_E_OsCounter_Det = TRUE;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   638  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   639                      WdgM_ConfigSetPtr->PtrToRunningCounterValue[DeadlineIdx] = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   640                      *ReturnStatus = E_NOT_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   641                   }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   642  #endif /*((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_OS)) */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   643  #if((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_MCU))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   644                  ElapsedCounterValueTemp = RunningCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   645                  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   646                   * TRACE[BSW_SWS_AR4_0_R2_WatchDogManager_Ext-2821]
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   647                   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   648                  RunningCounterValueTemp = (TickType)Mcu_Rb_GetSysTicks();
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   649                  ElapsedCounterValueTemp = RunningCounterValueTemp - ElapsedCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   650                  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   651                   * TRACE[BSW_SWS_AR4_0_R2_WatchDogManager_Ext-2861]
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   652                   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   653                  /* TRACE[WDGM229] Perform checking when deadline endpoint reached*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   654                  if ((ElapsedCounterValueTemp >= DeadlineSupervisionPtr[DeadlineIdx].DeadlineMin) &&
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   655                          (ElapsedCounterValueTemp <= DeadlineSupervisionPtr[DeadlineIdx].DeadlineMax))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   656                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   657                      /* Update of Local supervision status (WdgM_SupervisedEntityDyn[SEID].NewLocalStatus) not needed */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   658                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   659                  /*TRACE [WDGM294] Since the time diffrence is not within range the deadline result is
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   660                   * incorrect */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   661                  else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   662                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   663                      WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus | WDGM_LOCAL_STATUS_EXPIRED;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   664  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   665                      WdgM_Rb_FirstExpiredEntity(ElapsedCounterValueTemp, DeadlineSupervisionPtr[DeadlineIdx].StartCheckpointId,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   666                                                 DeadlineSupervisionPtr[DeadlineIdx].StopCheckpointId, SEID, WDGM_RB_FAILED_IN_DEADLINE_CHECKPOINTREACHED, WdgM_Mode);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   667  #endif /*(WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   668                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   669                  if(DeadlineSupervisionPtr[DeadlineIdx].StopCheckpointId != DeadlineSupervisionPtr[DeadlineIdx].StartCheckpointId)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   670                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   671                      WdgM_ConfigSetPtr->PtrToRunningCounterValue[DeadlineIdx] = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   672                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   673                  else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   674                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   675                      if(RunningCounterValueTemp == ((TickType)WDGM_PRV_C_ZERO))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   676                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   677                          /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   678                           * This is to avoid not to detect already started Deadline Supervision exactly at 0.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   679                           * Anyway the resolution of RunningCounterValueTemp (of type TickType) is very high, impact of addition of 1, w.r.t Seconds
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   680                           * is very less.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   681                           */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   682                          RunningCounterValueTemp = (TickType)WDGM_PRV_C_ONE;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   683                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   684                      /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   685                       * This is for the special case to detect Start of Deadline Supervision, where for cyclic
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   686                       * Task Deadline Start and destination Checkpoints are configured same.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   687                       */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   688                      WdgM_ConfigSetPtr->PtrToRunningCounterValue[DeadlineIdx] = RunningCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   689                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   690  #endif /* ((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_MCU)) */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   691              }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   692              else if (CheckpointID == DeadlineSupervisionPtr[DeadlineIdx].StartCheckpointId)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   693              {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   694                  /* Reference: OS384 */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   695                  /* TRACE[WDGM228] Record the time stamp if deadline started*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   696                  /* Note : SWS_WdgM_00228 means that it is not considered as an error by Deadline Supervision if
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   697                   * a given Deadline Start Checkpoint is reached several times without reaching the corresponding
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   698                   * Deadline End Checkpoint (each time the timestamp is just updated)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   699  #if((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_OS))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   700                  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   701                   * Running counter value should be captured/stored only if GetElapsedCounterValue returns E_OK.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   702                   * If the return value is other than E_OK then set *ReturnStatus as E_NOT_OK. If DET is enabled
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   703                   * then report error to DET.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   704                   *TRACE[BSW_SWS_AR4_0_R2_WatchDogManager_Ext-2820]
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   705                   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   706                  if(E_OK == (GetElapsedCounterValue(WdgM_SupervisedEntity[SEID].TimerId, &RunningCounterValueTemp, &ElapsedCounterValueTemp)))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   707                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   708                      if(RunningCounterValueTemp == ((TickType)WDGM_PRV_C_ZERO))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   709                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   710                          /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   711                           * This is to avoid not to detect already started Deadline Supervision exactly at 0.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   712                           * Anyway the resolution of RunningCounterValueTemp (of type TickType) is very high,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   713                           * impact of addition of 1, w.r.t Seconds is very less.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   714                           */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   715                          RunningCounterValueTemp = (TickType)WDGM_PRV_C_ONE;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   716                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   717                      /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   718                       * TRACE[BSW_SWS_AR4_0_R2_WatchDogManager_Ext-2818]
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   719                       */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   720                      WdgM_ConfigSetPtr->PtrToRunningCounterValue[DeadlineIdx] = RunningCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   721                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   722                  else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   723                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   724                      /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   725                       * Running Counter will not be modified. It will remain as 0
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   726                       * TRACE[BSW_SWS_AR4_0_R2_WatchDogManager_Ext-2858]
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   727                       */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   728  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   729                      Report_E_OsCounter_Det = TRUE;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   730  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   731                      WdgM_ConfigSetPtr->PtrToRunningCounterValue[DeadlineIdx] = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   732                      *ReturnStatus = E_NOT_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   733                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   734  #endif /* ((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_OS)) */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   735  #if((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_MCU))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   736                  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   737                   * TRACE[BSW_SWS_AR4_0_R2_WatchDogManager_Ext-2821]
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   738                   * TRACE[BSW_SWS_AR4_0_R2_WatchDogManager_Ext-2859]
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   739                   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   740                  RunningCounterValueTemp = (TickType)Mcu_Rb_GetSysTicks();
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   741                  if(RunningCounterValueTemp == ((TickType)WDGM_PRV_C_ZERO))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   742                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   743                      /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   744                       * This is to avoid not to detect already started Deadline Supervision exactly at 0.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   745                       * Anyway the resolution of RunningCounterValueTemp (of type TickType) is very high, impact of
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   746                       * addition of 1, w.r.t Seconds is very less.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   747                       */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   748                      RunningCounterValueTemp = (TickType)WDGM_PRV_C_ONE;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   749                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   750                  WdgM_ConfigSetPtr->PtrToRunningCounterValue[DeadlineIdx] = RunningCounterValueTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   751  #endif /* ((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_MCU)) */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   752              }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   753              else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   754              {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   755                  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   756                   * ReturnStatus should be ok for following condition
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   757                   * TRACE[SWS_WdgM_00354]Do not consider it as error when End Check point reached before Start check point or
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   758                   * when Deadline End Checkpoint is reached several times in a sequence.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   759                   * Running counter value == 0 & check point == stop
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   760                   * ReturnStatus = E_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   761                   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   762              }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   763          }/* End of for loop */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   764          SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   765  #if((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_OS))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   766  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   767          /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   768          * TRACE[BSW_SWS_AR4_0_R2_WatchDogManager_Ext-2862]
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   769          */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   770          if(Report_E_OsCounter_Det == TRUE)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   771          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   772              /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored, and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   773              (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_CHECKPOINT_REACHED_APIID, WDGM_E_OS_COUNTER);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   774          }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   775  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   776  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   777      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   778      else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   779      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   780          SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   781  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   782          /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored, and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   783          (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_CHECKPOINT_REACHED_APIID, WDGM_E_SEDEACTIVATED);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   784          *ReturnStatus = E_NOT_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   785  #endif /* ((WDGM_DEV_ERROR_DETECT) == (STD_ON)) */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   786      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   787  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   788  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   789  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   790  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   791  #if (WDGM_INTERNAL_GRAPH_CONFIGURED == STD_ON)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   792  /*******************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   793  * Name              :   WdgM_Prv_LogicalSupervisionCheckpointReached_v_Inl
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   794  * Description       :   Does the Internal Graph Logical Monitoring part of WdgM_CheckpointReached().
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   795  * Parameters[in]    :   SEID, CheckpointID
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   796  * Parameters[inout] :   ReturnStatus
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   797  * Limitations       :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   798  * ReturnType        :   Std_ReturnType
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   799  *******************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   800  LOCAL_INLINE Std_ReturnType WdgM_Prv_LogicalSupervisionCheckpointReached_v_Inl(VAR(WdgM_SupervisedEntityIdType,AUTOMATIC) SEID,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   801  VAR(WdgM_CheckpointIdType,AUTOMATIC) CheckpointID)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   802  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   803      VAR(uint16,AUTOMATIC) cntrDestCPs;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   804      VAR(uint16,AUTOMATIC) idxStartDestCPs;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   805      VAR(uint16,AUTOMATIC) idxCPProperty_givenCP;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   806      VAR(WdgM_PositionInGraph_ten,AUTOMATIC) posnInGraph_en;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   807      VAR(uint16,AUTOMATIC)  nrDestCheckpoints;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   808      VAR(Std_ReturnType,AUTOMATIC)  ReturnStatus;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   809  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   810      VAR(uint8,AUTOMATIC) ExpiredLocation;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   811      VAR(WdgM_CheckpointIdType,AUTOMATIC)  idLastReachedCheckpoint;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   812      VAR(WdgM_ModeType,AUTOMATIC)  Mode;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   813  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   814      ExpiredLocation = WDGM_RB_DEFAULT_EXPIREDLOCATION;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   815      idLastReachedCheckpoint = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   816      Mode = WDGM_RB_MAX_MODEID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   817  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   818      ReturnStatus = E_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   819  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   820      if(WdgM_SupervisedEntity[SEID].hasInternalGraph == TRUE)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   821      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   822          idxCPProperty_givenCP = WdgM_SupervisedEntity[SEID].idxInternalGraphCPProperty + CheckpointID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   823          posnInGraph_en = WdgM_InternalGraph_CPProperty[idxCPProperty_givenCP].posnInGraph_en;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   824          /*When reported CPID which do not belong to the current Internal graph no action should be taken hence this check is done
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   825           *TRACE[SWS_WdgM_00297]For any reported Checkpoint that does not belong to any Graph, then it
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   826           * shall be ignore and not update the result of the Logical Supervision for the Supervised Entity.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   827          if(posnInGraph_en != WDGM_POSNGRAPH_NONE_E)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   828          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   829  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   830              /* Lock introduced:
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   831               * 1.In WdgM_SupervisedEntityDyn we check for Local status deactivated,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   832               * if mode changes here and the reported Supervised entity becomes deactivated in the new mode then,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   833               * the reported checkpoint shall not be processed.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   834              /*TRACE[SWS_WdgM_00208] Since SEActive is False for DEACTIVATED, no supervision process is performed*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   835              SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   836              if ((WdgM_SupervisedEntityDyn[SEID].NewLocalStatus & WDGM_LOCAL_STATUS_DEACTIVATED) != WDGM_LOCAL_STATUS_DEACTIVATED)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   837              {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   838  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   839                  /* TRACE[SWS_WdgM_00332 and SWS_WdgM_00273] If the function WdgM_CheckpointReached the result correct, and
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   840                   * the Checkpoint is defined as a initial one, then the function WdgM_CheckpointReached shall set the
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   841                   * Activity Flag of the corresponding graph to true.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   842                  if(WdgM_SupervisedEntityDyn[SEID].flgActivity == FALSE)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   843                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   844                      if(posnInGraph_en == WDGM_POSNGRAPH_INITIAL_E)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   845                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   846                          WdgM_SupervisedEntityDyn[SEID].idLastReachedCheckpoint = CheckpointID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   847                          WdgM_SupervisedEntityDyn[SEID].flgActivity = TRUE;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   848                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   849                      /*Update the NewLocalStatus value as expired if
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   850                       * Reported Checkpoint is not an Initial Checkpoint and
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   851                       * Internal Graph is not active*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   852                      else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   853                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   854                          WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus | WDGM_LOCAL_STATUS_EXPIRED;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   855                          #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   856                              ExpiredLocation = WDGM_RB_FAILED_IN_LOGICAL_INTGRAPH_CPREACHED_GRAPHNOTSTARTED;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   857                              idLastReachedCheckpoint = WdgM_SupervisedEntityDyn[SEID].idLastReachedCheckpoint;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   858                              Mode = WdgM_Mode;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   859                          #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   860                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   861                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   862  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   863                  else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   864                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   865                      /* TRACE[SWS_WdgM_00246 and SWS_WdgM_00274] Iterate through all the transition
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   866                       * to find Reported checkpoint has valid transition
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   867                       * (i.e. Is it Successor of perviously reported Checkpoint) */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   868                      idxCPProperty_givenCP = WdgM_SupervisedEntity[SEID].idxInternalGraphCPProperty + WdgM_SupervisedEntityDyn[SEID].idLastReachedCheckpoint;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   869                      idxStartDestCPs = WdgM_InternalGraph_CPProperty[idxCPProperty_givenCP].idxDestCheckpoints;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   870                      nrDestCheckpoints = WdgM_InternalGraph_CPProperty[idxCPProperty_givenCP].nrDestCheckpoints;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   871                      for(cntrDestCPs=0;cntrDestCPs<nrDestCheckpoints;cntrDestCPs++)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   872                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   873                          if(WdgM_InternalGraph_DestCheckpoints[idxStartDestCPs + cntrDestCPs] == CheckpointID)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   874                          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   875                              WdgM_SupervisedEntityDyn[SEID].idLastReachedCheckpoint = CheckpointID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   876                              break;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   877                          }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   878                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   879                      /*Update the NewLocalStatus value as expired if
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   880                      * Reported Checkpoint has no valid transition and Internal Graph is active*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   881                      if(cntrDestCPs == nrDestCheckpoints)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   882                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   883                          WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus | WDGM_LOCAL_STATUS_EXPIRED;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   884                          #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   885                              ExpiredLocation = WDGM_RB_FAILED_IN_LOGICAL_INTGRAPH_CPREACHED_GRAPHSTARTED;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   886                              idLastReachedCheckpoint = WdgM_SupervisedEntityDyn[SEID].idLastReachedCheckpoint;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   887                              Mode = WdgM_Mode;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   888                          #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   889                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   890                      /* TRACE[SWS_WdgM_00331 and SWS_WdgM_00274] When the reported checkpoint is a final
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   891                       * checkpoint then deactivate corresponding Internal graph
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   892                       * (i.e. by setting SEID Activity Flag to false), hence this check is done.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   893                      else if (posnInGraph_en == WDGM_POSNGRAPH_FINAL_E)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   894                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   895                          WdgM_SupervisedEntityDyn[SEID].flgActivity = FALSE;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   896                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   897                      else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   898                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   899                          /*TRACE[SWS_WdgM_00274]If the reported Checkpoint is a successor of the stored Checkpoint within
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   900                           * the Graph, then the result of the Logical Supervision of the Supervised Entity is correct.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   901                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   902                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   903                  SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   904                  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   905                  if((ExpiredLocation == WDGM_RB_FAILED_IN_LOGICAL_INTGRAPH_CPREACHED_GRAPHNOTSTARTED) ||
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   906                          (ExpiredLocation == WDGM_RB_FAILED_IN_LOGICAL_INTGRAPH_CPREACHED_GRAPHSTARTED))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   907                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   908                      WdgM_Rb_FirstExpiredEntity(WDGM_PRV_C_ZERO, CheckpointID, idLastReachedCheckpoint,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   909                                                 SEID, ExpiredLocation, Mode);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   910                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   911                  #endif /*(WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   912              }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   913              else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   914              {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   915                  SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   916                  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   917                      /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   918                       * and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   919                      (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_CHECKPOINT_REACHED_APIID, WDGM_E_SEDEACTIVATED);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   920                      ReturnStatus = E_NOT_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   921                  #endif /* ((WDGM_DEV_ERROR_DETECT) == (STD_ON)) */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   922              }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   923          }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   924      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   925      return ReturnStatus;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   926  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   927  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   928  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   929  /************************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   930   * Name              :   WdgM_Prv_UpdateAliveSupervisionDyn_v_Inl
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   931   * Description       :   Update the AliveSupervision Variables at mode change
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   932   * Parameters[in]    :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   933   * Limitations       :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   934   * Return Value      :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   935   ************************************************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   936  LOCAL_INLINE void WdgM_Prv_UpdateAliveSupervisionDyn_v_Inl(void)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   937  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   938  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   939      /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   940       * Disable the Alive Supervision upto next WdgM_MainFunction call to synchronise the expected indication and
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   941       * the new Supervision Cycle. Other variables are not required to be reset here as anyway in WdgM_MainFunction
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   942       * it will be reinitialized at the time of start of Alive Supervision, when WdgM_AliveSupervisionActive
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   943       * becomes true.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   944       *
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   945       */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   946      WdgM_AliveSupervisionActive = FALSE;
	movh.a	a15,#@his(WdgM_AliveSupervisionActive)
	lea	a15,[a15]@los(WdgM_AliveSupervisionActive)
.L451:
	mov	d15,#0
.L452:
	st.b	[a15],d15
.L236:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   947  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   948  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   949  #if ((WDGM_MAX_DEADLINE_SUPERVISIONS) > (WDGM_PRV_C_ZERO))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   950  /************************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   951   * Name              :   WdgM_Prv_UpdateDeadlineSupervisionDyn_v_Inl
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   952   * Description       :   Update the Checkpoint Linking to the different Deadline Supervisions in current mode
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   953   * Parameters[in]    :   Mode
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   954   * Limitations       :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   955   * Return Value      :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   956   ************************************************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   957  LOCAL_INLINE void WdgM_Prv_UpdateDeadlineSupervisionDyn_v_Inl(VAR(WdgM_ModeType,AUTOMATIC) Mode)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   958  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   959      VAR(uint16, AUTOMATIC) OldIdx;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   960      VAR(uint16, AUTOMATIC)NewIdx;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   961      VAR(uint16, AUTOMATIC)DeadlineIdx;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   962      VAR(uint16, AUTOMATIC)Offset;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   963      VAR(uint16, AUTOMATIC)SingleCheckpointDeadlineSupervisionSize;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   964      VAR(WdgM_SupervisedEntityIdType, AUTOMATIC) SEID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   965      VAR(WdgM_CheckpointIdType, AUTOMATIC) CheckpointID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   966  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   967      VAR(TickType, AUTOMATIC)   RunningCounterValueTemp[WDGM_MAX_DEADLINE_SUPERVISIONS];
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   968      P2CONST(WdgM_DeadlineSupervisionType, AUTOMATIC, WDGM_APPL_CONST) OldDeadlineSupervisionPtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   969      P2CONST(WdgM_DeadlineSupervisionType, AUTOMATIC, WDGM_APPL_CONST) NewDeadlineSupervisionPtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   970  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   971      /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   972       * Transfer all the Running Counter values for the start checkpoints from previous Mode to
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   973       * current mode for all Deadline supervisions which were active in previous mode and are active
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   974       * in current mode also.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   975       */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   976  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   977      OldDeadlineSupervisionPtr = WdgM_ConfigSetPtr->PtrToMode[WdgM_Mode].PtrToDeadlineSupervision;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   978      NewDeadlineSupervisionPtr = WdgM_ConfigSetPtr->PtrToMode[Mode].PtrToDeadlineSupervision;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   979  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   980      for(OldIdx = WDGM_PRV_C_ZERO; OldIdx < WdgM_ConfigSetPtr->PtrToMode[WdgM_Mode].NoOfDeadlineSupervision; OldIdx++)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   981      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   982          RunningCounterValueTemp[OldIdx] = WdgM_ConfigSetPtr->PtrToRunningCounterValue[OldIdx];
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   983          WdgM_ConfigSetPtr->PtrToRunningCounterValue[OldIdx] = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   984      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   985  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   986      for(NewIdx = WDGM_PRV_C_ZERO; NewIdx < WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfDeadlineSupervision; NewIdx++)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   987      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   988          for(OldIdx = WDGM_PRV_C_ZERO; OldIdx < WdgM_ConfigSetPtr->PtrToMode[WdgM_Mode].NoOfDeadlineSupervision; OldIdx++)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   989          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   990              if((OldDeadlineSupervisionPtr[OldIdx].StartCheckpointId == NewDeadlineSupervisionPtr[NewIdx].StartCheckpointId)&&
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   991                  (OldDeadlineSupervisionPtr[OldIdx].StopCheckpointId == NewDeadlineSupervisionPtr[NewIdx].StopCheckpointId)&&
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   992                  (OldDeadlineSupervisionPtr[OldIdx].SupervisedEntityId == NewDeadlineSupervisionPtr[NewIdx].SupervisedEntityId))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   993              {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   994                  /* MR12 RULE 9.1 VIOLATION: Unset Values are not used in the range NoOfDeadlineSupervision to "WDGM_MAX_DEADLINE_SUPERVISIONS". */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   995                  WdgM_ConfigSetPtr->PtrToRunningCounterValue[NewIdx] = RunningCounterValueTemp[OldIdx];
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   996              }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   997          }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   998      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   999  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1000      Offset = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1001      NewDeadlineSupervisionPtr = WdgM_ConfigSetPtr->PtrToMode[Mode].PtrToDeadlineSupervision;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1002  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1003      for(SEID = WDGM_PRV_C_ZERO; SEID < WDGM_NO_OF_SUPERVISED_ENTITIES; SEID++)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1004      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1005          for(CheckpointID = WDGM_PRV_C_ZERO; CheckpointID < WdgM_SupervisedEntity[SEID].NoOfCheckpoint; CheckpointID++)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1006          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1007              SingleCheckpointDeadlineSupervisionSize = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1008              WdgM_SupervisedEntity[SEID].PtrToCheckpoint[CheckpointID].PtrToCheckpointDyn->PtrToDeadlineIndices =
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1009                      &WdgM_ConfigSetPtr->PtrToDeadlineIndices[Offset];
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1010  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1011              for(DeadlineIdx = WDGM_PRV_C_ZERO; DeadlineIdx < WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfDeadlineSupervision; DeadlineIdx++)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1012              {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1013  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1014                  if(((NewDeadlineSupervisionPtr[DeadlineIdx].StartCheckpointId == CheckpointID)||
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1015                          (NewDeadlineSupervisionPtr[DeadlineIdx].StopCheckpointId == CheckpointID))&&
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1016                          (NewDeadlineSupervisionPtr[DeadlineIdx].SupervisedEntityId == SEID))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1017                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1018                      WdgM_ConfigSetPtr->PtrToDeadlineIndices[Offset] = DeadlineIdx; /* Store this DeadlineIdx (valid)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1019                      Offset++;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1020                      SingleCheckpointDeadlineSupervisionSize++;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1021                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1022              }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1023  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1024              WdgM_SupervisedEntity[SEID].PtrToCheckpoint[CheckpointID].PtrToCheckpointDyn->NoOfDeadlineSupervision = SingleCheckpointDeadlineSupervisionSize;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1025          }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1026      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1027  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1028  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1029  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1030  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1031  /************************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1032   * Name              :   WdgM_Prv_UpdateTriggerDyn_v_Inl
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1033   * Description       :   Update the Trigger condition and Wdg Mode in current mode
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1034   * Parameters[in]    :   Mode
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1035   * Parameters[inout] :   ReturnStatus
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1036   * Limitations       :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1037   * Return Value      :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1038   ************************************************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1039  LOCAL_INLINE void WdgM_Prv_UpdateTriggerDyn_v_Inl(VAR(WdgM_ModeType,AUTOMATIC) Mode, P2VAR(Std_ReturnType,AUTOMATIC,WDGM_APPL_DATA)ReturnStatus)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1040  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1041      VAR(uint8, AUTOMATIC) triggerIdx_u8;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1042      P2CONST(WdgM_TriggerType, AUTOMATIC, WDGM_APPL_CONST) TriggerPtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1043      *ReturnStatus = E_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1044      /* Trigger the Watchdogs for new trigger conditionvalue */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1045  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1046      for(triggerIdx_u8 = WDGM_PRV_C_ZERO; triggerIdx_u8 < WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfTrigger; triggerIdx_u8++)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1047      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1048          if(WdgM_ConfigSetPtr->PtrToMode[Mode].PtrToTrigger[triggerIdx_u8].WdgMode != WDGIF_OFF_MODE)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1049          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1050              WdgIf_SetTriggerCondition(WdgM_ConfigSetPtr->PtrToMode[Mode].PtrToTrigger[triggerIdx_u8].DeviceIdx,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1051                      WdgM_ConfigSetPtr->PtrToMode[Mode].PtrToTrigger[triggerIdx_u8].TriggerConditionValue);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1052          }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1053      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1054  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1055      /* Setting the Wdg driver Modes */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1056      TriggerPtr = WdgM_ConfigSetPtr->PtrToMode[Mode].PtrToTrigger;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1057      for(triggerIdx_u8= WDGM_PRV_C_ZERO; triggerIdx_u8<WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfTrigger; triggerIdx_u8++)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1058      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1059          *ReturnStatus = WdgIf_SetMode(TriggerPtr[triggerIdx_u8].DeviceIdx, TriggerPtr[triggerIdx_u8].WdgMode);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1060          if (*ReturnStatus != E_OK)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1061          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1062              break;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1063          }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1064      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1065  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1066  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1067  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1068  /************************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1069   * Name              :   WdgM_Prv_UpdateSupervisedEntityDyn_v_Inl
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1070   * Description       :   Update the WdgM_SupervisedEntityDyn Status of All the Supervised Entity in current mode
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1071   * Parameters[in]    :   Mode
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1072   * Limitations       :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1073   * Return Value      :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1074   ************************************************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1075  LOCAL_INLINE void WdgM_Prv_UpdateSupervisedEntityDyn_v_Inl(VAR(WdgM_ModeType,AUTOMATIC) Mode)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1076  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1077      VAR(uint16, AUTOMATIC) ctr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1078      VAR(WdgM_SupervisedEntityIdType, AUTOMATIC) SEID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1079      VAR(WdgM_SupervisedEntityIdType, AUTOMATIC) LspIdx;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1080      P2CONST(WdgM_AliveSupervisionType, AUTOMATIC, WDGM_APPL_CONST) AliveSupervisionPtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1081      P2CONST(WdgM_LocalStatusParamsType, AUTOMATIC, WDGM_APPL_CONST) LocalStatusParamsPtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1082  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1083      AliveSupervisionPtr = WdgM_ConfigSetPtr->PtrToMode[Mode].PtrToAliveSupervision;
	sha	d2,d8,#5
.L453:
	lea	a4,[a2]16
	ld.a	a15,[a4]
.L454:
	addsc.a	a15,a15,d2,#0
.L455:
	ld.a	a5,[a15]16
.L326:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1084      LocalStatusParamsPtr = WdgM_ConfigSetPtr->PtrToMode[Mode].PtrToLocalStatusParams;
	ld.a	a6,[a15]24
.L327:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1085  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1086      for(SEID = WDGM_PRV_C_ZERO; SEID < WDGM_NO_OF_SUPERVISED_ENTITIES; SEID++)
	mov	d3,#0
.L328:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1086      for(SEID = WDGM_PRV_C_ZERO; SEID < WDGM_NO_OF_SUPERVISED_ENTITIES; SEID++)      (inlined)
	j	.L36
.L37:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1087      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1088          for(LspIdx = WDGM_PRV_C_ZERO; LspIdx < WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfLocalStatusParams; LspIdx++)
	mov	d0,#0
.L329:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1089          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1090              if(LocalStatusParamsPtr[LspIdx].SupervisedEntityId == SEID)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1091              {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1092                  if(WdgM_SupervisedEntityDyn[SEID].OldLocalStatus == WDGM_LOCAL_STATUS_DEACTIVATED)
	movh.a	a15,#@his(WdgM_SupervisedEntityDyn)
	lea	a15,[a15]@los(WdgM_SupervisedEntityDyn)
.L456:
	mul	d15,d3,#12
	addsc.a	a15,a15,d15,#0
.L457:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1088          for(LspIdx = WDGM_PRV_C_ZERO; LspIdx < WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfLocalStatusParams; LspIdx++)      (inlined)
	j	.L38
.L39:
	addsc.a	a2,a6,d0,#1
.L458:
	ld.bu	d15,[a2]1
.L459:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1090              if(LocalStatusParamsPtr[LspIdx].SupervisedEntityId == SEID)      (inlined)
	jne	d15,#0,.L40
.L460:
	ld.bu	d15,[a15]11
.L461:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1092                  if(WdgM_SupervisedEntityDyn[SEID].OldLocalStatus == WDGM_LOCAL_STATUS_DEACTIVATED)      (inlined)
	jne	d15,#4,.L41
.L462:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1093                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1094                      /* TRACE[WDGM209] IF local status is DEACTIVATED and SetMode changes
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1095                       * SE to ACTIVE, local status of SE is OK*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1096                      /* TRACE[WDGM268] Transition: 9 : Local status OK if active:
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1097                       * When SetMode changes mode.. SE's Set to OK here*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1098                      /* SE is ACTIVE and local status is DEACTIVATED then locak status is OK */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1099                      /* TRACE[WDGM268] WdgM Init Successful hence set the local Mode to OK*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1100                      WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WDGM_LOCAL_STATUS_OK;
	mov	d15,#0
.L463:
	st.b	[a15]10,d15
.L464:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1101                      WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleTol = LocalStatusParamsPtr[LspIdx].FailedAliveSupervisionRefCycleTol;
	ld.bu	d15,[a2]
.L465:
	st.b	[a15]1,d15

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1092                  if(WdgM_SupervisedEntityDyn[SEID].OldLocalStatus == WDGM_LOCAL_STATUS_DEACTIVATED)      (inlined)
.L41:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1104                  break; /* This break is very important in order to detect whether SEID is active or not (in below check)..!! */      (inlined)
	j	.L42

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1090              if(LocalStatusParamsPtr[LspIdx].SupervisedEntityId == SEID)      (inlined)
.L40:
	add	d0,#1
.L330:
	extr.u	d0,d0,#0,#8

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1088          for(LspIdx = WDGM_PRV_C_ZERO; LspIdx < WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfLocalStatusParams; LspIdx++)      (inlined)
.L38:
	ld.a	a2,[a4]
.L466:
	addsc.a	a2,a2,d2,#0
.L467:
	ld.hu	d1,[a2]12
.L468:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1088          for(LspIdx = WDGM_PRV_C_ZERO; LspIdx < WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfLocalStatusParams; LspIdx++)      (inlined)
	jlt.u	d0,d1,.L39

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1117          if((LspIdx == WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfLocalStatusParams)&&      (inlined)
.L42:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1102                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1103  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1104                  break; /* This break is very important in order to detect whether SEID is active or not (in below check)..!! */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1105              }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1106          }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1107  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1108          /* TRACE[WDGM269] Change local status DEACTIVATED if not active*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1109          /* TRACE[WDGM291]  If local state is FAILED and Set mode has changed
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1110           * the Mode to Deactivate then change local status to DEACTIVATED*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1111          /* TRACE[WDGM207] If local state is OK and Set mode has changed
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1112           * the Mode to Deactivate then change local status to DEACTIVATED*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1113          /* TRACE[WDGM208] : Transition 12, 7, 8 */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1114          /* If SE is NOT ACTIVE and local state is NOT EXPIRED then change local status to DEACTIVATED */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1115          /* TRACE[SWS_WdgM_00296] Init flgActivity to FALSE and idLastReachedCheckpoint to zero
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1116           * for WdgM_SupervisedEntityDyn is NOT ACTIVE*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1117          if((LspIdx == WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfLocalStatusParams)&&
	ld.a	a2,[a4]
.L469:
	addsc.a	a2,a2,d2,#0
.L470:
	ld.hu	d15,[a2]12
.L471:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1117          if((LspIdx == WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfLocalStatusParams)&&      (inlined)
	jne	d15,d0,.L43
.L472:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1118                  ((WdgM_SupervisedEntityDyn[SEID].OldLocalStatus & WDGM_LOCAL_STATUS_EXPIRED) != WDGM_LOCAL_STATUS_EXPIRED))
	ld.bu	d15,[a15]11
.L473:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1118                  ((WdgM_SupervisedEntityDyn[SEID].OldLocalStatus & WDGM_LOCAL_STATUS_EXPIRED) != WDGM_LOCAL_STATUS_EXPIRED))      (inlined)
	jnz.t	d15:1,.L44
.L474:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1119          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1120              WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WDGM_LOCAL_STATUS_DEACTIVATED;
	mov	d15,#4
.L475:
	st.b	[a15]10,d15
.L476:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1121              WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleTol = WDGM_PRV_C_ZERO;
	mov	d15,#0
.L477:
	st.b	[a15]1,d15

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1117          if((LspIdx == WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfLocalStatusParams)&&      (inlined)
.L44:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1118                  ((WdgM_SupervisedEntityDyn[SEID].OldLocalStatus & WDGM_LOCAL_STATUS_EXPIRED) != WDGM_LOCAL_STATUS_EXPIRED))      (inlined)
.L43:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1122  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1123              #if (WDGM_INTERNAL_GRAPH_CONFIGURED == STD_ON)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1124                  WdgM_SupervisedEntityDyn[SEID].flgActivity = FALSE;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1125                  WdgM_SupervisedEntityDyn[SEID].idLastReachedCheckpoint = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1126              #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1127          }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1128  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1129  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1130          for(ctr = WDGM_PRV_C_ZERO; ctr < WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfAliveSupervision; ctr++)
	mov	d0,#0
.L331:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1130          for(ctr = WDGM_PRV_C_ZERO; ctr < WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfAliveSupervision; ctr++)      (inlined)
	j	.L45
.L46:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1131          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1132              if(AliveSupervisionPtr[ctr].SupervisedEntityId == SEID)
	mul	d15,d0,#10
	addsc.a	a2,a5,d15,#0
.L478:
	ld.bu	d15,[a2]5
.L479:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1132              if(AliveSupervisionPtr[ctr].SupervisedEntityId == SEID)      (inlined)
	jne	d15,#0,.L47
.L480:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1134                  break;  /* This break is very important in order to detect whether Alive Supervision is configured for this SEID ..!! */      (inlined)
	j	.L48

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1132              if(AliveSupervisionPtr[ctr].SupervisedEntityId == SEID)      (inlined)
.L47:
	add	d0,#1
.L332:
	extr.u	d0,d0,#0,#16

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1130          for(ctr = WDGM_PRV_C_ZERO; ctr < WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfAliveSupervision; ctr++)      (inlined)
.L45:
	ld.a	a2,[a4]
.L481:
	addsc.a	a2,a2,d2,#0
.L482:
	ld.hu	d15,[a2]8
.L483:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1130          for(ctr = WDGM_PRV_C_ZERO; ctr < WdgM_ConfigSetPtr->PtrToMode[Mode].NoOfAliveSupervision; ctr++)      (inlined)
	jlt.u	d0,d15,.L46

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1138          WdgM_SupervisedEntityDyn[SEID].AliveSupervisionIdx = ctr; /* In case Alive supervision not configured AliveSupervisionIdx      (inlined)
.L48:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1133              {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1134                  break;  /* This break is very important in order to detect whether Alive Supervision is configured for this SEID ..!! */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1135              }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1136          }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1137  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1138          WdgM_SupervisedEntityDyn[SEID].AliveSupervisionIdx = ctr; /* In case Alive supervision not configured AliveSupervisionIdx
	st.h	[a15]8,d0
.L484:
	add	d3,#1

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	  1086      for(SEID = WDGM_PRV_C_ZERO; SEID < WDGM_NO_OF_SUPERVISED_ENTITIES; SEID++)      (inlined)
.L36:
	jeq	d3,#0,.L37
.L239:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   380          {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   381              /* Deadline supervision */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   382              /* Lock introduced:
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   383              * 1. If Mode change is a relevent request we perform update of deadline timings information,
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   384              * which is mode dependent. Hence placed under a lock. so that no CPR occurs here.
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   385              * 2. Update of Global mode shoule be a one time continous activity when set mode operation is valid.
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   386              * 3. The Supervised information is updated in WdgM_Prv_UpdateSupervisedEntityDyn_v_Inl hence in lock
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   387              * 3. Flag update for SetMode indication if not in a lock will
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   388              * cause a problem at End of WdgM_MainFunction. This will cause missing of TRUE to FALSE change and not reset
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   389              */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   390              SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   391              /* Alive supervision */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   392              WdgM_Prv_UpdateAliveSupervisionDyn_v_Inl();
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   393  #if ((WDGM_MAX_DEADLINE_SUPERVISIONS) > (WDGM_PRV_C_ZERO))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   394              WdgM_Prv_UpdateDeadlineSupervisionDyn_v_Inl(Mode);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   395  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   396              /* WDGM317:RFC request in AutoSAR bugzilla Id : 55705 */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   397              WdgM_Prv_UpdateSupervisedEntityDyn_v_Inl(Mode);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   398              WdgM_Mode = Mode;
	movh.a	a15,#@his(WdgM_Mode)
	lea	a15,[a15]@los(WdgM_Mode)
.L485:
	st.b	[a15],d8
.L486:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   399              SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   400              /* LocalStatusParams */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   401  #if((WDGM_RTE_DISABLED) == (STD_OFF))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   402              if(SchM_Mode_WdgM_Current_WdgMSupervisionCycle() != WdgM_ConfigSetPtr->PtrToMode[Mode].SchMWdgMSupervisionCycle)
	sha	d8,#5
.L313:
	ld.a	a15,[a4]
.L487:
	addsc.a	a15,a15,d8,#0
.L488:
	ld.bu	d15,[a15]2
.L489:
	jeq	d15,#0,.L49
.L49:
	j	.L50
.L35:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   403              {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   404                  SchM_Switch_WdgM_WdgMSupervisionCycle(WdgM_ConfigSetPtr->PtrToMode[Mode].SchMWdgMSupervisionCycle);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   405              }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   406  #endif /*(WDGM_RTE_DISABLED == STD_OFF)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   407          }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   408          /* SWS_WdgM_00186 & SWS_WdgM_00142 Returns E_NOT_OK when a call to WdgIf_SetMode service fails*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   409          else
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   410         {   /* TRACE[WDGM142] Watchdog Manager shall report to the Diagnostic Event Manager an error with the value WDGM_E_SET_MODE */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   411              SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   412              /* WDGM317: RFC request in AutoSAR bugzilla Id : 55705 */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   413              WdgM_Prv_SetMode_GlobalStatus = WDGM_GLOBAL_STATUS_STOPPED;
	movh.a	a15,#@his(WdgM_Prv_SetMode_GlobalStatus)
	lea	a15,[a15]@los(WdgM_Prv_SetMode_GlobalStatus)
.L490:
	mov	d15,#3
.L491:
	st.b	[a15],d15
.L492:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   414              SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   415  #if((WDGM_DEM_ALIVE_SUPERVISION_REPORT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   416              Dem_ReportErrorStatus(WdgM_ConfigSetPtr->ErrorSetMode, DEM_EVENT_STATUS_FAILED);
	ld.hu	d4,[a2]6
.L493:
	mov	d5,#1
	call	Dem_ReportErrorStatus
.L50:
.L27:
.L24:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   417  #endif /*((WDGM_DEM_ALIVE_SUPERVISION_REPORT) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   418          }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   419      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   420      return (ReturnStatus);
	ld.bu	d2,[a10]
.L494:
	j	.L51

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   421  }
.L51:
.L23:
.L19:
.L17:
	ret
.L217:
	
__WdgM_SetMode_function_end:
	.size	WdgM_SetMode,__WdgM_SetMode_function_end-WdgM_SetMode
.L166:
	; End of function
	
	.sdecl	'.text.WdgM.WdgM_GetMode',code,cluster('WdgM_GetMode')
	.sect	'.text.WdgM.WdgM_GetMode'
	.align	2
	
	.global	WdgM_GetMode

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   422  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   423  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   424  /*******************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   425  * Name              :   WdgM_GetMode
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   426  * Description       :   Returns the current mode of the Watchdog Manager.
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   427  * Parameters[out]   :   Mode
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   428  * Limitations       :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   429  * ReturnType        :   Std_ReturnType
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   430  *******************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   431  /*[WDGM168] Implementation of WdgM_GetMode*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   432  /* TODO : TRACE[WDGM170] yet to me mapped*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   433  FUNC(Std_ReturnType, WDGM_CODE_FAST) WdgM_GetMode (P2VAR(WdgM_ModeType,AUTOMATIC,WDGM_APPL_DATA)Mode)
; Function WdgM_GetMode
.L145:
WdgM_GetMode:	.type	func

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   434  {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   435  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   436      /*TRACE[WDGM253] If WdgM is not intilized GetMode should not be service anymore*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   437      if (WdgM_GlobalStatus == WDGM_GLOBAL_STATUS_DEACTIVATED) /*WDGM253*/
	movh.a	a15,#@his(WdgM_GlobalStatus)
	lea	a15,[a15]@los(WdgM_GlobalStatus)
	ld.bu	d15,[a15]
.L499:
	jne	d15,#4,.L52
.L500:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   438      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   439          /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored, and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   440          (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_GET_MODE_APIID , WDGM_E_NO_INIT);
	mov	d4,#13
.L501:
	mov	d5,#0
.L502:
	mov	d6,#11
.L503:
	mov	d7,#16
	call	Det_ReportError
.L333:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   441          return E_NOT_OK;
	mov	d2,#1
.L504:
	j	.L53
.L52:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   442      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   443      /*TRACE[WDGM254] Check for null parameters*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   444      if (Mode == NULL_PTR)
	jnz.a	a4,.L54
.L505:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   445      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   446          /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored, and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   447          (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_GET_MODE_APIID, WDGM_E_INV_POINTER);
	mov	d4,#13
.L506:
	mov	d5,#0
.L507:
	mov	d6,#11
.L508:
	mov	d7,#20
	call	Det_ReportError
.L334:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   448          return E_NOT_OK;
	mov	d2,#1
.L509:
	j	.L55
.L54:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   449      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   450  #endif /*((WDGM_DEV_ERROR_DETECT) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   451      *Mode = WdgM_Mode;
	movh.a	a15,#@his(WdgM_Mode)
	lea	a15,[a15]@los(WdgM_Mode)
	ld.bu	d15,[a15]
.L510:
	st.b	[a4],d15
.L511:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   452      return E_OK;
	mov	d2,#0
.L512:
	j	.L56

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   453  }
.L56:
.L55:
.L53:
	ret
.L250:
	
__WdgM_GetMode_function_end:
	.size	WdgM_GetMode,__WdgM_GetMode_function_end-WdgM_GetMode
.L171:
	; End of function
	
	.sdecl	'.text.WdgM.WdgM_GetLocalStatus',code,cluster('WdgM_GetLocalStatus')
	.sect	'.text.WdgM.WdgM_GetLocalStatus'
	.align	2
	
	.global	WdgM_GetLocalStatus

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   454  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   455  /*******************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   456  * Name              :   WdgM_GetLocalStatus
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   457  * Description       :   Returns the supervision status of an individual Supervised Entity.
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   458  * Parameters[in]    :   SEID
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   459  * Parameters[out]   :   Status
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   460  * Limitations       :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   461  * ReturnType        :   Std_ReturnType
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   462  *******************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   463  /* TRACE[WDGM169] Implementation of WdgM_GetLocalStatus*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   464  FUNC(Std_ReturnType, WDGM_CODE_FAST)  WdgM_GetLocalStatus(VAR(WdgM_SupervisedEntityIdType,AUTOMATIC) SEID,
; Function WdgM_GetLocalStatus
.L147:
WdgM_GetLocalStatus:	.type	func

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   465      P2VAR(WdgM_LocalStatusType,AUTOMATIC,WDGM_APPL_DATA)Status)
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   466  {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   467      /* TRACE[WDGM171] Exclude some checks based on the flags set*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   468  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   469      /* TRACE[WDGM257] Check if WdgM is initilized*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   470      if (WdgM_GlobalStatus == WDGM_GLOBAL_STATUS_DEACTIVATED)
	movh.a	a15,#@his(WdgM_GlobalStatus)
	lea	a15,[a15]@los(WdgM_GlobalStatus)
	ld.bu	d15,[a15]
.L517:
	jne	d15,#4,.L57
.L518:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   471      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   472          /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored, and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   473          (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_GET_LOCAL_STATUS_APIID , WDGM_E_NO_INIT);
	mov	d4,#13
.L335:
	mov	d5,#0
.L519:
	mov	d6,#12
.L520:
	mov	d7,#16
	call	Det_ReportError
.L336:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   474          return E_NOT_OK;
	mov	d2,#1
.L521:
	j	.L58
.L57:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   475      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   476      /* TRACE[WDGM172] Check for valid SEID*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   477      if (SEID >= WDGM_NO_OF_SUPERVISED_ENTITIES)
	jeq	d4,#0,.L59
.L522:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   478      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   479          /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored, and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   480          (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_GET_LOCAL_STATUS_APIID , WDGM_E_PARAM_SEID);
	mov	d4,#13
.L337:
	mov	d5,#0
.L523:
	mov	d6,#12
.L524:
	mov	d7,#19
	call	Det_ReportError
.L338:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   481          return E_NOT_OK;
	mov	d2,#1
.L525:
	j	.L60
.L59:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   482      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   483      /* TRACE[WDGM257] Check for valid pointer*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   484      if (Status == NULL_PTR)
	jnz.a	a4,.L61
.L526:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   485      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   486          /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored, and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   487          (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_GET_LOCAL_STATUS_APIID, WDGM_E_INV_POINTER);
	mov	d4,#13
.L339:
	mov	d5,#0
.L527:
	mov	d6,#12
.L528:
	mov	d7,#20
	call	Det_ReportError
.L340:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   488          return E_NOT_OK;
	mov	d2,#1
.L529:
	j	.L62
.L61:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   489      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   490  #endif /*((WDGM_DEV_ERROR_DETECT) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   491  	/*Interrupt lock: The fetch from a structure could be a non atomic operation*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   492      SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   493      *Status = WdgM_SupervisedEntityDyn[SEID].OldLocalStatus;
	movh.a	a15,#@his(WdgM_SupervisedEntityDyn)
	lea	a15,[a15]@los(WdgM_SupervisedEntityDyn)
.L530:
	mul	d15,d4,#12
	addsc.a	a15,a15,d15,#0
.L531:
	ld.bu	d15,[a15]11
.L532:
	st.b	[a4],d15
.L533:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   494      SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   495      return E_OK;
	mov	d2,#0
.L534:
	j	.L63

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   496  }
.L63:
.L62:
.L60:
.L58:
	ret
.L253:
	
__WdgM_GetLocalStatus_function_end:
	.size	WdgM_GetLocalStatus,__WdgM_GetLocalStatus_function_end-WdgM_GetLocalStatus
.L176:
	; End of function
	
	.sdecl	'.text.WdgM.WdgM_GetGlobalStatus',code,cluster('WdgM_GetGlobalStatus')
	.sect	'.text.WdgM.WdgM_GetGlobalStatus'
	.align	2
	
	.global	WdgM_GetGlobalStatus

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   497  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   498  /*******************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   499  * Name              :   WdgM_GetGlobalStatus
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   500  * Description       :   Returns the global supervision status of the Watchdog Manager.
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   501  * Parameters[out]   :   Status
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   502  * Limitations       :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   503  * ReturnType        :   Std_ReturnType
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   504  *******************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   505  /* TRACE[WDGM175] Implementation of WdgM_GetGlobalStatus*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   506  /* TODO: TRACE[WDGM258] yet to be mapped */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   507  FUNC(Std_ReturnType, WDGM_CODE_FAST)  WdgM_GetGlobalStatus(P2VAR(WdgM_GlobalStatusType,AUTOMATIC,WDGM_APPL_DATA)Status)
; Function WdgM_GetGlobalStatus
.L149:
WdgM_GetGlobalStatus:	.type	func

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   508  {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   509  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   510      /* TRACE[WDGM176] Check if WdgM is Initilized*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   511      if (WdgM_GlobalStatus == WDGM_GLOBAL_STATUS_DEACTIVATED)
	movh.a	a15,#@his(WdgM_GlobalStatus)
	lea	a15,[a15]@los(WdgM_GlobalStatus)
	ld.bu	d15,[a15]
.L539:
	jne	d15,#4,.L64
.L540:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   512      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   513          /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored, and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   514          (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_GET_GLOBAL_STATUS_APIID , WDGM_E_NO_INIT);
	mov	d4,#13
.L541:
	mov	d5,#0
.L542:
	mov	d6,#13
.L543:
	mov	d7,#16
	call	Det_ReportError
.L341:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   515          return E_NOT_OK;
	mov	d2,#1
.L544:
	j	.L65
.L64:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   516      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   517      /* TRACE[WDGM344] Check if status is a Null Pointer*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   518      if (Status == NULL_PTR)
	jnz.a	a4,.L66
.L545:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   519      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   520          /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored, and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   521          (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_GET_GLOBAL_STATUS_APIID, WDGM_E_INV_POINTER);
	mov	d4,#13
.L546:
	mov	d5,#0
.L547:
	mov	d6,#13
.L548:
	mov	d7,#20
	call	Det_ReportError
.L342:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   522          return E_NOT_OK;
	mov	d2,#1
.L549:
	j	.L67
.L66:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   523      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   524  #endif /*((WDGM_DEV_ERROR_DETECT) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   525  	/* No Lock: 8 bit access is assumed to be atomic*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   526      *Status = WdgM_GlobalStatus;
	st.b	[a4],d15
.L550:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   527      return E_OK;
	mov	d2,#0
.L551:
	j	.L68

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   528  }
.L68:
.L67:
.L65:
	ret
.L257:
	
__WdgM_GetGlobalStatus_function_end:
	.size	WdgM_GetGlobalStatus,__WdgM_GetGlobalStatus_function_end-WdgM_GetGlobalStatus
.L181:
	; End of function
	
	.sdecl	'.text.WdgM.WdgM_PerformReset',code,cluster('WdgM_PerformReset')
	.sect	'.text.WdgM.WdgM_PerformReset'
	.align	2
	
	.global	WdgM_PerformReset

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   529  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   530  /*******************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   531  * Name              :   WdgM_PerformReset
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   532  * Description       :   Instructs the Watchdog Manager to cause a watchdog reset.
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   533  * Parameters[in]    :   void
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   534  * Limitations       :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   535  * ReturnType        :   void
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   536  *******************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   537  /* TRACE[WDGM264] Implementation of WdgM_PerformReset*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   538  /* TODO: TRACE[WDGM233] not yet mapped */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   539  FUNC(void, WDGM_CODE_FAST) WdgM_PerformReset(void)
; Function WdgM_PerformReset
.L151:
WdgM_PerformReset:	.type	func

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   540  {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   541  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   542      /* TRACE[WDGM270] Check for WdgM is initilized*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   543      if (WdgM_GlobalStatus == WDGM_GLOBAL_STATUS_DEACTIVATED)
	movh.a	a15,#@his(WdgM_GlobalStatus)
	lea	a15,[a15]@los(WdgM_GlobalStatus)
	ld.bu	d15,[a15]
.L556:
	jne	d15,#4,.L69
.L557:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   544      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   545          /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored, and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   546          (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_PERFORM_RESET_APIID , WDGM_E_NO_INIT);
	mov	d4,#13
.L558:
	mov	d5,#0
.L559:
	mov	d6,#15
.L560:
	mov	d7,#16
	call	Det_ReportError
.L561:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   547          return;
	j	.L70
.L69:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   548      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   549  #endif /*((WDGM_DEV_ERROR_DETECT) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   550  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   551      /* TRACE[WDGM232] Set trigger for all configured to zero */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   552      /* Deactived so that WdgM Main Function in the next cycle will set value to Zero*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   553      SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   554      WdgM_GlobalStatus = WDGM_GLOBAL_STATUS_DEACTIVATED;
	mov	d15,#4
.L562:
	st.b	[a15],d15
.L563:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   555      SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   556      WdgM_Prv_SetTriggerCondition(WDGM_GLOBAL_STATUS_DEACTIVATED);
	mov	d4,#4
	call	WdgM_Prv_SetTriggerCondition
.L564:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   557      return;
	j	.L71

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   558  }
.L71:
.L70:
	ret
.L260:
	
__WdgM_PerformReset_function_end:
	.size	WdgM_PerformReset,__WdgM_PerformReset_function_end-WdgM_PerformReset
.L186:
	; End of function
	
	.sdecl	'.text.WdgM.WdgM_GetFirstExpiredSEID',code,cluster('WdgM_GetFirstExpiredSEID')
	.sect	'.text.WdgM.WdgM_GetFirstExpiredSEID'
	.align	2
	
	.global	WdgM_GetFirstExpiredSEID

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   559  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   560  #define WDGM_STOP_SEC_CODE_FAST
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   561  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   562  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   563  #define WDGM_START_SEC_CODE_SLOW
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   564  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   565  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   566  /*******************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   567  * Name              :   WdgM_GetFirstExpiredSEID
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   568  * Description       :   Returns SEID that first reached the state WDGM_LOCAL_STATUS_EXPIRED.
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   569  * Parameters[out]   :   SEID
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   570  * Limitations       :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   571  * ReturnType        :   Std_ReturnType
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   572  * NOTE: Source is WdgM specification version 4.0.3 (Its done for future compatibility)
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   573  *******************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   574  /* TRACE[WDGM346] Implementation of WdgM_GetFirstExpiredSEID*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   575  /* TODO: TRACE[WDGM348] yet to be mapped*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   576  FUNC(Std_ReturnType, WDGM_CODE_SLOW)  WdgM_GetFirstExpiredSEID(P2VAR(WdgM_SupervisedEntityIdType,AUTOMATIC,WDGM_APPL_DATA)SEID)
; Function WdgM_GetFirstExpiredSEID
.L153:
WdgM_GetFirstExpiredSEID:	.type	func

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   577  {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   578      VAR(Std_ReturnType, AUTOMATIC) ReturnStatus = E_NOT_OK;
	mov	d2,#1
.L344:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   579      VAR(WdgM_SupervisedEntityIdType, AUTOMATIC) FirstExpiredSupervisedEntityIdTemp;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   580  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   581  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   582      /* TRACE[WDGM347] Check for NULL pointer*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   583      if (SEID == NULL_PTR)
	jnz.a	a4,.L72
.L636:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   584      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   585          /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored, and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   586          (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_GET_FIRST_EXPIRED_SEID_APIID, WDGM_E_INV_POINTER);
	mov	d4,#13
.L637:
	mov	d5,#0
.L638:
	mov	d6,#16
.L639:
	mov	d7,#20
	call	Det_ReportError
.L343:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   587          return E_NOT_OK;
	mov	d2,#1
.L640:
	j	.L73
.L72:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   588      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   589  #endif /*((WDGM_DEV_ERROR_DETECT) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   590      /*As per rules a correct entry is one copy of the  FirstExpiredSupervisedEntityId and second copy is
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   591       *the complement of the FirstExpiredSupervisedEntityId both should match whne either one is inverted*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   592      /*TRACE[WDGM349] implement the specific format as defined in the specifcations for SEID*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   593  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   594      FirstExpiredSupervisedEntityIdTemp = WdgM_Prv_ComplementSeId_to_Inl(WdgM_FirstExpiredSupervisedEntityId_Comp);
	movh.a	a15,#@his(WdgM_FirstExpiredSupervisedEntityId_Comp)
	lea	a15,[a15]@los(WdgM_FirstExpiredSupervisedEntityId_Comp)
	ld.bu	d15,[a15]
.L277:

; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	     1  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	     2  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	     3  #ifndef WDGM_CFG_H
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	     4  #define WDGM_CFG_H
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	     5  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	     6  /*
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	     7   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	     8   * Includes
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	     9   **********************************************************************************************************************
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    10  */
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    11  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    12  /*[WDGMFCK] The module shall include SchM_WdgM_Type.h*/
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    13  #include "SchM_WdgM_Type.h"
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    14  #include "Os.h"
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    15  #if (!defined(OS_AR_RELEASE_MAJOR_VERSION) || (OS_AR_RELEASE_MAJOR_VERSION != 4))
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    16  #error “AUTOSAR major version undefined or mismatched“
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    17  #endif
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    18  #if (!defined(OS_AR_RELEASE_MINOR_VERSION) || (OS_AR_RELEASE_MINOR_VERSION != 2))
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    19  #error “AUTOSAR minor version undefined or mismatched“
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    20  #endif
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    21  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    22  #include "Std_Types.h"
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    23  #if (!defined(STD_TYPES_AR_RELEASE_MAJOR_VERSION) || (STD_TYPES_AR_RELEASE_MAJOR_VERSION != 4))
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    24  #error “AUTOSAR major version undefined or mismatched“
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    25  #endif
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    26  #if (!defined(STD_TYPES_AR_RELEASE_MINOR_VERSION) || (STD_TYPES_AR_RELEASE_MINOR_VERSION != 2))
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    27  #error “AUTOSAR minor version undefined or mismatched“
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    28  #endif
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    29  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    30  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    31  #include "Det.h"
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    32  #if (!defined(DET_AR_RELEASE_MAJOR_VERSION) || (DET_AR_RELEASE_MAJOR_VERSION != 4))
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    33  #error “AUTOSAR major version undefined or mismatched“
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    34  #endif
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    35  #if (!defined(DET_AR_RELEASE_MINOR_VERSION) || (DET_AR_RELEASE_MINOR_VERSION != 2))
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    36  #error “AUTOSAR minor version undefined or mismatched“
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    37  #endif
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    38  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    39  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    40  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    41  /*TRACE[WDGM126] Include Dem.h*/
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    42  #include "Dem.h"
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    43  #if (!defined(DEM_AR_RELEASE_MAJOR_VERSION) || (DEM_AR_RELEASE_MAJOR_VERSION != 4))
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    44  #error “AUTOSAR major version undefined or mismatched“
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    45  #endif
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    46  #if (!defined(DEM_AR_RELEASE_MINOR_VERSION) || (DEM_AR_RELEASE_MINOR_VERSION != 2))
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    47  #error “AUTOSAR minor version undefined or mismatched“
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    48  #endif
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    49  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    50  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    51  #include "WdgIf.h"
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    52  #if (!defined(WDGIF_AR_RELEASE_MAJOR_VERSION) || (WDGIF_AR_RELEASE_MAJOR_VERSION != 4))
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    53  #error “AUTOSAR major version undefined or mismatched“
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    54  #endif
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    55  #if (!defined(WDGIF_AR_RELEASE_MINOR_VERSION) || (WDGIF_AR_RELEASE_MINOR_VERSION != 2))
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    56  #error “AUTOSAR minor version undefined or mismatched“
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    57  #endif
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    58  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    59  /*
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    60   *********************************************************************************************************
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    61   * Defines/Macros
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    62   *********************************************************************************************************
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    63  */
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    64  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    65  #define WDGM_VARIANT_PRE_COMPILE                                     (1)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    66  #define WDGM_DEADLINE_TIMEOUT_DETECT                                 (STD_ON)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    67  #define WDGM_DEV_ERROR_DETECT                                        (STD_ON)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    68  #define WDGM_RTE_DISABLED                                            (STD_OFF)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    69  #define WDGM_RB_DEBUG_OPTION_ENABLED                                 (STD_OFF)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    70  #define WDGM_DEFENSIVE_BEHAVIOR                                      (STD_OFF)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    71  #define WDGM_DEM_ALIVE_SUPERVISION_REPORT                            (STD_ON)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    72  #define WDGM_IMMEDIATE_RESET                                         (STD_OFF)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    73  #define WDGM_OFF_MODE_ENABLED                                        (STD_OFF)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    74  #define WDGM_VERSION_INFO_API                                        (STD_OFF)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    75  #define WDGM_PRV_C_ZERO                                              (0)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    76  #define WDGM_PRV_C_ONE                                               (1)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    77  #define WDGM_PRV_C_TWO                                               (2)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    78  #define WDGM_INVALID_WDGIF_DEVICE_INDEX                              (1)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    79  #define WDGM_INVALID_DEM_EVENT_ID                                    (0)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    80  #define WDGM_INVALID_TIMER_ID                                        ((CounterType)(0))
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    81  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    82  #define WDGM_NO_OF_WATCHDOGS                                         (1)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    83  #define WDGM_NO_OF_EXTERNAL_CALLER_IDENTIFIERS                       (0)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    84  #define WDGM_NO_OF_SUPERVISED_ENTITIES                               ((WdgM_SupervisedEntityIdType)(1))
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    85  #define WDGM_NO_OF_CHECKPOINTS                                       ((WdgM_CheckpointIdType)(1))
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    86  #define WDGM_NO_OF_DISTINCT_CHECKPOINTS                              ((WdgM_CheckpointIdType)(1))
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    87  #define WDGM_MAX_DEADLINE_SUPERVISIONS                               (0)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    88  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    89  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    90  /*Enable this to STD_ON if your use case does not involve WdgM_MainFunction being pre-empted by WdgM_SetMode vice versa.*/
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    91  #define WDGM_LOCK_DISABLE_FOR_DGS                                    (STD_ON)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    92  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    93  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    94  /* Symbolic names for Supervised Entities */
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    95  #define WdgMConf_WdgMSupervisedEntity_WdgMSupervisedEntity_Alive_Supervision_Entity1  ((WdgM_SupervisedEntityIdType)(0))
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    96  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    97  /* Symbolic names for CheckPoint Identifiers */
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    98  #define WdgMConf_WdgMCheckpoint_WdgMCheckpoint_Alive_Supervision_Entity1  ((WdgM_CheckpointIdType)(0))
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	    99  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   100  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   101  /* Symbolic names for Watchdog instances */
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   102  #define WdgMConf_WdgMWatchdog_WdgMWatchdog                           (WdgIfConf_WdgIfDevice_WdgIfDevice)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   103  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   104  /* WdgMSupervisionCycle Definitions [ms] */
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   105  #define WDGM_INVALID_SUPERVISION_CYCLE                               ((uint32)(0))
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   106  #define WDGM_SUPERVISION_CYCLE_0                                     ((uint32)(10))
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   107  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   108  /* Timer interface selection for Deadline supervision */
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   109  #define     WDGM_RB_DEADLINE_TIMER_SELECTION_NONE     (0)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   110  #define     WDGM_RB_DEADLINE_TIMER_SELECTION_MCU      (1)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   111  #define     WDGM_RB_DEADLINE_TIMER_SELECTION_OS       (2)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   112  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   113  /* No WdgMDeadlineSupervision configured so no timer selection is done*/
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   114  #define WDGM_RB_DEADLINE_TIMER_SELECTION WDGM_RB_DEADLINE_TIMER_SELECTION_NONE
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   115  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   116  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   117  #define WDGM_INTERNAL_GRAPH_CONFIGURED  STD_OFF
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   118  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   119  #define WdgMConf_WdgMMode_WdgMMode_FastMode                         	((WdgM_ModeType)(0))
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   120  #define WdgMConf_WdgMMode_WdgMMode_SlowMode                         	((WdgM_ModeType)(1))
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   121  #define WDGM_INVALID_MODE_INDEX                                     	((WdgM_ModeType)(2))
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   122  /*
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   123  ***************************************************************************************************
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   124  * Type definitions
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   125  ***************************************************************************************************
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   126  */
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   127  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   128  typedef uint8 WdgM_ModeType;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   129  typedef uint8 WdgM_LocalStatusType;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   130  typedef uint8 WdgM_GlobalStatusType;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   131  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   132  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   133  typedef struct
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   134  {
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   135      VAR(uint16,WDGM_VAR_FAST_CLEARED_16)  NoOfDeadlineSupervision;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   136      P2VAR(uint16,WDGM_VAR_FAST_CLEARED_16,WDGM_APPL_DATA)PtrToDeadlineIndices;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   137  }WdgM_CheckpointDynType;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   138  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   139  typedef struct
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   140  {
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   141  	CONSTP2VAR(WdgM_CheckpointDynType, WDGM_VAR_FAST_CLEARED_UNSPECIFIED, WDGM_APPL_DATA)PtrToCheckpointDyn;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   142  }WdgM_CheckpointType;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   143  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   144  typedef struct
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   145  {
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   146      VAR(uint8,WDGM_VAR_FAST_CLEARED_8)					FailedAliveSupervisionRefCycleCtr; 				/* To track the failed reference cycles of SE*/
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   147      VAR(uint8,WDGM_VAR_FAST_CLEARED_8)					FailedAliveSupervisionRefCycleTol;   /* Configuration Value to be copied at Mode change of WdgM from WdgM_LocalStatusParams. */
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   148      VAR(uint16,WDGM_VAR_FAST_CLEARED_16)			        IndividualSupervisionCycleCtr;        /* To track the supervision cycles of SE*/
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   149      VAR(uint32,WDGM_VAR_FAST_CLEARED_32)				IndividualAliveUpdateCtr;    /* To track the alivecounter of SE*/
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   150      VAR(uint16,WDGM_VAR_FAST_CLEARED_16)				AliveSupervisionIdx;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   151      VAR(WdgM_LocalStatusType,WDGM_VAR_FAST_CLEARED_UNSPECIFIED)  	NewLocalStatus;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   152      VAR(WdgM_LocalStatusType,WDGM_VAR_FAST_CLEARED_UNSPECIFIED)  	OldLocalStatus;			 /* Only to be updated in WdgM_MainFunction after current Monitoring Status is reported to RTE */
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   153  #if WDGM_INTERNAL_GRAPH_CONFIGURED == STD_ON
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   154      VAR(boolean,WDGM_VAR_FAST_CLEARED_BOOLEAN)                      flgActivity;    // True – graph active, False – graph inactive
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   155      VAR(WdgM_CheckpointIdType,WDGM_VAR_FAST_CLEARED_UNSPECIFIED)    idLastReachedCheckpoint;    
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   156  #endif 
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   157  }WdgM_SupervisedEntityDynType;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   158  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   159  typedef struct
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   160  {
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   161      VAR(uint16,WDGM_VAR_FAST_CLEARED_16)                      NoOfCheckpoint;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   162      VAR(boolean,WDGM_VAR_FAST_CLEARED_BOOLEAN)   	      PartionEnabled;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   163      VAR(CounterType,WDGM_VAR_FAST_CLEARED_UNSPECIFIED)	      TimerId;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   164      VAR(ApplicationType,WDGM_VAR_FAST_CLEARED_UNSPECIFIED)    OsApplicationId;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   165      P2CONST( WdgM_CheckpointType,WDGM_VAR_FAST_CLEARED_UNSPECIFIED,WDGM_APPL_DATA)PtrToCheckpoint;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   166      CONSTP2VAR(WdgM_SupervisedEntityDynType, WDGM_VAR_FAST_CLEARED_UNSPECIFIED, WDGM_APPL_DATA)PtrToSupervisedEntityDyn;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   167  #if WDGM_INTERNAL_GRAPH_CONFIGURED == STD_ON
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   168      VAR(boolean,WDGM_VAR_FAST_CLEARED_BOOLEAN)            hasInternalGraph;    /* True – has Internal Graph, False – does not have Internal Graph*/
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   169      VAR(uint16,WDGM_VAR_FAST_CLEARED_16)                  idxInternalGraphCPProperty;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   170  #endif    
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   171  }WdgM_SupervisedEntityType;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   172  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   173  /*TRACE[WDGM085] All the resources required for Alive Monitoring */
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   174  typedef struct
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   175  {
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   176      VAR(uint16,WDGM_VAR_FAST_CLEARED_16)                                   MinMargin;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   177      VAR(uint16,WDGM_VAR_FAST_CLEARED_16)                                   MaxMargin;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   178      VAR(WdgM_CheckpointIdType,WDGM_VAR_FAST_CLEARED_UNSPECIFIED)           AliveSupervisionCheckpointId;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   179      VAR(WdgM_SupervisedEntityIdType,WDGM_VAR_FAST_CLEARED_UNSPECIFIED)     SupervisedEntityId;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   180      VAR(uint16,WDGM_VAR_FAST_CLEARED_16)                                   ExpectedAliveIndications;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   181      VAR(uint16,WDGM_VAR_FAST_CLEARED_16)                                   SupervisionReferenceCycle;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   182  }WdgM_AliveSupervisionType;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   183  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   184  /*TRACE[WDGM293] All the resources required for Deadline Monitoring */
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   185  typedef struct
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   186  {
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   187      VAR(WdgM_CheckpointIdType,WDGM_VAR_FAST_CLEARED_UNSPECIFIED)       StartCheckpointId;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   188      VAR(WdgM_CheckpointIdType,WDGM_VAR_FAST_CLEARED_UNSPECIFIED)       StopCheckpointId;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   189      VAR(WdgM_SupervisedEntityIdType,WDGM_VAR_FAST_CLEARED_UNSPECIFIED) SupervisedEntityId;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   190      VAR(TickType,WDGM_VAR_FAST_CLEARED_UNSPECIFIED)                    DeadlineMin;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   191      VAR(TickType,WDGM_VAR_FAST_CLEARED_UNSPECIFIED)                    DeadlineMax;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   192  }WdgM_DeadlineSupervisionType;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   193  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   194  typedef struct
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   195  {
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   196      VAR(uint8,WDGM_VAR_FAST_CLEARED_UNSPECIFIED)                       FailedAliveSupervisionRefCycleTol;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   197      VAR(WdgM_SupervisedEntityIdType,WDGM_VAR_FAST_CLEARED_UNSPECIFIED) SupervisedEntityId;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   198  }WdgM_LocalStatusParamsType;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   199  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   200  typedef struct
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   201  {
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   202      VAR(uint16,WDGM_VAR_FAST_CLEARED_16)                   TriggerConditionValue;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   203      VAR(uint8,WDGM_VAR_FAST_CLEARED_8)                     DeviceIdx;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   204      VAR(WdgIf_ModeType,WDGM_VAR_FAST_CLEARED_UNSPECIFIED)  WdgMode;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   205  }WdgM_TriggerType;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   206  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   207  typedef struct
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   208  {
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   209      VAR(uint16,WDGM_VAR_FAST_CLEARED_16)  ExpiredSupervisionCycleTol;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   210      VAR(Rte_ModeType_WdgMSupervisionCycle,WDGM_VAR_FAST_CLEARED_UNSPECIFIED) SchMWdgMSupervisionCycle;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   211      VAR(uint32,WDGM_VAR_FAST_CLEARED_32) SupervisionCycle;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   212      VAR(uint16,WDGM_VAR_FAST_CLEARED_16)  NoOfAliveSupervision;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   213      VAR(uint16,WDGM_VAR_FAST_CLEARED_16)  NoOfDeadlineSupervision;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   214      VAR(uint16,WDGM_VAR_FAST_CLEARED_16)  NoOfLocalStatusParams;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   215      VAR(uint8,WDGM_VAR_FAST_CLEARED_8)    NoOfTrigger;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   216      P2CONST(WdgM_AliveSupervisionType,WDGM_VAR_FAST_UNSPECIFIED,WDGM_APPL_CONST)PtrToAliveSupervision;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   217      P2CONST(WdgM_DeadlineSupervisionType,WDGM_VAR_FAST_UNSPECIFIED,WDGM_APPL_CONST)PtrToDeadlineSupervision;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   218      P2CONST(WdgM_LocalStatusParamsType,WDGM_VAR_FAST_UNSPECIFIED,WDGM_APPL_CONST)PtrToLocalStatusParams;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   219      P2CONST(WdgM_TriggerType,WDGM_VAR_FAST_UNSPECIFIED,WDGM_APPL_CONST)PtrToTrigger;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   220  }WdgM_PrvModeType;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   221  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   222  /* WDGM029 */
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   223  typedef struct
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   224  {
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   225      VAR(WdgM_ModeType,WDGM_VAR_FAST_UNSPECIFIED)               InitialMode;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   226      VAR(uint8,WDGM_VAR_FAST_8)                                 NoOfMode;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   227  #if((WDGM_DEM_ALIVE_SUPERVISION_REPORT) == (STD_ON))
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   228      VAR(Dem_EventIdType,WDGM_VAR_FAST_UNSPECIFIED)             ErrorImproperCaller;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   229      VAR(Dem_EventIdType,WDGM_VAR_FAST_UNSPECIFIED)             ErrorSupervision;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   230      VAR(Dem_EventIdType,WDGM_VAR_FAST_UNSPECIFIED)             ErrorSetMode;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   231  #else /*WDGM_DEM_ALIVE_SUPERVISION_REPORT*/
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   232      VAR(uint16,WDGM_VAR_FAST_16)				    ErrorImproperCaller;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   233      VAR(uint16,WDGM_VAR_FAST_16)			            ErrorSupervision;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   234      VAR(uint16,WDGM_VAR_FAST_16)			            ErrorSetMode;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   235  #endif /*WDGM_DEM_ALIVE_SUPERVISION_REPORT*/
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   236  	CONSTP2VAR(TickType, WDGM_VAR_FAST_UNSPECIFIED, WDGM_APPL_DATA)PtrToRunningCounterValue;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   237  	CONSTP2VAR(uint16, WDGM_VAR_FAST_UNSPECIFIED, WDGM_APPL_DATA)PtrToDeadlineIndices;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   238      P2CONST(WdgM_PrvModeType,WDGM_VAR_FAST_UNSPECIFIED,WDGM_APPL_CONST)PtrToMode;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   239  }WdgM_ConfigType;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   240  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   241  #if WDGM_INTERNAL_GRAPH_CONFIGURED == STD_ON
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   242  typedef enum
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   243  {
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   244      WDGM_POSNGRAPH_NONE_E = 0,                 // Does not belong to Internal graph (value 0)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   245      WDGM_POSNGRAPH_INITIAL_E,               // Initial checkpoint (value 1)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   246      WDGM_POSNGRAPH_FINAL_E,                 // Final checkpoint (value 2)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   247      WDGM_POSNGRAPH_INTERMEDIATE_E // Intermediate checkpoint (value 3)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   248  } WdgM_PositionInGraph_ten;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   249  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   250  typedef struct
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   251  {
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   252      WdgM_PositionInGraph_ten    posnInGraph_en;             
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   253      uint16                      nrDestCheckpoints; 
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   254      uint16                      idxDestCheckpoints;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   255  } WdgM_InternalGraph_CPPropertyType;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   256  #endif 
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   257  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   258  /*
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   259  ***************************************************************************************************
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   260  * External declaration
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   261  ***************************************************************************************************
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   262  */
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   263  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   264  #define WDGM_START_SEC_CONFIG_DATA_FAST_UNSPECIFIED
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   265  #include "WdgM_Cfg_MemMap.h"
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   266  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   267  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   268  extern CONST(WdgM_CheckpointType, WDGM_CONST_FAST_UNSPECIFIED) WdgM_Checkpoint[1];
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   269  extern CONST(WdgM_SupervisedEntityType, WDGM_CONST_FAST_UNSPECIFIED) WdgM_SupervisedEntity[1];
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   270  /*No Internal Graph Configured for Logical Supervision....!!! */ 
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   271  #define WDGM_STOP_SEC_CONFIG_DATA_FAST_UNSPECIFIED
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   272  #include "WdgM_Cfg_MemMap.h"
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   273  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   274  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   275  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   276  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   277  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   278  #define WDGM_START_SEC_CONFIG_DATA_FAST_UNSPECIFIED
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   279  #include "WdgM_Cfg_MemMap.h"
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   280  /* Variable declarations from WdgMConfigSet */
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   281  extern CONST(WdgM_AliveSupervisionType, WDGM_CONST_FAST_UNSPECIFIED) WdgM_AliveSupervision[2];
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   282  /* No WdgMDeadlineSupervision is configured....!!! */
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   283  extern CONST(WdgM_LocalStatusParamsType, WDGM_CONST_FAST_UNSPECIFIED) WdgM_LocalStatusParams[2];
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   284  extern CONST(WdgM_TriggerType, WDGM_CONST_FAST_UNSPECIFIED) WdgM_Trigger[2];
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   285  extern CONST(WdgM_PrvModeType, WDGM_CONST_FAST_UNSPECIFIED) WdgM_PrvMode[2];
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   286  extern CONST(WdgM_ConfigType, WDGM_CONST_FAST_UNSPECIFIED) WdgM_Config;
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   287  #define WDGM_STOP_SEC_CONFIG_DATA_FAST_UNSPECIFIED
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   288  #include "WdgM_Cfg_MemMap.h"
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   289  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   290  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   291  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   292  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   293  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   294  #define WDGM_START_SEC_VAR_FAST_CLEARED_UNSPECIFIED
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   295  #include "WdgM_Cfg_MemMap.h"
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   296  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   297  /*TRACE[WDGM240] The Alive Counters of each Checkpoint shall be available for debugging */
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   298  /*TRACE[WDGM241] The Alive Counters of each Checkpoint shall be available for debugging */
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   299  /*TRACE[WDGM242] The Alive Counters of each Checkpoint shall be available for debugging */
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   300  /*TRACE[WDGM238] The local supervision status of each SE is available for debugging*/
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   301  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   302  extern VAR(WdgM_SupervisedEntityDynType, WDGM_VAR_FAST_CLEARED_UNSPECIFIED) WdgM_SupervisedEntityDyn[1];
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   303  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   304  #define WDGM_STOP_SEC_VAR_FAST_CLEARED_UNSPECIFIED
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   305  #include "WdgM_Cfg_MemMap.h"
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   306  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   307  LOCAL_INLINE WdgM_SupervisedEntityIdType WdgM_Prv_ComplementSeId_to_Inl(VAR(WdgM_SupervisedEntityIdType,AUTOMATIC) SEID);
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   308  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   309  
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   310  /************************************************************************************************************************
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   311  * Name              :   WdgM_Prv_ComplementSeId_to_Inl
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   312  * Description       :   returns 1's complement of the SEID passed as argument.
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   313  * Parameters[in]    :   SEID
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   314  * Limitations       :   None
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   315  * Return Value      :   WdgM_SupervisedEntityIdType
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   316  ************************************************************************************************************************/
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   317  LOCAL_INLINE WdgM_SupervisedEntityIdType WdgM_Prv_ComplementSeId_to_Inl(VAR(WdgM_SupervisedEntityIdType,AUTOMATIC) SEID)
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   318  {
; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   319      return (((WdgM_SupervisedEntityIdType)(0xFF)) - SEID);
	rsub	d15,d15,#255
.L345:

; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   319      return (((WdgM_SupervisedEntityIdType)(0xFF)) - SEID);      (inlined)
	j	.L74

; .\BSW\src\BSW\Gen\WdgM\WdgM_Cfg.h	   320  }      (inlined)
.L74:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   595      if(WdgM_FirstExpiredSupervisedEntityId == FirstExpiredSupervisedEntityIdTemp)
	movh.a	a15,#@his(WdgM_FirstExpiredSupervisedEntityId)
	lea	a15,[a15]@los(WdgM_FirstExpiredSupervisedEntityId)
	ld.bu	d0,[a15]
.L641:
	jne	d15,d0,.L75
.L642:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   596      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   597          *SEID = WdgM_FirstExpiredSupervisedEntityId;
	st.b	[a4],d15
.L643:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   598          ReturnStatus = E_OK;
	mov	d2,#0
.L644:
	j	.L76
.L75:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   599      }/*If no correct entry saved in the LOG. This also takes care of corrupt entry case*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   600      else
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   601      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   602          *SEID = WDGM_PRV_C_ZERO;
	mov	d15,#0
.L346:
	st.b	[a4],d15
.L76:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   603      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   604      return ReturnStatus;
	j	.L77

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   605  }
.L77:
.L73:
	ret
.L271:
	
__WdgM_GetFirstExpiredSEID_function_end:
	.size	WdgM_GetFirstExpiredSEID,__WdgM_GetFirstExpiredSEID_function_end-WdgM_GetFirstExpiredSEID
.L201:
	; End of function
	
	.sdecl	'.text.WdgM.WdgM_CheckpointReached',code,cluster('WdgM_CheckpointReached')
	.sect	'.text.WdgM.WdgM_CheckpointReached'
	.align	2
	
	.global	WdgM_CheckpointReached

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   606  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   607  #define WDGM_STOP_SEC_CODE_SLOW
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   608  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   609  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   610  #define WDGM_START_SEC_CODE
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   611  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   612  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   613  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   614  /*******************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   615  * Name              :   WdgM_CheckpointReached
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   616  * Description       :   Indicates to the Watchdog Manager that a Checkpoint within a Supervised
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   617  *                       Entity has been reached.
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   618  * Parameters[in]    :   SEID, CheckpointID
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   619  * Limitations       :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   620  * ReturnType        :   Std_ReturnType
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   621  *******************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   622  /*TRACE[WDGM263] Implementation of WdgM_CheckpointReached*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   623  /*TRACE[WDGM200] The local supervision status is monitored via WdgM_CheckpointReached */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   624  /*TODO: [WDGM323] Logical to be Implemented*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   625  /* Port defined argument value has been replaced with a macro as the generated variable could not have a user defined name */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   626  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   627  #if((WDGM_RTE_DISABLED) == (STD_OFF))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   628  FUNC(Std_ReturnType, WDGM_CODE_FAST) WdgM_CheckpointReached(VAR(WdgM_SupervisedEntityIdType,AUTOMATIC) Rte_PDAV0,
; Function WdgM_CheckpointReached
.L155:
WdgM_CheckpointReached:	.type	func

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   629  VAR(WdgM_CheckpointIdType,AUTOMATIC) CheckpointID)
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   630  #else
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   631  FUNC(Std_ReturnType, WDGM_CODE_FAST) WdgM_CheckpointReached(VAR(WdgM_SupervisedEntityIdType,AUTOMATIC) SEID,
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   632  VAR(WdgM_CheckpointIdType,AUTOMATIC) CheckpointID)
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   633  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   634  {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   635      #if((WDGM_RTE_DISABLED) == (STD_OFF))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   636      VAR(WdgM_SupervisedEntityIdType,AUTOMATIC) SEID = Rte_PDAV0;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   637      #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   638      VAR(uint16,AUTOMATIC) SvIdx;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   639      VAR(Std_ReturnType,AUTOMATIC) ReturnStatus = E_OK;
	mov	d2,#0
.L349:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   640  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   641  #if ((WDGM_MAX_DEADLINE_SUPERVISIONS) > (WDGM_PRV_C_ZERO))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   642      VAR(Std_ReturnType,AUTOMATIC) DeadlineReturnStatus;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   643  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   644  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   645  #if (WDGM_INTERNAL_GRAPH_CONFIGURED == STD_ON)
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   646      VAR(Std_ReturnType,AUTOMATIC) LogicalReturnStatus;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   647  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   648  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   649      /* TRACE[WDGM279] Check if WdgM is initilized  */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   650      if (WdgM_GlobalStatus != WDGM_GLOBAL_STATUS_DEACTIVATED)
	movh.a	a15,#@his(WdgM_GlobalStatus)
	lea	a15,[a15]@los(WdgM_GlobalStatus)
	ld.bu	d15,[a15]
.L755:
	jeq	d15,#4,.L78
.L756:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   651      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   652          /* TRACE[WDGM278] Check for vaild SEID */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   653          if (SEID < WDGM_NO_OF_SUPERVISED_ENTITIES)
	jne	d4,#0,.L79
.L757:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   654          {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   655              /* TRACE[WDGM319] Check if for the given SE ,the checkpoint ID belongs to is set to Active in current mode*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   656              /* TRACE[WDGM284] Check for checkpointID is within the associated CheckpointID's for a SE*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   657              if(CheckpointID < WdgM_SupervisedEntity[SEID].NoOfCheckpoint)
	movh.a	a15,#@his(WdgM_SupervisedEntity)
	lea	a15,[a15]@los(WdgM_SupervisedEntity)
.L758:
	mul	d15,d4,#20
	addsc.a	a15,a15,d15,#0
.L759:
	ld.hu	d15,[a15]0
.L760:
	jge.u	d5,d15,.L80
.L761:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   658              {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   659  #endif /* ((WDGM_DEV_ERROR_DETECT) == (STD_ON)) */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   660                  SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   661                  /* Lock introduced:
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   662                   * 1.In WdgM_SupervisedEntityDyn we check for Local status deactivated,
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   663                   * if mode changes here then for newely active or deactive mode we will peform unncessary operation.
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   664                   */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   665                  /*TRACE[WDGM208] Since SEActive is False for DEACTIVATED, no supervision process is performed*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   666                  if ((WdgM_SupervisedEntityDyn[SEID].NewLocalStatus & WDGM_LOCAL_STATUS_DEACTIVATED) != WDGM_LOCAL_STATUS_DEACTIVATED)
	movh.a	a15,#@his(WdgM_SupervisedEntityDyn)
	lea	a15,[a15]@los(WdgM_SupervisedEntityDyn)
.L762:
	mul	d15,d4,#12
	addsc.a	a2,a15,d15,#0
.L763:
	ld.bu	d15,[a2]10
.L764:
	jnz.t	d15:2,.L81
.L765:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   667                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   668                      /* Alive Supervision */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   669                      /* Lock introduced:
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   670                       * 1. In WdgM_SupervisedEntityDyn we check for AliveSupervisionIdx,
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   671                       *  which could be corrupted if Mode chage occurs and  WdgM_SupervisedEntityDyn is modified.
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   672                       */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   673                      SvIdx = WdgM_SupervisedEntityDyn[SEID].AliveSupervisionIdx;
	ld.hu	d0,[a2]8
.L351:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   674                      /*TRACE[WDGM321] Increment the alive indication counter of reported Checkpoint*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   675                      if((SvIdx != WdgM_ConfigSetPtr->PtrToMode[WdgM_Mode].NoOfAliveSupervision)&&
	movh.a	a15,#@his(WdgM_ConfigSetPtr)
	lea	a15,[a15]@los(WdgM_ConfigSetPtr)
	ld.a	a15,[a15]
.L766:
	ld.a	a15,[a15]16
.L767:
	movh.a	a4,#@his(WdgM_Mode)
	lea	a4,[a4]@los(WdgM_Mode)
	ld.bu	d15,[a4]
	sha	d15,#5
.L768:
	addsc.a	a15,a15,d15,#0
.L769:
	ld.hu	d15,[a15]8
.L770:
	jeq	d15,d0,.L82
.L771:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   676                              (WdgM_ConfigSetPtr->PtrToMode[WdgM_Mode].PtrToAliveSupervision[SvIdx].AliveSupervisionCheckpointId == CheckpointID))
	mul	d15,d0,#10
.L772:
	ld.a	a15,[a15]16
.L773:
	addsc.a	a15,a15,d15,#0
.L774:
	ld.bu	d15,[a15]4
.L775:
	jne	d15,d5,.L83
.L776:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   677                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   678                          /* Lock introduced:
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   679                           * 1. the ++ is a read modify write operation ,
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   680                           * read: old value
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   681                           * preempt: WdgM_MainFunction: modify source value to 0
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   682                           * modify : old value + 1
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   683                           * write : old value +1 (source has been made 0 hence final should be 0+1)
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   684                           */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   685                          WdgM_SupervisedEntityDyn[SEID].IndividualAliveUpdateCtr++;
	add.a	a2,#4
	ld.w	d15,[a2]
.L777:
	add	d15,#1
	st.w	[a2],d15
.L83:
.L82:
	j	.L84
.L81:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   686                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   687                      SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   688                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   689                  else
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   690                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   691                      /*Lock Disable: On failure to enter if case release lock*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   692                      SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   693  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   694                      /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored, and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   695                      (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_CHECKPOINT_REACHED_APIID, WDGM_E_SEDEACTIVATED);
	mov	d4,#13
.L348:
	mov	d5,#0
.L347:
	mov	d6,#14
.L778:
	mov	d7,#25
	call	Det_ReportError
.L350:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   696                      /*When CPR are reported which do not belong to the current mode no action should be taken hence return E_OK */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   697                      /*only when DET is enabled should reporting be enabled and E_NOT_OK */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   698                      ReturnStatus = E_NOT_OK;
	mov	d2,#1
.L84:
	j	.L85
.L80:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   699  #endif /* ((WDGM_DEV_ERROR_DETECT) == (STD_ON)) */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   700                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   701                  /* Deadline Supervision */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   702                  /* TRACE[WDGM322] Perform Deadline supervision*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   703                  /* Lock introduced:
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   704                   * 1. During Deadline Checkpoint Reached we refer the WdgM_Mode which has to be atomic.
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   705                   * 2. Local status is modified here hence to prevent
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   706                   */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   707  #if ((WDGM_MAX_DEADLINE_SUPERVISIONS) > (WDGM_PRV_C_ZERO))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   708                  WdgM_Prv_DeadlineSupervisionCheckpointReached_v_Inl(SEID, CheckpointID, &DeadlineReturnStatus);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   709                  if (DeadlineReturnStatus != E_OK)
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   710                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   711                      ReturnStatus = E_NOT_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   712                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   713  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   714                  /* Logical Supervision for Internal Graph*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   715  #if (WDGM_INTERNAL_GRAPH_CONFIGURED == STD_ON)
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   716                  LogicalReturnStatus = WdgM_Prv_LogicalSupervisionCheckpointReached_v_Inl(SEID, CheckpointID);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   717                  if (LogicalReturnStatus != E_OK)
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   718                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   719                      ReturnStatus = E_NOT_OK;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   720                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   721  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   722  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   723  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   724              }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   725              else
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   726              {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   727                  /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored, and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   728                  (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_CHECKPOINT_REACHED_APIID , WDGM_E_CPID);
	mov	d4,#13
.L354:
	mov	d5,#0
.L353:
	mov	d6,#14
.L779:
	mov	d7,#22
	call	Det_ReportError
.L352:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   729                  ReturnStatus = E_NOT_OK;
	mov	d2,#1
.L85:
	j	.L86
.L79:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   730              }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   731          }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   732          else
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   733          {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   734              /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored, and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   735              (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_CHECKPOINT_REACHED_APIID , WDGM_E_PARAM_SEID);
	mov	d4,#13
.L357:
	mov	d5,#0
.L356:
	mov	d6,#14
.L780:
	mov	d7,#19
	call	Det_ReportError
.L355:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   736              ReturnStatus = E_NOT_OK;
	mov	d2,#1
.L86:
	j	.L87
.L78:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   737          }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   738      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   739      else
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   740      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   741          /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored, and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   742          (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_CHECKPOINT_REACHED_APIID , WDGM_E_NO_INIT);
	mov	d4,#13
.L360:
	mov	d5,#0
.L359:
	mov	d6,#14
.L781:
	mov	d7,#16
	call	Det_ReportError
.L358:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   743          ReturnStatus = E_NOT_OK;
	mov	d2,#1
.L87:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   744      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   745  #endif /* ((WDGM_DEV_ERROR_DETECT) == (STD_ON)) */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   746      return ReturnStatus;
	j	.L88

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   747  }
.L88:
	ret
.L296:
	
__WdgM_CheckpointReached_function_end:
	.size	WdgM_CheckpointReached,__WdgM_CheckpointReached_function_end-WdgM_CheckpointReached
.L211:
	; End of function
	
	.sdecl	'.text.WdgM.WdgM_MainFunction',code,cluster('WdgM_MainFunction')
	.sect	'.text.WdgM.WdgM_MainFunction'
	.align	2
	
	.global	WdgM_MainFunction

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   748  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   749  /*******************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   750  * Name              :   WdgM_MainFunction
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   751  * Description       :   Performs the processing of the cyclic Watchdog Manager jobs.
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   752  * Parameters[in]    :   void
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   753  * Limitations       :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   754  * ReturnType        :   void
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   755  *******************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   756  /* TRACE[WDGM159] Implementation of WdgM_MainFunction*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   757  FUNC(void, WDGM_CODE) WdgM_MainFunction(void)
; Function WdgM_MainFunction
.L157:
WdgM_MainFunction:	.type	func
	sub.a	a10,#8
.L361:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   758  {  /* AUTOSAR_SRS_BSWGeneral.pdf: WDGM345: BSW00433, BSW00429 allows to be called before OS starts. */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   759      VAR(WdgM_SupervisedEntityIdType, AUTOMATIC) SEID;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   760      VAR(WdgM_GlobalStatusType, AUTOMATIC) NewGlobalStatus = WDGM_GLOBAL_STATUS_DEACTIVATED;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   761      /*Introduce GlobalStatusCached:
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   762      *1. If RTE update required we store the WdgM_GlobalStatus and compare with NewGlobalStatus.
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   763      */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   764  #if(((WDGM_DEM_ALIVE_SUPERVISION_REPORT) == (STD_ON))||((WDGM_RTE_DISABLED) == (STD_OFF))||((WDGM_IMMEDIATE_RESET) == (STD_ON)))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   765      VAR(WdgM_GlobalStatusType, AUTOMATIC) GlobalStatusCached ;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   766  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   767  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   768      WdgM_MainFunction_Cnt_u32++;
	movh.a	a15,#@his(WdgM_MainFunction_Cnt_u32)
	lea	a15,[a15]@los(WdgM_MainFunction_Cnt_u32)
	ld.w	d15,[a15]
.L649:
	add	d15,#1
	st.w	[a15],d15
.L650:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   769  #endif  /*((WDGM_DEV_ERROR_DETECT) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   770  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   771      /*TRACE[SWS_WdgM_00039] If DET is enabled then proceed the global status check.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   772      /*TRACE[SWS_WdgM_00223] If global status is DEACTIVATED then return without calling Set Trigger*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   773  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   774      if (WdgM_GlobalStatus == WDGM_GLOBAL_STATUS_DEACTIVATED)
	movh.a	a15,#@his(WdgM_GlobalStatus)
	lea	a15,[a15]@los(WdgM_GlobalStatus)
	st.a	[a10],a15
	ld.bu	d8,[a15]
.L651:
	jne	d8,#4,.L89
.L652:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   775      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   776          /* As per AUTOSAR spec of DET, the function 'Det_ReportError' always returns E_OK. So the return value can be ignored, and hence it is type casted to type void.*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   777          (void)Det_ReportError(WDGM_MODULE_ID, WDGM_INSTANCE_ID, WDGM_MAIN_FUNCTION_APIID , WDGM_E_NO_INIT);
	mov	d4,#13
.L653:
	mov	d5,#0
.L654:
	mov	d6,#8
.L655:
	mov	d7,#16
	call	Det_ReportError
.L656:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   778          return;
	j	.L90
.L89:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   779      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   780  #endif  /*((WDGM_DEV_ERROR_DETECT) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   781  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   782  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   783  #else /*(WDGM_LOCK_DISABLE_FOR_DGS == STD_OFF)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   784      SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   785  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   786  #if(((WDGM_DEM_ALIVE_SUPERVISION_REPORT) == (STD_ON))||((WDGM_RTE_DISABLED) == (STD_OFF))||((WDGM_IMMEDIATE_RESET) == (STD_ON)))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   787      GlobalStatusCached = WdgM_GlobalStatus;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   788  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   789      if((WdgM_GlobalStatus != WDGM_GLOBAL_STATUS_DEACTIVATED)&&(WdgM_GlobalStatus != WDGM_GLOBAL_STATUS_STOPPED)&&(WdgM_Prv_SetMode_GlobalStatus != WDGM_GLOBAL_STATUS_STOPPED))
	jeq	d8,#4,.L91
.L657:
	jeq	d8,#3,.L92
.L658:
	movh.a	a15,#@his(WdgM_Prv_SetMode_GlobalStatus)
	lea	a15,[a15]@los(WdgM_Prv_SetMode_GlobalStatus)
	ld.bu	d0,[a15]
.L659:
	jeq	d0,#3,.L93
.L286:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     1  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     2  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     3  #ifndef WDGM_PRV_H
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     4  #define WDGM_PRV_H
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     5  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     6  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     7   **********************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     8   * Includes
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     9   **********************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    10  */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    11  #define WDGM_PRV_AVOID_RTE_PROVIDED_FUNC_DECLARATION
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    12  #include "WdgM.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    13  #undef WDGM_PRV_AVOID_RTE_PROVIDED_FUNC_DECLARATION
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    14  #if((WDGM_RTE_DISABLED) == (STD_OFF))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    15  #include "SchM_WdgM.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    16  #include "WdgM_Cfg_SchM.h" /* TODO: To be removed when RTE supports Exclusive Area. */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    17  #include "Rte_WdgM.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    18  #else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    19  #include "WdgM_Cfg_SchM.h" /* It is mandatory if RTE is disabled. */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    20  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    21  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    22  #include "WdgIf.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    23  #if (!defined(WDGIF_AR_RELEASE_MAJOR_VERSION) || (WDGIF_AR_RELEASE_MAJOR_VERSION != 4))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    24  #error “AUTOSAR major version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    25  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    26  #if (!defined(WDGIF_AR_RELEASE_MINOR_VERSION) || (WDGIF_AR_RELEASE_MINOR_VERSION != 2))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    27  #error “AUTOSAR minor version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    28  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    29  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    30  #if (((WDGM_IMMEDIATE_RESET) == (STD_ON)) || ((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_MCU)))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    31  #include "Mcu.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    32  #if (!defined(MCU_AR_RELEASE_MAJOR_VERSION) || (MCU_AR_RELEASE_MAJOR_VERSION != 4))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    33  #error “AUTOSAR major version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    34  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    35  #if (!defined(MCU_AR_RELEASE_MINOR_VERSION) || (MCU_AR_RELEASE_MINOR_VERSION != 2))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    36  #error “AUTOSAR minor version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    37  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    38  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    39  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    40  #include "BswM_WdgM.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    41  #if (!defined(BSWM_AR_RELEASE_MAJOR_VERSION) || (BSWM_AR_RELEASE_MAJOR_VERSION != 4))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    42  #error “AUTOSAR major version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    43  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    44  #if (!defined(BSWM_AR_RELEASE_MINOR_VERSION) || (BSWM_AR_RELEASE_MINOR_VERSION != 2))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    45  #error “AUTOSAR minor version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    46  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    47  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    48  #include "Os.h" /* specified in SWS. required for GetElapsedCounterValue Api */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    49  #if (!defined(OS_AR_RELEASE_MAJOR_VERSION) || (OS_AR_RELEASE_MAJOR_VERSION != 4))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    50  #error “AUTOSAR major version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    51  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    52  #if (!defined(OS_AR_RELEASE_MINOR_VERSION) || (OS_AR_RELEASE_MINOR_VERSION != 2))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    53  #error “AUTOSAR minor version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    54  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    55  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    56  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    57   *********************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    58   * Defines/Macros
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    59   *********************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    60  */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    61  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    62  /* For debugging */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    63  #if ((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    64  #define WDGM_RB_FAILED_IN_ALIVE_MAINFUNCTION                            ((uint8)(1))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    65  #define WDGM_RB_FAILED_IN_DEADLINE_MAINFUNCTION                         ((uint8)(2))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    66  #define WDGM_RB_FAILED_IN_DEADLINE_CHECKPOINTREACHED                    ((uint8)(3))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    67  #define WDGM_RB_FAILED_IN_LOGICAL_INTGRAPH_CPREACHED_GRAPHNOTSTARTED    ((uint8)(4))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    68  #define WDGM_RB_FAILED_IN_LOGICAL_INTGRAPH_CPREACHED_GRAPHSTARTED       ((uint8)(5))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    69  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    70  typedef struct
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    71  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    72  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    73      VAR(TickType,WDGM_VAR_FAST_POWER_ON_CLEARED_UNSPECIFIED)                    FirstElapsedCounterValue;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    74      VAR(uint16,WDGM_VAR_FAST_POWER_ON_CLEARED_16)                               FirstExpiredCheckpointId_t;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    75      VAR(uint16,WDGM_VAR_FAST_POWER_ON_CLEARED_16)                               FirstExpiredAdditionalCheckpointId;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    76      VAR(WdgM_SupervisedEntityIdType,WDGM_VAR_FAST_POWER_ON_CLEARED_UNSPECIFIED) FirstExpiredSupervisedEntityId_t;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    77      VAR(uint8,WDGM_VAR_FAST_POWER_ON_CLEARED_8)                                 FirstExpiredLocation_t;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    78      VAR(WdgM_ModeType,AUTOMATIC)                                                FirstExpiredModeId;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    79  }WdgM_Rb_FirstExpiredEntityInfo_tst;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    80  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    81  #endif /*WDGM_RB_DEBUG_OPTION_ENABLED*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    82  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    83  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    84   **********************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    85   * Extern declarations
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    86   **********************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    87  */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    88  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    89  #define WDGM_START_SEC_VAR_FAST_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    90  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    91  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    92  extern P2CONST(WdgM_ConfigType, WDGM_VAR_FAST_CLEARED_UNSPECIFIED, WDGM_APPL_CONST)WdgM_ConfigSetPtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    93  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    94  #define WDGM_STOP_SEC_VAR_FAST_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    95  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    96  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    97  #define WDGM_START_SEC_VAR_FAST_CLEARED_BOOLEAN
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    98  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    99  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   100  extern VAR(boolean, WDGM_VAR_FAST_CLEARED_BOOLEAN) WdgM_AliveSupervisionActive;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   101  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   102  #define WDGM_STOP_SEC_VAR_FAST_CLEARED_BOOLEAN
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   103  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   104  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   105  #define WDGM_START_SEC_VAR_FAST_CLEARED_8
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   106  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   107  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   108  extern VAR(uint8, WDGM_VAR_FAST_CLEARED_8) WdgM_Mode;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   109  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   110  #define WDGM_STOP_SEC_VAR_FAST_CLEARED_8
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   111  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   112  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   113  #define WDGM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   114  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   115  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   116  extern VAR(uint16, WDGM_VAR_CLEARED_16) WdgM_ExpiredSupervisionCycleCtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   117  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   118  #define WDGM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   119  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   120  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   121  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   122  #define WDGM_START_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   123  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   124  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   125  extern VAR(uint32, WDGM_VAR_CLEARED_32) WdgM_MainFunction_Cnt_u32;  /* This variable is used only for debug purpose. */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   126  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   127  #define WDGM_STOP_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   128  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   129  #endif /*((WDGM_DEV_ERROR_DETECT) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   130  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   131  #define WDGM_START_SEC_VAR_SLOW_INIT_BOOLEAN
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   132  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   133  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   134  extern VAR(boolean, WDGM_VAR_SLOW_INIT_BOOLEAN) WdgM_Prv_FirstDeactivation_b;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   135  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   136  #define WDGM_STOP_SEC_VAR_SLOW_INIT_BOOLEAN
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   137  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   138  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   139  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   140  #define WDGM_START_SEC_VAR_FAST_POWER_ON_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   141  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   142  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   143  extern VAR(WdgM_Rb_FirstExpiredEntityInfo_tst, WDGM_VAR_FAST_POWER_ON_CLEARED_UNSPECIFIED) WdgM_Rb_FirstExpiredEntityInfo_st;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   144  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   145  #define WDGM_STOP_SEC_VAR_FAST_POWER_ON_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   146  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   147  #endif /*(WDGM_RB_DEBUG_OPTION_ENABLED == STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   148  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   149  #define WDGM_START_SEC_VAR_POWER_ON_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   150  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   151  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   152  /* TRACE[WDGM349] Implementation of non-initialized RAM location, stored as a double-inverse value */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   153  extern VAR(WdgM_SupervisedEntityIdType, WDGM_VAR_POWER_ON_CLEARED_UNSPECIFIED) WdgM_FirstExpiredSupervisedEntityId;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   154  extern VAR(WdgM_SupervisedEntityIdType, WDGM_VAR_POWER_ON_CLEARED_UNSPECIFIED) WdgM_FirstExpiredSupervisedEntityId_Comp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   155  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   156  #define WDGM_STOP_SEC_VAR_POWER_ON_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   157  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   158  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   159  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   160  #define WDGM_START_SEC_VAR_FAST_POWER_ON_CLEARED_8
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   161  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   162  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   163  extern VAR(uint8, WDGM_VAR_FAST_POWER_ON_CLEARED_8) WdgM_Rb_FirstExpiredEntity_Cnt_u8;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   164  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   165  #define WDGM_STOP_SEC_VAR_FAST_POWER_ON_CLEARED_8
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   166  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   167  #endif /*(WDGM_RB_DEBUG_OPTION_ENABLED == STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   168  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   169  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   170   ***********************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   171   * Private Function Declaration
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   172   ***********************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   173  */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   174  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   175  #define WDGM_START_SEC_CODE
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   176  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   177  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   178  extern FUNC(void, WDGM_CODE) WdgM_Prv_SetTriggerCondition(VAR(WdgM_GlobalStatusType, AUTOMATIC)globalStatus_tu8);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   179  extern FUNC(void,WDGM_CODE) WdgM_Prv_LocalStatusMainFunction(void);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   180  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   181  #define WDGM_STOP_SEC_CODE
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   182  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   183  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   184  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   185  #define WDGM_START_SEC_CODE_FAST
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   186  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   187  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   188  extern FUNC(void, WDGM_CODE_FAST) WdgM_Rb_FirstExpiredEntity(VAR(TickType,AUTOMATIC) ElapsedCounterValue, VAR(uint16,AUTOMATIC) CheckpointID,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   189          VAR(uint16,AUTOMATIC) AdditionalCheckpointID, VAR(WdgM_SupervisedEntityIdType,AUTOMATIC) SEID,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   190          VAR(uint8,AUTOMATIC) ExpiredLocation, VAR(WdgM_ModeType,AUTOMATIC) ModeId);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   191  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   192  #define WDGM_STOP_SEC_CODE_FAST
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   193  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   194  #endif/*(WDGM_RB_DEBUG_OPTION_ENABLED == STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   195  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   196  LOCAL_INLINE void WdgM_Prv_AliveSupervisionMainFunction_v_Inl(void);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   197  LOCAL_INLINE void WdgM_Prv_UpdateAliveSupervisionDyn_v_Inl(void);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   198  LOCAL_INLINE void WdgM_Prv_UpdateTriggerDyn_v_Inl(VAR(WdgM_ModeType,AUTOMATIC) Mode, P2VAR(Std_ReturnType,AUTOMATIC,WDGM_APPL_DATA)ReturnStatus);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   199  LOCAL_INLINE void WdgM_Prv_UpdateSupervisedEntityDyn_v_Inl(VAR(WdgM_ModeType,AUTOMATIC) Mode);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   200  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   201  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   202  LOCAL_INLINE void WdgM_Rb_DebugVariables_Init_v_Inl(void);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   203  #endif/*(WDGM_RB_DEBUG_OPTION_ENABLED == STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   204  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   205  #if((WDGM_DEADLINE_TIMEOUT_DETECT == STD_ON) && ((WDGM_MAX_DEADLINE_SUPERVISIONS) > (WDGM_PRV_C_ZERO)))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   206  LOCAL_INLINE void WdgM_Prv_DeadlineSupervisionMainFunction_v_Inl(void);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   207  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   208  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   209  #if ((WDGM_MAX_DEADLINE_SUPERVISIONS) > (WDGM_PRV_C_ZERO))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   210  LOCAL_INLINE void WdgM_Prv_DeadlineSupervisionCheckpointReached_v_Inl(VAR(WdgM_SupervisedEntityIdType,AUTOMATIC) SEID,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   211  VAR(WdgM_CheckpointIdType,AUTOMATIC) CheckpointID, P2VAR(Std_ReturnType,AUTOMATIC,WDGM_APPL_DATA)ReturnStatus);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   212  LOCAL_INLINE void WdgM_Prv_UpdateDeadlineSupervisionDyn_v_Inl(VAR(WdgM_ModeType,AUTOMATIC) Mode);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   213  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   214  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   215  #if (WDGM_INTERNAL_GRAPH_CONFIGURED == STD_ON)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   216  LOCAL_INLINE Std_ReturnType WdgM_Prv_LogicalSupervisionCheckpointReached_v_Inl(VAR(WdgM_SupervisedEntityIdType,AUTOMATIC) SEID,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   217  VAR(WdgM_CheckpointIdType,AUTOMATIC) CheckpointID);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   218  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   219  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   220   ************************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   221   * Inline Function Definitions
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   222   ************************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   223   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   224  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   225  /************************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   226   * Name              :   WdgM_Rb_DebugVariables_Init_v_Inl
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   227   * Description       :   Initialises the debug Variables
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   228   * Parameters[in]    :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   229   * Limitations       :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   230   * Return Value      :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   231   ************************************************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   232  LOCAL_INLINE void WdgM_Rb_DebugVariables_Init_v_Inl(void)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   233  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   234      WdgM_Rb_FirstExpiredEntityInfo_st.FirstElapsedCounterValue          = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   235      WdgM_Rb_FirstExpiredEntityInfo_st.FirstExpiredCheckpointId_t        = WDGM_RB_MAX_CHECKPOINTID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   236      WdgM_Rb_FirstExpiredEntityInfo_st.FirstExpiredAdditionalCheckpointId= WDGM_RB_MAX_CHECKPOINTID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   237      WdgM_Rb_FirstExpiredEntityInfo_st.FirstExpiredSupervisedEntityId_t  = WDGM_RB_MAX_SUPERVISEDENTITYID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   238      WdgM_Rb_FirstExpiredEntityInfo_st.FirstExpiredLocation_t            = WDGM_RB_DEFAULT_EXPIREDLOCATION;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   239      WdgM_Rb_FirstExpiredEntityInfo_st.FirstExpiredModeId                = WDGM_RB_MAX_MODEID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   240  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   241        WdgM_Rb_FirstExpiredEntity_Cnt_u8 = WDGM_PRV_C_ONE;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   242  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   243  #endif/*(WDGM_RB_DEBUG_OPTION_ENABLED == STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   244  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   245  /************************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   246   * Name              :   WdgM_Prv_AliveSupervisionMainFunction_v_Inl
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   247   * Description       :   Update the Alive Supervision in WdgM_MainFunction
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   248   * Parameters[in]    :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   249   * Limitations       :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   250   * Return Value      :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   251   ************************************************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   252  LOCAL_INLINE void WdgM_Prv_AliveSupervisionMainFunction_v_Inl(void)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   253  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   254      VAR(WdgM_SupervisedEntityIdType, AUTOMATIC) SEID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   255      VAR(uint16, AUTOMATIC) AliveSupervisionIdx;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   256      P2CONST(WdgM_AliveSupervisionType, AUTOMATIC, WDGM_APPL_CONST) AliveSupervisionPtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   257      VAR(uint32,AUTOMATIC) IndividualAliveUpdateCtrCache = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   258      AliveSupervisionPtr = WdgM_ConfigSetPtr->PtrToMode[WdgM_Mode].PtrToAliveSupervision;
	movh.a	a12,#@his(WdgM_Mode)
	lea	a12,[a12]@los(WdgM_Mode)
	ld.bu	d0,[a12]
	sha	d2,d0,#5
.L660:
	movh.a	a13,#@his(WdgM_ConfigSetPtr)
	lea	a13,[a13]@los(WdgM_ConfigSetPtr)
	ld.a	a15,[a13]
.L661:
	lea	a7,[a15]16
	ld.a	a15,[a7]
.L662:
	addsc.a	a15,a15,d2,#0
.L287:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   790      {   /*Enter here if global mode is OK or FAILED*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   791          if (WdgM_GlobalStatus != WDGM_GLOBAL_STATUS_EXPIRED)
	jeq	d8,#2,.L94
.L290:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     1  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     2  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     3  #ifndef WDGM_PRV_H
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     4  #define WDGM_PRV_H
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     5  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     6  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     7   **********************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     8   * Includes
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	     9   **********************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    10  */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    11  #define WDGM_PRV_AVOID_RTE_PROVIDED_FUNC_DECLARATION
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    12  #include "WdgM.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    13  #undef WDGM_PRV_AVOID_RTE_PROVIDED_FUNC_DECLARATION
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    14  #if((WDGM_RTE_DISABLED) == (STD_OFF))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    15  #include "SchM_WdgM.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    16  #include "WdgM_Cfg_SchM.h" /* TODO: To be removed when RTE supports Exclusive Area. */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    17  #include "Rte_WdgM.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    18  #else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    19  #include "WdgM_Cfg_SchM.h" /* It is mandatory if RTE is disabled. */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    20  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    21  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    22  #include "WdgIf.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    23  #if (!defined(WDGIF_AR_RELEASE_MAJOR_VERSION) || (WDGIF_AR_RELEASE_MAJOR_VERSION != 4))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    24  #error “AUTOSAR major version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    25  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    26  #if (!defined(WDGIF_AR_RELEASE_MINOR_VERSION) || (WDGIF_AR_RELEASE_MINOR_VERSION != 2))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    27  #error “AUTOSAR minor version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    28  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    29  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    30  #if (((WDGM_IMMEDIATE_RESET) == (STD_ON)) || ((WDGM_RB_DEADLINE_TIMER_SELECTION) == (WDGM_RB_DEADLINE_TIMER_SELECTION_MCU)))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    31  #include "Mcu.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    32  #if (!defined(MCU_AR_RELEASE_MAJOR_VERSION) || (MCU_AR_RELEASE_MAJOR_VERSION != 4))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    33  #error “AUTOSAR major version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    34  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    35  #if (!defined(MCU_AR_RELEASE_MINOR_VERSION) || (MCU_AR_RELEASE_MINOR_VERSION != 2))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    36  #error “AUTOSAR minor version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    37  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    38  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    39  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    40  #include "BswM_WdgM.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    41  #if (!defined(BSWM_AR_RELEASE_MAJOR_VERSION) || (BSWM_AR_RELEASE_MAJOR_VERSION != 4))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    42  #error “AUTOSAR major version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    43  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    44  #if (!defined(BSWM_AR_RELEASE_MINOR_VERSION) || (BSWM_AR_RELEASE_MINOR_VERSION != 2))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    45  #error “AUTOSAR minor version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    46  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    47  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    48  #include "Os.h" /* specified in SWS. required for GetElapsedCounterValue Api */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    49  #if (!defined(OS_AR_RELEASE_MAJOR_VERSION) || (OS_AR_RELEASE_MAJOR_VERSION != 4))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    50  #error “AUTOSAR major version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    51  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    52  #if (!defined(OS_AR_RELEASE_MINOR_VERSION) || (OS_AR_RELEASE_MINOR_VERSION != 2))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    53  #error “AUTOSAR minor version undefined or mismatched“
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    54  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    55  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    56  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    57   *********************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    58   * Defines/Macros
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    59   *********************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    60  */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    61  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    62  /* For debugging */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    63  #if ((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    64  #define WDGM_RB_FAILED_IN_ALIVE_MAINFUNCTION                            ((uint8)(1))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    65  #define WDGM_RB_FAILED_IN_DEADLINE_MAINFUNCTION                         ((uint8)(2))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    66  #define WDGM_RB_FAILED_IN_DEADLINE_CHECKPOINTREACHED                    ((uint8)(3))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    67  #define WDGM_RB_FAILED_IN_LOGICAL_INTGRAPH_CPREACHED_GRAPHNOTSTARTED    ((uint8)(4))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    68  #define WDGM_RB_FAILED_IN_LOGICAL_INTGRAPH_CPREACHED_GRAPHSTARTED       ((uint8)(5))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    69  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    70  typedef struct
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    71  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    72  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    73      VAR(TickType,WDGM_VAR_FAST_POWER_ON_CLEARED_UNSPECIFIED)                    FirstElapsedCounterValue;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    74      VAR(uint16,WDGM_VAR_FAST_POWER_ON_CLEARED_16)                               FirstExpiredCheckpointId_t;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    75      VAR(uint16,WDGM_VAR_FAST_POWER_ON_CLEARED_16)                               FirstExpiredAdditionalCheckpointId;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    76      VAR(WdgM_SupervisedEntityIdType,WDGM_VAR_FAST_POWER_ON_CLEARED_UNSPECIFIED) FirstExpiredSupervisedEntityId_t;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    77      VAR(uint8,WDGM_VAR_FAST_POWER_ON_CLEARED_8)                                 FirstExpiredLocation_t;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    78      VAR(WdgM_ModeType,AUTOMATIC)                                                FirstExpiredModeId;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    79  }WdgM_Rb_FirstExpiredEntityInfo_tst;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    80  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    81  #endif /*WDGM_RB_DEBUG_OPTION_ENABLED*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    82  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    83  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    84   **********************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    85   * Extern declarations
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    86   **********************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    87  */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    88  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    89  #define WDGM_START_SEC_VAR_FAST_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    90  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    91  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    92  extern P2CONST(WdgM_ConfigType, WDGM_VAR_FAST_CLEARED_UNSPECIFIED, WDGM_APPL_CONST)WdgM_ConfigSetPtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    93  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    94  #define WDGM_STOP_SEC_VAR_FAST_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    95  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    96  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    97  #define WDGM_START_SEC_VAR_FAST_CLEARED_BOOLEAN
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    98  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	    99  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   100  extern VAR(boolean, WDGM_VAR_FAST_CLEARED_BOOLEAN) WdgM_AliveSupervisionActive;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   101  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   102  #define WDGM_STOP_SEC_VAR_FAST_CLEARED_BOOLEAN
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   103  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   104  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   105  #define WDGM_START_SEC_VAR_FAST_CLEARED_8
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   106  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   107  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   108  extern VAR(uint8, WDGM_VAR_FAST_CLEARED_8) WdgM_Mode;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   109  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   110  #define WDGM_STOP_SEC_VAR_FAST_CLEARED_8
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   111  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   112  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   113  #define WDGM_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   114  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   115  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   116  extern VAR(uint16, WDGM_VAR_CLEARED_16) WdgM_ExpiredSupervisionCycleCtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   117  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   118  #define WDGM_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   119  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   120  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   121  #if((WDGM_DEV_ERROR_DETECT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   122  #define WDGM_START_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   123  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   124  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   125  extern VAR(uint32, WDGM_VAR_CLEARED_32) WdgM_MainFunction_Cnt_u32;  /* This variable is used only for debug purpose. */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   126  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   127  #define WDGM_STOP_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   128  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   129  #endif /*((WDGM_DEV_ERROR_DETECT) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   130  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   131  #define WDGM_START_SEC_VAR_SLOW_INIT_BOOLEAN
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   132  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   133  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   134  extern VAR(boolean, WDGM_VAR_SLOW_INIT_BOOLEAN) WdgM_Prv_FirstDeactivation_b;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   135  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   136  #define WDGM_STOP_SEC_VAR_SLOW_INIT_BOOLEAN
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   137  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   138  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   139  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   140  #define WDGM_START_SEC_VAR_FAST_POWER_ON_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   141  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   142  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   143  extern VAR(WdgM_Rb_FirstExpiredEntityInfo_tst, WDGM_VAR_FAST_POWER_ON_CLEARED_UNSPECIFIED) WdgM_Rb_FirstExpiredEntityInfo_st;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   144  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   145  #define WDGM_STOP_SEC_VAR_FAST_POWER_ON_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   146  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   147  #endif /*(WDGM_RB_DEBUG_OPTION_ENABLED == STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   148  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   149  #define WDGM_START_SEC_VAR_POWER_ON_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   150  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   151  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   152  /* TRACE[WDGM349] Implementation of non-initialized RAM location, stored as a double-inverse value */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   153  extern VAR(WdgM_SupervisedEntityIdType, WDGM_VAR_POWER_ON_CLEARED_UNSPECIFIED) WdgM_FirstExpiredSupervisedEntityId;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   154  extern VAR(WdgM_SupervisedEntityIdType, WDGM_VAR_POWER_ON_CLEARED_UNSPECIFIED) WdgM_FirstExpiredSupervisedEntityId_Comp;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   155  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   156  #define WDGM_STOP_SEC_VAR_POWER_ON_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   157  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   158  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   159  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   160  #define WDGM_START_SEC_VAR_FAST_POWER_ON_CLEARED_8
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   161  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   162  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   163  extern VAR(uint8, WDGM_VAR_FAST_POWER_ON_CLEARED_8) WdgM_Rb_FirstExpiredEntity_Cnt_u8;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   164  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   165  #define WDGM_STOP_SEC_VAR_FAST_POWER_ON_CLEARED_8
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   166  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   167  #endif /*(WDGM_RB_DEBUG_OPTION_ENABLED == STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   168  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   169  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   170   ***********************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   171   * Private Function Declaration
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   172   ***********************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   173  */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   174  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   175  #define WDGM_START_SEC_CODE
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   176  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   177  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   178  extern FUNC(void, WDGM_CODE) WdgM_Prv_SetTriggerCondition(VAR(WdgM_GlobalStatusType, AUTOMATIC)globalStatus_tu8);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   179  extern FUNC(void,WDGM_CODE) WdgM_Prv_LocalStatusMainFunction(void);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   180  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   181  #define WDGM_STOP_SEC_CODE
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   182  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   183  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   184  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   185  #define WDGM_START_SEC_CODE_FAST
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   186  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   187  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   188  extern FUNC(void, WDGM_CODE_FAST) WdgM_Rb_FirstExpiredEntity(VAR(TickType,AUTOMATIC) ElapsedCounterValue, VAR(uint16,AUTOMATIC) CheckpointID,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   189          VAR(uint16,AUTOMATIC) AdditionalCheckpointID, VAR(WdgM_SupervisedEntityIdType,AUTOMATIC) SEID,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   190          VAR(uint8,AUTOMATIC) ExpiredLocation, VAR(WdgM_ModeType,AUTOMATIC) ModeId);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   191  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   192  #define WDGM_STOP_SEC_CODE_FAST
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   193  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   194  #endif/*(WDGM_RB_DEBUG_OPTION_ENABLED == STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   195  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   196  LOCAL_INLINE void WdgM_Prv_AliveSupervisionMainFunction_v_Inl(void);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   197  LOCAL_INLINE void WdgM_Prv_UpdateAliveSupervisionDyn_v_Inl(void);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   198  LOCAL_INLINE void WdgM_Prv_UpdateTriggerDyn_v_Inl(VAR(WdgM_ModeType,AUTOMATIC) Mode, P2VAR(Std_ReturnType,AUTOMATIC,WDGM_APPL_DATA)ReturnStatus);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   199  LOCAL_INLINE void WdgM_Prv_UpdateSupervisedEntityDyn_v_Inl(VAR(WdgM_ModeType,AUTOMATIC) Mode);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   200  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   201  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   202  LOCAL_INLINE void WdgM_Rb_DebugVariables_Init_v_Inl(void);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   203  #endif/*(WDGM_RB_DEBUG_OPTION_ENABLED == STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   204  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   205  #if((WDGM_DEADLINE_TIMEOUT_DETECT == STD_ON) && ((WDGM_MAX_DEADLINE_SUPERVISIONS) > (WDGM_PRV_C_ZERO)))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   206  LOCAL_INLINE void WdgM_Prv_DeadlineSupervisionMainFunction_v_Inl(void);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   207  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   208  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   209  #if ((WDGM_MAX_DEADLINE_SUPERVISIONS) > (WDGM_PRV_C_ZERO))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   210  LOCAL_INLINE void WdgM_Prv_DeadlineSupervisionCheckpointReached_v_Inl(VAR(WdgM_SupervisedEntityIdType,AUTOMATIC) SEID,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   211  VAR(WdgM_CheckpointIdType,AUTOMATIC) CheckpointID, P2VAR(Std_ReturnType,AUTOMATIC,WDGM_APPL_DATA)ReturnStatus);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   212  LOCAL_INLINE void WdgM_Prv_UpdateDeadlineSupervisionDyn_v_Inl(VAR(WdgM_ModeType,AUTOMATIC) Mode);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   213  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   214  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   215  #if (WDGM_INTERNAL_GRAPH_CONFIGURED == STD_ON)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   216  LOCAL_INLINE Std_ReturnType WdgM_Prv_LogicalSupervisionCheckpointReached_v_Inl(VAR(WdgM_SupervisedEntityIdType,AUTOMATIC) SEID,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   217  VAR(WdgM_CheckpointIdType,AUTOMATIC) CheckpointID);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   218  #endif
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   219  /*
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   220   ************************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   221   * Inline Function Definitions
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   222   ************************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   223   */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   224  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   225  /************************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   226   * Name              :   WdgM_Rb_DebugVariables_Init_v_Inl
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   227   * Description       :   Initialises the debug Variables
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   228   * Parameters[in]    :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   229   * Limitations       :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   230   * Return Value      :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   231   ************************************************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   232  LOCAL_INLINE void WdgM_Rb_DebugVariables_Init_v_Inl(void)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   233  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   234      WdgM_Rb_FirstExpiredEntityInfo_st.FirstElapsedCounterValue          = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   235      WdgM_Rb_FirstExpiredEntityInfo_st.FirstExpiredCheckpointId_t        = WDGM_RB_MAX_CHECKPOINTID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   236      WdgM_Rb_FirstExpiredEntityInfo_st.FirstExpiredAdditionalCheckpointId= WDGM_RB_MAX_CHECKPOINTID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   237      WdgM_Rb_FirstExpiredEntityInfo_st.FirstExpiredSupervisedEntityId_t  = WDGM_RB_MAX_SUPERVISEDENTITYID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   238      WdgM_Rb_FirstExpiredEntityInfo_st.FirstExpiredLocation_t            = WDGM_RB_DEFAULT_EXPIREDLOCATION;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   239      WdgM_Rb_FirstExpiredEntityInfo_st.FirstExpiredModeId                = WDGM_RB_MAX_MODEID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   240  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   241        WdgM_Rb_FirstExpiredEntity_Cnt_u8 = WDGM_PRV_C_ONE;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   242  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   243  #endif/*(WDGM_RB_DEBUG_OPTION_ENABLED == STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   244  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   245  /************************************************************************************************************************
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   246   * Name              :   WdgM_Prv_AliveSupervisionMainFunction_v_Inl
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   247   * Description       :   Update the Alive Supervision in WdgM_MainFunction
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   248   * Parameters[in]    :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   249   * Limitations       :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   250   * Return Value      :   None
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   251   ************************************************************************************************************************/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   252  LOCAL_INLINE void WdgM_Prv_AliveSupervisionMainFunction_v_Inl(void)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   253  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   254      VAR(WdgM_SupervisedEntityIdType, AUTOMATIC) SEID;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   255      VAR(uint16, AUTOMATIC) AliveSupervisionIdx;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   256      P2CONST(WdgM_AliveSupervisionType, AUTOMATIC, WDGM_APPL_CONST) AliveSupervisionPtr;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   257      VAR(uint32,AUTOMATIC) IndividualAliveUpdateCtrCache = WDGM_PRV_C_ZERO;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   258      AliveSupervisionPtr = WdgM_ConfigSetPtr->PtrToMode[WdgM_Mode].PtrToAliveSupervision;
	ld.a	a6,[a15]16
.L362:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   259  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   260      for(AliveSupervisionIdx= WDGM_PRV_C_ZERO;
	mov	d3,#0
.L364:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   261      AliveSupervisionIdx < WdgM_ConfigSetPtr->PtrToMode[WdgM_Mode].NoOfAliveSupervision;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   262      AliveSupervisionIdx++)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   263      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   264          SEID = AliveSupervisionPtr[AliveSupervisionIdx].SupervisedEntityId;
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   265          /* TRACE[WDGM208] If SE was in local state deactivated then leave those SE
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   266           * in that state and start processing of supervision for other SE's  */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   267          /* TRACE[WDGM083] Check for Alive Supervison config, If NO then do not
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   268           * perform Alive counter examination*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   269          if(((WdgM_SupervisedEntityDyn[SEID].NewLocalStatus & WDGM_LOCAL_STATUS_DEACTIVATED)!= WDGM_LOCAL_STATUS_DEACTIVATED)&&
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   270                  (WdgM_AliveSupervisionActive == TRUE))
	movh.a	a14,#@his(WdgM_AliveSupervisionActive)
	lea	a14,[a14]@los(WdgM_AliveSupervisionActive)
	ld.bu	d4,[a14]
.L663:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   261      AliveSupervisionIdx < WdgM_ConfigSetPtr->PtrToMode[WdgM_Mode].NoOfAliveSupervision;      (inlined)
	j	.L95

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   262      AliveSupervisionIdx++)      (inlined)
.L96:
	mul	d15,d3,#10
	addsc.a	a15,a6,d15,#0
.L664:
	ld.bu	d15,[a15]5
.L366:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   271          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   272              WdgM_SupervisedEntityDyn[SEID].IndividualSupervisionCycleCtr++;
	mul	d15,d15,#12
.L367:
	movh.a	a2,#@his(WdgM_SupervisedEntityDyn)
	lea	a2,[a2]@los(WdgM_SupervisedEntityDyn)
.L665:
	addsc.a	a5,a2,d15,#0
.L666:
	mov.aa	a3,a5
	add.a	a3,#2
.L667:
	lea	a2,[a5]10
	ld.bu	d0,[a2]
.L668:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   269          if(((WdgM_SupervisedEntityDyn[SEID].NewLocalStatus & WDGM_LOCAL_STATUS_DEACTIVATED)!= WDGM_LOCAL_STATUS_DEACTIVATED)&&      (inlined)
	jnz.t	d0:2,.L97
.L669:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   270                  (WdgM_AliveSupervisionActive == TRUE))      (inlined)
	jne	d4,#1,.L98
.L670:
	ld.hu	d0,[a5]2
.L671:
	add	d0,#1
	st.h	[a3],d0
.L672:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   273              /*TRACE[WDGM098] Perform checking only at the configured Supervision Reference Cycle*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   274              if (WdgM_SupervisedEntityDyn[SEID].IndividualSupervisionCycleCtr ==
	ld.hu	d0,[a5]2
.L673:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   275                      AliveSupervisionPtr[AliveSupervisionIdx].SupervisionReferenceCycle)
	ld.hu	d1,[a15]8
.L674:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   274              if (WdgM_SupervisedEntityDyn[SEID].IndividualSupervisionCycleCtr ==      (inlined)
	jne	d0,d1,.L99
.L675:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   276              {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   277                  /*Interrupt lock to cache IndividualAliveUpdateCtr for calculation. Reset alive Counter here*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   278                  /*Interrupt Lock:
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   279                   * 1. Cache and set to 0 should be an atomic operation so as to capture new CP.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   280                   * If no Lock then after caching we can get CPR and the counter is incremented coming back to mainFunction
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   281                   * we will set the IndividualAliveUpdateCtr to 0. Hence One count will be lost.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   282                   * */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   283  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   284                  SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   285  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   286                  IndividualAliveUpdateCtrCache = WdgM_SupervisedEntityDyn[SEID].IndividualAliveUpdateCtr;
	mov.aa	a4,a5
	add.a	a4,#4
	ld.w	d0,[a4]
.L368:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   287                  WdgM_SupervisedEntityDyn[SEID].IndividualAliveUpdateCtr = WDGM_PRV_C_ZERO;
	mov	d1,#0
.L676:
	st.w	[a4],d1
.L677:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   288  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   289                  SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   290  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   291                  /*[WDGM074] Check if AliveCounter is within limit*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   292                  /*Check for if Alive counter is within the range hence "correct" state*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   293                  if (((IndividualAliveUpdateCtrCache )>=
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   294                  ((uint32)AliveSupervisionPtr[AliveSupervisionIdx].ExpectedAliveIndications - (uint32)AliveSupervisionPtr[AliveSupervisionIdx].MinMargin))&&
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   295                  ((IndividualAliveUpdateCtrCache) <=
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   296                  ((uint32)AliveSupervisionPtr[AliveSupervisionIdx].ExpectedAliveIndications + (uint32)AliveSupervisionPtr[AliveSupervisionIdx].MaxMargin)))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   297                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   298                      /* TRACE[WDGM300] If SE is in LS status FAILED and results of
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   299                       * AS are correct  and the counter for failed supervision reference cycle is >1 */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   300                      if(WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr > WDGM_PRV_C_ONE)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   301                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   302                          /*Lock Enabled: Lock required because when preempted by CRP then the newly modified value will be replaced by MainFunction here*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   303  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   304                          SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   305  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   306                          WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus | WDGM_LOCAL_STATUS_FAILED;
	ld.bu	d15,[a2]
.L678:
	ld.hu	d1,[a15]6
.L679:
	ld.hu	d5,[a15]0
.L680:
	sub	d5,d1,d5
.L681:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   293                  if (((IndividualAliveUpdateCtrCache )>=      (inlined)
	jlt.u	d0,d5,.L100
.L682:
	ld.hu	d5,[a15]2
.L683:
	add	d1,d5
.L684:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   295                  ((IndividualAliveUpdateCtrCache) <=      (inlined)
	jlt.u	d1,d0,.L101
.L685:
	ld.bu	d0,[a5]
.L369:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   300                      if(WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr > WDGM_PRV_C_ONE)      (inlined)
	jlt.u	d0,#2,.L102
.L686:
	or	d15,#1
.L687:
	st.b	[a2],d15
.L688:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   307  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   308                          SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   309  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   310                          WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr--;
	ld.bu	d15,[a5]
.L689:
	add	d15,#-1
	st.b	[a5],d15
.L690:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   306                          WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus | WDGM_LOCAL_STATUS_FAILED;      (inlined)
	j	.L103

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   300                      if(WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr > WDGM_PRV_C_ONE)      (inlined)
.L102:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   311                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   312                      /* TRACE[WDGM205] If SE is in LS status FAILED and results of AS
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   313                       * are correct and the counter for failed supervision
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   314                       * reference cycle is equal 1 */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   315                      else if(WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr == WDGM_PRV_C_ONE)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   316                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   317                          /*Lock Enabled: Lock required because when preempted by CRP then the newly modified value will be replaced by MainFunction here*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   318  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   319                          SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   320  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   321                          WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus & ((WdgM_LocalStatusType)(~WDGM_LOCAL_STATUS_FAILED));
	and	d15,#254
.L691:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   315                      else if(WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr == WDGM_PRV_C_ONE)      (inlined)
	jne	d0,#1,.L104
.L692:
	st.b	[a2],d15
.L693:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   322  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   323                          SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   324  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   325                          WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr = WDGM_PRV_C_ZERO;
	mov	d15,#0
.L694:
	st.b	[a5],d15
.L695:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   321                          WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus & ((WdgM_LocalStatusType)(~WDGM_LOCAL_STATUS_FAILED));      (inlined)
	j	.L105

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   315                      else if(WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr == WDGM_PRV_C_ONE)      (inlined)
.L104:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   326                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   327                      else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   328                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   329                          /*Lock Enabled: Lock required because when preempted by CRP then the newly modified value will be replaced by MainFunction here*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   330  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   331                          SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   332  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   333                          WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus & ((WdgM_LocalStatusType)(~WDGM_LOCAL_STATUS_FAILED));
	st.b	[a2],d15

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   327                      else      (inlined)
.L105:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   315                      else if(WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr == WDGM_PRV_C_ONE)      (inlined)
.L103:
	j	.L106

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   293                  if (((IndividualAliveUpdateCtrCache )>=      (inlined)
.L101:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   296                  ((uint32)AliveSupervisionPtr[AliveSupervisionIdx].ExpectedAliveIndications + (uint32)AliveSupervisionPtr[AliveSupervisionIdx].MaxMargin)))      (inlined)
.L100:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   334  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   335                          SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   336  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   337                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   338                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   339                  /*[WDGM115] If alive indiaction not within tolerance the incorrect*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   340                  /*Else since Alive counter is  not within the range hence "incorrect" state*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   341                  else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   342                  {   /* TRACE[WDGM202] If SE was in LS status OK and results of
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   343                       * atleast one AS is incorrect and the fault tolerence == 0*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   344                      /* TRACE[WDGM203] If SE was in LS status OK and results of
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   345                       * atleast one AS is incorrect and the failure fault tolerence > 0*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   346                      /* TRACE[WDGM204] If SE was in LS status FAILURE and results of
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   347                      * atleast one AS is incorrect and the failure supervision refrence cycle < tolerence*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   348                      /*Lock Enabled: Lock required because when preempted by CRP then the newly modified value will be replaced by MainFunction here*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   349  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   350                      SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   351  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   352                      WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus | WDGM_LOCAL_STATUS_FAILED;
	or	d15,#1
.L696:
	st.b	[a2],d15
.L697:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   353  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   354                      SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   355  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   356                      WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr++;
	ld.bu	d15,[a5]
.L698:
	add	d15,#1
	st.b	[a5],d15
.L699:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   357                      /* TRACE[WDGM206] If SE was in LS status FAILED and results of
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   358                       * atleast one AS is incorrect and the counter for failed supervision reference cycle > Ref Cycle*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   359                      if (WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr > WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleTol)
	ld.bu	d0,[a5]
.L370:
	ld.bu	d15,[a5]1
.L700:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   359                      if (WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr > WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleTol)      (inlined)
	jge.u	d15,d0,.L107
.L701:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   360                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   361                          /*Lock Enabled: Lock required because when preempted by CRP then the newly modified value will be replaced by MainFunction here*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   362  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   363                          SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   364  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   365                          WdgM_SupervisedEntityDyn[SEID].NewLocalStatus = WdgM_SupervisedEntityDyn[SEID].NewLocalStatus | WDGM_LOCAL_STATUS_EXPIRED;
	ld.bu	d15,[a2]
.L702:
	or	d15,#2
.L703:
	st.b	[a2],d15

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   359                      if (WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr > WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleTol)      (inlined)
.L107:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   341                  else      (inlined)
.L106:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   366  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   367                          SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   368  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   369  #if((WDGM_RB_DEBUG_OPTION_ENABLED) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   370                          WdgM_Rb_FirstExpiredEntity(WDGM_PRV_C_ZERO, (uint16)AliveSupervisionPtr[AliveSupervisionIdx].AliveSupervisionCheckpointId,
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   371                                                     WDGM_RB_MAX_CHECKPOINTID, SEID, WDGM_RB_FAILED_IN_ALIVE_MAINFUNCTION, WdgM_Mode);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   372  #endif/*(WDGM_RB_DEBUG_OPTION_ENABLED == STD_ON)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   373                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   374                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   375                  WdgM_SupervisedEntityDyn[SEID].IndividualSupervisionCycleCtr = WDGM_PRV_C_ZERO;
	mov	d15,#0
.L704:
	st.h	[a3],d15

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   274              if (WdgM_SupervisedEntityDyn[SEID].IndividualSupervisionCycleCtr ==      (inlined)
.L99:
	j	.L108

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   269          if(((WdgM_SupervisedEntityDyn[SEID].NewLocalStatus & WDGM_LOCAL_STATUS_DEACTIVATED)!= WDGM_LOCAL_STATUS_DEACTIVATED)&&      (inlined)
.L98:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   270                  (WdgM_AliveSupervisionActive == TRUE))      (inlined)
.L97:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   376              }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   377          }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   378          else
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   379          {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   380              /* This is required to do the syncronization of different Alive Supervisions after Mode change happens
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   381                 When mode change occurs the counters have to be reset to 0 */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   382  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   383              /*Lock Placed:
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   384                Any modification operation(Eg:incrementing the counter value) on WdgM_SupervisedEntityDyn[SEID].IndividualAliveUpdateCtr
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   385                variable is done in atomic in other places[WdgM_CheckpointReached()]. So here also modification(setting to 0) should be done in atomic.
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   386                So that modification operation is not preempted by each other
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   387              */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   388  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   389  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   390              SchM_Enter_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   391  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   392  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   393              WdgM_SupervisedEntityDyn[SEID].IndividualAliveUpdateCtr = WDGM_PRV_C_ZERO;
	mov.aa	a15,a5
	add.a	a15,#4
.L705:
	mov	d15,#0
.L706:
	st.w	[a15],d15
.L707:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   394  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   395  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   396              SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   397  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   398  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   399              /*Clear IndividualSupervisionCycleCtr and FailedAliveSupervisionRefCycleCtr When Mode change happens  */
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   400              WdgM_SupervisedEntityDyn[SEID].IndividualSupervisionCycleCtr = WDGM_PRV_C_ZERO;
	mov	d15,#0
.L708:
	st.h	[a3],d15
.L709:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   401              WdgM_SupervisedEntityDyn[SEID].FailedAliveSupervisionRefCycleCtr = WDGM_PRV_C_ZERO;
	mov	d15,#0
.L710:
	st.b	[a5],d15

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   378          else      (inlined)
.L108:
	add	d3,#1
.L365:
	extr.u	d3,d3,#0,#16

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   261      AliveSupervisionIdx < WdgM_ConfigSetPtr->PtrToMode[WdgM_Mode].NoOfAliveSupervision;      (inlined)
.L95:
	ld.a	a15,[a7]
.L711:
	addsc.a	a15,a15,d2,#0
.L712:
	ld.hu	d15,[a15]8
.L713:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   261      AliveSupervisionIdx < WdgM_ConfigSetPtr->PtrToMode[WdgM_Mode].NoOfAliveSupervision;      (inlined)
	jlt.u	d3,d15,.L96
.L714:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   406      if(WdgM_AliveSupervisionActive == FALSE)      (inlined)
	jne	d4,#0,.L109
.L715:

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   402  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   403          }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   404      }
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   405  
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   406      if(WdgM_AliveSupervisionActive == FALSE)
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   407      {
; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   408          WdgM_AliveSupervisionActive = TRUE;
	mov	d15,#1
.L716:
	st.b	[a14],d15

; BSW\src\BSW\Gen\WdgM\src\WdgM_Prv.h	   406      if(WdgM_AliveSupervisionActive == FALSE)      (inlined)
.L109:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   792          {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   793              /* Update Alive Supervision for All the SupervisedEntity */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   794              WdgM_Prv_AliveSupervisionMainFunction_v_Inl();
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   795              /* Update Deadline Supervision for All the SupervisedEntity */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   796              /* Feature enhancement as per comment 11 of Bugzilla Id : 56735 */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   797  #if((WDGM_DEADLINE_TIMEOUT_DETECT == STD_ON) && ((WDGM_MAX_DEADLINE_SUPERVISIONS) > (WDGM_PRV_C_ZERO)))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   798              WdgM_Prv_DeadlineSupervisionMainFunction_v_Inl();
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   799  #endif /*((WDGM_DEADLINE_TIMEOUT_DETECT == STD_ON) && ((WDGM_MAX_DEADLINE_SUPERVISIONS) > (WDGM_PRV_C_ZERO)))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   800              /* Local State Machine:  */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   801              WdgM_Prv_LocalStatusMainFunction();
	call	WdgM_Prv_LocalStatusMainFunction
.L363:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   802              /* Global State Machine:  */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   803              /* TRACE[WDGM214] Global State Machine should run after Local State Machine*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   804              /* TRACE[WDGM218] If global is OK or FAILED and if local is DEACTIVATE or OK then global state is set to OK*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   805              /* TRACE[WDGM078] If global is OK and if local is DEACTIVATE then global state is set to OK*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   806              NewGlobalStatus = WDGM_GLOBAL_STATUS_OK;
	mov	d9,#0
.L371:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   807              for(SEID = WDGM_PRV_C_ZERO; SEID < WDGM_NO_OF_SUPERVISED_ENTITIES; SEID++)
	mov	d0,#0
.L372:
	j	.L110
.L111:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   808              {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   809                  /* Check for all SE if any local status is EXPIRED, if yes the change gloabal status to STOPPED*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   810                  /* No lock for Local status as if previous is ok or expired then we work on old value and finally we change to expired*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   811                  if ((WdgM_SupervisedEntityDyn[SEID].NewLocalStatus & WDGM_LOCAL_STATUS_EXPIRED) == WDGM_LOCAL_STATUS_EXPIRED)
	movh.a	a15,#@his(WdgM_SupervisedEntityDyn)
	lea	a15,[a15]@los(WdgM_SupervisedEntityDyn)
.L717:
	mul	d15,d0,#12
	addsc.a	a15,a15,d15,#0
.L718:
	ld.bu	d15,[a15]10
.L719:
	jz.t	d15:1,.L112
.L720:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   812                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   813                      /* TRACE[WDGM215] If Global status is OK an any local
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   814                       * status is EXPIRED  then global status is EXPIRED */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   815                      /* TRACE[WDGM077] If Global status is FAILED an any local
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   816                       *  status is EXPIRED  then global status is EXPIRED */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   817                      NewGlobalStatus = WDGM_GLOBAL_STATUS_EXPIRED;
	mov	d9,#2
.L721:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   818                      /* TRACE[WDGM216] Check if global status is OK, any SEID's
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   819                       * local status is EXPIRED? if yes then global status is EXPIRED
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   820                       * further if expired tolerance is zero change global status to STOPPED */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   821                      /* TRACE[WDGM117]  Check if global status is FAILED any SEID's
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   822                       * local status is EXPIRED? if yes then global status is EXPIRED
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   823                       * further if expired tolerance is zero change global status to STOPPED */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   824                      if (WdgM_ConfigSetPtr->PtrToMode[WdgM_Mode].ExpiredSupervisionCycleTol == WDGM_PRV_C_ZERO)
	ld.a	a15,[a13]
.L722:
	ld.a	a15,[a15]16
.L723:
	ld.bu	d0,[a12]
.L373:
	sha	d0,#5
.L724:
	addsc.a	a15,a15,d0,#0
.L725:
	ld.hu	d15,[a15]0
.L726:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   825                      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   826                          NewGlobalStatus = WDGM_GLOBAL_STATUS_STOPPED;
	cmovn	d9,d15,#3
.L113:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   827                      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   828                      break;
	j	.L114
.L112:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   829                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   830                  /* TRACE[WDGM217] if global and local status is FAILED
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   831                   * and no local STATUS is EXPIRED the global status will remain FAILED*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   832                  /* TRACE[WDGM076] if global status is OK and any local status is FAILED
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   833                   * and no local is EXPIRED the global status will remain FAILED*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   834                  /* No lock for Local status as if previous is ok or expired then we work on old local status*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   835                  else if ((WdgM_SupervisedEntityDyn[SEID].NewLocalStatus & WDGM_LOCAL_STATUS_FAILED)==WDGM_LOCAL_STATUS_FAILED)
	jz.t	d15:0,.L115
.L727:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   836                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   837                      NewGlobalStatus = WDGM_GLOBAL_STATUS_FAILED;
	mov	d9,#1
.L728:
	j	.L116
.L115:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   838                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   839                  else
.L116:
	add	d0,#1
.L110:
	jeq	d0,#0,.L111

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   840                  {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   841                      /* Code should not come here this else is for MISRA warning*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   842                  }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   843              }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   844          }
.L114:
	j	.L117
.L94:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   845          else
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   846          {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   847              NewGlobalStatus = WDGM_GLOBAL_STATUS_EXPIRED;
	mov	d9,#2
.L374:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   848              /* TRACE[WDGM219] If global is EXPIRED and local status atleast one is
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   849               * EXPIRED and counter less than or equal to tolerance keep global
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   850               * EXPIRED and increment counter*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   851              WdgM_ExpiredSupervisionCycleCtr++;
	movh.a	a2,#@his(WdgM_ExpiredSupervisionCycleCtr)
	lea	a2,[a2]@los(WdgM_ExpiredSupervisionCycleCtr)
	ld.hu	d15,[a2]0
.L729:
	add	d15,#1
	st.h	[a2],d15
.L730:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   852              if (WdgM_ExpiredSupervisionCycleCtr > WdgM_ConfigSetPtr->PtrToMode[WdgM_Mode].ExpiredSupervisionCycleTol)
	ld.hu	d15,[a2]0
.L731:
	ld.hu	d0,[a15]0
.L732:
	ge.u	d15,d0,d15
.L733:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   853              {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   854                  /*Interrupt Lock: Disabled
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   855                   *1. Global Status is changed to STOPPED, outside the lock
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   856                   *   only SetMode can change to STOPPED , so no need for lock hence forth.
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   857                   */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   858                  /* TRACE[WDGM220] If global is EXPIRED and local status atleast one is
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   859                   * EXPIRED and counter greater than tolerance make global STOPPED */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   860                  NewGlobalStatus = WDGM_GLOBAL_STATUS_STOPPED;
	cmovn	d9,d15,#3
.L118:
.L117:
	j	.L119
.L93:
.L92:
.L91:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   861                  /* TRACE[WDGM129] When global status changed to STOPPED inform DEM*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   862              }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   863  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   864          } /* TRACE[WDGM221] Since no check for global state STOPPED hence the global status will remain STOPPED */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   865      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   866      else
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   867      {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   868          if(WdgM_Prv_SetMode_GlobalStatus == WDGM_GLOBAL_STATUS_STOPPED)
	movh.a	a15,#@his(WdgM_Prv_SetMode_GlobalStatus)
	lea	a15,[a15]@los(WdgM_Prv_SetMode_GlobalStatus)
	ld.bu	d15,[a15]
.L734:
	eq	d15,d15,#3
.L735:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   869          {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   870              NewGlobalStatus = WDGM_GLOBAL_STATUS_STOPPED;
	seln	d9,d15,d8,#3
.L375:
	j	.L121
.L120:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   871          }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   872          else
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   873          {
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   874              NewGlobalStatus = WdgM_GlobalStatus;
	mov	d9,d8
.L121:
.L119:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   875          }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   876      }
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   877  #if((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   878  #else /*(WDGM_LOCK_DISABLE_FOR_DGS == STD_OFF)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   879  	SchM_Exit_WdgM(WDGM_SCHM_EXCLSV_AREA);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   880  #endif/*((WDGM_LOCK_DISABLE_FOR_DGS) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   881  	/*Move DEM outside the interrupt lock */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   882  #if((WDGM_DEM_ALIVE_SUPERVISION_REPORT) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   883  	if((NewGlobalStatus == WDGM_GLOBAL_STATUS_STOPPED) && (GlobalStatusCached != WDGM_GLOBAL_STATUS_STOPPED))
	jne	d9,#3,.L122
.L736:
	jeq	d8,#3,.L123
.L737:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   884  	{
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   885          Dem_ReportErrorStatus(WdgM_ConfigSetPtr->ErrorSupervision, DEM_EVENT_STATUS_FAILED);
	movh.a	a15,#@his(WdgM_ConfigSetPtr)
	lea	a15,[a15]@los(WdgM_ConfigSetPtr)
	ld.a	a15,[a15]
.L738:
	ld.hu	d4,[a15]4
.L739:
	mov	d5,#1
	call	Dem_ReportErrorStatus
.L123:
.L122:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   886  	}
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   887  #endif /*((WDGM_DEM_ALIVE_SUPERVISION_REPORT) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   888  #if((WDGM_RTE_DISABLED) == (STD_OFF))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   889  	/* TRACE[WDGM198] */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   890  	if((GlobalStatusCached!= WDGM_GLOBAL_STATUS_DEACTIVATED) && (GlobalStatusCached!=WDGM_GLOBAL_STATUS_STOPPED))
	jeq	d8,#4,.L124
.L740:
	jeq	d8,#3,.L125
.L741:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   891  	{
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   892  		if (NewGlobalStatus != GlobalStatusCached)
	jeq	d9,d8,.L126
.L742:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   893  		{
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   894  			switch (NewGlobalStatus)
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   895  			{
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   896  				case WDGM_GLOBAL_STATUS_OK:
	mov	d15,#0
	jeq	d15,d9,.L127
.L743:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   897  					Rte_Switch_WdgM_globalMode_currentMode(RTE_MODE_WdgM_Mode_SUPERVISION_OK);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   898  					break;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   899  				case WDGM_GLOBAL_STATUS_FAILED:
	mov	d15,#1
	jeq	d15,d9,.L128
.L744:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   900  					Rte_Switch_WdgM_globalMode_currentMode(RTE_MODE_WdgM_Mode_SUPERVISION_FAILED);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   901  					break;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   902  				case WDGM_GLOBAL_STATUS_EXPIRED:
	mov	d15,#2
	jeq	d15,d9,.L129
.L745:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   903  					Rte_Switch_WdgM_globalMode_currentMode(RTE_MODE_WdgM_Mode_SUPERVISION_EXPIRED);
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   904  					break;
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   905  				case WDGM_GLOBAL_STATUS_STOPPED:
	mov	d15,#3
	jeq	d15,d9,.L130
	j	.L131
.L127:
	mov	d4,#0
	call	Rte_Switch_WdgM_globalMode_currentMode
.L746:
	j	.L132
.L128:
	mov	d4,#1
	call	Rte_Switch_WdgM_globalMode_currentMode
.L747:
	j	.L133
.L129:
	mov	d4,#2
	call	Rte_Switch_WdgM_globalMode_currentMode
.L748:
	j	.L134
.L130:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   906  					/* TRACE[WDGM133] Perform MCU Reset*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   907  #if((WDGM_IMMEDIATE_RESET) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   908  					Mcu_PerformReset();
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   909  					/* TRACE[WDGM134] Incase of a MCU reset do not inform RTE*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   910  #else/*(WDGM_IMMEDIATE_RESET == STD_OFF)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   911  					Rte_Switch_WdgM_globalMode_currentMode(RTE_MODE_WdgM_Mode_SUPERVISION_STOPPED);
	mov	d4,#3
	call	Rte_Switch_WdgM_globalMode_currentMode
.L749:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   912  #endif /*((WDGM_IMMEDIATE_RESET) == (STD_ON))*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   913  					break;
	j	.L135

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   914  				default: /* WDGM_GLOBAL_STATUS_DEACTIVATED: Reset is pending...!!! */
.L131:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   915  					break;
	j	.L136

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   916  			}
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   917          }
.L136:
.L135:
.L134:
.L133:
.L132:
.L126:
.L125:
.L124:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   918  	}
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   919  #elif((WDGM_IMMEDIATE_RESET) == (STD_ON))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   920  	if((NewGlobalStatus == WDGM_GLOBAL_STATUS_STOPPED)&& (GlobalStatusCached != WDGM_GLOBAL_STATUS_STOPPED))
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   921  	{
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   922  		Mcu_PerformReset();
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   923  	}
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   924  #endif /*(WDGM_RTE_DISABLED == STD_OFF)*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   925      /* TRACE[WDGM223] Based on global ststua the trigger conditions are set */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   926      /*Send trigger values the Watchdog*/
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   927  	WdgM_Prv_SetTriggerCondition(NewGlobalStatus);
	mov	d4,d9
.L376:
	call	WdgM_Prv_SetTriggerCondition
.L377:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   928      WdgM_GlobalStatus = NewGlobalStatus;
	ld.a	a15,[a10]
	st.b	[a15],d9
.L750:

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   929      return;
	j	.L137

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   930  }
.L137:
.L90:
	ret
.L281:
	
__WdgM_MainFunction_function_end:
	.size	WdgM_MainFunction,__WdgM_MainFunction_function_end-WdgM_MainFunction
.L206:
	; End of function
	
	.sdecl	'.data.WdgM.WdgM_GlobalStatus',data,cluster('WdgM_GlobalStatus')
	.sect	'.data.WdgM.WdgM_GlobalStatus'
WdgM_GlobalStatus:	.type	object
	.size	WdgM_GlobalStatus,1
	.byte	4
	.sdecl	'.data.WdgM.WdgM_Prv_SetMode_GlobalStatus',data,cluster('WdgM_Prv_SetMode_GlobalStatus')
	.sect	'.data.WdgM.WdgM_Prv_SetMode_GlobalStatus'
WdgM_Prv_SetMode_GlobalStatus:	.type	object
	.size	WdgM_Prv_SetMode_GlobalStatus,1
	.byte	4
	.calls	'WdgM_Init','Det_ReportError'
	.calls	'WdgM_Init','__INDIRECT__'
	.calls	'WdgM_Init','WdgM_SetMode'
	.calls	'WdgM_DeInit','Det_ReportError'
	.calls	'WdgM_SetMode','Det_ReportError'
	.calls	'WdgM_SetMode','Wdg_SetTriggerCondition'
	.calls	'WdgM_SetMode','Wdg_SetMode'
	.calls	'WdgM_SetMode','Dem_ReportErrorStatus'
	.calls	'WdgM_GetMode','Det_ReportError'
	.calls	'WdgM_GetLocalStatus','Det_ReportError'
	.calls	'WdgM_GetGlobalStatus','Det_ReportError'
	.calls	'WdgM_PerformReset','Det_ReportError'
	.calls	'WdgM_PerformReset','WdgM_Prv_SetTriggerCondition'
	.calls	'WdgM_GetFirstExpiredSEID','Det_ReportError'
	.calls	'WdgM_CheckpointReached','Det_ReportError'
	.calls	'WdgM_MainFunction','Det_ReportError'
	.calls	'WdgM_MainFunction','WdgM_Prv_LocalStatusMainFunction'
	.calls	'WdgM_MainFunction','Dem_ReportErrorStatus'
	.calls	'WdgM_MainFunction','Rte_Switch_WdgM_globalMode_currentMode'
	.calls	'WdgM_MainFunction','WdgM_Prv_SetTriggerCondition'
	.calls	'WdgM_Init','',0
	.calls	'WdgM_DeInit','',0
	.calls	'WdgM_SetMode','',8
	.calls	'WdgM_GetMode','',0
	.calls	'WdgM_GetLocalStatus','',0
	.calls	'WdgM_GetGlobalStatus','',0
	.calls	'WdgM_PerformReset','',0
	.calls	'WdgM_GetFirstExpiredSEID','',0
	.calls	'WdgM_CheckpointReached','',0
	.extern	Det_ReportError
	.extern	Dem_ReportErrorStatus
	.extern	Wdg_SetMode
	.extern	Wdg_SetTriggerCondition
	.extern	WdgM_SupervisedEntity
	.extern	WdgM_Config
	.extern	WdgM_SupervisedEntityDyn
	.extern	Rte_Inst_WdgM
	.extern	Rte_Switch_WdgM_globalMode_currentMode
	.extern	WdgM_ConfigSetPtr
	.extern	WdgM_AliveSupervisionActive
	.extern	WdgM_Mode
	.extern	WdgM_ExpiredSupervisionCycleCtr
	.extern	WdgM_MainFunction_Cnt_u32
	.extern	WdgM_FirstExpiredSupervisedEntityId
	.extern	WdgM_FirstExpiredSupervisedEntityId_Comp
	.extern	WdgM_Prv_SetTriggerCondition
	.extern	WdgM_Prv_LocalStatusMainFunction
	.extern	__INDIRECT__
	.calls	'WdgM_MainFunction','',8
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L159:
	.word	14887
	.half	3
	.word	.L160
	.byte	4
.L158:
	.byte	1
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L161
.L216:
	.byte	2
	.byte	'unsigned char',0,1,8,3
	.word	131
	.byte	4
	.byte	'rba_DiagLib_Bit8SetBit',0,3,1,36,19,1,1,5
	.byte	'buffer',0,1,36,49
	.word	148
	.byte	5
	.byte	'bit_position',0,1,36,63
	.word	131
	.byte	6,0,4
	.byte	'rba_DiagLib_Bit8ClearBit',0,3,1,42,19,1,1,5
	.byte	'buffer',0,1,42,51
	.word	148
	.byte	5
	.byte	'bit_position',0,1,42,65
	.word	131
	.byte	6,0,7
	.byte	'rba_DiagLib_Bit8GetSingleBit',0,3,1,60,20
	.word	131
	.byte	1,1,5
	.byte	'value',0,1,60,55
	.word	131
	.byte	5
	.byte	'bit_position',0,1,60,68
	.word	131
	.byte	6,0,4
	.byte	'rba_DiagLib_Bit8ClearBits',0,3,1,77,19,1,1,5
	.byte	'value',0,1,77,52
	.word	148
	.byte	5
	.byte	'bit_position',0,1,77,65
	.word	131
	.byte	5
	.byte	'number_of_bits',0,1,77,85
	.word	131
	.byte	6,0
.L219:
	.byte	2
	.byte	'unsigned short int',0,2,7,3
	.word	461
	.byte	4
	.byte	'rba_DiagLib_Bit16SetBit',0,3,2,36,19,1,1,5
	.byte	'buffer',0,2,36,51
	.word	483
	.byte	5
	.byte	'bit_position',0,2,36,65
	.word	131
	.byte	6,0,4
	.byte	'rba_DiagLib_Bit16ClearBit',0,3,2,42,19,1,1,5
	.byte	'buffer',0,2,42,53
	.word	483
	.byte	5
	.byte	'bit_position',0,2,42,67
	.word	131
	.byte	6,0,7
	.byte	'rba_DiagLib_Bit16GetSingleBit',0,3,2,60,21
	.word	461
	.byte	1,1,5
	.byte	'value',0,2,60,58
	.word	461
	.byte	5
	.byte	'bit_position',0,2,60,71
	.word	131
	.byte	6,0,4
	.byte	'rba_DiagLib_Bit16ClearBits',0,3,2,78,19,1,1,5
	.byte	'value',0,2,78,54
	.word	483
	.byte	5
	.byte	'bit_position',0,2,78,67
	.word	131
	.byte	5
	.byte	'number_of_bits',0,2,78,87
	.word	131
	.byte	6,0
.L294:
	.byte	2
	.byte	'unsigned int',0,4,7,3
	.word	800
	.byte	4
	.byte	'rba_DiagLib_Bit32SetBit',0,3,3,36,19,1,1,5
	.byte	'buffer',0,3,36,51
	.word	816
	.byte	5
	.byte	'bit_position',0,3,36,65
	.word	131
	.byte	6,0,4
	.byte	'rba_DiagLib_Bit32ClearBit',0,3,3,42,19,1,1,5
	.byte	'buffer',0,3,42,53
	.word	816
	.byte	5
	.byte	'bit_position',0,3,42,67
	.word	131
	.byte	6,0,7
	.byte	'rba_DiagLib_Bit32GetSingleBit',0,3,3,60,21
	.word	800
	.byte	1,1,5
	.byte	'value',0,3,60,58
	.word	800
	.byte	5
	.byte	'bit_position',0,3,60,71
	.word	131
	.byte	6,0,4
	.byte	'rba_DiagLib_Bit32ClearBits',0,3,3,78,19,1,1,5
	.byte	'value',0,3,78,54
	.word	816
	.byte	5
	.byte	'bit_position',0,3,78,67
	.word	131
	.byte	5
	.byte	'number_of_bits',0,3,78,87
	.word	131
	.byte	6,0
.L276:
	.byte	7
	.byte	'WdgM_Prv_ComplementSeId_to_Inl',0,3,4,189,2,42
	.word	131
	.byte	1,1
.L278:
	.byte	5
	.byte	'SEID',0,4,189,2,116
	.word	131
.L280:
	.byte	6,0
.L285:
	.byte	4
	.byte	'WdgM_Prv_AliveSupervisionMainFunction_v_Inl',0,3,5,252,1,19,1,1
.L288:
	.byte	6,0
.L234:
	.byte	4
	.byte	'WdgM_Prv_UpdateAliveSupervisionDyn_v_Inl',0,3,5,168,7,19,1,1
.L237:
	.byte	6,0,3
	.word	131
.L225:
	.byte	4
	.byte	'WdgM_Prv_UpdateTriggerDyn_v_Inl',0,3,5,143,8,19,1,1
.L227:
	.byte	5
	.byte	'Mode',0,5,143,8,80
	.word	131
.L229:
	.byte	5
	.byte	'ReturnStatus',0,5,143,8,132,1
	.word	1297
.L231:
	.byte	6,0
.L238:
	.byte	4
	.byte	'WdgM_Prv_UpdateSupervisedEntityDyn_v_Inl',0,3,5,179,8,19,1,1
.L240:
	.byte	5
	.byte	'Mode',0,5,179,8,89
	.word	131
.L242:
	.byte	6,0,8
	.byte	'Det_ReportError',0,6,112,16
	.word	131
	.byte	1,1,1,1,5
	.byte	'ModuleId',0,6,112,39
	.word	461
	.byte	5
	.byte	'InstanceId',0,6,112,55
	.word	131
	.byte	5
	.byte	'ApiId',0,6,112,73
	.word	131
	.byte	5
	.byte	'ErrorId',0,6,112,86
	.word	131
	.byte	0,9
	.word	153
	.byte	10
	.word	183
	.byte	10
	.word	198
	.byte	6,0,9
	.word	221
	.byte	10
	.word	253
	.byte	10
	.word	268
	.byte	6,0,9
	.word	291
	.byte	10
	.word	331
	.byte	10
	.word	345
	.byte	6,0,9
	.word	368
	.byte	10
	.word	401
	.byte	10
	.word	415
	.byte	10
	.word	436
	.byte	6,0,9
	.word	488
	.byte	10
	.word	519
	.byte	10
	.word	534
	.byte	6,0,9
	.word	557
	.byte	10
	.word	590
	.byte	10
	.word	605
	.byte	6,0,9
	.word	628
	.byte	10
	.word	669
	.byte	10
	.word	683
	.byte	6,0,9
	.word	706
	.byte	10
	.word	740
	.byte	10
	.word	754
	.byte	10
	.word	775
	.byte	6,0,9
	.word	821
	.byte	10
	.word	852
	.byte	10
	.word	867
	.byte	6,0,9
	.word	890
	.byte	10
	.word	923
	.byte	10
	.word	938
	.byte	6,0,9
	.word	961
	.byte	10
	.word	1002
	.byte	10
	.word	1016
	.byte	6,0,9
	.word	1039
	.byte	10
	.word	1073
	.byte	10
	.word	1087
	.byte	10
	.word	1108
	.byte	6,0,11
	.byte	'Dem_ReportErrorStatus',0,7,192,5,6,1,1,1,1,5
	.byte	'EventId',0,7,192,5,44
	.word	461
	.byte	5
	.byte	'EventStatus',0,7,192,5,73
	.word	131
	.byte	0,12,9,26,10,4,13
	.byte	'WDGIF_OFF_MODE',0,0,13
	.byte	'WDGIF_SLOW_MODE',0,1,13
	.byte	'WDGIF_FAST_MODE',0,2,0,8
	.byte	'Wdg_SetMode',0,8,59,37
	.word	131
	.byte	1,1,1,1,5
	.byte	'l_WdgMode',0,8,59,80
	.word	1830
	.byte	0,11
	.byte	'Wdg_SetTriggerCondition',0,8,61,21,1,1,1,1,5
	.byte	'timeout',0,8,61,52
	.word	461
	.byte	0,9
	.word	1133
	.byte	10
	.word	1176
	.byte	6,0,14,4,200,1,9,8,15
	.byte	'TriggerConditionValue',0
	.word	461
	.byte	2,2,35,0,15
	.byte	'DeviceIdx',0
	.word	131
	.byte	1,2,35,2,15
	.byte	'WdgMode',0
	.word	1830
	.byte	4,2,35,4,0,16
	.word	1993
.L223:
	.byte	3
	.word	2067
	.byte	14,4,174,1,9,10,15
	.byte	'MinMargin',0
	.word	461
	.byte	2,2,35,0,15
	.byte	'MaxMargin',0
	.word	461
	.byte	2,2,35,2,15
	.byte	'AliveSupervisionCheckpointId',0
	.word	131
	.byte	1,2,35,4,15
	.byte	'SupervisedEntityId',0
	.word	131
	.byte	1,2,35,5,15
	.byte	'ExpectedAliveIndications',0
	.word	461
	.byte	2,2,35,6,15
	.byte	'SupervisionReferenceCycle',0
	.word	461
	.byte	2,2,35,8,0,16
	.word	2077
.L246:
	.byte	3
	.word	2257
	.byte	14,4,194,1,9,2,15
	.byte	'FailedAliveSupervisionRefCycleTol',0
	.word	131
	.byte	1,2,35,0,15
	.byte	'SupervisedEntityId',0
	.word	131
	.byte	1,2,35,1,0,16
	.word	2267
.L248:
	.byte	3
	.word	2345
.L251:
	.byte	3
	.word	131
.L255:
	.byte	3
	.word	131
.L258:
	.byte	3
	.word	131
	.byte	3
	.word	800
	.byte	16
	.word	2370
	.byte	16
	.word	483
	.byte	14,4,185,1,9,12,15
	.byte	'StartCheckpointId',0
	.word	131
	.byte	1,2,35,0,15
	.byte	'StopCheckpointId',0
	.word	131
	.byte	1,2,35,1,15
	.byte	'SupervisedEntityId',0
	.word	131
	.byte	1,2,35,2,15
	.byte	'DeadlineMin',0
	.word	800
	.byte	4,2,35,4,15
	.byte	'DeadlineMax',0
	.word	800
	.byte	4,2,35,8,0,16
	.word	2385
	.byte	3
	.word	2515
	.byte	14,4,207,1,9,32,15
	.byte	'ExpiredSupervisionCycleTol',0
	.word	461
	.byte	2,2,35,0,15
	.byte	'SchMWdgMSupervisionCycle',0
	.word	131
	.byte	1,2,35,2,15
	.byte	'SupervisionCycle',0
	.word	800
	.byte	4,2,35,4,15
	.byte	'NoOfAliveSupervision',0
	.word	461
	.byte	2,2,35,8,15
	.byte	'NoOfDeadlineSupervision',0
	.word	461
	.byte	2,2,35,10,15
	.byte	'NoOfLocalStatusParams',0
	.word	461
	.byte	2,2,35,12,15
	.byte	'NoOfTrigger',0
	.word	131
	.byte	1,2,35,14,15
	.byte	'PtrToAliveSupervision',0
	.word	2262
	.byte	4,2,35,16,15
	.byte	'PtrToDeadlineSupervision',0
	.word	2520
	.byte	4,2,35,20,15
	.byte	'PtrToLocalStatusParams',0
	.word	2350
	.byte	4,2,35,24,15
	.byte	'PtrToTrigger',0
	.word	2072
	.byte	4,2,35,28,0,16
	.word	2525
	.byte	3
	.word	2862
	.byte	14,4,223,1,9,20,15
	.byte	'InitialMode',0
	.word	131
	.byte	1,2,35,0,15
	.byte	'NoOfMode',0
	.word	131
	.byte	1,2,35,1,15
	.byte	'ErrorImproperCaller',0
	.word	461
	.byte	2,2,35,2,15
	.byte	'ErrorSupervision',0
	.word	461
	.byte	2,2,35,4,15
	.byte	'ErrorSetMode',0
	.word	461
	.byte	2,2,35,6,15
	.byte	'PtrToRunningCounterValue',0
	.word	2375
	.byte	4,2,35,8,15
	.byte	'PtrToDeadlineIndices',0
	.word	2380
	.byte	4,2,35,12,15
	.byte	'PtrToMode',0
	.word	2867
	.byte	4,2,35,16,0,16
	.word	2872
.L262:
	.byte	3
	.word	3078
	.byte	17
	.word	131
	.byte	1,1,3
	.word	3088
	.byte	18
	.byte	'Rte_SwitchAckFP_WdgM_WdgM_IndividualMode_currentMode',0,11,183,4,9
	.word	3095
	.byte	19
	.word	131
	.byte	1,1,20
	.word	131
	.byte	0,3
	.word	3162
	.byte	18
	.byte	'Rte_SwitchFP_WdgM_WdgM_IndividualMode_currentMode',0,11,197,4,9
	.word	3175
	.byte	21
	.byte	'Rte_PDS_WdgM_WdgM_IndividualMode_P',0,10,62,8,8,15
	.byte	'SwitchAck_currentMode',0
	.word	3100
	.byte	4,2,35,0,15
	.byte	'Switch_currentMode',0
	.word	3180
	.byte	4,2,35,4,0,16
	.word	3239
	.byte	3
	.word	3339
	.byte	3
	.word	3088
	.byte	3
	.word	3162
	.byte	16
	.word	3239
	.byte	3
	.word	3359
.L268:
	.byte	18
	.byte	'Rte_PortHandle_WdgM_IndividualMode_P',0,10,83,82
	.word	3364
.L272:
	.byte	3
	.word	131
	.byte	8
	.byte	'Rte_Switch_WdgM_globalMode_currentMode',0,10,118,32
	.word	131
	.byte	1,1,1,1,5
	.byte	'data',0,10,118,93
	.word	131
	.byte	0,11
	.byte	'WdgM_Prv_SetTriggerCondition',0,5,178,1,30,1,1,1,1,5
	.byte	'globalStatus_tu8',0,5,178,1,96
	.word	131
	.byte	0,22
	.byte	'WdgM_Prv_LocalStatusMainFunction',0,5,179,1,29,1,1,1,1,9
	.word	1192
	.byte	6,0,9
	.word	1246
	.byte	6,0,9
	.word	1302
	.byte	10
	.word	1342
	.byte	10
	.word	1356
	.byte	6,0,9
	.word	1381
	.byte	10
	.word	1430
	.byte	6,0,23
	.byte	'__INDIRECT__',0,12,1,1,1,1,1,24,1,3
	.word	3654
	.byte	18
	.byte	'__codeptr',0,12,1,1
	.word	3656
	.byte	2
	.byte	'char',0,1,6,18
	.byte	'sint8',0,13,76,25
	.word	3679
	.byte	18
	.byte	'uint8',0,13,81,25
	.word	131
	.byte	18
	.byte	'uint16',0,13,91,25
	.word	461
	.byte	18
	.byte	'uint32',0,13,106,24
	.word	800
	.byte	2
	.byte	'unsigned long long int',0,8,7,18
	.byte	'uint64',0,13,111,30
	.word	3745
	.byte	18
	.byte	'boolean',0,13,127,25
	.word	131
	.byte	2
	.byte	'unsigned long int',0,4,7,18
	.byte	'uint16_least',0,13,147,1,25
	.word	3802
	.byte	18
	.byte	'StatusType',0,14,191,1,27
	.word	131
	.byte	18
	.byte	'Std_ReturnType',0,14,199,1,15
	.word	131
	.byte	14,14,206,1,9,8,15
	.byte	'vendorID',0
	.word	461
	.byte	2,2,35,0,15
	.byte	'moduleID',0
	.word	461
	.byte	2,2,35,2,15
	.byte	'sw_major_version',0
	.word	131
	.byte	1,2,35,4,15
	.byte	'sw_minor_version',0
	.word	131
	.byte	1,2,35,5,15
	.byte	'sw_patch_version',0
	.word	131
	.byte	1,2,35,6,0,18
	.byte	'Std_VersionInfoType',0,14,213,1,3
	.word	3889
	.byte	18
	.byte	'PduIdType',0,15,22,19
	.word	461
	.byte	18
	.byte	'PduLengthType',0,15,26,19
	.word	461
	.byte	12,16,113,9,4,13
	.byte	'TP_DATACONF',0,0,13
	.byte	'TP_DATARETRY',0,1,13
	.byte	'TP_CONFPENDING',0,2,0,18
	.byte	'TpDataStateType',0,16,118,3
	.word	4079
	.byte	18
	.byte	'Can_IdType',0,17,32,16
	.word	800
	.byte	18
	.byte	'Can_HwHandleType',0,17,43,16
	.word	461
	.byte	14,18,93,9,8,15
	.byte	'Class',0
	.word	131
	.byte	1,2,35,0,15
	.byte	'TIN',0
	.word	131
	.byte	1,2,35,1,15
	.byte	'ReturnAddress',0
	.word	800
	.byte	4,2,35,4,0,18
	.byte	'OsTrapInfoType',0,18,97,3
	.word	4199
	.byte	25,68
	.word	800
	.byte	26,16,0,14,18,154,1,9,68,15
	.byte	'store',0
	.word	4279
	.byte	68,2,35,0,0,25,68
	.word	4288
	.byte	26,0,0,18
	.byte	'Os_JumpBufType',0,18,156,1,3
	.word	4310
	.byte	18
	.byte	'Os_StackTraceType',0,18,174,1,18
	.word	800
	.byte	14,18,175,1,9,8,15
	.byte	'sp',0
	.word	800
	.byte	4,2,35,0,15
	.byte	'ctx',0
	.word	800
	.byte	4,2,35,4,0,18
	.byte	'Os_StackValueType',0,18,175,1,63
	.word	4370
	.byte	18
	.byte	'Os_StackSizeType',0,18,176,1,27
	.word	4370
	.byte	27,1,1,3
	.word	4455
	.byte	18
	.byte	'Os_VoidVoidFunctionType',0,18,179,1,16
	.word	4458
	.byte	18
	.byte	'ApplicationType',0,18,193,1,23
	.word	131
	.byte	21
	.byte	'Os_ApplicationConfigurationType_s',0,18,198,1,16,2,15
	.byte	'app_id',0
	.word	131
	.byte	1,2,35,0,15
	.byte	'access',0
	.word	131
	.byte	1,2,35,1,0,18
	.byte	'Os_ApplicationConfigurationType',0,18,201,1,3
	.word	4521
	.byte	18
	.byte	'Os_CoreStateType',0,18,203,1,16
	.word	800
	.byte	18
	.byte	'AreaIdType',0,18,204,1,16
	.word	461
	.byte	18
	.byte	'Os_PeripheralAddressType',0,18,212,1,22
	.word	800
	.byte	18
	.byte	'TickType',0,18,221,1,22
	.word	800
	.byte	18
	.byte	'Os_StopwatchTickType',0,18,225,1,22
	.word	800
	.byte	18
	.byte	'Os_Lockable',0,18,234,1,18
	.word	816
	.byte	18
	.byte	'CoreIdType',0,18,236,1,16
	.word	461
	.byte	18
	.byte	'SpinlockIdType',0,18,237,1,16
	.word	461
	.byte	12,18,239,1,9,4,13
	.byte	'TRYTOGETSPINLOCK_SUCCESS',0,0,13
	.byte	'TRYTOGETSPINLOCK_NOSUCCESS',0,1,0,18
	.byte	'TryToGetSpinlockType',0,18,239,1,74
	.word	4828
	.byte	12,18,174,2,9,4,13
	.byte	'APPLICATION_ACCESSIBLE',0,0,13
	.byte	'APPLICATION_RESTARTING',0,1,13
	.byte	'APPLICATION_TERMINATED',0,2,0,18
	.byte	'ApplicationStateType',0,18,174,2,92
	.word	4921
	.byte	28
	.byte	'void',0,3
	.word	5033
	.byte	29,1,1,20
	.word	131
	.byte	20
	.word	5039
	.byte	0,3
	.word	5044
	.byte	18
	.byte	'Os_FunctionEntryType',0,18,183,2,16
	.word	5058
	.byte	21
	.byte	'Os_MeterInfoType_s',0,18,193,2,16,48,15
	.byte	'elapsed',0
	.word	800
	.byte	4,2,35,0,15
	.byte	'previous',0
	.word	800
	.byte	4,2,35,4,15
	.byte	'max',0
	.word	800
	.byte	4,2,35,8,15
	.byte	'cumulative',0
	.word	800
	.byte	4,2,35,12,15
	.byte	'stackbase',0
	.word	4370
	.byte	8,2,35,16,15
	.byte	'stackusage',0
	.word	4370
	.byte	8,2,35,24,15
	.byte	'stackmax',0
	.word	4370
	.byte	8,2,35,32,15
	.byte	'stackbudget',0
	.word	4370
	.byte	8,2,35,40,0,18
	.byte	'Os_MeterInfoType',0,18,202,2,3
	.word	5093
	.byte	3
	.word	5093
	.byte	18
	.byte	'Os_MeterInfoRefType',0,18,203,2,50
	.word	5291
	.byte	18
	.byte	'EventMaskType',0,18,206,2,15
	.word	131
	.byte	18
	.byte	'Os_imaskType',0,18,211,2,16
	.word	800
	.byte	21
	.byte	'Os_ISRDynType_s',0,18,213,2,16,48,15
	.byte	'meter',0
	.word	5093
	.byte	48,2,35,0,0,18
	.byte	'Os_ISRDynType',0,18,215,2,3
	.word	5370
	.byte	3
	.word	5370
	.byte	16
	.word	5431
	.byte	21
	.byte	'Os_ISRType_s',0,18,216,2,16,24,15
	.byte	'entry_function',0
	.word	4463
	.byte	4,2,35,0,15
	.byte	'dynamic',0
	.word	5436
	.byte	4,2,35,4,15
	.byte	'imask',0
	.word	800
	.byte	4,2,35,8,15
	.byte	'stackbudget',0
	.word	4370
	.byte	8,2,35,12,15
	.byte	'access',0
	.word	131
	.byte	1,2,35,20,15
	.byte	'application',0
	.word	131
	.byte	1,2,35,21,0,18
	.byte	'Os_ISRType',0,18,223,2,3
	.word	5441
	.byte	3
	.word	4455
	.byte	16
	.word	5441
	.byte	3
	.word	5600
	.byte	18
	.byte	'ISRType',0,18,224,2,46
	.word	5605
	.byte	18
	.byte	'Os_bitmask',0,18,239,2,22
	.word	800
	.byte	18
	.byte	'Os_pset0Type',0,18,240,2,20
	.word	800
	.byte	18
	.byte	'Os_pset1Type',0,18,241,2,20
	.word	800
	.byte	18
	.byte	'Os_pset2Type',0,18,242,2,20
	.word	800
	.byte	30,18,243,2,9,4,15
	.byte	'p0',0
	.word	800
	.byte	4,2,35,0,15
	.byte	'p1',0
	.word	800
	.byte	4,2,35,0,15
	.byte	'p2',0
	.word	800
	.byte	4,2,35,0,0,18
	.byte	'Os_psetType',0,18,247,2,3
	.word	5713
	.byte	30,18,249,2,9,4,15
	.byte	't0',0
	.word	800
	.byte	4,2,35,0,15
	.byte	't1',0
	.word	800
	.byte	4,2,35,0,15
	.byte	't2',0
	.word	800
	.byte	4,2,35,0,0,18
	.byte	'Os_tpmaskType',0,18,253,2,3
	.word	5777
	.byte	18
	.byte	'Os_ActivationCountType',0,18,254,2,23
	.word	131
	.byte	21
	.byte	'Os_TaskDynType_s',0,18,128,3,16,120,15
	.byte	'terminate_jump_buf',0
	.word	4319
	.byte	68,2,35,0,15
	.byte	'meter',0
	.word	5093
	.byte	48,2,35,68,15
	.byte	'activation_count',0
	.word	131
	.byte	1,2,35,116,0,18
	.byte	'Os_TaskDynType',0,18,132,3,3
	.word	5875
	.byte	25,68
	.word	4288
	.byte	26,0,0,3
	.word	5875
	.byte	16
	.word	6001
	.byte	21
	.byte	'Os_TaskType_s',0,18,134,3,16,40,15
	.byte	'dynamic',0
	.word	6006
	.byte	4,2,35,0,15
	.byte	'entry_function',0
	.word	4463
	.byte	4,2,35,4,15
	.byte	'pset',0
	.word	5713
	.byte	4,2,35,8,15
	.byte	'base_tpmask',0
	.word	5777
	.byte	4,2,35,12,15
	.byte	'tpmask',0
	.word	5777
	.byte	4,2,35,16,15
	.byte	'core_id',0
	.word	461
	.byte	2,2,35,20,15
	.byte	'index',0
	.word	800
	.byte	4,2,35,24,15
	.byte	'stackbudget',0
	.word	4370
	.byte	8,2,35,28,15
	.byte	'activation_count',0
	.word	131
	.byte	1,2,35,36,15
	.byte	'access',0
	.word	131
	.byte	1,2,35,37,15
	.byte	'application',0
	.word	131
	.byte	1,2,35,38,0,18
	.byte	'Os_TaskType',0,18,146,3,3
	.word	6011
	.byte	16
	.word	6011
	.byte	3
	.word	6261
	.byte	18
	.byte	'TaskType',0,18,147,3,47
	.word	6266
	.byte	31
	.byte	'Os_TaskStateType',0,18,155,3,6,4,13
	.byte	'SUSPENDED',0,0,13
	.byte	'READY',0,1,13
	.byte	'WAITING',0,2,13
	.byte	'RUNNING',0,3,0,18
	.byte	'TaskStateType',0,18,156,3,31
	.word	6289
	.byte	30,18,167,3,3,4,15
	.byte	'tpmask',0
	.word	5777
	.byte	4,2,35,0,0,21
	.byte	'Os_ResourceDynType_s',0,18,166,3,16,4,15
	.byte	'saved_priority',0
	.word	6376
	.byte	4,2,35,0,0,18
	.byte	'Os_ResourceDynType',0,18,170,3,3
	.word	6399
	.byte	3
	.word	6399
	.byte	16
	.word	6479
	.byte	21
	.byte	'Os_ResourceType_s',0,18,171,3,16,12,15
	.byte	'dynamic',0
	.word	6484
	.byte	4,2,35,0,15
	.byte	'tpmask',0
	.word	5777
	.byte	4,2,35,4,15
	.byte	'access',0
	.word	131
	.byte	1,2,35,8,0,18
	.byte	'Os_ResourceType',0,18,175,3,3
	.word	6489
	.byte	14,18,181,3,9,12,15
	.byte	'maxallowedvalue',0
	.word	800
	.byte	4,2,35,0,15
	.byte	'ticksperbase',0
	.word	800
	.byte	4,2,35,4,15
	.byte	'mincycle',0
	.word	800
	.byte	4,2,35,8,0,18
	.byte	'AlarmBaseType',0,18,185,3,3
	.word	6588
	.byte	14,18,206,3,9,8,15
	.byte	'Running',0
	.word	131
	.byte	1,2,35,0,15
	.byte	'Pending',0
	.word	131
	.byte	1,2,35,1,15
	.byte	'Delay',0
	.word	800
	.byte	4,2,35,4,0,18
	.byte	'Os_CounterStatusType',0,18,210,3,3
	.word	6683
	.byte	3
	.word	3088
	.byte	18
	.byte	'Os_CounterIncrAdvType',0,18,217,3,22
	.word	6769
	.byte	21
	.byte	's_swd',0,18,222,3,12,4,15
	.byte	'count',0
	.word	800
	.byte	4,2,35,0,0,30,18,221,3,3,4,15
	.byte	'sw',0
	.word	6805
	.byte	4,2,35,0,0,21
	.byte	'Os_CounterDynType_s',0,18,220,3,16,4,15
	.byte	'type_dependent',0
	.word	6833
	.byte	4,2,35,0,0,18
	.byte	'Os_CounterDynType',0,18,226,3,3
	.word	6852
	.byte	3
	.word	6852
	.byte	16
	.word	6930
	.byte	21
	.byte	'Os_CounterType_s',0,18,227,3,16,28,15
	.byte	'dynamic',0
	.word	6935
	.byte	4,2,35,0,15
	.byte	'advincr',0
	.word	6774
	.byte	4,2,35,4,15
	.byte	'base',0
	.word	6588
	.byte	12,2,35,8,15
	.byte	'core',0
	.word	5039
	.byte	4,2,35,20,15
	.byte	'access',0
	.word	131
	.byte	1,2,35,24,15
	.byte	'application',0
	.word	131
	.byte	1,2,35,25,0,18
	.byte	'Os_CounterType',0,18,234,3,3
	.word	6940
	.byte	3
	.word	3088
	.byte	16
	.word	6940
	.byte	3
	.word	7092
	.byte	18
	.byte	'CounterType',0,18,235,3,52
	.word	7097
	.byte	31
	.byte	'Os_ScheduleTableStatusType',0,18,240,3,6,4,13
	.byte	'SCHEDULETABLE_STOPPED',0,0,13
	.byte	'SCHEDULETABLE_NEXT',0,1,13
	.byte	'SCHEDULETABLE_WAITING',0,2,13
	.byte	'SCHEDULETABLE_RUNNING',0,3,13
	.byte	'SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS',0,4,0,18
	.byte	'ScheduleTableStatusType',0,18,241,3,41
	.word	7123
	.byte	16
	.word	.L378-.L159
	.byte	3
	.word	7323
	.byte	18
	.byte	'ScheduleTableType',0,18,128,4,58
	.word	7328
	.byte	21
	.byte	'Os_ScheduleTableDynType_s',0,18,130,4,16,16,15
	.byte	'match',0
	.word	800
	.byte	4,2,35,0,15
	.byte	'next',0
	.word	7333
	.byte	4,2,35,4,15
	.byte	'state',0
	.word	7123
	.byte	4,2,35,8,15
	.byte	'config',0
	.word	461
	.byte	2,2,35,12,0,3
	.word	7360
	.byte	16
	.word	7453
.L378:
	.byte	21
	.byte	'Os_ScheduleTableType_s',0,18,247,3,16,16,15
	.byte	'dynamic',0
	.word	7458
	.byte	4,2,35,0,15
	.byte	'counter',0
	.word	7102
	.byte	4,2,35,4,15
	.byte	'repeat',0
	.word	131
	.byte	1,2,35,8,15
	.byte	'config',0
	.word	461
	.byte	2,2,35,10,15
	.byte	'initial',0
	.word	131
	.byte	1,2,35,12,15
	.byte	'access',0
	.word	131
	.byte	1,2,35,13,15
	.byte	'application',0
	.word	131
	.byte	1,2,35,14,0,18
	.byte	'Os_ScheduleTableType',0,18,255,3,3
	.word	7463
	.byte	16
	.word	7463
	.byte	3
	.word	7643
	.byte	16
	.word	6940
	.byte	3
	.word	7653
	.byte	32
	.word	4763
	.byte	32
	.word	5713
	.byte	32
	.word	5610
	.byte	32
	.word	6271
	.byte	32
	.word	5777
	.byte	32
	.word	131
	.byte	32
	.word	6271
	.byte	21
	.byte	'Os_ControlledCoreType_s',0,18,251,6,16,112,15
	.byte	'TrapInfo',0
	.word	4199
	.byte	8,2,35,0,15
	.byte	'lock_taskaccess',0
	.word	7663
	.byte	4,2,35,8,15
	.byte	'ReadyTasks',0
	.word	7668
	.byte	4,2,35,12,15
	.byte	'RunningISR',0
	.word	7673
	.byte	4,2,35,16,15
	.byte	'RunningTask',0
	.word	7678
	.byte	4,2,35,20,15
	.byte	'RunningTPMask',0
	.word	7683
	.byte	4,2,35,24,15
	.byte	'CurrentMeteredObject',0
	.word	5296
	.byte	4,2,35,28,15
	.byte	'IdleMeter',0
	.word	5093
	.byte	48,2,35,32,15
	.byte	'AppAccess',0
	.word	131
	.byte	1,2,35,80,15
	.byte	'AppOverride',0
	.word	7688
	.byte	1,2,35,81,15
	.byte	'GetStackValueAdjust',0
	.word	4370
	.byte	8,2,35,84,15
	.byte	'InErrorHook',0
	.word	131
	.byte	1,2,35,92,15
	.byte	'ChainTaskRef',0
	.word	7693
	.byte	4,2,35,96,15
	.byte	'GetStackUsageAdjust',0
	.word	4370
	.byte	8,2,35,100,15
	.byte	'InProtectionHook',0
	.word	131
	.byte	1,2,35,108,15
	.byte	'CoreIsActive',0
	.word	131
	.byte	1,2,35,109,15
	.byte	'InShutdownHook',0
	.word	131
	.byte	1,2,35,110,0,18
	.byte	'Os_ControlledCoreType',0,18,141,7,3
	.word	7698
	.byte	3
	.word	800
	.byte	16
	.word	5441
	.byte	3
	.word	8154
	.byte	16
	.word	6011
	.byte	3
	.word	8164
	.byte	3
	.word	5093
	.byte	21
	.byte	'Os_AnyCoreType_s',0,18,151,7,16,96,15
	.byte	'DisableAllImask',0
	.word	800
	.byte	4,2,35,0,15
	.byte	'SuspendAllImask',0
	.word	800
	.byte	4,2,35,4,15
	.byte	'SuspendOSImask',0
	.word	800
	.byte	4,2,35,8,15
	.byte	'DisableAllCount',0
	.word	800
	.byte	4,2,35,12,15
	.byte	'SuspendAllCount',0
	.word	800
	.byte	4,2,35,16,15
	.byte	'SuspendOSCount',0
	.word	800
	.byte	4,2,35,20,15
	.byte	'RestartJumpBuf',0
	.word	4319
	.byte	68,2,35,24,15
	.byte	'Restartable',0
	.word	131
	.byte	1,2,35,92,0,18
	.byte	'Os_AnyCoreType',0,18,160,7,3
	.word	8179
	.byte	18
	.byte	'Can_TxObjPriorityClassType',0,19,219,3,16
	.word	800
	.byte	21
	.byte	'Can_TxHwObjectConfigType',0,19,231,3,16,8,15
	.byte	'MsgObjId',0
	.word	131
	.byte	1,2,35,0,15
	.byte	'HwControllerId',0
	.word	131
	.byte	1,2,35,1,15
	.byte	'TxObjPriorityClass',0
	.word	800
	.byte	4,2,35,4,0,18
	.byte	'Can_TxHwObjectConfigType',0,19,252,3,3
	.word	8456
	.byte	21
	.byte	'Can_RxHwObjectConfigType',0,19,129,4,16,12,15
	.byte	'MaskRef',0
	.word	800
	.byte	4,2,35,0,15
	.byte	'MsgId',0
	.word	800
	.byte	4,2,35,4,15
	.byte	'MsgObjId',0
	.word	131
	.byte	1,2,35,8,15
	.byte	'HwControllerId',0
	.word	131
	.byte	1,2,35,9,0,18
	.byte	'Can_RxHwObjectConfigType',0,19,147,4,3
	.word	8592
	.byte	25,4
	.word	131
	.byte	26,3,0,21
	.byte	'Can_ControllerMOMapConfigType',0,19,181,4,16,4,15
	.byte	'ControllerMOMap',0
	.word	8732
	.byte	4,2,35,0,0,18
	.byte	'Can_ControllerMOMapConfigType',0,19,184,4,3
	.word	8741
	.byte	21
	.byte	'Can_NPCRValueType',0,19,188,4,16,2,15
	.byte	'Can_NPCRValue',0
	.word	461
	.byte	2,2,35,0,0,18
	.byte	'Can_NPCRValueType',0,19,191,4,3
	.word	8842
	.byte	21
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,19,194,4,16,8,15
	.byte	'CanControllerBaudrate',0
	.word	800
	.byte	4,2,35,0,15
	.byte	'CanControllerBaudrateCfg',0
	.word	461
	.byte	2,2,35,4,0,18
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,19,198,4,3
	.word	8917
	.byte	16
	.word	8917
	.byte	3
	.word	9082
	.byte	21
	.byte	'Can_BaudrateConfigPtrType',0,19,201,4,16,4,15
	.byte	'Can_kBaudrateConfigPtr',0
	.word	9087
	.byte	4,2,35,0,0,18
	.byte	'Can_BaudrateConfigPtrType',0,19,204,4,3
	.word	9092
	.byte	21
	.byte	'Can_EventHandlingType',0,19,226,4,16,4,15
	.byte	'CanEventType',0
	.word	8732
	.byte	4,2,35,0,0,18
	.byte	'Can_EventHandlingType',0,19,229,4,3
	.word	9192
	.byte	18
	.byte	'Rte_TransformerErrorCode',0,20,130,1,15
	.word	131
	.byte	18
	.byte	'Rte_TransformerClass',0,20,131,1,15
	.word	131
	.byte	14,20,168,1,9,12,15
	.byte	'in',0
	.word	5039
	.byte	4,2,35,0,15
	.byte	'out',0
	.word	5039
	.byte	4,2,35,4,15
	.byte	'used',0
	.word	461
	.byte	2,2,35,8,15
	.byte	'lost_data',0
	.word	131
	.byte	1,2,35,10,0,18
	.byte	'Rte_QDynType',0,20,173,1,3
	.word	9338
	.byte	12,20,175,1,9,4,13
	.byte	'RTE_DRA',0,0,13
	.byte	'RTE_WOWP',0,1,13
	.byte	'RTE_TASK',0,2,13
	.byte	'RTE_ARE',0,3,13
	.byte	'RTE_EV',0,4,13
	.byte	'RTE_MSI',0,5,0,18
	.byte	'Rte_NotificationType',0,20,182,1,3
	.word	9425
	.byte	3
	.word	9338
	.byte	21
	.byte	'Rte_QCmnType',0,20,184,1,16,24,15
	.byte	'dynamic',0
	.word	9523
	.byte	4,2,35,0,15
	.byte	'copy',0
	.word	131
	.byte	1,2,35,4,15
	.byte	'queue_size',0
	.word	461
	.byte	2,2,35,6,15
	.byte	'element_size',0
	.word	461
	.byte	2,2,35,8,15
	.byte	'buffer_start',0
	.word	5039
	.byte	4,2,35,12,15
	.byte	'buffer_end',0
	.word	5039
	.byte	4,2,35,16,15
	.byte	'notification_type',0
	.word	9425
	.byte	4,2,35,20,0,18
	.byte	'Rte_QCmnType',0,20,192,1,3
	.word	9528
	.byte	18
	.byte	'Rte_AlarmRefType',0,20,224,1,32
	.word	800
	.byte	18
	.byte	'Rte_AlarmIndexType',0,20,226,1,32
	.word	461
	.byte	25,128,8
	.word	131
	.byte	26,255,7,0,18
	.byte	'Impl_NVM_DstPtrType_1024',0,11,50,15
	.word	9766
	.byte	18
	.byte	'CanIf_u32_impl',0,11,69,16
	.word	800
	.byte	18
	.byte	'CanIf_u16_impl',0,11,71,16
	.word	461
	.byte	18
	.byte	'CanIf_u8_impl',0,11,73,15
	.word	131
	.byte	18
	.byte	'CanIf_ControllerModeType_Enum_impl',0,11,88,15
	.word	131
	.byte	18
	.byte	'CanIf_PduModeType_Enum_impl',0,11,90,15
	.word	131
	.byte	14,11,92,9,2,15
	.byte	'DeviceMode',0
	.word	131
	.byte	1,2,35,0,15
	.byte	'ChannelMode',0
	.word	131
	.byte	1,2,35,1,0,18
	.byte	'CanIf_ControllerStateType_struct_impl',0,11,95,3
	.word	9957
	.byte	18
	.byte	'CanIf_NotifStatusType_Enum_impl',0,11,100,15
	.word	131
	.byte	18
	.byte	'CanSM_boolean_Impl',0,11,120,15
	.word	131
	.byte	18
	.byte	'CanSM_u8_Impl',0,11,123,15
	.word	131
	.byte	18
	.byte	'CanSM_BusOffRecoveryStateType_Enum_impl',0,11,128,1,15
	.word	131
	.byte	18
	.byte	'CanSM_NetworkModeStateType_Enum_impl',0,11,132,1,15
	.word	131
	.byte	18
	.byte	'CanSM_u16_Impl',0,11,136,1,16
	.word	461
	.byte	18
	.byte	'CanSM_TimerStateType_Enum_impl',0,11,138,1,15
	.word	131
	.byte	14,11,140,1,9,4,15
	.byte	'cntTick_u16',0
	.word	461
	.byte	2,2,35,0,15
	.byte	'stTimer',0
	.word	131
	.byte	1,2,35,2,0,18
	.byte	'CanSM_TimerConfig_tst_struct_impl',0,11,143,1,3
	.word	10298
	.byte	18
	.byte	'Com_impl_u16',0,11,154,1,16
	.word	461
	.byte	18
	.byte	'Com_impl_u8',0,11,157,1,15
	.word	131
	.byte	18
	.byte	'ComM_uint32_Impl',0,11,173,1,16
	.word	800
	.byte	18
	.byte	'ComM_uint16_Impl',0,11,175,1,16
	.word	461
	.byte	18
	.byte	'ComM_uint8_Impl',0,11,177,1,15
	.word	131
	.byte	18
	.byte	'ComM_bool_Impl',0,11,179,1,15
	.word	131
	.byte	14,11,181,1,9,24,15
	.byte	'ChannelState_e',0
	.word	800
	.byte	4,2,35,0,15
	.byte	'LightTimeoutCtr_u32',0
	.word	800
	.byte	4,2,35,4,15
	.byte	'MinFullComTimeoutCtr_u16',0
	.word	461
	.byte	2,2,35,8,15
	.byte	'ChannelMode_u8',0
	.word	131
	.byte	1,2,35,10,15
	.byte	'BusSmMode_u8',0
	.word	131
	.byte	1,2,35,11,15
	.byte	'UserRequestCtr_u8',0
	.word	131
	.byte	1,2,35,12,15
	.byte	'PassiveRequestState_u8',0
	.word	131
	.byte	1,2,35,13,15
	.byte	'PncRequestCtr_u8',0
	.word	131
	.byte	1,2,35,14,15
	.byte	'InhibitionReqStatus_u8',0
	.word	131
	.byte	1,2,35,15,15
	.byte	'NmNetworkRequestStatus_b',0
	.word	131
	.byte	1,2,35,16,15
	.byte	'DiagnosticRequestState_b',0
	.word	131
	.byte	1,2,35,17,15
	.byte	'CommunicationAllowed_b',0
	.word	131
	.byte	1,2,35,18,15
	.byte	'NmBusSleepIndicationStatus_b',0
	.word	131
	.byte	1,2,35,19,15
	.byte	'NmPrepareBusSleepIndicationStatus_b',0
	.word	131
	.byte	1,2,35,20,15
	.byte	'NmNetworkModeStatus_b',0
	.word	131
	.byte	1,2,35,21,0,18
	.byte	'ComM_ChannelStruct_Impl',0,11,197,1,3
	.word	10530
	.byte	14,11,206,1,9,10,15
	.byte	'WakeUpInhibitionCtr_u16',0
	.word	461
	.byte	2,2,35,0,15
	.byte	'LimitToNoComCtr_u16',0
	.word	461
	.byte	2,2,35,2,15
	.byte	'RequestedUserMode_t',0
	.word	131
	.byte	1,2,35,4,15
	.byte	'IndicatedUserMode_t',0
	.word	131
	.byte	1,2,35,5,15
	.byte	'numChannelsInFullCom_u8',0
	.word	131
	.byte	1,2,35,6,15
	.byte	'numChannelsInSilentCom_u8',0
	.word	131
	.byte	1,2,35,7,15
	.byte	'numChannelsInNoCom_u8',0
	.word	131
	.byte	1,2,35,8,0,18
	.byte	'ComM_UserStruct_Impl',0,11,214,1,3
	.word	11034
	.byte	18
	.byte	'Dcm_IOOperationResponseType',0,11,252,1,15
	.word	131
	.byte	18
	.byte	'Dcm_RequestDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspRequestRoutineResultsOutSignal_0PrimitivType',0
	.byte	11,138,2,15
	.word	131
	.byte	18
	.byte	'Dcm_StartDataIn_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineInSignalPrimitivType',0,11,146,2,15
	.word	131
	.byte	18
	.byte	'Dcm_StartDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineOutSignalPrimitivType',0,11,150,2,15
	.word	131
	.byte	18
	.byte	'Dcm_StopDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStopRoutineOutSignalPrimitivType',0,11,154,2,15
	.word	131
	.byte	18
	.byte	'Dem_EventIdType',0,11,168,2,16
	.word	461
	.byte	18
	.byte	'Dem_EventStatusType',0,11,170,2,15
	.word	131
	.byte	18
	.byte	'WdgM_CheckpointIdType',0,11,133,3,15
	.word	131
	.byte	18
	.byte	'WdgM_SupervisedEntityIdType',0,11,135,3,15
	.word	131
	.byte	18
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockNative_1024_Type',0,11,243,3,34
	.word	9777
	.byte	25,128,8
	.word	131
	.byte	26,255,7,0,18
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockRedundant_1024_Type',0,11,246,3,34
	.word	9777
	.byte	18
	.byte	'Rte_ModeType_WdgMSupervisionCycle',0,21,24,15
	.word	131
	.byte	18
	.byte	'WdgIf_ModeType',0,9,31,3
	.word	1830
	.byte	18
	.byte	'WdgM_ModeType',0,4,128,1,15
	.word	131
	.byte	18
	.byte	'WdgM_LocalStatusType',0,4,129,1,15
	.word	131
	.byte	18
	.byte	'WdgM_GlobalStatusType',0,4,130,1,15
	.word	131
	.byte	14,4,133,1,9,8,15
	.byte	'NoOfDeadlineSupervision',0
	.word	461
	.byte	2,2,35,0,15
	.byte	'PtrToDeadlineIndices',0
	.word	483
	.byte	4,2,35,4,0,18
	.byte	'WdgM_CheckpointDynType',0,4,137,1,2
	.word	12123
	.byte	3
	.word	12123
	.byte	16
	.word	12225
	.byte	14,4,139,1,9,4,15
	.byte	'PtrToCheckpointDyn',0
	.word	12230
	.byte	4,2,35,0,0,18
	.byte	'WdgM_CheckpointType',0,4,142,1,2
	.word	12235
	.byte	14,4,144,1,9,12,15
	.byte	'FailedAliveSupervisionRefCycleCtr',0
	.word	131
	.byte	1,2,35,0,15
	.byte	'FailedAliveSupervisionRefCycleTol',0
	.word	131
	.byte	1,2,35,1,15
	.byte	'IndividualSupervisionCycleCtr',0
	.word	461
	.byte	2,2,35,2,15
	.byte	'IndividualAliveUpdateCtr',0
	.word	800
	.byte	4,2,35,4,15
	.byte	'AliveSupervisionIdx',0
	.word	461
	.byte	2,2,35,8,15
	.byte	'NewLocalStatus',0
	.word	131
	.byte	1,2,35,10,15
	.byte	'OldLocalStatus',0
	.word	131
	.byte	1,2,35,11,0,18
	.byte	'WdgM_SupervisedEntityDynType',0,4,157,1,2
	.word	12299
	.byte	16
	.word	12235
	.byte	3
	.word	12580
	.byte	3
	.word	12299
	.byte	16
	.word	12590
	.byte	14,4,159,1,9,20,15
	.byte	'NoOfCheckpoint',0
	.word	461
	.byte	2,2,35,0,15
	.byte	'PartionEnabled',0
	.word	131
	.byte	1,2,35,2,15
	.byte	'TimerId',0
	.word	7102
	.byte	4,2,35,4,15
	.byte	'OsApplicationId',0
	.word	131
	.byte	1,2,35,8,15
	.byte	'PtrToCheckpoint',0
	.word	12585
	.byte	4,2,35,12,15
	.byte	'PtrToSupervisedEntityDyn',0
	.word	12595
	.byte	4,2,35,16,0,18
	.byte	'WdgM_SupervisedEntityType',0,4,171,1,2
	.word	12600
	.byte	18
	.byte	'WdgM_AliveSupervisionType',0,4,182,1,2
	.word	2077
	.byte	18
	.byte	'WdgM_DeadlineSupervisionType',0,4,192,1,2
	.word	2385
	.byte	18
	.byte	'WdgM_LocalStatusParamsType',0,4,198,1,2
	.word	2267
	.byte	18
	.byte	'WdgM_TriggerType',0,4,205,1,2
	.word	1993
	.byte	18
	.byte	'WdgM_PrvModeType',0,4,220,1,2
	.word	2525
	.byte	18
	.byte	'WdgM_ConfigType',0,4,239,1,2
	.word	2872
	.byte	25,20
	.word	12600
	.byte	26,0,0,16
	.word	12977
	.byte	33
	.byte	'WdgM_SupervisedEntity',0,4,141,2,70
	.word	12986
	.byte	1,1,16
	.word	2872
	.byte	33
	.byte	'WdgM_Config',0,4,158,2,60
	.word	13024
	.byte	1,1,25,12
	.word	12299
	.byte	26,0,0,33
	.byte	'WdgM_SupervisedEntityDyn',0,4,174,2,77
	.word	13052
	.byte	1,1,18
	.byte	'Rte_TaskRefType',0,22,184,1,32
	.word	6271
	.byte	18
	.byte	'Rte_EventRefType',0,22,185,1,32
	.word	131
	.byte	18
	.byte	'Rte_EventType',0,22,186,1,32
	.word	800
	.byte	18
	.byte	'Rte_REActCounterType',0,22,252,1,15
	.word	131
	.byte	3
	.word	131
	.byte	18
	.byte	'Rte_REActCounterRefType',0,22,253,1,58
	.word	13201
	.byte	14,22,255,1,9,8,15
	.byte	'task',0
	.word	13097
	.byte	4,2,35,0,15
	.byte	'acnt',0
	.word	13206
	.byte	4,2,35,4,0,18
	.byte	'Rte_REContainerType',0,22,130,2,3
	.word	13239
	.byte	16
	.word	6011
	.byte	3
	.word	13303
	.byte	3
	.word	131
	.byte	16
	.word	13239
	.byte	3
	.word	13318
	.byte	18
	.byte	'Rte_REContainerRefType',0,22,132,2,60
	.word	13323
	.byte	18
	.byte	'Rte_MSICounterType',0,22,149,2,16
	.word	461
	.byte	3
	.word	461
	.byte	18
	.byte	'Rte_MSICounterRefType',0,22,150,2,56
	.word	13388
	.byte	18
	.byte	'Rte_MSIPendingFlagType',0,22,152,2,17
	.word	131
	.byte	3
	.word	131
	.byte	18
	.byte	'Rte_MSIPendingFlagRefType',0,22,153,2,60
	.word	13456
	.byte	14,22,163,2,9,24,15
	.byte	'counter',0
	.word	13393
	.byte	4,2,35,0,15
	.byte	'incCounter',0
	.word	131
	.byte	1,2,35,4,15
	.byte	'pending',0
	.word	13461
	.byte	4,2,35,8,15
	.byte	'osTask',0
	.word	13097
	.byte	4,2,35,12,15
	.byte	'acnt',0
	.word	13206
	.byte	4,2,35,16,15
	.byte	'osEvent',0
	.word	131
	.byte	1,2,35,20,15
	.byte	'MSIInit',0
	.word	461
	.byte	2,2,35,22,0,18
	.byte	'Rte_MSITableEntry',0,22,172,2,3
	.word	13496
	.byte	3
	.word	461
	.byte	3
	.word	131
	.byte	18
	.byte	'Rte_TaskArrayIndex',0,22,179,2,16
	.word	131
	.byte	18
	.byte	'Rte_NrWaitingTasks',0,22,180,2,16
	.word	131
	.byte	14,22,182,2,9,4,15
	.byte	'pending',0
	.word	131
	.byte	1,2,35,0,15
	.byte	'count',0
	.word	131
	.byte	1,2,35,1,15
	.byte	'firstWaitingTask',0
	.word	131
	.byte	1,2,35,2,0,18
	.byte	'Rte_WaitableDatum',0,22,186,2,3
	.word	13714
	.byte	3
	.word	13714
	.byte	14,22,226,2,9,12,15
	.byte	'event_id',0
	.word	800
	.byte	4,2,35,0,15
	.byte	'wd',0
	.word	13806
	.byte	4,2,35,4,15
	.byte	'timeout',0
	.word	800
	.byte	4,2,35,8,0,18
	.byte	'Rte_WOWP_NotificationType',0,22,230,2,3
	.word	13811
	.byte	16
	.word	13811
	.byte	3
	.word	13900
	.byte	18
	.byte	'Rte_WOWP_NotificationRefType',0,22,232,2,66
	.word	13905
	.byte	18
	.byte	'Rte_ARE_NotificationType',0,22,234,2,29
	.word	13239
	.byte	21
	.byte	'Rte_QTaskType',0,22,243,2,16,28,15
	.byte	'cmn',0
	.word	9528
	.byte	24,2,35,0,15
	.byte	'task',0
	.word	13097
	.byte	4,2,35,24,0,18
	.byte	'Rte_QTaskType',0,22,246,2,3
	.word	13982
	.byte	21
	.byte	'Rte_QREType',0,22,250,2,16,28,15
	.byte	'cmn',0
	.word	9528
	.byte	24,2,35,0,15
	.byte	're',0
	.word	13328
	.byte	4,2,35,24,0,18
	.byte	'Rte_QREType',0,22,253,2,3
	.word	14053
	.byte	16
	.word	13239
	.byte	3
	.word	14118
	.byte	21
	.byte	'Rte_QWWPType',0,22,129,3,16,28,15
	.byte	'cmn',0
	.word	9528
	.byte	24,2,35,0,15
	.byte	'wwp',0
	.word	13910
	.byte	4,2,35,24,0,18
	.byte	'Rte_QWWPType',0,22,132,3,3
	.word	14128
	.byte	16
	.word	13811
	.byte	3
	.word	14196
	.byte	21
	.byte	'Rte_QEvType',0,22,136,3,16,36,15
	.byte	'cmn',0
	.word	9528
	.byte	24,2,35,0,15
	.byte	'task',0
	.word	13097
	.byte	4,2,35,24,15
	.byte	'mask',0
	.word	131
	.byte	1,2,35,28,15
	.byte	'acnt',0
	.word	13206
	.byte	4,2,35,32,0,18
	.byte	'Rte_QEvType',0,22,141,3,3
	.word	14206
	.byte	21
	.byte	'Rte_QMSIType',0,22,145,3,16,48,15
	.byte	'cmn',0
	.word	9528
	.byte	24,2,35,0,15
	.byte	'task',0
	.word	13097
	.byte	4,2,35,24,15
	.byte	'mask',0
	.word	131
	.byte	1,2,35,28,15
	.byte	'acnt',0
	.word	13206
	.byte	4,2,35,32,15
	.byte	'msiCounter',0
	.word	13393
	.byte	4,2,35,36,15
	.byte	'msiPending',0
	.word	13461
	.byte	4,2,35,40,15
	.byte	'msiLimit',0
	.word	461
	.byte	2,2,35,44,0,18
	.byte	'Rte_QMSIType',0,22,153,3,3
	.word	14301
	.byte	25,8
	.word	3239
	.byte	26,0,0,18
	.byte	'Rte_PDS_WdgM_WdgM_IndividualMode_PA',0,10,67,51
	.word	14456
	.byte	21
	.byte	'Rte_CDS_WdgM',0,10,68,8,8,15
	.byte	'mode_WdgMSupervisedEntity_Alive_Supervision_Entity1',0
	.word	14465
	.byte	8,2,35,0,0,16
	.word	14509
	.byte	33
	.byte	'Rte_Inst_WdgM',0,10,96,46
	.word	14589
	.byte	1,1,25,8
	.word	3239
	.byte	26,0,0,33
	.byte	'WdgM_ConfigSetPtr',0,5,92,84
	.word	3083
	.byte	1,1,33
	.byte	'WdgM_AliveSupervisionActive',0,5,100,52
	.word	131
	.byte	1,1,33
	.byte	'WdgM_Mode',0,5,108,44
	.word	131
	.byte	1,1,33
	.byte	'WdgM_ExpiredSupervisionCycleCtr',0,5,116,41
	.word	461
	.byte	1,1,33
	.byte	'WdgM_MainFunction_Cnt_u32',0,5,125,41
	.word	800
	.byte	1,1,33
	.byte	'WdgM_FirstExpiredSupervisedEntityId',0,5,153,1,80
	.word	131
	.byte	1,1,33
	.byte	'WdgM_FirstExpiredSupervisedEntityId_Comp',0,5,154,1,80
	.word	131
	.byte	1,1,0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L160:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,36,0,3,8,11,15,62,15,0,0,3,15,0,73,19,0,0,4,46,1,3,8,32
	.byte	13,58,15,59,15,57,15,54,15,39,12,0,0,5,5,0,3,8,58,15,59,15,57,15,73,19,0,0,6,11,0,0,0,7,46,1,3,8,32,13
	.byte	58,15,59,15,57,15,73,19,54,15,39,12,0,0,8,46,1,3,8,58,15,59,15,57,15,73,19,54,15,39,12,63,12,60,12,0,0
	.byte	9,46,1,49,19,0,0,10,5,0,49,19,0,0,11,46,1,3,8,58,15,59,15,57,15,54,15,39,12,63,12,60,12,0,0,12,4,1,58
	.byte	15,59,15,57,15,11,15,0,0,13,40,0,3,8,28,13,0,0,14,19,1,58,15,59,15,57,15,11,15,0,0,15,13,0,3,8,73,19,11
	.byte	15,56,9,0,0,16,38,0,73,19,0,0,17,21,0,73,19,54,15,39,12,0,0,18,22,0,3,8,58,15,59,15,57,15,73,19,0,0,19
	.byte	21,1,73,19,54,15,39,12,0,0,20,5,0,73,19,0,0,21,19,1,3,8,58,15,59,15,57,15,11,15,0,0,22,46,0,3,8,58,15
	.byte	59,15,57,15,54,15,39,12,63,12,60,12,0,0,23,46,0,3,8,58,15,59,15,57,15,54,15,63,12,60,12,0,0,24,21,0,54
	.byte	15,0,0,25,1,1,11,15,73,19,0,0,26,33,0,47,15,0,0,27,21,0,54,15,39,12,0,0,28,59,0,3,8,0,0,29,21,1,54,15
	.byte	39,12,0,0,30,23,1,58,15,59,15,57,15,11,15,0,0,31,4,1,3,8,58,15,59,15,57,15,11,15,0,0,32,53,0,73,19,0,0
	.byte	33,52,0,3,8,58,15,59,15,57,15,73,19,63,12,60,12,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L161:
	.word	.L380-.L379
.L379:
	.half	3
	.word	.L382-.L381
.L381:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Rba_DiagLib\\src\\rba_DiagLib_Bits8.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Rba_DiagLib\\src\\rba_DiagLib_Bits16.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Rba_DiagLib\\src\\rba_DiagLib_Bits32.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\WdgM\\WdgM_Cfg.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM_Prv.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Det\\api\\Det.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Dem\\api\\Dem.h',0,0,0,0
	.byte	'.\\Integration\\MCAL\\Include\\Wdg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\WdgIf\\api\\WdgIf_Types.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_WdgM.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Type.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM.c',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Platform\\Platform_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Std_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Can_GeneralTypes.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\RTOS_T\\Gen\\inc\\Os.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Can_17_MCanP\\inc\\Can_17_MCanP.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte.h',0,0,0,0
	.byte	'.\\RTE\\gen\\SchM_WdgM_Type.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Intl.h',0,0,0,0,0
.L382:
.L380:
	.sdecl	'.debug_info',debug,cluster('WdgM_SetMode')
	.sect	'.debug_info'
.L162:
	.word	575
	.half	3
	.word	.L163
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L165,.L164
	.byte	2
	.word	.L158
	.byte	3
	.byte	'WdgM_SetMode',0,1,139,2,38
	.word	.L216
	.byte	1,1,1
	.word	.L143,.L217,.L142
	.byte	4
	.byte	'Mode',0,1,139,2,80
	.word	.L216,.L218
	.byte	4
	.byte	'CallerID',0,1,139,2,108
	.word	.L219,.L220
	.byte	5
	.word	.L143,.L217
	.byte	6
	.byte	'ctr',0,1,147,2,27
	.word	.L216,.L221
	.byte	6
	.byte	'ReturnStatus',0,1,151,2,36
	.word	.L216,.L222
	.byte	6
	.byte	'TriggerPtr',0,1,157,2,59
	.word	.L223,.L224
	.byte	7
	.word	.L225,.L226,.L34
	.byte	8
	.word	.L227,.L228
	.byte	8
	.word	.L229,.L230
	.byte	9
	.word	.L231,.L226,.L34
	.byte	6
	.byte	'triggerIdx_u8',0,2,145,8,27
	.word	.L216,.L232
	.byte	6
	.byte	'TriggerPtr',0,2,146,8,59
	.word	.L223,.L233
	.byte	0,0,7
	.word	.L234,.L235,.L236
	.byte	10
	.word	.L237,.L235,.L236
	.byte	0,7
	.word	.L238,.L236,.L239
	.byte	8
	.word	.L240,.L241
	.byte	9
	.word	.L242,.L236,.L239
	.byte	6
	.byte	'ctr',0,2,181,8,28
	.word	.L219,.L243
	.byte	6
	.byte	'SEID',0,2,182,8,49
	.word	.L216,.L244
	.byte	6
	.byte	'LspIdx',0,2,183,8,49
	.word	.L216,.L245
	.byte	6
	.byte	'AliveSupervisionPtr',0,2,184,8,68
	.word	.L246,.L247
	.byte	6
	.byte	'LocalStatusParamsPtr',0,2,185,8,69
	.word	.L248,.L249
	.byte	0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('WdgM_SetMode')
	.sect	'.debug_abbrev'
.L163:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,7,29,1,49,16,17,1,18,1,0,0,8,5,0,49,16,2,6,0,0,9,11,1,49,16,17
	.byte	1,18,1,0,0,10,11,0,49,16,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('WdgM_SetMode')
	.sect	'.debug_line'
.L164:
	.word	.L384-.L383
.L383:
	.half	3
	.word	.L386-.L385
.L385:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM_Prv.h',0,0,0,0,0
.L386:
	.byte	5,38,7,0,5,2
	.word	.L143
	.byte	3,138,2,1,5,20,9
	.half	.L312-.L143
	.byte	3,23,1,5,18,9
	.half	.L387-.L312
	.byte	1,5,20,9
	.half	.L388-.L387
	.byte	3,3,1,5,5,9
	.half	.L389-.L388
	.byte	1,5,13,7,9
	.half	.L390-.L389
	.byte	3,36,1,5,9,9
	.half	.L391-.L390
	.byte	1,5,35,7,9
	.half	.L392-.L391
	.byte	3,3,1,5,51,9
	.half	.L311-.L392
	.byte	1,5,69,9
	.half	.L310-.L311
	.byte	1,5,91,9
	.half	.L393-.L310
	.byte	1,5,20,9
	.half	.L394-.L393
	.byte	3,1,1,5,13,9
	.half	.L395-.L394
	.byte	1,5,21,9
	.half	.L16-.L395
	.byte	3,3,1,5,38,9
	.half	.L396-.L16
	.byte	1,5,9,9
	.half	.L397-.L396
	.byte	1,5,35,7,9
	.half	.L398-.L397
	.byte	3,3,1,5,51,9
	.half	.L315-.L398
	.byte	1,5,69,9
	.half	.L314-.L315
	.byte	1,5,90,9
	.half	.L399-.L314
	.byte	1,5,20,9
	.half	.L400-.L399
	.byte	3,1,1,5,13,9
	.half	.L401-.L400
	.byte	1,5,51,9
	.half	.L18-.L401
	.byte	3,11,1,5,39,9
	.half	.L402-.L18
	.byte	1,5,50,9
	.half	.L403-.L402
	.byte	1,5,56,9
	.half	.L404-.L403
	.byte	1,5,16,9
	.half	.L318-.L404
	.byte	3,1,1,5,87,9
	.half	.L320-.L318
	.byte	1,5,27,9
	.half	.L21-.L320
	.byte	3,2,1,5,32,9
	.half	.L405-.L21
	.byte	1,5,13,9
	.half	.L406-.L405
	.byte	1,5,39,7,9
	.half	.L407-.L406
	.byte	3,4,1,5,55,9
	.half	.L317-.L407
	.byte	1,5,73,9
	.half	.L316-.L317
	.byte	1,5,95,9
	.half	.L408-.L316
	.byte	1,5,24,9
	.half	.L319-.L408
	.byte	3,2,1,5,17,9
	.half	.L409-.L319
	.byte	1,5,92,9
	.half	.L22-.L409
	.byte	3,120,1,5,41,9
	.half	.L20-.L22
	.byte	1,5,58,9
	.half	.L410-.L20
	.byte	1,5,69,9
	.half	.L411-.L410
	.byte	1,5,75,9
	.half	.L412-.L411
	.byte	1,5,87,9
	.half	.L413-.L412
	.byte	1,5,21,7,9
	.half	.L15-.L413
	.byte	3,112,1,5,16,9
	.half	.L414-.L15
	.byte	3,37,1,5,33,9
	.half	.L415-.L414
	.byte	1,5,8,9
	.half	.L416-.L415
	.byte	1,5,48,7,9
	.half	.L417-.L416
	.byte	1,5,47,9
	.half	.L418-.L417
	.byte	1,5,24,7,9
	.half	.L419-.L418
	.byte	3,1,1,5,68,7,9
	.half	.L420-.L419
	.byte	1,5,65,9
	.half	.L421-.L420
	.byte	1,5,48,7,9
	.half	.L25-.L421
	.byte	3,4,1,4,2,5,21,9
	.half	.L226-.L25
	.byte	3,153,5,1,5,19,9
	.half	.L422-.L226
	.byte	1,5,23,9
	.half	.L423-.L422
	.byte	3,3,1,5,41,9
	.half	.L322-.L423
	.byte	3,2,1,5,104,9
	.half	.L424-.L322
	.byte	3,126,1,5,12,9
	.half	.L29-.L424
	.byte	3,2,1,5,29,9
	.half	.L425-.L29
	.byte	1,5,40,9
	.half	.L426-.L425
	.byte	1,5,46,9
	.half	.L427-.L426
	.byte	1,5,59,9
	.half	.L428-.L427
	.byte	1,5,74,9
	.half	.L429-.L428
	.byte	1,5,9,9
	.half	.L430-.L429
	.byte	1,5,13,7,9
	.half	.L431-.L430
	.byte	3,2,1,5,119,9
	.half	.L30-.L431
	.byte	3,124,1,5,58,9
	.half	.L28-.L30
	.byte	1,5,75,9
	.half	.L432-.L28
	.byte	1,5,86,9
	.half	.L433-.L432
	.byte	1,5,92,9
	.half	.L434-.L433
	.byte	1,5,104,9
	.half	.L435-.L434
	.byte	1,5,18,7,9
	.half	.L436-.L435
	.byte	3,10,1,5,35,9
	.half	.L437-.L436
	.byte	1,5,46,9
	.half	.L438-.L437
	.byte	1,5,52,9
	.half	.L439-.L438
	.byte	1,5,22,9
	.half	.L325-.L439
	.byte	3,1,1,5,101,9
	.half	.L440-.L325
	.byte	1,5,25,9
	.half	.L32-.L440
	.byte	3,2,1,5,23,9
	.half	.L441-.L32
	.byte	1,5,13,9
	.half	.L442-.L441
	.byte	3,1,1,5,9,9
	.half	.L443-.L442
	.byte	1,5,55,7,9
	.half	.L444-.L443
	.byte	3,125,1,5,13,9
	.half	.L445-.L444
	.byte	3,5,1,5,116,9
	.half	.L33-.L445
	.byte	3,123,1,5,55,9
	.half	.L31-.L33
	.byte	1,5,72,9
	.half	.L446-.L31
	.byte	1,5,83,9
	.half	.L447-.L446
	.byte	1,5,89,9
	.half	.L448-.L447
	.byte	1,5,101,9
	.half	.L449-.L448
	.byte	1,4,1,5,12,7,9
	.half	.L34-.L449
	.byte	3,218,122,1,5,9,9
	.half	.L450-.L34
	.byte	1,4,2,5,5,7,9
	.half	.L235-.L450
	.byte	3,183,4,1,5,35,9
	.half	.L451-.L235
	.byte	1,5,33,9
	.half	.L452-.L451
	.byte	1,5,56,9
	.half	.L236-.L452
	.byte	3,137,1,1,5,44,9
	.half	.L453-.L236
	.byte	1,5,55,9
	.half	.L454-.L453
	.byte	1,5,61,9
	.half	.L455-.L454
	.byte	1,5,62,9
	.half	.L326-.L455
	.byte	3,1,1,5,14,9
	.half	.L327-.L326
	.byte	3,2,1,5,70,9
	.half	.L328-.L327
	.byte	1,5,20,9
	.half	.L37-.L328
	.byte	3,2,1,9
	.half	.L329-.L37
	.byte	3,4,1,5,44,9
	.half	.L456-.L329
	.byte	1,5,104,9
	.half	.L457-.L456
	.byte	3,124,1,5,36,9
	.half	.L39-.L457
	.byte	3,2,1,5,44,9
	.half	.L458-.L39
	.byte	1,5,13,9
	.half	.L459-.L458
	.byte	1,5,50,7,9
	.half	.L460-.L459
	.byte	3,2,1,5,17,9
	.half	.L461-.L460
	.byte	1,5,69,7,9
	.half	.L462-.L461
	.byte	3,8,1,5,67,9
	.half	.L463-.L462
	.byte	1,5,116,9
	.half	.L464-.L463
	.byte	3,1,1,5,86,9
	.half	.L465-.L464
	.byte	1,5,17,9
	.half	.L41-.L465
	.byte	3,3,1,5,112,9
	.half	.L40-.L41
	.byte	3,112,1,5,65,9
	.half	.L38-.L40
	.byte	1,5,76,9
	.half	.L466-.L38
	.byte	1,5,82,9
	.half	.L467-.L466
	.byte	1,5,104,9
	.half	.L468-.L467
	.byte	1,5,40,7,9
	.half	.L42-.L468
	.byte	3,29,1,5,51,9
	.half	.L469-.L42
	.byte	1,5,57,9
	.half	.L470-.L469
	.byte	1,5,12,9
	.half	.L471-.L470
	.byte	1,5,49,7,9
	.half	.L472-.L471
	.byte	3,1,1,5,94,9
	.half	.L473-.L472
	.byte	1,5,61,7,9
	.half	.L474-.L473
	.byte	3,2,1,5,59,9
	.half	.L475-.L474
	.byte	1,5,80,9
	.half	.L476-.L475
	.byte	3,1,1,5,78,9
	.half	.L477-.L476
	.byte	1,5,17,9
	.half	.L43-.L477
	.byte	3,9,1,5,97,9
	.half	.L331-.L43
	.byte	1,5,35,9
	.half	.L46-.L331
	.byte	3,2,1,5,40,9
	.half	.L478-.L46
	.byte	1,5,13,9
	.half	.L479-.L478
	.byte	1,5,17,7,9
	.half	.L480-.L479
	.byte	3,2,1,5,102,9
	.half	.L47-.L480
	.byte	3,124,1,5,59,9
	.half	.L45-.L47
	.byte	1,5,70,9
	.half	.L481-.L45
	.byte	1,5,76,9
	.half	.L482-.L481
	.byte	1,5,97,9
	.half	.L483-.L482
	.byte	1,5,60,7,9
	.half	.L48-.L483
	.byte	3,8,1,5,76,9
	.half	.L484-.L48
	.byte	3,76,1,5,70,9
	.half	.L36-.L484
	.byte	1,4,1,5,13,7,9
	.half	.L239-.L36
	.byte	3,208,122,1,5,23,9
	.half	.L485-.L239
	.byte	1,5,94,9
	.half	.L486-.L485
	.byte	3,4,1,5,82,9
	.half	.L313-.L486
	.byte	1,5,93,9
	.half	.L487-.L313
	.byte	1,5,99,9
	.half	.L488-.L487
	.byte	1,5,13,9
	.half	.L489-.L488
	.byte	1,7,9
	.half	.L49-.L489
	.byte	1,9
	.half	.L35-.L49
	.byte	3,11,1,5,45,9
	.half	.L490-.L35
	.byte	1,5,43,9
	.half	.L491-.L490
	.byte	1,5,52,9
	.half	.L492-.L491
	.byte	3,3,1,5,68,9
	.half	.L493-.L492
	.byte	1,5,13,9
	.half	.L24-.L493
	.byte	3,4,1,5,5,9
	.half	.L494-.L24
	.byte	1,5,1,9
	.half	.L17-.L494
	.byte	3,1,1,7,9
	.half	.L166-.L17
	.byte	0,1,1
.L384:
	.sdecl	'.debug_ranges',debug,cluster('WdgM_SetMode')
	.sect	'.debug_ranges'
.L165:
	.word	-1,.L143,0,.L166-.L143,0,0
	.sdecl	'.debug_info',debug,cluster('WdgM_GetMode')
	.sect	'.debug_info'
.L167:
	.word	202
	.half	3
	.word	.L168
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L170,.L169
	.byte	2
	.word	.L158
	.byte	3
	.byte	'WdgM_GetMode',0,1,177,3,38
	.word	.L216
	.byte	1,1,1
	.word	.L145,.L250,.L144
	.byte	4
	.byte	'Mode',0,1,177,3,97
	.word	.L251,.L252
	.byte	5
	.word	.L145,.L250
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('WdgM_GetMode')
	.sect	'.debug_abbrev'
.L168:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('WdgM_GetMode')
	.sect	'.debug_line'
.L169:
	.word	.L496-.L495
.L495:
	.half	3
	.word	.L498-.L497
.L497:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM.c',0,0,0,0,0
.L498:
	.byte	5,9,7,0,5,2
	.word	.L145
	.byte	3,180,3,1,5,5,9
	.half	.L499-.L145
	.byte	1,5,31,7,9
	.half	.L500-.L499
	.byte	3,3,1,5,47,9
	.half	.L501-.L500
	.byte	1,5,65,9
	.half	.L502-.L501
	.byte	1,5,87,9
	.half	.L503-.L502
	.byte	1,5,16,9
	.half	.L333-.L503
	.byte	3,1,1,5,9,9
	.half	.L504-.L333
	.byte	1,5,5,9
	.half	.L52-.L504
	.byte	3,3,1,5,31,7,9
	.half	.L505-.L52
	.byte	3,3,1,5,47,9
	.half	.L506-.L505
	.byte	1,5,65,9
	.half	.L507-.L506
	.byte	1,5,86,9
	.half	.L508-.L507
	.byte	1,5,16,9
	.half	.L334-.L508
	.byte	3,1,1,5,9,9
	.half	.L509-.L334
	.byte	1,5,13,9
	.half	.L54-.L509
	.byte	3,3,1,5,11,9
	.half	.L510-.L54
	.byte	1,5,12,9
	.half	.L511-.L510
	.byte	3,1,1,5,5,9
	.half	.L512-.L511
	.byte	1,5,1,9
	.half	.L53-.L512
	.byte	3,1,1,7,9
	.half	.L171-.L53
	.byte	0,1,1
.L496:
	.sdecl	'.debug_ranges',debug,cluster('WdgM_GetMode')
	.sect	'.debug_ranges'
.L170:
	.word	-1,.L145,0,.L171-.L145,0,0
	.sdecl	'.debug_info',debug,cluster('WdgM_GetLocalStatus')
	.sect	'.debug_info'
.L172:
	.word	229
	.half	3
	.word	.L173
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L175,.L174
	.byte	2
	.word	.L158
	.byte	3
	.byte	'WdgM_GetLocalStatus',0,1,208,3,39
	.word	.L216
	.byte	1,1,1
	.word	.L147,.L253,.L146
	.byte	4
	.byte	'SEID',0,1,208,3,102
	.word	.L216,.L254
	.byte	4
	.byte	'Status',0,1,209,3,57
	.word	.L255,.L256
	.byte	5
	.word	.L147,.L253
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('WdgM_GetLocalStatus')
	.sect	'.debug_abbrev'
.L173:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('WdgM_GetLocalStatus')
	.sect	'.debug_line'
.L174:
	.word	.L514-.L513
.L513:
	.half	3
	.word	.L516-.L515
.L515:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM.c',0,0,0,0,0
.L516:
	.byte	5,9,7,0,5,2
	.word	.L147
	.byte	3,213,3,1,5,5,9
	.half	.L517-.L147
	.byte	1,5,31,7,9
	.half	.L518-.L517
	.byte	3,3,1,5,47,9
	.half	.L335-.L518
	.byte	1,5,65,9
	.half	.L519-.L335
	.byte	1,5,95,9
	.half	.L520-.L519
	.byte	1,5,16,9
	.half	.L336-.L520
	.byte	3,1,1,5,9,9
	.half	.L521-.L336
	.byte	1,5,5,9
	.half	.L57-.L521
	.byte	3,3,1,5,31,7,9
	.half	.L522-.L57
	.byte	3,3,1,5,47,9
	.half	.L337-.L522
	.byte	1,5,65,9
	.half	.L523-.L337
	.byte	1,5,95,9
	.half	.L524-.L523
	.byte	1,5,16,9
	.half	.L338-.L524
	.byte	3,1,1,5,9,9
	.half	.L525-.L338
	.byte	1,5,5,9
	.half	.L59-.L525
	.byte	3,3,1,5,31,7,9
	.half	.L526-.L59
	.byte	3,3,1,5,47,9
	.half	.L339-.L526
	.byte	1,5,65,9
	.half	.L527-.L339
	.byte	1,5,94,9
	.half	.L528-.L527
	.byte	1,5,16,9
	.half	.L340-.L528
	.byte	3,1,1,5,9,9
	.half	.L529-.L340
	.byte	1,5,15,9
	.half	.L61-.L529
	.byte	3,5,1,5,39,9
	.half	.L530-.L61
	.byte	1,5,45,9
	.half	.L531-.L530
	.byte	1,5,13,9
	.half	.L532-.L531
	.byte	1,5,12,9
	.half	.L533-.L532
	.byte	3,2,1,5,5,9
	.half	.L534-.L533
	.byte	1,5,1,9
	.half	.L58-.L534
	.byte	3,1,1,7,9
	.half	.L176-.L58
	.byte	0,1,1
.L514:
	.sdecl	'.debug_ranges',debug,cluster('WdgM_GetLocalStatus')
	.sect	'.debug_ranges'
.L175:
	.word	-1,.L147,0,.L176-.L147,0,0
	.sdecl	'.debug_info',debug,cluster('WdgM_GetGlobalStatus')
	.sect	'.debug_info'
.L177:
	.word	212
	.half	3
	.word	.L178
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L180,.L179
	.byte	2
	.word	.L158
	.byte	3
	.byte	'WdgM_GetGlobalStatus',0,1,251,3,39
	.word	.L216
	.byte	1,1,1
	.word	.L149,.L257,.L148
	.byte	4
	.byte	'Status',0,1,251,3,113
	.word	.L258,.L259
	.byte	5
	.word	.L149,.L257
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('WdgM_GetGlobalStatus')
	.sect	'.debug_abbrev'
.L178:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('WdgM_GetGlobalStatus')
	.sect	'.debug_line'
.L179:
	.word	.L536-.L535
.L535:
	.half	3
	.word	.L538-.L537
.L537:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM.c',0,0,0,0,0
.L538:
	.byte	5,9,7,0,5,2
	.word	.L149
	.byte	3,254,3,1,5,5,9
	.half	.L539-.L149
	.byte	1,5,31,7,9
	.half	.L540-.L539
	.byte	3,3,1,5,47,9
	.half	.L541-.L540
	.byte	1,5,65,9
	.half	.L542-.L541
	.byte	1,5,96,9
	.half	.L543-.L542
	.byte	1,5,16,9
	.half	.L341-.L543
	.byte	3,1,1,5,9,9
	.half	.L544-.L341
	.byte	1,5,5,9
	.half	.L64-.L544
	.byte	3,3,1,5,31,7,9
	.half	.L545-.L64
	.byte	3,3,1,5,47,9
	.half	.L546-.L545
	.byte	1,5,65,9
	.half	.L547-.L546
	.byte	1,5,95,9
	.half	.L548-.L547
	.byte	1,5,16,9
	.half	.L342-.L548
	.byte	3,1,1,5,9,9
	.half	.L549-.L342
	.byte	1,5,13,9
	.half	.L66-.L549
	.byte	3,4,1,5,12,9
	.half	.L550-.L66
	.byte	3,1,1,5,5,9
	.half	.L551-.L550
	.byte	1,5,1,9
	.half	.L65-.L551
	.byte	3,1,1,7,9
	.half	.L181-.L65
	.byte	0,1,1
.L536:
	.sdecl	'.debug_ranges',debug,cluster('WdgM_GetGlobalStatus')
	.sect	'.debug_ranges'
.L180:
	.word	-1,.L149,0,.L181-.L149,0,0
	.sdecl	'.debug_info',debug,cluster('WdgM_PerformReset')
	.sect	'.debug_info'
.L182:
	.word	185
	.half	3
	.word	.L183
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L185,.L184
	.byte	2
	.word	.L158
	.byte	3
	.byte	'WdgM_PerformReset',0,1,155,4,28,1,1,1
	.word	.L151,.L260,.L150
	.byte	4
	.word	.L151,.L260
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('WdgM_PerformReset')
	.sect	'.debug_abbrev'
.L183:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('WdgM_PerformReset')
	.sect	'.debug_line'
.L184:
	.word	.L553-.L552
.L552:
	.half	3
	.word	.L555-.L554
.L554:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM.c',0,0,0,0,0
.L555:
	.byte	5,9,7,0,5,2
	.word	.L151
	.byte	3,158,4,1,5,5,9
	.half	.L556-.L151
	.byte	1,5,31,7,9
	.half	.L557-.L556
	.byte	3,3,1,5,47,9
	.half	.L558-.L557
	.byte	1,5,65,9
	.half	.L559-.L558
	.byte	1,5,92,9
	.half	.L560-.L559
	.byte	1,5,9,9
	.half	.L561-.L560
	.byte	3,1,1,5,25,9
	.half	.L69-.L561
	.byte	3,7,1,5,23,9
	.half	.L562-.L69
	.byte	1,5,34,9
	.half	.L563-.L562
	.byte	3,2,1,5,5,9
	.half	.L564-.L563
	.byte	3,1,1,5,1,9
	.half	.L70-.L564
	.byte	3,1,1,7,9
	.half	.L186-.L70
	.byte	0,1,1
.L553:
	.sdecl	'.debug_ranges',debug,cluster('WdgM_PerformReset')
	.sect	'.debug_ranges'
.L185:
	.word	-1,.L151,0,.L186-.L151,0,0
	.sdecl	'.debug_info',debug,cluster('WdgM_Init')
	.sect	'.debug_info'
.L187:
	.word	310
	.half	3
	.word	.L188
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L190,.L189
	.byte	2
	.word	.L158
	.byte	3
	.byte	'WdgM_Init',0,1,54,28,1,1,1
	.word	.L139,.L261,.L138
	.byte	4
	.byte	'ConfigPtr',0,1,54,90
	.word	.L262,.L263
	.byte	5
	.word	.L139,.L261
	.byte	6
	.byte	'TriggerIdx',0,1,57,27
	.word	.L216,.L264
	.byte	6
	.byte	'TriggerPtr',0,1,58,59
	.word	.L223,.L265
	.byte	6
	.byte	'SEID',0,1,60,49
	.word	.L216,.L266
	.byte	6
	.byte	'ReturnStatus',0,1,64,36
	.word	.L216,.L267
	.byte	6
	.byte	'PortHandle',0,1,66,57
	.word	.L268,.L269
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('WdgM_Init')
	.sect	'.debug_abbrev'
.L188:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,52,0,3
	.byte	8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('WdgM_Init')
	.sect	'.debug_line'
.L189:
	.word	.L566-.L565
.L565:
	.half	3
	.word	.L568-.L567
.L567:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM.c',0,0,0,0,0
.L568:
	.byte	5,70,7,0,5,2
	.word	.L139
	.byte	3,193,0,1,5,5,9
	.half	.L569-.L139
	.byte	3,7,1,5,33,9
	.half	.L570-.L569
	.byte	1,5,31,9
	.half	.L571-.L570
	.byte	1,5,9,9
	.half	.L572-.L571
	.byte	3,11,1,5,30,9
	.half	.L573-.L572
	.byte	1,5,27,9
	.half	.L574-.L573
	.byte	1,5,47,9
	.half	.L575-.L574
	.byte	3,26,1,5,35,9
	.half	.L576-.L575
	.byte	1,5,64,9
	.half	.L577-.L576
	.byte	1,5,46,9
	.half	.L578-.L577
	.byte	1,5,78,9
	.half	.L579-.L578
	.byte	1,5,20,9
	.half	.L302-.L579
	.byte	3,1,1,5,98,9
	.half	.L305-.L302
	.byte	3,1,1,5,23,9
	.half	.L3-.L305
	.byte	3,3,1,5,35,9
	.half	.L580-.L3
	.byte	1,5,9,9
	.half	.L581-.L580
	.byte	1,5,35,7,9
	.half	.L582-.L581
	.byte	3,5,1,5,51,9
	.half	.L583-.L582
	.byte	1,5,69,9
	.half	.L584-.L583
	.byte	1,5,86,9
	.half	.L585-.L584
	.byte	1,5,13,9
	.half	.L304-.L585
	.byte	3,2,1,5,23,9
	.half	.L4-.L304
	.byte	3,119,1,5,43,9
	.half	.L2-.L4
	.byte	3,127,1,5,72,9
	.half	.L586-.L2
	.byte	1,5,54,9
	.half	.L587-.L586
	.byte	1,5,86,9
	.half	.L588-.L587
	.byte	1,5,98,9
	.half	.L589-.L588
	.byte	1,5,14,7,9
	.half	.L590-.L589
	.byte	3,15,1,5,70,9
	.half	.L307-.L590
	.byte	1,5,9,9
	.half	.L7-.L307
	.byte	3,2,1,5,33,9
	.half	.L591-.L7
	.byte	1,5,57,9
	.half	.L592-.L591
	.byte	1,5,55,9
	.half	.L593-.L592
	.byte	1,5,57,9
	.half	.L594-.L593
	.byte	3,1,1,5,55,9
	.half	.L595-.L594
	.byte	1,5,19,9
	.half	.L596-.L595
	.byte	3,8,1,5,25,9
	.half	.L597-.L596
	.byte	1,5,45,9
	.half	.L598-.L597
	.byte	1,5,76,9
	.half	.L599-.L598
	.byte	3,117,1,5,70,9
	.half	.L6-.L599
	.byte	1,5,5,7,9
	.half	.L600-.L6
	.byte	3,14,1,5,37,9
	.half	.L601-.L600
	.byte	1,5,35,9
	.half	.L602-.L601
	.byte	1,5,33,9
	.half	.L603-.L602
	.byte	3,5,1,5,50,9
	.half	.L604-.L603
	.byte	1,5,65,9
	.half	.L605-.L604
	.byte	1,5,9,9
	.half	.L308-.L605
	.byte	3,33,1,5,5,9
	.half	.L606-.L308
	.byte	3,97,1,5,9,7,9
	.half	.L607-.L606
	.byte	3,3,1,5,47,9
	.half	.L608-.L607
	.byte	1,5,45,9
	.half	.L609-.L608
	.byte	1,5,9,9
	.half	.L610-.L609
	.byte	3,2,1,5,52,9
	.half	.L611-.L610
	.byte	1,5,50,9
	.half	.L612-.L611
	.byte	1,5,9,9
	.half	.L613-.L612
	.byte	3,1,1,5,43,9
	.half	.L614-.L613
	.byte	1,5,41,9
	.half	.L615-.L614
	.byte	1,5,29,9
	.half	.L616-.L615
	.byte	3,25,1,5,27,9
	.half	.L617-.L616
	.byte	1,5,62,9
	.half	.L618-.L617
	.byte	3,100,1,5,29,9
	.half	.L8-.L618
	.byte	3,35,1,5,27,9
	.half	.L619-.L8
	.byte	1,5,5,9
	.half	.L9-.L619
	.byte	3,3,1,5,1,9
	.half	.L5-.L9
	.byte	3,1,1,7,9
	.half	.L191-.L5
	.byte	0,1,1
.L566:
	.sdecl	'.debug_ranges',debug,cluster('WdgM_Init')
	.sect	'.debug_ranges'
.L190:
	.word	-1,.L139,0,.L191-.L139,0,0
	.sdecl	'.debug_info',debug,cluster('WdgM_DeInit')
	.sect	'.debug_info'
.L192:
	.word	179
	.half	3
	.word	.L193
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L195,.L194
	.byte	2
	.word	.L158
	.byte	3
	.byte	'WdgM_DeInit',0,1,201,1,28,1,1,1
	.word	.L141,.L270,.L140
	.byte	4
	.word	.L141,.L270
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('WdgM_DeInit')
	.sect	'.debug_abbrev'
.L193:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('WdgM_DeInit')
	.sect	'.debug_line'
.L194:
	.word	.L621-.L620
.L620:
	.half	3
	.word	.L623-.L622
.L622:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM.c',0,0,0,0,0
.L623:
	.byte	5,9,7,0,5,2
	.word	.L141
	.byte	3,205,1,1,5,5,9
	.half	.L624-.L141
	.byte	1,5,31,7,9
	.half	.L625-.L624
	.byte	3,3,1,5,47,9
	.half	.L626-.L625
	.byte	1,5,65,9
	.half	.L627-.L626
	.byte	1,5,86,9
	.half	.L628-.L627
	.byte	1,5,9,9
	.half	.L629-.L628
	.byte	3,1,1,5,5,9
	.half	.L11-.L629
	.byte	3,4,1,5,29,7,9
	.half	.L630-.L11
	.byte	3,4,1,5,27,9
	.half	.L631-.L630
	.byte	1,5,5,9
	.half	.L13-.L631
	.byte	3,3,1,5,1,9
	.half	.L12-.L13
	.byte	3,1,1,7,9
	.half	.L196-.L12
	.byte	0,1,1
.L621:
	.sdecl	'.debug_ranges',debug,cluster('WdgM_DeInit')
	.sect	'.debug_ranges'
.L195:
	.word	-1,.L141,0,.L196-.L141,0,0
	.sdecl	'.debug_info',debug,cluster('WdgM_GetFirstExpiredSEID')
	.sect	'.debug_info'
.L197:
	.word	325
	.half	3
	.word	.L198
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L200,.L199
	.byte	2
	.word	.L158
	.byte	3
	.byte	'WdgM_GetFirstExpiredSEID',0,1,192,4,39
	.word	.L216
	.byte	1,1,1
	.word	.L153,.L271,.L152
	.byte	4
	.byte	'SEID',0,1,192,4,123
	.word	.L272,.L273
	.byte	5
	.word	.L153,.L271
	.byte	6
	.byte	'ReturnStatus',0,1,194,4,36
	.word	.L216,.L274
	.byte	6
	.byte	'FirstExpiredSupervisedEntityIdTemp',0,1,195,4,49
	.word	.L216,.L275
	.byte	7
	.word	.L276,.L277,.L74
	.byte	8
	.word	.L278,.L279
	.byte	9
	.word	.L280,.L277,.L74
	.byte	0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('WdgM_GetFirstExpiredSEID')
	.sect	'.debug_abbrev'
.L198:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,7,29,1,49,16,17,1,18,1,0,0,8,5,0,49,16,2,6,0,0,9,11,0,49,16,17
	.byte	1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('WdgM_GetFirstExpiredSEID')
	.sect	'.debug_line'
.L199:
	.word	.L633-.L632
.L632:
	.half	3
	.word	.L635-.L634
.L634:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM.c',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\WdgM\\WdgM_Cfg.h',0,0,0,0,0
.L635:
	.byte	5,49,7,0,5,2
	.word	.L153
	.byte	3,193,4,1,5,5,9
	.half	.L344-.L153
	.byte	3,5,1,5,31,7,9
	.half	.L636-.L344
	.byte	3,3,1,5,47,9
	.half	.L637-.L636
	.byte	1,5,65,9
	.half	.L638-.L637
	.byte	1,5,100,9
	.half	.L639-.L638
	.byte	1,5,16,9
	.half	.L343-.L639
	.byte	3,1,1,5,9,9
	.half	.L640-.L343
	.byte	1,5,73,9
	.half	.L72-.L640
	.byte	3,7,1,4,2,5,51,9
	.half	.L277-.L72
	.byte	3,237,125,1,5,5,9
	.half	.L345-.L277
	.byte	1,4,1,5,8,9
	.half	.L74-.L345
	.byte	3,148,2,1,5,5,9
	.half	.L641-.L74
	.byte	1,5,15,7,9
	.half	.L642-.L641
	.byte	3,2,1,5,22,9
	.half	.L643-.L642
	.byte	3,1,1,5,52,9
	.half	.L644-.L643
	.byte	3,127,1,5,17,9
	.half	.L75-.L644
	.byte	3,5,1,5,15,9
	.half	.L346-.L75
	.byte	1,5,5,9
	.half	.L76-.L346
	.byte	3,2,1,5,1,9
	.half	.L73-.L76
	.byte	3,1,1,7,9
	.half	.L201-.L73
	.byte	0,1,1
.L633:
	.sdecl	'.debug_ranges',debug,cluster('WdgM_GetFirstExpiredSEID')
	.sect	'.debug_ranges'
.L200:
	.word	-1,.L153,0,.L201-.L153,0,0
	.sdecl	'.debug_info',debug,cluster('WdgM_MainFunction')
	.sect	'.debug_info'
.L202:
	.word	429
	.half	3
	.word	.L203
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L205,.L204
	.byte	2
	.word	.L158
	.byte	3
	.byte	'WdgM_MainFunction',0,1,245,5,23,1,1,1
	.word	.L157,.L281,.L156
	.byte	4
	.word	.L157,.L281
	.byte	5
	.byte	'SEID',0,1,247,5,49
	.word	.L216,.L282
	.byte	5
	.byte	'NewGlobalStatus',0,1,248,5,43
	.word	.L216,.L283
	.byte	5
	.byte	'GlobalStatusCached',0,1,253,5,43
	.word	.L216,.L284
	.byte	6
	.word	.L285,.L286,.L287
	.byte	7
	.word	.L288,.L289
	.byte	5
	.byte	'SEID',0,2,254,1,49
	.word	.L216,.L291
	.byte	5
	.byte	'AliveSupervisionIdx',0,2,255,1,28
	.word	.L219,.L292
	.byte	5
	.byte	'AliveSupervisionPtr',0,2,128,2,68
	.word	.L246,.L293
	.byte	5
	.byte	'IndividualAliveUpdateCtrCache',0,2,129,2,27
	.word	.L294,.L295
	.byte	0,0,8
	.word	.L285,.L290,.L109
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('WdgM_MainFunction')
	.sect	'.debug_abbrev'
.L203:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,11,1,17,1,18,1,0,0,5,52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,6,29,1
	.byte	49,16,17,1,18,1,0,0,7,11,1,49,16,85,6,0,0,8,29,0,49,16,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('WdgM_MainFunction')
	.sect	'.debug_line'
.L204:
	.word	.L646-.L645
.L645:
	.half	3
	.word	.L648-.L647
.L647:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM_Prv.h',0,0,0,0,0
.L648:
	.byte	5,23,7,0,5,2
	.word	.L157
	.byte	3,244,5,1,5,5,9
	.half	.L361-.L157
	.byte	3,11,1,5,30,9
	.half	.L649-.L361
	.byte	1,5,9,9
	.half	.L650-.L649
	.byte	3,6,1,5,5,9
	.half	.L651-.L650
	.byte	1,5,31,7,9
	.half	.L652-.L651
	.byte	3,3,1,5,47,9
	.half	.L653-.L652
	.byte	1,5,65,9
	.half	.L654-.L653
	.byte	1,5,92,9
	.half	.L655-.L654
	.byte	1,5,9,9
	.half	.L656-.L655
	.byte	3,1,1,5,8,9
	.half	.L89-.L656
	.byte	3,11,1,5,82,7,9
	.half	.L657-.L89
	.byte	1,5,115,7,9
	.half	.L658-.L657
	.byte	1,5,145,1,9
	.half	.L659-.L658
	.byte	1,4,2,5,56,7,9
	.half	.L286-.L659
	.byte	3,237,123,1,5,27,9
	.half	.L660-.L286
	.byte	1,5,44,9
	.half	.L661-.L660
	.byte	1,5,55,9
	.half	.L662-.L661
	.byte	1,4,1,5,9,9
	.half	.L287-.L662
	.byte	3,149,4,1,4,2,5,66,7,9
	.half	.L290-.L287
	.byte	3,235,123,1,5,28,9
	.half	.L362-.L290
	.byte	3,2,1,5,18,9
	.half	.L364-.L362
	.byte	3,10,1,5,87,9
	.half	.L663-.L364
	.byte	3,119,1,5,35,9
	.half	.L96-.L663
	.byte	3,3,1,5,56,9
	.half	.L664-.L96
	.byte	1,5,37,9
	.half	.L366-.L664
	.byte	3,8,1,5,13,9
	.half	.L367-.L366
	.byte	1,5,37,9
	.half	.L665-.L367
	.byte	1,5,43,9
	.half	.L666-.L665
	.byte	1,5,44,9
	.half	.L667-.L666
	.byte	3,125,1,5,12,9
	.half	.L668-.L667
	.byte	1,5,46,7,9
	.half	.L669-.L668
	.byte	3,1,1,5,43,7,9
	.half	.L670-.L669
	.byte	3,2,1,5,73,9
	.half	.L671-.L670
	.byte	1,5,47,9
	.half	.L672-.L671
	.byte	3,2,1,5,61,9
	.half	.L673-.L672
	.byte	3,1,1,5,13,9
	.half	.L674-.L673
	.byte	3,127,1,5,79,7,9
	.half	.L675-.L674
	.byte	3,12,1,5,75,9
	.half	.L368-.L675
	.byte	3,1,1,5,73,9
	.half	.L676-.L368
	.byte	1,5,103,9
	.half	.L677-.L676
	.byte	3,19,1,5,66,9
	.half	.L678-.L677
	.byte	3,116,1,5,142,1,9
	.half	.L679-.L678
	.byte	1,5,92,9
	.half	.L680-.L679
	.byte	1,5,21,9
	.half	.L681-.L680
	.byte	3,127,1,5,142,1,7,9
	.half	.L682-.L681
	.byte	3,3,1,5,92,9
	.half	.L683-.L682
	.byte	1,5,50,9
	.half	.L684-.L683
	.byte	3,127,1,5,54,7,9
	.half	.L685-.L684
	.byte	3,5,1,5,21,9
	.half	.L369-.L685
	.byte	1,5,119,7,9
	.half	.L686-.L369
	.byte	3,6,1,5,71,9
	.half	.L687-.L686
	.byte	1,5,55,9
	.half	.L688-.L687
	.byte	3,4,1,5,89,9
	.half	.L689-.L688
	.byte	1,5,145,1,9
	.half	.L690-.L689
	.byte	3,124,1,5,119,9
	.half	.L102-.L690
	.byte	3,15,1,5,26,9
	.half	.L691-.L102
	.byte	3,122,1,5,71,7,9
	.half	.L692-.L691
	.byte	3,6,1,5,92,9
	.half	.L693-.L692
	.byte	3,4,1,5,90,9
	.half	.L694-.L693
	.byte	1,5,172,1,9
	.half	.L695-.L694
	.byte	3,124,1,5,71,9
	.half	.L104-.L695
	.byte	3,12,1,5,21,9
	.half	.L103-.L104
	.byte	3,110,1,5,115,9
	.half	.L100-.L103
	.byte	3,37,1,5,67,9
	.half	.L696-.L100
	.byte	1,5,51,9
	.half	.L697-.L696
	.byte	3,4,1,5,85,9
	.half	.L698-.L697
	.byte	1,5,55,9
	.half	.L699-.L698
	.byte	3,3,1,5,122,9
	.half	.L370-.L699
	.byte	1,5,21,9
	.half	.L700-.L370
	.byte	1,5,103,7,9
	.half	.L701-.L700
	.byte	3,6,1,5,119,9
	.half	.L702-.L701
	.byte	1,5,71,9
	.half	.L703-.L702
	.byte	1,5,80,9
	.half	.L106-.L703
	.byte	3,10,1,5,78,9
	.half	.L704-.L106
	.byte	1,5,13,9
	.half	.L99-.L704
	.byte	3,155,127,1,5,43,9
	.half	.L97-.L99
	.byte	3,247,0,1,5,71,9
	.half	.L705-.L97
	.byte	1,5,69,9
	.half	.L706-.L705
	.byte	1,5,76,9
	.half	.L707-.L706
	.byte	3,7,1,5,74,9
	.half	.L708-.L707
	.byte	1,5,80,9
	.half	.L709-.L708
	.byte	3,1,1,5,78,9
	.half	.L710-.L709
	.byte	1,5,24,9
	.half	.L108-.L710
	.byte	3,245,126,1,5,44,9
	.half	.L95-.L108
	.byte	3,127,1,5,55,9
	.half	.L711-.L95
	.byte	1,5,66,9
	.half	.L712-.L711
	.byte	1,5,87,9
	.half	.L713-.L712
	.byte	1,5,5,7,9
	.half	.L714-.L713
	.byte	3,145,1,1,5,39,7,9
	.half	.L715-.L714
	.byte	3,2,1,5,37,9
	.half	.L716-.L715
	.byte	1,4,1,5,45,9
	.half	.L109-.L716
	.byte	3,137,3,1,5,29,9
	.half	.L363-.L109
	.byte	3,5,1,5,22,9
	.half	.L371-.L363
	.byte	3,1,1,5,78,9
	.half	.L372-.L371
	.byte	1,5,22,9
	.half	.L111-.L372
	.byte	3,4,1,5,46,9
	.half	.L717-.L111
	.byte	1,5,52,9
	.half	.L718-.L717
	.byte	1,5,17,9
	.half	.L719-.L718
	.byte	1,5,37,7,9
	.half	.L720-.L719
	.byte	3,6,1,5,25,9
	.half	.L721-.L720
	.byte	3,7,1,5,42,9
	.half	.L722-.L721
	.byte	1,5,54,9
	.half	.L723-.L722
	.byte	1,5,53,9
	.half	.L724-.L723
	.byte	1,5,64,9
	.half	.L725-.L724
	.byte	1,5,41,9
	.half	.L726-.L725
	.byte	3,2,1,5,21,9
	.half	.L113-.L726
	.byte	3,2,1,5,22,9
	.half	.L112-.L113
	.byte	3,7,1,5,37,7,9
	.half	.L727-.L112
	.byte	3,2,1,5,64,9
	.half	.L728-.L727
	.byte	1,5,84,9
	.half	.L116-.L728
	.byte	3,98,1,5,78,9
	.half	.L110-.L116
	.byte	1,5,9,7,9
	.half	.L114-.L110
	.byte	3,37,1,5,29,9
	.half	.L94-.L114
	.byte	3,3,1,5,13,9
	.half	.L374-.L94
	.byte	3,4,1,5,44,9
	.half	.L729-.L374
	.byte	1,5,17,9
	.half	.L730-.L729
	.byte	3,1,1,5,90,9
	.half	.L731-.L730
	.byte	1,5,13,9
	.half	.L732-.L731
	.byte	1,5,33,9
	.half	.L733-.L732
	.byte	3,8,1,5,9,9
	.half	.L117-.L733
	.byte	3,113,1,5,12,9
	.half	.L91-.L117
	.byte	3,23,1,5,9,9
	.half	.L734-.L91
	.byte	1,5,29,9
	.half	.L735-.L734
	.byte	3,2,1,5,57,9
	.half	.L375-.L735
	.byte	1,5,29,9
	.half	.L120-.L375
	.byte	3,4,1,5,5,9
	.half	.L119-.L120
	.byte	3,9,1,5,76,7,9
	.half	.L736-.L119
	.byte	1,5,31,7,9
	.half	.L737-.L736
	.byte	3,2,1,5,48,9
	.half	.L738-.L737
	.byte	1,5,68,9
	.half	.L739-.L738
	.byte	1,5,5,9
	.half	.L122-.L739
	.byte	3,5,1,5,81,7,9
	.half	.L740-.L122
	.byte	1,5,3,7,9
	.half	.L741-.L740
	.byte	3,2,1,5,10,7,9
	.half	.L742-.L741
	.byte	3,4,1,9
	.half	.L743-.L742
	.byte	3,3,1,9
	.half	.L744-.L743
	.byte	3,3,1,9
	.half	.L745-.L744
	.byte	3,3,1,5,45,9
	.half	.L127-.L745
	.byte	3,120,1,5,6,9
	.half	.L746-.L127
	.byte	3,1,1,5,45,9
	.half	.L128-.L746
	.byte	3,2,1,5,6,9
	.half	.L747-.L128
	.byte	3,1,1,5,45,9
	.half	.L129-.L747
	.byte	3,2,1,5,6,9
	.half	.L748-.L129
	.byte	3,1,1,5,45,9
	.half	.L130-.L748
	.byte	3,7,1,5,6,9
	.half	.L749-.L130
	.byte	3,2,1,9
	.half	.L131-.L749
	.byte	3,2,1,5,31,9
	.half	.L124-.L131
	.byte	3,12,1,5,23,9
	.half	.L377-.L124
	.byte	3,1,1,5,5,9
	.half	.L750-.L377
	.byte	3,1,1,5,1,9
	.half	.L90-.L750
	.byte	3,1,1,7,9
	.half	.L206-.L90
	.byte	0,1,1
.L646:
	.sdecl	'.debug_ranges',debug,cluster('WdgM_MainFunction')
	.sect	'.debug_ranges'
.L205:
	.word	-1,.L157,0,.L206-.L157,0,0
.L289:
	.word	-1,.L157,.L286-.L157,.L287-.L157,.L290-.L157,.L109-.L157,0,0
	.sdecl	'.debug_info',debug,cluster('WdgM_CheckpointReached')
	.sect	'.debug_info'
.L207:
	.word	307
	.half	3
	.word	.L208
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L210,.L209
	.byte	2
	.word	.L158
	.byte	3
	.byte	'WdgM_CheckpointReached',0,1,244,4,38
	.word	.L216
	.byte	1,1,1
	.word	.L155,.L296,.L154
	.byte	4
	.byte	'Rte_PDAV0',0,1,244,4,104
	.word	.L216,.L297
	.byte	4
	.byte	'CheckpointID',0,1,245,4,38
	.word	.L216,.L298
	.byte	5
	.word	.L155,.L296
	.byte	6
	.byte	'SEID',0,1,252,4,48
	.word	.L216,.L299
	.byte	6
	.byte	'SvIdx',0,1,254,4,27
	.word	.L219,.L300
	.byte	6
	.byte	'ReturnStatus',0,1,255,4,35
	.word	.L216,.L301
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('WdgM_CheckpointReached')
	.sect	'.debug_abbrev'
.L208:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('WdgM_CheckpointReached')
	.sect	'.debug_line'
.L209:
	.word	.L752-.L751
.L751:
	.half	3
	.word	.L754-.L753
.L753:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM.c',0,0,0,0,0
.L754:
	.byte	5,48,7,0,5,2
	.word	.L155
	.byte	3,254,4,1,5,9,9
	.half	.L349-.L155
	.byte	3,11,1,5,5,9
	.half	.L755-.L349
	.byte	1,5,9,7,9
	.half	.L756-.L755
	.byte	3,3,1,5,31,7,9
	.half	.L757-.L756
	.byte	3,4,1,5,52,9
	.half	.L758-.L757
	.byte	1,5,58,9
	.half	.L759-.L758
	.byte	1,5,13,9
	.half	.L760-.L759
	.byte	1,5,22,7,9
	.half	.L761-.L760
	.byte	3,9,1,5,46,9
	.half	.L762-.L761
	.byte	1,5,52,9
	.half	.L763-.L762
	.byte	1,5,17,9
	.half	.L764-.L763
	.byte	1,5,59,7,9
	.half	.L765-.L764
	.byte	3,7,1,5,34,9
	.half	.L351-.L765
	.byte	3,2,1,5,51,9
	.half	.L766-.L351
	.byte	1,5,63,9
	.half	.L767-.L766
	.byte	1,5,62,9
	.half	.L768-.L767
	.byte	1,5,73,9
	.half	.L769-.L768
	.byte	1,5,24,9
	.half	.L770-.L769
	.byte	1,5,91,7,9
	.half	.L771-.L770
	.byte	3,1,1,5,69,9
	.half	.L772-.L771
	.byte	1,5,91,9
	.half	.L773-.L772
	.byte	1,5,98,9
	.half	.L774-.L773
	.byte	1,5,128,1,9
	.half	.L775-.L774
	.byte	1,5,55,7,9
	.half	.L776-.L775
	.byte	3,9,1,5,80,9
	.half	.L777-.L776
	.byte	1,5,144,1,9
	.half	.L82-.L777
	.byte	3,119,1,5,43,9
	.half	.L81-.L82
	.byte	3,19,1,5,59,9
	.half	.L348-.L81
	.byte	1,5,77,9
	.half	.L347-.L348
	.byte	1,5,108,9
	.half	.L778-.L347
	.byte	1,5,34,9
	.half	.L350-.L778
	.byte	3,3,1,5,17,9
	.half	.L84-.L350
	.byte	3,119,1,5,39,9
	.half	.L80-.L84
	.byte	3,39,1,5,55,9
	.half	.L354-.L80
	.byte	1,5,73,9
	.half	.L353-.L354
	.byte	1,5,105,9
	.half	.L779-.L353
	.byte	1,5,30,9
	.half	.L352-.L779
	.byte	3,1,1,5,13,9
	.half	.L85-.L352
	.byte	3,124,1,5,35,9
	.half	.L79-.L85
	.byte	3,10,1,5,51,9
	.half	.L357-.L79
	.byte	1,5,69,9
	.half	.L356-.L357
	.byte	1,5,101,9
	.half	.L780-.L356
	.byte	1,5,26,9
	.half	.L355-.L780
	.byte	3,1,1,5,9,9
	.half	.L86-.L355
	.byte	3,124,1,5,31,9
	.half	.L78-.L86
	.byte	3,10,1,5,47,9
	.half	.L360-.L78
	.byte	1,5,65,9
	.half	.L359-.L360
	.byte	1,5,97,9
	.half	.L781-.L359
	.byte	1,5,22,9
	.half	.L358-.L781
	.byte	3,1,1,5,5,9
	.half	.L87-.L358
	.byte	3,3,1,5,1,9
	.half	.L88-.L87
	.byte	3,1,1,7,9
	.half	.L211-.L88
	.byte	0,1,1
.L752:
	.sdecl	'.debug_ranges',debug,cluster('WdgM_CheckpointReached')
	.sect	'.debug_ranges'
.L210:
	.word	-1,.L155,0,.L211-.L155,0,0
	.sdecl	'.debug_info',debug,cluster('WdgM_GlobalStatus')
	.sect	'.debug_info'
.L212:
	.word	161
	.half	3
	.word	.L213
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1,2
	.word	.L158
	.byte	3
	.byte	'WdgM_GlobalStatus',0,12,27,62
	.word	.L216
	.byte	5,3
	.word	WdgM_GlobalStatus
	.byte	0
	.sdecl	'.debug_abbrev',debug,cluster('WdgM_GlobalStatus')
	.sect	'.debug_abbrev'
.L213:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,0,0,2,61,0,24,16,0,0,3,52,0,3,8,58,15,59,15,57,15,73,16,2,9,0,0,0
	.sdecl	'.debug_info',debug,cluster('WdgM_Prv_SetMode_GlobalStatus')
	.sect	'.debug_info'
.L214:
	.word	173
	.half	3
	.word	.L215
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\WdgM\\src\\WdgM.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1,2
	.word	.L158
	.byte	3
	.byte	'WdgM_Prv_SetMode_GlobalStatus',0,12,29,58
	.word	.L216
	.byte	5,3
	.word	WdgM_Prv_SetMode_GlobalStatus
	.byte	0
	.sdecl	'.debug_abbrev',debug,cluster('WdgM_Prv_SetMode_GlobalStatus')
	.sect	'.debug_abbrev'
.L215:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,0,0,2,61,0,24,16,0,0,3,52,0,3,8,58,15,59,15,57,15,73,16,2,9,0,0,0
	.sdecl	'.debug_loc',debug,cluster('WdgM_CheckpointReached')
	.sect	'.debug_loc'
.L298:
	.word	-1,.L155,0,.L347-.L155
	.half	1
	.byte	85
	.word	.L80-.L155,.L353-.L155
	.half	1
	.byte	85
	.word	.L79-.L155,.L356-.L155
	.half	1
	.byte	85
	.word	.L78-.L155,.L359-.L155
	.half	1
	.byte	85
	.word	0,0
.L301:
	.word	-1,.L155,.L349-.L155,.L350-.L155
	.half	1
	.byte	82
	.word	.L84-.L155,.L352-.L155
	.half	1
	.byte	82
	.word	.L85-.L155,.L355-.L155
	.half	1
	.byte	82
	.word	.L86-.L155,.L358-.L155
	.half	1
	.byte	82
	.word	.L87-.L155,.L296-.L155
	.half	1
	.byte	82
	.word	0,0
.L297:
	.word	-1,.L155,0,.L348-.L155
	.half	1
	.byte	84
	.word	.L80-.L155,.L354-.L155
	.half	1
	.byte	84
	.word	.L79-.L155,.L357-.L155
	.half	1
	.byte	84
	.word	.L78-.L155,.L360-.L155
	.half	1
	.byte	84
	.word	0,0
.L299:
	.word	0,0
.L300:
	.word	-1,.L155,.L351-.L155,.L81-.L155
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L154:
	.word	-1,.L155,0,.L296-.L155
	.half	2
	.byte	138,0
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('WdgM_DeInit')
	.sect	'.debug_loc'
.L140:
	.word	-1,.L141,0,.L270-.L141
	.half	2
	.byte	138,0
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('WdgM_GetFirstExpiredSEID')
	.sect	'.debug_loc'
.L275:
	.word	-1,.L153,.L345-.L153,.L346-.L153
	.half	1
	.byte	95
	.word	0,0
.L274:
	.word	-1,.L153,.L344-.L153,.L343-.L153
	.half	1
	.byte	82
	.word	.L72-.L153,.L73-.L153
	.half	1
	.byte	82
	.word	0,0
.L279:
	.word	0,0
.L273:
	.word	-1,.L153,0,.L343-.L153
	.half	1
	.byte	100
	.word	.L72-.L153,.L73-.L153
	.half	1
	.byte	100
	.word	0,0
.L152:
	.word	-1,.L153,0,.L271-.L153
	.half	2
	.byte	138,0
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('WdgM_GetGlobalStatus')
	.sect	'.debug_loc'
.L259:
	.word	-1,.L149,0,.L341-.L149
	.half	1
	.byte	100
	.word	.L64-.L149,.L342-.L149
	.half	1
	.byte	100
	.word	.L66-.L149,.L65-.L149
	.half	1
	.byte	100
	.word	0,0
.L148:
	.word	-1,.L149,0,.L257-.L149
	.half	2
	.byte	138,0
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('WdgM_GetLocalStatus')
	.sect	'.debug_loc'
.L254:
	.word	-1,.L147,0,.L335-.L147
	.half	1
	.byte	84
	.word	.L57-.L147,.L337-.L147
	.half	1
	.byte	84
	.word	.L59-.L147,.L339-.L147
	.half	1
	.byte	84
	.word	.L61-.L147,.L58-.L147
	.half	1
	.byte	84
	.word	0,0
.L256:
	.word	-1,.L147,0,.L336-.L147
	.half	1
	.byte	100
	.word	.L57-.L147,.L338-.L147
	.half	1
	.byte	100
	.word	.L59-.L147,.L340-.L147
	.half	1
	.byte	100
	.word	.L61-.L147,.L58-.L147
	.half	1
	.byte	100
	.word	0,0
.L146:
	.word	-1,.L147,0,.L253-.L147
	.half	2
	.byte	138,0
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('WdgM_GetMode')
	.sect	'.debug_loc'
.L252:
	.word	-1,.L145,0,.L333-.L145
	.half	1
	.byte	100
	.word	.L52-.L145,.L334-.L145
	.half	1
	.byte	100
	.word	.L54-.L145,.L53-.L145
	.half	1
	.byte	100
	.word	0,0
.L144:
	.word	-1,.L145,0,.L250-.L145
	.half	2
	.byte	138,0
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('WdgM_Init')
	.sect	'.debug_loc'
.L263:
	.word	-1,.L139,0,.L302-.L139
	.half	1
	.byte	100
	.word	0,0
.L269:
	.word	-1,.L139,.L303-.L139,.L261-.L139
	.half	1
	.byte	108
	.word	0,0
.L267:
	.word	-1,.L139,.L308-.L139,.L5-.L139
	.half	1
	.byte	82
	.word	0,0
.L266:
	.word	-1,.L139,.L307-.L139,.L5-.L139
	.half	1
	.byte	88
	.word	0,0
.L264:
	.word	-1,.L139,.L305-.L139,.L304-.L139
	.half	5
	.byte	144,32,157,32,0
	.word	.L4-.L139,.L306-.L139
	.half	5
	.byte	144,32,157,32,0
	.word	.L2-.L139,.L7-.L139
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L265:
	.word	-1,.L139,.L302-.L139,.L304-.L139
	.half	1
	.byte	100
	.word	.L4-.L139,.L7-.L139
	.half	1
	.byte	100
	.word	0,0
.L138:
	.word	-1,.L139,0,.L261-.L139
	.half	2
	.byte	138,0
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('WdgM_MainFunction')
	.sect	'.debug_loc'
.L292:
	.word	-1,.L157,.L364-.L157,.L365-.L157
	.half	1
	.byte	83
	.word	.L95-.L157,.L363-.L157
	.half	1
	.byte	83
	.word	0,0
.L293:
	.word	-1,.L157,.L362-.L157,.L363-.L157
	.half	1
	.byte	102
	.word	0,0
.L284:
	.word	0,0
.L295:
	.word	-1,.L157,.L368-.L157,.L369-.L157
	.half	5
	.byte	144,32,157,32,0
	.word	.L100-.L157,.L370-.L157
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L283:
	.word	-1,.L157,.L371-.L157,.L94-.L157
	.half	1
	.byte	89
	.word	.L374-.L157,.L91-.L157
	.half	1
	.byte	89
	.word	.L375-.L157,.L120-.L157
	.half	1
	.byte	89
	.word	.L119-.L157,.L90-.L157
	.half	1
	.byte	89
	.word	.L376-.L157,.L377-.L157
	.half	1
	.byte	84
	.word	0,0
.L291:
	.word	-1,.L157,.L366-.L157,.L367-.L157
	.half	1
	.byte	95
	.word	0,0
.L282:
	.word	-1,.L157,.L372-.L157,.L373-.L157
	.half	5
	.byte	144,32,157,32,0
	.word	.L112-.L157,.L114-.L157
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L156:
	.word	-1,.L157,0,.L361-.L157
	.half	2
	.byte	138,0
	.word	.L361-.L157,.L281-.L157
	.half	2
	.byte	138,8
	.word	.L281-.L157,.L281-.L157
	.half	2
	.byte	138,0
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('WdgM_PerformReset')
	.sect	'.debug_loc'
.L150:
	.word	-1,.L151,0,.L260-.L151
	.half	2
	.byte	138,0
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('WdgM_SetMode')
	.sect	'.debug_loc'
.L247:
	.word	-1,.L143,.L326-.L143,.L35-.L143
	.half	1
	.byte	101
	.word	0,0
.L220:
	.word	-1,.L143,0,.L310-.L143
	.half	1
	.byte	85
	.word	.L16-.L143,.L314-.L143
	.half	1
	.byte	85
	.word	.L18-.L143,.L316-.L143
	.half	1
	.byte	85
	.word	.L22-.L143,.L29-.L143
	.half	1
	.byte	85
	.word	0,0
.L249:
	.word	-1,.L143,.L327-.L143,.L35-.L143
	.half	1
	.byte	102
	.word	0,0
.L245:
	.word	-1,.L143,.L329-.L143,.L330-.L143
	.half	5
	.byte	144,32,157,32,0
	.word	.L38-.L143,.L331-.L143
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L218:
	.word	-1,.L143,0,.L311-.L143
	.half	1
	.byte	84
	.word	.L312-.L143,.L313-.L143
	.half	1
	.byte	88
	.word	.L16-.L143,.L315-.L143
	.half	1
	.byte	84
	.word	.L18-.L143,.L317-.L143
	.half	1
	.byte	84
	.word	.L22-.L143,.L29-.L143
	.half	1
	.byte	84
	.word	.L35-.L143,.L24-.L143
	.half	1
	.byte	88
	.word	0,0
.L228:
	.word	0,0
.L241:
	.word	0,0
.L222:
	.word	-1,.L143,0,.L217-.L143
	.half	2
	.byte	145,120
	.word	0,0
.L230:
	.word	0,0
.L244:
	.word	-1,.L143,.L328-.L143,.L35-.L143
	.half	1
	.byte	83
	.word	0,0
.L224:
	.word	-1,.L143,.L318-.L143,.L319-.L143
	.half	1
	.byte	100
	.word	.L22-.L143,.L15-.L143
	.half	1
	.byte	100
	.word	0,0
.L233:
	.word	-1,.L143,.L325-.L143,.L24-.L143
	.half	1
	.byte	110
	.word	0,0
.L142:
	.word	-1,.L143,0,.L309-.L143
	.half	2
	.byte	138,0
	.word	.L309-.L143,.L217-.L143
	.half	2
	.byte	138,8
	.word	.L217-.L143,.L217-.L143
	.half	2
	.byte	138,0
	.word	0,0
.L221:
	.word	-1,.L143,.L320-.L143,.L319-.L143
	.half	1
	.byte	81
	.word	.L22-.L143,.L321-.L143
	.half	1
	.byte	81
	.word	.L20-.L143,.L15-.L143
	.half	1
	.byte	81
	.word	0,0
.L243:
	.word	-1,.L143,.L331-.L143,.L332-.L143
	.half	5
	.byte	144,32,157,32,0
	.word	.L45-.L143,.L36-.L143
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L232:
	.word	-1,.L143,.L322-.L143,.L323-.L143
	.half	1
	.byte	89
	.word	.L28-.L143,.L324-.L143
	.half	1
	.byte	89
	.word	.L31-.L143,.L24-.L143
	.half	1
	.byte	89
	.word	0,0
	.sdecl	'.debug_frame',debug
	.sect	'.debug_frame'
.L782:
	.word	48
	.word	-1
	.byte	3,0,2,1,27,12,26,0,8,27,8,26,8,28,8,29,8,30,8,31,8,34,8,35,8,32,8,33,8,16,8,17,8,24,8,25,8,36,8,37,8,38
	.byte	8,39
	.sdecl	'.debug_frame',debug,cluster('WdgM_Init')
	.sect	'.debug_frame'
	.word	12
	.word	.L782,.L139,.L261-.L139
	.sdecl	'.debug_frame',debug,cluster('WdgM_DeInit')
	.sect	'.debug_frame'
	.word	12
	.word	.L782,.L141,.L270-.L141
	.sdecl	'.debug_frame',debug,cluster('WdgM_SetMode')
	.sect	'.debug_frame'
	.word	36
	.word	.L782,.L143,.L217-.L143
	.byte	4
	.word	(.L309-.L143)/2
	.byte	19,8,22,26,3,19,138,8,4
	.word	(.L217-.L309)/2
	.byte	19,0,8,26,0,0
	.sdecl	'.debug_frame',debug,cluster('WdgM_GetMode')
	.sect	'.debug_frame'
	.word	12
	.word	.L782,.L145,.L250-.L145
	.sdecl	'.debug_frame',debug,cluster('WdgM_GetLocalStatus')
	.sect	'.debug_frame'
	.word	12
	.word	.L782,.L147,.L253-.L147
	.sdecl	'.debug_frame',debug,cluster('WdgM_GetGlobalStatus')
	.sect	'.debug_frame'
	.word	12
	.word	.L782,.L149,.L257-.L149
	.sdecl	'.debug_frame',debug,cluster('WdgM_PerformReset')
	.sect	'.debug_frame'
	.word	12
	.word	.L782,.L151,.L260-.L151
	.sdecl	'.debug_frame',debug,cluster('WdgM_GetFirstExpiredSEID')
	.sect	'.debug_frame'
	.word	12
	.word	.L782,.L153,.L271-.L153
	.sdecl	'.debug_frame',debug,cluster('WdgM_CheckpointReached')
	.sect	'.debug_frame'
	.word	12
	.word	.L782,.L155,.L296-.L155
	.sdecl	'.debug_frame',debug,cluster('WdgM_MainFunction')
	.sect	'.debug_frame'
	.word	36
	.word	.L782,.L157,.L281-.L157
	.byte	4
	.word	(.L361-.L157)/2
	.byte	19,8,22,26,3,19,138,8,4
	.word	(.L281-.L361)/2
	.byte	19,0,8,26,0,0

; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   931  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   932  #define WDGM_STOP_SEC_CODE
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   933  #include "WdgM_Cfg_MemMap.h"
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   934  
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   935  /* TODO : [WDGM271] : Logical yet to be implemented */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   936  /* TODO : [WDGM296] : Logical yet to be implemented */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   937  /* TODO : [WDGM295] : Logical yet to be implemented */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   938  /* TODO : [WDGM246] : Logical yet to be implemented */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   939  /* TODO : [WDGM274] : Logical yet to be implemented */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   940  /* TODO : [WDGM252] : Logical yet to be implemented */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   941  /* TODO : [WDGM233] : Logical yet to be implemented */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   942  /* TODO : [WDGM332] : Logical yet to be implemented */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   943  /* TODO : [WDGM331] : Logical yet to be implemented */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   944  /* TODO : [WDGM297] : Logical yet to be implemented */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   945  /* TODO : [WDGM273] : Logical yet to be implemented */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   946  /* TODO : [WDGM329] : Logical yet to be implemented */
; BSW\src\BSW\Gen\WdgM\src\WdgM.c	   947  /* TODO : [WDGM242] : Logical yet to be implemented */

	; Module end
