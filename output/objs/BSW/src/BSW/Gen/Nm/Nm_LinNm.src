	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 19053136 SN 09001910"
	.compiler_invocation	"ctc -f cc16372a -c99 --integer-enumeration -D__CPU__=tc27x -D__CPU_TC27X__ --core=tc1.6.x --eabi-compliant --fp-model=-float -D_TASKING_C_TRICORE_=1 -I.\\output\\inc -g2 -t4 --language=-comments,-gcc,+volatile,-strings --default-near-size=0 -O2ROPYGKLF-predict --default-a1-size=0 --default-a0-size=0 --source --switch=auto -o output\\objs\\BSW\\src\\BSW\\Gen\\Nm\\Nm_LinNm.src BSW\\src\\BSW\\Gen\\Nm\\src\\Nm_LinNm.c"
	.compiler_name		"ctc"
	;source	'BSW\\src\\BSW\\Gen\\Nm\\src\\Nm_LinNm.c'

	
$TC16X
	
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L3:
	.word	8777
	.half	3
	.word	.L4
	.byte	4
.L2:
	.byte	1
	.byte	'BSW\\src\\BSW\\Gen\\Nm\\src\\Nm_LinNm.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L5
	.byte	2,1,3
	.word	133
	.byte	4
	.byte	'__codeptr',0,1,1,1
	.word	135
	.byte	5,2,116,9,4,6
	.byte	'NM_ACTIVE_CHANNEL',0,0,6
	.byte	'NM_PASSIVE_CHANNEL',0,1,0,4
	.byte	'Nm_ChannelType',0,2,120,3
	.word	158
	.byte	7
	.byte	'char',0,1,6,4
	.byte	'sint8',0,3,76,25
	.word	228
	.byte	7
	.byte	'unsigned char',0,1,8,4
	.byte	'uint8',0,3,81,25
	.word	250
	.byte	7
	.byte	'unsigned short int',0,2,7,4
	.byte	'uint16',0,3,91,25
	.word	281
	.byte	7
	.byte	'unsigned int',0,4,7,4
	.byte	'uint32',0,3,106,24
	.word	318
	.byte	7
	.byte	'unsigned long long int',0,8,7,4
	.byte	'uint64',0,3,111,30
	.word	349
	.byte	4
	.byte	'boolean',0,3,127,25
	.word	250
	.byte	4
	.byte	'StatusType',0,4,191,1,27
	.word	250
	.byte	4
	.byte	'Std_ReturnType',0,4,199,1,15
	.word	250
	.byte	8,4,206,1,9,8,9
	.byte	'vendorID',0
	.word	281
	.byte	2,2,35,0,9
	.byte	'moduleID',0
	.word	281
	.byte	2,2,35,2,9
	.byte	'sw_major_version',0
	.word	250
	.byte	1,2,35,4,9
	.byte	'sw_minor_version',0
	.word	250
	.byte	1,2,35,5,9
	.byte	'sw_patch_version',0
	.word	250
	.byte	1,2,35,6,0,4
	.byte	'Std_VersionInfoType',0,4,213,1,3
	.word	450
	.byte	4
	.byte	'PduIdType',0,5,22,19
	.word	281
	.byte	4
	.byte	'PduLengthType',0,5,26,19
	.word	281
	.byte	5,6,113,9,4,6
	.byte	'TP_DATACONF',0,0,6
	.byte	'TP_DATARETRY',0,1,6
	.byte	'TP_CONFPENDING',0,2,0,4
	.byte	'TpDataStateType',0,6,118,3
	.word	640
	.byte	4
	.byte	'NetworkHandleType',0,6,128,1,17
	.word	250
	.byte	4
	.byte	'CanNm_TimerType',0,7,74,17
	.word	318
	.byte	4
	.byte	'Can_IdType',0,8,32,16
	.word	318
	.byte	4
	.byte	'Can_HwHandleType',0,8,43,16
	.word	281
	.byte	8,9,93,9,8,9
	.byte	'Class',0
	.word	250
	.byte	1,2,35,0,9
	.byte	'TIN',0
	.word	250
	.byte	1,2,35,1,9
	.byte	'ReturnAddress',0
	.word	318
	.byte	4,2,35,4,0,4
	.byte	'OsTrapInfoType',0,9,97,3
	.word	811
	.byte	10,68
	.word	318
	.byte	11,16,0,8,9,154,1,9,68,9
	.byte	'store',0
	.word	891
	.byte	68,2,35,0,0,10,68
	.word	900
	.byte	11,0,0,4
	.byte	'Os_JumpBufType',0,9,156,1,3
	.word	922
	.byte	4
	.byte	'Os_StackTraceType',0,9,174,1,18
	.word	318
	.byte	8,9,175,1,9,8,9
	.byte	'sp',0
	.word	318
	.byte	4,2,35,0,9
	.byte	'ctx',0
	.word	318
	.byte	4,2,35,4,0,4
	.byte	'Os_StackValueType',0,9,175,1,63
	.word	982
	.byte	4
	.byte	'Os_StackSizeType',0,9,176,1,27
	.word	982
	.byte	12,1,1,3
	.word	1067
	.byte	4
	.byte	'Os_VoidVoidFunctionType',0,9,179,1,16
	.word	1070
	.byte	4
	.byte	'ApplicationType',0,9,193,1,23
	.word	250
	.byte	13
	.byte	'Os_ApplicationConfigurationType_s',0,9,198,1,16,2,9
	.byte	'app_id',0
	.word	250
	.byte	1,2,35,0,9
	.byte	'access',0
	.word	250
	.byte	1,2,35,1,0,4
	.byte	'Os_ApplicationConfigurationType',0,9,201,1,3
	.word	1133
	.byte	4
	.byte	'Os_CoreStateType',0,9,203,1,16
	.word	318
	.byte	4
	.byte	'AreaIdType',0,9,204,1,16
	.word	281
	.byte	4
	.byte	'Os_PeripheralAddressType',0,9,212,1,22
	.word	318
	.byte	4
	.byte	'TickType',0,9,221,1,22
	.word	318
	.byte	4
	.byte	'Os_StopwatchTickType',0,9,225,1,22
	.word	318
	.byte	3
	.word	318
	.byte	4
	.byte	'Os_Lockable',0,9,234,1,18
	.word	1375
	.byte	4
	.byte	'CoreIdType',0,9,236,1,16
	.word	281
	.byte	4
	.byte	'SpinlockIdType',0,9,237,1,16
	.word	281
	.byte	5,9,239,1,9,4,6
	.byte	'TRYTOGETSPINLOCK_SUCCESS',0,0,6
	.byte	'TRYTOGETSPINLOCK_NOSUCCESS',0,1,0,4
	.byte	'TryToGetSpinlockType',0,9,239,1,74
	.word	1445
	.byte	5,9,174,2,9,4,6
	.byte	'APPLICATION_ACCESSIBLE',0,0,6
	.byte	'APPLICATION_RESTARTING',0,1,6
	.byte	'APPLICATION_TERMINATED',0,2,0,4
	.byte	'ApplicationStateType',0,9,174,2,92
	.word	1538
	.byte	14
	.byte	'void',0,3
	.word	1650
	.byte	15,1,1,16
	.word	250
	.byte	16
	.word	1656
	.byte	0,3
	.word	1661
	.byte	4
	.byte	'Os_FunctionEntryType',0,9,183,2,16
	.word	1675
	.byte	13
	.byte	'Os_MeterInfoType_s',0,9,193,2,16,48,9
	.byte	'elapsed',0
	.word	318
	.byte	4,2,35,0,9
	.byte	'previous',0
	.word	318
	.byte	4,2,35,4,9
	.byte	'max',0
	.word	318
	.byte	4,2,35,8,9
	.byte	'cumulative',0
	.word	318
	.byte	4,2,35,12,9
	.byte	'stackbase',0
	.word	982
	.byte	8,2,35,16,9
	.byte	'stackusage',0
	.word	982
	.byte	8,2,35,24,9
	.byte	'stackmax',0
	.word	982
	.byte	8,2,35,32,9
	.byte	'stackbudget',0
	.word	982
	.byte	8,2,35,40,0,4
	.byte	'Os_MeterInfoType',0,9,202,2,3
	.word	1710
	.byte	3
	.word	1710
	.byte	4
	.byte	'Os_MeterInfoRefType',0,9,203,2,50
	.word	1908
	.byte	4
	.byte	'EventMaskType',0,9,206,2,15
	.word	250
	.byte	4
	.byte	'Os_imaskType',0,9,211,2,16
	.word	318
	.byte	13
	.byte	'Os_ISRDynType_s',0,9,213,2,16,48,9
	.byte	'meter',0
	.word	1710
	.byte	48,2,35,0,0,4
	.byte	'Os_ISRDynType',0,9,215,2,3
	.word	1987
	.byte	3
	.word	1987
	.byte	17
	.word	2048
	.byte	13
	.byte	'Os_ISRType_s',0,9,216,2,16,24,9
	.byte	'entry_function',0
	.word	1075
	.byte	4,2,35,0,9
	.byte	'dynamic',0
	.word	2053
	.byte	4,2,35,4,9
	.byte	'imask',0
	.word	318
	.byte	4,2,35,8,9
	.byte	'stackbudget',0
	.word	982
	.byte	8,2,35,12,9
	.byte	'access',0
	.word	250
	.byte	1,2,35,20,9
	.byte	'application',0
	.word	250
	.byte	1,2,35,21,0,4
	.byte	'Os_ISRType',0,9,223,2,3
	.word	2058
	.byte	3
	.word	1067
	.byte	17
	.word	2058
	.byte	3
	.word	2217
	.byte	4
	.byte	'ISRType',0,9,224,2,46
	.word	2222
	.byte	4
	.byte	'Os_bitmask',0,9,239,2,22
	.word	318
	.byte	4
	.byte	'Os_pset0Type',0,9,240,2,20
	.word	318
	.byte	4
	.byte	'Os_pset1Type',0,9,241,2,20
	.word	318
	.byte	4
	.byte	'Os_pset2Type',0,9,242,2,20
	.word	318
	.byte	18,9,243,2,9,4,9
	.byte	'p0',0
	.word	318
	.byte	4,2,35,0,9
	.byte	'p1',0
	.word	318
	.byte	4,2,35,0,9
	.byte	'p2',0
	.word	318
	.byte	4,2,35,0,0,4
	.byte	'Os_psetType',0,9,247,2,3
	.word	2330
	.byte	18,9,249,2,9,4,9
	.byte	't0',0
	.word	318
	.byte	4,2,35,0,9
	.byte	't1',0
	.word	318
	.byte	4,2,35,0,9
	.byte	't2',0
	.word	318
	.byte	4,2,35,0,0,4
	.byte	'Os_tpmaskType',0,9,253,2,3
	.word	2394
	.byte	4
	.byte	'Os_ActivationCountType',0,9,254,2,23
	.word	250
	.byte	13
	.byte	'Os_TaskDynType_s',0,9,128,3,16,120,9
	.byte	'terminate_jump_buf',0
	.word	931
	.byte	68,2,35,0,9
	.byte	'meter',0
	.word	1710
	.byte	48,2,35,68,9
	.byte	'activation_count',0
	.word	250
	.byte	1,2,35,116,0,4
	.byte	'Os_TaskDynType',0,9,132,3,3
	.word	2492
	.byte	10,68
	.word	900
	.byte	11,0,0,3
	.word	2492
	.byte	17
	.word	2618
	.byte	13
	.byte	'Os_TaskType_s',0,9,134,3,16,40,9
	.byte	'dynamic',0
	.word	2623
	.byte	4,2,35,0,9
	.byte	'entry_function',0
	.word	1075
	.byte	4,2,35,4,9
	.byte	'pset',0
	.word	2330
	.byte	4,2,35,8,9
	.byte	'base_tpmask',0
	.word	2394
	.byte	4,2,35,12,9
	.byte	'tpmask',0
	.word	2394
	.byte	4,2,35,16,9
	.byte	'core_id',0
	.word	281
	.byte	2,2,35,20,9
	.byte	'index',0
	.word	318
	.byte	4,2,35,24,9
	.byte	'stackbudget',0
	.word	982
	.byte	8,2,35,28,9
	.byte	'activation_count',0
	.word	250
	.byte	1,2,35,36,9
	.byte	'access',0
	.word	250
	.byte	1,2,35,37,9
	.byte	'application',0
	.word	250
	.byte	1,2,35,38,0,4
	.byte	'Os_TaskType',0,9,146,3,3
	.word	2628
	.byte	17
	.word	2628
	.byte	3
	.word	2878
	.byte	4
	.byte	'TaskType',0,9,147,3,47
	.word	2883
	.byte	19
	.byte	'Os_TaskStateType',0,9,155,3,6,4,6
	.byte	'SUSPENDED',0,0,6
	.byte	'READY',0,1,6
	.byte	'WAITING',0,2,6
	.byte	'RUNNING',0,3,0,4
	.byte	'TaskStateType',0,9,156,3,31
	.word	2906
	.byte	18,9,167,3,3,4,9
	.byte	'tpmask',0
	.word	2394
	.byte	4,2,35,0,0,13
	.byte	'Os_ResourceDynType_s',0,9,166,3,16,4,9
	.byte	'saved_priority',0
	.word	2993
	.byte	4,2,35,0,0,4
	.byte	'Os_ResourceDynType',0,9,170,3,3
	.word	3016
	.byte	3
	.word	3016
	.byte	17
	.word	3096
	.byte	13
	.byte	'Os_ResourceType_s',0,9,171,3,16,12,9
	.byte	'dynamic',0
	.word	3101
	.byte	4,2,35,0,9
	.byte	'tpmask',0
	.word	2394
	.byte	4,2,35,4,9
	.byte	'access',0
	.word	250
	.byte	1,2,35,8,0,4
	.byte	'Os_ResourceType',0,9,175,3,3
	.word	3106
	.byte	8,9,181,3,9,12,9
	.byte	'maxallowedvalue',0
	.word	318
	.byte	4,2,35,0,9
	.byte	'ticksperbase',0
	.word	318
	.byte	4,2,35,4,9
	.byte	'mincycle',0
	.word	318
	.byte	4,2,35,8,0,4
	.byte	'AlarmBaseType',0,9,185,3,3
	.word	3205
	.byte	8,9,206,3,9,8,9
	.byte	'Running',0
	.word	250
	.byte	1,2,35,0,9
	.byte	'Pending',0
	.word	250
	.byte	1,2,35,1,9
	.byte	'Delay',0
	.word	318
	.byte	4,2,35,4,0,4
	.byte	'Os_CounterStatusType',0,9,210,3,3
	.word	3300
	.byte	20
	.word	250
	.byte	1,1,3
	.word	3386
	.byte	4
	.byte	'Os_CounterIncrAdvType',0,9,217,3,22
	.word	3393
	.byte	13
	.byte	's_swd',0,9,222,3,12,4,9
	.byte	'count',0
	.word	318
	.byte	4,2,35,0,0,18,9,221,3,3,4,9
	.byte	'sw',0
	.word	3429
	.byte	4,2,35,0,0,13
	.byte	'Os_CounterDynType_s',0,9,220,3,16,4,9
	.byte	'type_dependent',0
	.word	3457
	.byte	4,2,35,0,0,4
	.byte	'Os_CounterDynType',0,9,226,3,3
	.word	3476
	.byte	3
	.word	3476
	.byte	17
	.word	3554
	.byte	13
	.byte	'Os_CounterType_s',0,9,227,3,16,28,9
	.byte	'dynamic',0
	.word	3559
	.byte	4,2,35,0,9
	.byte	'advincr',0
	.word	3398
	.byte	4,2,35,4,9
	.byte	'base',0
	.word	3205
	.byte	12,2,35,8,9
	.byte	'core',0
	.word	1656
	.byte	4,2,35,20,9
	.byte	'access',0
	.word	250
	.byte	1,2,35,24,9
	.byte	'application',0
	.word	250
	.byte	1,2,35,25,0,4
	.byte	'Os_CounterType',0,9,234,3,3
	.word	3564
	.byte	3
	.word	3386
	.byte	17
	.word	3564
	.byte	3
	.word	3716
	.byte	4
	.byte	'CounterType',0,9,235,3,52
	.word	3721
	.byte	19
	.byte	'Os_ScheduleTableStatusType',0,9,240,3,6,4,6
	.byte	'SCHEDULETABLE_STOPPED',0,0,6
	.byte	'SCHEDULETABLE_NEXT',0,1,6
	.byte	'SCHEDULETABLE_WAITING',0,2,6
	.byte	'SCHEDULETABLE_RUNNING',0,3,6
	.byte	'SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS',0,4,0,4
	.byte	'ScheduleTableStatusType',0,9,241,3,41
	.word	3747
	.byte	17
	.word	.L6-.L3
	.byte	3
	.word	3947
	.byte	4
	.byte	'ScheduleTableType',0,9,128,4,58
	.word	3952
	.byte	13
	.byte	'Os_ScheduleTableDynType_s',0,9,130,4,16,16,9
	.byte	'match',0
	.word	318
	.byte	4,2,35,0,9
	.byte	'next',0
	.word	3957
	.byte	4,2,35,4,9
	.byte	'state',0
	.word	3747
	.byte	4,2,35,8,9
	.byte	'config',0
	.word	281
	.byte	2,2,35,12,0,3
	.word	3984
	.byte	17
	.word	4077
.L6:
	.byte	13
	.byte	'Os_ScheduleTableType_s',0,9,247,3,16,16,9
	.byte	'dynamic',0
	.word	4082
	.byte	4,2,35,0,9
	.byte	'counter',0
	.word	3726
	.byte	4,2,35,4,9
	.byte	'repeat',0
	.word	250
	.byte	1,2,35,8,9
	.byte	'config',0
	.word	281
	.byte	2,2,35,10,9
	.byte	'initial',0
	.word	250
	.byte	1,2,35,12,9
	.byte	'access',0
	.word	250
	.byte	1,2,35,13,9
	.byte	'application',0
	.word	250
	.byte	1,2,35,14,0,4
	.byte	'Os_ScheduleTableType',0,9,255,3,3
	.word	4087
	.byte	17
	.word	4087
	.byte	3
	.word	4267
	.byte	17
	.word	3564
	.byte	3
	.word	4277
	.byte	21
	.word	1380
	.byte	21
	.word	2330
	.byte	21
	.word	2227
	.byte	21
	.word	2888
	.byte	21
	.word	2394
	.byte	21
	.word	250
	.byte	21
	.word	2888
	.byte	13
	.byte	'Os_ControlledCoreType_s',0,9,251,6,16,112,9
	.byte	'TrapInfo',0
	.word	811
	.byte	8,2,35,0,9
	.byte	'lock_taskaccess',0
	.word	4287
	.byte	4,2,35,8,9
	.byte	'ReadyTasks',0
	.word	4292
	.byte	4,2,35,12,9
	.byte	'RunningISR',0
	.word	4297
	.byte	4,2,35,16,9
	.byte	'RunningTask',0
	.word	4302
	.byte	4,2,35,20,9
	.byte	'RunningTPMask',0
	.word	4307
	.byte	4,2,35,24,9
	.byte	'CurrentMeteredObject',0
	.word	1913
	.byte	4,2,35,28,9
	.byte	'IdleMeter',0
	.word	1710
	.byte	48,2,35,32,9
	.byte	'AppAccess',0
	.word	250
	.byte	1,2,35,80,9
	.byte	'AppOverride',0
	.word	4312
	.byte	1,2,35,81,9
	.byte	'GetStackValueAdjust',0
	.word	982
	.byte	8,2,35,84,9
	.byte	'InErrorHook',0
	.word	250
	.byte	1,2,35,92,9
	.byte	'ChainTaskRef',0
	.word	4317
	.byte	4,2,35,96,9
	.byte	'GetStackUsageAdjust',0
	.word	982
	.byte	8,2,35,100,9
	.byte	'InProtectionHook',0
	.word	250
	.byte	1,2,35,108,9
	.byte	'CoreIsActive',0
	.word	250
	.byte	1,2,35,109,9
	.byte	'InShutdownHook',0
	.word	250
	.byte	1,2,35,110,0,4
	.byte	'Os_ControlledCoreType',0,9,141,7,3
	.word	4322
	.byte	3
	.word	318
	.byte	17
	.word	2058
	.byte	3
	.word	4778
	.byte	17
	.word	2628
	.byte	3
	.word	4788
	.byte	3
	.word	1710
	.byte	13
	.byte	'Os_AnyCoreType_s',0,9,151,7,16,96,9
	.byte	'DisableAllImask',0
	.word	318
	.byte	4,2,35,0,9
	.byte	'SuspendAllImask',0
	.word	318
	.byte	4,2,35,4,9
	.byte	'SuspendOSImask',0
	.word	318
	.byte	4,2,35,8,9
	.byte	'DisableAllCount',0
	.word	318
	.byte	4,2,35,12,9
	.byte	'SuspendAllCount',0
	.word	318
	.byte	4,2,35,16,9
	.byte	'SuspendOSCount',0
	.word	318
	.byte	4,2,35,20,9
	.byte	'RestartJumpBuf',0
	.word	931
	.byte	68,2,35,24,9
	.byte	'Restartable',0
	.word	250
	.byte	1,2,35,92,0,4
	.byte	'Os_AnyCoreType',0,9,160,7,3
	.word	4803
	.byte	4
	.byte	'Can_TxObjPriorityClassType',0,10,219,3,16
	.word	318
	.byte	13
	.byte	'Can_TxHwObjectConfigType',0,10,231,3,16,8,9
	.byte	'MsgObjId',0
	.word	250
	.byte	1,2,35,0,9
	.byte	'HwControllerId',0
	.word	250
	.byte	1,2,35,1,9
	.byte	'TxObjPriorityClass',0
	.word	318
	.byte	4,2,35,4,0,4
	.byte	'Can_TxHwObjectConfigType',0,10,252,3,3
	.word	5080
	.byte	13
	.byte	'Can_RxHwObjectConfigType',0,10,129,4,16,12,9
	.byte	'MaskRef',0
	.word	318
	.byte	4,2,35,0,9
	.byte	'MsgId',0
	.word	318
	.byte	4,2,35,4,9
	.byte	'MsgObjId',0
	.word	250
	.byte	1,2,35,8,9
	.byte	'HwControllerId',0
	.word	250
	.byte	1,2,35,9,0,4
	.byte	'Can_RxHwObjectConfigType',0,10,147,4,3
	.word	5216
	.byte	10,4
	.word	250
	.byte	11,3,0,13
	.byte	'Can_ControllerMOMapConfigType',0,10,181,4,16,4,9
	.byte	'ControllerMOMap',0
	.word	5356
	.byte	4,2,35,0,0,4
	.byte	'Can_ControllerMOMapConfigType',0,10,184,4,3
	.word	5365
	.byte	13
	.byte	'Can_NPCRValueType',0,10,188,4,16,2,9
	.byte	'Can_NPCRValue',0
	.word	281
	.byte	2,2,35,0,0,4
	.byte	'Can_NPCRValueType',0,10,191,4,3
	.word	5466
	.byte	13
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,10,194,4,16,8,9
	.byte	'CanControllerBaudrate',0
	.word	318
	.byte	4,2,35,0,9
	.byte	'CanControllerBaudrateCfg',0
	.word	281
	.byte	2,2,35,4,0,4
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,10,198,4,3
	.word	5541
	.byte	17
	.word	5541
	.byte	3
	.word	5706
	.byte	13
	.byte	'Can_BaudrateConfigPtrType',0,10,201,4,16,4,9
	.byte	'Can_kBaudrateConfigPtr',0
	.word	5711
	.byte	4,2,35,0,0,4
	.byte	'Can_BaudrateConfigPtrType',0,10,204,4,3
	.word	5716
	.byte	13
	.byte	'Can_EventHandlingType',0,10,226,4,16,4,9
	.byte	'CanEventType',0
	.word	5356
	.byte	4,2,35,0,0,4
	.byte	'Can_EventHandlingType',0,10,229,4,3
	.word	5816
	.byte	4
	.byte	'Rte_TransformerErrorCode',0,11,130,1,15
	.word	250
	.byte	4
	.byte	'Rte_TransformerClass',0,11,131,1,15
	.word	250
	.byte	8,11,168,1,9,12,9
	.byte	'in',0
	.word	1656
	.byte	4,2,35,0,9
	.byte	'out',0
	.word	1656
	.byte	4,2,35,4,9
	.byte	'used',0
	.word	281
	.byte	2,2,35,8,9
	.byte	'lost_data',0
	.word	250
	.byte	1,2,35,10,0,4
	.byte	'Rte_QDynType',0,11,173,1,3
	.word	5962
	.byte	5,11,175,1,9,4,6
	.byte	'RTE_DRA',0,0,6
	.byte	'RTE_WOWP',0,1,6
	.byte	'RTE_TASK',0,2,6
	.byte	'RTE_ARE',0,3,6
	.byte	'RTE_EV',0,4,6
	.byte	'RTE_MSI',0,5,0,4
	.byte	'Rte_NotificationType',0,11,182,1,3
	.word	6049
	.byte	10,128,8
	.word	250
	.byte	11,255,7,0,4
	.byte	'Impl_NVM_DstPtrType_1024',0,12,50,15
	.word	6147
	.byte	4
	.byte	'CanIf_u32_impl',0,12,69,16
	.word	318
	.byte	4
	.byte	'CanIf_u16_impl',0,12,71,16
	.word	281
	.byte	4
	.byte	'CanIf_u8_impl',0,12,73,15
	.word	250
	.byte	4
	.byte	'CanIf_ControllerModeType_Enum_impl',0,12,88,15
	.word	250
	.byte	4
	.byte	'CanIf_PduModeType_Enum_impl',0,12,90,15
	.word	250
	.byte	8,12,92,9,2,9
	.byte	'DeviceMode',0
	.word	250
	.byte	1,2,35,0,9
	.byte	'ChannelMode',0
	.word	250
	.byte	1,2,35,1,0,4
	.byte	'CanIf_ControllerStateType_struct_impl',0,12,95,3
	.word	6338
	.byte	4
	.byte	'CanIf_NotifStatusType_Enum_impl',0,12,100,15
	.word	250
	.byte	4
	.byte	'CanSM_boolean_Impl',0,12,120,15
	.word	250
	.byte	4
	.byte	'CanSM_u8_Impl',0,12,123,15
	.word	250
	.byte	4
	.byte	'CanSM_BusOffRecoveryStateType_Enum_impl',0,12,128,1,15
	.word	250
	.byte	4
	.byte	'CanSM_NetworkModeStateType_Enum_impl',0,12,132,1,15
	.word	250
	.byte	4
	.byte	'CanSM_u16_Impl',0,12,136,1,16
	.word	281
	.byte	4
	.byte	'CanSM_TimerStateType_Enum_impl',0,12,138,1,15
	.word	250
	.byte	8,12,140,1,9,4,9
	.byte	'cntTick_u16',0
	.word	281
	.byte	2,2,35,0,9
	.byte	'stTimer',0
	.word	250
	.byte	1,2,35,2,0,4
	.byte	'CanSM_TimerConfig_tst_struct_impl',0,12,143,1,3
	.word	6679
	.byte	4
	.byte	'Com_impl_u16',0,12,154,1,16
	.word	281
	.byte	4
	.byte	'Com_impl_u8',0,12,157,1,15
	.word	250
	.byte	4
	.byte	'ComM_uint32_Impl',0,12,173,1,16
	.word	318
	.byte	4
	.byte	'ComM_uint16_Impl',0,12,175,1,16
	.word	281
	.byte	4
	.byte	'ComM_uint8_Impl',0,12,177,1,15
	.word	250
	.byte	4
	.byte	'ComM_bool_Impl',0,12,179,1,15
	.word	250
	.byte	8,12,181,1,9,24,9
	.byte	'ChannelState_e',0
	.word	318
	.byte	4,2,35,0,9
	.byte	'LightTimeoutCtr_u32',0
	.word	318
	.byte	4,2,35,4,9
	.byte	'MinFullComTimeoutCtr_u16',0
	.word	281
	.byte	2,2,35,8,9
	.byte	'ChannelMode_u8',0
	.word	250
	.byte	1,2,35,10,9
	.byte	'BusSmMode_u8',0
	.word	250
	.byte	1,2,35,11,9
	.byte	'UserRequestCtr_u8',0
	.word	250
	.byte	1,2,35,12,9
	.byte	'PassiveRequestState_u8',0
	.word	250
	.byte	1,2,35,13,9
	.byte	'PncRequestCtr_u8',0
	.word	250
	.byte	1,2,35,14,9
	.byte	'InhibitionReqStatus_u8',0
	.word	250
	.byte	1,2,35,15,9
	.byte	'NmNetworkRequestStatus_b',0
	.word	250
	.byte	1,2,35,16,9
	.byte	'DiagnosticRequestState_b',0
	.word	250
	.byte	1,2,35,17,9
	.byte	'CommunicationAllowed_b',0
	.word	250
	.byte	1,2,35,18,9
	.byte	'NmBusSleepIndicationStatus_b',0
	.word	250
	.byte	1,2,35,19,9
	.byte	'NmPrepareBusSleepIndicationStatus_b',0
	.word	250
	.byte	1,2,35,20,9
	.byte	'NmNetworkModeStatus_b',0
	.word	250
	.byte	1,2,35,21,0,4
	.byte	'ComM_ChannelStruct_Impl',0,12,197,1,3
	.word	6911
	.byte	8,12,206,1,9,10,9
	.byte	'WakeUpInhibitionCtr_u16',0
	.word	281
	.byte	2,2,35,0,9
	.byte	'LimitToNoComCtr_u16',0
	.word	281
	.byte	2,2,35,2,9
	.byte	'RequestedUserMode_t',0
	.word	250
	.byte	1,2,35,4,9
	.byte	'IndicatedUserMode_t',0
	.word	250
	.byte	1,2,35,5,9
	.byte	'numChannelsInFullCom_u8',0
	.word	250
	.byte	1,2,35,6,9
	.byte	'numChannelsInSilentCom_u8',0
	.word	250
	.byte	1,2,35,7,9
	.byte	'numChannelsInNoCom_u8',0
	.word	250
	.byte	1,2,35,8,0,4
	.byte	'ComM_UserStruct_Impl',0,12,214,1,3
	.word	7415
	.byte	4
	.byte	'Dcm_IOOperationResponseType',0,12,252,1,15
	.word	250
	.byte	4
	.byte	'Dcm_RequestDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspRequestRoutineResultsOutSignal_0PrimitivType',0
	.byte	12,138,2,15
	.word	250
	.byte	4
	.byte	'Dcm_StartDataIn_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineInSignalPrimitivType',0,12,146,2,15
	.word	250
	.byte	4
	.byte	'Dcm_StartDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineOutSignalPrimitivType',0,12,150,2,15
	.word	250
	.byte	4
	.byte	'Dcm_StopDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStopRoutineOutSignalPrimitivType',0,12,154,2,15
	.word	250
	.byte	4
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockNative_1024_Type',0,12,243,3,34
	.word	6158
	.byte	10,128,8
	.word	250
	.byte	11,255,7,0,4
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockRedundant_1024_Type',0,12,246,3,34
	.word	6158
	.byte	5,13,186,1,10,4,6
	.byte	'NM_BUS_TYPE_CAN',0,0,0,4
	.byte	'Nm_BusType',0,13,189,1,3
	.word	8233
	.byte	4
	.byte	'Nm_TimerType',0,14,73,16
	.word	318
	.byte	4
	.byte	'rba_BswSrv_uint64',0,15,66,28
	.word	349
	.byte	5,16,136,3,9,4,6
	.byte	'NM_SYNCPOINT_INVALID',0,0,6
	.byte	'NM_SYNCPOINT_INIT',0,1,6
	.byte	'NM_SYNCPOINT_READY',0,2,6
	.byte	'NM_SYNCPOINT_REACHED',0,3,0,4
	.byte	'Nm_SynchType',0,16,142,3,3
	.word	8325
	.byte	5,16,155,3,9,4,6
	.byte	'NM_CLUSTER_INIT',0,0,6
	.byte	'NM_CLUSTER_PASSIVE',0,1,6
	.byte	'NM_CLUSTER_ACTIVE_ACTIVE',0,2,6
	.byte	'NM_CLUSTER_ACTIVE_PASSIVE',0,3,0,4
	.byte	'Nm_ClusterStateType',0,16,161,3,3
	.word	8441
	.byte	5,16,177,3,9,4,6
	.byte	'NM_CHANNEL_STATE_UNINIT',0,0,6
	.byte	'NM_CHANNEL_STATE_INIT',0,1,6
	.byte	'NM_CHANNEL_STATE_NORMAL',0,2,6
	.byte	'NM_CHANNEL_STATE_PREPARE_WAIT_SLEEP',0,3,6
	.byte	'NM_CHANNEL_STATE_WAIT_SLEEP',0,4,6
	.byte	'NM_CHANNEL_STATE_BUS_SLEEP',0,5,0,4
	.byte	'Nm_ChannelStateType',0,16,186,3,3
	.word	8571
	.byte	0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L4:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,21,0,54,15,0,0,3,15,0,73,19,0,0,4,22,0,3,8,58,15,59,15
	.byte	57,15,73,19,0,0,5,4,1,58,15,59,15,57,15,11,15,0,0,6,40,0,3,8,28,13,0,0,7,36,0,3,8,11,15,62,15,0,0,8,19
	.byte	1,58,15,59,15,57,15,11,15,0,0,9,13,0,3,8,73,19,11,15,56,9,0,0,10,1,1,11,15,73,19,0,0,11,33,0,47,15,0,0
	.byte	12,21,0,54,15,39,12,0,0,13,19,1,3,8,58,15,59,15,57,15,11,15,0,0,14,59,0,3,8,0,0,15,21,1,54,15,39,12,0
	.byte	0,16,5,0,73,19,0,0,17,38,0,73,19,0,0,18,23,1,58,15,59,15,57,15,11,15,0,0,19,4,1,3,8,58,15,59,15,57,15
	.byte	11,15,0,0,20,21,0,73,19,54,15,39,12,0,0,21,53,0,73,19,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L5:
	.word	.L8-.L7
.L7:
	.half	3
	.word	.L10-.L9
.L9:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Nm\\src\\Nm_LinNm.c',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Nm\\api\\NmStack_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Platform\\Platform_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Std_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\CanNm_PreCompile_and_PB_Variant\\CanNm_Cfg.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Can_GeneralTypes.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\RTOS_T\\Gen\\inc\\Os.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Can_17_MCanP\\inc\\Can_17_MCanP.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Type.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Nm\\Nm_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Nm\\api\\Nm.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\rba_BswSrv.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Nm\\api\\Nm_Priv.h',0,0,0,0,0
.L10:
.L8:

; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	     1  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	     2  /*
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	     3   ***************************************************************************************************
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	     4   * Includes
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	     5   ***************************************************************************************************
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	     6   */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	     7  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	     8  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	     9  /* NM Interface private header file, this file is included only by Nm module */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    10  #include "Nm_Priv.h"
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    11  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    12  /* NM Interface header file for declaration of callback notifications */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    13  #include "Nm_Cbk.h"
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    14  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    15  #if (NM_LINNM_SUPPORT != STD_OFF)
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    16  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    17  /*
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    18   ***************************************************************************************************
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    19   * Variables
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    20   ***************************************************************************************************
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    21   */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    22  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    23  /*
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    24   ***************************************************************************************************
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    25   * Defines
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    26   ***************************************************************************************************
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    27   */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    28  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    29  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    30  /*
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    31   **********************************************************************************************************************
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    32   * Prototypes
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    33   **********************************************************************************************************************
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    34   */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    35  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    36  LOCAL_INLINE FUNC(void, NM_CODE) LinNm_ChangeState(
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    37                                                     P2VAR(LinNm_RamType, AUTOMATIC, LINNM_APPL_DATA) RamPtr_pst,
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    38                                                     VAR(Nm_StateType, AUTOMATIC) nmState_en,
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    39                                                     VAR(Nm_ModeType, AUTOMATIC) nmMode_en
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    40                                                     );
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    41  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    42  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    43  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    44  LOCAL_INLINE FUNC(void, NM_CODE) LinNm_ComputeSwFrTimer(
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    45                                                         P2VAR(LinNm_RamType, AUTOMATIC, NM_APPL_DATA) RamPtr_pst
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    46                                                         );
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    47  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    48  LOCAL_INLINE FUNC(void, NM_CODE) LinNm_GotoBusSleepMode(
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    49  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    50                                                      CONST(NetworkHandleType, AUTOMATIC) nmChannelHandle,
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    51                                                      P2VAR(LinNm_RamType, AUTOMATIC, NM_APPL_DATA) RamPtr_pst
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    52  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    53                                                      );
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    54  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    55  LOCAL_INLINE FUNC(void, NM_CODE) LinNm_GotoNetworkMode(
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    56  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    57                                                      CONST(NetworkHandleType, AUTOMATIC) nmChannelHandle,
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    58                                                      P2VAR(LinNm_RamType, AUTOMATIC, NM_APPL_DATA) RamPtr_pst
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    59  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    60                                                      );
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    61  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    62  static FUNC(void, NM_CODE) LinNm_InternalMainProcess(
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    63                                                      CONST(NetworkHandleType, AUTOMATIC) LinNm_NetworkHandle
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    64                                                      );
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    65  #define NM_START_SEC_CODE
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    66  #include "Nm_MemMap.h"
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    67  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    68   Function name    : LinNm_Init
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    69   Syntax           : void LinNm_Init(void)
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    70   Description      : This is the AUTOSAR interface for initialization called by EcuM.
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    71   Parameter        : NONE
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    72   Return value     : NONE
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    73   **********************************************************************************************************************/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    74  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    75  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    76  FUNC(void, NM_CODE) LinNm_Init(
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    77                                      void
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    78                                   )
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    79  {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    80      /* Pointer to RAM data */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    81      P2VAR(LinNm_RamType, AUTOMATIC, LINNM_APPL_DATA) RamPtr_pst;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    82  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    83      /* variable to hold Channel handle */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    84      VAR(uint8_least, AUTOMATIC) Channel_ui;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    85  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    86      /*********************************************** End Of Declarations ****************************************/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    87  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    88       /* Initialize all the channels which are configured as active */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    89       for(Channel_ui = 0; Channel_ui < (uint8_least)NM_MAX_LINNM_CHANNELS; Channel_ui++)
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    90       {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    91           /* initialize pointer to RAM structure */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    92           RamPtr_pst = &LinNm_RamData_st[Channel_ui];
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    93  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    94           /* Initialize LinNm's mode to bus-sleep mode */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    95           RamPtr_pst->Mode_e = NM_MODE_BUS_SLEEP;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    96  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    97           /* Initialize LinNm's state to bus-sleep mode */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    98           RamPtr_pst->State_e = NM_STATE_BUS_SLEEP;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	    99  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   100           /* Initialize LinNm's internal global variable network request status */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   101           RamPtr_pst->NetworkReqState_e = LINNM_NETWORK_RELEASED_E;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   102  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   103           /* Initialize the free running timer */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   104           RamPtr_pst->ctSwFrTimer_u32 = 0;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   105  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   106           /* Initialize the LinNm Timeout Timer */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   107           RamPtr_pst->ctLINNMTimeoutTimer_u32 = 0;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   108  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   109         }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   110  }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   111  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   112  /***************************************************************************************************
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   113   Function name    : LinNm_MainFunction
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   114   Syntax           : void LinNm_MainFunction( void )
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   115   Description      : Main function of the LinNm which processes the algorithm described in document SWS LinNm.
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   116   Parameter        : None
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   117   Return value     : None
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   118   ***************************************************************************************************/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   119  FUNC(void, NM_CODE) LinNm_MainFunction(void)
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   120  {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   121  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   122      /* Variable to hold the Network Handle of LinNm */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   123      VAR(NetworkHandleType, AUTOMATIC) LinNm_NetworkHandle;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   124  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   125      for(LinNm_NetworkHandle = 0; LinNm_NetworkHandle < NM_MAX_LINNM_CHANNELS ; LinNm_NetworkHandle++)
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   126      {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   127          LinNm_InternalMainProcess(LinNm_NetworkHandle);
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   128      }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   129  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   130  }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   131  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   132  /***************************************************************************************************
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   133   Function name    : LinNm_InternalMainProcess
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   134   Syntax           : void LinNm_InternalMainProcess( const NetworkHandleType LinNm_NetworkHandle )
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   135   Description      : This is an internal main function of LINNM.
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   136                      This is an internal function that does processing of state machine for all channels.
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   137                      This is called by each channel specific Main Function that is scheduled in certain raster.
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   138   Parameter        : LinNm_NetworkHandle - Identification of the LINNM-channel
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   139   Return value     : None
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   140   ***************************************************************************************************/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   141  static FUNC(void, NM_CODE) LinNm_InternalMainProcess(CONST(NetworkHandleType, AUTOMATIC) LinNm_NetworkHandle)
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   142  {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   143  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   144       /* pointer to RAM data */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   145       P2VAR(LinNm_RamType, AUTOMATIC, NM_APPL_DATA)    RamPtr_pst;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   146  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   147       /* initialize the pointer to RAM data structure */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   148       RamPtr_pst = &LinNm_RamData_st[LinNm_NetworkHandle];
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   149  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   150      /* Compute the Free Running timer */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   151       LinNm_ComputeSwFrTimer(RamPtr_pst);
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   152  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   153       if(RamPtr_pst->State_e == NM_STATE_NORMAL_OPERATION)
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   154       {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   155           if(RamPtr_pst->NetworkReqState_e != LINNM_NETWORK_REQUESTED_E)
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   156           {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   157               if(((RamPtr_pst->ctSwFrTimer_u32) - (RamPtr_pst->ctLINNMTimeoutTimer_u32)) >= LINNM_TIMEOUT_TIMER )
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   158               {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   159  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   160                   /* Go to Bus Sleep Mode */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   161                   LinNm_ChangeState(RamPtr_pst, NM_STATE_BUS_SLEEP, NM_MODE_BUS_SLEEP);
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   162  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   163                   /* Notify to the upper layer about changes of the LinNm states if configuration parameter
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   164                                             LINNM_STATE_CHANGE_IND_ENABLED is set to TRUE */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   165  #if (LINNM_STATE_CHANGE_IND_ENABLED != STD_OFF)
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   166                   Nm_StateChangeNotification(LinNm_ConfData_auo[LinNm_NetworkHandle], NM_STATE_NORMAL_OPERATION, NM_STATE_BUS_SLEEP);
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   167  #endif
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   168  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   169                   /* indicate NmIf about Bus Sleep mode */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   170                   Nm_BusSleepMode(LinNm_ConfData_auo[LinNm_NetworkHandle]);
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   171  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   172               }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   173               else
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   174               {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   175                   /* stay in network mode until timer gets expired */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   176               }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   177           }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   178           else
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   179           {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   180                /*stay in network mode until network release is called */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   181           }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   182       }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   183       else
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   184       {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   185            /* stay in the bus sleep state */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   186       }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   187  }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   188  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   189  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   190  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   191  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   192  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   193  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   194  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   195  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   196  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   197  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   198   Function name    : LinNm_PassiveStartUp
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   199   Syntax           : Std_ReturnType LinNm_PassiveStartUp( NetworkHandleType nmChannelHandle )
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   200   Description      : Passive startup of the AUTOSAR LIN NM.
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   201   Parameter        : nmChannelHandle - Identification of the NM-channel
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   202   Return value     : Std_ReturnType   - E_OK: No error
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   203                                      - E_NOT_OK: Passive startup of network management has failed
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   204  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   205   **********************************************************************************************************************/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   206  FUNC(Std_ReturnType, NM_CODE) LinNm_PassiveStartUp(VAR(NetworkHandleType, AUTOMATIC)  nmChannelHandle)
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   207  {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   208  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   209      /* pointer to RAM data */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   210      P2VAR(LinNm_RamType, AUTOMATIC, NM_APPL_DATA)    RamPtr_pst;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   211  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   212      /* Return Value of the API */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   213      VAR(Std_ReturnType, AUTOMATIC)     RetVal;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   214  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   215      /* Variable to hold the Network Handle of LinNm */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   216      VAR(NetworkHandleType, AUTOMATIC) LinNm_NetworkHandle;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   217  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   218      /*********************************************** End Of Declarations ****************************************/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   219  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   220      /* Receive the Internal LinNmChannel structure index from the received  ComM ChannelID*/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   221      LinNm_NetworkHandle = NM_LINNM_GET_HANDLE(nmChannelHandle);
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   222  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   223      /* initialize the pointer to RAM data structure */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   224      RamPtr_pst = &LinNm_RamData_st[LinNm_NetworkHandle];
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   225  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   226      /* check whether the channel handle is within the allowed range and LinNm is initialised*/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   227      if((LinNm_NetworkHandle < (uint8)NM_MAX_LINNM_CHANNELS)&&(RamPtr_pst->State_e != NM_STATE_UNINIT))
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   228      {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   229          /* check if LinNm is in Bus Sleep State */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   230          if(RamPtr_pst->State_e == NM_STATE_BUS_SLEEP)
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   231          {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   232  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   233                /* Goto Bus Network Mode */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   234                LinNm_GotoNetworkMode(nmChannelHandle,RamPtr_pst);
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   235  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   236  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   237  #if(LINNM_TIMEOUT_TIMER != 0U)
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   238  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   239                /* set the Network Requested Status to released as it will be processed in the main function */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   240                 RamPtr_pst->NetworkReqState_e = LINNM_NETWORK_RELEASED_E;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   241  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   242                 /* start LinNm-Timeout time */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   243                 RamPtr_pst->ctLINNMTimeoutTimer_u32 = RamPtr_pst->ctSwFrTimer_u32;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   244  #else
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   245                 /* Goto Bus Sleep without staying in Network Mode */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   246                 LinNm_GotoBusSleepMode(nmChannelHandle,RamPtr_pst);
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   247  #endif
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   248  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   249  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   250               /* return successful transition */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   251               RetVal = E_OK;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   252  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   253           }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   254           else
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   255           {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   256  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   257               /* service is rejected if the current state is not bus sleep*/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   258               RetVal = E_NOT_OK;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   259           }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   260  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   261  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   262      }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   263      else
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   264      {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   265  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   266          /*  service is rejected if the hanlde id is not within the specified limit or if the module is not initialised*/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   267          RetVal = E_NOT_OK;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   268      }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   269  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   270  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   271      return RetVal;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   272  }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   273  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   274  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   275  #if (LINNM_PASSIVE_MODE_ENABLED != STD_ON)
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   276   /**********************************************************************************************************************
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   277    Function name    : LinNm_NetworkRequest
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   278    Syntax           : Std_ReturnType LinNm_NetworkRequest( NetworkHandleType nmChannelHandle )
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   279    Description      : Request the network, since ECU needs to communicate on the bus
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   280    Parameter        : nmChannelHandle - Identification of the NM-channel
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   281    Return value     : Std_ReturnType   - E_OK: No error
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   282                                       - E_NOT_OK: Requesting of network has failed
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   283  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   284    **********************************************************************************************************************/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   285   FUNC(Std_ReturnType, NM_CODE) LinNm_NetworkRequest(VAR(NetworkHandleType, AUTOMATIC)  nmChannelHandle)
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   286  {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   287  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   288  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   289      /* pointer to RAM data */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   290      P2VAR(LinNm_RamType, AUTOMATIC, NM_APPL_DATA)    RamPtr_pst;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   291  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   292      /* Return Value of the API */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   293      VAR(Std_ReturnType, AUTOMATIC)     RetVal;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   294  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   295      /* Variable to hold the Network Handle of LinNm */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   296      VAR(NetworkHandleType, AUTOMATIC) LinNm_NetworkHandle;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   297  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   298      /*********************************************** End Of Declarations ****************************************/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   299  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   300      /* Receive the Internal LinNmChannel structure index from the received  ComM ChannelID*/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   301      LinNm_NetworkHandle = NM_LINNM_GET_HANDLE(nmChannelHandle);
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   302  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   303      /* initialize the pointer to RAM data structure */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   304      RamPtr_pst = &LinNm_RamData_st[LinNm_NetworkHandle];
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   305  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   306      /* check whether the channel handle is within the allowed range and LinNm is initialised*/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   307      if((LinNm_NetworkHandle < (uint8)NM_MAX_LINNM_CHANNELS)&&(RamPtr_pst->State_e != NM_STATE_UNINIT))
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   308      {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   309          /* check if LinNm is in Bus Sleep State */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   310          if(RamPtr_pst->State_e == NM_STATE_BUS_SLEEP)
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   311          {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   312              /* Set network status to request bus */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   313              LinNm_RamData_st[LinNm_NetworkHandle].NetworkReqState_e = LINNM_NETWORK_REQUESTED_E;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   314  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   315              /* Goto Bus Network Mode */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   316              LinNm_GotoNetworkMode(nmChannelHandle,RamPtr_pst);
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   317  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   318  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   319              /* return successful transition */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   320              RetVal = E_OK;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   321  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   322           }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   323           else
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   324           {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   325  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   326               /* service is rejected if the current state is not bus sleep*/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   327               RetVal = E_NOT_OK;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   328           }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   329  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   330      }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   331      else
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   332      {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   333  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   334          /* service is rejected if the hanlde id is not within the specified limit or if the module is not initialised*/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   335          RetVal = E_NOT_OK;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   336      }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   337  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   338  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   339      return RetVal;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   340  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   341   }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   342  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   343   /**********************************************************************************************************************
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   344    Function name    : LinNm_NetworkRelease
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   345    Syntax           : Std_ReturnType LinNm_NetworkRelease( NetworkHandleType nmChannelHandle )
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   346    Description      : Release the network, since ECU does not want to communicate on the bus.
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   347    Parameter        : nmChannelHandle - Identification of the NM-channel
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   348    Return value     : Std_ReturnType   - E_OK: No error
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   349                                       - E_NOT_OK: Releasing of network has failed
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   350  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   351    **********************************************************************************************************************/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   352  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   353   FUNC(Std_ReturnType, NM_CODE) LinNm_NetworkRelease(VAR(NetworkHandleType, AUTOMATIC)  nmChannelHandle)
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   354  {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   355  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   356      /* pointer to RAM data */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   357      P2VAR(LinNm_RamType, AUTOMATIC, NM_APPL_DATA)    RamPtr_pst;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   358  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   359      /* Return Value of the API */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   360      VAR(Std_ReturnType, AUTOMATIC)     RetVal;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   361  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   362      /* Variable to hold the Network Handle of LinNm */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   363      VAR(NetworkHandleType, AUTOMATIC) LinNm_NetworkHandle;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   364  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   365      /*********************************************** End Of Declarations ****************************************/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   366  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   367      /* Receive the Internal LinNmChannel structure index from the received  ComM ChannelID*/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   368      LinNm_NetworkHandle = NM_LINNM_GET_HANDLE(nmChannelHandle);
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   369  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   370      /* initialize the pointer to RAM data structure */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   371      RamPtr_pst = &LinNm_RamData_st[LinNm_NetworkHandle];
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   372  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   373      /* check whether the channel handle is within the allowed range and LinNm is initialised*/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   374      if((LinNm_NetworkHandle < (uint8)NM_MAX_LINNM_CHANNELS)&&(RamPtr_pst->State_e != NM_STATE_UNINIT))
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   375      {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   376          /* check if LinNm is Normal operation state */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   377          if(RamPtr_pst->State_e == NM_STATE_NORMAL_OPERATION)
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   378          {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   379              /* Set network status to release bus */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   380              LinNm_RamData_st[LinNm_NetworkHandle].NetworkReqState_e = LINNM_NETWORK_RELEASED_E;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   381  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   382              /* Goto Bus Sleep without staying in Network Mode */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   383              LinNm_GotoBusSleepMode(nmChannelHandle,RamPtr_pst);
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   384  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   385  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   386              /* return successful transition */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   387              RetVal = E_OK;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   388  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   389           }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   390          else
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   391           {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   392  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   393              /* service is rejected if the current state is not normal operation state*/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   394              RetVal = E_NOT_OK;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   395           }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   396  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   397       }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   398       else
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   399        {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   400  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   401             /* service is rejected if the hanlde id is not within the specified limit or if the module is not initialised*/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   402           RetVal = E_NOT_OK;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   403        }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   404  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   405  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   406        return RetVal;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   407  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   408  }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   409  #endif
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   410  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   411   /**********************************************************************************************************************
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   412    Function name    : LinNm_GetState
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   413    Syntax           : Std_ReturnType LinNm_GetState(
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   414                                                      NetworkHandleType nmNetworkHandle
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   415                                                     Nm_StateType*  nmStatePtr,
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   416                                                     Nm_ModeType*  nmModePtr
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   417                                                   )
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   418    Description      : Returns the state of the network management.The function LinNm_GetState shall be called
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   419                       (e.g. LinNm_GetState function is called if channel is configured as LIN).
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   420    Parameter        : nmNetworkHandle - Identification of the NM-channel
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   421                       nmStatePtr      - Pointer where state of the network management shall be copied to
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   422                       nmModePtr       - Pointer to the location where the mode of the network management shall be copied to
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   423    Return value     : Std_ReturnType   - E_OK: No error
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   424                                         E_NOT_OK : Error
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   425    **********************************************************************************************************************/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   426  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   427  FUNC(Std_ReturnType, NM_CODE) LinNm_GetState(VAR(NetworkHandleType, AUTOMATIC)  nmNetworkHandle,
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   428                                                        P2VAR(Nm_StateType, AUTOMATIC, NM_APPL_DATA) nmStatePtr,
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   429                                                         P2VAR(Nm_ModeType, AUTOMATIC, NM_APPL_DATA) nmModePtr)
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   430  {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   431  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   432      /* pointer to RAM data */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   433      P2VAR(LinNm_RamType, AUTOMATIC, NM_APPL_DATA)    RamPtr_pst;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   434  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   435      /* Return Value of the API */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   436      VAR(Std_ReturnType, AUTOMATIC)     RetVal;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   437  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   438      /* Variable to hold the Network Handle of LinNm */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   439      VAR(NetworkHandleType, AUTOMATIC) LinNm_NetworkHandle;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   440  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   441      /*********************************************** End Of Declarations ****************************************/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   442  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   443      /* Receive the Internal LinNmChannel structure index from the received  ComM ChannelID*/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   444      LinNm_NetworkHandle = NM_LINNM_GET_HANDLE(nmNetworkHandle);
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   445  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   446      /* initialize the pointer to RAM data structure */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   447      RamPtr_pst = &LinNm_RamData_st[LinNm_NetworkHandle];
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   448  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   449      /* check whether the channel handle is within the allowed range */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   450      if((LinNm_NetworkHandle < (uint8)NM_MAX_LINNM_CHANNELS) && (RamPtr_pst->State_e != NM_STATE_UNINIT) && (nmStatePtr != NULL_PTR) && (nmModePtr != NULL_PTR))
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   451      {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   452  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   453          /* suspend interrupts to provide Data consistency */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   454          SchM_Enter_Nm_GetStateNoNest();
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   455  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   456          /* copy the current LinNm state */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   457          *nmStatePtr  = LinNm_RamData_st[LinNm_NetworkHandle].State_e;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   458  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   459          /* copy the current LinNm mode */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   460          *nmModePtr   = LinNm_RamData_st[LinNm_NetworkHandle].Mode_e;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   461  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   462          /* enable interrupts */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   463          SchM_Exit_Nm_GetStateNoNest();
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   464  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   465  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   466          /* return successful transition */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   467          RetVal = E_OK;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   468  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   469      }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   470      else
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   471      {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   472  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   473          /* service is rejected */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   474          RetVal = E_NOT_OK;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   475      }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   476  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   477  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   478      return RetVal;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   479  }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   480  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   481  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   482  /**
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   483   ***************************************************************************************************
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   484   Function name    : LinNm_ChangeState
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   485  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   486   Description      : This is an internal function of LinNm. This function changes the state and mode of
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   487                      LinNm without any data-inconsistency problem
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   488   Parameter        : RamPtr_pst - pointer to the RAM data structure of the current channel
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   489                    : nmState_e - state to be changed to
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   490                    : nmMode_e - mode to be changed to
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   491   Return value     : None
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   492   ***************************************************************************************************
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   493   */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   494  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   495  LOCAL_INLINE FUNC(void, NM_CODE)   LinNm_ChangeState(
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   496                                                          P2VAR(LinNm_RamType, AUTOMATIC, LINNM_APPL_DATA) RamPtr_pst,
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   497                                                          VAR(Nm_StateType, AUTOMATIC) nmState_en,
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   498                                                          VAR(Nm_ModeType, AUTOMATIC) nmMode_en
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   499                                                        )
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   500  {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   501  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   502      /* protect from interrupt to ensure data consistency between state and mode updates */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   503      SchM_Enter_Nm_ChangeStateNoNest();
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   504  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   505      /* update state and modes */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   506      RamPtr_pst->State_e  =  nmState_en;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   507  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   508      RamPtr_pst->Mode_e   =  nmMode_en;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   509  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   510      /* unprotect */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   511      SchM_Exit_Nm_ChangeStateNoNest();
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   512  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   513      return;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   514  }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   515  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   516  /*****************************************************************************************************
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   517   * @ingroup LINNM_INL_H
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   518   *
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   519   *  This inline function computes the free running timer using Main Function period.            \n
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   520   *
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   521   *  @param    RamPtr_pst - pointer to the RAM structure                       \n
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   522   *
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   523   *  @return None \n
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   524   *  *****************************************************************************************************
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   525   */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   526  LOCAL_INLINE FUNC(void, NM_CODE) LinNm_ComputeSwFrTimer(
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   527          P2VAR(LinNm_RamType, AUTOMATIC, NM_APPL_DATA) RamPtr_pst
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   528  )
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   529  {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   530      /* Timer to hold current time stamp of an event */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   531      /* Timer to hold previous time stamp of an event */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   532      /* return value of functions */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   533      /**** End Of Declarations ****/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   534      /* SW Free Running timer handling */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   535      /* read the current time */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   536      RamPtr_pst->ctSwFrTimer_u32 += LINNM_MAINFUNCTION_PERIOD;
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   537  }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   538  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   539  /*****************************************************************************************************
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   540   * @ingroup LINNM_INL_H
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   541   *
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   542   *  This inline function does transition to Bus Sleep mode from Network Mode.           \n
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   543   *
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   544   *  @param    RamPtr_pst - pointer to the RAM structure                       \n
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   545   *
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   546   *  @return None \n
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   547   *  *****************************************************************************************************
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   548   */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   549  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   550  LOCAL_INLINE FUNC(void, NM_CODE) LinNm_GotoBusSleepMode(
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   551                                                      CONST(NetworkHandleType, AUTOMATIC) nmChannelHandle,
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   552                                                      P2VAR(LinNm_RamType, AUTOMATIC, NM_APPL_DATA) RamPtr_pst
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   553                                                      )
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   554  {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   555      /* Go to Bus Sleep Mode */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   556      LinNm_ChangeState(RamPtr_pst, NM_STATE_BUS_SLEEP, NM_MODE_BUS_SLEEP);
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   557  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   558      /* Notify to the upper layer about changes of the LinNm states if configuration parameter
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   559                               LINNM_STATE_CHANGE_IND_ENABLED is set to TRUE */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   560  #if (LINNM_STATE_CHANGE_IND_ENABLED != STD_OFF)
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   561       Nm_StateChangeNotification(nmChannelHandle, NM_STATE_NORMAL_OPERATION, NM_STATE_BUS_SLEEP);
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   562  #endif
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   563  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   564       /* indicate NmIf about Bus Sleep mode */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   565       Nm_BusSleepMode(nmChannelHandle);
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   566  }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   567  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   568  /*****************************************************************************************************
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   569   * @ingroup LINNM_INL_H
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   570   *
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   571   *  This inline function does transition to Network Mode from Bus Sleep Mode.           \n
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   572   *
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   573   *  @param    RamPtr_pst - pointer to the RAM structure                       \n
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   574   *
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   575   *  @return None \n
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   576   *  *****************************************************************************************************
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   577   */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   578  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   579  LOCAL_INLINE FUNC(void, NM_CODE) LinNm_GotoNetworkMode(
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   580                                                      CONST(NetworkHandleType, AUTOMATIC) nmChannelHandle,
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   581                                                      P2VAR(LinNm_RamType, AUTOMATIC, NM_APPL_DATA) RamPtr_pst
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   582                                                      )
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   583  {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   584      /* Go to Network Mode */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   585      LinNm_ChangeState(RamPtr_pst, NM_STATE_NORMAL_OPERATION, NM_MODE_NETWORK);
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   586  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   587      /* Notify to the upper layer about changes of the LinNm states if configuration parameter
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   588                         LINNM_STATE_CHANGE_IND_ENABLED is set to TRUE */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   589  #if (LINNM_STATE_CHANGE_IND_ENABLED != STD_OFF)
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   590      Nm_StateChangeNotification(nmChannelHandle, NM_STATE_BUS_SLEEP, NM_STATE_NORMAL_OPERATION);
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   591  #endif
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   592  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   593      /* indicate NmIf about Network mode */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   594      Nm_NetworkMode(nmChannelHandle);
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   595  }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   596  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   597  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   598  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   599  /**********************************************************************************************************************
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   600   Function name    : LinNm_SetSleepReadyBit
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   601   Syntax           : Std_ReturnType LinNm_SetSleepReadyBit( VAR(NetworkHandleType, AUTOMATIC)  nmChannelHandle ,
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   602                                                            VAR (boolean, AUTOMATIC) nmSleepReadyBit)
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   603   Description      : Empty function to be compliant with NM specifications.
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   604   Parameter        : nmChannelHandle - Identification of the NM-channel
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   605                       nmSleepReadyBit- Value written to ReadySleep Bit in CBV
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   606   Return value     :  E_OK: No error
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   607  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   608   **********************************************************************************************************************/
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   609  #if (LINNM_COORDINATOR_SYNC_SUPPORT_ENABLED != STD_OFF)
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   610  FUNC(Std_ReturnType, NM_CODE) LinNm_SetSleepReadyBit(VAR(NetworkHandleType, AUTOMATIC)  nmChannelHandle,
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   611                                                             VAR (boolean, AUTOMATIC) nmSleepReadyBit)
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   612  {
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   613  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   614      /* This API is just a dummy to satisfy NM interface linkage. It shall always return E_OK. */
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   615      (void)(nmChannelHandle);
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   616      (void)(nmSleepReadyBit);
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   617  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   618      return (E_OK);
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   619  }
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   620  #endif
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   621  
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   622  #define NM_STOP_SEC_CODE
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   623  #include "Nm_MemMap.h"
; BSW\src\BSW\Gen\Nm\src\Nm_LinNm.c	   624  #endif

	; Module end
