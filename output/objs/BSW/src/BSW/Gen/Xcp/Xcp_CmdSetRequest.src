	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 19053136 SN 09001910"
	.compiler_invocation	"ctc -f cc15468a -c99 --integer-enumeration -D__CPU__=tc27x -D__CPU_TC27X__ --core=tc1.6.x --eabi-compliant --fp-model=-float -D_TASKING_C_TRICORE_=1 -I.\\output\\inc -g2 -t4 --language=-comments,-gcc,+volatile,-strings --default-near-size=0 -O2ROPYGKLF-predict --default-a1-size=0 --default-a0-size=0 --source --switch=auto -o output\\objs\\BSW\\src\\BSW\\Gen\\Xcp\\Xcp_CmdSetRequest.src BSW\\src\\BSW\\Gen\\Xcp\\src\\Xcp_CmdSetRequest.c"
	.compiler_name		"ctc"
	;source	'BSW\\src\\BSW\\Gen\\Xcp\\src\\Xcp_CmdSetRequest.c'

	
$TC16X
	
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L3:
	.word	13523
	.half	3
	.word	.L4
	.byte	4
.L2:
	.byte	1
	.byte	'BSW\\src\\BSW\\Gen\\Xcp\\src\\Xcp_CmdSetRequest.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L5
	.byte	2,1,3
	.word	143
	.byte	4
	.byte	'__codeptr',0,1,1,1
	.word	145
	.byte	5
	.byte	'char',0,1,6,4
	.byte	'sint8',0,2,76,25
	.word	168
	.byte	5
	.byte	'unsigned char',0,1,8,4
	.byte	'uint8',0,2,81,25
	.word	190
	.byte	5
	.byte	'unsigned short int',0,2,7,4
	.byte	'uint16',0,2,91,25
	.word	221
	.byte	5
	.byte	'unsigned int',0,4,7,4
	.byte	'uint32',0,2,106,24
	.word	258
	.byte	5
	.byte	'unsigned long long int',0,8,7,4
	.byte	'uint64',0,2,111,30
	.word	289
	.byte	4
	.byte	'boolean',0,2,127,25
	.word	190
	.byte	4
	.byte	'StatusType',0,3,191,1,27
	.word	190
	.byte	4
	.byte	'Std_ReturnType',0,3,199,1,15
	.word	190
	.byte	6,3,206,1,9,8,7
	.byte	'vendorID',0
	.word	221
	.byte	2,2,35,0,7
	.byte	'moduleID',0
	.word	221
	.byte	2,2,35,2,7
	.byte	'sw_major_version',0
	.word	190
	.byte	1,2,35,4,7
	.byte	'sw_minor_version',0
	.word	190
	.byte	1,2,35,5,7
	.byte	'sw_patch_version',0
	.word	190
	.byte	1,2,35,6,0,4
	.byte	'Std_VersionInfoType',0,3,213,1,3
	.word	390
	.byte	4
	.byte	'PduIdType',0,4,22,19
	.word	221
	.byte	4
	.byte	'PduLengthType',0,4,26,19
	.word	221
	.byte	8,5,113,9,4,9
	.byte	'TP_DATACONF',0,0,9
	.byte	'TP_DATARETRY',0,1,9
	.byte	'TP_CONFPENDING',0,2,0,4
	.byte	'TpDataStateType',0,5,118,3
	.word	580
	.byte	8,6,225,1,9,4,9
	.byte	'XCP_STATE_DISCONNECTED',0,0,9
	.byte	'XCP_STATE_DISCONNECTING',0,1,9
	.byte	'XCP_STATE_CONNECTED',0,2,9
	.byte	'XCP_STATE_RESUME',0,3,9
	.byte	'XCP_STATE_DISABLED',0,240,1,0,4
	.byte	'Xcp_State_t',0,6,231,1,2
	.word	656
	.byte	4
	.byte	'Xcp_AddrValue',0,6,165,3,23
	.word	258
	.byte	6,6,168,3,9,8,7
	.byte	'AddrValue',0
	.word	258
	.byte	4,2,35,0,7
	.byte	'Extension',0
	.word	190
	.byte	1,2,35,4,0,4
	.byte	'Xcp_AddrType_t',0,6,172,3,3
	.word	821
	.byte	4
	.byte	'Xcp_PduIdType',0,6,174,3,15
	.word	190
	.byte	8,6,177,3,9,4,9
	.byte	'XCP_ERR_CMD_SYNCH',0,0,9
	.byte	'XCP_ERR_CMD_BUSY',0,16,9
	.byte	'XCP_ERR_DAQ_ACTIVE',0,17,9
	.byte	'XCP_ERR_PGM_ACTIVE',0,18,9
	.byte	'XCP_ERR_CMD_UNKNOWN',0,32,9
	.byte	'XCP_ERR_CMD_SYNTAX',0,33,9
	.byte	'XCP_ERR_OUT_OF_RANGE',0,34,9
	.byte	'XCP_ERR_WRITE_PROTECTED',0,35,9
	.byte	'XCP_ERR_ACCESS_DENIED',0,36,9
	.byte	'XCP_ERR_ACCESS_LOCKED',0,37,9
	.byte	'XCP_ERR_PAGE_NOT_VALID',0,38,9
	.byte	'XCP_ERR_MODE_NOT_VALID',0,39,9
	.byte	'XCP_ERR_SEGMENT_NOT_VALID',0,40,9
	.byte	'XCP_ERR_SEQUENCE',0,41,9
	.byte	'XCP_ERR_DAQ_CONFIG',0,42,9
	.byte	'XCP_ERR_MEMORY_OVERFLOW',0,48,9
	.byte	'XCP_ERR_GENERIC',0,49,9
	.byte	'XCP_ERR_VERIFY',0,50,9
	.byte	'XCP_ERR_RES_TEMP_NOT_ACCESS',0,51,9
	.byte	'XCP_ERR_SUBCMD_UNKNOWN',0,52,9
	.byte	'XCP_REPEAT_COMMAND',0,252,1,9
	.byte	'XCP_NO_ACCESS_HIDE',0,253,1,9
	.byte	'XCP_NO_RESPONSE',0,254,1,9
	.byte	'XCP_NO_ERROR',0,255,1,0,4
	.byte	'Xcp_ErrorCode',0,6,204,3,2
	.word	913
	.byte	8,6,207,3,9,4,9
	.byte	'XCP_DAQ_STATE_NO_DAQ',0,0,9
	.byte	'XCP_DAQ_STATE_FREE_DAQ',0,1,9
	.byte	'XCP_DAQ_STATE_ALLOC_DAQ',0,2,9
	.byte	'XCP_DAQ_STATE_ALLOC_ODT',0,3,9
	.byte	'XCP_DAQ_STATE_ALLOC_ODT_ENTRY',0,4,9
	.byte	'XCP_DAQ_STATE_WRITE_DAQ',0,5,9
	.byte	'XCP_DAQ_STATE_PREPARE_START',0,6,9
	.byte	'XCP_DAQ_STATE_SHIFTING',0,7,9
	.byte	'XCP_DAQ_STATE_STOP_REQUESTED',0,8,9
	.byte	'XCP_DAQ_STATE_READY_TO_RUN',0,9,9
	.byte	'XCP_DAQ_STATE_RUNNING',0,10,0,4
	.byte	'Xcp_DaqState_t',0,6,220,3,2
	.word	1477
	.byte	8,6,223,3,9,4,9
	.byte	'XCP_DAQ_NO_OVERLOAD_INDICATION',0,0,9
	.byte	'XCP_DAQ_OVERLOAD_INDICATION_PID',0,1,9
	.byte	'XCP_DAQ_OVERLOAD_INDICATION_EVENT',0,2,0,4
	.byte	'Xcp_Overload_t',0,6,228,3,2
	.word	1805
	.byte	8,6,233,3,9,4,9
	.byte	'XCP_IDENTIFICATION_FIELD_TYPE_ABSOLUTE',0,1,9
	.byte	'XCP_IDENTIFICATION_FIELD_TYPE_RELATIVE_BYTE',0,2,9
	.byte	'XCP_IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD',0,3,9
	.byte	'XCP_IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD_ALIGNED',0,4,0,4
	.byte	'Xcp_IdField_t',0,6,239,3,2
	.word	1939
	.byte	8,6,242,3,9,4,9
	.byte	'XCP_ODT_OPTIMIZATION_OM_DEFAULT',0,0,9
	.byte	'XCP_ODT_OPTIMIZATION_OM_ODT_TYPE_16',0,1,9
	.byte	'XCP_ODT_OPTIMIZATION_OM_ODT_TYPE_32',0,2,9
	.byte	'XCP_ODT_OPTIMIZATION_OM_ODT_TYPE_64',0,3,9
	.byte	'XCP_ODT_OPTIMIZATION_OM_ODT_TYPE_ALIGNMENT',0,4,9
	.byte	'XCP_ODT_OPTIMIZATION_OM_MAX_ENTRY_SIZE',0,5,0,4
	.byte	'Xcp_OdtOptimizationType_t',0,6,250,3,2
	.word	2156
	.byte	8,6,253,3,9,4,9
	.byte	'XCP_CONSISTENCY_ODT',0,0,9
	.byte	'XCP_CONSISTENCY_DAQ',0,1,9
	.byte	'XCP_CONSISTENCY_EVENT',0,2,9
	.byte	'XCP_CONSISTENCY_NONE',0,3,0,4
	.byte	'Xcp_Consistency_t',0,6,131,4,2
	.word	2432
	.byte	8,6,134,4,9,4,9
	.byte	'XCP_TIMESTAMP_TYPE_NO_TIME_STAMP',0,0,9
	.byte	'XCP_TIMESTAMP_TYPE_ONE_BYTE',0,1,9
	.byte	'XCP_TIMESTAMP_TYPE_TWO_BYTE',0,2,9
	.byte	'XCP_TIMESTAMP_TYPE_FOUR_BYTE',0,4,0,4
	.byte	'Xcp_Timestamp_t',0,6,140,4,2
	.word	2557
	.byte	10,8
	.word	190
	.byte	11,7,0,6,6,174,4,9,12,7
	.byte	'Buffer_au8',0
	.word	2715
	.byte	8,2,35,0,7
	.byte	'Length_u32',0
	.word	258
	.byte	4,2,35,8,0,4
	.byte	'Xcp_Cto8_t',0,6,178,4,2
	.word	2724
	.byte	3
	.word	190
	.byte	6,5,71,9,8,7
	.byte	'SduDataPtr',0
	.word	2791
	.byte	4,2,35,0,7
	.byte	'SduLength',0
	.word	221
	.byte	2,2,35,4,0,12
	.word	2796
	.byte	3
	.word	2841
	.byte	13
	.word	190
	.byte	1,1,14
	.word	2846
	.byte	14
	.word	190
	.byte	14
	.word	190
	.byte	0,3
	.word	2851
	.byte	15,1,1,14
	.word	190
	.byte	14
	.word	190
	.byte	0,3
	.word	2879
	.byte	15,1,1,14
	.word	190
	.byte	0,3
	.word	2898
	.byte	13
	.word	190
	.byte	1,1,14
	.word	190
	.byte	0,3
	.word	2912
	.byte	3
	.word	2796
	.byte	15,1,1,14
	.word	2846
	.byte	14
	.word	2930
	.byte	14
	.word	190
	.byte	0,3
	.word	2935
	.byte	13
	.word	190
	.byte	1,1,14
	.word	190
	.byte	14
	.word	221
	.byte	14
	.word	190
	.byte	0,3
	.word	2959
	.byte	6,7,164,1,9,56,7
	.byte	'TLTransmit_pfct',0
	.word	2874
	.byte	4,2,35,0,7
	.byte	'TLInit_pfct',0
	.word	2893
	.byte	4,2,35,4,7
	.byte	'TLConnect_pfct',0
	.word	2907
	.byte	4,2,35,8,7
	.byte	'TLDisconnect_pfct',0
	.word	2925
	.byte	4,2,35,12,7
	.byte	'TLTransportLayerCmd_pfct',0
	.word	2954
	.byte	4,2,35,16,7
	.byte	'TLGetTxPduId_pfct',0
	.word	2982
	.byte	4,2,35,20,7
	.byte	'MaxCto_u8',0
	.word	190
	.byte	1,2,35,24,7
	.byte	'MaxDto_u16',0
	.word	221
	.byte	2,2,35,26,7
	.byte	'TimestampType_en',0
	.word	2557
	.byte	4,2,35,28,7
	.byte	'IdFieldType_en',0
	.word	1939
	.byte	4,2,35,32,7
	.byte	'OverloadType_en',0
	.word	1805
	.byte	4,2,35,36,7
	.byte	'OdtOptimizationType_en',0
	.word	2156
	.byte	4,2,35,40,7
	.byte	'Consistency_en',0
	.word	2432
	.byte	4,2,35,44,7
	.byte	'PdRam_u32',0
	.word	258
	.byte	4,2,35,48,7
	.byte	'EdRam_u32',0
	.word	258
	.byte	4,2,35,52,0,4
	.byte	'Xcp_PL_TL_Cfg_t',0,7,184,1,2
	.word	2987
	.byte	8,7,188,1,9,4,9
	.byte	'XCP_RAMSECTION_INVALID',0,0,9
	.byte	'XCP_RAMSECTION_PD',0,1,9
	.byte	'XCP_RAMSECTION_ED',0,2,0,4
	.byte	'Xcp_RamSectionType_t',0,7,193,1,2
	.word	3385
	.byte	6,7,195,1,9,12,7
	.byte	'DaqRamPtr_pu8',0
	.word	2791
	.byte	4,2,35,0,7
	.byte	'DaqRamTotalSize_u32',0
	.word	258
	.byte	4,2,35,4,7
	.byte	'RamSectionType_en',0
	.word	3385
	.byte	4,2,35,8,0,4
	.byte	'Xcp_DaqRamSection_Cfg_t',0,7,200,1,2
	.word	3487
	.byte	10,1
	.word	190
	.byte	11,0,0,6,7,203,1,9,8,7
	.byte	'DaqRamFreeSize_u32',0
	.word	258
	.byte	4,2,35,0,7
	.byte	'PLConnected_ab',0
	.word	3606
	.byte	1,2,35,4,0,4
	.byte	'Xcp_DaqRamSections_t',0,7,207,1,2
	.word	3615
	.byte	6,7,230,1,9,4,7
	.byte	'EventChannelDirection_u8',0
	.word	190
	.byte	1,2,35,0,7
	.byte	'EventChannelTimeCycle_u8',0
	.word	190
	.byte	1,2,35,1,7
	.byte	'EventChannelTimeUnit_u8',0
	.word	190
	.byte	1,2,35,2,7
	.byte	'EventChannelPriority_u8',0
	.word	190
	.byte	1,2,35,3,0,4
	.byte	'Xcp_EventChannel_Cfg_t',0,7,236,1,2
	.word	3704
	.byte	4
	.byte	'rba_BswSrv_uint64',0,8,66,28
	.word	289
	.byte	4
	.byte	'Can_IdType',0,9,32,16
	.word	258
	.byte	4
	.byte	'Can_HwHandleType',0,9,43,16
	.word	221
	.byte	6,10,93,9,8,7
	.byte	'Class',0
	.word	190
	.byte	1,2,35,0,7
	.byte	'TIN',0
	.word	190
	.byte	1,2,35,1,7
	.byte	'ReturnAddress',0
	.word	258
	.byte	4,2,35,4,0,4
	.byte	'OsTrapInfoType',0,10,97,3
	.word	3947
	.byte	10,68
	.word	258
	.byte	11,16,0,6,10,154,1,9,68,7
	.byte	'store',0
	.word	4027
	.byte	68,2,35,0,0,10,68
	.word	4036
	.byte	11,0,0,4
	.byte	'Os_JumpBufType',0,10,156,1,3
	.word	4058
	.byte	4
	.byte	'Os_StackTraceType',0,10,174,1,18
	.word	258
	.byte	6,10,175,1,9,8,7
	.byte	'sp',0
	.word	258
	.byte	4,2,35,0,7
	.byte	'ctx',0
	.word	258
	.byte	4,2,35,4,0,4
	.byte	'Os_StackValueType',0,10,175,1,63
	.word	4118
	.byte	4
	.byte	'Os_StackSizeType',0,10,176,1,27
	.word	4118
	.byte	16,1,1,3
	.word	4203
	.byte	4
	.byte	'Os_VoidVoidFunctionType',0,10,179,1,16
	.word	4206
	.byte	4
	.byte	'ApplicationType',0,10,193,1,23
	.word	190
	.byte	17
	.byte	'Os_ApplicationConfigurationType_s',0,10,198,1,16,2,7
	.byte	'app_id',0
	.word	190
	.byte	1,2,35,0,7
	.byte	'access',0
	.word	190
	.byte	1,2,35,1,0,4
	.byte	'Os_ApplicationConfigurationType',0,10,201,1,3
	.word	4269
	.byte	4
	.byte	'Os_CoreStateType',0,10,203,1,16
	.word	258
	.byte	4
	.byte	'AreaIdType',0,10,204,1,16
	.word	221
	.byte	4
	.byte	'Os_PeripheralAddressType',0,10,212,1,22
	.word	258
	.byte	4
	.byte	'TickType',0,10,221,1,22
	.word	258
	.byte	4
	.byte	'Os_StopwatchTickType',0,10,225,1,22
	.word	258
	.byte	3
	.word	258
	.byte	4
	.byte	'Os_Lockable',0,10,234,1,18
	.word	4511
	.byte	4
	.byte	'CoreIdType',0,10,236,1,16
	.word	221
	.byte	4
	.byte	'SpinlockIdType',0,10,237,1,16
	.word	221
	.byte	8,10,239,1,9,4,9
	.byte	'TRYTOGETSPINLOCK_SUCCESS',0,0,9
	.byte	'TRYTOGETSPINLOCK_NOSUCCESS',0,1,0,4
	.byte	'TryToGetSpinlockType',0,10,239,1,74
	.word	4581
	.byte	8,10,174,2,9,4,9
	.byte	'APPLICATION_ACCESSIBLE',0,0,9
	.byte	'APPLICATION_RESTARTING',0,1,9
	.byte	'APPLICATION_TERMINATED',0,2,0,4
	.byte	'ApplicationStateType',0,10,174,2,92
	.word	4674
	.byte	18
	.byte	'void',0,3
	.word	4786
	.byte	15,1,1,14
	.word	190
	.byte	14
	.word	4792
	.byte	0,3
	.word	4797
	.byte	4
	.byte	'Os_FunctionEntryType',0,10,183,2,16
	.word	4811
	.byte	17
	.byte	'Os_MeterInfoType_s',0,10,193,2,16,48,7
	.byte	'elapsed',0
	.word	258
	.byte	4,2,35,0,7
	.byte	'previous',0
	.word	258
	.byte	4,2,35,4,7
	.byte	'max',0
	.word	258
	.byte	4,2,35,8,7
	.byte	'cumulative',0
	.word	258
	.byte	4,2,35,12,7
	.byte	'stackbase',0
	.word	4118
	.byte	8,2,35,16,7
	.byte	'stackusage',0
	.word	4118
	.byte	8,2,35,24,7
	.byte	'stackmax',0
	.word	4118
	.byte	8,2,35,32,7
	.byte	'stackbudget',0
	.word	4118
	.byte	8,2,35,40,0,4
	.byte	'Os_MeterInfoType',0,10,202,2,3
	.word	4846
	.byte	3
	.word	4846
	.byte	4
	.byte	'Os_MeterInfoRefType',0,10,203,2,50
	.word	5044
	.byte	4
	.byte	'EventMaskType',0,10,206,2,15
	.word	190
	.byte	4
	.byte	'Os_imaskType',0,10,211,2,16
	.word	258
	.byte	17
	.byte	'Os_ISRDynType_s',0,10,213,2,16,48,7
	.byte	'meter',0
	.word	4846
	.byte	48,2,35,0,0,4
	.byte	'Os_ISRDynType',0,10,215,2,3
	.word	5123
	.byte	3
	.word	5123
	.byte	12
	.word	5184
	.byte	17
	.byte	'Os_ISRType_s',0,10,216,2,16,24,7
	.byte	'entry_function',0
	.word	4211
	.byte	4,2,35,0,7
	.byte	'dynamic',0
	.word	5189
	.byte	4,2,35,4,7
	.byte	'imask',0
	.word	258
	.byte	4,2,35,8,7
	.byte	'stackbudget',0
	.word	4118
	.byte	8,2,35,12,7
	.byte	'access',0
	.word	190
	.byte	1,2,35,20,7
	.byte	'application',0
	.word	190
	.byte	1,2,35,21,0,4
	.byte	'Os_ISRType',0,10,223,2,3
	.word	5194
	.byte	3
	.word	4203
	.byte	12
	.word	5194
	.byte	3
	.word	5353
	.byte	4
	.byte	'ISRType',0,10,224,2,46
	.word	5358
	.byte	4
	.byte	'Os_bitmask',0,10,239,2,22
	.word	258
	.byte	4
	.byte	'Os_pset0Type',0,10,240,2,20
	.word	258
	.byte	4
	.byte	'Os_pset1Type',0,10,241,2,20
	.word	258
	.byte	4
	.byte	'Os_pset2Type',0,10,242,2,20
	.word	258
	.byte	19,10,243,2,9,4,7
	.byte	'p0',0
	.word	258
	.byte	4,2,35,0,7
	.byte	'p1',0
	.word	258
	.byte	4,2,35,0,7
	.byte	'p2',0
	.word	258
	.byte	4,2,35,0,0,4
	.byte	'Os_psetType',0,10,247,2,3
	.word	5466
	.byte	19,10,249,2,9,4,7
	.byte	't0',0
	.word	258
	.byte	4,2,35,0,7
	.byte	't1',0
	.word	258
	.byte	4,2,35,0,7
	.byte	't2',0
	.word	258
	.byte	4,2,35,0,0,4
	.byte	'Os_tpmaskType',0,10,253,2,3
	.word	5530
	.byte	4
	.byte	'Os_ActivationCountType',0,10,254,2,23
	.word	190
	.byte	17
	.byte	'Os_TaskDynType_s',0,10,128,3,16,120,7
	.byte	'terminate_jump_buf',0
	.word	4067
	.byte	68,2,35,0,7
	.byte	'meter',0
	.word	4846
	.byte	48,2,35,68,7
	.byte	'activation_count',0
	.word	190
	.byte	1,2,35,116,0,4
	.byte	'Os_TaskDynType',0,10,132,3,3
	.word	5628
	.byte	10,68
	.word	4036
	.byte	11,0,0,3
	.word	5628
	.byte	12
	.word	5754
	.byte	17
	.byte	'Os_TaskType_s',0,10,134,3,16,40,7
	.byte	'dynamic',0
	.word	5759
	.byte	4,2,35,0,7
	.byte	'entry_function',0
	.word	4211
	.byte	4,2,35,4,7
	.byte	'pset',0
	.word	5466
	.byte	4,2,35,8,7
	.byte	'base_tpmask',0
	.word	5530
	.byte	4,2,35,12,7
	.byte	'tpmask',0
	.word	5530
	.byte	4,2,35,16,7
	.byte	'core_id',0
	.word	221
	.byte	2,2,35,20,7
	.byte	'index',0
	.word	258
	.byte	4,2,35,24,7
	.byte	'stackbudget',0
	.word	4118
	.byte	8,2,35,28,7
	.byte	'activation_count',0
	.word	190
	.byte	1,2,35,36,7
	.byte	'access',0
	.word	190
	.byte	1,2,35,37,7
	.byte	'application',0
	.word	190
	.byte	1,2,35,38,0,4
	.byte	'Os_TaskType',0,10,146,3,3
	.word	5764
	.byte	12
	.word	5764
	.byte	3
	.word	6014
	.byte	4
	.byte	'TaskType',0,10,147,3,47
	.word	6019
	.byte	20
	.byte	'Os_TaskStateType',0,10,155,3,6,4,9
	.byte	'SUSPENDED',0,0,9
	.byte	'READY',0,1,9
	.byte	'WAITING',0,2,9
	.byte	'RUNNING',0,3,0,4
	.byte	'TaskStateType',0,10,156,3,31
	.word	6042
	.byte	19,10,167,3,3,4,7
	.byte	'tpmask',0
	.word	5530
	.byte	4,2,35,0,0,17
	.byte	'Os_ResourceDynType_s',0,10,166,3,16,4,7
	.byte	'saved_priority',0
	.word	6129
	.byte	4,2,35,0,0,4
	.byte	'Os_ResourceDynType',0,10,170,3,3
	.word	6152
	.byte	3
	.word	6152
	.byte	12
	.word	6232
	.byte	17
	.byte	'Os_ResourceType_s',0,10,171,3,16,12,7
	.byte	'dynamic',0
	.word	6237
	.byte	4,2,35,0,7
	.byte	'tpmask',0
	.word	5530
	.byte	4,2,35,4,7
	.byte	'access',0
	.word	190
	.byte	1,2,35,8,0,4
	.byte	'Os_ResourceType',0,10,175,3,3
	.word	6242
	.byte	6,10,181,3,9,12,7
	.byte	'maxallowedvalue',0
	.word	258
	.byte	4,2,35,0,7
	.byte	'ticksperbase',0
	.word	258
	.byte	4,2,35,4,7
	.byte	'mincycle',0
	.word	258
	.byte	4,2,35,8,0,4
	.byte	'AlarmBaseType',0,10,185,3,3
	.word	6341
	.byte	6,10,206,3,9,8,7
	.byte	'Running',0
	.word	190
	.byte	1,2,35,0,7
	.byte	'Pending',0
	.word	190
	.byte	1,2,35,1,7
	.byte	'Delay',0
	.word	258
	.byte	4,2,35,4,0,4
	.byte	'Os_CounterStatusType',0,10,210,3,3
	.word	6436
	.byte	21
	.word	190
	.byte	1,1,3
	.word	6522
	.byte	4
	.byte	'Os_CounterIncrAdvType',0,10,217,3,22
	.word	6529
	.byte	17
	.byte	's_swd',0,10,222,3,12,4,7
	.byte	'count',0
	.word	258
	.byte	4,2,35,0,0,19,10,221,3,3,4,7
	.byte	'sw',0
	.word	6565
	.byte	4,2,35,0,0,17
	.byte	'Os_CounterDynType_s',0,10,220,3,16,4,7
	.byte	'type_dependent',0
	.word	6593
	.byte	4,2,35,0,0,4
	.byte	'Os_CounterDynType',0,10,226,3,3
	.word	6612
	.byte	3
	.word	6612
	.byte	12
	.word	6690
	.byte	17
	.byte	'Os_CounterType_s',0,10,227,3,16,28,7
	.byte	'dynamic',0
	.word	6695
	.byte	4,2,35,0,7
	.byte	'advincr',0
	.word	6534
	.byte	4,2,35,4,7
	.byte	'base',0
	.word	6341
	.byte	12,2,35,8,7
	.byte	'core',0
	.word	4792
	.byte	4,2,35,20,7
	.byte	'access',0
	.word	190
	.byte	1,2,35,24,7
	.byte	'application',0
	.word	190
	.byte	1,2,35,25,0,4
	.byte	'Os_CounterType',0,10,234,3,3
	.word	6700
	.byte	3
	.word	6522
	.byte	12
	.word	6700
	.byte	3
	.word	6852
	.byte	4
	.byte	'CounterType',0,10,235,3,52
	.word	6857
	.byte	20
	.byte	'Os_ScheduleTableStatusType',0,10,240,3,6,4,9
	.byte	'SCHEDULETABLE_STOPPED',0,0,9
	.byte	'SCHEDULETABLE_NEXT',0,1,9
	.byte	'SCHEDULETABLE_WAITING',0,2,9
	.byte	'SCHEDULETABLE_RUNNING',0,3,9
	.byte	'SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS',0,4,0,4
	.byte	'ScheduleTableStatusType',0,10,241,3,41
	.word	6883
	.byte	12
	.word	.L6-.L3
	.byte	3
	.word	7083
	.byte	4
	.byte	'ScheduleTableType',0,10,128,4,58
	.word	7088
	.byte	17
	.byte	'Os_ScheduleTableDynType_s',0,10,130,4,16,16,7
	.byte	'match',0
	.word	258
	.byte	4,2,35,0,7
	.byte	'next',0
	.word	7093
	.byte	4,2,35,4,7
	.byte	'state',0
	.word	6883
	.byte	4,2,35,8,7
	.byte	'config',0
	.word	221
	.byte	2,2,35,12,0,3
	.word	7120
	.byte	12
	.word	7213
.L6:
	.byte	17
	.byte	'Os_ScheduleTableType_s',0,10,247,3,16,16,7
	.byte	'dynamic',0
	.word	7218
	.byte	4,2,35,0,7
	.byte	'counter',0
	.word	6862
	.byte	4,2,35,4,7
	.byte	'repeat',0
	.word	190
	.byte	1,2,35,8,7
	.byte	'config',0
	.word	221
	.byte	2,2,35,10,7
	.byte	'initial',0
	.word	190
	.byte	1,2,35,12,7
	.byte	'access',0
	.word	190
	.byte	1,2,35,13,7
	.byte	'application',0
	.word	190
	.byte	1,2,35,14,0,4
	.byte	'Os_ScheduleTableType',0,10,255,3,3
	.word	7223
	.byte	12
	.word	7223
	.byte	3
	.word	7403
	.byte	12
	.word	6700
	.byte	3
	.word	7413
	.byte	22
	.word	4516
	.byte	22
	.word	5466
	.byte	22
	.word	5363
	.byte	22
	.word	6024
	.byte	22
	.word	5530
	.byte	22
	.word	190
	.byte	22
	.word	6024
	.byte	17
	.byte	'Os_ControlledCoreType_s',0,10,251,6,16,112,7
	.byte	'TrapInfo',0
	.word	3947
	.byte	8,2,35,0,7
	.byte	'lock_taskaccess',0
	.word	7423
	.byte	4,2,35,8,7
	.byte	'ReadyTasks',0
	.word	7428
	.byte	4,2,35,12,7
	.byte	'RunningISR',0
	.word	7433
	.byte	4,2,35,16,7
	.byte	'RunningTask',0
	.word	7438
	.byte	4,2,35,20,7
	.byte	'RunningTPMask',0
	.word	7443
	.byte	4,2,35,24,7
	.byte	'CurrentMeteredObject',0
	.word	5049
	.byte	4,2,35,28,7
	.byte	'IdleMeter',0
	.word	4846
	.byte	48,2,35,32,7
	.byte	'AppAccess',0
	.word	190
	.byte	1,2,35,80,7
	.byte	'AppOverride',0
	.word	7448
	.byte	1,2,35,81,7
	.byte	'GetStackValueAdjust',0
	.word	4118
	.byte	8,2,35,84,7
	.byte	'InErrorHook',0
	.word	190
	.byte	1,2,35,92,7
	.byte	'ChainTaskRef',0
	.word	7453
	.byte	4,2,35,96,7
	.byte	'GetStackUsageAdjust',0
	.word	4118
	.byte	8,2,35,100,7
	.byte	'InProtectionHook',0
	.word	190
	.byte	1,2,35,108,7
	.byte	'CoreIsActive',0
	.word	190
	.byte	1,2,35,109,7
	.byte	'InShutdownHook',0
	.word	190
	.byte	1,2,35,110,0,4
	.byte	'Os_ControlledCoreType',0,10,141,7,3
	.word	7458
	.byte	3
	.word	258
	.byte	12
	.word	5194
	.byte	3
	.word	7914
	.byte	12
	.word	5764
	.byte	3
	.word	7924
	.byte	3
	.word	4846
	.byte	17
	.byte	'Os_AnyCoreType_s',0,10,151,7,16,96,7
	.byte	'DisableAllImask',0
	.word	258
	.byte	4,2,35,0,7
	.byte	'SuspendAllImask',0
	.word	258
	.byte	4,2,35,4,7
	.byte	'SuspendOSImask',0
	.word	258
	.byte	4,2,35,8,7
	.byte	'DisableAllCount',0
	.word	258
	.byte	4,2,35,12,7
	.byte	'SuspendAllCount',0
	.word	258
	.byte	4,2,35,16,7
	.byte	'SuspendOSCount',0
	.word	258
	.byte	4,2,35,20,7
	.byte	'RestartJumpBuf',0
	.word	4067
	.byte	68,2,35,24,7
	.byte	'Restartable',0
	.word	190
	.byte	1,2,35,92,0,4
	.byte	'Os_AnyCoreType',0,10,160,7,3
	.word	7939
	.byte	4
	.byte	'Can_TxObjPriorityClassType',0,11,219,3,16
	.word	258
	.byte	17
	.byte	'Can_TxHwObjectConfigType',0,11,231,3,16,8,7
	.byte	'MsgObjId',0
	.word	190
	.byte	1,2,35,0,7
	.byte	'HwControllerId',0
	.word	190
	.byte	1,2,35,1,7
	.byte	'TxObjPriorityClass',0
	.word	258
	.byte	4,2,35,4,0,4
	.byte	'Can_TxHwObjectConfigType',0,11,252,3,3
	.word	8216
	.byte	17
	.byte	'Can_RxHwObjectConfigType',0,11,129,4,16,12,7
	.byte	'MaskRef',0
	.word	258
	.byte	4,2,35,0,7
	.byte	'MsgId',0
	.word	258
	.byte	4,2,35,4,7
	.byte	'MsgObjId',0
	.word	190
	.byte	1,2,35,8,7
	.byte	'HwControllerId',0
	.word	190
	.byte	1,2,35,9,0,4
	.byte	'Can_RxHwObjectConfigType',0,11,147,4,3
	.word	8352
	.byte	10,4
	.word	190
	.byte	11,3,0,17
	.byte	'Can_ControllerMOMapConfigType',0,11,181,4,16,4,7
	.byte	'ControllerMOMap',0
	.word	8492
	.byte	4,2,35,0,0,4
	.byte	'Can_ControllerMOMapConfigType',0,11,184,4,3
	.word	8501
	.byte	17
	.byte	'Can_NPCRValueType',0,11,188,4,16,2,7
	.byte	'Can_NPCRValue',0
	.word	221
	.byte	2,2,35,0,0,4
	.byte	'Can_NPCRValueType',0,11,191,4,3
	.word	8602
	.byte	17
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,11,194,4,16,8,7
	.byte	'CanControllerBaudrate',0
	.word	258
	.byte	4,2,35,0,7
	.byte	'CanControllerBaudrateCfg',0
	.word	221
	.byte	2,2,35,4,0,4
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,11,198,4,3
	.word	8677
	.byte	12
	.word	8677
	.byte	3
	.word	8842
	.byte	17
	.byte	'Can_BaudrateConfigPtrType',0,11,201,4,16,4,7
	.byte	'Can_kBaudrateConfigPtr',0
	.word	8847
	.byte	4,2,35,0,0,4
	.byte	'Can_BaudrateConfigPtrType',0,11,204,4,3
	.word	8852
	.byte	17
	.byte	'Can_EventHandlingType',0,11,226,4,16,4,7
	.byte	'CanEventType',0
	.word	8492
	.byte	4,2,35,0,0,4
	.byte	'Can_EventHandlingType',0,11,229,4,3
	.word	8952
	.byte	4
	.byte	'Rte_TransformerErrorCode',0,12,130,1,15
	.word	190
	.byte	4
	.byte	'Rte_TransformerClass',0,12,131,1,15
	.word	190
	.byte	6,12,168,1,9,12,7
	.byte	'in',0
	.word	4792
	.byte	4,2,35,0,7
	.byte	'out',0
	.word	4792
	.byte	4,2,35,4,7
	.byte	'used',0
	.word	221
	.byte	2,2,35,8,7
	.byte	'lost_data',0
	.word	190
	.byte	1,2,35,10,0,4
	.byte	'Rte_QDynType',0,12,173,1,3
	.word	9098
	.byte	8,12,175,1,9,4,9
	.byte	'RTE_DRA',0,0,9
	.byte	'RTE_WOWP',0,1,9
	.byte	'RTE_TASK',0,2,9
	.byte	'RTE_ARE',0,3,9
	.byte	'RTE_EV',0,4,9
	.byte	'RTE_MSI',0,5,0,4
	.byte	'Rte_NotificationType',0,12,182,1,3
	.word	9185
	.byte	10,128,8
	.word	190
	.byte	11,255,7,0,4
	.byte	'Impl_NVM_DstPtrType_1024',0,13,50,15
	.word	9283
	.byte	4
	.byte	'CanIf_u32_impl',0,13,69,16
	.word	258
	.byte	4
	.byte	'CanIf_u16_impl',0,13,71,16
	.word	221
	.byte	4
	.byte	'CanIf_u8_impl',0,13,73,15
	.word	190
	.byte	4
	.byte	'CanIf_ControllerModeType_Enum_impl',0,13,88,15
	.word	190
	.byte	4
	.byte	'CanIf_PduModeType_Enum_impl',0,13,90,15
	.word	190
	.byte	6,13,92,9,2,7
	.byte	'DeviceMode',0
	.word	190
	.byte	1,2,35,0,7
	.byte	'ChannelMode',0
	.word	190
	.byte	1,2,35,1,0,4
	.byte	'CanIf_ControllerStateType_struct_impl',0,13,95,3
	.word	9474
	.byte	4
	.byte	'CanIf_NotifStatusType_Enum_impl',0,13,100,15
	.word	190
	.byte	4
	.byte	'CanSM_boolean_Impl',0,13,120,15
	.word	190
	.byte	4
	.byte	'CanSM_u8_Impl',0,13,123,15
	.word	190
	.byte	4
	.byte	'CanSM_BusOffRecoveryStateType_Enum_impl',0,13,128,1,15
	.word	190
	.byte	4
	.byte	'CanSM_NetworkModeStateType_Enum_impl',0,13,132,1,15
	.word	190
	.byte	4
	.byte	'CanSM_u16_Impl',0,13,136,1,16
	.word	221
	.byte	4
	.byte	'CanSM_TimerStateType_Enum_impl',0,13,138,1,15
	.word	190
	.byte	6,13,140,1,9,4,7
	.byte	'cntTick_u16',0
	.word	221
	.byte	2,2,35,0,7
	.byte	'stTimer',0
	.word	190
	.byte	1,2,35,2,0,4
	.byte	'CanSM_TimerConfig_tst_struct_impl',0,13,143,1,3
	.word	9815
	.byte	4
	.byte	'Com_impl_u16',0,13,154,1,16
	.word	221
	.byte	4
	.byte	'Com_impl_u8',0,13,157,1,15
	.word	190
	.byte	4
	.byte	'ComM_uint32_Impl',0,13,173,1,16
	.word	258
	.byte	4
	.byte	'ComM_uint16_Impl',0,13,175,1,16
	.word	221
	.byte	4
	.byte	'ComM_uint8_Impl',0,13,177,1,15
	.word	190
	.byte	4
	.byte	'ComM_bool_Impl',0,13,179,1,15
	.word	190
	.byte	6,13,181,1,9,24,7
	.byte	'ChannelState_e',0
	.word	258
	.byte	4,2,35,0,7
	.byte	'LightTimeoutCtr_u32',0
	.word	258
	.byte	4,2,35,4,7
	.byte	'MinFullComTimeoutCtr_u16',0
	.word	221
	.byte	2,2,35,8,7
	.byte	'ChannelMode_u8',0
	.word	190
	.byte	1,2,35,10,7
	.byte	'BusSmMode_u8',0
	.word	190
	.byte	1,2,35,11,7
	.byte	'UserRequestCtr_u8',0
	.word	190
	.byte	1,2,35,12,7
	.byte	'PassiveRequestState_u8',0
	.word	190
	.byte	1,2,35,13,7
	.byte	'PncRequestCtr_u8',0
	.word	190
	.byte	1,2,35,14,7
	.byte	'InhibitionReqStatus_u8',0
	.word	190
	.byte	1,2,35,15,7
	.byte	'NmNetworkRequestStatus_b',0
	.word	190
	.byte	1,2,35,16,7
	.byte	'DiagnosticRequestState_b',0
	.word	190
	.byte	1,2,35,17,7
	.byte	'CommunicationAllowed_b',0
	.word	190
	.byte	1,2,35,18,7
	.byte	'NmBusSleepIndicationStatus_b',0
	.word	190
	.byte	1,2,35,19,7
	.byte	'NmPrepareBusSleepIndicationStatus_b',0
	.word	190
	.byte	1,2,35,20,7
	.byte	'NmNetworkModeStatus_b',0
	.word	190
	.byte	1,2,35,21,0,4
	.byte	'ComM_ChannelStruct_Impl',0,13,197,1,3
	.word	10047
	.byte	6,13,206,1,9,10,7
	.byte	'WakeUpInhibitionCtr_u16',0
	.word	221
	.byte	2,2,35,0,7
	.byte	'LimitToNoComCtr_u16',0
	.word	221
	.byte	2,2,35,2,7
	.byte	'RequestedUserMode_t',0
	.word	190
	.byte	1,2,35,4,7
	.byte	'IndicatedUserMode_t',0
	.word	190
	.byte	1,2,35,5,7
	.byte	'numChannelsInFullCom_u8',0
	.word	190
	.byte	1,2,35,6,7
	.byte	'numChannelsInSilentCom_u8',0
	.word	190
	.byte	1,2,35,7,7
	.byte	'numChannelsInNoCom_u8',0
	.word	190
	.byte	1,2,35,8,0,4
	.byte	'ComM_UserStruct_Impl',0,13,214,1,3
	.word	10551
	.byte	4
	.byte	'Dcm_IOOperationResponseType',0,13,252,1,15
	.word	190
	.byte	4
	.byte	'Dcm_RequestDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspRequestRoutineResultsOutSignal_0PrimitivType',0
	.byte	13,138,2,15
	.word	190
	.byte	4
	.byte	'Dcm_StartDataIn_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineInSignalPrimitivType',0,13,146,2,15
	.word	190
	.byte	4
	.byte	'Dcm_StartDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineOutSignalPrimitivType',0,13,150,2,15
	.word	190
	.byte	4
	.byte	'Dcm_StopDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStopRoutineOutSignalPrimitivType',0,13,154,2,15
	.word	190
	.byte	4
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockNative_1024_Type',0,13,243,3,34
	.word	9294
	.byte	10,128,8
	.word	190
	.byte	11,255,7,0,4
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockRedundant_1024_Type',0,13,246,3,34
	.word	9294
	.byte	8,14,216,1,9,4,9
	.byte	'XCP_BG_IDLE',0,0,9
	.byte	'XCP_BG_CHKSUM',0,1,9
	.byte	'XCP_BG_MEM_WRITE',0,2,9
	.byte	'XCP_BG_REPEAT_CMD',0,3,9
	.byte	'XCP_BG_DO_DISCONNECT',0,4,9
	.byte	'XCP_BG_CANCEL_REQ',0,5,0,4
	.byte	'Xcp_BgActivity_t',0,14,224,1,3
	.word	11369
	.byte	15,1,1,14
	.word	2846
	.byte	14
	.word	190
	.byte	0,3
	.word	11514
	.byte	4
	.byte	'Xcp_CmdFunctionPtr',0,14,230,1,16
	.word	11528
	.byte	6,14,241,1,9,8,7
	.byte	'WritePos_u16',0
	.word	221
	.byte	2,2,35,0,7
	.byte	'ReadPos_u16',0
	.word	221
	.byte	2,2,35,2,7
	.byte	'ReadPos_OdtNum_u16',0
	.word	221
	.byte	2,2,35,4,7
	.byte	'QueSize_u16',0
	.word	221
	.byte	2,2,35,6,0,4
	.byte	'Xcp_Que_t',0,14,247,1,3
	.word	11561
	.byte	6,14,250,1,9,24,7
	.byte	'XcpState_en',0
	.word	656
	.byte	4,2,35,0,7
	.byte	'ConnectedTlId_u8',0
	.word	190
	.byte	1,2,35,4,7
	.byte	'ResourceProtStatus_u8',0
	.word	190
	.byte	1,2,35,5,7
	.byte	'Mta',0
	.word	821
	.byte	8,2,35,8,7
	.byte	'MaxDto_u16',0
	.word	221
	.byte	2,2,35,16,7
	.byte	'MaxDtoAligned_u16',0
	.word	221
	.byte	2,2,35,18,7
	.byte	'MaxCto_u8',0
	.word	190
	.byte	1,2,35,20,0,4
	.byte	'Xcp_Session_t',0,14,138,2,2
	.word	11679
	.byte	6,14,149,2,9,12,7
	.byte	'Buffer_au8',0
	.word	2715
	.byte	8,2,35,0,7
	.byte	'Length_u32',0
	.word	258
	.byte	4,2,35,8,0,4
	.byte	'Xcp_CtoMax_t',0,14,153,2,2
	.word	11866
	.byte	10,255,1
	.word	190
	.byte	11,254,1,0,6,14,157,2,9,132,2,7
	.byte	'UploadRunning_b',0
	.word	190
	.byte	1,2,35,0,7
	.byte	'RemainingSize_u8',0
	.word	190
	.byte	1,2,35,1,7
	.byte	'DownloadSize_u8',0
	.word	190
	.byte	1,2,35,2,7
	.byte	'ReceivedSize_u8',0
	.word	190
	.byte	1,2,35,3,7
	.byte	'DownloadBuffer_au8',0
	.word	11935
	.byte	255,1,2,35,4,0,4
	.byte	'Xcp_Mem_t',0,14,178,2,2
	.word	11946
	.byte	6,14,183,2,9,2,7
	.byte	'SeedWaitingKey_b',0
	.word	190
	.byte	1,2,35,0,7
	.byte	'SeedRemaingSize_u8',0
	.word	190
	.byte	1,2,35,1,0,4
	.byte	'Xcp_SeedAndKey_t',0,14,187,2,2
	.word	12103
	.byte	6,14,192,2,9,4,7
	.byte	'BlockSize_u32',0
	.word	258
	.byte	4,2,35,0,0,4
	.byte	'Xcp_Checksum_t',0,14,198,2,2
	.word	12190
	.byte	6,14,203,2,9,18,7
	.byte	'Xcp_Debug_TransmitOkCtr',0
	.word	221
	.byte	2,2,35,0,7
	.byte	'Xcp_Debug_TransmitNotOkCtr',0
	.word	221
	.byte	2,2,35,2,7
	.byte	'Xcp_Debug_SendResTxConfCtr',0
	.word	221
	.byte	2,2,35,4,7
	.byte	'Xcp_Debug_SendResCtr',0
	.word	221
	.byte	2,2,35,6,7
	.byte	'Xcp_Debug_SendEvTxConfCtr',0
	.word	221
	.byte	2,2,35,8,7
	.byte	'Xcp_Debug_SendEvCtr',0
	.word	221
	.byte	2,2,35,10,7
	.byte	'Xcp_Debug_SendDaqTxConfCtr',0
	.word	221
	.byte	2,2,35,12,7
	.byte	'Xcp_Debug_SendDaqCtr',0
	.word	221
	.byte	2,2,35,14,7
	.byte	'Xcp_Debug_TxConfCtr',0
	.word	221
	.byte	2,2,35,16,0,4
	.byte	'Xcp_Debug_t',0,14,216,2,2
	.word	12244
	.byte	6,14,225,2,9,8,7
	.byte	'OdtEntryPos_u16',0
	.word	221
	.byte	2,2,35,0,7
	.byte	'OdtEntryMax_u16',0
	.word	221
	.byte	2,2,35,2,7
	.byte	'DaqListNum_u16',0
	.word	221
	.byte	2,2,35,4,7
	.byte	'AbsOdtNum_u16',0
	.word	221
	.byte	2,2,35,6,0,4
	.byte	'Xcp_SelectedOdtEntry_t',0,14,231,2,2
	.word	12566
	.byte	6,14,234,2,9,6,7
	.byte	'OdtEntryFirst_u16',0
	.word	221
	.byte	2,2,35,0,7
	.byte	'OdtEntryCnt_u8',0
	.word	190
	.byte	1,2,35,2,7
	.byte	'CopyRoutine_u8',0
	.word	190
	.byte	1,2,35,3,7
	.byte	'Length_u16',0
	.word	221
	.byte	2,2,35,4,0,4
	.byte	'Xcp_Odt_t',0,14,240,2,2
	.word	12702
	.byte	22
	.word	190
	.byte	22
	.word	190
	.byte	6,14,254,2,9,24,7
	.byte	'DaqListQue_p',0
	.word	2791
	.byte	4,2,35,0,7
	.byte	'DaqListQuePos',0
	.word	11561
	.byte	8,2,35,4,7
	.byte	'OdtFirst_u16',0
	.word	221
	.byte	2,2,35,12,7
	.byte	'EventChannelNum_u16',0
	.word	221
	.byte	2,2,35,14,7
	.byte	'OdtCnt_u8',0
	.word	190
	.byte	1,2,35,16,7
	.byte	'XcpTxPduId',0
	.word	190
	.byte	1,2,35,17,7
	.byte	'Prescaler_u8',0
	.word	190
	.byte	1,2,35,18,7
	.byte	'CycleCnt_u8',0
	.word	190
	.byte	1,2,35,19,7
	.byte	'Priority_u8',0
	.word	190
	.byte	1,2,35,20,7
	.byte	'Flags_u8',0
	.word	190
	.byte	1,2,35,21,7
	.byte	'Mode_u8',0
	.word	12823
	.byte	1,2,35,22,7
	.byte	'CurrentlyRunning_b',0
	.word	12828
	.byte	1,2,35,23,0,4
	.byte	'Xcp_DaqList_t',0,14,143,3,2
	.word	12833
	.byte	3
	.word	12833
	.byte	3
	.word	12702
	.byte	3
	.word	258
	.byte	3
	.word	221
	.byte	6,14,146,3,9,56,7
	.byte	'DaqList_p',0
	.word	13125
	.byte	4,2,35,0,7
	.byte	'Odt_p',0
	.word	13130
	.byte	4,2,35,4,7
	.byte	'OdtEntryAddress_p',0
	.word	13135
	.byte	4,2,35,8,7
	.byte	'OdtEntrySize_p',0
	.word	2791
	.byte	4,2,35,12,7
	.byte	'PriorityList_p',0
	.word	13140
	.byte	4,2,35,16,7
	.byte	'DaqQue_p',0
	.word	2791
	.byte	4,2,35,20,7
	.byte	'DaqListCnt_u16',0
	.word	221
	.byte	2,2,35,24,7
	.byte	'OdtCnt_u16',0
	.word	221
	.byte	2,2,35,26,7
	.byte	'OdtEntryCnt_u16',0
	.word	221
	.byte	2,2,35,28,7
	.byte	'SelectedOdtEntry',0
	.word	12566
	.byte	8,2,35,30,7
	.byte	'DaqRamPtr_pu8',0
	.word	2791
	.byte	4,2,35,40,7
	.byte	'DaqRamSize_u32',0
	.word	258
	.byte	4,2,35,44,7
	.byte	'DaqListSendingCnt_u16',0
	.word	221
	.byte	2,2,35,48,7
	.byte	'DaqListSending_u16',0
	.word	221
	.byte	2,2,35,50,7
	.byte	'DaqState_en',0
	.word	1477
	.byte	4,2,35,52,0,4
	.byte	'Xcp_DaqConfig_t',0,14,180,3,2
	.word	13145
	.byte	0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L4:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,21,0,54,15,0,0,3,15,0,73,19,0,0,4,22,0,3,8,58,15,59,15
	.byte	57,15,73,19,0,0,5,36,0,3,8,11,15,62,15,0,0,6,19,1,58,15,59,15,57,15,11,15,0,0,7,13,0,3,8,73,19,11,15,56
	.byte	9,0,0,8,4,1,58,15,59,15,57,15,11,15,0,0,9,40,0,3,8,28,13,0,0,10,1,1,11,15,73,19,0,0,11,33,0,47,15,0,0
	.byte	12,38,0,73,19,0,0,13,21,1,73,19,54,15,39,12,0,0,14,5,0,73,19,0,0,15,21,1,54,15,39,12,0,0,16,21,0,54,15
	.byte	39,12,0,0,17,19,1,3,8,58,15,59,15,57,15,11,15,0,0,18,59,0,3,8,0,0,19,23,1,58,15,59,15,57,15,11,15,0,0
	.byte	20,4,1,3,8,58,15,59,15,57,15,11,15,0,0,21,21,0,73,19,54,15,39,12,0,0,22,53,0,73,19,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L5:
	.word	.L8-.L7
.L7:
	.half	3
	.word	.L10-.L9
.L9:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Xcp\\src\\Xcp_CmdSetRequest.c',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Platform\\Platform_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Std_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Xcp\\api\\Xcp_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Xcp\\Xcp_Cfg.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\rba_BswSrv.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Can_GeneralTypes.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\RTOS_T\\Gen\\inc\\Os.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Can_17_MCanP\\inc\\Can_17_MCanP.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Type.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Xcp\\api\\Xcp_Priv.h',0,0,0,0,0
.L10:
.L8:

; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	     1  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	     2  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	     3  /***************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	     4  * Includes
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	     5  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	     6  #include "Xcp.h"
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	     7  #include "Xcp_Priv.h"
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	     8  #if ((XCP_RESUME_MODE == STD_ON) && (XCP_SYNCHRONOUS_DATA_ACQUISITION_DAQ == STD_ON))
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	     9  #include "NvM.h"
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    10  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    11  /***************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    12  * Type definitions
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    13  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    14  /** XCP DAQ total counters and state for Resume Mode */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    15  /* MR12 RULE 5.6 VIOLATION: Type declaration is needed only for Xcp Resume Mode to simplify the copy procedure. */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    16  typedef struct
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    17  {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    18    uint16          DaqListCnt_u16;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    19    uint16          OdtCnt_u16;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    20    uint16          OdtEntryCnt_u16;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    21  # if (XCP_SYNCHRONOUS_DATA_STIMULATION_STIM == STD_ON)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    22    uint16          OdtStimCnt_u16;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    23  # endif
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    24    Xcp_DaqState_t  DaqState_en;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    25  } Xcp_DaqResumeData_t;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    26  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    27  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    28  /***************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    29  * Macros
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    30  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    31  #define XCP_BLOCK_INFO_INDEX 0u
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    32  #define XCP_BLOCK_DATA_INDEX 1u
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    33  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    34  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    35  /***************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    36  * Variables
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    37  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    38  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    39  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    40  /***************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    41  * Local function declarations
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    42  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    43  #define XCP_START_SEC_CODE
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    44  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    45  static void Xcp_EvResumeMode(uint8 protLayerId);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    46  static void Xcp_EvClearDaq(uint8 protLayerId);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    47  static void Xcp_EvStoreDaq(uint8 protLayerId);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    48  static Xcp_ErrorCode Xcp_PrepareNVMBlock(uint8 protLayerId);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    49  static void Xcp_RestoreDaqConfig(uint8 protLayerId);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    50  static void Xcp_ConnectTransportLayer(uint8 protLayerId, uint8 XcpTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    51  static void Xcp_DaqSetResumeMode(uint8 protLayerId);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    52  static Std_ReturnType Xcp_NvMReadBlock(uint8 BlockNo, void* AddrDataPtr);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    53  static void Xcp_EvStoreClearTrigger(void);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    54  #define XCP_STOP_SEC_CODE
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    55  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    56  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    57  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    58  /***************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    59  * Functions
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    60  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    61  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    62  #define XCP_START_SEC_CODE
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    63  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    64  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    65  /**
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    66  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    67  This service handles the entering RESUME mode or clearing the saved DAQ configuration
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    68  \param[in]  XcpPacket     Pointer to the received command packet
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    69  \param[in]  protLayerId   Protocol Layer Id
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    70  \return     -
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    71  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    72  void Xcp_CmdSetRequest(const PduInfoType* XcpPacket, uint8 protLayerId)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    73  {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    74    /*Start of run time measurement*/
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    75    XCP_RTM_TIMETRACK_START()
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    76  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    77    /* Command variables */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    78    /* MR12 RULE 11.5, 1.1 VIOLATION: This function is called with data (a PDU) from the CanIf/FrIf/EthIf which ensure 4-Byte-Alignment.
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    79                                      The cast allows easier (= safer) access to the data in the PDU.
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    80                                      Casting over void* is necessary as otherwise some compilers complain */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    81    const Xcp_CmdSetRequest_t* const CmdPtr = (const Xcp_CmdSetRequest_t*) (void*) XcpPacket->SduDataPtr;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    82  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    83    /* Local variables */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    84    Xcp_ErrorCode Error;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    85  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    86    /* Initialization */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    87    Error = XCP_NO_ERROR;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    88  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    89    /* If the SetRequest command is received for Protocol Layer 1 return ERR_GENERIC */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    90    /* because saving from PL 1 is not possible in NvM due to access to protected memory area */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    91    if (protLayerId >= 1u)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    92    {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    93      Error = XCP_ERR_GENERIC;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    94    }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    95    else if (Xcp_GlobalNoInit.SetRequestData.StorageMode != XCP_STORE_IDLE)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    96    {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    97      /* If any SET_REQUEST is in progress reject the new received request */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    98      Error = XCP_ERR_CMD_BUSY;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	    99    }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   100    else if (CmdPtr->Mode_u8 == XCP_SET_REQUEST_STORE_CAL_REQ)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   101    {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   102      /* STORE_CAL_REQ not supported now */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   103      Error = XCP_ERR_OUT_OF_RANGE;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   104    }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   105    else
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   106    {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   107      /* Branch for MISRA compliance */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   108    }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   109  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   110    if (Error == XCP_NO_ERROR)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   111    {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   112      if (CmdPtr->Mode_u8 == XCP_SET_REQUEST_STORE_DAQ_REQ_RESUME)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   113      {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   114        /* Set the session information to XCP_STORE_DAQ_REQ */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   115        XCP_RESUME_SESSION_STATUS(protLayerId) = XCP_STORE_DAQ_REQ;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   116        /* Store Session Configuration ID from the received command */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   117        Xcp_NoInit[protLayerId].Session.SessionConfId_u16 = CmdPtr->SessionConfigID_u16;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   118        /* Set requested storing mode to write so that the data is written to NvM */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   119        Xcp_GlobalNoInit.SetRequestData.StorageMode = XCP_STORE_MODE_WRITE;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   120        /* Check if any DAQ list is selected - only selected lists should be saved in NvM */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   121        Xcp_DaqSetResumeMode(protLayerId);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   122        /* Pack the data to be copied in the NvM blocks */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   123        Error = Xcp_PrepareNVMBlock(protLayerId);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   124  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   125        if (Error != XCP_NO_ERROR)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   126        {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   127          /* Reset the session information to XCP_STORE_DAQ_REQ */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   128          XCP_RESUME_SESSION_STATUS(protLayerId) &= (uint8)(~XCP_STORE_DAQ_REQ);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   129        }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   130      }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   131      else if (CmdPtr->Mode_u8 == XCP_SET_REQUEST_CLEAR_DAQ_REQ)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   132      {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   133        /* Set the session information to XCP_CLEAR_DAQ_REQ */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   134        XCP_RESUME_SESSION_STATUS(protLayerId) = XCP_CLEAR_DAQ_REQ;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   135        /* Clear the SessionConfId */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   136        Xcp_NoInit[protLayerId].Session.SessionConfId_u16 = 0;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   137        /* Set requested storing mode to clear so that the data is cleared from NvM */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   138        Xcp_GlobalNoInit.SetRequestData.StorageMode = XCP_STORE_MODE_CLEAR;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   139      }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   140      else
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   141      {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   142        /* The requested mode is not a valid mode */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   143        Error = XCP_ERR_OUT_OF_RANGE;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   144      }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   145    }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   146  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   147    if (Error == XCP_NO_ERROR)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   148    {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   149      /* Prepare and send positive response */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   150      Xcp_SendPosRes(protLayerId);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   151    }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   152    else
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   153    {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   154      /* Reset storage mode */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   155      Xcp_GlobalNoInit.SetRequestData.StorageMode = XCP_STORE_IDLE;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   156      /* Send negative response */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   157      Xcp_SendErrRes(Error, protLayerId);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   158    }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   159  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   160    /*End of run time measurement*/
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   161    XCP_RTM_TIMETRACK_FINISH()
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   162  }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   163  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   164  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   165  /**
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   166  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   167  This service activates the RESUME mode at init and sets DAQ list in mode RUNNING
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   168  \param[in]  -
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   169  \return     -
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   170  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   171  void Xcp_ResumeModeActivate(void)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   172  {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   173    /* local variables */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   174    uint8 protLayerId;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   175    uint8 transLayerId;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   176  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   177    /* Trigger read of the NVM block that contains the basic information: TransLayerId, ProtLayerId, DAQ configuration size, SessionConfigurationId */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   178    /* MR12 DIR 1.1 VIOLATION: The input parameters of Xcp_NvMReadBlock() are declared as (void*) so we have to cast. */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   179    if (Xcp_NvMReadBlock(XCP_BLOCK_INFO_INDEX, (void*)&Xcp_GlobalNoInit.SetRequestData.TLData_t) == E_OK)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   180    {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   181      /* Extract the transport layer id and check the validity */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   182      transLayerId = Xcp_GlobalNoInit.SetRequestData.TLData_t.ConnectedTlId_u8;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   183      if (transLayerId != 0xFF)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   184      {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   185        protLayerId = 0u;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   186        /* The connected Transport Layer Id must be set because is used in the RAM setting function to retrieve the RAM size for DAQ */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   187        Xcp_NoInit[protLayerId].Session.ConnectedTlId_u8 = transLayerId;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   188        /* Connect always with the first Protocol Layer after reset to avoid wrong memory access */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   189        (void)Xcp_DaqRamSetRam(protLayerId);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   190        /* Set back the connected TL to 0xFF because in case Resume Mode is not requested no connection should be done */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   191        Xcp_NoInit[protLayerId].Session.ConnectedTlId_u8 = 0xFF;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   192        /* Check if the DaqRamPtr was set by the Xcp_DaqRamSetRam */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   193        if (Xcp_NoInit[protLayerId].DaqConfig.DaqRamPtr_pu8 != NULL_PTR)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   194        {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   195          /* MR12 DIR 1.1 VIOLATION: The input parameters of Xcp_NvMReadBlock() are declared as (void*) so we have to cast. */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   196          if (Xcp_NvMReadBlock(XCP_BLOCK_DATA_INDEX, (void*)Xcp_NoInit[protLayerId].DaqConfig.DaqRamPtr_pu8) == E_OK)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   197          {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   198            /* If the read was successful restore DAQ configuration and set RESUME mode if required */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   199            Xcp_RestoreDaqConfig(protLayerId);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   200          }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   201        }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   202        else
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   203        {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   204          /* Read ended with error - call DET to signal that no DAQ configuration is restored because of pointer initialization issues */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   205          XCP_DET_REPORT_ERROR_NO_RET(XCP_INITIALIZE_SID, XCP_E_INV_POINTER);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   206        }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   207      }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   208      else
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   209      {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   210        /* Read ended with error - call DET to signal that no valid data was restored */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   211        XCP_DET_REPORT_ERROR_NO_RET(XCP_INITIALIZE_SID, XCP_E_INV_POINTER);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   212      }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   213    }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   214    else
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   215    {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   216      /* Read ended with error - nothing to be done */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   217      /* This can happen after a previous CLEAR_DAQ_REQ as well since this is invalidating the NvM block for a next read */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   218    }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   219  }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   220  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   221  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   222  /**
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   223  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   224  This service treats the resume mode store request - saving in NVM and must be called
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   225  from Xcp_MainFunction
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   226  \param[in]  -
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   227  \return     -
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   228  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   229  /* HIS METRIC v(G) VIOLATION IN Xcp_ResumeModeStorage: Function contains very simple "else if" statements and "switch-cases". HIS metric compliance would decrease readability and maintainability. */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   230  void Xcp_ResumeModeStorage(void)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   231  {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   232    /* local variables */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   233    Std_ReturnType NvM_GetErrorStatusResult;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   234    NvM_RequestResultType BlockStatus;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   235    Std_ReturnType ErrorState;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   236    uint8 protLayerId;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   237  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   238    /* Initialization */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   239    NvM_GetErrorStatusResult = E_NOT_OK;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   240    ErrorState = E_OK;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   241    protLayerId = 0u;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   242  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   243    /* State machine for the processing of a STORE or CLEAR in NvM */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   244    switch (Xcp_GlobalNoInit.SetRequestData.ReqProcessingState)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   245    {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   246      case XCP_NVM_NO_JOB:
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   247      {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   248        /* State machine for processing the requested mode in SET_REQUEST */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   249        switch (Xcp_GlobalNoInit.SetRequestData.StorageMode)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   250        {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   251          case XCP_STORE_MODE_WRITE:
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   252          {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   253            /* First NvM block is processed - erase first the TranspLayer information and DAQ size */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   254            ErrorState = NvM_EraseNvBlock(Xcp_PlCfgConst.NvMBlockInfo[XCP_BLOCK_INFO_INDEX].BlockId);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   255            /* Next state will be to write the NVM DATA block with DAQ configuration */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   256            Xcp_GlobalNoInit.SetRequestData.StorageMode = XCP_STORE_MODE_BLOCK_DATA_WRITE;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   257            /* Request received by NvM - set processing status to XCP_NVM_JOB_RUNNING */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   258            Xcp_GlobalNoInit.SetRequestData.ReqProcessingState = XCP_NVM_JOB_RUNNING;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   259          }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   260          break;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   261  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   262          case XCP_STORE_MODE_BLOCK_INFO_WRITE:
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   263          {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   264            /* Request the writing to NvM for the TransportLayer information and DAQ size block */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   265            /* MR12 DIR 1.1 VIOLATION: The input parameters of NvM_WriteBlock() are declared as (void*) so we have to cast. */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   266            ErrorState = NvM_WriteBlock(Xcp_PlCfgConst.NvMBlockInfo[XCP_BLOCK_INFO_INDEX].BlockId, (void*)&Xcp_GlobalNoInit.SetRequestData.TLData_t);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   267            /* Next state is set to XCP_STORE_MODE_WRITE to send the EV_STORE_DAQ */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   268            Xcp_GlobalNoInit.SetRequestData.StorageMode = XCP_STORE_MODE_WRITE;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   269            /* Request received by NvM - set processing status to XCP_NVM_JOB_RUNNING */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   270            Xcp_GlobalNoInit.SetRequestData.ReqProcessingState = XCP_NVM_JOB_RUNNING;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   271          }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   272          break;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   273  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   274          case XCP_STORE_MODE_BLOCK_DATA_WRITE:
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   275          {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   276            /* Request the writing to NvM for the DAQ configuration block */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   277            /* MR12 DIR 1.1 VIOLATION: The input parameters of NvM_WriteBlock() are declared as (void*) so we have to cast. */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   278            ErrorState = NvM_WriteBlock(Xcp_PlCfgConst.NvMBlockInfo[XCP_BLOCK_DATA_INDEX].BlockId, (void*)Xcp_NoInit[protLayerId].DaqConfig.DaqRamPtr_pu8);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   279            /* Next state will be writing the INFO block */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   280            Xcp_GlobalNoInit.SetRequestData.StorageMode = XCP_STORE_MODE_BLOCK_INFO_WRITE;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   281            /* Request received by NvM - set processing status to XCP_NVM_JOB_RUNNING */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   282            Xcp_GlobalNoInit.SetRequestData.ReqProcessingState = XCP_NVM_JOB_RUNNING;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   283          }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   284          break;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   285  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   286          case XCP_STORE_MODE_CLEAR:
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   287          {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   288            /* Request the erase of TransportLayer information and DAQ size block from NvM */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   289            ErrorState = NvM_EraseNvBlock(Xcp_PlCfgConst.NvMBlockInfo[XCP_BLOCK_INFO_INDEX].BlockId);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   290            /* Next state will trigger erase of the DAQ configuration block */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   291            Xcp_GlobalNoInit.SetRequestData.StorageMode = XCP_STORE_MODE_BLOCK_DATA_CLEAR;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   292            /* Request received by NvM - set processing status to XCP_NVM_JOB_RUNNING */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   293            Xcp_GlobalNoInit.SetRequestData.ReqProcessingState = XCP_NVM_JOB_RUNNING;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   294          }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   295          break;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   296  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   297          case XCP_STORE_MODE_BLOCK_DATA_CLEAR:
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   298          {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   299            /* Request the erase of DAQ configuration block from NvM */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   300            ErrorState = NvM_EraseNvBlock(Xcp_PlCfgConst.NvMBlockInfo[XCP_BLOCK_DATA_INDEX].BlockId);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   301            /* Next state is XCP_STORE_MODE_CLEAR to trigger the sending of EV_CLEAR_DAQ */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   302            Xcp_GlobalNoInit.SetRequestData.StorageMode = XCP_STORE_MODE_CLEAR;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   303            /* Request received by NvM - set processing status to XCP_NVM_JOB_RUNNING */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   304            Xcp_GlobalNoInit.SetRequestData.ReqProcessingState = XCP_NVM_JOB_RUNNING;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   305          }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   306          break;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   307  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   308          default:
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   309            /* The default is empty, as we are handling all elements of the enum in the cases of this switch, but we shall have a default-case */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   310          break;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   311        }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   312      }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   313      break;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   314  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   315      case XCP_NVM_JOB_RUNNING:
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   316      {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   317        if ((Xcp_GlobalNoInit.SetRequestData.StorageMode == XCP_STORE_MODE_WRITE)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   318           || (Xcp_GlobalNoInit.SetRequestData.StorageMode == XCP_STORE_MODE_BLOCK_DATA_WRITE)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   319           || (Xcp_GlobalNoInit.SetRequestData.StorageMode == XCP_STORE_MODE_BLOCK_DATA_CLEAR))
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   320        {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   321          /* Ask the status of the NvM operation for the INFO block */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   322          NvM_GetErrorStatusResult = NvM_GetErrorStatus(Xcp_PlCfgConst.NvMBlockInfo[XCP_BLOCK_INFO_INDEX].BlockId, &BlockStatus);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   323        }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   324        else
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   325        {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   326          /* Ask the status of the NvM operation for the DATA block */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   327          NvM_GetErrorStatusResult = NvM_GetErrorStatus(Xcp_PlCfgConst.NvMBlockInfo[XCP_BLOCK_DATA_INDEX].BlockId, &BlockStatus);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   328        }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   329  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   330        if (NvM_GetErrorStatusResult == E_OK)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   331        {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   332          if (BlockStatus == NVM_REQ_OK)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   333          {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   334            /* Set back the processing state to XCP_NVM_NO_JOB to start processing the next block if any available */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   335            Xcp_GlobalNoInit.SetRequestData.ReqProcessingState = XCP_NVM_NO_JOB;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   336            Xcp_EvStoreClearTrigger();
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   337          }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   338          else if (BlockStatus != NVM_REQ_PENDING)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   339          {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   340            /* Request is rejected by NvM - set error status */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   341            ErrorState = E_NOT_OK;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   342          }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   343          else
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   344          {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   345            /* Do nothing */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   346          }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   347        }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   348        else
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   349        {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   350          /* Request is rejected by NvM - set error status */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   351          ErrorState = E_NOT_OK;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   352        }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   353      }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   354      break;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   355  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   356      default:
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   357        /* The default is empty, as we are handling all elements of the enum in the cases of this switch, but we shall have a default-case */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   358      break;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   359    }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   360  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   361    /* Check if any of the requests returned error */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   362    if (ErrorState == E_NOT_OK)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   363    {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   364      /* In case the configuration could not be saved in NvM set the SessionConfId back to 0 to signal that no NvM data is available */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   365      Xcp_NoInit[protLayerId].Session.SessionConfId_u16 = 0;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   366      /* Set back also the session status bit to avoid wrong information as response from GET_STATUS */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   367      XCP_RESUME_SESSION_STATUS(protLayerId) &= ((uint8)(~XCP_STORE_DAQ_REQ) & (uint8)(~XCP_CLEAR_DAQ_REQ));
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   368      /* Set the request processing state to no request to be able to process a new request from Master */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   369      Xcp_GlobalNoInit.SetRequestData.ReqProcessingState = XCP_NVM_NO_JOB;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   370      /* If any of the block writing or clearing failed then stop further processing */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   371      Xcp_GlobalNoInit.SetRequestData.StorageMode = XCP_STORE_IDLE;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   372    }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   373  }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   374  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   375  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   376  /***************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   377  * Local functions
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   378  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   379  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   380  /**
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   381  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   382  This service copies the needed data for the RESUME mode
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   383  \param[in]  protLayerId   Protocol Layer Id
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   384  \retval     XCP_NO_ERROR              Prepare successful
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   385  \retval     XCP_ERR_DAQ_ACTIVE        daq running
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   386  \retval     XCP_ERR_MEMORY_OVERFLOW   no place to save DAQ config
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   387  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   388  static Xcp_ErrorCode Xcp_PrepareNVMBlock(uint8 protLayerId)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   389  {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   390    /* local variables */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   391    Xcp_ErrorCode Error;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   392  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   393    /* Initialization */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   394    Error = XCP_NO_ERROR;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   395  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   396    /* If DAQ runs when SET_REQUEST is received respond with error XCP_ERR_DAQ_ACTIVE */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   397    if (Xcp_NoInit[protLayerId].DaqConfig.DaqState_en == XCP_DAQ_STATE_RUNNING)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   398    {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   399      Error = XCP_ERR_DAQ_ACTIVE;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   400    }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   401    else
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   402    {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   403      /* local variables */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   404      uint32 BlockSize;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   405      uint32 WriteRamPos;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   406      uint32 MaxRamCopySize;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   407      Xcp_DaqResumeData_t* Xcp_DaqResumeData;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   408  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   409      /* MR12 RULE 11.4 VIOLATION: Cast from pointer to XCP_ADDR_TYPE is OK as this type is able to store the address (see type definition) */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   410      WriteRamPos = XCP_MACHINE_ALIGN((XCP_ADDR_TYPE) Xcp_NoInit[protLayerId].DaqConfig.PriorityList_p) - (XCP_ADDR_TYPE) Xcp_NoInit[protLayerId].DaqConfig.DaqRamPtr_pu8;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   411      /* Calculate needed block size for all DAQ configuration */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   412      BlockSize = WriteRamPos + sizeof(Xcp_DaqResumeData_t);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   413      /* Calculate the maximum position in the DAQ RAM pointer where the transport layer information can be saved */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   414      MaxRamCopySize = XCP_MIN(Xcp_NoInit[protLayerId].DaqConfig.DaqRamSize_u32, Xcp_PlCfgConst.NvMBlockInfo[XCP_BLOCK_DATA_INDEX].BlockLength);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   415  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   416      /* Check if enough space to copy in the NvM INFO block */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   417      if (sizeof(Xcp_SmallBlockData_t) <= Xcp_PlCfgConst.NvMBlockInfo[XCP_BLOCK_INFO_INDEX].BlockLength)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   418      {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   419        /* In the NvM INFO block the saved data is: Connected Transport Layer Id, Protocol Layer Id, DAQ configuration size and SessionConfigurationId */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   420        Xcp_GlobalNoInit.SetRequestData.TLData_t.ConnectedTlId_u8 = Xcp_NoInit[protLayerId].Session.ConnectedTlId_u8;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   421        Xcp_GlobalNoInit.SetRequestData.TLData_t.DaqConfigSize_u32 = WriteRamPos;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   422        Xcp_GlobalNoInit.SetRequestData.TLData_t.SessionConfId_u16 = Xcp_NoInit[protLayerId].Session.SessionConfId_u16;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   423        /* Call TransportLayer function to copy the data specific for this TranspLayer */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   424        Error = Xcp_PlCfgConst.TlCfg[XCP_ACTIVE_TL_ID(protLayerId)].TLResumeModeData_pfct(&Xcp_NoInit[protLayerId].DaqConfig.DaqRamPtr_pu8[BlockSize], &Xcp_NoInit[protLayerId].DaqConfig.DaqRamPtr_pu8[MaxRamCopySize], XCP_ACTIVE_TL_ID(protLayerId));
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   425  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   426        if (Error == XCP_NO_ERROR)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   427        {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   428          /* Check if it is enough space in NVM DATA block for the DAQ configuration */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   429          if ((BlockSize > 0u) && (BlockSize <= MaxRamCopySize))
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   430          {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   431            /* MR12 RULE 11.5, 1.1 VIOLATION: The pointer cast is required for copying the data from the Daq pointer to local structure */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   432            Xcp_DaqResumeData = (Xcp_DaqResumeData_t*)((void*)&Xcp_NoInit[protLayerId].DaqConfig.DaqRamPtr_pu8[WriteRamPos]);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   433            /* Copy at the end of DAQ configuration the overall information for the DAQ lists */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   434            Xcp_DaqResumeData->DaqListCnt_u16 = Xcp_NoInit[protLayerId].DaqConfig.DaqListCnt_u16;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   435            Xcp_DaqResumeData->OdtCnt_u16 = Xcp_NoInit[protLayerId].DaqConfig.OdtCnt_u16;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   436            Xcp_DaqResumeData->OdtEntryCnt_u16 = Xcp_NoInit[protLayerId].DaqConfig.OdtEntryCnt_u16;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   437          #if (XCP_SYNCHRONOUS_DATA_STIMULATION_STIM == STD_ON)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   438            Xcp_DaqResumeData->OdtStimCnt_u16 = Xcp_NoInit[protLayerId].DaqConfig.OdtStimCnt_u16;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   439          #endif
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   440            Xcp_DaqResumeData->DaqState_en = Xcp_NoInit[protLayerId].DaqConfig.DaqState_en;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   441          }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   442          else
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   443          {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   444            /* not enough space in NvM block */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   445            Error = XCP_ERR_MEMORY_OVERFLOW;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   446          }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   447        }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   448      }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   449      else
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   450      {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   451        /* not enough space in NvM block */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   452        Error = XCP_ERR_MEMORY_OVERFLOW;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   453      }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   454    }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   455  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   456    return Error;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   457  }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   458  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   459  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   460  /**
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   461  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   462  This service restores in DAQ config the NVM data, sends Ev_ResumeMode and sets RESUME DAQ lists to
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   463  running mode if requested mode is RESUME
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   464  \param[in]  protLayerId   Protocol Layer Id
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   465  \return     -
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   466  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   467  static void Xcp_RestoreDaqConfig(uint8 protLayerId)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   468  {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   469    /* local variables */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   470    uint16 daqListNo;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   471    uint32 DaqSize;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   472    boolean ResumeReq;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   473    Xcp_DaqResumeData_t* Xcp_DaqResumeData;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   474  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   475    /* Initialization */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   476    ResumeReq = FALSE;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   477  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   478    /* Restore the DAQ size */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   479    DaqSize = Xcp_GlobalNoInit.SetRequestData.TLData_t.DaqConfigSize_u32;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   480    /* MR12 RULE 11.5, 1.1 VIOLATION: The pointer cast is required for copying the data from local structure to Daq pointer */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   481    /* Copy back to DAQ config the saved configuration: number of DAQ list, ODTs, ODT entries and DAQ state */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   482    Xcp_DaqResumeData = (Xcp_DaqResumeData_t*)((void*)&Xcp_NoInit[protLayerId].DaqConfig.DaqRamPtr_pu8[DaqSize]);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   483    /* Check if the resume was requested and if read back data is valid before restoring it in the structures. */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   484    if (Xcp_DaqResumeData->DaqListCnt_u16 > 0u)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   485    {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   486      /* Restore Session Configuration Id */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   487      Xcp_NoInit[protLayerId].Session.SessionConfId_u16 = Xcp_GlobalNoInit.SetRequestData.TLData_t.SessionConfId_u16;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   488      /* Copy the DAQ info in case PL is valid and DAQ info read from NvM is not empty */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   489      Xcp_NoInit[protLayerId].DaqConfig.DaqListCnt_u16 = Xcp_DaqResumeData->DaqListCnt_u16;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   490      Xcp_NoInit[protLayerId].DaqConfig.OdtCnt_u16 = Xcp_DaqResumeData->OdtCnt_u16;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   491      Xcp_NoInit[protLayerId].DaqConfig.OdtEntryCnt_u16 = Xcp_DaqResumeData->OdtEntryCnt_u16;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   492  # if (XCP_SYNCHRONOUS_DATA_STIMULATION_STIM == STD_ON)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   493      Xcp_NoInit[protLayerId].DaqConfig.OdtStimCnt_u16 = Xcp_DaqResumeData->OdtStimCnt_u16;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   494  # endif
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   495      Xcp_NoInit[protLayerId].DaqConfig.DaqState_en = Xcp_DaqResumeData->DaqState_en;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   496      /* Check if any of the DAQ lists was marked for start in RESUME and set ResumeReq flag */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   497      for (daqListNo = 0; daqListNo < Xcp_NoInit[protLayerId].DaqConfig.DaqListCnt_u16; daqListNo++)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   498      {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   499        if ((XCP_DAQ_MODE(daqListNo, protLayerId) & XCP_DAQLISTMODE_RESUME) == XCP_DAQLISTMODE_RESUME )
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   500        {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   501          ResumeReq = TRUE;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   502          break; /* Break to exit the loop once a DAQ list with resume is found */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   503        }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   504      }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   505    }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   506    /* If any DAQ list was selected for resume mode send EV_RESUME_MODE, set session status to resume and DAQ running */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   507    if (ResumeReq == TRUE)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   508    {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   509      uint32 BlockSize;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   510  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   511      /* Call this function to set necessary transport layer parameters to the required protocol layer */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   512      Xcp_ConnectTransportLayer(protLayerId, Xcp_GlobalNoInit.SetRequestData.TLData_t.ConnectedTlId_u8);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   513      /* Calculate the position were Transport Layer data is saved */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   514      BlockSize = DaqSize + sizeof(Xcp_DaqResumeData_t);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   515      /* Call Transport Layer function to set back the communication parameters */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   516      (void)Xcp_PlCfgConst.TlCfg[XCP_ACTIVE_TL_ID(protLayerId)].TLResumeModeData_pfct(&Xcp_NoInit[protLayerId].DaqConfig.DaqRamPtr_pu8[BlockSize], NULL_PTR, XCP_ACTIVE_TL_ID(protLayerId));
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   517      /* Call Xcp_DaqRamCalc to calculate the needed memory for DAQ configuration and set the pointers to Daq, Odt, Odt entry information from DaqConfig */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   518      (void)Xcp_DaqRamCalc(0, 0, 0, protLayerId);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   519      /* Call Xcp_DaqQueRamCalc to calculate needed memory for DAQ queue and initialize corresponding pointers */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   520      (void)Xcp_DaqQueRamCalc(0, TRUE, protLayerId);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   521      /* Now EV_RESUME_MODE can be sent */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   522      Xcp_EvResumeMode(protLayerId);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   523  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   524      for (daqListNo = 0; daqListNo < Xcp_NoInit[protLayerId].DaqConfig.DaqListCnt_u16; daqListNo++)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   525      {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   526        if ((XCP_DAQ_MODE(daqListNo, protLayerId) & XCP_DAQLISTMODE_RESUME) == XCP_DAQLISTMODE_RESUME)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   527        {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   528          Xcp_DaqListStart(daqListNo, protLayerId);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   529        }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   530      }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   531      /* Recalculate PriorityList to prioritize the started DAQ lists for RESUME mode */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   532      Xcp_DaqCalculatePriorityList(protLayerId);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   533      /* Set RESUME mode flag - is returned in GET_STATUS response */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   534      XCP_RESUME_SESSION_STATUS(protLayerId) = XCP_RESUME;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   535      /* Set DAQ-state to running */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   536      Xcp_NoInit[protLayerId].DaqConfig.DaqState_en = XCP_DAQ_STATE_RUNNING;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   537      /* Set XCP in state RESUME */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   538      Xcp_NoInit[protLayerId].Session.XcpState_en = XCP_STATE_RESUME;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   539    }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   540  }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   541  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   542  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   543  /**
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   544  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   545  This service sends the event EV_RESUME_MODE
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   546  \param[in]  protLayerId   Protocol Layer Id
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   547  \return     -
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   548  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   549  static void Xcp_EvResumeMode(uint8 protLayerId)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   550  {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   551    /* local variables */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   552    Xcp_Cto8_t XcpEvPacket;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   553    Xcp_EvResumeMode_t* EvPtr;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   554  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   555    /* initialize event packet */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   556    XcpEvPacket.Length_u32 = XCP_EV_RESUME_MODE_LENGTH;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   557    /* MR12 RULE 11.5, 1.1 VIOLATION: Compiler ensures the correct alignment in the datastructure, thus casting is no problem.
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   558                                      The cast allows easier (= safer) access to the data in the PDU.
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   559                                      Casting over void* is necessary as otherwise some compilers complain */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   560    EvPtr = (Xcp_EvResumeMode_t*) (void*) XcpEvPacket.Buffer_au8;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   561  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   562    /* prepare Resume Mode event */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   563    EvPtr->PacketId_u8  = XCP_PACKET_ID_EV;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   564    EvPtr->EventCode_u8 = XCP_EV_RESUME_MODE;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   565    EvPtr->SessionConfigID_u16 = Xcp_NoInit[protLayerId].Session.SessionConfId_u16;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   566    /* Depending on the timestamp support send the calculated timestamp or 0 */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   567  # if (XCP_TIMESTAMP == STD_ON)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   568    EvPtr->Timestamp_u32 = XcpAppl_GetTimestamp();
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   569  # else
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   570    EvPtr->Timestamp_u32 = 0;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   571  # endif
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   572    /* send out event */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   573    Xcp_SendEv(&XcpEvPacket, protLayerId);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   574  }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   575  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   576  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   577  /**
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   578  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   579  This service sends the event EV_CLEAR_DAQ
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   580  \param[in]  protLayerId   Protocol Layer Id
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   581  \return     -
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   582  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   583  static void Xcp_EvClearDaq(uint8 protLayerId)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   584  {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   585    /* Clear the CLEAR_DAQ_REQ bit that is received by the GET_STATUS */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   586    XCP_RESUME_SESSION_STATUS(protLayerId) = XCP_RESUME_SESSION_STATUS(protLayerId) & (uint8)(~XCP_CLEAR_DAQ_REQ);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   587    /* send out XCP_EV_CLEAR_DAQ event */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   588    Xcp_SendEv_Code(XCP_EV_CLEAR_DAQ, protLayerId);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   589  }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   590  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   591  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   592  /**
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   593  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   594  This service sends the event EV_STORE_DAQ
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   595  \param[in]  protLayerId   Protocol Layer Id
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   596  \return     -
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   597  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   598  static void Xcp_EvStoreDaq(uint8 protLayerId)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   599  {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   600    /* Clear the STORE_DAQ_REQ bit that is received by the GET_STATUS */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   601    XCP_RESUME_SESSION_STATUS(protLayerId) = XCP_RESUME_SESSION_STATUS(protLayerId) & (uint8)(~XCP_STORE_DAQ_REQ);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   602    /* send out XCP_EV_STORE_DAQ event */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   603    Xcp_SendEv_Code(XCP_EV_STORE_DAQ, protLayerId);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   604  }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   605  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   606  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   607  /**
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   608  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   609  This service sets necessary information for the transport layer in the corresponding protocol layer
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   610  \param[in]  protLayerId           Protocol Layer Id
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   611  \param[in]  XcpTransportLayerId   Transport Layer Id
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   612  \return     -
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   613  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   614  static void Xcp_ConnectTransportLayer(uint8 protLayerId, uint8 XcpTransportLayerId)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   615  {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   616    /* save transport layer id in protocol layer */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   617    XCP_ACTIVE_TL_ID(protLayerId) = XcpTransportLayerId;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   618    /* save protocol layer id in lookup table */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   619    Xcp_GlobalNoInit.Tl2PlRef_au8[XcpTransportLayerId] = protLayerId;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   620    /* save TransportLayerId and transport layer specific parameters */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   621    Xcp_NoInit[protLayerId].Session.MaxCto_u8 = Xcp_PlCfgConst.TlCfg[XcpTransportLayerId].MaxCto_u8;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   622    Xcp_NoInit[protLayerId].Session.MaxDto_u16 = Xcp_PlCfgConst.TlCfg[XcpTransportLayerId].MaxDto_u16;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   623    Xcp_NoInit[protLayerId].Session.MaxDtoAligned_u16 = XCP_MACHINE_ALIGN(Xcp_NoInit[protLayerId].Session.MaxDto_u16);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   624  # if (XCP_IDFIELD_OTHER_THAN_ABSOLUTE == STD_ON)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   625    Xcp_NoInit[protLayerId].Session.IdFieldType_en = Xcp_PlCfgConst.TlCfg[XcpTransportLayerId].IdFieldType_en;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   626  # endif
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   627  }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   628  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   629  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   630  /**
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   631  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   632  This service sets DAQ list mode to Resume for selected DAQ lists
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   633  \param[in]  protLayerId   Protocol Layer Id
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   634  \return     -
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   635  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   636  static void Xcp_DaqSetResumeMode(uint8 protLayerId)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   637  {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   638    uint16 daqListNo;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   639  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   640    for (daqListNo = 0; daqListNo < Xcp_NoInit[protLayerId].DaqConfig.DaqListCnt_u16; daqListNo++)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   641    {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   642      /* Check if any DAQ list is selected */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   643      if ((XCP_DAQ_MODE(daqListNo, protLayerId) & XCP_DAQLISTMODE_SELECTED) == XCP_DAQLISTMODE_SELECTED)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   644      {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   645        /* Reset SELECTED flag and set RESUME flag for previously selected lists */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   646        XCP_DAQ_MODE(daqListNo, protLayerId) = (XCP_DAQ_MODE(daqListNo, protLayerId) & (uint8)(~XCP_DAQLISTMODE_SELECTED)) | XCP_DAQLISTMODE_RESUME;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   647      }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   648    }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   649  }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   650  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   651  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   652  /**
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   653  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   654  Read out the NvM-Block specified by BlockNo
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   655  \param[in]  BlockNo       NvM Block number in generated structure
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   656  \param[in]  AddrDataPtr   Pointer to location where the data shall be stored
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   657  \return     Read successful
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   658  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   659  static Std_ReturnType Xcp_NvMReadBlock(uint8 BlockNo, void* AddrDataPtr)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   660  {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   661    NvM_RequestResultType ReadResult;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   662    Std_ReturnType NvM_GetErrStatusResult;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   663    Std_ReturnType ReturnStatus;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   664  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   665    /* Call NvM_ReadBlock to read the TransportLayer, DAQ size or DAQ configuration */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   666    if (NvM_ReadBlock(Xcp_PlCfgConst.NvMBlockInfo[BlockNo].BlockId, AddrDataPtr) == E_OK)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   667    {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   668      do
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   669      {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   670        /* Call NvM_MainFunction and MemIf_Rb_MainFunction to process the request */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   671        NvM_MainFunction();
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   672        MemIf_Rb_MainFunction();
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   673        NvM_GetErrStatusResult = NvM_GetErrorStatus(Xcp_PlCfgConst.NvMBlockInfo[BlockNo].BlockId, &ReadResult);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   674      }while((NvM_GetErrStatusResult == E_OK) && (ReadResult == NVM_REQ_PENDING));
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   675      /* Check if the read from NvM was successfully done */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   676      if (ReadResult == NVM_REQ_OK)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   677      {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   678        ReturnStatus = E_OK;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   679      }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   680      else
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   681      {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   682        ReturnStatus = E_NOT_OK;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   683      }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   684    }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   685    else
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   686    {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   687      /* If the NvM_ReadBlock request was not accepted by NvM return E_NOT_OK */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   688      ReturnStatus = E_NOT_OK;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   689    }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   690  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   691    return ReturnStatus;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   692  }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   693  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   694  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   695  /**
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   696  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   697  This service triggers the sending of EV_STORE_DAQ or EV_CLEAR_DAQ
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   698  \param[in]  -
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   699  \return     -
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   700  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   701  static void Xcp_EvStoreClearTrigger(void)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   702  {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   703    uint8 protLayerId;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   704  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   705    protLayerId = 0u;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   706  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   707    if (Xcp_GlobalNoInit.SetRequestData.StorageMode == XCP_STORE_MODE_CLEAR)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   708    {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   709      /* Clearing of NvM DAQ configuration is finished - send the EV_CLEAR_DAQ */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   710      Xcp_EvClearDaq(protLayerId);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   711      /* Set the request processing state to XCP_STORE_IDLE to be able to process a new request */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   712      Xcp_GlobalNoInit.SetRequestData.StorageMode = XCP_STORE_IDLE;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   713    }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   714    else if (Xcp_GlobalNoInit.SetRequestData.StorageMode == XCP_STORE_MODE_WRITE)
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   715    {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   716      /* Storing of NvM DAQ configuration is finished - send the EV_STORE_DAQ */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   717      Xcp_EvStoreDaq(protLayerId);
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   718      /* Set the request processing state to XCP_STORE_IDLE to be able to process a new request */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   719      Xcp_GlobalNoInit.SetRequestData.StorageMode = XCP_STORE_IDLE;
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   720    }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   721    else
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   722    {
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   723      /* Nothing to do */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   724    }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   725  }
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   726  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   727  /* ------------------------------------------------------------------------ */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   728  /* End section for code */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   729  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   730  #define XCP_STOP_SEC_CODE
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   731  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   732  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   733  #else
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   734    /* HIS METRIC COMF VIOLATION IN Xcp_CmdSetRequest.c: The feature is not enabled - no code is needed in this file */
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   735  #endif
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   736  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   737  
; BSW\src\BSW\Gen\Xcp\src\Xcp_CmdSetRequest.c	   738  

	; Module end
