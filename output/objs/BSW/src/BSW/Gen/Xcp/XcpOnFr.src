	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 19053136 SN 09001910"
	.compiler_invocation	"ctc -f cc16428a -c99 --integer-enumeration -D__CPU__=tc27x -D__CPU_TC27X__ --core=tc1.6.x --eabi-compliant --fp-model=-float -D_TASKING_C_TRICORE_=1 -I.\\output\\inc -g2 -t4 --language=-comments,-gcc,+volatile,-strings --default-near-size=0 -O2ROPYGKLF-predict --default-a1-size=0 --default-a0-size=0 --source --switch=auto -o output\\objs\\BSW\\src\\BSW\\Gen\\Xcp\\XcpOnFr.src BSW\\src\\BSW\\Gen\\Xcp\\src\\XcpOnFr.c"
	.compiler_name		"ctc"
	;source	'BSW\\src\\BSW\\Gen\\Xcp\\src\\XcpOnFr.c'

	
$TC16X
	
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L3:
	.word	13513
	.half	3
	.word	.L4
	.byte	4
.L2:
	.byte	1
	.byte	'BSW\\src\\BSW\\Gen\\Xcp\\src\\XcpOnFr.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L5
	.byte	2,1,3
	.word	133
	.byte	4
	.byte	'__codeptr',0,1,1,1
	.word	135
	.byte	5
	.byte	'char',0,1,6,4
	.byte	'sint8',0,2,76,25
	.word	158
	.byte	5
	.byte	'unsigned char',0,1,8,4
	.byte	'uint8',0,2,81,25
	.word	180
	.byte	5
	.byte	'unsigned short int',0,2,7,4
	.byte	'uint16',0,2,91,25
	.word	211
	.byte	5
	.byte	'unsigned int',0,4,7,4
	.byte	'uint32',0,2,106,24
	.word	248
	.byte	5
	.byte	'unsigned long long int',0,8,7,4
	.byte	'uint64',0,2,111,30
	.word	279
	.byte	4
	.byte	'boolean',0,2,127,25
	.word	180
	.byte	4
	.byte	'StatusType',0,3,191,1,27
	.word	180
	.byte	4
	.byte	'Std_ReturnType',0,3,199,1,15
	.word	180
	.byte	6,3,206,1,9,8,7
	.byte	'vendorID',0
	.word	211
	.byte	2,2,35,0,7
	.byte	'moduleID',0
	.word	211
	.byte	2,2,35,2,7
	.byte	'sw_major_version',0
	.word	180
	.byte	1,2,35,4,7
	.byte	'sw_minor_version',0
	.word	180
	.byte	1,2,35,5,7
	.byte	'sw_patch_version',0
	.word	180
	.byte	1,2,35,6,0,4
	.byte	'Std_VersionInfoType',0,3,213,1,3
	.word	380
	.byte	4
	.byte	'PduIdType',0,4,22,19
	.word	211
	.byte	4
	.byte	'PduLengthType',0,4,26,19
	.word	211
	.byte	8,5,113,9,4,9
	.byte	'TP_DATACONF',0,0,9
	.byte	'TP_DATARETRY',0,1,9
	.byte	'TP_CONFPENDING',0,2,0,4
	.byte	'TpDataStateType',0,5,118,3
	.word	570
	.byte	8,6,225,1,9,4,9
	.byte	'XCP_STATE_DISCONNECTED',0,0,9
	.byte	'XCP_STATE_DISCONNECTING',0,1,9
	.byte	'XCP_STATE_CONNECTED',0,2,9
	.byte	'XCP_STATE_RESUME',0,3,9
	.byte	'XCP_STATE_DISABLED',0,240,1,0,4
	.byte	'Xcp_State_t',0,6,231,1,2
	.word	646
	.byte	4
	.byte	'Xcp_AddrValue',0,6,165,3,23
	.word	248
	.byte	6,6,168,3,9,8,7
	.byte	'AddrValue',0
	.word	248
	.byte	4,2,35,0,7
	.byte	'Extension',0
	.word	180
	.byte	1,2,35,4,0,4
	.byte	'Xcp_AddrType_t',0,6,172,3,3
	.word	811
	.byte	4
	.byte	'Xcp_PduIdType',0,6,174,3,15
	.word	180
	.byte	8,6,177,3,9,4,9
	.byte	'XCP_ERR_CMD_SYNCH',0,0,9
	.byte	'XCP_ERR_CMD_BUSY',0,16,9
	.byte	'XCP_ERR_DAQ_ACTIVE',0,17,9
	.byte	'XCP_ERR_PGM_ACTIVE',0,18,9
	.byte	'XCP_ERR_CMD_UNKNOWN',0,32,9
	.byte	'XCP_ERR_CMD_SYNTAX',0,33,9
	.byte	'XCP_ERR_OUT_OF_RANGE',0,34,9
	.byte	'XCP_ERR_WRITE_PROTECTED',0,35,9
	.byte	'XCP_ERR_ACCESS_DENIED',0,36,9
	.byte	'XCP_ERR_ACCESS_LOCKED',0,37,9
	.byte	'XCP_ERR_PAGE_NOT_VALID',0,38,9
	.byte	'XCP_ERR_MODE_NOT_VALID',0,39,9
	.byte	'XCP_ERR_SEGMENT_NOT_VALID',0,40,9
	.byte	'XCP_ERR_SEQUENCE',0,41,9
	.byte	'XCP_ERR_DAQ_CONFIG',0,42,9
	.byte	'XCP_ERR_MEMORY_OVERFLOW',0,48,9
	.byte	'XCP_ERR_GENERIC',0,49,9
	.byte	'XCP_ERR_VERIFY',0,50,9
	.byte	'XCP_ERR_RES_TEMP_NOT_ACCESS',0,51,9
	.byte	'XCP_ERR_SUBCMD_UNKNOWN',0,52,9
	.byte	'XCP_REPEAT_COMMAND',0,252,1,9
	.byte	'XCP_NO_ACCESS_HIDE',0,253,1,9
	.byte	'XCP_NO_RESPONSE',0,254,1,9
	.byte	'XCP_NO_ERROR',0,255,1,0,4
	.byte	'Xcp_ErrorCode',0,6,204,3,2
	.word	903
	.byte	8,6,207,3,9,4,9
	.byte	'XCP_DAQ_STATE_NO_DAQ',0,0,9
	.byte	'XCP_DAQ_STATE_FREE_DAQ',0,1,9
	.byte	'XCP_DAQ_STATE_ALLOC_DAQ',0,2,9
	.byte	'XCP_DAQ_STATE_ALLOC_ODT',0,3,9
	.byte	'XCP_DAQ_STATE_ALLOC_ODT_ENTRY',0,4,9
	.byte	'XCP_DAQ_STATE_WRITE_DAQ',0,5,9
	.byte	'XCP_DAQ_STATE_PREPARE_START',0,6,9
	.byte	'XCP_DAQ_STATE_SHIFTING',0,7,9
	.byte	'XCP_DAQ_STATE_STOP_REQUESTED',0,8,9
	.byte	'XCP_DAQ_STATE_READY_TO_RUN',0,9,9
	.byte	'XCP_DAQ_STATE_RUNNING',0,10,0,4
	.byte	'Xcp_DaqState_t',0,6,220,3,2
	.word	1467
	.byte	8,6,223,3,9,4,9
	.byte	'XCP_DAQ_NO_OVERLOAD_INDICATION',0,0,9
	.byte	'XCP_DAQ_OVERLOAD_INDICATION_PID',0,1,9
	.byte	'XCP_DAQ_OVERLOAD_INDICATION_EVENT',0,2,0,4
	.byte	'Xcp_Overload_t',0,6,228,3,2
	.word	1795
	.byte	8,6,233,3,9,4,9
	.byte	'XCP_IDENTIFICATION_FIELD_TYPE_ABSOLUTE',0,1,9
	.byte	'XCP_IDENTIFICATION_FIELD_TYPE_RELATIVE_BYTE',0,2,9
	.byte	'XCP_IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD',0,3,9
	.byte	'XCP_IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD_ALIGNED',0,4,0,4
	.byte	'Xcp_IdField_t',0,6,239,3,2
	.word	1929
	.byte	8,6,242,3,9,4,9
	.byte	'XCP_ODT_OPTIMIZATION_OM_DEFAULT',0,0,9
	.byte	'XCP_ODT_OPTIMIZATION_OM_ODT_TYPE_16',0,1,9
	.byte	'XCP_ODT_OPTIMIZATION_OM_ODT_TYPE_32',0,2,9
	.byte	'XCP_ODT_OPTIMIZATION_OM_ODT_TYPE_64',0,3,9
	.byte	'XCP_ODT_OPTIMIZATION_OM_ODT_TYPE_ALIGNMENT',0,4,9
	.byte	'XCP_ODT_OPTIMIZATION_OM_MAX_ENTRY_SIZE',0,5,0,4
	.byte	'Xcp_OdtOptimizationType_t',0,6,250,3,2
	.word	2146
	.byte	8,6,253,3,9,4,9
	.byte	'XCP_CONSISTENCY_ODT',0,0,9
	.byte	'XCP_CONSISTENCY_DAQ',0,1,9
	.byte	'XCP_CONSISTENCY_EVENT',0,2,9
	.byte	'XCP_CONSISTENCY_NONE',0,3,0,4
	.byte	'Xcp_Consistency_t',0,6,131,4,2
	.word	2422
	.byte	8,6,134,4,9,4,9
	.byte	'XCP_TIMESTAMP_TYPE_NO_TIME_STAMP',0,0,9
	.byte	'XCP_TIMESTAMP_TYPE_ONE_BYTE',0,1,9
	.byte	'XCP_TIMESTAMP_TYPE_TWO_BYTE',0,2,9
	.byte	'XCP_TIMESTAMP_TYPE_FOUR_BYTE',0,4,0,4
	.byte	'Xcp_Timestamp_t',0,6,140,4,2
	.word	2547
	.byte	10,8
	.word	180
	.byte	11,7,0,6,6,174,4,9,12,7
	.byte	'Buffer_au8',0
	.word	2705
	.byte	8,2,35,0,7
	.byte	'Length_u32',0
	.word	248
	.byte	4,2,35,8,0,4
	.byte	'Xcp_Cto8_t',0,6,178,4,2
	.word	2714
	.byte	3
	.word	180
	.byte	6,5,71,9,8,7
	.byte	'SduDataPtr',0
	.word	2781
	.byte	4,2,35,0,7
	.byte	'SduLength',0
	.word	211
	.byte	2,2,35,4,0,12
	.word	2786
	.byte	3
	.word	2831
	.byte	13
	.word	180
	.byte	1,1,14
	.word	2836
	.byte	14
	.word	180
	.byte	14
	.word	180
	.byte	0,3
	.word	2841
	.byte	15,1,1,14
	.word	180
	.byte	14
	.word	180
	.byte	0,3
	.word	2869
	.byte	15,1,1,14
	.word	180
	.byte	0,3
	.word	2888
	.byte	13
	.word	180
	.byte	1,1,14
	.word	180
	.byte	0,3
	.word	2902
	.byte	3
	.word	2786
	.byte	15,1,1,14
	.word	2836
	.byte	14
	.word	2920
	.byte	14
	.word	180
	.byte	0,3
	.word	2925
	.byte	13
	.word	180
	.byte	1,1,14
	.word	180
	.byte	14
	.word	211
	.byte	14
	.word	180
	.byte	0,3
	.word	2949
	.byte	6,7,164,1,9,56,7
	.byte	'TLTransmit_pfct',0
	.word	2864
	.byte	4,2,35,0,7
	.byte	'TLInit_pfct',0
	.word	2883
	.byte	4,2,35,4,7
	.byte	'TLConnect_pfct',0
	.word	2897
	.byte	4,2,35,8,7
	.byte	'TLDisconnect_pfct',0
	.word	2915
	.byte	4,2,35,12,7
	.byte	'TLTransportLayerCmd_pfct',0
	.word	2944
	.byte	4,2,35,16,7
	.byte	'TLGetTxPduId_pfct',0
	.word	2972
	.byte	4,2,35,20,7
	.byte	'MaxCto_u8',0
	.word	180
	.byte	1,2,35,24,7
	.byte	'MaxDto_u16',0
	.word	211
	.byte	2,2,35,26,7
	.byte	'TimestampType_en',0
	.word	2547
	.byte	4,2,35,28,7
	.byte	'IdFieldType_en',0
	.word	1929
	.byte	4,2,35,32,7
	.byte	'OverloadType_en',0
	.word	1795
	.byte	4,2,35,36,7
	.byte	'OdtOptimizationType_en',0
	.word	2146
	.byte	4,2,35,40,7
	.byte	'Consistency_en',0
	.word	2422
	.byte	4,2,35,44,7
	.byte	'PdRam_u32',0
	.word	248
	.byte	4,2,35,48,7
	.byte	'EdRam_u32',0
	.word	248
	.byte	4,2,35,52,0,4
	.byte	'Xcp_PL_TL_Cfg_t',0,7,184,1,2
	.word	2977
	.byte	8,7,188,1,9,4,9
	.byte	'XCP_RAMSECTION_INVALID',0,0,9
	.byte	'XCP_RAMSECTION_PD',0,1,9
	.byte	'XCP_RAMSECTION_ED',0,2,0,4
	.byte	'Xcp_RamSectionType_t',0,7,193,1,2
	.word	3375
	.byte	6,7,195,1,9,12,7
	.byte	'DaqRamPtr_pu8',0
	.word	2781
	.byte	4,2,35,0,7
	.byte	'DaqRamTotalSize_u32',0
	.word	248
	.byte	4,2,35,4,7
	.byte	'RamSectionType_en',0
	.word	3375
	.byte	4,2,35,8,0,4
	.byte	'Xcp_DaqRamSection_Cfg_t',0,7,200,1,2
	.word	3477
	.byte	10,1
	.word	180
	.byte	11,0,0,6,7,203,1,9,8,7
	.byte	'DaqRamFreeSize_u32',0
	.word	248
	.byte	4,2,35,0,7
	.byte	'PLConnected_ab',0
	.word	3596
	.byte	1,2,35,4,0,4
	.byte	'Xcp_DaqRamSections_t',0,7,207,1,2
	.word	3605
	.byte	6,7,230,1,9,4,7
	.byte	'EventChannelDirection_u8',0
	.word	180
	.byte	1,2,35,0,7
	.byte	'EventChannelTimeCycle_u8',0
	.word	180
	.byte	1,2,35,1,7
	.byte	'EventChannelTimeUnit_u8',0
	.word	180
	.byte	1,2,35,2,7
	.byte	'EventChannelPriority_u8',0
	.word	180
	.byte	1,2,35,3,0,4
	.byte	'Xcp_EventChannel_Cfg_t',0,7,236,1,2
	.word	3694
	.byte	4
	.byte	'rba_BswSrv_uint64',0,8,66,28
	.word	279
	.byte	4
	.byte	'Can_IdType',0,9,32,16
	.word	248
	.byte	4
	.byte	'Can_HwHandleType',0,9,43,16
	.word	211
	.byte	6,10,93,9,8,7
	.byte	'Class',0
	.word	180
	.byte	1,2,35,0,7
	.byte	'TIN',0
	.word	180
	.byte	1,2,35,1,7
	.byte	'ReturnAddress',0
	.word	248
	.byte	4,2,35,4,0,4
	.byte	'OsTrapInfoType',0,10,97,3
	.word	3937
	.byte	10,68
	.word	248
	.byte	11,16,0,6,10,154,1,9,68,7
	.byte	'store',0
	.word	4017
	.byte	68,2,35,0,0,10,68
	.word	4026
	.byte	11,0,0,4
	.byte	'Os_JumpBufType',0,10,156,1,3
	.word	4048
	.byte	4
	.byte	'Os_StackTraceType',0,10,174,1,18
	.word	248
	.byte	6,10,175,1,9,8,7
	.byte	'sp',0
	.word	248
	.byte	4,2,35,0,7
	.byte	'ctx',0
	.word	248
	.byte	4,2,35,4,0,4
	.byte	'Os_StackValueType',0,10,175,1,63
	.word	4108
	.byte	4
	.byte	'Os_StackSizeType',0,10,176,1,27
	.word	4108
	.byte	16,1,1,3
	.word	4193
	.byte	4
	.byte	'Os_VoidVoidFunctionType',0,10,179,1,16
	.word	4196
	.byte	4
	.byte	'ApplicationType',0,10,193,1,23
	.word	180
	.byte	17
	.byte	'Os_ApplicationConfigurationType_s',0,10,198,1,16,2,7
	.byte	'app_id',0
	.word	180
	.byte	1,2,35,0,7
	.byte	'access',0
	.word	180
	.byte	1,2,35,1,0,4
	.byte	'Os_ApplicationConfigurationType',0,10,201,1,3
	.word	4259
	.byte	4
	.byte	'Os_CoreStateType',0,10,203,1,16
	.word	248
	.byte	4
	.byte	'AreaIdType',0,10,204,1,16
	.word	211
	.byte	4
	.byte	'Os_PeripheralAddressType',0,10,212,1,22
	.word	248
	.byte	4
	.byte	'TickType',0,10,221,1,22
	.word	248
	.byte	4
	.byte	'Os_StopwatchTickType',0,10,225,1,22
	.word	248
	.byte	3
	.word	248
	.byte	4
	.byte	'Os_Lockable',0,10,234,1,18
	.word	4501
	.byte	4
	.byte	'CoreIdType',0,10,236,1,16
	.word	211
	.byte	4
	.byte	'SpinlockIdType',0,10,237,1,16
	.word	211
	.byte	8,10,239,1,9,4,9
	.byte	'TRYTOGETSPINLOCK_SUCCESS',0,0,9
	.byte	'TRYTOGETSPINLOCK_NOSUCCESS',0,1,0,4
	.byte	'TryToGetSpinlockType',0,10,239,1,74
	.word	4571
	.byte	8,10,174,2,9,4,9
	.byte	'APPLICATION_ACCESSIBLE',0,0,9
	.byte	'APPLICATION_RESTARTING',0,1,9
	.byte	'APPLICATION_TERMINATED',0,2,0,4
	.byte	'ApplicationStateType',0,10,174,2,92
	.word	4664
	.byte	18
	.byte	'void',0,3
	.word	4776
	.byte	15,1,1,14
	.word	180
	.byte	14
	.word	4782
	.byte	0,3
	.word	4787
	.byte	4
	.byte	'Os_FunctionEntryType',0,10,183,2,16
	.word	4801
	.byte	17
	.byte	'Os_MeterInfoType_s',0,10,193,2,16,48,7
	.byte	'elapsed',0
	.word	248
	.byte	4,2,35,0,7
	.byte	'previous',0
	.word	248
	.byte	4,2,35,4,7
	.byte	'max',0
	.word	248
	.byte	4,2,35,8,7
	.byte	'cumulative',0
	.word	248
	.byte	4,2,35,12,7
	.byte	'stackbase',0
	.word	4108
	.byte	8,2,35,16,7
	.byte	'stackusage',0
	.word	4108
	.byte	8,2,35,24,7
	.byte	'stackmax',0
	.word	4108
	.byte	8,2,35,32,7
	.byte	'stackbudget',0
	.word	4108
	.byte	8,2,35,40,0,4
	.byte	'Os_MeterInfoType',0,10,202,2,3
	.word	4836
	.byte	3
	.word	4836
	.byte	4
	.byte	'Os_MeterInfoRefType',0,10,203,2,50
	.word	5034
	.byte	4
	.byte	'EventMaskType',0,10,206,2,15
	.word	180
	.byte	4
	.byte	'Os_imaskType',0,10,211,2,16
	.word	248
	.byte	17
	.byte	'Os_ISRDynType_s',0,10,213,2,16,48,7
	.byte	'meter',0
	.word	4836
	.byte	48,2,35,0,0,4
	.byte	'Os_ISRDynType',0,10,215,2,3
	.word	5113
	.byte	3
	.word	5113
	.byte	12
	.word	5174
	.byte	17
	.byte	'Os_ISRType_s',0,10,216,2,16,24,7
	.byte	'entry_function',0
	.word	4201
	.byte	4,2,35,0,7
	.byte	'dynamic',0
	.word	5179
	.byte	4,2,35,4,7
	.byte	'imask',0
	.word	248
	.byte	4,2,35,8,7
	.byte	'stackbudget',0
	.word	4108
	.byte	8,2,35,12,7
	.byte	'access',0
	.word	180
	.byte	1,2,35,20,7
	.byte	'application',0
	.word	180
	.byte	1,2,35,21,0,4
	.byte	'Os_ISRType',0,10,223,2,3
	.word	5184
	.byte	3
	.word	4193
	.byte	12
	.word	5184
	.byte	3
	.word	5343
	.byte	4
	.byte	'ISRType',0,10,224,2,46
	.word	5348
	.byte	4
	.byte	'Os_bitmask',0,10,239,2,22
	.word	248
	.byte	4
	.byte	'Os_pset0Type',0,10,240,2,20
	.word	248
	.byte	4
	.byte	'Os_pset1Type',0,10,241,2,20
	.word	248
	.byte	4
	.byte	'Os_pset2Type',0,10,242,2,20
	.word	248
	.byte	19,10,243,2,9,4,7
	.byte	'p0',0
	.word	248
	.byte	4,2,35,0,7
	.byte	'p1',0
	.word	248
	.byte	4,2,35,0,7
	.byte	'p2',0
	.word	248
	.byte	4,2,35,0,0,4
	.byte	'Os_psetType',0,10,247,2,3
	.word	5456
	.byte	19,10,249,2,9,4,7
	.byte	't0',0
	.word	248
	.byte	4,2,35,0,7
	.byte	't1',0
	.word	248
	.byte	4,2,35,0,7
	.byte	't2',0
	.word	248
	.byte	4,2,35,0,0,4
	.byte	'Os_tpmaskType',0,10,253,2,3
	.word	5520
	.byte	4
	.byte	'Os_ActivationCountType',0,10,254,2,23
	.word	180
	.byte	17
	.byte	'Os_TaskDynType_s',0,10,128,3,16,120,7
	.byte	'terminate_jump_buf',0
	.word	4057
	.byte	68,2,35,0,7
	.byte	'meter',0
	.word	4836
	.byte	48,2,35,68,7
	.byte	'activation_count',0
	.word	180
	.byte	1,2,35,116,0,4
	.byte	'Os_TaskDynType',0,10,132,3,3
	.word	5618
	.byte	10,68
	.word	4026
	.byte	11,0,0,3
	.word	5618
	.byte	12
	.word	5744
	.byte	17
	.byte	'Os_TaskType_s',0,10,134,3,16,40,7
	.byte	'dynamic',0
	.word	5749
	.byte	4,2,35,0,7
	.byte	'entry_function',0
	.word	4201
	.byte	4,2,35,4,7
	.byte	'pset',0
	.word	5456
	.byte	4,2,35,8,7
	.byte	'base_tpmask',0
	.word	5520
	.byte	4,2,35,12,7
	.byte	'tpmask',0
	.word	5520
	.byte	4,2,35,16,7
	.byte	'core_id',0
	.word	211
	.byte	2,2,35,20,7
	.byte	'index',0
	.word	248
	.byte	4,2,35,24,7
	.byte	'stackbudget',0
	.word	4108
	.byte	8,2,35,28,7
	.byte	'activation_count',0
	.word	180
	.byte	1,2,35,36,7
	.byte	'access',0
	.word	180
	.byte	1,2,35,37,7
	.byte	'application',0
	.word	180
	.byte	1,2,35,38,0,4
	.byte	'Os_TaskType',0,10,146,3,3
	.word	5754
	.byte	12
	.word	5754
	.byte	3
	.word	6004
	.byte	4
	.byte	'TaskType',0,10,147,3,47
	.word	6009
	.byte	20
	.byte	'Os_TaskStateType',0,10,155,3,6,4,9
	.byte	'SUSPENDED',0,0,9
	.byte	'READY',0,1,9
	.byte	'WAITING',0,2,9
	.byte	'RUNNING',0,3,0,4
	.byte	'TaskStateType',0,10,156,3,31
	.word	6032
	.byte	19,10,167,3,3,4,7
	.byte	'tpmask',0
	.word	5520
	.byte	4,2,35,0,0,17
	.byte	'Os_ResourceDynType_s',0,10,166,3,16,4,7
	.byte	'saved_priority',0
	.word	6119
	.byte	4,2,35,0,0,4
	.byte	'Os_ResourceDynType',0,10,170,3,3
	.word	6142
	.byte	3
	.word	6142
	.byte	12
	.word	6222
	.byte	17
	.byte	'Os_ResourceType_s',0,10,171,3,16,12,7
	.byte	'dynamic',0
	.word	6227
	.byte	4,2,35,0,7
	.byte	'tpmask',0
	.word	5520
	.byte	4,2,35,4,7
	.byte	'access',0
	.word	180
	.byte	1,2,35,8,0,4
	.byte	'Os_ResourceType',0,10,175,3,3
	.word	6232
	.byte	6,10,181,3,9,12,7
	.byte	'maxallowedvalue',0
	.word	248
	.byte	4,2,35,0,7
	.byte	'ticksperbase',0
	.word	248
	.byte	4,2,35,4,7
	.byte	'mincycle',0
	.word	248
	.byte	4,2,35,8,0,4
	.byte	'AlarmBaseType',0,10,185,3,3
	.word	6331
	.byte	6,10,206,3,9,8,7
	.byte	'Running',0
	.word	180
	.byte	1,2,35,0,7
	.byte	'Pending',0
	.word	180
	.byte	1,2,35,1,7
	.byte	'Delay',0
	.word	248
	.byte	4,2,35,4,0,4
	.byte	'Os_CounterStatusType',0,10,210,3,3
	.word	6426
	.byte	21
	.word	180
	.byte	1,1,3
	.word	6512
	.byte	4
	.byte	'Os_CounterIncrAdvType',0,10,217,3,22
	.word	6519
	.byte	17
	.byte	's_swd',0,10,222,3,12,4,7
	.byte	'count',0
	.word	248
	.byte	4,2,35,0,0,19,10,221,3,3,4,7
	.byte	'sw',0
	.word	6555
	.byte	4,2,35,0,0,17
	.byte	'Os_CounterDynType_s',0,10,220,3,16,4,7
	.byte	'type_dependent',0
	.word	6583
	.byte	4,2,35,0,0,4
	.byte	'Os_CounterDynType',0,10,226,3,3
	.word	6602
	.byte	3
	.word	6602
	.byte	12
	.word	6680
	.byte	17
	.byte	'Os_CounterType_s',0,10,227,3,16,28,7
	.byte	'dynamic',0
	.word	6685
	.byte	4,2,35,0,7
	.byte	'advincr',0
	.word	6524
	.byte	4,2,35,4,7
	.byte	'base',0
	.word	6331
	.byte	12,2,35,8,7
	.byte	'core',0
	.word	4782
	.byte	4,2,35,20,7
	.byte	'access',0
	.word	180
	.byte	1,2,35,24,7
	.byte	'application',0
	.word	180
	.byte	1,2,35,25,0,4
	.byte	'Os_CounterType',0,10,234,3,3
	.word	6690
	.byte	3
	.word	6512
	.byte	12
	.word	6690
	.byte	3
	.word	6842
	.byte	4
	.byte	'CounterType',0,10,235,3,52
	.word	6847
	.byte	20
	.byte	'Os_ScheduleTableStatusType',0,10,240,3,6,4,9
	.byte	'SCHEDULETABLE_STOPPED',0,0,9
	.byte	'SCHEDULETABLE_NEXT',0,1,9
	.byte	'SCHEDULETABLE_WAITING',0,2,9
	.byte	'SCHEDULETABLE_RUNNING',0,3,9
	.byte	'SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS',0,4,0,4
	.byte	'ScheduleTableStatusType',0,10,241,3,41
	.word	6873
	.byte	12
	.word	.L6-.L3
	.byte	3
	.word	7073
	.byte	4
	.byte	'ScheduleTableType',0,10,128,4,58
	.word	7078
	.byte	17
	.byte	'Os_ScheduleTableDynType_s',0,10,130,4,16,16,7
	.byte	'match',0
	.word	248
	.byte	4,2,35,0,7
	.byte	'next',0
	.word	7083
	.byte	4,2,35,4,7
	.byte	'state',0
	.word	6873
	.byte	4,2,35,8,7
	.byte	'config',0
	.word	211
	.byte	2,2,35,12,0,3
	.word	7110
	.byte	12
	.word	7203
.L6:
	.byte	17
	.byte	'Os_ScheduleTableType_s',0,10,247,3,16,16,7
	.byte	'dynamic',0
	.word	7208
	.byte	4,2,35,0,7
	.byte	'counter',0
	.word	6852
	.byte	4,2,35,4,7
	.byte	'repeat',0
	.word	180
	.byte	1,2,35,8,7
	.byte	'config',0
	.word	211
	.byte	2,2,35,10,7
	.byte	'initial',0
	.word	180
	.byte	1,2,35,12,7
	.byte	'access',0
	.word	180
	.byte	1,2,35,13,7
	.byte	'application',0
	.word	180
	.byte	1,2,35,14,0,4
	.byte	'Os_ScheduleTableType',0,10,255,3,3
	.word	7213
	.byte	12
	.word	7213
	.byte	3
	.word	7393
	.byte	12
	.word	6690
	.byte	3
	.word	7403
	.byte	22
	.word	4506
	.byte	22
	.word	5456
	.byte	22
	.word	5353
	.byte	22
	.word	6014
	.byte	22
	.word	5520
	.byte	22
	.word	180
	.byte	22
	.word	6014
	.byte	17
	.byte	'Os_ControlledCoreType_s',0,10,251,6,16,112,7
	.byte	'TrapInfo',0
	.word	3937
	.byte	8,2,35,0,7
	.byte	'lock_taskaccess',0
	.word	7413
	.byte	4,2,35,8,7
	.byte	'ReadyTasks',0
	.word	7418
	.byte	4,2,35,12,7
	.byte	'RunningISR',0
	.word	7423
	.byte	4,2,35,16,7
	.byte	'RunningTask',0
	.word	7428
	.byte	4,2,35,20,7
	.byte	'RunningTPMask',0
	.word	7433
	.byte	4,2,35,24,7
	.byte	'CurrentMeteredObject',0
	.word	5039
	.byte	4,2,35,28,7
	.byte	'IdleMeter',0
	.word	4836
	.byte	48,2,35,32,7
	.byte	'AppAccess',0
	.word	180
	.byte	1,2,35,80,7
	.byte	'AppOverride',0
	.word	7438
	.byte	1,2,35,81,7
	.byte	'GetStackValueAdjust',0
	.word	4108
	.byte	8,2,35,84,7
	.byte	'InErrorHook',0
	.word	180
	.byte	1,2,35,92,7
	.byte	'ChainTaskRef',0
	.word	7443
	.byte	4,2,35,96,7
	.byte	'GetStackUsageAdjust',0
	.word	4108
	.byte	8,2,35,100,7
	.byte	'InProtectionHook',0
	.word	180
	.byte	1,2,35,108,7
	.byte	'CoreIsActive',0
	.word	180
	.byte	1,2,35,109,7
	.byte	'InShutdownHook',0
	.word	180
	.byte	1,2,35,110,0,4
	.byte	'Os_ControlledCoreType',0,10,141,7,3
	.word	7448
	.byte	3
	.word	248
	.byte	12
	.word	5184
	.byte	3
	.word	7904
	.byte	12
	.word	5754
	.byte	3
	.word	7914
	.byte	3
	.word	4836
	.byte	17
	.byte	'Os_AnyCoreType_s',0,10,151,7,16,96,7
	.byte	'DisableAllImask',0
	.word	248
	.byte	4,2,35,0,7
	.byte	'SuspendAllImask',0
	.word	248
	.byte	4,2,35,4,7
	.byte	'SuspendOSImask',0
	.word	248
	.byte	4,2,35,8,7
	.byte	'DisableAllCount',0
	.word	248
	.byte	4,2,35,12,7
	.byte	'SuspendAllCount',0
	.word	248
	.byte	4,2,35,16,7
	.byte	'SuspendOSCount',0
	.word	248
	.byte	4,2,35,20,7
	.byte	'RestartJumpBuf',0
	.word	4057
	.byte	68,2,35,24,7
	.byte	'Restartable',0
	.word	180
	.byte	1,2,35,92,0,4
	.byte	'Os_AnyCoreType',0,10,160,7,3
	.word	7929
	.byte	4
	.byte	'Can_TxObjPriorityClassType',0,11,219,3,16
	.word	248
	.byte	17
	.byte	'Can_TxHwObjectConfigType',0,11,231,3,16,8,7
	.byte	'MsgObjId',0
	.word	180
	.byte	1,2,35,0,7
	.byte	'HwControllerId',0
	.word	180
	.byte	1,2,35,1,7
	.byte	'TxObjPriorityClass',0
	.word	248
	.byte	4,2,35,4,0,4
	.byte	'Can_TxHwObjectConfigType',0,11,252,3,3
	.word	8206
	.byte	17
	.byte	'Can_RxHwObjectConfigType',0,11,129,4,16,12,7
	.byte	'MaskRef',0
	.word	248
	.byte	4,2,35,0,7
	.byte	'MsgId',0
	.word	248
	.byte	4,2,35,4,7
	.byte	'MsgObjId',0
	.word	180
	.byte	1,2,35,8,7
	.byte	'HwControllerId',0
	.word	180
	.byte	1,2,35,9,0,4
	.byte	'Can_RxHwObjectConfigType',0,11,147,4,3
	.word	8342
	.byte	10,4
	.word	180
	.byte	11,3,0,17
	.byte	'Can_ControllerMOMapConfigType',0,11,181,4,16,4,7
	.byte	'ControllerMOMap',0
	.word	8482
	.byte	4,2,35,0,0,4
	.byte	'Can_ControllerMOMapConfigType',0,11,184,4,3
	.word	8491
	.byte	17
	.byte	'Can_NPCRValueType',0,11,188,4,16,2,7
	.byte	'Can_NPCRValue',0
	.word	211
	.byte	2,2,35,0,0,4
	.byte	'Can_NPCRValueType',0,11,191,4,3
	.word	8592
	.byte	17
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,11,194,4,16,8,7
	.byte	'CanControllerBaudrate',0
	.word	248
	.byte	4,2,35,0,7
	.byte	'CanControllerBaudrateCfg',0
	.word	211
	.byte	2,2,35,4,0,4
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,11,198,4,3
	.word	8667
	.byte	12
	.word	8667
	.byte	3
	.word	8832
	.byte	17
	.byte	'Can_BaudrateConfigPtrType',0,11,201,4,16,4,7
	.byte	'Can_kBaudrateConfigPtr',0
	.word	8837
	.byte	4,2,35,0,0,4
	.byte	'Can_BaudrateConfigPtrType',0,11,204,4,3
	.word	8842
	.byte	17
	.byte	'Can_EventHandlingType',0,11,226,4,16,4,7
	.byte	'CanEventType',0
	.word	8482
	.byte	4,2,35,0,0,4
	.byte	'Can_EventHandlingType',0,11,229,4,3
	.word	8942
	.byte	4
	.byte	'Rte_TransformerErrorCode',0,12,130,1,15
	.word	180
	.byte	4
	.byte	'Rte_TransformerClass',0,12,131,1,15
	.word	180
	.byte	6,12,168,1,9,12,7
	.byte	'in',0
	.word	4782
	.byte	4,2,35,0,7
	.byte	'out',0
	.word	4782
	.byte	4,2,35,4,7
	.byte	'used',0
	.word	211
	.byte	2,2,35,8,7
	.byte	'lost_data',0
	.word	180
	.byte	1,2,35,10,0,4
	.byte	'Rte_QDynType',0,12,173,1,3
	.word	9088
	.byte	8,12,175,1,9,4,9
	.byte	'RTE_DRA',0,0,9
	.byte	'RTE_WOWP',0,1,9
	.byte	'RTE_TASK',0,2,9
	.byte	'RTE_ARE',0,3,9
	.byte	'RTE_EV',0,4,9
	.byte	'RTE_MSI',0,5,0,4
	.byte	'Rte_NotificationType',0,12,182,1,3
	.word	9175
	.byte	10,128,8
	.word	180
	.byte	11,255,7,0,4
	.byte	'Impl_NVM_DstPtrType_1024',0,13,50,15
	.word	9273
	.byte	4
	.byte	'CanIf_u32_impl',0,13,69,16
	.word	248
	.byte	4
	.byte	'CanIf_u16_impl',0,13,71,16
	.word	211
	.byte	4
	.byte	'CanIf_u8_impl',0,13,73,15
	.word	180
	.byte	4
	.byte	'CanIf_ControllerModeType_Enum_impl',0,13,88,15
	.word	180
	.byte	4
	.byte	'CanIf_PduModeType_Enum_impl',0,13,90,15
	.word	180
	.byte	6,13,92,9,2,7
	.byte	'DeviceMode',0
	.word	180
	.byte	1,2,35,0,7
	.byte	'ChannelMode',0
	.word	180
	.byte	1,2,35,1,0,4
	.byte	'CanIf_ControllerStateType_struct_impl',0,13,95,3
	.word	9464
	.byte	4
	.byte	'CanIf_NotifStatusType_Enum_impl',0,13,100,15
	.word	180
	.byte	4
	.byte	'CanSM_boolean_Impl',0,13,120,15
	.word	180
	.byte	4
	.byte	'CanSM_u8_Impl',0,13,123,15
	.word	180
	.byte	4
	.byte	'CanSM_BusOffRecoveryStateType_Enum_impl',0,13,128,1,15
	.word	180
	.byte	4
	.byte	'CanSM_NetworkModeStateType_Enum_impl',0,13,132,1,15
	.word	180
	.byte	4
	.byte	'CanSM_u16_Impl',0,13,136,1,16
	.word	211
	.byte	4
	.byte	'CanSM_TimerStateType_Enum_impl',0,13,138,1,15
	.word	180
	.byte	6,13,140,1,9,4,7
	.byte	'cntTick_u16',0
	.word	211
	.byte	2,2,35,0,7
	.byte	'stTimer',0
	.word	180
	.byte	1,2,35,2,0,4
	.byte	'CanSM_TimerConfig_tst_struct_impl',0,13,143,1,3
	.word	9805
	.byte	4
	.byte	'Com_impl_u16',0,13,154,1,16
	.word	211
	.byte	4
	.byte	'Com_impl_u8',0,13,157,1,15
	.word	180
	.byte	4
	.byte	'ComM_uint32_Impl',0,13,173,1,16
	.word	248
	.byte	4
	.byte	'ComM_uint16_Impl',0,13,175,1,16
	.word	211
	.byte	4
	.byte	'ComM_uint8_Impl',0,13,177,1,15
	.word	180
	.byte	4
	.byte	'ComM_bool_Impl',0,13,179,1,15
	.word	180
	.byte	6,13,181,1,9,24,7
	.byte	'ChannelState_e',0
	.word	248
	.byte	4,2,35,0,7
	.byte	'LightTimeoutCtr_u32',0
	.word	248
	.byte	4,2,35,4,7
	.byte	'MinFullComTimeoutCtr_u16',0
	.word	211
	.byte	2,2,35,8,7
	.byte	'ChannelMode_u8',0
	.word	180
	.byte	1,2,35,10,7
	.byte	'BusSmMode_u8',0
	.word	180
	.byte	1,2,35,11,7
	.byte	'UserRequestCtr_u8',0
	.word	180
	.byte	1,2,35,12,7
	.byte	'PassiveRequestState_u8',0
	.word	180
	.byte	1,2,35,13,7
	.byte	'PncRequestCtr_u8',0
	.word	180
	.byte	1,2,35,14,7
	.byte	'InhibitionReqStatus_u8',0
	.word	180
	.byte	1,2,35,15,7
	.byte	'NmNetworkRequestStatus_b',0
	.word	180
	.byte	1,2,35,16,7
	.byte	'DiagnosticRequestState_b',0
	.word	180
	.byte	1,2,35,17,7
	.byte	'CommunicationAllowed_b',0
	.word	180
	.byte	1,2,35,18,7
	.byte	'NmBusSleepIndicationStatus_b',0
	.word	180
	.byte	1,2,35,19,7
	.byte	'NmPrepareBusSleepIndicationStatus_b',0
	.word	180
	.byte	1,2,35,20,7
	.byte	'NmNetworkModeStatus_b',0
	.word	180
	.byte	1,2,35,21,0,4
	.byte	'ComM_ChannelStruct_Impl',0,13,197,1,3
	.word	10037
	.byte	6,13,206,1,9,10,7
	.byte	'WakeUpInhibitionCtr_u16',0
	.word	211
	.byte	2,2,35,0,7
	.byte	'LimitToNoComCtr_u16',0
	.word	211
	.byte	2,2,35,2,7
	.byte	'RequestedUserMode_t',0
	.word	180
	.byte	1,2,35,4,7
	.byte	'IndicatedUserMode_t',0
	.word	180
	.byte	1,2,35,5,7
	.byte	'numChannelsInFullCom_u8',0
	.word	180
	.byte	1,2,35,6,7
	.byte	'numChannelsInSilentCom_u8',0
	.word	180
	.byte	1,2,35,7,7
	.byte	'numChannelsInNoCom_u8',0
	.word	180
	.byte	1,2,35,8,0,4
	.byte	'ComM_UserStruct_Impl',0,13,214,1,3
	.word	10541
	.byte	4
	.byte	'Dcm_IOOperationResponseType',0,13,252,1,15
	.word	180
	.byte	4
	.byte	'Dcm_RequestDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspRequestRoutineResultsOutSignal_0PrimitivType',0
	.byte	13,138,2,15
	.word	180
	.byte	4
	.byte	'Dcm_StartDataIn_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineInSignalPrimitivType',0,13,146,2,15
	.word	180
	.byte	4
	.byte	'Dcm_StartDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineOutSignalPrimitivType',0,13,150,2,15
	.word	180
	.byte	4
	.byte	'Dcm_StopDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStopRoutineOutSignalPrimitivType',0,13,154,2,15
	.word	180
	.byte	4
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockNative_1024_Type',0,13,243,3,34
	.word	9284
	.byte	10,128,8
	.word	180
	.byte	11,255,7,0,4
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockRedundant_1024_Type',0,13,246,3,34
	.word	9284
	.byte	8,14,216,1,9,4,9
	.byte	'XCP_BG_IDLE',0,0,9
	.byte	'XCP_BG_CHKSUM',0,1,9
	.byte	'XCP_BG_MEM_WRITE',0,2,9
	.byte	'XCP_BG_REPEAT_CMD',0,3,9
	.byte	'XCP_BG_DO_DISCONNECT',0,4,9
	.byte	'XCP_BG_CANCEL_REQ',0,5,0,4
	.byte	'Xcp_BgActivity_t',0,14,224,1,3
	.word	11359
	.byte	15,1,1,14
	.word	2836
	.byte	14
	.word	180
	.byte	0,3
	.word	11504
	.byte	4
	.byte	'Xcp_CmdFunctionPtr',0,14,230,1,16
	.word	11518
	.byte	6,14,241,1,9,8,7
	.byte	'WritePos_u16',0
	.word	211
	.byte	2,2,35,0,7
	.byte	'ReadPos_u16',0
	.word	211
	.byte	2,2,35,2,7
	.byte	'ReadPos_OdtNum_u16',0
	.word	211
	.byte	2,2,35,4,7
	.byte	'QueSize_u16',0
	.word	211
	.byte	2,2,35,6,0,4
	.byte	'Xcp_Que_t',0,14,247,1,3
	.word	11551
	.byte	6,14,250,1,9,24,7
	.byte	'XcpState_en',0
	.word	646
	.byte	4,2,35,0,7
	.byte	'ConnectedTlId_u8',0
	.word	180
	.byte	1,2,35,4,7
	.byte	'ResourceProtStatus_u8',0
	.word	180
	.byte	1,2,35,5,7
	.byte	'Mta',0
	.word	811
	.byte	8,2,35,8,7
	.byte	'MaxDto_u16',0
	.word	211
	.byte	2,2,35,16,7
	.byte	'MaxDtoAligned_u16',0
	.word	211
	.byte	2,2,35,18,7
	.byte	'MaxCto_u8',0
	.word	180
	.byte	1,2,35,20,0,4
	.byte	'Xcp_Session_t',0,14,138,2,2
	.word	11669
	.byte	6,14,149,2,9,12,7
	.byte	'Buffer_au8',0
	.word	2705
	.byte	8,2,35,0,7
	.byte	'Length_u32',0
	.word	248
	.byte	4,2,35,8,0,4
	.byte	'Xcp_CtoMax_t',0,14,153,2,2
	.word	11856
	.byte	10,255,1
	.word	180
	.byte	11,254,1,0,6,14,157,2,9,132,2,7
	.byte	'UploadRunning_b',0
	.word	180
	.byte	1,2,35,0,7
	.byte	'RemainingSize_u8',0
	.word	180
	.byte	1,2,35,1,7
	.byte	'DownloadSize_u8',0
	.word	180
	.byte	1,2,35,2,7
	.byte	'ReceivedSize_u8',0
	.word	180
	.byte	1,2,35,3,7
	.byte	'DownloadBuffer_au8',0
	.word	11925
	.byte	255,1,2,35,4,0,4
	.byte	'Xcp_Mem_t',0,14,178,2,2
	.word	11936
	.byte	6,14,183,2,9,2,7
	.byte	'SeedWaitingKey_b',0
	.word	180
	.byte	1,2,35,0,7
	.byte	'SeedRemaingSize_u8',0
	.word	180
	.byte	1,2,35,1,0,4
	.byte	'Xcp_SeedAndKey_t',0,14,187,2,2
	.word	12093
	.byte	6,14,192,2,9,4,7
	.byte	'BlockSize_u32',0
	.word	248
	.byte	4,2,35,0,0,4
	.byte	'Xcp_Checksum_t',0,14,198,2,2
	.word	12180
	.byte	6,14,203,2,9,18,7
	.byte	'Xcp_Debug_TransmitOkCtr',0
	.word	211
	.byte	2,2,35,0,7
	.byte	'Xcp_Debug_TransmitNotOkCtr',0
	.word	211
	.byte	2,2,35,2,7
	.byte	'Xcp_Debug_SendResTxConfCtr',0
	.word	211
	.byte	2,2,35,4,7
	.byte	'Xcp_Debug_SendResCtr',0
	.word	211
	.byte	2,2,35,6,7
	.byte	'Xcp_Debug_SendEvTxConfCtr',0
	.word	211
	.byte	2,2,35,8,7
	.byte	'Xcp_Debug_SendEvCtr',0
	.word	211
	.byte	2,2,35,10,7
	.byte	'Xcp_Debug_SendDaqTxConfCtr',0
	.word	211
	.byte	2,2,35,12,7
	.byte	'Xcp_Debug_SendDaqCtr',0
	.word	211
	.byte	2,2,35,14,7
	.byte	'Xcp_Debug_TxConfCtr',0
	.word	211
	.byte	2,2,35,16,0,4
	.byte	'Xcp_Debug_t',0,14,216,2,2
	.word	12234
	.byte	6,14,225,2,9,8,7
	.byte	'OdtEntryPos_u16',0
	.word	211
	.byte	2,2,35,0,7
	.byte	'OdtEntryMax_u16',0
	.word	211
	.byte	2,2,35,2,7
	.byte	'DaqListNum_u16',0
	.word	211
	.byte	2,2,35,4,7
	.byte	'AbsOdtNum_u16',0
	.word	211
	.byte	2,2,35,6,0,4
	.byte	'Xcp_SelectedOdtEntry_t',0,14,231,2,2
	.word	12556
	.byte	6,14,234,2,9,6,7
	.byte	'OdtEntryFirst_u16',0
	.word	211
	.byte	2,2,35,0,7
	.byte	'OdtEntryCnt_u8',0
	.word	180
	.byte	1,2,35,2,7
	.byte	'CopyRoutine_u8',0
	.word	180
	.byte	1,2,35,3,7
	.byte	'Length_u16',0
	.word	211
	.byte	2,2,35,4,0,4
	.byte	'Xcp_Odt_t',0,14,240,2,2
	.word	12692
	.byte	22
	.word	180
	.byte	22
	.word	180
	.byte	6,14,254,2,9,24,7
	.byte	'DaqListQue_p',0
	.word	2781
	.byte	4,2,35,0,7
	.byte	'DaqListQuePos',0
	.word	11551
	.byte	8,2,35,4,7
	.byte	'OdtFirst_u16',0
	.word	211
	.byte	2,2,35,12,7
	.byte	'EventChannelNum_u16',0
	.word	211
	.byte	2,2,35,14,7
	.byte	'OdtCnt_u8',0
	.word	180
	.byte	1,2,35,16,7
	.byte	'XcpTxPduId',0
	.word	180
	.byte	1,2,35,17,7
	.byte	'Prescaler_u8',0
	.word	180
	.byte	1,2,35,18,7
	.byte	'CycleCnt_u8',0
	.word	180
	.byte	1,2,35,19,7
	.byte	'Priority_u8',0
	.word	180
	.byte	1,2,35,20,7
	.byte	'Flags_u8',0
	.word	180
	.byte	1,2,35,21,7
	.byte	'Mode_u8',0
	.word	12813
	.byte	1,2,35,22,7
	.byte	'CurrentlyRunning_b',0
	.word	12818
	.byte	1,2,35,23,0,4
	.byte	'Xcp_DaqList_t',0,14,143,3,2
	.word	12823
	.byte	3
	.word	12823
	.byte	3
	.word	12692
	.byte	3
	.word	248
	.byte	3
	.word	211
	.byte	6,14,146,3,9,56,7
	.byte	'DaqList_p',0
	.word	13115
	.byte	4,2,35,0,7
	.byte	'Odt_p',0
	.word	13120
	.byte	4,2,35,4,7
	.byte	'OdtEntryAddress_p',0
	.word	13125
	.byte	4,2,35,8,7
	.byte	'OdtEntrySize_p',0
	.word	2781
	.byte	4,2,35,12,7
	.byte	'PriorityList_p',0
	.word	13130
	.byte	4,2,35,16,7
	.byte	'DaqQue_p',0
	.word	2781
	.byte	4,2,35,20,7
	.byte	'DaqListCnt_u16',0
	.word	211
	.byte	2,2,35,24,7
	.byte	'OdtCnt_u16',0
	.word	211
	.byte	2,2,35,26,7
	.byte	'OdtEntryCnt_u16',0
	.word	211
	.byte	2,2,35,28,7
	.byte	'SelectedOdtEntry',0
	.word	12556
	.byte	8,2,35,30,7
	.byte	'DaqRamPtr_pu8',0
	.word	2781
	.byte	4,2,35,40,7
	.byte	'DaqRamSize_u32',0
	.word	248
	.byte	4,2,35,44,7
	.byte	'DaqListSendingCnt_u16',0
	.word	211
	.byte	2,2,35,48,7
	.byte	'DaqListSending_u16',0
	.word	211
	.byte	2,2,35,50,7
	.byte	'DaqState_en',0
	.word	1467
	.byte	4,2,35,52,0,4
	.byte	'Xcp_DaqConfig_t',0,14,180,3,2
	.word	13135
	.byte	0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L4:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,21,0,54,15,0,0,3,15,0,73,19,0,0,4,22,0,3,8,58,15,59,15
	.byte	57,15,73,19,0,0,5,36,0,3,8,11,15,62,15,0,0,6,19,1,58,15,59,15,57,15,11,15,0,0,7,13,0,3,8,73,19,11,15,56
	.byte	9,0,0,8,4,1,58,15,59,15,57,15,11,15,0,0,9,40,0,3,8,28,13,0,0,10,1,1,11,15,73,19,0,0,11,33,0,47,15,0,0
	.byte	12,38,0,73,19,0,0,13,21,1,73,19,54,15,39,12,0,0,14,5,0,73,19,0,0,15,21,1,54,15,39,12,0,0,16,21,0,54,15
	.byte	39,12,0,0,17,19,1,3,8,58,15,59,15,57,15,11,15,0,0,18,59,0,3,8,0,0,19,23,1,58,15,59,15,57,15,11,15,0,0
	.byte	20,4,1,3,8,58,15,59,15,57,15,11,15,0,0,21,21,0,73,19,54,15,39,12,0,0,22,53,0,73,19,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L5:
	.word	.L8-.L7
.L7:
	.half	3
	.word	.L10-.L9
.L9:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Xcp\\src\\XcpOnFr.c',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Platform\\Platform_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Std_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Xcp\\api\\Xcp_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Xcp\\Xcp_Cfg.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\rba_BswSrv.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Can_GeneralTypes.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\RTOS_T\\Gen\\inc\\Os.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Can_17_MCanP\\inc\\Can_17_MCanP.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Type.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Xcp\\api\\Xcp_Priv.h',0,0,0,0,0
.L10:
.L8:

; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	     1  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	     2  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	     3  /***************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	     4  * Includes
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	     5  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	     6  #include "Xcp.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	     7  #include "Xcp_Priv.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	     8  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	     9  #if (XCP_ON_FLEXRAY_ENABLED == STD_ON)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    10  #include "FrIf.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    11  #include "XcpOnFr_Types.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    12  #include "XcpOnFr_Cfg.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    13  #include "XcpOnFr_Cbk.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    14  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    15  /* Check versions */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    16  #if (!defined(FRIF_AR_RELEASE_MAJOR_VERSION) || (FRIF_AR_RELEASE_MAJOR_VERSION != XCP_AR_RELEASE_MAJOR_VERSION))
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    17    #error "AUTOSAR major version undefined or mismatched"
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    18  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    19  #if (!defined(FRIF_AR_RELEASE_MINOR_VERSION) || (FRIF_AR_RELEASE_MINOR_VERSION != XCP_AR_RELEASE_MINOR_VERSION))
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    20    #error "AUTOSAR minor version undefined or mismatched"
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    21  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    22  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    23  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    24  /*
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    25  Design decisions:
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    26  Rx Pdus: PacketStart points always to start of new XcpPacket
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    27  Tx Pdus: Length points to the length for next frame (LEN). Reason for not pointing to start of new XcpPacket:
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    28           FlexRay frame has maximum length of 254 byte. Start position of new XcpPacket would be 256.
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    29           With uint8 this would be 0. To save RAM Length points to LEN and not to start of next XcpPacket
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    30  */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    31  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    32  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    33  /***************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    34  * Defines/Macros
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    35  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    36  /** Mark the given Pdu as blocked */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    37  #define XCP_BLOCK_PDU(PduId)      do { Xcp_FrCfgCleared.TxPduBlocked_ab[PduId] = TRUE; } while (0)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    38  /** Clear the given Pdu and mark it as free */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    39  #define XCP_EMPTY_PDU(PduId)      do { Xcp_FrCfgCleared.TxPdu[PduId].SduLength = 1; Xcp_FrCfgCleared.TxPduBlocked_ab[PduId] = FALSE;} while (0) /* 1 because on position 0 is always NAX */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    40  /** Is the given Pdu blocked? */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    41  #define XCP_IS_PDU_BLOCKED(PduId) Xcp_FrCfgCleared.TxPduBlocked_ab[PduId]
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    42  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    43  /* Header and alignment definitions */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    44  #if (XCP_FR_PACKET_ALIGNMENT == XCP_FR_PACKET_ALIGNMENT_8)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    45    #define XCP_FR_ALIGNMENT_MASK 0u
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    46    #if ((XCP_FR_FRAME_CONCATENATION == STD_OFF) && (XCP_FR_SEQUENCE_CORRECTION == STD_OFF))
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    47      #define XCP_FR_HEADER_SIZE 1u
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    48    #elif ((XCP_FR_FRAME_CONCATENATION == STD_ON) && (XCP_FR_SEQUENCE_CORRECTION == STD_OFF))
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    49      #define XCP_FR_HEADER_SIZE 2u
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    50    #elif ((XCP_FR_FRAME_CONCATENATION == STD_OFF) && (XCP_FR_SEQUENCE_CORRECTION == STD_ON))
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    51      #define XCP_FR_HEADER_SIZE 2u
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    52    #elif ((XCP_FR_FRAME_CONCATENATION == STD_ON) && (XCP_FR_SEQUENCE_CORRECTION == STD_ON))
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    53      #define XCP_FR_HEADER_SIZE 3u
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    54    #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    55  #elif (XCP_FR_PACKET_ALIGNMENT == XCP_FR_PACKET_ALIGNMENT_16)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    56    #define XCP_FR_ALIGNMENT_MASK 1u
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    57    #if ((XCP_FR_FRAME_CONCATENATION == STD_OFF) && (XCP_FR_SEQUENCE_CORRECTION == STD_OFF))
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    58      #define XCP_FR_HEADER_SIZE 2u
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    59    #elif ((XCP_FR_FRAME_CONCATENATION == STD_ON) && (XCP_FR_SEQUENCE_CORRECTION == STD_OFF))
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    60      #define XCP_FR_HEADER_SIZE 2u
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    61    #elif ((XCP_FR_FRAME_CONCATENATION == STD_OFF) && (XCP_FR_SEQUENCE_CORRECTION == STD_ON))
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    62      #define XCP_FR_HEADER_SIZE 2u
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    63    #elif ((XCP_FR_FRAME_CONCATENATION == STD_ON) && (XCP_FR_SEQUENCE_CORRECTION == STD_ON))
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    64      #define XCP_FR_HEADER_SIZE 4u
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    65    #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    66  #elif (XCP_FR_PACKET_ALIGNMENT == XCP_FR_PACKET_ALIGNMENT_32)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    67    #define XCP_FR_ALIGNMENT_MASK 3u
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    68    #if ((XCP_FR_FRAME_CONCATENATION == STD_OFF) && (XCP_FR_SEQUENCE_CORRECTION == STD_OFF))
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    69      #define XCP_FR_HEADER_SIZE 4u
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    70    #elif ((XCP_FR_FRAME_CONCATENATION == STD_ON) && (XCP_FR_SEQUENCE_CORRECTION == STD_OFF))
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    71      #define XCP_FR_HEADER_SIZE 4u
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    72    #elif ((XCP_FR_FRAME_CONCATENATION == STD_OFF) && (XCP_FR_SEQUENCE_CORRECTION == STD_ON))
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    73      #define XCP_FR_HEADER_SIZE 4u
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    74    #elif ((XCP_FR_FRAME_CONCATENATION == STD_ON) && (XCP_FR_SEQUENCE_CORRECTION == STD_ON))
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    75      #define XCP_FR_HEADER_SIZE 4u
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    76    #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    77  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    78  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    79  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    80  /***************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    81  * Variables
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    82  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    83  #define XCP_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    84  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    85  /** Array for conversion from PacketId into PacketType - usage: PacketType = XcpFrPacketId2PacketType[0xff-PacketId]; */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    86  static const Xcp_PacketType_t XcpFrPacketId2PacketType[] =
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    87  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    88    XCP_PACKET_TYPE_RES_ERR,
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    89    XCP_PACKET_TYPE_RES_ERR,
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    90    XCP_PACKET_TYPE_EV_SERV,
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    91    XCP_PACKET_TYPE_EV_SERV
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    92  };
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    93  #define XCP_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    94  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    95  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    96  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    97  /***************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    98  * Local function declarations
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	    99  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   100  #define XCP_START_SEC_CODE_FAST
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   101  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   102  static Std_ReturnType   Xcp_FrTransmitInMainfunction(const PduInfoType* XcpPacketPtr, uint8 XcpFrTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   103  static Xcp_PacketType_t Xcp_FrPacketId2PacketType(uint8 XcpPacketId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   104  static Xcp_PduIdType    Xcp_FrGetFreeTxPduId(Xcp_PacketType_t XcpPacketType, uint8 XcpFrTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   105  static Std_ReturnType   Xcp_FrNoFreeTxPduId(Xcp_PacketType_t XcpPacketType, uint8 XcpFrTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   106  static PduLengthType    Xcp_FrInsertHeader(Xcp_PduIdType XcpTxPduId, uint8 XcpFrTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   107  #if (XCP_FR_FRAME_CONCATENATION == STD_ON)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   108  static void             Xcp_FrFinishFrame(Xcp_PduIdType XcpTxPduId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   109  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   110  #define XCP_STOP_SEC_CODE_FAST
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   111  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   112  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   113  #define XCP_START_SEC_CODE
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   114  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   115  static Xcp_ErrorCode  Xcp_FrTransportLayerCmd_Assign(const PduInfoType* XcpCmdPacketPtr, uint8 XcpFrTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   116  static Xcp_ErrorCode  Xcp_FrTransportLayerCmd_Activate(const PduInfoType* XcpCmdPacketPtr, uint8 XcpFrTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   117  static Xcp_ErrorCode  Xcp_FrTransportLayerCmd_Deactivate(const PduInfoType* XcpCmdPacketPtr, uint8 XcpFrTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   118  #define XCP_STOP_SEC_CODE
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   119  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   120  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   121  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   122  /***************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   123  * Functions
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   124  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   125  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   126  #define XCP_START_SEC_CODE
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   127  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   128  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   129  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   130  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   131  This function is called by the lower layers when an AUTOSAR XCP PDU has been received
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   132  \param[in]  XcpRxPduId    PduId that has been received
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   133  \param[in]  XcpRxPduPtr   Pointer to received Pdu
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   134  \return     -
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   135  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   136  void Xcp_FrIfRxIndication(PduIdType XcpRxPduId, const PduInfoType* XcpRxPduPtr)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   137  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   138    /* Local variables */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   139    PduInfoType XcpPacketPtr;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   140    uint8 XcpTransportLayerId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   141    PduLengthType PacketStart;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   142    XCP_ADDR_TYPE XcpBufferAligned[(XCP_FR_RX_PDU_LEN_MAX + (XCP_ADDR_LEN - 1u)) / XCP_ADDR_LEN];
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   143  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   144    /*--- DET reporting ----------------------------------------------------------------------------*/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   145    /* If Xcp is uninitialized, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   146    XCP_DET_REPORT_ERROR((Xcp_GlobalNoInit.InitStatus_u8 != XCP_INIT), XCP_RX_INDICATION_SID, XCP_E_NOT_INITIALIZED);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   147    /* If XcpRxPduPtr is NULL_PTR, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   148    XCP_DET_REPORT_ERROR((XcpRxPduPtr == NULL_PTR), XCP_RX_INDICATION_SID, XCP_E_NULL_POINTER);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   149    /* If SduDataPtr within XcpRxPduPtr is NULL_PTR, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   150    XCP_DET_REPORT_ERROR((XcpRxPduPtr->SduDataPtr == NULL_PTR), XCP_RX_INDICATION_SID, XCP_E_NULL_POINTER);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   151    /* If Invalid RxPduId, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   152    XCP_DET_REPORT_ERROR((XcpRxPduId >= XCP_FR_NUMBER_OF_RX_PDUS), XCP_RX_INDICATION_SID, XCP_E_INVALID_PDUID);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   153    /*--- / DET reporting --------------------------------------------------------------------------*/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   154  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   155    /* Get TransportLayer Id related to received PduId */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   156    XcpTransportLayerId = Xcp_FrCfgConst.RxPduCfg[XcpRxPduId].TLId_u8;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   157  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   158    /* Check if the message is for this Transport Layer (compare NAX) */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   159    /* MR12 RULE 2.2 VIOLATION: XCP_*_TRANSPORT_LAYER_INDEX_OFFSET changes depending on the configuration thus the calculation is necessary if the value is not 0 (0 raises the MISRA violation) */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   160    if (XcpRxPduPtr->SduDataPtr[0] == Xcp_FrCfgConst.TlCfg[XcpTransportLayerId-XCP_FR_TRANSPORT_LAYER_INDEX_OFFSET].Nax_u8)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   161    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   162      /* Set PacketStart after header */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   163      PacketStart = XCP_FR_HEADER_SIZE;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   164  #if (XCP_FR_FRAME_CONCATENATION == STD_ON)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   165      /* Check if any data to process (LEN > 0) && if packet data is in boundaries of RxPdu */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   166      while ((XcpRxPduPtr->SduDataPtr[PacketStart-1u] > 0) && ((PacketStart + XcpRxPduPtr->SduDataPtr[PacketStart-1u]) <= XcpRxPduPtr->SduLength))
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   167      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   168        /* Extract length of the XCP packet which will be sent to Protocol Layer */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   169        XcpPacketPtr.SduLength = XcpRxPduPtr->SduDataPtr[PacketStart-1u];
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   170  #else
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   171      /* Check if any data to process */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   172      if (XcpRxPduPtr->SduLength > XCP_FR_HEADER_SIZE)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   173      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   174        /* Calculate the length of the XCP packet which will be sent to Protocol Layer */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   175        XcpPacketPtr.SduLength = XcpRxPduPtr->SduLength - XCP_FR_HEADER_SIZE;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   176  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   177        /* Set pointer to PacketStart */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   178        XcpPacketPtr.SduDataPtr = XcpRxPduPtr->SduDataPtr + PacketStart;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   179  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   180        /* Align XCP packet to uint32/uint64 for protocol layer */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   181        /* MR12 RULE 11.4 VIOLATION: Cast from pointer to XCP_ADDR_TYPE is OK as this type is able to store the address (see type definition) */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   182        if (((XCP_ADDR_TYPE)XcpPacketPtr.SduDataPtr & (XCP_ADDR_LEN - 1u)) != 0u)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   183        {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   184          /* Pdu length can not be bigger than maximum configured for the corresponding TL */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   185          XcpPacketPtr.SduLength = XCP_MIN(XcpPacketPtr.SduLength, XCP_FR_RX_PDU_LEN_MAX);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   186          /* MR12 DIR 1.1 VIOLATION: The input parameters of rba_BswSrv_MemCopy() are declared as (void*) for generic implementation of MemCopy. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   187          Xcp_MemCopy(XcpBufferAligned, XcpPacketPtr.SduDataPtr, XcpPacketPtr.SduLength);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   188          XcpPacketPtr.SduDataPtr = (uint8*)XcpBufferAligned;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   189        }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   190        /* Call protocol layer receive function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   191        Xcp_Receive(&XcpPacketPtr, XcpTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   192  #if (XCP_FR_FRAME_CONCATENATION == STD_ON)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   193        /* Move PacketStart in received frame to beginning of next XcpPacket */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   194        PacketStart = ((PacketStart + XcpPacketPtr.SduLength) | XCP_FR_ALIGNMENT_MASK) + 1u;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   195  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   196      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   197    } /* NAX check */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   198  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   199  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   200  #define XCP_STOP_SEC_CODE
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   201  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   202  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   203  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   204  #define XCP_START_SEC_CODE_FAST
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   205  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   206  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   207  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   208  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   209  This function is called by protocol layer to transmit XcpPackets
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   210  \param[in]  XcpPacketPtr          Pointer to XcpPacket (with Length and data pointer)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   211  \param[in]  XcpTransportLayerId   Global Transport Layer Id
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   212  \param[in]  XcpTxPduId            XcpTxPduId (relevant for CAN only)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   213  \return     status of the transmit request
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   214  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   215  Std_ReturnType Xcp_FrTransmit(const PduInfoType* XcpPacketPtr, uint8 XcpTransportLayerId, Xcp_PduIdType XcpTxPduId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   216  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   217    /* Local variables */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   218    uint8 XcpFrTransportLayerId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   219  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   220    /* Shift the Transport Layer Id */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   221    /* MR12 RULE 2.2 VIOLATION: XCP_*_TRANSPORT_LAYER_INDEX_OFFSET changes depending on the configuration thus the calculation is necessary if the value is not 0 (0 raises the MISRA violation) */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   222    XcpFrTransportLayerId = XcpTransportLayerId - XCP_FR_TRANSPORT_LAYER_INDEX_OFFSET;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   223  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   224    /*--- DET reporting ----------------------------------------------------------------------------*/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   225    /* If Xcp is uninitialized, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   226    XCP_DET_REPORT_ERROR_RET((Xcp_GlobalNoInit.InitStatus_u8 != XCP_INIT), XCP_TRANSMIT_SID, XCP_E_NOT_INITIALIZED, E_NOT_OK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   227    /* If XcpPacketPtr is NULL_PTR, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   228    XCP_DET_REPORT_ERROR_RET((XcpPacketPtr == NULL_PTR), XCP_TRANSMIT_SID, XCP_E_NULL_POINTER, E_NOT_OK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   229    /* Check if Transport Layer Id is invalid, report to DET and exit the function  */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   230    XCP_DET_REPORT_ERROR_RET((XcpFrTransportLayerId >= XCP_FR_NUMBER_OF_TRANSPORT_LAYERS), XCP_TRANSMIT_SID, XCP_E_INVALID_TRANSPORT_LAYER_ID, E_NOT_OK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   231    /* If this function is called before transmission in FrMainFunctionTx, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   232    XCP_DET_REPORT_ERROR_RET((Xcp_FrCfgCleared.TxPacketPtr[XcpFrTransportLayerId].SduLength != 0u), XCP_TRANSMIT_SID, XCP_E_UNEXPECTED_FUNCTION_CALL, E_NOT_OK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   233    /*--- / DET reporting --------------------------------------------------------------------------*/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   234  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   235    /* Used only in XcpOnCan */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   236    XCP_PARAM_UNUSED(XcpTxPduId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   237  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   238    /* Store pointer to Xcp Packet and TransportLayer Id */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   239    Xcp_FrCfgCleared.TxPacketPtr[XcpFrTransportLayerId].SduDataPtr = XcpPacketPtr->SduDataPtr;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   240    Xcp_FrCfgCleared.TxPacketPtr[XcpFrTransportLayerId].SduLength  = XcpPacketPtr->SduLength;   /* Must be after SduDataPtr */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   241  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   242    return E_OK;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   243  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   244  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   245  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   246  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   247  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   248  Local function for handling the frame transmission, called from Xcp_FrMainFunctionTx or Xcp_FrTransmit
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   249  \param[in]  XcpPacketPtr            Pointer to XcpPacket (with Length and data pointer)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   250  \param[in]  XcpFrTransportLayerId   Local FlexRay Transport Layer Id
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   251  \return     status of the transmit request
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   252  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   253  /* HIS METRIC LEVEL VIOLATION IN Xcp_FrTransmitInMainfunction: HIS metric compliance would decrease readability and maintainability. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   254  static Std_ReturnType Xcp_FrTransmitInMainfunction(const PduInfoType* XcpPacketPtr, uint8 XcpFrTransportLayerId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   255  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   256    /* Local variables */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   257    Xcp_PduIdType PduId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   258    PduLengthType PduLengthLocal;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   259    PduInfoType* TxPduPtr;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   260    Std_ReturnType RetVal;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   261    Xcp_PacketType_t XcpPacketType;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   262  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   263    /*--- DET reporting ----------------------------------------------------------------------------*/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   264    /* If Xcp is uninitialized, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   265    XCP_DET_REPORT_ERROR_RET((Xcp_GlobalNoInit.InitStatus_u8 != XCP_INIT), XCP_TRANSMIT_SID, XCP_E_NOT_INITIALIZED, E_NOT_OK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   266    /* If XcpPacketPtr is NULL_PTR, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   267    XCP_DET_REPORT_ERROR_RET((XcpPacketPtr == NULL_PTR), XCP_TRANSMIT_SID, XCP_E_NULL_POINTER, E_NOT_OK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   268    /* Check if Transport Layer Id is invalid, report to DET and exit the function  */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   269    XCP_DET_REPORT_ERROR_RET((XcpFrTransportLayerId >= XCP_FR_NUMBER_OF_TRANSPORT_LAYERS), XCP_TRANSMIT_SID, XCP_E_INVALID_TRANSPORT_LAYER_ID, E_NOT_OK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   270    /* If this function is called before transmission in FrMainFunctionTx, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   271    XCP_DET_REPORT_ERROR_RET((Xcp_FrCfgCleared.TxPacketPtr[XcpFrTransportLayerId].SduLength == 0u), XCP_TRANSMIT_SID, XCP_E_UNEXPECTED_FUNCTION_CALL, E_NOT_OK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   272    /*--- / DET reporting --------------------------------------------------------------------------*/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   273  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   274    /* Initial value */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   275    RetVal = E_OK;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   276    /* Resolve packet type from Packet Id */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   277    XcpPacketType = Xcp_FrPacketId2PacketType(XcpPacketPtr->SduDataPtr[0]);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   278    /* Find Free XcpTxPduId */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   279    PduId = Xcp_FrGetFreeTxPduId(XcpPacketType, XcpFrTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   280  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   281  #if (XCP_FR_FRAME_CONCATENATION == STD_ON)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   282    /* Pdu found? */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   283    if (PduId != XCP_PDU_ID_UNKNOWN)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   284    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   285      /* Get pointer to TxPdu */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   286      TxPduPtr = &Xcp_FrCfgCleared.TxPdu[PduId];
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   287      /* Insert XcpHeader and get new PduLength */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   288      PduLengthLocal = Xcp_FrInsertHeader(PduId, XcpFrTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   289  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   290      /* Check if enough space in Pdu */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   291      if ((PduLengthLocal + 1u + XcpPacketPtr->SduLength) <= Xcp_FrCfgConst.TxPduCfg[PduId].PduSize_u8)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   292      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   293        /* Store length before XcpPacket (LEN) */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   294        TxPduPtr->SduDataPtr[PduLengthLocal] = (uint8)XcpPacketPtr->SduLength;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   295        /* Copy data to PduBuffer buffer */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   296        /* MR12 DIR 1.1 VIOLATION: The input parameters of rba_BswSrv_MemCopy() are declared as (void*) for generic implementation of MemCopy. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   297        Xcp_MemCopy(&(TxPduPtr->SduDataPtr[PduLengthLocal+1u]), XcpPacketPtr->SduDataPtr, XcpPacketPtr->SduLength);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   298        /* Update length of Pdu */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   299        TxPduPtr->SduLength = ((PduLengthLocal + 1u + XcpPacketPtr->SduLength) | XCP_FR_ALIGNMENT_MASK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   300      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   301      /* Check if Pdu contains header only (special case, e. g. RES_ERR doesn't fit into VARIABLE Pdu) */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   302      else if (PduLengthLocal == (XCP_FR_HEADER_SIZE - 1u))
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   303      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   304        RetVal = E_NOT_OK;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   305      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   306      /* Not enough space in Pdu */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   307      else
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   308      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   309        /* Add zero length frame at the end, if needed */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   310        Xcp_FrFinishFrame(PduId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   311        /* Block TxPdu */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   312        XCP_BLOCK_PDU(PduId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   313        /* Call transmit function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   314        if (FrIf_Transmit(Xcp_FrCfgConst.TxPduCfg[PduId].FrIfPduId, TxPduPtr) != E_OK)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   315        {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   316          /* Transmit error -> empty PDU */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   317          XCP_EMPTY_PDU(PduId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   318          RetVal = E_NOT_OK;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   319          /* Increase DET counter */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   320          XCP_DEBUG_CTR_INC(Xcp_FrCfgCleared.Xcp_Debug_FrTxFrIfErrorCtr[XcpFrTransportLayerId]);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   321        }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   322        /* Transmit OK */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   323        else
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   324        {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   325          /* Get next Pdu */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   326          PduId = Xcp_FrGetFreeTxPduId(XcpPacketType, XcpFrTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   327          /* Pdu found? */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   328          if (PduId != XCP_PDU_ID_UNKNOWN)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   329          {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   330            /* Get pointer to TxPdu */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   331            TxPduPtr = &Xcp_FrCfgCleared.TxPdu[PduId];
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   332            /* Insert XcpHeader and get new PduLength */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   333            PduLengthLocal = Xcp_FrInsertHeader(PduId, XcpFrTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   334  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   335            /* Check if enough space in Pdu */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   336            if ((PduLengthLocal + 1u + XcpPacketPtr->SduLength) <= Xcp_FrCfgConst.TxPduCfg[PduId].PduSize_u8)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   337            {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   338              /* Store length before XcpPacket (LEN) */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   339              TxPduPtr->SduDataPtr[PduLengthLocal] = (uint8)XcpPacketPtr->SduLength;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   340              /* Copy data to PduBuffer buffer */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   341              /* MR12 DIR 1.1 VIOLATION: The input parameters of rba_BswSrv_MemCopy() are declared as (void*) for generic implementation of MemCopy. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   342              Xcp_MemCopy(&(TxPduPtr->SduDataPtr[PduLengthLocal+1u]), XcpPacketPtr->SduDataPtr, XcpPacketPtr->SduLength);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   343              /* Update length of Pdu */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   344              TxPduPtr->SduLength = ((PduLengthLocal + 1u + XcpPacketPtr->SduLength) | XCP_FR_ALIGNMENT_MASK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   345            }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   346            else
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   347            {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   348              RetVal = E_NOT_OK;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   349            }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   350          }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   351          else
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   352          {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   353            RetVal = Xcp_FrNoFreeTxPduId(XcpPacketType, XcpFrTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   354          }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   355        }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   356      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   357    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   358    else
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   359    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   360      RetVal = Xcp_FrNoFreeTxPduId(XcpPacketType, XcpFrTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   361    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   362  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   363  #else   /* XCP_FR_FRAME_CONCATENATION == STD_OFF */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   364  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   365    /* Pdu found? */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   366    if ( (PduId != XCP_PDU_ID_UNKNOWN)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   367      && ((XCP_FR_HEADER_SIZE + XcpPacketPtr->SduLength) <= Xcp_FrCfgConst.TxPduCfg[PduId].PduSize_u8) )  /* Check if enough space in Pdu */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   368    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   369      /* Get pointer to TxPdu */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   370      TxPduPtr = &Xcp_FrCfgCleared.TxPdu[PduId];
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   371      /* Insert XcpHeader and get new PduLength */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   372      PduLengthLocal = Xcp_FrInsertHeader(PduId, XcpFrTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   373      /* Copy data to PduBuffer buffer */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   374      /* MR12 DIR 1.1 VIOLATION: The input parameters of rba_BswSrv_MemCopy() are declared as (void*) for generic implementation of MemCopy. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   375      Xcp_MemCopy(&(TxPduPtr->SduDataPtr[PduLengthLocal+1u]), XcpPacketPtr->SduDataPtr, XcpPacketPtr->SduLength);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   376      /* Update length of Pdu */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   377      TxPduPtr->SduLength = PduLengthLocal + 1u + XcpPacketPtr->SduLength;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   378      /* Block TxPdu */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   379      XCP_BLOCK_PDU(PduId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   380      /* Call transmit function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   381      if (FrIf_Transmit(Xcp_FrCfgConst.TxPduCfg[PduId].FrIfPduId, TxPduPtr) != E_OK)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   382      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   383        /* Transmit error -> empty PDU */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   384        XCP_EMPTY_PDU(PduId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   385        /* Error */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   386        RetVal = E_NOT_OK;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   387        /* Increase DET counter */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   388        XCP_DEBUG_CTR_INC(Xcp_FrCfgCleared.Xcp_Debug_FrTxFrIfErrorCtr[XcpFrTransportLayerId]);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   389      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   390    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   391    else
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   392    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   393      RetVal = Xcp_FrNoFreeTxPduId(XcpPacketType, XcpFrTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   394    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   395  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   396  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   397    /* Return */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   398    return RetVal;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   399  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   400  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   401  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   402  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   403  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   404  This function is called by the lower layers when an AUTOSAR XCP PDU has been transmitted
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   405  \param[in]  XcpTxPduId  PduId that has been transmitted
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   406  \return     none
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   407  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   408  void Xcp_FrIfTxConfirmation(PduIdType XcpTxPduId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   409  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   410    /*--- DET reporting ----------------------------------------------------------------------------*/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   411    /* If Xcp is uninitialized, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   412    XCP_DET_REPORT_ERROR((Xcp_GlobalNoInit.InitStatus_u8 != XCP_INIT), XCP_TX_CONFIRMATION_SID, XCP_E_NOT_INITIALIZED);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   413    /* If Invalid TxPduId, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   414    XCP_DET_REPORT_ERROR((XcpTxPduId >= XCP_FR_NUMBER_OF_TX_PDUS), XCP_TX_CONFIRMATION_SID, XCP_E_INVALID_PDUID);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   415    /* TxConfirmation called without previous Transmit, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   416    XCP_DET_REPORT_ERROR((XCP_IS_PDU_BLOCKED(XcpTxPduId) == FALSE), XCP_TX_CONFIRMATION_SID, XCP_E_UNEXPECTED_FUNCTION_CALL);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   417    /*--- / DET reporting --------------------------------------------------------------------------*/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   418  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   419    /* Unblock Pdu and release PduBuffer */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   420    XCP_EMPTY_PDU(XcpTxPduId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   421  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   422  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   423  #define XCP_STOP_SEC_CODE_FAST
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   424  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   425  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   426  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   427  #define XCP_START_SEC_CODE
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   428  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   429  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   430  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   431  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   432  Xcp main function for transmission on Transport Layer
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   433  \param[in]  -
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   434  \return     -
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   435  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   436  /* HIS METRIC LEVEL VIOLATION IN Xcp_FrMainFunctionTx: Function contains several necessary if statements. HIS metric compliance would decrease readability and maintainability. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   437  void Xcp_FrMainFunctionTx(void)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   438  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   439    uint8 i;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   440  #if (XCP_FR_FRAME_CONCATENATION == STD_ON)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   441    Xcp_PduIdType PduId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   442  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   443  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   444    /* Check if at least one FR transport layer is connected */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   445    if (Xcp_FrCfgNoInit.ConnectedTLCtr_u8 > 0)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   446    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   447      /* Check all FlexRay transport layers */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   448      for (i = 0 ; i < XCP_FR_NUMBER_OF_TRANSPORT_LAYERS ; i++)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   449      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   450        /* Anything to transmit? */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   451        while ( (Xcp_FrCfgCleared.TxPacketPtr[i].SduLength != 0u)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   452  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   453             /* was transmit successful? */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   454             /* MR12 RULE 13.5 VIOLATION: Conditions are evaluated from left to right. The function call is only done if the first condition is TRUE - this is intended behavior; Redesign not possible as while loop and not if - change would decrease maintainability and increase runtime */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   455             && (Xcp_FrTransmitInMainfunction(&(Xcp_FrCfgCleared.TxPacketPtr[i]), i) == E_OK)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   456  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   457              )
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   458        {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   459          Xcp_FrCfgCleared.TxPacketPtr[i].SduLength = 0;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   460          /* MR12 RULE 2.2 VIOLATION: XCP_*_TRANSPORT_LAYER_INDEX_OFFSET changes depending on the configuration thus the calculation is necessary if the value is not 0 (0 raises the MISRA violation) */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   461          Xcp_TxConfirmation(i + XCP_FR_TRANSPORT_LAYER_INDEX_OFFSET);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   462        }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   463      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   464  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   465  #if (XCP_FR_FRAME_CONCATENATION == STD_ON)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   466  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   467      /* Check all Pdus */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   468      for (PduId = 0 ; PduId < XCP_FR_NUMBER_OF_TX_PDUS ; PduId++)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   469      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   470        /* Check if there is anything to transmit */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   471        if ( (XCP_IS_PDU_BLOCKED(PduId) == FALSE)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   472          && (Xcp_FrCfgCleared.TxPdu[PduId].SduLength > 1u))
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   473        {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   474          Xcp_FrFinishFrame(PduId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   475          /* Block TxPdu */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   476          XCP_BLOCK_PDU(PduId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   477          /* Call transmit function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   478          if (FrIf_Transmit(Xcp_FrCfgConst.TxPduCfg[PduId].FrIfPduId, &Xcp_FrCfgCleared.TxPdu[PduId]) != E_OK)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   479          {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   480            /* Transmit error -> empty PDU */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   481            XCP_EMPTY_PDU(PduId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   482            /* Increase DET counter */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   483            XCP_DEBUG_CTR_INC(Xcp_FrCfgCleared.Xcp_Debug_FrTxFrIfErrorCtr[Xcp_FrCfgConst.TxPduCfg[PduId].TLId_u8]);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   484          }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   485        }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   486      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   487  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   488  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   489    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   490  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   491  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   492  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   493  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   494  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   495  Within this API, the upper layer module (called module) shall copy its data into the buffer provided
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   496  by PduInfoPtr->SduDataPtr and update the length of the actual copied data in PduInfoPtr->SduLength.
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   497  \param[in]  TxPduId     PduId that is requested to be transmitted
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   498  \param[in]  PduInfoPtr  Pointer to XcpPacket (with Length and data pointer)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   499  \return     status of the transmit request
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   500  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   501  Std_ReturnType Xcp_FrIfTriggerTransmit(PduIdType TxPduId, PduInfoType* PduInfoPtr)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   502  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   503    /* Local variables */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   504    PduLengthType PduLength;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   505  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   506    /*--- DET reporting ----------------------------------------------------------------------------*/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   507    /* If Xcp is uninitialized, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   508    XCP_DET_REPORT_ERROR_RET((Xcp_GlobalNoInit.InitStatus_u8 != XCP_INIT), XCP_TRIGGER_TRANSMIT_SID, XCP_E_NOT_INITIALIZED, E_NOT_OK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   509    /* If XcpRxPduPtr is NULL_PTR, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   510    XCP_DET_REPORT_ERROR_RET((PduInfoPtr == NULL_PTR), XCP_TRIGGER_TRANSMIT_SID, XCP_E_NULL_POINTER, E_NOT_OK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   511    /* If Invalid TxPduId, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   512    XCP_DET_REPORT_ERROR_RET((TxPduId >= XCP_FR_NUMBER_OF_TX_PDUS), XCP_TRIGGER_TRANSMIT_SID, XCP_E_INVALID_PDUID, E_NOT_OK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   513    /* TriggerTransmit called without previous Transmit, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   514    XCP_DET_REPORT_ERROR_RET((XCP_IS_PDU_BLOCKED(TxPduId) == FALSE), XCP_TRIGGER_TRANSMIT_SID, XCP_E_UNEXPECTED_FUNCTION_CALL, E_NOT_OK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   515    /*--- / DET reporting --------------------------------------------------------------------------*/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   516  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   517    /* Get PduLenth */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   518    PduLength = Xcp_FrCfgCleared.TxPdu[TxPduId].SduLength;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   519    /* Copy whole PduBuffer to FrIf */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   520    /* MR12 DIR 1.1 VIOLATION: The input parameters of rba_BswSrv_MemCopy() are declared as (void*) for generic implementation of MemCopy. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   521    Xcp_MemCopy(PduInfoPtr->SduDataPtr, Xcp_FrCfgCleared.TxPdu[TxPduId].SduDataPtr, PduLength);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   522    /* Copy length of the data */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   523    PduInfoPtr->SduLength = PduLength;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   524    /* Return */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   525    return(E_OK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   526  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   527  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   528  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   529  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   530  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   531  Initialization of the transport layer internal variables
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   532  \param[in]  XcpTransportLayerId   Global Transport Layer Id
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   533  \param[in]  XcpInitStatus         was Xcp already initialized before or not
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   534  \return     -
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   535  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   536  void Xcp_FrInit(uint8 XcpTransportLayerId, uint8 XcpInitStatus)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   537  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   538    /* Local variables */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   539    uint8  XcpFrTransportLayerId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   540    uint32 TLId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   541    uint32 PduId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   542    uint32 Offset;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   543  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   544    XCP_PARAM_UNUSED(XcpInitStatus);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   545  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   546    /* Shift the Transport Layer Id */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   547    /* MR12 RULE 2.2 VIOLATION: XCP_*_TRANSPORT_LAYER_INDEX_OFFSET changes depending on the configuration thus the calculation is necessary if the value is not 0 (0 raises the MISRA violation) */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   548    XcpFrTransportLayerId = XcpTransportLayerId - XCP_FR_TRANSPORT_LAYER_INDEX_OFFSET;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   549  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   550    /* Check if Transport Layer Id is invalid, report to DET and exit the function  */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   551    XCP_DET_REPORT_ERROR((XcpFrTransportLayerId >= XCP_FR_NUMBER_OF_TRANSPORT_LAYERS), XCP_INITIALIZE_SID, XCP_E_INVALID_TRANSPORT_LAYER_ID);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   552  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   553    /*--------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   554      No-init RAM - Initialization only for first time
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   555    --------------------------------------------------------------------------------------------------*/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   556    /* At this time no initialization for No-Init RAM needed
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   557    if (XcpInitStatus == XCP_UNINIT)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   558    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   559    } */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   560  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   561    /*--------------------------------------------------------------------------------------------------
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   562      Cleared RAM - Initialization always necessary
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   563    --------------------------------------------------------------------------------------------------*/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   564  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   565    /* ----- The part below must be executed for all Transport layers together to preserve proper offsets ----- */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   566  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   567  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   568    /* Initialize all transmission Pdus */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   569    Offset = 0;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   570    for (TLId = 0 ; TLId < XCP_FR_NUMBER_OF_TRANSPORT_LAYERS ; TLId++)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   571    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   572      for (PduId = Xcp_FrCfgConst.TlCfg[TLId].TxPduCfgOffset_u8 ; PduId < (Xcp_FrCfgConst.TlCfg[TLId].TxPduCfgOffset_u8 + Xcp_FrCfgConst.TlCfg[TLId].TxPduCfgCount_u8) ; PduId++)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   573      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   574        /* Is FrInit called for this transport layer? */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   575        if (XcpFrTransportLayerId == TLId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   576        {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   577          /* Set pointer of the PduData to proper position in PduBuffer */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   578          Xcp_FrCfgCleared.TxPdu[PduId].SduDataPtr = &(Xcp_FrCfgCleared.TxPduBuffer_au8[Offset]);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   579          /* Fill the buffer with Nax */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   580          Xcp_FrCfgCleared.TxPdu[PduId].SduDataPtr[0] = Xcp_FrCfgConst.TlCfg[TLId].Nax_u8;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   581          /* Set the position just after Nax */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   582          Xcp_FrCfgCleared.TxPdu[PduId].SduLength = 1u;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   583        }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   584        /* Shift offset in the PduBuffer */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   585        Offset += XCP_4BYTE_ALIGN(Xcp_FrCfgConst.TxPduCfg[PduId].PduSize_u8);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   586      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   587    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   588  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   589  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   590  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   591  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   592  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   593  Connect command related handling for the transport layer
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   594  \param[in]  XcpTransportLayerId   Global Transport Layer Id
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   595  \return     -
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   596  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   597  void Xcp_FrConnect(uint8 XcpTransportLayerId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   598  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   599    /* Local variables */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   600    uint32 PduId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   601    uint32 XcpFrTransportLayerId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   602  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   603    /* Shift the Transport Layer Id */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   604    /* MR12 RULE 2.2 VIOLATION: XCP_*_TRANSPORT_LAYER_INDEX_OFFSET changes depending on the configuration thus the calculation is necessary if the value is not 0 (0 raises the MISRA violation) */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   605    XcpFrTransportLayerId = XcpTransportLayerId - XCP_FR_TRANSPORT_LAYER_INDEX_OFFSET;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   606  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   607    /* Check if Transport Layer Id is invalid, report to DET and exit the function  */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   608    XCP_DET_REPORT_ERROR((XcpFrTransportLayerId >= XCP_FR_NUMBER_OF_TRANSPORT_LAYERS), XCP_CONNECT_SID, XCP_E_INVALID_TRANSPORT_LAYER_ID);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   609  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   610    /* Check if transport layer already not connected */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   611    if (Xcp_FrCfgNoInit.Connected_ab[XcpFrTransportLayerId] == FALSE)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   612    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   613      /* Lock interrupts */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   614      SchM_Enter_Xcp_FrTransmit();
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   615      /* Configure all Transmit Pdus */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   616      for (PduId = Xcp_FrCfgConst.TlCfg[XcpFrTransportLayerId].TxPduCfgOffset_u8 ; PduId < (Xcp_FrCfgConst.TlCfg[XcpFrTransportLayerId].TxPduCfgOffset_u8 + Xcp_FrCfgConst.TlCfg[XcpFrTransportLayerId].TxPduCfgCount_u8) ; PduId++)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   617      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   618        /* Set initial allowed packet type */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   619        Xcp_FrCfgNoInit.TxPduType_a[PduId] = Xcp_FrCfgConst.TxPduCfg[PduId].AllowedType;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   620        /* Deactivate Pdu for EV_SERV */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   621        Xcp_FrCfgNoInit.TxPduEvServActivated_ab[PduId] = FALSE;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   622      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   623      /* Set flag that connected */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   624      Xcp_FrCfgNoInit.Connected_ab[XcpFrTransportLayerId] = TRUE;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   625      /* Increase counter of connected transport layers */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   626      Xcp_FrCfgNoInit.ConnectedTLCtr_u8++;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   627      /* Unlock interrupts */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   628      SchM_Exit_Xcp_FrTransmit();
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   629    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   630  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   631  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   632  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   633  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   634  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   635  Disconnects the transport layer
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   636  \param[in]  XcpTransportLayerId   Global Transport Layer Id
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   637  \return     result of disconnect request
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   638  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   639  Std_ReturnType Xcp_FrDisconnect(uint8 XcpTransportLayerId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   640  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   641    /* Local variables */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   642    Std_ReturnType RetVal;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   643    uint32 XcpFrTransportLayerId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   644  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   645    /* Initial values */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   646    RetVal = E_OK;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   647  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   648    /* Shift the Transport Layer Id */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   649    /* MR12 RULE 2.2 VIOLATION: XCP_*_TRANSPORT_LAYER_INDEX_OFFSET changes depending on the configuration thus the calculation is necessary if the value is not 0 (0 raises the MISRA violation) */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   650    XcpFrTransportLayerId = XcpTransportLayerId - XCP_FR_TRANSPORT_LAYER_INDEX_OFFSET;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   651  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   652    /* Check if Transport Layer Id is invalid, report to DET and exit the function  */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   653    XCP_DET_REPORT_ERROR_RET((XcpFrTransportLayerId >= XCP_FR_NUMBER_OF_TRANSPORT_LAYERS), XCP_DISCONNECT_SID, XCP_E_INVALID_TRANSPORT_LAYER_ID, E_NOT_OK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   654  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   655    /* Check if transport layer already connected */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   656    if (Xcp_FrCfgNoInit.Connected_ab[XcpFrTransportLayerId] != FALSE)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   657    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   658      /* All Pdus sent? */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   659      if (Xcp_FrCfgCleared.TxPacketPtr[XcpFrTransportLayerId].SduLength == 0u)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   660      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   661        /* Lock interrupts */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   662        SchM_Enter_Xcp_FrTransmit();
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   663        /* Set flag that disconnected */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   664        Xcp_FrCfgNoInit.Connected_ab[XcpFrTransportLayerId] = FALSE;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   665        /* Decrease counter of connected transport layers */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   666        Xcp_FrCfgNoInit.ConnectedTLCtr_u8--;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   667        /* Unlock interrupts */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   668        SchM_Exit_Xcp_FrTransmit();
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   669      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   670      /* Pdus must be transmitted, not ready to disconnect */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   671      else
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   672      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   673        RetVal = E_NOT_OK;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   674      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   675    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   676    else
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   677    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   678      /* Unexpected case */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   679      XCP_DET_REPORT_ERROR_NO_RET(XCP_DISCONNECT_SID, XCP_E_UNEXPECTED_FUNCTION_CALL);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   680    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   681    return RetVal;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   682  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   683  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   684  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   685  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   686  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   687  This function handles specific Transport Layer Commands
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   688  \param[in]  XcpCmdPacketPtr       Pointer to XcpPacket with received command
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   689  \param[out] XcpResPacketPtr       Pointer to XcpPacket where the response shall be stored
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   690  \param[in]  XcpTransportLayerId   Global Transport Layer Id
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   691  \return     -
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   692  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   693  void Xcp_FrTransportLayerCmd(const PduInfoType* XcpCmdPacketPtr, PduInfoType* XcpResPacketPtr, uint8 XcpTransportLayerId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   694  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   695    uint8 XcpFrTransportLayerId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   696    Xcp_ErrorCode Error;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   697  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   698    /* Shift the Transport Layer Id */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   699    /* MR12 RULE 2.2 VIOLATION: XCP_*_TRANSPORT_LAYER_INDEX_OFFSET changes depending on the configuration thus the calculation is necessary if the value is not 0 (0 raises the MISRA violation) */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   700    XcpFrTransportLayerId = XcpTransportLayerId-XCP_FR_TRANSPORT_LAYER_INDEX_OFFSET;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   701  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   702    /* Check if Transport Layer Id is invalid, report to DET and exit the function  */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   703    XCP_DET_REPORT_ERROR((XcpFrTransportLayerId >= XCP_FR_NUMBER_OF_TRANSPORT_LAYERS), XCP_TRANSPORT_LAYER_CMD_SID, XCP_E_INVALID_TRANSPORT_LAYER_ID);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   704  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   705    /* Default return value if not valid command length */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   706    Error = XCP_ERR_CMD_SYNTAX;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   707  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   708    /* Check TransportLayer Command code */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   709    switch(XcpCmdPacketPtr->SduDataPtr[1])
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   710    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   711      /* Assign/deassign FlexRay LPDU identifiers to buffers */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   712      case XCP_FR_TLCMD_FLX_ASSIGN:
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   713      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   714        /* Check command length */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   715        if (XcpCmdPacketPtr->SduLength >= XCP_CMD_FR_ASSIGN_LENGTH)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   716        {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   717          Error = Xcp_FrTransportLayerCmd_Assign(XcpCmdPacketPtr, XcpFrTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   718        }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   719      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   720      break;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   721  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   722      /* Activate communication of a FlexRay buffer */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   723      case XCP_FR_TLCMD_FLX_ACTIVATE:
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   724      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   725        /* Check command length */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   726        if (XcpCmdPacketPtr->SduLength >= XCP_CMD_FR_ACTIVATE_LENGTH)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   727        {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   728          Error = Xcp_FrTransportLayerCmd_Activate(XcpCmdPacketPtr, XcpFrTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   729        }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   730      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   731      break;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   732  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   733      /* Deactivate communication of a FlexRay buffer */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   734      case XCP_FR_TLCMD_FLX_DEACTIVATE:
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   735      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   736        /* Check command length */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   737        if (XcpCmdPacketPtr->SduLength >= XCP_CMD_FR_DEACTIVATE_LENGTH)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   738        {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   739          Error = Xcp_FrTransportLayerCmd_Deactivate(XcpCmdPacketPtr, XcpFrTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   740        }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   741      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   742      break;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   743  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   744      default:
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   745      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   746        /* If GET/SET_DAQ_BUF shall be implemented, use following function prototypes.
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   747        Error = Xcp_FrTransportLayerCmd_GetDaqBuf(XcpCmdPacketPtr, XcpResPacketPtr, XcpFrTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   748        Error = Xcp_FrTransportLayerCmd_SetDaqBuf(XcpCmdPacketPtr, XcpFrTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   749        */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   750  # if ((XCP_ASAM_MAJOR_VERSION <= 1u) && (XCP_ASAM_MINOR_VERSION <= 2u))
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   751       /* Unknown command */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   752       Error = XCP_ERR_CMD_UNKNOWN;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   753  # else
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   754       /* Unknown subcommand for Xcp 1.3 version and beyond */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   755       Error = XCP_ERR_SUBCMD_UNKNOWN;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   756  # endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   757  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   758      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   759      break;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   760    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   761  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   762    /* Check if no error */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   763    if (Error == XCP_NO_ERROR)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   764    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   765      /* Positive response */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   766      XcpResPacketPtr->SduDataPtr[0] = 0xFFu;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   767      XcpResPacketPtr->SduLength = 1;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   768    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   769    else
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   770    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   771      /* Negative response */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   772      XcpResPacketPtr->SduDataPtr[0] = 0xFEu;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   773      XcpResPacketPtr->SduDataPtr[1] = (uint8) Error;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   774      XcpResPacketPtr->SduLength = 2;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   775    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   776  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   777  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   778  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   779  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   780  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   781  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   782  This function is called by protocol layer to find a XcpTxPduId for a given EventChannel
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   783  \param[in]  XcpPacketId             Type of the packet (1st byte of packets to transmit)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   784  \param[in]  XcpEventChannelNumber   Event channel number (relevant for CAN only)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   785  \param[in]  XcpTransportLayerId     Id if Transport Layer given by Protocol layer
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   786  \return     XcpTxPduId
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   787  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   788  Xcp_PduIdType Xcp_FrGetTxPduId(uint8 XcpPacketId, uint16 XcpEventChannelNumber, uint8 XcpTransportLayerId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   789  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   790    XCP_PARAM_UNUSED(XcpEventChannelNumber);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   791    XCP_PARAM_UNUSED(XcpTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   792    XCP_PARAM_UNUSED(XcpPacketId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   793  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   794    return XCP_PDU_ID_UNKNOWN;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   795  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   796  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   797  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   798  #if ((XCP_RESUME_MODE == STD_ON) && (XCP_SYNCHRONOUS_DATA_ACQUISITION_DAQ == STD_ON))
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   799  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   800  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   801  This function is called to copy transport layer needed data for Resume Mode
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   802  \param[in]  DaqRamPtr             Pointer to Daq RAM address where data is saved
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   803  \param[in]  XcpDaqRamEndPtr       Last DAQ RAM address for requested Protocol Layer
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   804  \param[in]  XcpTransportLayerId   Id if Transport Layer given by Protocol layer
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   805  \return     Error code in case is not enough space to save the data
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   806  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   807  Xcp_ErrorCode Xcp_FrResumeModeData(uint8* DaqRamPtr, const uint8* XcpDaqRamEndPtr, uint8 XcpTransportLayerId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   808  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   809    uint8 XcpFrTransportLayerId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   810    Xcp_ErrorCode Error;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   811  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   812    /* Shift the Transport Layer Id */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   813    /* MR12 RULE 2.2 VIOLATION: XCP_*_TRANSPORT_LAYER_INDEX_OFFSET changes depending on the configuration thus the calculation is necessary if the value is not 0 (0 raises the MISRA violation) */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   814    XcpFrTransportLayerId = XcpTransportLayerId - XCP_FR_TRANSPORT_LAYER_INDEX_OFFSET;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   815  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   816    /* Check if Transport Layer Id is invalid, report to DET and exit the function  */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   817    XCP_DET_REPORT_ERROR_RET((XcpFrTransportLayerId >= XCP_FR_NUMBER_OF_TRANSPORT_LAYERS), XCP_CMD_SID, XCP_E_INVALID_TRANSPORT_LAYER_ID, XCP_ERR_GENERIC);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   818  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   819    Error = XCP_NO_ERROR;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   820    /* If the XcpDaqRamEndPtr is NULL_PTR means that the function is currently used to set back the saved NvM data for the Transport Layer */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   821    if (XcpDaqRamEndPtr != NULL_PTR)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   822    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   823      /* If enough space to Fr transport layer configuration to NvM then copy the data at the given place otherwise return ERR_MEMORY_OVERFLOW */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   824      if ((DaqRamPtr + sizeof(Xcp_FrCfgNoInit.TxPduType_a) + sizeof(Xcp_FrCfgNoInit.TxPduEvServActivated_ab)) <= XcpDaqRamEndPtr)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   825      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   826        /* Copy the configured TxPduType */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   827        /* MR12 DIR 1.1 VIOLATION: The input parameters of rba_BswSrv_MemCopy() are declared as (void*) for generic implementation of MemCopy. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   828        Xcp_MemCopy(DaqRamPtr, &Xcp_FrCfgNoInit.TxPduType_a, sizeof(Xcp_FrCfgNoInit.TxPduType_a));
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   829  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   830        /* Copy the TxPduEvServActivated configuration */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   831        /* MR12 DIR 1.1 VIOLATION: The input parameters of rba_BswSrv_MemCopy() are declared as (void*) for generic implementation of MemCopy. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   832        Xcp_MemCopy(DaqRamPtr + sizeof(Xcp_FrCfgNoInit.TxPduType_a), &Xcp_FrCfgNoInit.TxPduEvServActivated_ab, sizeof(Xcp_FrCfgNoInit.TxPduEvServActivated_ab));
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   833  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   834      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   835      else
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   836      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   837        Error = XCP_ERR_MEMORY_OVERFLOW;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   838      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   839    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   840    else
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   841    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   842      /* Set connected status for Transport Layer */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   843      Xcp_FrCfgNoInit.Connected_ab[XcpFrTransportLayerId] = TRUE;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   844      /* Copy the configured TxPduType */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   845      /* MR12 DIR 1.1 VIOLATION: The input parameters of rba_BswSrv_MemCopy() are declared as (void*) for generic implementation of MemCopy. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   846      Xcp_MemCopy(&Xcp_FrCfgNoInit.TxPduType_a, DaqRamPtr, sizeof(Xcp_FrCfgNoInit.TxPduType_a));
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   847  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   848      /* Copy the TxPduEvServActivated configuration */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   849      /* MR12 DIR 1.1 VIOLATION: The input parameters of rba_BswSrv_MemCopy() are declared as (void*) for generic implementation of MemCopy. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   850      Xcp_MemCopy(&Xcp_FrCfgNoInit.TxPduEvServActivated_ab, DaqRamPtr + sizeof(Xcp_FrCfgNoInit.TxPduType_a), sizeof(Xcp_FrCfgNoInit.TxPduEvServActivated_ab));
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   851  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   852      Xcp_FrCfgNoInit.ConnectedTLCtr_u8++;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   853    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   854  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   855    return Error;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   856  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   857  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   858  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   859  #define XCP_STOP_SEC_CODE
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   860  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   861  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   862  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   863  /***************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   864  * Local functions
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   865  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   866  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   867  #define XCP_START_SEC_CODE_FAST
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   868  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   869  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   870  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   871  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   872  Convert PacketId to PacketType
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   873  \param[in]  XcpPacketId   PacketId of XcpPacket (first byte)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   874  \return     PacketType of given PacketId
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   875  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   876  static Xcp_PacketType_t Xcp_FrPacketId2PacketType(uint8 XcpPacketId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   877  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   878    /* Local variables */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   879    Xcp_PacketType_t RetVal;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   880  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   881    /* Resolve Packet Type from Packet Id */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   882    if (XcpPacketId <= XCP_PACKET_ID_DAQ_MAX)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   883    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   884      RetVal = XCP_PACKET_TYPE_DAQ;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   885    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   886    else
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   887    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   888      RetVal = XcpFrPacketId2PacketType[0xFF-XcpPacketId];
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   889    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   890    return RetVal;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   891  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   892  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   893  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   894  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   895  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   896  Find free Tx Pdu for given Packet Type
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   897  \param[in]  XcpPacketType           Packet Type
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   898  \param[in]  XcpFrTransportLayerId   Local FlexRay Transport Layer Id
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   899  \return     PduId which can be used for transmission, XCP_PDU_ID_UNKNOWN if free Pdu is not found
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   900  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   901  static Xcp_PduIdType Xcp_FrGetFreeTxPduId(Xcp_PacketType_t XcpPacketType, uint8 XcpFrTransportLayerId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   902  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   903    /* Local variables */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   904    Xcp_PduIdType PduId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   905  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   906  #if (XCP_FR_ONLY_ONE_TX_PDU == STD_ON)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   907    XCP_PARAM_UNUSED(XcpPacketType);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   908  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   909    /* Initial value */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   910    PduId = XCP_PDU_ID_UNKNOWN;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   911  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   912    /* Check if is not reserved for Tx */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   913    if (XCP_IS_PDU_BLOCKED(Xcp_FrCfgConst.TlCfg[XcpFrTransportLayerId].TxPduCfgOffset_u8) == FALSE)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   914    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   915      PduId = Xcp_FrCfgConst.TlCfg[XcpFrTransportLayerId].TxPduCfgOffset_u8;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   916    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   917  #else
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   918    const uint8 PduFirst = Xcp_FrCfgConst.TlCfg[XcpFrTransportLayerId].TxPduCfgOffset_u8;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   919    const uint8 PduLast  = Xcp_FrCfgConst.TlCfg[XcpFrTransportLayerId].TxPduCfgOffset_u8 + Xcp_FrCfgConst.TlCfg[XcpFrTransportLayerId].TxPduCfgCount_u8;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   920    uint8 i;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   921  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   922    /* Initial value */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   923    PduId = XCP_PDU_ID_UNKNOWN;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   924  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   925    /* Search for Pdu with requested type */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   926    /* MR12 RULE 15.4 VIOLATION: more than one break is needed to avoid additional local breakloop variable  */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   927    for (i = PduFirst ; i < PduLast ; i++)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   928    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   929      /* Allowed type? */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   930      if ( ((Xcp_FrCfgNoInit.TxPduType_a[i] & XcpPacketType) == XcpPacketType)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   931      /* Is Pdu available? */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   932        && (XCP_IS_PDU_BLOCKED(i) == FALSE) )
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   933      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   934        /* EV_SERV needs additional check */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   935        if (XcpPacketType == XCP_PACKET_TYPE_EV_SERV)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   936        {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   937          /* Check if EV_SERV allowed for transmission */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   938          if (Xcp_FrCfgNoInit.TxPduEvServActivated_ab[i] != FALSE)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   939          {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   940            PduId = i;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   941            break;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   942          }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   943        }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   944        /* RES_ERR and DAQ are always allowed */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   945        else
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   946        {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   947          PduId = i;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   948          break;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   949        }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   950      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   951    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   952  #endif /* #if (XCP_FR_ONLY_ONE_TX_PDU == STD_ON) */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   953    return(PduId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   954  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   955  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   956  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   957  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   958  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   959  Function is called if transmission failed. Finds correct return value for Transmit function.
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   960  \param[in]  XcpPacketType           Type of XcpPacket which transmission failed
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   961  \param[in]  XcpFrTransportLayerId   Local FlexRay Transport Layer Id
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   962  \return     status for transmit request
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   963  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   964  static Std_ReturnType Xcp_FrNoFreeTxPduId(Xcp_PacketType_t XcpPacketType, uint8 XcpFrTransportLayerId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   965  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   966    /* Local variables */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   967    Std_ReturnType RetVal;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   968  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   969    XCP_PARAM_UNUSED(XcpFrTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   970    if (XcpPacketType == XCP_PACKET_TYPE_EV_SERV)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   971    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   972      /* Do not inform protocol layer, just don't send the packet */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   973      RetVal = E_OK;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   974      XCP_DEBUG_CTR_INC(Xcp_FrCfgCleared.Xcp_Debug_FrTxEvServPduIgnoredCtr[XcpFrTransportLayerId]);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   975    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   976    else
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   977    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   978      /* Error */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   979      RetVal = E_NOT_OK;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   980      XCP_DEBUG_CTR_INC(Xcp_FrCfgCleared.Xcp_Debug_FrTxNoFreePduCtr[XcpFrTransportLayerId]);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   981    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   982    return RetVal;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   983  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   984  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   985  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   986  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   987  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   988  Generate FlexRay frame header
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   989  \param[in]  XcpTxPduId              Id of Pdu
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   990  \param[in]  XcpFrTransportLayerId   Local FlexRay Transport Layer Id
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   991  \return     Position after the header - 1
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   992  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   993  static PduLengthType Xcp_FrInsertHeader(Xcp_PduIdType XcpTxPduId, uint8 XcpFrTransportLayerId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   994  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   995  #if (XCP_FR_FRAME_CONCATENATION == STD_ON)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   996    /* In case of frame concatenation, header shall be added if Pdu is empty */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   997    if (Xcp_FrCfgCleared.TxPdu[XcpTxPduId].SduLength == 1u)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   998  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	   999    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1000  #if (XCP_FR_SEQUENCE_CORRECTION == STD_OFF)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1001      XCP_PARAM_UNUSED(XcpFrTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1002  #else
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1003      /* Set value of the counter (always in second byte)*/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1004      Xcp_FrCfgCleared.TxPdu[XcpTxPduId].SduDataPtr[1] = Xcp_FrCfgNoInit.TxCounter_au8[XcpFrTransportLayerId];
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1005      /* Update counter */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1006      Xcp_FrCfgNoInit.TxCounter_au8[XcpFrTransportLayerId]++;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1007  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1008      /* Set position where length (LEN) will be stored (1 byte before XcpPacket starts) */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1009      Xcp_FrCfgCleared.TxPdu[XcpTxPduId].SduLength = XCP_FR_HEADER_SIZE - 1u;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1010    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1011    return (Xcp_FrCfgCleared.TxPdu[XcpTxPduId].SduLength);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1012  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1013  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1014  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1015  #if (XCP_FR_FRAME_CONCATENATION == STD_ON)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1016  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1017  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1018  Finish FlexRay frame
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1019  \param[in]  XcpTxPduId  Id of Pdu
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1020  \return     -
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1021  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1022  static void Xcp_FrFinishFrame(Xcp_PduIdType XcpTxPduId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1023  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1024    /* Local variables */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1025    PduLengthType PduLengthLocal;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1026  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1027    /* Get PduLength */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1028    PduLengthLocal = Xcp_FrCfgCleared.TxPdu[XcpTxPduId].SduLength;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1029  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1030    /* Can next packet length (LEN) be inserted? */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1031    if (PduLengthLocal < Xcp_FrCfgConst.TxPduCfg[XcpTxPduId].PduSize_u8)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1032    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1033      /* Set next packet length (LEN) to 0 */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1034      Xcp_FrCfgCleared.TxPdu[XcpTxPduId].SduDataPtr[PduLengthLocal] = 0;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1035      /* LEN shall also be transmitted --> Add 1 to PduLength */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1036      Xcp_FrCfgCleared.TxPdu[XcpTxPduId].SduLength = PduLengthLocal + 1u;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1037    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1038    else
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1039    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1040      /* Reduce to maximum Pdu length */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1041      Xcp_FrCfgCleared.TxPdu[XcpTxPduId].SduLength = Xcp_FrCfgConst.TxPduCfg[XcpTxPduId].PduSize_u8;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1042    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1043  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1044  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1045  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1046  #define XCP_STOP_SEC_CODE_FAST
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1047  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1048  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1049  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1050  #define XCP_START_SEC_CODE
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1051  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1052  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1053  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1054  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1055  This function handles specific Transport Layer Command: ASSIGN FlexRay LPDU identifiers to buffers
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1056  \param[in]  XcpCmdPacketPtr         Pointer to XcpPacket with received command
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1057  \param[in]  XcpFrTransportLayerId   Local FlexRay Transport Layer Id
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1058  \return     Response error code or XCP_NO_ERROR
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1059  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1060  static Xcp_ErrorCode Xcp_FrTransportLayerCmd_Assign(const PduInfoType* XcpCmdPacketPtr, uint8 XcpFrTransportLayerId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1061  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1062    /* MR12 RULE 11.5, 1.1 VIOLATION: This function is called with data (a PDU) from the CanIf/FrIf/EthIf which ensure 4-Byte-Alignment.
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1063                                      The cast allows easier (= safer) access to the data in the PDU.
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1064                                      Casting over void* is necessary as otherwise some compilers complain */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1065    const Xcp_CmdFrAssign_t* const CmdPtr = (const Xcp_CmdFrAssign_t*) (void*) XcpCmdPacketPtr->SduDataPtr;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1066    Xcp_ErrorCode Error;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1067    Xcp_PduIdType PduId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1068  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1069    XCP_PARAM_UNUSED(XcpFrTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1070  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1071    /* Initial value */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1072    Error = XCP_ERR_OUT_OF_RANGE;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1073  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1074    /* Check if valid FlexRay buffer number - Reception PDU */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1075    if (CmdPtr->FlxBuf_u8 < XCP_FR_NUMBER_OF_RX_PDUS)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1076    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1077      /* Get PduId */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1078      PduId = CmdPtr->FlxBuf_u8;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1079  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1080      /* Check if new buffer type is allowed (Reconfiguration allowed & given Type allowed) */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1081      if (   ((Xcp_FrCfgConst.RxPduCfg[PduId].AllowedType & XCP_PACKET_TYPE_VARIABLE) == XCP_PACKET_TYPE_VARIABLE)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1082          && ((Xcp_FrCfgConst.RxPduCfg[PduId].AllowedType & CmdPtr->PacketType_u8)    == CmdPtr->PacketType_u8)   )
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1083      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1084        /* OK */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1085        Error = XCP_NO_ERROR;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1086      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1087    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1088    /* Check if valid FlexRay buffer number - Transmission PDU */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1089    /* else if not possible because of HIS metric LEVEL compliance */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1090    if ((CmdPtr->FlxBuf_u8 >= XCP_FR_NUMBER_OF_RX_PDUS) && (CmdPtr->FlxBuf_u8 < (XCP_FR_NUMBER_OF_RX_PDUS + XCP_FR_NUMBER_OF_TX_PDUS)))
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1091    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1092      PduId = CmdPtr->FlxBuf_u8 - XCP_FR_NUMBER_OF_RX_PDUS;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1093  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1094      /* Check if new buffer type is allowed (Reconfiguration allowed & given Type allowed) */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1095      if (   ((Xcp_FrCfgConst.TxPduCfg[PduId].AllowedType & XCP_PACKET_TYPE_VARIABLE) == XCP_PACKET_TYPE_VARIABLE)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1096          && ((Xcp_FrCfgConst.TxPduCfg[PduId].AllowedType & CmdPtr->PacketType_u8)    == CmdPtr->PacketType_u8)   )
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1097      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1098        /* Update buffer type */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1099        Xcp_FrCfgNoInit.TxPduType_a[PduId] = (Xcp_PacketType_t)CmdPtr->PacketType_u8;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1100        /* Deactivate Pdu for EV_SERV */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1101        Xcp_FrCfgNoInit.TxPduEvServActivated_ab[PduId] = FALSE;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1102        /* OK */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1103        Error = XCP_NO_ERROR;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1104      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1105    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1106    /* Check if reset for all VARIABLE FlexRay buffer shall be done */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1107    /* else if not possible because of HIS metric LEVEL compliance */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1108    if ((CmdPtr->FlxBuf_u8 == 0xFFu) && (CmdPtr->PacketType_u8 == 0x00u))
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1109    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1110      /* Lock interrupts */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1111      SchM_Enter_Xcp_FrTransmit();
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1112      /* Reset all VARIABLE buffers to their initial states */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1113      for (PduId = Xcp_FrCfgConst.TlCfg[XcpFrTransportLayerId].TxPduCfgOffset_u8; PduId < (Xcp_FrCfgConst.TlCfg[XcpFrTransportLayerId].TxPduCfgOffset_u8 + Xcp_FrCfgConst.TlCfg[XcpFrTransportLayerId].TxPduCfgCount_u8); PduId++)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1114      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1115        /* Is it VARIABLE buffer? */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1116        if ((Xcp_FrCfgConst.TxPduCfg[PduId].AllowedType & XCP_PACKET_TYPE_VARIABLE) == XCP_PACKET_TYPE_VARIABLE)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1117        {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1118          /* Set type initial state */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1119          Xcp_FrCfgNoInit.TxPduType_a[PduId] = Xcp_FrCfgConst.TxPduCfg[PduId].AllowedType;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1120          /* Deactivate Pdu for EV_SERV */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1121          Xcp_FrCfgNoInit.TxPduEvServActivated_ab[PduId] = FALSE;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1122        }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1123      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1124      /* Unlock interrupts */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1125      SchM_Exit_Xcp_FrTransmit();
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1126      /* OK */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1127      Error = XCP_NO_ERROR;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1128    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1129    else
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1130    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1131      /* Error = XCP_ERR_OUT_OF_RANGE already set */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1132    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1133    /* Return Error Code */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1134    return(Error);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1135  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1136  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1137  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1138  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1139  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1140  This function handles specific Transport Layer Command: ACTIVATE EV_SERV Pdus of a FlexRay buffer
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1141  \param[in]  XcpCmdPacketPtr         Pointer to XcpPacket with received command
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1142  \param[in]  XcpFrTransportLayerId   Local FlexRay Transport Layer Id
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1143  \return     Response error code or XCP_NO_ERROR
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1144  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1145  static Xcp_ErrorCode Xcp_FrTransportLayerCmd_Activate(const PduInfoType* XcpCmdPacketPtr, uint8 XcpFrTransportLayerId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1146  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1147    /* MR12 RULE 11.5, 1.1 VIOLATION: This function is called with data (a PDU) from the CanIf/FrIf/EthIf which ensure 4-Byte-Alignment.
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1148                                      The cast allows easier (= safer) access to the data in the PDU.
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1149                                      Casting over void* is necessary as otherwise some compilers complain */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1150    const Xcp_CmdFrActivate_t* const CmdPtr = (const Xcp_CmdFrActivate_t*) (void*) XcpCmdPacketPtr->SduDataPtr;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1151    Xcp_ErrorCode Error;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1152    Xcp_PduIdType PduId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1153  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1154    XCP_PARAM_UNUSED(XcpFrTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1155  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1156    /* Initial value */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1157    Error = XCP_ERR_OUT_OF_RANGE;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1158  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1159    /* Check if valid FlexRay buffer number - Transmission PDU */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1160    if ( (CmdPtr->FlxBuf_u8 >= XCP_FR_NUMBER_OF_RX_PDUS)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1161      && (CmdPtr->FlxBuf_u8 < (XCP_FR_NUMBER_OF_RX_PDUS + XCP_FR_NUMBER_OF_TX_PDUS))
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1162       )
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1163    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1164      /* Shift the PduId to match in the TxPdus array */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1165      PduId = CmdPtr->FlxBuf_u8 - XCP_FR_NUMBER_OF_RX_PDUS;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1166      /* Check if EV_SERV - only for that type this command is valid */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1167      if (   ((Xcp_FrCfgConst.TxPduCfg[PduId].AllowedType & XCP_PACKET_TYPE_VARIABLE) == XCP_PACKET_TYPE_VARIABLE)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1168          && ((Xcp_FrCfgNoInit.TxPduType_a[PduId] & XCP_PACKET_TYPE_EV_SERV) == XCP_PACKET_TYPE_EV_SERV))
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1169      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1170        /* Activate Pdu for EV_SERV */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1171        Xcp_FrCfgNoInit.TxPduEvServActivated_ab[PduId] = TRUE;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1172        /* OK */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1173        Error = XCP_NO_ERROR;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1174      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1175    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1176    /* Return Error Code */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1177    return(Error);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1178  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1179  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1180  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1181  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1182  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1183  This function handles specific Transport Layer Command: DEACTIVATE EV_SERV Pdus of a FlexRay buffer
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1184  \param[in]  XcpCmdPacketPtr         Pointer to XcpPacket with received command
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1185  \param[in]  XcpFrTransportLayerId   Local FlexRay Transport Layer Id
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1186  \return     Response error code or XCP_NO_ERROR
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1187  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1188  static Xcp_ErrorCode Xcp_FrTransportLayerCmd_Deactivate(const PduInfoType* XcpCmdPacketPtr, uint8 XcpFrTransportLayerId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1189  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1190    /* MR12 RULE 11.5, 1.1 VIOLATION: This function is called with data (a PDU) from the CanIf/FrIf/EthIf which ensure 4-Byte-Alignment.
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1191                                      The cast allows easier (= safer) access to the data in the PDU.
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1192                                      Casting over void* is necessary as otherwise some compilers complain */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1193    const Xcp_CmdFrDeactivate_t* const CmdPtr = (const Xcp_CmdFrDeactivate_t*) (void*) XcpCmdPacketPtr->SduDataPtr;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1194    Xcp_ErrorCode Error;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1195    Xcp_PduIdType PduId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1196  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1197    XCP_PARAM_UNUSED(XcpFrTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1198  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1199    /* Initial value */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1200    Error = XCP_ERR_OUT_OF_RANGE;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1201  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1202    /* Check if valid FlexRay buffer number - Transmission PDU */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1203    if ( (CmdPtr->FlxBuf_u8 >= XCP_FR_NUMBER_OF_RX_PDUS)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1204      && (CmdPtr->FlxBuf_u8 < (XCP_FR_NUMBER_OF_RX_PDUS + XCP_FR_NUMBER_OF_TX_PDUS))
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1205       )
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1206    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1207      /* Shift the PduId to match in the TxPdus array */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1208      PduId = CmdPtr->FlxBuf_u8 - XCP_FR_NUMBER_OF_RX_PDUS;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1209      /* Check if EV_SERV - only for that type this command is valid */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1210      if (   ((Xcp_FrCfgConst.TxPduCfg[PduId].AllowedType & XCP_PACKET_TYPE_VARIABLE) == XCP_PACKET_TYPE_VARIABLE)
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1211          && ((Xcp_FrCfgNoInit.TxPduType_a[PduId] & XCP_PACKET_TYPE_EV_SERV) == XCP_PACKET_TYPE_EV_SERV))
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1212      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1213        /* Deactivate Pdu for EV_SERV */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1214        Xcp_FrCfgNoInit.TxPduEvServActivated_ab[PduId] = FALSE;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1215        /* OK */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1216        Error = XCP_NO_ERROR;
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1217      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1218    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1219    /* Return Error Code */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1220    return(Error);
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1221  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1222  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1223  #define XCP_STOP_SEC_CODE
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1224  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1225  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1226  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1227  #endif /* #if (XCP_ON_FLEXRAY_ENABLED == STD_ON) */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1228  /* HIS METRIC COMF VIOLATION IN XcpOnFr.c: If Xcp on Flexray is disabled, this file is empty. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1229  
; BSW\src\BSW\Gen\Xcp\src\XcpOnFr.c	  1230  

	; Module end
