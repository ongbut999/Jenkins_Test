	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 19053136 SN 09001910"
	.compiler_invocation	"ctc -f cc15444a -c99 --integer-enumeration -D__CPU__=tc27x -D__CPU_TC27X__ --core=tc1.6.x --eabi-compliant --fp-model=-float -D_TASKING_C_TRICORE_=1 -I.\\output\\inc -g2 -t4 --language=-comments,-gcc,+volatile,-strings --default-near-size=0 -O2ROPYGKLF-predict --default-a1-size=0 --default-a0-size=0 --source --switch=auto -o output\\objs\\BSW\\src\\BSW\\Gen\\Xcp\\XcpOnEth.src BSW\\src\\BSW\\Gen\\Xcp\\src\\XcpOnEth.c"
	.compiler_name		"ctc"
	;source	'BSW\\src\\BSW\\Gen\\Xcp\\src\\XcpOnEth.c'

	
$TC16X
	
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L3:
	.word	13514
	.half	3
	.word	.L4
	.byte	4
.L2:
	.byte	1
	.byte	'BSW\\src\\BSW\\Gen\\Xcp\\src\\XcpOnEth.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L5
	.byte	2,1,3
	.word	134
	.byte	4
	.byte	'__codeptr',0,1,1,1
	.word	136
	.byte	5
	.byte	'char',0,1,6,4
	.byte	'sint8',0,2,76,25
	.word	159
	.byte	5
	.byte	'unsigned char',0,1,8,4
	.byte	'uint8',0,2,81,25
	.word	181
	.byte	5
	.byte	'unsigned short int',0,2,7,4
	.byte	'uint16',0,2,91,25
	.word	212
	.byte	5
	.byte	'unsigned int',0,4,7,4
	.byte	'uint32',0,2,106,24
	.word	249
	.byte	5
	.byte	'unsigned long long int',0,8,7,4
	.byte	'uint64',0,2,111,30
	.word	280
	.byte	4
	.byte	'boolean',0,2,127,25
	.word	181
	.byte	4
	.byte	'StatusType',0,3,191,1,27
	.word	181
	.byte	4
	.byte	'Std_ReturnType',0,3,199,1,15
	.word	181
	.byte	6,3,206,1,9,8,7
	.byte	'vendorID',0
	.word	212
	.byte	2,2,35,0,7
	.byte	'moduleID',0
	.word	212
	.byte	2,2,35,2,7
	.byte	'sw_major_version',0
	.word	181
	.byte	1,2,35,4,7
	.byte	'sw_minor_version',0
	.word	181
	.byte	1,2,35,5,7
	.byte	'sw_patch_version',0
	.word	181
	.byte	1,2,35,6,0,4
	.byte	'Std_VersionInfoType',0,3,213,1,3
	.word	381
	.byte	4
	.byte	'PduIdType',0,4,22,19
	.word	212
	.byte	4
	.byte	'PduLengthType',0,4,26,19
	.word	212
	.byte	8,5,113,9,4,9
	.byte	'TP_DATACONF',0,0,9
	.byte	'TP_DATARETRY',0,1,9
	.byte	'TP_CONFPENDING',0,2,0,4
	.byte	'TpDataStateType',0,5,118,3
	.word	571
	.byte	8,6,225,1,9,4,9
	.byte	'XCP_STATE_DISCONNECTED',0,0,9
	.byte	'XCP_STATE_DISCONNECTING',0,1,9
	.byte	'XCP_STATE_CONNECTED',0,2,9
	.byte	'XCP_STATE_RESUME',0,3,9
	.byte	'XCP_STATE_DISABLED',0,240,1,0,4
	.byte	'Xcp_State_t',0,6,231,1,2
	.word	647
	.byte	4
	.byte	'Xcp_AddrValue',0,6,165,3,23
	.word	249
	.byte	6,6,168,3,9,8,7
	.byte	'AddrValue',0
	.word	249
	.byte	4,2,35,0,7
	.byte	'Extension',0
	.word	181
	.byte	1,2,35,4,0,4
	.byte	'Xcp_AddrType_t',0,6,172,3,3
	.word	812
	.byte	4
	.byte	'Xcp_PduIdType',0,6,174,3,15
	.word	181
	.byte	8,6,177,3,9,4,9
	.byte	'XCP_ERR_CMD_SYNCH',0,0,9
	.byte	'XCP_ERR_CMD_BUSY',0,16,9
	.byte	'XCP_ERR_DAQ_ACTIVE',0,17,9
	.byte	'XCP_ERR_PGM_ACTIVE',0,18,9
	.byte	'XCP_ERR_CMD_UNKNOWN',0,32,9
	.byte	'XCP_ERR_CMD_SYNTAX',0,33,9
	.byte	'XCP_ERR_OUT_OF_RANGE',0,34,9
	.byte	'XCP_ERR_WRITE_PROTECTED',0,35,9
	.byte	'XCP_ERR_ACCESS_DENIED',0,36,9
	.byte	'XCP_ERR_ACCESS_LOCKED',0,37,9
	.byte	'XCP_ERR_PAGE_NOT_VALID',0,38,9
	.byte	'XCP_ERR_MODE_NOT_VALID',0,39,9
	.byte	'XCP_ERR_SEGMENT_NOT_VALID',0,40,9
	.byte	'XCP_ERR_SEQUENCE',0,41,9
	.byte	'XCP_ERR_DAQ_CONFIG',0,42,9
	.byte	'XCP_ERR_MEMORY_OVERFLOW',0,48,9
	.byte	'XCP_ERR_GENERIC',0,49,9
	.byte	'XCP_ERR_VERIFY',0,50,9
	.byte	'XCP_ERR_RES_TEMP_NOT_ACCESS',0,51,9
	.byte	'XCP_ERR_SUBCMD_UNKNOWN',0,52,9
	.byte	'XCP_REPEAT_COMMAND',0,252,1,9
	.byte	'XCP_NO_ACCESS_HIDE',0,253,1,9
	.byte	'XCP_NO_RESPONSE',0,254,1,9
	.byte	'XCP_NO_ERROR',0,255,1,0,4
	.byte	'Xcp_ErrorCode',0,6,204,3,2
	.word	904
	.byte	8,6,207,3,9,4,9
	.byte	'XCP_DAQ_STATE_NO_DAQ',0,0,9
	.byte	'XCP_DAQ_STATE_FREE_DAQ',0,1,9
	.byte	'XCP_DAQ_STATE_ALLOC_DAQ',0,2,9
	.byte	'XCP_DAQ_STATE_ALLOC_ODT',0,3,9
	.byte	'XCP_DAQ_STATE_ALLOC_ODT_ENTRY',0,4,9
	.byte	'XCP_DAQ_STATE_WRITE_DAQ',0,5,9
	.byte	'XCP_DAQ_STATE_PREPARE_START',0,6,9
	.byte	'XCP_DAQ_STATE_SHIFTING',0,7,9
	.byte	'XCP_DAQ_STATE_STOP_REQUESTED',0,8,9
	.byte	'XCP_DAQ_STATE_READY_TO_RUN',0,9,9
	.byte	'XCP_DAQ_STATE_RUNNING',0,10,0,4
	.byte	'Xcp_DaqState_t',0,6,220,3,2
	.word	1468
	.byte	8,6,223,3,9,4,9
	.byte	'XCP_DAQ_NO_OVERLOAD_INDICATION',0,0,9
	.byte	'XCP_DAQ_OVERLOAD_INDICATION_PID',0,1,9
	.byte	'XCP_DAQ_OVERLOAD_INDICATION_EVENT',0,2,0,4
	.byte	'Xcp_Overload_t',0,6,228,3,2
	.word	1796
	.byte	8,6,233,3,9,4,9
	.byte	'XCP_IDENTIFICATION_FIELD_TYPE_ABSOLUTE',0,1,9
	.byte	'XCP_IDENTIFICATION_FIELD_TYPE_RELATIVE_BYTE',0,2,9
	.byte	'XCP_IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD',0,3,9
	.byte	'XCP_IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD_ALIGNED',0,4,0,4
	.byte	'Xcp_IdField_t',0,6,239,3,2
	.word	1930
	.byte	8,6,242,3,9,4,9
	.byte	'XCP_ODT_OPTIMIZATION_OM_DEFAULT',0,0,9
	.byte	'XCP_ODT_OPTIMIZATION_OM_ODT_TYPE_16',0,1,9
	.byte	'XCP_ODT_OPTIMIZATION_OM_ODT_TYPE_32',0,2,9
	.byte	'XCP_ODT_OPTIMIZATION_OM_ODT_TYPE_64',0,3,9
	.byte	'XCP_ODT_OPTIMIZATION_OM_ODT_TYPE_ALIGNMENT',0,4,9
	.byte	'XCP_ODT_OPTIMIZATION_OM_MAX_ENTRY_SIZE',0,5,0,4
	.byte	'Xcp_OdtOptimizationType_t',0,6,250,3,2
	.word	2147
	.byte	8,6,253,3,9,4,9
	.byte	'XCP_CONSISTENCY_ODT',0,0,9
	.byte	'XCP_CONSISTENCY_DAQ',0,1,9
	.byte	'XCP_CONSISTENCY_EVENT',0,2,9
	.byte	'XCP_CONSISTENCY_NONE',0,3,0,4
	.byte	'Xcp_Consistency_t',0,6,131,4,2
	.word	2423
	.byte	8,6,134,4,9,4,9
	.byte	'XCP_TIMESTAMP_TYPE_NO_TIME_STAMP',0,0,9
	.byte	'XCP_TIMESTAMP_TYPE_ONE_BYTE',0,1,9
	.byte	'XCP_TIMESTAMP_TYPE_TWO_BYTE',0,2,9
	.byte	'XCP_TIMESTAMP_TYPE_FOUR_BYTE',0,4,0,4
	.byte	'Xcp_Timestamp_t',0,6,140,4,2
	.word	2548
	.byte	10,8
	.word	181
	.byte	11,7,0,6,6,174,4,9,12,7
	.byte	'Buffer_au8',0
	.word	2706
	.byte	8,2,35,0,7
	.byte	'Length_u32',0
	.word	249
	.byte	4,2,35,8,0,4
	.byte	'Xcp_Cto8_t',0,6,178,4,2
	.word	2715
	.byte	3
	.word	181
	.byte	6,5,71,9,8,7
	.byte	'SduDataPtr',0
	.word	2782
	.byte	4,2,35,0,7
	.byte	'SduLength',0
	.word	212
	.byte	2,2,35,4,0,12
	.word	2787
	.byte	3
	.word	2832
	.byte	13
	.word	181
	.byte	1,1,14
	.word	2837
	.byte	14
	.word	181
	.byte	14
	.word	181
	.byte	0,3
	.word	2842
	.byte	15,1,1,14
	.word	181
	.byte	14
	.word	181
	.byte	0,3
	.word	2870
	.byte	15,1,1,14
	.word	181
	.byte	0,3
	.word	2889
	.byte	13
	.word	181
	.byte	1,1,14
	.word	181
	.byte	0,3
	.word	2903
	.byte	3
	.word	2787
	.byte	15,1,1,14
	.word	2837
	.byte	14
	.word	2921
	.byte	14
	.word	181
	.byte	0,3
	.word	2926
	.byte	13
	.word	181
	.byte	1,1,14
	.word	181
	.byte	14
	.word	212
	.byte	14
	.word	181
	.byte	0,3
	.word	2950
	.byte	6,7,164,1,9,56,7
	.byte	'TLTransmit_pfct',0
	.word	2865
	.byte	4,2,35,0,7
	.byte	'TLInit_pfct',0
	.word	2884
	.byte	4,2,35,4,7
	.byte	'TLConnect_pfct',0
	.word	2898
	.byte	4,2,35,8,7
	.byte	'TLDisconnect_pfct',0
	.word	2916
	.byte	4,2,35,12,7
	.byte	'TLTransportLayerCmd_pfct',0
	.word	2945
	.byte	4,2,35,16,7
	.byte	'TLGetTxPduId_pfct',0
	.word	2973
	.byte	4,2,35,20,7
	.byte	'MaxCto_u8',0
	.word	181
	.byte	1,2,35,24,7
	.byte	'MaxDto_u16',0
	.word	212
	.byte	2,2,35,26,7
	.byte	'TimestampType_en',0
	.word	2548
	.byte	4,2,35,28,7
	.byte	'IdFieldType_en',0
	.word	1930
	.byte	4,2,35,32,7
	.byte	'OverloadType_en',0
	.word	1796
	.byte	4,2,35,36,7
	.byte	'OdtOptimizationType_en',0
	.word	2147
	.byte	4,2,35,40,7
	.byte	'Consistency_en',0
	.word	2423
	.byte	4,2,35,44,7
	.byte	'PdRam_u32',0
	.word	249
	.byte	4,2,35,48,7
	.byte	'EdRam_u32',0
	.word	249
	.byte	4,2,35,52,0,4
	.byte	'Xcp_PL_TL_Cfg_t',0,7,184,1,2
	.word	2978
	.byte	8,7,188,1,9,4,9
	.byte	'XCP_RAMSECTION_INVALID',0,0,9
	.byte	'XCP_RAMSECTION_PD',0,1,9
	.byte	'XCP_RAMSECTION_ED',0,2,0,4
	.byte	'Xcp_RamSectionType_t',0,7,193,1,2
	.word	3376
	.byte	6,7,195,1,9,12,7
	.byte	'DaqRamPtr_pu8',0
	.word	2782
	.byte	4,2,35,0,7
	.byte	'DaqRamTotalSize_u32',0
	.word	249
	.byte	4,2,35,4,7
	.byte	'RamSectionType_en',0
	.word	3376
	.byte	4,2,35,8,0,4
	.byte	'Xcp_DaqRamSection_Cfg_t',0,7,200,1,2
	.word	3478
	.byte	10,1
	.word	181
	.byte	11,0,0,6,7,203,1,9,8,7
	.byte	'DaqRamFreeSize_u32',0
	.word	249
	.byte	4,2,35,0,7
	.byte	'PLConnected_ab',0
	.word	3597
	.byte	1,2,35,4,0,4
	.byte	'Xcp_DaqRamSections_t',0,7,207,1,2
	.word	3606
	.byte	6,7,230,1,9,4,7
	.byte	'EventChannelDirection_u8',0
	.word	181
	.byte	1,2,35,0,7
	.byte	'EventChannelTimeCycle_u8',0
	.word	181
	.byte	1,2,35,1,7
	.byte	'EventChannelTimeUnit_u8',0
	.word	181
	.byte	1,2,35,2,7
	.byte	'EventChannelPriority_u8',0
	.word	181
	.byte	1,2,35,3,0,4
	.byte	'Xcp_EventChannel_Cfg_t',0,7,236,1,2
	.word	3695
	.byte	4
	.byte	'rba_BswSrv_uint64',0,8,66,28
	.word	280
	.byte	4
	.byte	'Can_IdType',0,9,32,16
	.word	249
	.byte	4
	.byte	'Can_HwHandleType',0,9,43,16
	.word	212
	.byte	6,10,93,9,8,7
	.byte	'Class',0
	.word	181
	.byte	1,2,35,0,7
	.byte	'TIN',0
	.word	181
	.byte	1,2,35,1,7
	.byte	'ReturnAddress',0
	.word	249
	.byte	4,2,35,4,0,4
	.byte	'OsTrapInfoType',0,10,97,3
	.word	3938
	.byte	10,68
	.word	249
	.byte	11,16,0,6,10,154,1,9,68,7
	.byte	'store',0
	.word	4018
	.byte	68,2,35,0,0,10,68
	.word	4027
	.byte	11,0,0,4
	.byte	'Os_JumpBufType',0,10,156,1,3
	.word	4049
	.byte	4
	.byte	'Os_StackTraceType',0,10,174,1,18
	.word	249
	.byte	6,10,175,1,9,8,7
	.byte	'sp',0
	.word	249
	.byte	4,2,35,0,7
	.byte	'ctx',0
	.word	249
	.byte	4,2,35,4,0,4
	.byte	'Os_StackValueType',0,10,175,1,63
	.word	4109
	.byte	4
	.byte	'Os_StackSizeType',0,10,176,1,27
	.word	4109
	.byte	16,1,1,3
	.word	4194
	.byte	4
	.byte	'Os_VoidVoidFunctionType',0,10,179,1,16
	.word	4197
	.byte	4
	.byte	'ApplicationType',0,10,193,1,23
	.word	181
	.byte	17
	.byte	'Os_ApplicationConfigurationType_s',0,10,198,1,16,2,7
	.byte	'app_id',0
	.word	181
	.byte	1,2,35,0,7
	.byte	'access',0
	.word	181
	.byte	1,2,35,1,0,4
	.byte	'Os_ApplicationConfigurationType',0,10,201,1,3
	.word	4260
	.byte	4
	.byte	'Os_CoreStateType',0,10,203,1,16
	.word	249
	.byte	4
	.byte	'AreaIdType',0,10,204,1,16
	.word	212
	.byte	4
	.byte	'Os_PeripheralAddressType',0,10,212,1,22
	.word	249
	.byte	4
	.byte	'TickType',0,10,221,1,22
	.word	249
	.byte	4
	.byte	'Os_StopwatchTickType',0,10,225,1,22
	.word	249
	.byte	3
	.word	249
	.byte	4
	.byte	'Os_Lockable',0,10,234,1,18
	.word	4502
	.byte	4
	.byte	'CoreIdType',0,10,236,1,16
	.word	212
	.byte	4
	.byte	'SpinlockIdType',0,10,237,1,16
	.word	212
	.byte	8,10,239,1,9,4,9
	.byte	'TRYTOGETSPINLOCK_SUCCESS',0,0,9
	.byte	'TRYTOGETSPINLOCK_NOSUCCESS',0,1,0,4
	.byte	'TryToGetSpinlockType',0,10,239,1,74
	.word	4572
	.byte	8,10,174,2,9,4,9
	.byte	'APPLICATION_ACCESSIBLE',0,0,9
	.byte	'APPLICATION_RESTARTING',0,1,9
	.byte	'APPLICATION_TERMINATED',0,2,0,4
	.byte	'ApplicationStateType',0,10,174,2,92
	.word	4665
	.byte	18
	.byte	'void',0,3
	.word	4777
	.byte	15,1,1,14
	.word	181
	.byte	14
	.word	4783
	.byte	0,3
	.word	4788
	.byte	4
	.byte	'Os_FunctionEntryType',0,10,183,2,16
	.word	4802
	.byte	17
	.byte	'Os_MeterInfoType_s',0,10,193,2,16,48,7
	.byte	'elapsed',0
	.word	249
	.byte	4,2,35,0,7
	.byte	'previous',0
	.word	249
	.byte	4,2,35,4,7
	.byte	'max',0
	.word	249
	.byte	4,2,35,8,7
	.byte	'cumulative',0
	.word	249
	.byte	4,2,35,12,7
	.byte	'stackbase',0
	.word	4109
	.byte	8,2,35,16,7
	.byte	'stackusage',0
	.word	4109
	.byte	8,2,35,24,7
	.byte	'stackmax',0
	.word	4109
	.byte	8,2,35,32,7
	.byte	'stackbudget',0
	.word	4109
	.byte	8,2,35,40,0,4
	.byte	'Os_MeterInfoType',0,10,202,2,3
	.word	4837
	.byte	3
	.word	4837
	.byte	4
	.byte	'Os_MeterInfoRefType',0,10,203,2,50
	.word	5035
	.byte	4
	.byte	'EventMaskType',0,10,206,2,15
	.word	181
	.byte	4
	.byte	'Os_imaskType',0,10,211,2,16
	.word	249
	.byte	17
	.byte	'Os_ISRDynType_s',0,10,213,2,16,48,7
	.byte	'meter',0
	.word	4837
	.byte	48,2,35,0,0,4
	.byte	'Os_ISRDynType',0,10,215,2,3
	.word	5114
	.byte	3
	.word	5114
	.byte	12
	.word	5175
	.byte	17
	.byte	'Os_ISRType_s',0,10,216,2,16,24,7
	.byte	'entry_function',0
	.word	4202
	.byte	4,2,35,0,7
	.byte	'dynamic',0
	.word	5180
	.byte	4,2,35,4,7
	.byte	'imask',0
	.word	249
	.byte	4,2,35,8,7
	.byte	'stackbudget',0
	.word	4109
	.byte	8,2,35,12,7
	.byte	'access',0
	.word	181
	.byte	1,2,35,20,7
	.byte	'application',0
	.word	181
	.byte	1,2,35,21,0,4
	.byte	'Os_ISRType',0,10,223,2,3
	.word	5185
	.byte	3
	.word	4194
	.byte	12
	.word	5185
	.byte	3
	.word	5344
	.byte	4
	.byte	'ISRType',0,10,224,2,46
	.word	5349
	.byte	4
	.byte	'Os_bitmask',0,10,239,2,22
	.word	249
	.byte	4
	.byte	'Os_pset0Type',0,10,240,2,20
	.word	249
	.byte	4
	.byte	'Os_pset1Type',0,10,241,2,20
	.word	249
	.byte	4
	.byte	'Os_pset2Type',0,10,242,2,20
	.word	249
	.byte	19,10,243,2,9,4,7
	.byte	'p0',0
	.word	249
	.byte	4,2,35,0,7
	.byte	'p1',0
	.word	249
	.byte	4,2,35,0,7
	.byte	'p2',0
	.word	249
	.byte	4,2,35,0,0,4
	.byte	'Os_psetType',0,10,247,2,3
	.word	5457
	.byte	19,10,249,2,9,4,7
	.byte	't0',0
	.word	249
	.byte	4,2,35,0,7
	.byte	't1',0
	.word	249
	.byte	4,2,35,0,7
	.byte	't2',0
	.word	249
	.byte	4,2,35,0,0,4
	.byte	'Os_tpmaskType',0,10,253,2,3
	.word	5521
	.byte	4
	.byte	'Os_ActivationCountType',0,10,254,2,23
	.word	181
	.byte	17
	.byte	'Os_TaskDynType_s',0,10,128,3,16,120,7
	.byte	'terminate_jump_buf',0
	.word	4058
	.byte	68,2,35,0,7
	.byte	'meter',0
	.word	4837
	.byte	48,2,35,68,7
	.byte	'activation_count',0
	.word	181
	.byte	1,2,35,116,0,4
	.byte	'Os_TaskDynType',0,10,132,3,3
	.word	5619
	.byte	10,68
	.word	4027
	.byte	11,0,0,3
	.word	5619
	.byte	12
	.word	5745
	.byte	17
	.byte	'Os_TaskType_s',0,10,134,3,16,40,7
	.byte	'dynamic',0
	.word	5750
	.byte	4,2,35,0,7
	.byte	'entry_function',0
	.word	4202
	.byte	4,2,35,4,7
	.byte	'pset',0
	.word	5457
	.byte	4,2,35,8,7
	.byte	'base_tpmask',0
	.word	5521
	.byte	4,2,35,12,7
	.byte	'tpmask',0
	.word	5521
	.byte	4,2,35,16,7
	.byte	'core_id',0
	.word	212
	.byte	2,2,35,20,7
	.byte	'index',0
	.word	249
	.byte	4,2,35,24,7
	.byte	'stackbudget',0
	.word	4109
	.byte	8,2,35,28,7
	.byte	'activation_count',0
	.word	181
	.byte	1,2,35,36,7
	.byte	'access',0
	.word	181
	.byte	1,2,35,37,7
	.byte	'application',0
	.word	181
	.byte	1,2,35,38,0,4
	.byte	'Os_TaskType',0,10,146,3,3
	.word	5755
	.byte	12
	.word	5755
	.byte	3
	.word	6005
	.byte	4
	.byte	'TaskType',0,10,147,3,47
	.word	6010
	.byte	20
	.byte	'Os_TaskStateType',0,10,155,3,6,4,9
	.byte	'SUSPENDED',0,0,9
	.byte	'READY',0,1,9
	.byte	'WAITING',0,2,9
	.byte	'RUNNING',0,3,0,4
	.byte	'TaskStateType',0,10,156,3,31
	.word	6033
	.byte	19,10,167,3,3,4,7
	.byte	'tpmask',0
	.word	5521
	.byte	4,2,35,0,0,17
	.byte	'Os_ResourceDynType_s',0,10,166,3,16,4,7
	.byte	'saved_priority',0
	.word	6120
	.byte	4,2,35,0,0,4
	.byte	'Os_ResourceDynType',0,10,170,3,3
	.word	6143
	.byte	3
	.word	6143
	.byte	12
	.word	6223
	.byte	17
	.byte	'Os_ResourceType_s',0,10,171,3,16,12,7
	.byte	'dynamic',0
	.word	6228
	.byte	4,2,35,0,7
	.byte	'tpmask',0
	.word	5521
	.byte	4,2,35,4,7
	.byte	'access',0
	.word	181
	.byte	1,2,35,8,0,4
	.byte	'Os_ResourceType',0,10,175,3,3
	.word	6233
	.byte	6,10,181,3,9,12,7
	.byte	'maxallowedvalue',0
	.word	249
	.byte	4,2,35,0,7
	.byte	'ticksperbase',0
	.word	249
	.byte	4,2,35,4,7
	.byte	'mincycle',0
	.word	249
	.byte	4,2,35,8,0,4
	.byte	'AlarmBaseType',0,10,185,3,3
	.word	6332
	.byte	6,10,206,3,9,8,7
	.byte	'Running',0
	.word	181
	.byte	1,2,35,0,7
	.byte	'Pending',0
	.word	181
	.byte	1,2,35,1,7
	.byte	'Delay',0
	.word	249
	.byte	4,2,35,4,0,4
	.byte	'Os_CounterStatusType',0,10,210,3,3
	.word	6427
	.byte	21
	.word	181
	.byte	1,1,3
	.word	6513
	.byte	4
	.byte	'Os_CounterIncrAdvType',0,10,217,3,22
	.word	6520
	.byte	17
	.byte	's_swd',0,10,222,3,12,4,7
	.byte	'count',0
	.word	249
	.byte	4,2,35,0,0,19,10,221,3,3,4,7
	.byte	'sw',0
	.word	6556
	.byte	4,2,35,0,0,17
	.byte	'Os_CounterDynType_s',0,10,220,3,16,4,7
	.byte	'type_dependent',0
	.word	6584
	.byte	4,2,35,0,0,4
	.byte	'Os_CounterDynType',0,10,226,3,3
	.word	6603
	.byte	3
	.word	6603
	.byte	12
	.word	6681
	.byte	17
	.byte	'Os_CounterType_s',0,10,227,3,16,28,7
	.byte	'dynamic',0
	.word	6686
	.byte	4,2,35,0,7
	.byte	'advincr',0
	.word	6525
	.byte	4,2,35,4,7
	.byte	'base',0
	.word	6332
	.byte	12,2,35,8,7
	.byte	'core',0
	.word	4783
	.byte	4,2,35,20,7
	.byte	'access',0
	.word	181
	.byte	1,2,35,24,7
	.byte	'application',0
	.word	181
	.byte	1,2,35,25,0,4
	.byte	'Os_CounterType',0,10,234,3,3
	.word	6691
	.byte	3
	.word	6513
	.byte	12
	.word	6691
	.byte	3
	.word	6843
	.byte	4
	.byte	'CounterType',0,10,235,3,52
	.word	6848
	.byte	20
	.byte	'Os_ScheduleTableStatusType',0,10,240,3,6,4,9
	.byte	'SCHEDULETABLE_STOPPED',0,0,9
	.byte	'SCHEDULETABLE_NEXT',0,1,9
	.byte	'SCHEDULETABLE_WAITING',0,2,9
	.byte	'SCHEDULETABLE_RUNNING',0,3,9
	.byte	'SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS',0,4,0,4
	.byte	'ScheduleTableStatusType',0,10,241,3,41
	.word	6874
	.byte	12
	.word	.L6-.L3
	.byte	3
	.word	7074
	.byte	4
	.byte	'ScheduleTableType',0,10,128,4,58
	.word	7079
	.byte	17
	.byte	'Os_ScheduleTableDynType_s',0,10,130,4,16,16,7
	.byte	'match',0
	.word	249
	.byte	4,2,35,0,7
	.byte	'next',0
	.word	7084
	.byte	4,2,35,4,7
	.byte	'state',0
	.word	6874
	.byte	4,2,35,8,7
	.byte	'config',0
	.word	212
	.byte	2,2,35,12,0,3
	.word	7111
	.byte	12
	.word	7204
.L6:
	.byte	17
	.byte	'Os_ScheduleTableType_s',0,10,247,3,16,16,7
	.byte	'dynamic',0
	.word	7209
	.byte	4,2,35,0,7
	.byte	'counter',0
	.word	6853
	.byte	4,2,35,4,7
	.byte	'repeat',0
	.word	181
	.byte	1,2,35,8,7
	.byte	'config',0
	.word	212
	.byte	2,2,35,10,7
	.byte	'initial',0
	.word	181
	.byte	1,2,35,12,7
	.byte	'access',0
	.word	181
	.byte	1,2,35,13,7
	.byte	'application',0
	.word	181
	.byte	1,2,35,14,0,4
	.byte	'Os_ScheduleTableType',0,10,255,3,3
	.word	7214
	.byte	12
	.word	7214
	.byte	3
	.word	7394
	.byte	12
	.word	6691
	.byte	3
	.word	7404
	.byte	22
	.word	4507
	.byte	22
	.word	5457
	.byte	22
	.word	5354
	.byte	22
	.word	6015
	.byte	22
	.word	5521
	.byte	22
	.word	181
	.byte	22
	.word	6015
	.byte	17
	.byte	'Os_ControlledCoreType_s',0,10,251,6,16,112,7
	.byte	'TrapInfo',0
	.word	3938
	.byte	8,2,35,0,7
	.byte	'lock_taskaccess',0
	.word	7414
	.byte	4,2,35,8,7
	.byte	'ReadyTasks',0
	.word	7419
	.byte	4,2,35,12,7
	.byte	'RunningISR',0
	.word	7424
	.byte	4,2,35,16,7
	.byte	'RunningTask',0
	.word	7429
	.byte	4,2,35,20,7
	.byte	'RunningTPMask',0
	.word	7434
	.byte	4,2,35,24,7
	.byte	'CurrentMeteredObject',0
	.word	5040
	.byte	4,2,35,28,7
	.byte	'IdleMeter',0
	.word	4837
	.byte	48,2,35,32,7
	.byte	'AppAccess',0
	.word	181
	.byte	1,2,35,80,7
	.byte	'AppOverride',0
	.word	7439
	.byte	1,2,35,81,7
	.byte	'GetStackValueAdjust',0
	.word	4109
	.byte	8,2,35,84,7
	.byte	'InErrorHook',0
	.word	181
	.byte	1,2,35,92,7
	.byte	'ChainTaskRef',0
	.word	7444
	.byte	4,2,35,96,7
	.byte	'GetStackUsageAdjust',0
	.word	4109
	.byte	8,2,35,100,7
	.byte	'InProtectionHook',0
	.word	181
	.byte	1,2,35,108,7
	.byte	'CoreIsActive',0
	.word	181
	.byte	1,2,35,109,7
	.byte	'InShutdownHook',0
	.word	181
	.byte	1,2,35,110,0,4
	.byte	'Os_ControlledCoreType',0,10,141,7,3
	.word	7449
	.byte	3
	.word	249
	.byte	12
	.word	5185
	.byte	3
	.word	7905
	.byte	12
	.word	5755
	.byte	3
	.word	7915
	.byte	3
	.word	4837
	.byte	17
	.byte	'Os_AnyCoreType_s',0,10,151,7,16,96,7
	.byte	'DisableAllImask',0
	.word	249
	.byte	4,2,35,0,7
	.byte	'SuspendAllImask',0
	.word	249
	.byte	4,2,35,4,7
	.byte	'SuspendOSImask',0
	.word	249
	.byte	4,2,35,8,7
	.byte	'DisableAllCount',0
	.word	249
	.byte	4,2,35,12,7
	.byte	'SuspendAllCount',0
	.word	249
	.byte	4,2,35,16,7
	.byte	'SuspendOSCount',0
	.word	249
	.byte	4,2,35,20,7
	.byte	'RestartJumpBuf',0
	.word	4058
	.byte	68,2,35,24,7
	.byte	'Restartable',0
	.word	181
	.byte	1,2,35,92,0,4
	.byte	'Os_AnyCoreType',0,10,160,7,3
	.word	7930
	.byte	4
	.byte	'Can_TxObjPriorityClassType',0,11,219,3,16
	.word	249
	.byte	17
	.byte	'Can_TxHwObjectConfigType',0,11,231,3,16,8,7
	.byte	'MsgObjId',0
	.word	181
	.byte	1,2,35,0,7
	.byte	'HwControllerId',0
	.word	181
	.byte	1,2,35,1,7
	.byte	'TxObjPriorityClass',0
	.word	249
	.byte	4,2,35,4,0,4
	.byte	'Can_TxHwObjectConfigType',0,11,252,3,3
	.word	8207
	.byte	17
	.byte	'Can_RxHwObjectConfigType',0,11,129,4,16,12,7
	.byte	'MaskRef',0
	.word	249
	.byte	4,2,35,0,7
	.byte	'MsgId',0
	.word	249
	.byte	4,2,35,4,7
	.byte	'MsgObjId',0
	.word	181
	.byte	1,2,35,8,7
	.byte	'HwControllerId',0
	.word	181
	.byte	1,2,35,9,0,4
	.byte	'Can_RxHwObjectConfigType',0,11,147,4,3
	.word	8343
	.byte	10,4
	.word	181
	.byte	11,3,0,17
	.byte	'Can_ControllerMOMapConfigType',0,11,181,4,16,4,7
	.byte	'ControllerMOMap',0
	.word	8483
	.byte	4,2,35,0,0,4
	.byte	'Can_ControllerMOMapConfigType',0,11,184,4,3
	.word	8492
	.byte	17
	.byte	'Can_NPCRValueType',0,11,188,4,16,2,7
	.byte	'Can_NPCRValue',0
	.word	212
	.byte	2,2,35,0,0,4
	.byte	'Can_NPCRValueType',0,11,191,4,3
	.word	8593
	.byte	17
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,11,194,4,16,8,7
	.byte	'CanControllerBaudrate',0
	.word	249
	.byte	4,2,35,0,7
	.byte	'CanControllerBaudrateCfg',0
	.word	212
	.byte	2,2,35,4,0,4
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,11,198,4,3
	.word	8668
	.byte	12
	.word	8668
	.byte	3
	.word	8833
	.byte	17
	.byte	'Can_BaudrateConfigPtrType',0,11,201,4,16,4,7
	.byte	'Can_kBaudrateConfigPtr',0
	.word	8838
	.byte	4,2,35,0,0,4
	.byte	'Can_BaudrateConfigPtrType',0,11,204,4,3
	.word	8843
	.byte	17
	.byte	'Can_EventHandlingType',0,11,226,4,16,4,7
	.byte	'CanEventType',0
	.word	8483
	.byte	4,2,35,0,0,4
	.byte	'Can_EventHandlingType',0,11,229,4,3
	.word	8943
	.byte	4
	.byte	'Rte_TransformerErrorCode',0,12,130,1,15
	.word	181
	.byte	4
	.byte	'Rte_TransformerClass',0,12,131,1,15
	.word	181
	.byte	6,12,168,1,9,12,7
	.byte	'in',0
	.word	4783
	.byte	4,2,35,0,7
	.byte	'out',0
	.word	4783
	.byte	4,2,35,4,7
	.byte	'used',0
	.word	212
	.byte	2,2,35,8,7
	.byte	'lost_data',0
	.word	181
	.byte	1,2,35,10,0,4
	.byte	'Rte_QDynType',0,12,173,1,3
	.word	9089
	.byte	8,12,175,1,9,4,9
	.byte	'RTE_DRA',0,0,9
	.byte	'RTE_WOWP',0,1,9
	.byte	'RTE_TASK',0,2,9
	.byte	'RTE_ARE',0,3,9
	.byte	'RTE_EV',0,4,9
	.byte	'RTE_MSI',0,5,0,4
	.byte	'Rte_NotificationType',0,12,182,1,3
	.word	9176
	.byte	10,128,8
	.word	181
	.byte	11,255,7,0,4
	.byte	'Impl_NVM_DstPtrType_1024',0,13,50,15
	.word	9274
	.byte	4
	.byte	'CanIf_u32_impl',0,13,69,16
	.word	249
	.byte	4
	.byte	'CanIf_u16_impl',0,13,71,16
	.word	212
	.byte	4
	.byte	'CanIf_u8_impl',0,13,73,15
	.word	181
	.byte	4
	.byte	'CanIf_ControllerModeType_Enum_impl',0,13,88,15
	.word	181
	.byte	4
	.byte	'CanIf_PduModeType_Enum_impl',0,13,90,15
	.word	181
	.byte	6,13,92,9,2,7
	.byte	'DeviceMode',0
	.word	181
	.byte	1,2,35,0,7
	.byte	'ChannelMode',0
	.word	181
	.byte	1,2,35,1,0,4
	.byte	'CanIf_ControllerStateType_struct_impl',0,13,95,3
	.word	9465
	.byte	4
	.byte	'CanIf_NotifStatusType_Enum_impl',0,13,100,15
	.word	181
	.byte	4
	.byte	'CanSM_boolean_Impl',0,13,120,15
	.word	181
	.byte	4
	.byte	'CanSM_u8_Impl',0,13,123,15
	.word	181
	.byte	4
	.byte	'CanSM_BusOffRecoveryStateType_Enum_impl',0,13,128,1,15
	.word	181
	.byte	4
	.byte	'CanSM_NetworkModeStateType_Enum_impl',0,13,132,1,15
	.word	181
	.byte	4
	.byte	'CanSM_u16_Impl',0,13,136,1,16
	.word	212
	.byte	4
	.byte	'CanSM_TimerStateType_Enum_impl',0,13,138,1,15
	.word	181
	.byte	6,13,140,1,9,4,7
	.byte	'cntTick_u16',0
	.word	212
	.byte	2,2,35,0,7
	.byte	'stTimer',0
	.word	181
	.byte	1,2,35,2,0,4
	.byte	'CanSM_TimerConfig_tst_struct_impl',0,13,143,1,3
	.word	9806
	.byte	4
	.byte	'Com_impl_u16',0,13,154,1,16
	.word	212
	.byte	4
	.byte	'Com_impl_u8',0,13,157,1,15
	.word	181
	.byte	4
	.byte	'ComM_uint32_Impl',0,13,173,1,16
	.word	249
	.byte	4
	.byte	'ComM_uint16_Impl',0,13,175,1,16
	.word	212
	.byte	4
	.byte	'ComM_uint8_Impl',0,13,177,1,15
	.word	181
	.byte	4
	.byte	'ComM_bool_Impl',0,13,179,1,15
	.word	181
	.byte	6,13,181,1,9,24,7
	.byte	'ChannelState_e',0
	.word	249
	.byte	4,2,35,0,7
	.byte	'LightTimeoutCtr_u32',0
	.word	249
	.byte	4,2,35,4,7
	.byte	'MinFullComTimeoutCtr_u16',0
	.word	212
	.byte	2,2,35,8,7
	.byte	'ChannelMode_u8',0
	.word	181
	.byte	1,2,35,10,7
	.byte	'BusSmMode_u8',0
	.word	181
	.byte	1,2,35,11,7
	.byte	'UserRequestCtr_u8',0
	.word	181
	.byte	1,2,35,12,7
	.byte	'PassiveRequestState_u8',0
	.word	181
	.byte	1,2,35,13,7
	.byte	'PncRequestCtr_u8',0
	.word	181
	.byte	1,2,35,14,7
	.byte	'InhibitionReqStatus_u8',0
	.word	181
	.byte	1,2,35,15,7
	.byte	'NmNetworkRequestStatus_b',0
	.word	181
	.byte	1,2,35,16,7
	.byte	'DiagnosticRequestState_b',0
	.word	181
	.byte	1,2,35,17,7
	.byte	'CommunicationAllowed_b',0
	.word	181
	.byte	1,2,35,18,7
	.byte	'NmBusSleepIndicationStatus_b',0
	.word	181
	.byte	1,2,35,19,7
	.byte	'NmPrepareBusSleepIndicationStatus_b',0
	.word	181
	.byte	1,2,35,20,7
	.byte	'NmNetworkModeStatus_b',0
	.word	181
	.byte	1,2,35,21,0,4
	.byte	'ComM_ChannelStruct_Impl',0,13,197,1,3
	.word	10038
	.byte	6,13,206,1,9,10,7
	.byte	'WakeUpInhibitionCtr_u16',0
	.word	212
	.byte	2,2,35,0,7
	.byte	'LimitToNoComCtr_u16',0
	.word	212
	.byte	2,2,35,2,7
	.byte	'RequestedUserMode_t',0
	.word	181
	.byte	1,2,35,4,7
	.byte	'IndicatedUserMode_t',0
	.word	181
	.byte	1,2,35,5,7
	.byte	'numChannelsInFullCom_u8',0
	.word	181
	.byte	1,2,35,6,7
	.byte	'numChannelsInSilentCom_u8',0
	.word	181
	.byte	1,2,35,7,7
	.byte	'numChannelsInNoCom_u8',0
	.word	181
	.byte	1,2,35,8,0,4
	.byte	'ComM_UserStruct_Impl',0,13,214,1,3
	.word	10542
	.byte	4
	.byte	'Dcm_IOOperationResponseType',0,13,252,1,15
	.word	181
	.byte	4
	.byte	'Dcm_RequestDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspRequestRoutineResultsOutSignal_0PrimitivType',0
	.byte	13,138,2,15
	.word	181
	.byte	4
	.byte	'Dcm_StartDataIn_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineInSignalPrimitivType',0,13,146,2,15
	.word	181
	.byte	4
	.byte	'Dcm_StartDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineOutSignalPrimitivType',0,13,150,2,15
	.word	181
	.byte	4
	.byte	'Dcm_StopDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStopRoutineOutSignalPrimitivType',0,13,154,2,15
	.word	181
	.byte	4
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockNative_1024_Type',0,13,243,3,34
	.word	9285
	.byte	10,128,8
	.word	181
	.byte	11,255,7,0,4
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockRedundant_1024_Type',0,13,246,3,34
	.word	9285
	.byte	8,14,216,1,9,4,9
	.byte	'XCP_BG_IDLE',0,0,9
	.byte	'XCP_BG_CHKSUM',0,1,9
	.byte	'XCP_BG_MEM_WRITE',0,2,9
	.byte	'XCP_BG_REPEAT_CMD',0,3,9
	.byte	'XCP_BG_DO_DISCONNECT',0,4,9
	.byte	'XCP_BG_CANCEL_REQ',0,5,0,4
	.byte	'Xcp_BgActivity_t',0,14,224,1,3
	.word	11360
	.byte	15,1,1,14
	.word	2837
	.byte	14
	.word	181
	.byte	0,3
	.word	11505
	.byte	4
	.byte	'Xcp_CmdFunctionPtr',0,14,230,1,16
	.word	11519
	.byte	6,14,241,1,9,8,7
	.byte	'WritePos_u16',0
	.word	212
	.byte	2,2,35,0,7
	.byte	'ReadPos_u16',0
	.word	212
	.byte	2,2,35,2,7
	.byte	'ReadPos_OdtNum_u16',0
	.word	212
	.byte	2,2,35,4,7
	.byte	'QueSize_u16',0
	.word	212
	.byte	2,2,35,6,0,4
	.byte	'Xcp_Que_t',0,14,247,1,3
	.word	11552
	.byte	6,14,250,1,9,24,7
	.byte	'XcpState_en',0
	.word	647
	.byte	4,2,35,0,7
	.byte	'ConnectedTlId_u8',0
	.word	181
	.byte	1,2,35,4,7
	.byte	'ResourceProtStatus_u8',0
	.word	181
	.byte	1,2,35,5,7
	.byte	'Mta',0
	.word	812
	.byte	8,2,35,8,7
	.byte	'MaxDto_u16',0
	.word	212
	.byte	2,2,35,16,7
	.byte	'MaxDtoAligned_u16',0
	.word	212
	.byte	2,2,35,18,7
	.byte	'MaxCto_u8',0
	.word	181
	.byte	1,2,35,20,0,4
	.byte	'Xcp_Session_t',0,14,138,2,2
	.word	11670
	.byte	6,14,149,2,9,12,7
	.byte	'Buffer_au8',0
	.word	2706
	.byte	8,2,35,0,7
	.byte	'Length_u32',0
	.word	249
	.byte	4,2,35,8,0,4
	.byte	'Xcp_CtoMax_t',0,14,153,2,2
	.word	11857
	.byte	10,255,1
	.word	181
	.byte	11,254,1,0,6,14,157,2,9,132,2,7
	.byte	'UploadRunning_b',0
	.word	181
	.byte	1,2,35,0,7
	.byte	'RemainingSize_u8',0
	.word	181
	.byte	1,2,35,1,7
	.byte	'DownloadSize_u8',0
	.word	181
	.byte	1,2,35,2,7
	.byte	'ReceivedSize_u8',0
	.word	181
	.byte	1,2,35,3,7
	.byte	'DownloadBuffer_au8',0
	.word	11926
	.byte	255,1,2,35,4,0,4
	.byte	'Xcp_Mem_t',0,14,178,2,2
	.word	11937
	.byte	6,14,183,2,9,2,7
	.byte	'SeedWaitingKey_b',0
	.word	181
	.byte	1,2,35,0,7
	.byte	'SeedRemaingSize_u8',0
	.word	181
	.byte	1,2,35,1,0,4
	.byte	'Xcp_SeedAndKey_t',0,14,187,2,2
	.word	12094
	.byte	6,14,192,2,9,4,7
	.byte	'BlockSize_u32',0
	.word	249
	.byte	4,2,35,0,0,4
	.byte	'Xcp_Checksum_t',0,14,198,2,2
	.word	12181
	.byte	6,14,203,2,9,18,7
	.byte	'Xcp_Debug_TransmitOkCtr',0
	.word	212
	.byte	2,2,35,0,7
	.byte	'Xcp_Debug_TransmitNotOkCtr',0
	.word	212
	.byte	2,2,35,2,7
	.byte	'Xcp_Debug_SendResTxConfCtr',0
	.word	212
	.byte	2,2,35,4,7
	.byte	'Xcp_Debug_SendResCtr',0
	.word	212
	.byte	2,2,35,6,7
	.byte	'Xcp_Debug_SendEvTxConfCtr',0
	.word	212
	.byte	2,2,35,8,7
	.byte	'Xcp_Debug_SendEvCtr',0
	.word	212
	.byte	2,2,35,10,7
	.byte	'Xcp_Debug_SendDaqTxConfCtr',0
	.word	212
	.byte	2,2,35,12,7
	.byte	'Xcp_Debug_SendDaqCtr',0
	.word	212
	.byte	2,2,35,14,7
	.byte	'Xcp_Debug_TxConfCtr',0
	.word	212
	.byte	2,2,35,16,0,4
	.byte	'Xcp_Debug_t',0,14,216,2,2
	.word	12235
	.byte	6,14,225,2,9,8,7
	.byte	'OdtEntryPos_u16',0
	.word	212
	.byte	2,2,35,0,7
	.byte	'OdtEntryMax_u16',0
	.word	212
	.byte	2,2,35,2,7
	.byte	'DaqListNum_u16',0
	.word	212
	.byte	2,2,35,4,7
	.byte	'AbsOdtNum_u16',0
	.word	212
	.byte	2,2,35,6,0,4
	.byte	'Xcp_SelectedOdtEntry_t',0,14,231,2,2
	.word	12557
	.byte	6,14,234,2,9,6,7
	.byte	'OdtEntryFirst_u16',0
	.word	212
	.byte	2,2,35,0,7
	.byte	'OdtEntryCnt_u8',0
	.word	181
	.byte	1,2,35,2,7
	.byte	'CopyRoutine_u8',0
	.word	181
	.byte	1,2,35,3,7
	.byte	'Length_u16',0
	.word	212
	.byte	2,2,35,4,0,4
	.byte	'Xcp_Odt_t',0,14,240,2,2
	.word	12693
	.byte	22
	.word	181
	.byte	22
	.word	181
	.byte	6,14,254,2,9,24,7
	.byte	'DaqListQue_p',0
	.word	2782
	.byte	4,2,35,0,7
	.byte	'DaqListQuePos',0
	.word	11552
	.byte	8,2,35,4,7
	.byte	'OdtFirst_u16',0
	.word	212
	.byte	2,2,35,12,7
	.byte	'EventChannelNum_u16',0
	.word	212
	.byte	2,2,35,14,7
	.byte	'OdtCnt_u8',0
	.word	181
	.byte	1,2,35,16,7
	.byte	'XcpTxPduId',0
	.word	181
	.byte	1,2,35,17,7
	.byte	'Prescaler_u8',0
	.word	181
	.byte	1,2,35,18,7
	.byte	'CycleCnt_u8',0
	.word	181
	.byte	1,2,35,19,7
	.byte	'Priority_u8',0
	.word	181
	.byte	1,2,35,20,7
	.byte	'Flags_u8',0
	.word	181
	.byte	1,2,35,21,7
	.byte	'Mode_u8',0
	.word	12814
	.byte	1,2,35,22,7
	.byte	'CurrentlyRunning_b',0
	.word	12819
	.byte	1,2,35,23,0,4
	.byte	'Xcp_DaqList_t',0,14,143,3,2
	.word	12824
	.byte	3
	.word	12824
	.byte	3
	.word	12693
	.byte	3
	.word	249
	.byte	3
	.word	212
	.byte	6,14,146,3,9,56,7
	.byte	'DaqList_p',0
	.word	13116
	.byte	4,2,35,0,7
	.byte	'Odt_p',0
	.word	13121
	.byte	4,2,35,4,7
	.byte	'OdtEntryAddress_p',0
	.word	13126
	.byte	4,2,35,8,7
	.byte	'OdtEntrySize_p',0
	.word	2782
	.byte	4,2,35,12,7
	.byte	'PriorityList_p',0
	.word	13131
	.byte	4,2,35,16,7
	.byte	'DaqQue_p',0
	.word	2782
	.byte	4,2,35,20,7
	.byte	'DaqListCnt_u16',0
	.word	212
	.byte	2,2,35,24,7
	.byte	'OdtCnt_u16',0
	.word	212
	.byte	2,2,35,26,7
	.byte	'OdtEntryCnt_u16',0
	.word	212
	.byte	2,2,35,28,7
	.byte	'SelectedOdtEntry',0
	.word	12557
	.byte	8,2,35,30,7
	.byte	'DaqRamPtr_pu8',0
	.word	2782
	.byte	4,2,35,40,7
	.byte	'DaqRamSize_u32',0
	.word	249
	.byte	4,2,35,44,7
	.byte	'DaqListSendingCnt_u16',0
	.word	212
	.byte	2,2,35,48,7
	.byte	'DaqListSending_u16',0
	.word	212
	.byte	2,2,35,50,7
	.byte	'DaqState_en',0
	.word	1468
	.byte	4,2,35,52,0,4
	.byte	'Xcp_DaqConfig_t',0,14,180,3,2
	.word	13136
	.byte	0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L4:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,21,0,54,15,0,0,3,15,0,73,19,0,0,4,22,0,3,8,58,15,59,15
	.byte	57,15,73,19,0,0,5,36,0,3,8,11,15,62,15,0,0,6,19,1,58,15,59,15,57,15,11,15,0,0,7,13,0,3,8,73,19,11,15,56
	.byte	9,0,0,8,4,1,58,15,59,15,57,15,11,15,0,0,9,40,0,3,8,28,13,0,0,10,1,1,11,15,73,19,0,0,11,33,0,47,15,0,0
	.byte	12,38,0,73,19,0,0,13,21,1,73,19,54,15,39,12,0,0,14,5,0,73,19,0,0,15,21,1,54,15,39,12,0,0,16,21,0,54,15
	.byte	39,12,0,0,17,19,1,3,8,58,15,59,15,57,15,11,15,0,0,18,59,0,3,8,0,0,19,23,1,58,15,59,15,57,15,11,15,0,0
	.byte	20,4,1,3,8,58,15,59,15,57,15,11,15,0,0,21,21,0,73,19,54,15,39,12,0,0,22,53,0,73,19,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L5:
	.word	.L8-.L7
.L7:
	.half	3
	.word	.L10-.L9
.L9:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Xcp\\src\\XcpOnEth.c',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Platform\\Platform_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Std_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Xcp\\api\\Xcp_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Xcp\\Xcp_Cfg.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\rba_BswSrv.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Can_GeneralTypes.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\RTOS_T\\Gen\\inc\\Os.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Can_17_MCanP\\inc\\Can_17_MCanP.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Type.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Xcp\\api\\Xcp_Priv.h',0,0,0,0,0
.L10:
.L8:

; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	     1  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	     2  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	     3  /***************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	     4  * Includes
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	     5  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	     6  #include "Xcp.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	     7  #include "Xcp_Priv.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	     8  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	     9  #if(XCP_ON_ETHERNET_ENABLED == STD_ON)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    10  #include "SoAd.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    11  #include "XcpOnEth_Cfg.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    12  #include "XcpOnEth_Cbk.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    13  #include "XcpOnEth_Types.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    14  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    15  /* Check versions */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    16  #if (!defined(SOAD_AR_RELEASE_MAJOR_VERSION) || (SOAD_AR_RELEASE_MAJOR_VERSION != XCP_AR_RELEASE_MAJOR_VERSION))
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    17  #error "AUTOSAR major version undefined or mismatched"
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    18  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    19  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    20  /***************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    21  * Defines/Macros
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    22  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    23  /* Alignment definitions */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    24  #if (XCP_ETH_PACKET_ALIGNMENT == XCP_ETH_PACKET_ALIGNMENT_16)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    25    #define XCP_ETH_ALIGNMENT_MASK 1u
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    26  #elif (XCP_ETH_PACKET_ALIGNMENT == XCP_ETH_PACKET_ALIGNMENT_32)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    27    #define XCP_ETH_ALIGNMENT_MASK 3u
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    28  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    29  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    30  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    31  /***************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    32  * Type definitions
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    33  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    34  /** XCP on Ethernet socket connection info */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    35  /* MR12 RULE 5.6 VIOLATION: Type declaration is needed only for Xcp on ETH. Declaration in any api will cause compiler errors for projects that use only Xcp on CAN. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    36  typedef struct
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    37  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    38    SoAd_SoConIdType        SoConId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    39    TcpIp_SockAddrInet6Type RemoteIpAddr; /* the Ipv6 type was used because it can accomodate both IPv4 and IPv6 addresses */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    40  } Xcp_SoConInfo_t;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    41  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    42  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    43  /***************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    44  * Variables
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    45  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    46  #define XCP_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    47  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    48  /** Structure with data for Ethernet Transport Layer channels */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    49  static Xcp_TransportLayerEthData_t Xcp_TransportLayerEthData[XCP_ETH_NUMBER_OF_TRANSPORT_LAYERS];
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    50  #if (XCP_ETH_ON_TCP_ENABLED == STD_ON)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    51  /** TCP received data for each Transport Layer. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    52  static Xcp_TcpEthRxData_t Xcp_TcpEthRxData[XCP_ETH_NUMBER_OF_TRANSPORT_LAYERS];
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    53  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    54  #define XCP_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    55  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    56  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    57  #define XCP_START_SEC_VAR_POWER_ON_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    58  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    59  /** Eth XCP packet counter has to stay in protected RAM */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    60  static uint16          Xcp_EthCtr_u16[XCP_ETH_NUMBER_OF_TRANSPORT_LAYERS];
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    61  static Xcp_SoConInfo_t Xcp_SoConData[XCP_ETH_NUMBER_OF_TRANSPORT_LAYERS];
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    62  #define XCP_STOP_SEC_VAR_POWER_ON_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    63  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    64  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    65  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    66  /***************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    67  * Local function declarations
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    68  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    69  #define XCP_START_SEC_CODE_FAST
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    70  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    71  static Std_ReturnType Xcp_EthTransmitInMainfunction(const PduInfoType* XcpPacketPtr, uint8 XcpEthTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    72  /* Function Xcp_EthResetTxBuffer is used for resetting the buffer with XCP message. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    73  static void Xcp_EthResetTxBuffer(uint8 XcpEthTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    74  /* Function Xcp_EthCopyPacketToBuffer will copy the XCP packet to the transmit pointer and attach the XCP header.
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    75    The function is used to avoid same code in multiple places. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    76  static void Xcp_EthCopyPacketToBuffer(const PduInfoType* XcpPacketPtr, uint8 XcpEthTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    77  #define XCP_STOP_SEC_CODE_FAST
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    78  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    79  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    80  #define XCP_START_SEC_CODE
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    81  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    82  /* Function Xcp_EthGetPacketLength for calculating XCP packet length from XCP header. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    83  static PduLengthType Xcp_EthGetPacketLength(const uint8* XcpLengthPtr);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    84  #define XCP_STOP_SEC_CODE
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    85  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    86  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    87  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    88  /***************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    89  * Functions
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    90  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    91  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    92  #define XCP_START_SEC_CODE
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    93  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    94  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    95  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    96  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    97  This function is called by the lower layers when an AUTOSAR XCP PDU has been received
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    98  \param[in]  XcpRxPduId    PduId that has been received
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	    99  \param[in]  XcpRxPduPtr   Pointer to received Pdu
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   100  \return     -
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   101  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   102  /* HIS METRIC LEVEL VIOLATION IN Xcp_SoAdIfRxIndication: Function contains several necessary if statements. HIS metric compliance would decrease readability and maintainability. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   103  void Xcp_SoAdIfRxIndication(PduIdType XcpRxPduId, const PduInfoType* XcpRxPduPtr)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   104  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   105    PduInfoType XcpPacketPtr;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   106    PduLengthType ReadPos;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   107    PduLengthType TLPduLength;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   108    PduLengthType EthPacketLength;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   109    XCP_ADDR_TYPE XcpBufferAligned[(XCP_ETH_RX_PDU_LEN_MAX + (XCP_ADDR_LEN - 1u)) / XCP_ADDR_LEN];
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   110    uint8 TransportLayerId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   111  #if (XCP_ETH_ON_TCP_ENABLED == STD_ON)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   112    uint8 XcpEthTransportLayerId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   113    PduLengthType XcpPacketLength;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   114  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   115  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   116    /*--- DET reporting ----------------------------------------------------------------------------*/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   117    /* If Xcp is uninitialized, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   118    XCP_DET_REPORT_ERROR((Xcp_GlobalNoInit.InitStatus_u8 != XCP_INIT), XCP_RX_INDICATION_SID, XCP_E_NOT_INITIALIZED);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   119    /* If XcpRxPduPtr is NULL_PTR, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   120    XCP_DET_REPORT_ERROR((XcpRxPduPtr == NULL_PTR), XCP_RX_INDICATION_SID, XCP_E_NULL_POINTER);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   121    /* If Invalid RxPduId, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   122    XCP_DET_REPORT_ERROR((XcpRxPduId >= XCP_ETH_NUMBER_OF_RX_PDU), XCP_RX_INDICATION_SID, XCP_E_INVALID_PDUID);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   123    /*--- / DET reporting --------------------------------------------------------------------------*/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   124  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   125    /* Calculate Transport Layer Id and Eth Transport Layer Id. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   126    TransportLayerId = Xcp_TransportLayerConfigEth.RxPduId2TransportLayerId[XcpRxPduId];
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   127    /* Read position inside the received packet. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   128    ReadPos = 0;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   129    /* To avoid writing over the RxBuffer length the length of the RxPdu will be limited to the Transport Layer Rx PduLength. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   130    TLPduLength = XCP_MIN(XcpRxPduPtr->SduLength, XCP_ETH_RX_PDU_LEN_MAX);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   131  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   132  #if (XCP_ETH_ON_TCP_ENABLED == STD_ON)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   133    XcpEthTransportLayerId = (uint8)XcpRxPduId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   134  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   135    if (Xcp_TransportLayerConfigEth.TransportLayerEthConfig[XcpEthTransportLayerId].ProtocolType == XCP_ETH_PROTOCOL_TCP)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   136    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   137      /* Previous message contained only the first byte from XCP packet length. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   138      if (Xcp_TcpEthRxData[XcpEthTransportLayerId].Xcp_CurrentLength == 1u)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   139      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   140        /* Calculate the length of the XCP packet. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   141        Xcp_TcpEthRxData[XcpEthTransportLayerId].Xcp_PacketLength = Xcp_TcpEthRxData[XcpEthTransportLayerId].Xcp_PacketLength + (PduLengthType)((PduLengthType)XcpRxPduPtr->SduDataPtr[0] << 8u) + XCP_ETH_PACKET_HEADER_LEN;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   142      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   143  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   144      /* Previous RxIndication had a segmented data and in the new received segment should be the rest of the XCP packet. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   145      XcpPacketLength = Xcp_TcpEthRxData[XcpEthTransportLayerId].Xcp_PacketLength - Xcp_TcpEthRxData[XcpEthTransportLayerId].Xcp_CurrentLength;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   146  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   147      /* Calculated XCP packet length to be copied is bigger than 0 and not bigger than the buffer length. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   148      if ((XcpPacketLength > 0u) && (Xcp_TcpEthRxData[XcpEthTransportLayerId].Xcp_PacketLength <= (XCP_ETH_TCP_MAX_CTO_DTO + XCP_ETH_PACKET_HEADER_LEN)))
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   149      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   150        if (XcpPacketLength <= TLPduLength)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   151        {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   152          /* This segment contains the complete rest of the XCP packet. Copy the received data in the Rx buffer from the current position. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   153          /* MR12 DIR 1.1 VIOLATION: The input parameters of rba_BswSrv_MemCopy() are declared as (void*) for generic implementation of MemCopy. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   154          Xcp_MemCopy(Xcp_TcpEthRxData[XcpEthTransportLayerId].Xcp_RxBuffer_au32 + Xcp_TcpEthRxData[XcpEthTransportLayerId].Xcp_CurrentLength, XcpRxPduPtr->SduDataPtr, XcpPacketLength);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   155          /* Set the length for the receive packet pointer to complete XCP packet length. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   156          XcpPacketPtr.SduLength = Xcp_TcpEthRxData[XcpEthTransportLayerId].Xcp_PacketLength - XCP_ETH_PACKET_HEADER_LEN;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   157          /* Data pointer points to XCP packet data. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   158          XcpPacketPtr.SduDataPtr = (uint8*)Xcp_TcpEthRxData[XcpEthTransportLayerId].Xcp_RxBuffer_au32 + XCP_ETH_PACKET_HEADER_LEN;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   159          /* Resolve RxPduId to global TransportLayerId and call receive function from protocol layer */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   160          Xcp_Receive(&XcpPacketPtr, TransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   161          /* Reset both packet length and available length. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   162          Xcp_TcpEthRxData[XcpEthTransportLayerId].Xcp_PacketLength = 0;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   163          Xcp_TcpEthRxData[XcpEthTransportLayerId].Xcp_CurrentLength = 0;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   164  #if (XCP_ETH_PACKET_ALIGNMENT == XCP_ETH_PACKET_ALIGNMENT_8)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   165          /* Calculate new read position in received frame in case padding is not required. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   166          ReadPos = XcpPacketLength;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   167  #else
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   168          /* Calculate new read position in received frame in case padding is requred. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   169          ReadPos = XcpPacketLength + ((1u+XCP_ETH_ALIGNMENT_MASK-(XcpPacketPtr.SduLength&XCP_ETH_ALIGNMENT_MASK))&XCP_ETH_ALIGNMENT_MASK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   170  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   171        }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   172        else
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   173        {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   174          /* The received segment doesn't contain the complete XCP packet. Copy the received data in the Rx buffer from the current position. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   175          /* MR12 DIR 1.1 VIOLATION: The input parameters of rba_BswSrv_MemCopy() are declared as (void*) for generic implementation of MemCopy. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   176          Xcp_MemCopy(Xcp_TcpEthRxData[XcpEthTransportLayerId].Xcp_RxBuffer_au32 + Xcp_TcpEthRxData[XcpEthTransportLayerId].Xcp_CurrentLength, XcpRxPduPtr->SduDataPtr, TLPduLength);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   177          /* Increment the current number of bytes received from the XCP packet. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   178          Xcp_TcpEthRxData[XcpEthTransportLayerId].Xcp_CurrentLength = Xcp_TcpEthRxData[XcpEthTransportLayerId].Xcp_CurrentLength + TLPduLength;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   179          /* Calculate new read position in received frame. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   180          ReadPos = TLPduLength;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   181        }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   182      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   183      else
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   184      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   185        /* Reset both packet length and available length. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   186        Xcp_TcpEthRxData[XcpEthTransportLayerId].Xcp_PacketLength = 0;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   187        Xcp_TcpEthRxData[XcpEthTransportLayerId].Xcp_CurrentLength = 0;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   188        XCP_DET_REPORT_ERROR_NO_RET(XCP_RX_INDICATION_SID, XCP_E_DATA_PACKET_NOK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   189      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   190    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   191  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   192  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   193  #if (XCP_ETH_FRAME_CONCATENATION == STD_ON)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   194    while (
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   195  #else
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   196    if (
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   197  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   198        /* Check that the Read Position is not out of bound. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   199        (ReadPos + 1u) < TLPduLength
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   200    )
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   201    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   202      EthPacketLength = Xcp_EthGetPacketLength(&XcpRxPduPtr->SduDataPtr[ReadPos]);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   203      if ((EthPacketLength > 0u) && ((ReadPos + XCP_ETH_PACKET_HEADER_LEN + EthPacketLength) <= TLPduLength))
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   204      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   205        /* Calculate the length of the XCP packet which will be sent to Protocol Layer. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   206        XcpPacketPtr.SduLength = EthPacketLength;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   207        /* XCP command pointer will point to the command start in the initial UDP frame. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   208        XcpPacketPtr.SduDataPtr = XcpRxPduPtr->SduDataPtr + XCP_ETH_PACKET_HEADER_LEN + ReadPos;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   209        /* Align XCP packet to uint32 for protocol layer */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   210        /* MR12 RULE 11.4 VIOLATION: Cast from pointer to XCP_ADDR_TYPE is OK as this type is able to store the address (see type definition) */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   211        if (((XCP_ADDR_TYPE)XcpPacketPtr.SduDataPtr & (XCP_ADDR_LEN - 1u)) != 0u)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   212        {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   213          /* MR12 DIR 1.1 VIOLATION: The input parameters of rba_BswSrv_MemCopy() are declared as (void*) for generic implementation of MemCopy. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   214          Xcp_MemCopy(XcpBufferAligned, XcpPacketPtr.SduDataPtr, XcpPacketPtr.SduLength);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   215          XcpPacketPtr.SduDataPtr = (uint8*)XcpBufferAligned;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   216        }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   217        /* Resolve RxPduId to global TransportLayerId and call receive function from protocol layer */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   218        Xcp_Receive(&XcpPacketPtr, TransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   219  #if (XCP_ETH_PACKET_ALIGNMENT == XCP_ETH_PACKET_ALIGNMENT_8)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   220        /* Calculate new read position in received frame in case padding is not required. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   221        ReadPos = ReadPos + XCP_ETH_PACKET_HEADER_LEN + XcpPacketPtr.SduLength;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   222  #else
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   223        /* Calculate new read position in received frame in case padding is requred. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   224        ReadPos = ReadPos + XCP_ETH_PACKET_HEADER_LEN + XcpPacketPtr.SduLength + ((1u+XCP_ETH_ALIGNMENT_MASK-(XcpPacketPtr.SduLength&XCP_ETH_ALIGNMENT_MASK))&XCP_ETH_ALIGNMENT_MASK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   225  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   226      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   227  #if (XCP_ETH_FRAME_CONCATENATION == STD_ON)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   228      else
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   229      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   230        /* Exit the while loop if no more complete xcp package is inside the ehternet frame. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   231        break;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   232      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   233  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   234    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   235  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   236  #if (XCP_ETH_ON_TCP_ENABLED == STD_ON)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   237    /* TcpIp segment was received and XCP packet is split between two TCP segments. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   238    if (Xcp_TransportLayerConfigEth.TransportLayerEthConfig[XcpEthTransportLayerId].ProtocolType == XCP_ETH_PROTOCOL_TCP)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   239    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   240      if ((ReadPos + 1u) == TLPduLength)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   241      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   242        /* The complete XCP packet length was not received in XCP header. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   243        Xcp_TcpEthRxData[XcpEthTransportLayerId].Xcp_CurrentLength = 1;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   244        Xcp_TcpEthRxData[XcpEthTransportLayerId].Xcp_PacketLength = XcpRxPduPtr->SduDataPtr[ReadPos];
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   245        /* Copy the first byte from XCP packet length. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   246        Xcp_TcpEthRxData[XcpEthTransportLayerId].Xcp_RxBuffer_au32[0] = XcpRxPduPtr->SduDataPtr[ReadPos];
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   247      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   248      else
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   249      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   250        /* Check that the Read Position is not out of bound. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   251        if ((ReadPos + 1u) < TLPduLength)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   252        {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   253          /* Check that in the received segment there are still bytes left after processing and that resulted XCP packet length is not 0. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   254          if ((Xcp_EthGetPacketLength(&XcpRxPduPtr->SduDataPtr[ReadPos]) > 0u))
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   255          {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   256            XcpPacketPtr.SduDataPtr = XcpRxPduPtr->SduDataPtr + ReadPos;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   257            /* XCP packet length extracted from received segment. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   258            Xcp_TcpEthRxData[XcpEthTransportLayerId].Xcp_PacketLength = Xcp_EthGetPacketLength(&XcpRxPduPtr->SduDataPtr[ReadPos]) + XCP_ETH_PACKET_HEADER_LEN;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   259            /* Number of bytes that can be copied from current segment for the XCP packet. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   260            Xcp_TcpEthRxData[XcpEthTransportLayerId].Xcp_CurrentLength = TLPduLength - ReadPos;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   261            /* Copy the available bytes to the RxBuffer. The length must not be bigger than the buffer length. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   262            if (Xcp_TcpEthRxData[XcpEthTransportLayerId].Xcp_CurrentLength <= (XCP_ETH_TCP_MAX_CTO_DTO + XCP_ETH_PACKET_HEADER_LEN))
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   263            {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   264              /* MR12 DIR 1.1 VIOLATION: The input parameters of rba_BswSrv_MemCopy() are declared as (void*) for generic implementation of MemCopy. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   265              Xcp_MemCopy(Xcp_TcpEthRxData[XcpEthTransportLayerId].Xcp_RxBuffer_au32, XcpPacketPtr.SduDataPtr, Xcp_TcpEthRxData[XcpEthTransportLayerId].Xcp_CurrentLength);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   266            }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   267          }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   268        }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   269      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   270    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   271  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   272  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   273  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   274  #define XCP_STOP_SEC_CODE
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   275  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   276  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   277  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   278  #define XCP_START_SEC_CODE_FAST
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   279  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   280  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   281  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   282  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   283  This function is called by protocol layer to transmit XcpPackets
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   284  \param[in]  XcpPacketPtr          Pointer to XcpPacket (with Length and data pointer)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   285  \param[in]  XcpTransportLayerId   Global Transport Layer Id
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   286  \param[in]  XcpTxPduId            XcpTxPduId (relevant for CAN only)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   287  \return     status of the transmit request
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   288  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   289  Std_ReturnType Xcp_EthTransmit(const PduInfoType* XcpPacketPtr, uint8 XcpTransportLayerId, Xcp_PduIdType XcpTxPduId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   290  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   291    /* Local variables */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   292    uint8 XcpEthTransportLayerId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   293    /* Shift the Transport Layer Id */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   294    /* MR12 RULE 2.2 VIOLATION: XCP_*_TRANSPORT_LAYER_INDEX_OFFSET changes depending on the configuration thus the calculation is necessary if the value is not 0 (0 raises the MISRA violation) */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   295    XcpEthTransportLayerId = XcpTransportLayerId - XCP_ETH_TRANSPORT_LAYER_INDEX_OFFSET;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   296  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   297    /*--- DET reporting ----------------------------------------------------------------------------*/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   298    /* If Xcp is uninitialized, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   299    XCP_DET_REPORT_ERROR_RET((Xcp_GlobalNoInit.InitStatus_u8 != XCP_INIT), XCP_TRANSMIT_SID, XCP_E_NOT_INITIALIZED, E_NOT_OK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   300    /* If XcpPacketPtr is NULL_PTR, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   301    XCP_DET_REPORT_ERROR_RET((XcpPacketPtr == NULL_PTR), XCP_TRANSMIT_SID, XCP_E_NULL_POINTER, E_NOT_OK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   302    /* Check if Transport Layer Id is invalid, report to DET and exit the function  */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   303    XCP_DET_REPORT_ERROR_RET(((XcpEthTransportLayerId) >= XCP_ETH_NUMBER_OF_TRANSPORT_LAYERS), XCP_TRANSMIT_SID, XCP_E_INVALID_TRANSPORT_LAYER_ID, E_NOT_OK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   304    /* Check if Packet length is zero, report to DET and exit the function  */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   305    XCP_DET_REPORT_ERROR_RET((XcpPacketPtr->SduLength == 0u), XCP_TRANSMIT_SID, XCP_E_DATA_PACKET_EMPTY, E_NOT_OK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   306    /* If this function is called before transmission in EthMainFunctionTx, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   307    XCP_DET_REPORT_ERROR_RET((Xcp_TransportLayerEthData[XcpEthTransportLayerId].TxPacketPtr.SduLength != 0u), XCP_TRANSMIT_SID, XCP_E_UNEXPECTED_FUNCTION_CALL, E_NOT_OK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   308    /*--- / DET reporting --------------------------------------------------------------------------*/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   309  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   310    /* Used only in XcpOnCan */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   311    XCP_PARAM_UNUSED(XcpTxPduId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   312  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   313    /* Store pointer to Xcp Packet and TransportLayer Id */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   314    Xcp_TransportLayerEthData[XcpEthTransportLayerId].TxPacketPtr.SduDataPtr = XcpPacketPtr->SduDataPtr;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   315    Xcp_TransportLayerEthData[XcpEthTransportLayerId].TxPacketPtr.SduLength  = XcpPacketPtr->SduLength;   /* Must be after SduDataPtr */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   316  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   317    return E_OK;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   318  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   319  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   320  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   321  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   322  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   323  Local function for handling the frame transmission, called from Xcp_EthMainFunctionTx or Xcp_EthTransmit
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   324  \param[in]  XcpPacketPtr            Pointer to XcpPacket (with Length and data pointer)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   325  \param[in]  XcpEthTransportLayerId  Local Ethernet Transport Layer Id
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   326  \return     status of the transmit request
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   327  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   328  static Std_ReturnType Xcp_EthTransmitInMainfunction(const PduInfoType* XcpPacketPtr, uint8 XcpEthTransportLayerId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   329  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   330    /* Local variables */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   331    Std_ReturnType RetVal;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   332  #if (XCP_ETH_FRAME_CONCATENATION == STD_ON)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   333    PduLengthType XcpFrameLen;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   334  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   335  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   336    /*--- DET reporting ----------------------------------------------------------------------------*/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   337    /* If Xcp is uninitialized, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   338    XCP_DET_REPORT_ERROR_RET((Xcp_GlobalNoInit.InitStatus_u8 != XCP_INIT), XCP_TRANSMIT_SID, XCP_E_NOT_INITIALIZED, E_NOT_OK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   339    /* If XcpPacketPtr is NULL_PTR, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   340    XCP_DET_REPORT_ERROR_RET((XcpPacketPtr == NULL_PTR), XCP_TRANSMIT_SID, XCP_E_NULL_POINTER, E_NOT_OK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   341    /* Check if Transport Layer Id is invalid, report to DET and exit the function  */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   342    XCP_DET_REPORT_ERROR_RET((XcpEthTransportLayerId >= XCP_ETH_NUMBER_OF_TRANSPORT_LAYERS), XCP_TRANSMIT_SID, XCP_E_INVALID_TRANSPORT_LAYER_ID, E_NOT_OK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   343    /* Check if Packet length is zero, report to DET and exit the function  */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   344    XCP_DET_REPORT_ERROR_RET((XcpPacketPtr->SduLength == 0u), XCP_TRANSMIT_SID, XCP_E_DATA_PACKET_EMPTY, E_NOT_OK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   345    /* Check if Packet length is the expected one, report to DET and exit the function  */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   346    XCP_DET_REPORT_ERROR_RET((Xcp_TransportLayerEthData[XcpEthTransportLayerId].TxPacketPtr.SduLength == 0u), XCP_TRANSMIT_SID, XCP_E_UNEXPECTED_FUNCTION_CALL, E_NOT_OK);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   347  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   348    /*--- / DET reporting --------------------------------------------------------------------------*/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   349  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   350    /* Initial value */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   351    RetVal = E_OK;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   352  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   353  #if (XCP_ETH_FRAME_CONCATENATION == STD_OFF)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   354    /* Check if enough space in Pdu */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   355    if ((XCP_ETH_PACKET_HEADER_LEN + XcpPacketPtr->SduLength) <= Xcp_TransportLayerConfigEth.TransportLayerEthConfig[XcpEthTransportLayerId].Xcp_PduLength)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   356    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   357      /* Copy the packet to the buffer. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   358      Xcp_EthCopyPacketToBuffer(XcpPacketPtr, XcpEthTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   359      /* Transmit the packet */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   360      RetVal = SoAd_IfTransmit(Xcp_TransportLayerConfigEth.TransportLayerEthConfig[XcpEthTransportLayerId].SoAdTxPduId, &Xcp_TransportLayerEthData[XcpEthTransportLayerId].Xcp_EthDataPacket);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   361      /* Reset TxBuffer */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   362      Xcp_EthResetTxBuffer(XcpEthTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   363    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   364    else
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   365    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   366      RetVal = E_NOT_OK;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   367    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   368  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   369  #else
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   370  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   371    /* Get PduLength */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   372    XcpFrameLen = Xcp_TransportLayerEthData[XcpEthTransportLayerId].Xcp_EthDataPacket.SduLength;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   373    /* First check if is enough space in the ETH frame for the packet to be transmitted.
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   374       In case there is space copy the received packet into the buffer.
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   375       If not enough space in the buffer then first make a transmit and in case transmit is successful, reset the buffer and copy the received
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   376       packet into the now empty buffer. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   377    if ((XcpFrameLen + XCP_ETH_PACKET_HEADER_LEN + XcpPacketPtr->SduLength) <= Xcp_TransportLayerConfigEth.TransportLayerEthConfig[XcpEthTransportLayerId].Xcp_PduLength)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   378    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   379      /* Copy the packet to the buffer. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   380      Xcp_EthCopyPacketToBuffer(XcpPacketPtr, XcpEthTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   381    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   382    else
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   383    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   384        /* No more space available in the frame: Transmit the packet, reset the buffer then copy the new received packet. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   385      if (SoAd_IfTransmit(Xcp_TransportLayerConfigEth.TransportLayerEthConfig[XcpEthTransportLayerId].SoAdTxPduId, &Xcp_TransportLayerEthData[XcpEthTransportLayerId].Xcp_EthDataPacket) == E_OK)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   386      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   387        Xcp_EthResetTxBuffer(XcpEthTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   388        /* Check if enough space in Pdu */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   389        if ((XCP_ETH_PACKET_HEADER_LEN + XcpPacketPtr->SduLength) <= Xcp_TransportLayerConfigEth.TransportLayerEthConfig[XcpEthTransportLayerId].Xcp_PduLength)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   390        {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   391          Xcp_EthCopyPacketToBuffer(XcpPacketPtr, XcpEthTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   392        }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   393        else
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   394        {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   395          RetVal = E_NOT_OK;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   396        }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   397      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   398      else
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   399      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   400        /* Transmission failed, return E_NOT_OK. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   401        RetVal = E_NOT_OK;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   402      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   403    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   404  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   405    return RetVal;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   406  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   407  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   408  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   409  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   410  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   411  This function is called by the lower layers when an AUTOSAR XCP PDU has been transmitted
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   412  \param[in]  XcpTxPduId  PduId that has been transmitted
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   413  \return     -
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   414  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   415  void Xcp_SoAdIfTxConfirmation(PduIdType XcpTxPduId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   416  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   417    /*--- DET reporting ----------------------------------------------------------------------------*/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   418    /* If Xcp is uninitialized, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   419    XCP_DET_REPORT_ERROR((Xcp_GlobalNoInit.InitStatus_u8 != XCP_INIT), XCP_TX_CONFIRMATION_SID, XCP_E_NOT_INITIALIZED);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   420    /* If Invalid TxPduId, report to DET and exit the function */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   421    XCP_DET_REPORT_ERROR((XcpTxPduId >= XCP_ETH_NUMBER_OF_TX_PDU), XCP_TX_CONFIRMATION_SID, XCP_E_INVALID_PDUID);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   422    /*--- / DET reporting --------------------------------------------------------------------------*/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   423  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   424    /* Used only in XcpOnCan */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   425    XCP_PARAM_UNUSED(XcpTxPduId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   426  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   427    /* Call of Xcp_TxConfirmation takes place in Xcp_EthMainFunctionTx.
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   428    Inside Xcp_SoAdTxConfirmation only DET reports are issued. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   429  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   430  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   431  #define XCP_STOP_SEC_CODE_FAST
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   432  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   433  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   434  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   435  #define XCP_START_SEC_CODE
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   436  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   437  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   438  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   439  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   440  Xcp main function for transmission on Transport Layer
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   441  \param[in]  -
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   442  \return     -
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   443  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   444  void Xcp_EthMainFunctionTx( void )
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   445  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   446    uint8 i;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   447  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   448    /* Check all Ethernet transport layers */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   449    for (i = 0; i < XCP_ETH_NUMBER_OF_TRANSPORT_LAYERS; i++)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   450    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   451      /* Anything to transmit? */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   452      while ( (Xcp_TransportLayerEthData[i].TxPacketPtr.SduLength != 0u)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   453            /* was transmit successful? */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   454            /* MR12 RULE 13.5 VIOLATION: Conditions are evaluated from left to right. The function call is only done if the first condition is TRUE - this is intended behavior; Redesign not possible as while loop instead of if possible - change would decrease maintainability and increase runtime */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   455            && (Xcp_EthTransmitInMainfunction(&Xcp_TransportLayerEthData[i].TxPacketPtr, i) == E_OK)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   456            )
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   457      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   458        Xcp_TransportLayerEthData[i].TxPacketPtr.SduLength = 0;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   459        /* MR12 RULE 2.2 VIOLATION: XCP_*_TRANSPORT_LAYER_INDEX_OFFSET changes depending on the configuration thus the calculation is necessary if the value is not 0 (0 raises the MISRA violation) */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   460        Xcp_TxConfirmation(i + XCP_ETH_TRANSPORT_LAYER_INDEX_OFFSET);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   461      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   462  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   463  #if (XCP_ETH_FRAME_CONCATENATION == STD_ON)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   464  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   465      /* Check if at the end of Xcp_EthMainFunctionTx the buffer is filled */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   466      if (Xcp_TransportLayerEthData[i].Xcp_EthDataPacket.SduLength > 0u)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   467      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   468        if(SoAd_IfTransmit(Xcp_TransportLayerConfigEth.TransportLayerEthConfig[i].SoAdTxPduId, &Xcp_TransportLayerEthData[i].Xcp_EthDataPacket) == E_OK)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   469        {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   470          /* Clear transmission buffer and reset transmission flag */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   471          Xcp_EthResetTxBuffer(i);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   472        }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   473      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   474  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   475  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   476    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   477  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   478  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   479  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   480  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   481  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   482  Initialization of the transport layer internal variables
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   483  \param[in]  XcpTransportLayerId   Global Transport Layer Id
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   484  \param[in]  XcpInitStatus         was Xcp already initialized before or not
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   485  \return     -
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   486  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   487  void Xcp_EthInit(uint8 XcpTransportLayerId, uint8 XcpInitStatus)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   488  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   489    PduIdType TxPduId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   490    Std_ReturnType soConRetVal;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   491    uint8 XcpEthTransportLayerId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   492  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   493    soConRetVal = E_NOT_OK;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   494  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   495    /* MR12 RULE 2.2 VIOLATION: XCP_*_TRANSPORT_LAYER_INDEX_OFFSET changes depending on the configuration thus the calculation is necessary if the value is not 0 (0 raises the MISRA violation) */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   496    XcpEthTransportLayerId = XcpTransportLayerId - XCP_ETH_TRANSPORT_LAYER_INDEX_OFFSET;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   497  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   498    Xcp_TransportLayerEthData[XcpEthTransportLayerId].Xcp_EthDataPacket.SduDataPtr = Xcp_TransportLayerEthData[XcpEthTransportLayerId].Xcp_DataBuffer_pu8;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   499    /* Extract TxPduId for socket connection Id calculation. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   500    TxPduId = Xcp_TransportLayerConfigEth.TransportLayerEthConfig[XcpEthTransportLayerId].SoAdTxPduId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   501    /* Find out the SoConId based on TxPduId. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   502    soConRetVal = SoAd_GetSoConId(TxPduId, &Xcp_SoConData[XcpEthTransportLayerId].SoConId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   503    /* Open Socket connection with corresponding SoConId. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   504    (void)SoAd_OpenSoCon(Xcp_SoConData[XcpEthTransportLayerId].SoConId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   505    /* The parameter is not used */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   506    XCP_PARAM_UNUSED(XcpInitStatus);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   507  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   508  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   509  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   510  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   511  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   512  Connect command related handling for the transport layer
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   513  \param[in]  XcpTransportLayerId   Global Transport Layer Id
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   514  \return     -
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   515  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   516  void Xcp_EthConnect(uint8 XcpTransportLayerId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   517  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   518    uint8 XcpEthTransportLayerId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   519  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   520    /* MR12 RULE 2.2 VIOLATION: XCP_*_TRANSPORT_LAYER_INDEX_OFFSET changes depending on the configuration thus the calculation is necessary if the value is not 0 (0 raises the MISRA violation) */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   521    XcpEthTransportLayerId = XcpTransportLayerId - XCP_ETH_TRANSPORT_LAYER_INDEX_OFFSET;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   522    /* Return in IpAddr the Remote Address of XCP for further usage in case of socket OFFLINE. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   523    Xcp_SoConData[XcpEthTransportLayerId].RemoteIpAddr.domain = Xcp_TransportLayerConfigEth.TransportLayerEthConfig[XcpEthTransportLayerId].SoConDomain;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   524    /* MR12 RULE 11.3 VIOLATION: typecasted to TcpIp_SockAddrType to match the AUTOSAR API Definition  */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   525    (void)SoAd_GetRemoteAddr(Xcp_SoConData[XcpEthTransportLayerId].SoConId, (TcpIp_SockAddrType *)&Xcp_SoConData[XcpEthTransportLayerId].RemoteIpAddr);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   526  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   527  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   528  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   529  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   530  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   531  Disconnects the transport layer
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   532  \param[in]  XcpTransportLayerId   Global Transport Layer Id
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   533  \return     result of disconnect request
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   534  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   535  Std_ReturnType Xcp_EthDisconnect(uint8 XcpTransportLayerId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   536  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   537    uint8 XcpEthTransportLayerId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   538    Std_ReturnType soConRetVal;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   539  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   540    soConRetVal = E_NOT_OK;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   541  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   542    /* MR12 RULE 2.2 VIOLATION: XCP_*_TRANSPORT_LAYER_INDEX_OFFSET changes depending on the configuration thus the calculation is necessary if the value is not 0 (0 raises the MISRA violation) */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   543    XcpEthTransportLayerId = XcpTransportLayerId - XCP_ETH_TRANSPORT_LAYER_INDEX_OFFSET;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   544  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   545    if (Xcp_TransportLayerEthData[XcpEthTransportLayerId].TxPacketPtr.SduLength == 0u)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   546    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   547      if (Xcp_TransportLayerConfigEth.TransportLayerEthConfig[XcpEthTransportLayerId].ProtocolType == XCP_ETH_PROTOCOL_TCP)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   548      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   549        /* For TCP at the moment no close socket request from XCP is needed because the TCP will perform
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   550        the disconnect once the FIN is received from the Remote. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   551        soConRetVal = E_OK;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   552      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   553      else
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   554      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   555        /* UDP is configured. Close socket connection. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   556        soConRetVal = SoAd_CloseSoCon(Xcp_SoConData[XcpEthTransportLayerId].SoConId, TRUE);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   557      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   558    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   559  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   560    return soConRetVal;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   561  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   562  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   563  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   564  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   565  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   566  This function handles specific Transport Layer Commands
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   567  \param[in]  XcpCmdPacketPtr       Pointer to XcpPacket with received command
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   568  \param[out] XcpResPacketPtr       Pointer to XcpPacket where the response shall be stored
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   569  \param[in]  XcpTransportLayerId   Global Transport Layer Id
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   570  \return     -
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   571  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   572  /* MR12 RULE 8.13 VIOLATION: All transport layers have a functions with this signature. Only in XcpOnEth it is not used and thus empty. Pointer cannot be constant to keep signature identical. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   573  void Xcp_EthTransportLayerCmd(const PduInfoType* XcpCmdPacketPtr, PduInfoType* XcpResPacketPtr, uint8 XcpTransportLayerId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   574  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   575    XCP_PARAM_UNUSED(XcpCmdPacketPtr);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   576    XCP_PARAM_UNUSED(XcpResPacketPtr);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   577    XCP_PARAM_UNUSED(XcpTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   578    /* Nothing to do in XcpOnEth */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   579  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   580  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   581  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   582  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   583  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   584  This function is called by protocol layer to find a XcpTxPduId for a given EventChannel
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   585  \param[in]  XcpPacketId             Type of the packet (1st byte of packets to transmit)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   586  \param[in]  XcpEventChannelNumber   Event channel number (relevant for CAN only)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   587  \param[in]  XcpTransportLayerId     Id if Transport Layer given by Protocol layer
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   588  \return     XcpTxPduId
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   589  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   590  Xcp_PduIdType Xcp_EthGetTxPduId(uint8 XcpPacketId, uint16 XcpEventChannelNumber, uint8 XcpTransportLayerId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   591  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   592    XCP_PARAM_UNUSED(XcpEventChannelNumber);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   593    XCP_PARAM_UNUSED(XcpTransportLayerId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   594    XCP_PARAM_UNUSED(XcpPacketId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   595  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   596    return XCP_PDU_ID_UNKNOWN;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   597  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   598  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   599  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   600  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   601  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   602  This function is called by the lower layers when SoConMode changes
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   603  \param[in]  SoConId   Id of the socket connection
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   604  \param[in]  Mode      new socket connection mode
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   605  \return     -
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   606  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   607  /* HIS METRIC LEVEL VIOLATION IN Xcp_SoConModeChg: Function contains several necessary if statements. HIS metric compliance would decrease readability and maintainability. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   608  void Xcp_SoConModeChg(SoAd_SoConIdType SoConId, SoAd_SoConModeType Mode)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   609  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   610    uint8 Index_u8;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   611    uint8 ProtocolLayerId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   612  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   613    Index_u8 = 0u;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   614  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   615    while(Index_u8 < XCP_ETH_NUMBER_OF_TRANSPORT_LAYERS)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   616    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   617      if (SoConId == Xcp_SoConData[Index_u8].SoConId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   618      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   619        /* MR12 RULE 2.2 VIOLATION: XCP_*_TRANSPORT_LAYER_INDEX_OFFSET changes depending on the configuration thus the calculation is necessary if the value is not 0 (0 raises the MISRA violation) */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   620        ProtocolLayerId = Xcp_GlobalNoInit.Tl2PlRef_au8[Index_u8 + XCP_ETH_TRANSPORT_LAYER_INDEX_OFFSET];
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   621  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   622        switch (Mode)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   623        {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   624          case SOAD_SOCON_RECONNECT:
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   625          {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   626            if(ProtocolLayerId != XCP_INVALID_PROTLAYER_ID)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   627            {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   628              if (Xcp_TransportLayerConfigEth.TransportLayerEthConfig[Index_u8].ProtocolType == XCP_ETH_PROTOCOL_UDP)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   629              {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   630                #if (XCP_RESUME_MODE == STD_ON)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   631                /* When RESUME mode is active the saved address friom the previous connection has to be set */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   632                if (Xcp_NoInit[ProtocolLayerId].Session.XcpState_en == XCP_STATE_RESUME)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   633                {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   634                  /* MR12 RULE 11.3 VIOLATION: typecasted to TcpIp_SockAddrType to match the AUTOSAR API Definition  */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   635                  if (SoAd_SetRemoteAddr(Xcp_SoConData[Index_u8].SoConId, ( const TcpIp_SockAddrType *)&Xcp_SoConData[Index_u8].RemoteIpAddr) == E_OK)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   636                  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   637                    (void)SoAd_OpenSoCon(SoConId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   638                  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   639                }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   640                #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   641              }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   642              else
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   643              { /* The Protocol type is TCP */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   644  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   645                if (Xcp_NoInit[ProtocolLayerId].Session.XcpState_en != XCP_STATE_RESUME)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   646                {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   647                  /* Disconnect Protocol layer */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   648                  Xcp_DoDisconnect(ProtocolLayerId, XCP_NO_RESPONSE);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   649  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   650                  /* Clear the transmit buffers from Xcp on Eth if the disconnect takes place to avoid sending data from the previous connect session with a new connect. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   651                  Xcp_TransportLayerEthData[Index_u8].Xcp_EthDataPacket.SduLength = 0u;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   652                }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   653                else
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   654                {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   655                  /* Do nothing. The Master has to try to open the Socket with the handshake SYN -> SYN + ACK -> ACK */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   656                }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   657              }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   658            }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   659          }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   660          break;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   661          case SOAD_SOCON_ONLINE:
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   662            /* do nothing */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   663          break;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   664          case SOAD_SOCON_OFFLINE:
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   665          {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   666            if (Xcp_TransportLayerConfigEth.TransportLayerEthConfig[Index_u8].ProtocolType == XCP_ETH_PROTOCOL_UDP)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   667            {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   668              /* Clear the transmit buffers from Xcp on Eth if the disconnect takes place to avoid sending data from the previous connect session with a new connect. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   669              Xcp_TransportLayerEthData[Index_u8].Xcp_EthDataPacket.SduLength = 0u;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   670              /* Reopen the socket connection. In case of UDP */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   671              (void)SoAd_OpenSoCon(Xcp_SoConData[Index_u8].SoConId);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   672            }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   673            else
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   674            { /* The Protocol type is TCP */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   675  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   676              if (ProtocolLayerId != XCP_INVALID_PROTLAYER_ID)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   677              {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   678                /* Disconnect Protocol layer */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   679                Xcp_DoDisconnect(ProtocolLayerId, XCP_NO_RESPONSE);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   680  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   681                /* Clear the transmit buffers from Xcp on Eth if the disconnect takes place to avoid sending data from the previous connect session with a new connect. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   682                Xcp_TransportLayerEthData[Index_u8].Xcp_EthDataPacket.SduLength = 0u;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   683              }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   684            }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   685          }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   686          break;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   687          default:
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   688          /* Nothing to do */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   689          break;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   690        }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   691        break; /* break to exit the while loop */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   692      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   693      Index_u8++;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   694    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   695  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   696  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   697  #if ((XCP_RESUME_MODE == STD_ON) && (XCP_SYNCHRONOUS_DATA_ACQUISITION_DAQ == STD_ON))
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   698  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   699  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   700  This function is called to copy transport layer needed data for Resume Mode
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   701  \param[in]  DaqRamPtr             Pointer to Daq RAM address where data is saved
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   702  \param[in]  XcpDaqRamEndPtr       Last DAQ RAM address for requested Protocol Layer
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   703  \param[in]  XcpTransportLayerId   Id if Transport Layer given by Protocol layer
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   704  \return     Error code in case is not enough space to save the data
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   705  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   706  Xcp_ErrorCode Xcp_EthResumeModeData(uint8* DaqRamPtr, const uint8* XcpDaqRamEndPtr, uint8 XcpTransportLayerId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   707  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   708    uint8 XcpEthTransportLayerId;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   709    Xcp_ErrorCode Error;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   710  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   711    /* MR12 RULE 2.2 VIOLATION: XCP_*_TRANSPORT_LAYER_INDEX_OFFSET changes depending on the configuration thus the calculation is necessary if the value is not 0 (0 raises the MISRA violation) */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   712    XcpEthTransportLayerId = XcpTransportLayerId - XCP_ETH_TRANSPORT_LAYER_INDEX_OFFSET;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   713    /* Check if Transport Layer Id is invalid, report to DET and exit the function  */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   714    XCP_DET_REPORT_ERROR_RET(((XcpEthTransportLayerId) >= XCP_ETH_NUMBER_OF_TRANSPORT_LAYERS), XCP_TRANSMIT_SID, XCP_E_INVALID_TRANSPORT_LAYER_ID, XCP_ERR_GENERIC);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   715  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   716    Error = XCP_NO_ERROR;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   717  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   718    /* If the XcpDaqRamEndPtr is NULL_PTR means that the function is currently used to set back the saved NvM data for the Transport Layer */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   719    if (XcpDaqRamEndPtr != NULL_PTR)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   720    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   721      /* If enough space to save the remote IP address to NvM then copy the data at the given place otherwise return ERR_MEMORY_OVERFLOW */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   722      if ((DaqRamPtr + sizeof(TcpIp_SockAddrInet6Type)) <= XcpDaqRamEndPtr)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   723      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   724        /* Copy SoAd Remote IP address to which XCP is connected */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   725        /* MR12 DIR 1.1 VIOLATION: The input parameters of rba_BswSrv_MemCopy() are declared as (void*) for generic implementation of MemCopy. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   726        Xcp_MemCopy(DaqRamPtr, &Xcp_SoConData[XcpEthTransportLayerId].RemoteIpAddr, sizeof(TcpIp_SockAddrInet6Type));
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   727      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   728      else
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   729      {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   730        Error = XCP_ERR_MEMORY_OVERFLOW;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   731      }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   732    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   733    else
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   734    {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   735      /* It is requested to read the remote IP address from NvM block */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   736      /* Set the previous remote IP address read from NvM into the Xcp_SoConData for further use */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   737      /* MR12 DIR 1.1 VIOLATION: The input parameters of rba_BswSrv_MemCopy() are declared as (void*) for generic implementation of MemCopy. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   738      Xcp_MemCopy(&Xcp_SoConData[XcpEthTransportLayerId].RemoteIpAddr, DaqRamPtr, sizeof(TcpIp_SockAddrInet6Type));
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   739    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   740  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   741    return Error;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   742  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   743  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   744  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   745  #define XCP_STOP_SEC_CODE
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   746  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   747  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   748  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   749  /***************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   750  * Local functions
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   751  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   752  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   753  #define XCP_START_SEC_CODE_FAST
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   754  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   755  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   756  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   757  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   758  This function will reset the transmission buffer.
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   759  \param[in]  XcpPacketPtr            Pointer to XcpPacket (with Length and data pointer)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   760  \param[in]  XcpEthTransportLayerId  transport layer id
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   761  \return     -
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   762  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   763  static void Xcp_EthCopyPacketToBuffer(const PduInfoType* XcpPacketPtr, uint8 XcpEthTransportLayerId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   764  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   765    /* Local variables */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   766    PduInfoType*  TxPduPtr;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   767    PduLengthType WritePos;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   768  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   769    /* Get pointer to TxPdu */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   770    TxPduPtr = &Xcp_TransportLayerEthData[XcpEthTransportLayerId].Xcp_EthDataPacket;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   771    /* Get PduLength */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   772    WritePos = TxPduPtr->SduLength;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   773  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   774    /* Ethernet header is always little endian. Same implementation for IFX and JDP. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   775    TxPduPtr->SduDataPtr[WritePos]      = (uint8)(XcpPacketPtr->SduLength);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   776    TxPduPtr->SduDataPtr[WritePos + 1u] = (uint8)(XcpPacketPtr->SduLength >> 8u);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   777    TxPduPtr->SduDataPtr[WritePos + 2u] = (uint8)(Xcp_EthCtr_u16[XcpEthTransportLayerId]);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   778    TxPduPtr->SduDataPtr[WritePos + 3u] = (uint8)(Xcp_EthCtr_u16[XcpEthTransportLayerId] >> 8u);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   779  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   780    /* Copy the packet data into the XCP packet after the header data. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   781    /* MR12 DIR 1.1 VIOLATION: The input parameters of rba_BswSrv_MemCopy() are declared as (void*) for generic implementation of MemCopy. */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   782    Xcp_MemCopy(&TxPduPtr->SduDataPtr[WritePos + XCP_ETH_PACKET_HEADER_LEN], XcpPacketPtr->SduDataPtr, XcpPacketPtr->SduLength);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   783    /* Store new packet length without padding*/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   784  #if (XCP_ETH_PACKET_ALIGNMENT == XCP_ETH_PACKET_ALIGNMENT_8)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   785    TxPduPtr->SduLength = WritePos + XCP_ETH_PACKET_HEADER_LEN + XcpPacketPtr->SduLength;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   786  #else
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   787    /* Store new packet length with padding*/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   788    TxPduPtr->SduLength = WritePos + XCP_ETH_PACKET_HEADER_LEN + (XcpPacketPtr->SduLength + ((1u+XCP_ETH_ALIGNMENT_MASK-(XcpPacketPtr->SduLength&XCP_ETH_ALIGNMENT_MASK))&XCP_ETH_ALIGNMENT_MASK));
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   789    /* If the sdu length exceeds the ethernet pdu length after padding, then reduce the padding and set the sdu length to the ethernet pdu length */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   790    if(TxPduPtr->SduLength > Xcp_TransportLayerConfigEth.TransportLayerEthConfig[XcpEthTransportLayerId].Xcp_PduLength){
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   791      TxPduPtr->SduLength = Xcp_TransportLayerConfigEth.TransportLayerEthConfig[XcpEthTransportLayerId].Xcp_PduLength;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   792    }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   793  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   794  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   795  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   796    /* Increment for next transmission */
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   797    Xcp_EthCtr_u16[XcpEthTransportLayerId]++;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   798  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   799  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   800  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   801  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   802  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   803  This function will reset the transmission buffer.
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   804  \param[in]  XcpEthTransportLayerId  transport layer id
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   805  \return     -
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   806  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   807  static void Xcp_EthResetTxBuffer(uint8 XcpEthTransportLayerId)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   808  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   809    Xcp_TransportLayerEthData[XcpEthTransportLayerId].Xcp_EthDataPacket.SduLength = 0;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   810  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   811  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   812  #define XCP_STOP_SEC_CODE_FAST
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   813  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   814  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   815  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   816  #define XCP_START_SEC_CODE
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   817  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   818  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   819  /**
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   820  ****************************************************************************************************
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   821  This function will return the XCP packet length from XCP header.
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   822  \param[in]  XcpLengthPtr  Pointer to XcpPacket (with Length and data pointer)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   823  \return     length of the XCP packet
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   824  ***************************************************************************************************/
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   825  static PduLengthType Xcp_EthGetPacketLength(const uint8* XcpLengthPtr)
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   826  {
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   827    PduLengthType XcpPacketLength;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   828  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   829    XcpPacketLength = XcpLengthPtr[0] + (PduLengthType)((PduLengthType)XcpLengthPtr[1]<<8u);
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   830  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   831    return XcpPacketLength;
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   832  }
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   833  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   834  #define XCP_STOP_SEC_CODE
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   835  #include "Xcp_MemMap.h"
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   836  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   837  #endif
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   838  
; BSW\src\BSW\Gen\Xcp\src\XcpOnEth.c	   839  /* HIS METRIC COMF VIOLATION IN XcpOnEth.c: If Xcp on Ethernet is disabled, this file is empty. */

	; Module end
