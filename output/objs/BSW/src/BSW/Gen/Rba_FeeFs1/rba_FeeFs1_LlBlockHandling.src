	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 19053136 SN 09001910"
	.compiler_invocation	"ctc -f cc17000a -c99 --integer-enumeration -D__CPU__=tc27x -D__CPU_TC27X__ --core=tc1.6.x --eabi-compliant --fp-model=-float -D_TASKING_C_TRICORE_=1 -I.\\output\\inc -g2 -t4 --language=-comments,-gcc,+volatile,-strings --default-near-size=0 -O2ROPYGKLF-predict --default-a1-size=0 --default-a0-size=0 --source --switch=auto -o output\\objs\\BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\rba_FeeFs1_LlBlockHandling.src BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c"
	.compiler_name		"ctc"
	;source	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c'

	
$TC16X
	
	.sdecl	'.text.rba_FeeFs1_LlBlockHandling.Fee_LLCompBlkInFlash',code,cluster('Fee_LLCompBlkInFlash')
	.sect	'.text.rba_FeeFs1_LlBlockHandling.Fee_LLCompBlkInFlash'
	.align	2
	
	.global	Fee_LLCompBlkInFlash

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	     1  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	     2  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	     3  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	     4  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	     5   **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	     6   * \moduledescription
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	     7   *           AUTOSAR FEE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	     8   *           According to Document Version 3.0.0, Part of Release 4.0, Revision 2
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	     9   * \scope    INTERN
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    10   **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    11   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    12  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    13  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    14  /*
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    15   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    16   * Includes
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    17   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    18   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    19  #include "Fee.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    20  #include "rba_FeeFs1_Prv.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    21  #include "rba_FeeFs1_Cbk.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    22  #include "Fls.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    23  #if (!defined(FLS_AR_RELEASE_MAJOR_VERSION) || (FLS_AR_RELEASE_MAJOR_VERSION != FEE_AR_RELEASE_MAJOR_VERSION))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    24      #error "AUTOSAR major version undefined or mismatched"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    25  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    26  #if (!defined(FLS_AR_RELEASE_MINOR_VERSION) || ((FLS_AR_RELEASE_MINOR_VERSION != 0) && (FLS_AR_RELEASE_MINOR_VERSION != 2)))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    27      #error "AUTOSAR minor version undefined or mismatched"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    28  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    29  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    30  #include "Crc.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    31  #if (!defined(CRC_AR_RELEASE_MAJOR_VERSION) || (CRC_AR_RELEASE_MAJOR_VERSION != FEE_AR_RELEASE_MAJOR_VERSION))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    32      #error "AUTOSAR major version undefined or mismatched"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    33  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    34  #if (!defined(CRC_AR_RELEASE_MINOR_VERSION) || ((CRC_AR_RELEASE_MINOR_VERSION != 0) && (CRC_AR_RELEASE_MINOR_VERSION != 2)))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    35      #error "AUTOSAR minor version undefined or mismatched"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    36  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    37  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    38  #if (FEE_PRV_DEBUGGING != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    39  #include "Mcu.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    40  /* FEE_PRV_DEBUGGING */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    41  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    42  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    43  #if(defined(FEE_PRV_CFG_SELECTED_FS) && (1 == FEE_PRV_CFG_SELECTED_FS))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    44  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    45  #if (FEE_PRESENT == 1)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    46  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    47   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    48   * Fee_LLCompBlkInFlash(): Verify block checksums
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    49   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    50   * This function can be used to verify block checksums using block
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    51   * header information. It can be called in the following situations:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    52   * - due to a write order in order to verify the already available
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    53   *   copy in the flash
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    54   * - after a write order in order to verify the programming result
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    55   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    56   * Hint: The compare will also work if the data is stored over
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    57   *       sector boundaries.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    58   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    59   * \param    HeaderInfo_ptr:        Pointer to the block header info
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    60   * \param    Data_pcu8:             Pointer to the data to be compared
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    61   * \return
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    62   * \retval   FEE_ORDER_PENDING_E:   Order is still pending
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    63   * \retval   FEE_ABORTED_E:         Order was aborted due to a wrong
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    64   *                                  FLS compare function call
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    65   * \retval   FEE_ERROR_E:           Difference detected
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    66   * \retval   FEE_ORDER_FINISHED_E:  Order finished successfully
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    67   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    68   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    69   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    70   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    71  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    72  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    73  FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLCompBlkInFlash(P2CONST(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) HeaderInfo_pcst,
; Function Fee_LLCompBlkInFlash
.L309:
Fee_LLCompBlkInFlash:	.type	func
	sub.a	a10,#8
.L489:
	mov.aa	a12,a4
.L492:
	st.a	[a10]4,a5
.L494:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    74                                                        P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) Data_pcu8)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    75  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    76      VAR(Fee_stRetVal_ten, AUTOMATIC) xRetVal_en = FEE_ORDER_PENDING_E; /* Function return */
	mov	d8,#0
.L495:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    77      VAR(uint16, AUTOMATIC) xNumBytes_u16  = 0;              /* Number of bytes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    78      VAR(uint8, AUTOMATIC)  xLogSectIdx_u8 = 0;              /* Logical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    79      VAR(uint8, AUTOMATIC)  xPhySectIdx_u8 = 0;              /* Physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    80      VAR(uint8, AUTOMATIC)  xPhyWrSectIdx_u8 = 0;            /* Physical sector index of the write address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    81      VAR(uint16, AUTOMATIC) xCmpLen_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    82  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    83      /* Switch over the state machine */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    84      switch(Fee_RdWrOrder_st.Fee_LLCompBlk)
	movh.a	a13,#@his(Fee_RdWrOrder_st)
	lea	a13,[a13]@los(Fee_RdWrOrder_st)
.L729:
	lea	a15,[a13]76
	st.a	[a10],a15
	ld.w	d0,[a13]76
.L730:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    85      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    86          /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    87          case FEE_LL_CMP_BLK_INIT_E:
	mov	d15,#0
	jeq	d15,d0,.L2
.L731:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    88          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    89              /* Depending on the page size, the header needs more than 1 page and there might be free space for
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    90               * data behind the header --> compare also data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    91              Fee_GlobInfoWrBlock_st.BytesAlrdyCompared_u16 = FEE_FREE_BYTES_AFTER_HEADER;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    92  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    93              /* Set next state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    94              Fee_RdWrOrder_st.Fee_LLCompBlk = FEE_LL_CMP_HEADER_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    95          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    96          /* No break to save time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    97  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    98          /* Compare the complete block header (+ 2 data bytes if possible) against the page buffer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	    99          /* MR12 RULE 16.3 VIOLATION: Time critical position */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   100          case FEE_LL_CMP_HEADER_E:
	mov	d15,#1
	jeq	d15,d0,.L3
.L732:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   101          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   102              /* Reset the compare result */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   103              Fee_GlobInfoWrBlock_st.CompareResult_u8 = 0xFF;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   104  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   105              /* Get the block header start address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   106              Fee_RdWrOrder_st.xCmpAddress = HeaderInfo_pcst->AdrBlkHeader_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   107  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   108              xCmpLen_u16 = FEE_BLOCK_OVERHEAD + HeaderInfo_pcst->BlkLength_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   109  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   110              if (xCmpLen_u16 > (FEE_PAGES_USED_BY_BLK_HEADER * FEE_PAGE_LEN))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   111              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   112                  xCmpLen_u16 = FEE_PAGES_USED_BY_BLK_HEADER * FEE_PAGE_LEN;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   113              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   114  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   115              /* Set the compare order */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   116              /* MR12 RULE 11.3 VIOLATION: Cast necessary for byte wise access */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   117              if (Fls_Compare(Fee_RdWrOrder_st.xCmpAddress,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   118                              (uint8*)Fee_PageBytePtr_cpu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   119                              xCmpLen_u16) != E_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   120              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   121                  /* An error occured due to wrong parameters or a busy/not init state of the Fls */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   122                  xRetVal_en = FEE_ABORTED_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   123              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   124              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   125              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   126                  /* The order was accepted and will be processed in the Fls driver */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   127                  Fee_RdWrOrder_st.Fee_LLCompBlk = FEE_LL_CMP_WAIT_HEADER_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   128  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   129                  /* Increment the compare address (if increment is behind the sector end address, the address will be set to
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   130                   * the sector end address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   131                  Fee_IncAddressInsideSector(&Fee_RdWrOrder_st.xCmpAddress, xCmpLen_u16, TRUE);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   132              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   133          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   134          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   135  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   136          /* Wait for the compare to finish */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   137          case FEE_LL_CMP_WAIT_HEADER_E:
	mov	d1,#2
	jeq	d1,d0,.L4
.L733:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   138          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   139              /* The next state (FEE_LL_CMP_DATA_SEC_A_E) will be set by the Fee_JobEndNotification () or
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   140               * Fee_JobErrorNotification() function automatically (in both cases verify the compare result
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   141               * inside the next case) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   142  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   143              /* Check whether the OS is currently running or not */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   144              if (Fee_stMain == FEE_POLLING_MODE_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   145              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   146                  /* Call the Fls main function manually */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   147                  Fls_MainFunction();
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   148              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   149  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   150              #if (STD_ON == FEE_POLLING_MODE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   151              /* Use the FLS polling mechanism in order to reach the next state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   152              Fee_CheckFlsJobResult();
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   153              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   154          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   155          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   156  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   157          /* Check for an overlap of the compare address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   158          case FEE_LL_CMP_CHECK_OVERLAP_E:
	mov	d1,#3
	jeq	d1,d0,.L5
.L734:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   159          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   160              /* Set the next state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   161              Fee_RdWrOrder_st.Fee_LLCompBlk = FEE_LL_CMP_DATA_SEC_A_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   162  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   163              /* Check if there are more bytes to be read. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   164              if(Fee_GlobInfoWrBlock_st.BytesAlrdyCompared_u16 < HeaderInfo_pcst->BlkLength_u16)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   165              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   166                  /* Some more bytes are left. check if the next bytes are over sector boundary and handle boundary conditions*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   167                  /* Get the physical sector index of the current compare address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   168                  xPhySectIdx_u8 = Fee_GetPhysSectorByAddress(Fee_RdWrOrder_st.xCmpAddress);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   169  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   170                  /* If there is only the block header inside the active sector, the Fee_RdWrOrder_st.xCmpAddress has to be set to the
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   171                   * beginning of the next logical sector. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   172                  if(Fee_RdWrOrder_st.xCmpAddress >= Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogEndAddress_u32)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   173                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   174                      /* The corresponding data is located in the next logical sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   175                      xLogSectIdx_u8 = (uint8)(Fee_idxLLSectorOrder_au8[xPhySectIdx_u8] + 1);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   176  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   177                      /* Check if switching from last to first sector requires an overflow */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   178                      if(xLogSectIdx_u8 >= FEE_NUM_FLASH_BANKS)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   179                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   180                          /* Abort, the block cannot continue in the logical sector 0 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   181                          xRetVal_en = FEE_ERROR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   182                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   183                      else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   184                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   185                          /* Before switching to next sector, check if next sector is programmed with data and if there are more data to be read. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   186                          if((Fee_LLSectorOrder_st[xLogSectIdx_u8].SecState_en == FEE_SECTOR_USED_E) ||
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   187                             (Fee_LLSectorOrder_st[xLogSectIdx_u8].SecState_en == FEE_SECTOR_FULL_E))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   188                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   189                              /* Get the new physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   190                              xPhySectIdx_u8 = Fee_LLSectorOrder_st[xLogSectIdx_u8].xPhySecIdx_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   191  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   192                              /* Set the new start address of the compare */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   193                              Fee_RdWrOrder_st.xCmpAddress = Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogStartAddress_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   194                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   195                          else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   196                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   197                              /* Abort, the block check as next sector is still not programmed with data. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   198                              xRetVal_en = FEE_ERROR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   199                              break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   200                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   201                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   202                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   203              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   204              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   205              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   206                  /* There wont be any more reads in the next sector as all bytes are read.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   207                     Its important that the driver continues with the next step and checks if the data matches. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   208              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   209  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   210          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   211          /* No break to save time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   212  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   213          /* Check the header compare result and compare the data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   214          /* MR12 RULE 16.3 VIOLATION: Time critical position */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   215          case FEE_LL_CMP_DATA_SEC_A_E:
	mov	d1,#4
	jeq	d1,d0,.L6
.L735:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   216          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   217              /* Check the header compare result */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   218              if (Fee_GlobInfoWrBlock_st.CompareResult_u8 > 0)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   219              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   220                  /* The compare failed, leave this function with an error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   221                  xRetVal_en = FEE_ERROR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   222              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   223              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   224              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   225                  /* The compare is OK, check if there is more data than what has already been checked
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   226                   * inside the block header (additional data pages) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   227                  if (HeaderInfo_pcst->BlkLength_u16 > Fee_GlobInfoWrBlock_st.BytesAlrdyCompared_u16)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   228                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   229                      /* Get the number of bytes to check */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   230                      xNumBytes_u16 = (uint16)(HeaderInfo_pcst->BlkLength_u16 -
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   231                                               Fee_GlobInfoWrBlock_st.BytesAlrdyCompared_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   232  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   233                      /* Check if all the data is located within the same sector and reset the amount of bytes to compare
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   234                       * in the next step, if necessary */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   235                      if (Fee_CalculateNumOfFreeBytesInCurSector(FEE_LL_SECTOR_USED_FOR_COMPARING) < xNumBytes_u16)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   236                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   237                          /* Restrict number of bytes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   238                          xNumBytes_u16 = (uint16)Fee_CalculateNumOfFreeBytesInCurSector(FEE_LL_SECTOR_USED_FOR_COMPARING);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   239                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   240  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   241                      /* Set the compare order */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   242                      if(Fls_Compare(Fee_RdWrOrder_st.xCmpAddress,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   243                                     &Data_pcu8[Fee_GlobInfoWrBlock_st.BytesAlrdyCompared_u16],
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   244                                     xNumBytes_u16) != E_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   245                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   246                          /* An error occured due to wrong parameters or a busy/not init state of the Fls */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   247                          xRetVal_en = FEE_ABORTED_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   248                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   249                      else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   250                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   251                          /* The order was accepted and will be processed in the Fls driver */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   252                          Fee_RdWrOrder_st.Fee_LLCompBlk = FEE_LL_CMP_WAIT_DATA_SEC_A_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   253  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   254                          /* Increment the compare address (if increment is behind the sector end address, the address will be set to
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   255                           * the sector end address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   256                          Fee_IncAddressInsideSector(&Fee_RdWrOrder_st.xCmpAddress, xNumBytes_u16, TRUE);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   257  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   258                          /* Increase the amount of already checked bytes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   259                          Fee_GlobInfoWrBlock_st.BytesAlrdyCompared_u16 = (uint16)(Fee_GlobInfoWrBlock_st.BytesAlrdyCompared_u16 +
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   260                                                                                   xNumBytes_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   261                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   262                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   263                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   264                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   265                      /* All data was stored inside the block header
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   266                       * --> compare successfully finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   267  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   268                      /* Update the cache with the last header address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   269                      Fee_LLUpdateAddressInCache(HeaderInfo_pcst->FeeIndex_u16, HeaderInfo_pcst->AdrBlkHeader_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   270  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   271                      /* Set return value */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   272                      xRetVal_en = FEE_ORDER_FINISHED_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   273                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   274              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   275          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   276          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   277  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   278          /* Wait for the compare to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   279          case FEE_LL_CMP_WAIT_DATA_SEC_A_E:
	mov	d1,#5
	jeq	d1,d0,.L7
.L736:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   280          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   281              /* The next state (FEE_LL_CMP_FINISHED_E) will be set by the Fee_JobEndNotification () or
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   282               * Fee_JobErrorNotification() function automatically (in both cases verify the compare result
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   283               * inside the next case) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   284  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   285              /* Check whether the OS is currently running or not */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   286              if (Fee_stMain == FEE_POLLING_MODE_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   287              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   288                  /* Call the Fls main function manually */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   289                  Fls_MainFunction();
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   290              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   291  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   292              #if (STD_ON == FEE_POLLING_MODE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   293              /* Use the FLS polling mechanism in order to reach the next state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   294              Fee_CheckFlsJobResult();
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   295              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   296          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   297          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   298  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   299          /* Verify the data compare result and reset the state machine */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   300          case FEE_LL_CMP_FINISHED_E:
	mov	d15,#6
	jeq	d15,d0,.L8
	j	.L9
.L2:
	movh.a	a15,#@his(Fee_GlobInfoWrBlock_st)
	lea	a15,[a15]@los(Fee_GlobInfoWrBlock_st)
.L737:
	add.a	a15,#2
.L738:
	mov	d15,#2
.L739:
	st.h	[a15],d15
.L740:
	mov	d15,#1
.L741:
	ld.a	a15,[a10]
	st.w	[a15],d15
.L3:
	movh.a	a15,#@his(Fee_GlobInfoWrBlock_st)
	lea	a15,[a15]@los(Fee_GlobInfoWrBlock_st)
.L742:
	mov	d15,#255
.L743:
	st.b	[a15]6,d15
.L744:
	lea	a15,[a13]8
.L745:
	ld.w	d15,[a12]
.L746:
	st.w	[a15],d15
.L747:
	ld.hu	d15,[a12]10
.L748:
	add	d15,d15,#14
	extr.u	d9,d15,#0,#16
.L496:
	mov	d15,#16
.L749:
	ge.u	d15,d15,d9
.L750:
	sel	d9,d15,d9,#16
.L10:
	ld.w	d4,[a15]
	movh.a	a2,#@his(Fee_PageBytePtr_cpu8)
	lea	a2,[a2]@los(Fee_PageBytePtr_cpu8)
	ld.a	a4,[a2]
.L491:
	mov	d5,d9
.L497:
	call	Fls_17_Pmu_Compare
.L490:
	jeq	d2,#0,.L11
.L751:
	mov	d8,#6
.L752:
	j	.L12
.L11:
	mov	d15,#2
.L753:
	ld.a	a2,[a10]
	st.w	[a2],d15
.L754:
	mov	d5,#1
	mov.aa	a4,a15
	mov	d4,d9
.L498:
	call	Fee_IncAddressInsideSector
.L12:
	j	.L13
.L4:
	movh.a	a15,#@his(Fee_stMain)
	lea	a15,[a15]@los(Fee_stMain)
	ld.w	d15,[a15]
.L755:
	jne	d15,#0,.L14
.L756:
	call	Fls_17_Pmu_MainFunction
.L14:
	call	Fee_CheckFlsJobResult
.L757:
	j	.L15
.L5:
	mov	d15,#4
.L758:
	st.w	[a15],d15
.L759:
	ld.hu	d15,[a12]10
.L760:
	movh.a	a15,#@his(Fee_GlobInfoWrBlock_st)
	lea	a15,[a15]@los(Fee_GlobInfoWrBlock_st)
.L761:
	ld.hu	d0,[a15]2
.L762:
	jge.u	d0,d15,.L16
.L763:
	lea	a14,[a13]8
	ld.w	d4,[a14]
	call	Fee_GetPhysSectorByAddress
.L499:
	movh.a	a2,#@his(Fee_FlashProp_st)
	lea	a2,[a2]@los(Fee_FlashProp_st)
.L764:
	ld.w	d0,[a14]
.L765:
	sha	d15,d2,#4
.L766:
	addsc.a	a15,a2,d15,#0
.L767:
	ld.w	d15,[a15]12
.L768:
	jlt.u	d0,d15,.L17
.L769:
	movh.a	a15,#@his(Fee_idxLLSectorOrder_au8)
	lea	a15,[a15]@los(Fee_idxLLSectorOrder_au8)
.L770:
	addsc.a	a15,a15,d2,#0
	ld.bu	d15,[a15]
.L771:
	add	d15,#1
.L772:
	extr.u	d15,d15,#0,#8
.L501:
	movh.a	a15,#@his(Fee_NumFlashBanksUsed_u8)
	lea	a15,[a15]@los(Fee_NumFlashBanksUsed_u8)
	ld.bu	d0,[a15]
.L773:
	jlt.u	d15,d0,.L18
.L774:
	mov	d8,#3
.L775:
	j	.L19
.L18:
	mul	d15,d15,#12
.L502:
	movh.a	a15,#@his(Fee_LLSectorOrder_st)
	lea	a15,[a15]@los(Fee_LLSectorOrder_st)
.L776:
	addsc.a	a15,a15,d15,#0
.L777:
	ld.w	d15,[a15]4
.L778:
	jeq	d15,#2,.L20
.L779:
	jne	d15,#3,.L21
.L20:
	ld.bu	d15,[a15]8
.L500:
	sha	d15,#4
.L503:
	addsc.a	a15,a2,d15,#0
.L780:
	ld.w	d15,[a15]8
.L781:
	st.w	[a14],d15
.L782:
	j	.L22
.L21:
	mov	d8,#3
.L783:
	j	.L23
.L22:
.L19:
.L17:
	j	.L24
.L16:
.L24:
.L6:
	movh.a	a14,#@his(Fee_GlobInfoWrBlock_st)
	lea	a14,[a14]@los(Fee_GlobInfoWrBlock_st)
.L784:
	ld.bu	d15,[a14]6
.L785:
	jeq	d15,#0,.L25
.L786:
	mov	d8,#3
.L787:
	j	.L26
.L25:
	mov.aa	a15,a14
	add.a	a15,#2
	ld.hu	d0,[a14]2
.L788:
	ld.hu	d15,[a12]10
.L789:
	jge.u	d0,d15,.L27
.L790:
	sub	d15,d0
.L791:
	extr.u	d9,d15,#0,#16
.L504:
	lea	a12,[a13]8
.L493:
	ld.w	d4,[a12]
	call	Fee_CalculateNumOfFreeBytesInCurSector
.L792:
	jge.u	d2,d9,.L28
.L793:
	ld.w	d4,[a12]
	call	Fee_CalculateNumOfFreeBytesInCurSector
.L794:
	extr.u	d9,d2,#0,#16
.L28:
	ld.w	d4,[a12]
	ld.hu	d15,[a14]2
	ld.a	a2,[a10]4
.L506:
	addsc.a	a4,a2,d15,#0
	mov	d5,d9
.L508:
	call	Fls_17_Pmu_Compare
.L507:
	jeq	d2,#0,.L29
.L795:
	mov	d8,#6
.L796:
	j	.L30
.L29:
	mov	d15,#5
.L797:
	ld.a	a2,[a10]
	st.w	[a2],d15
.L798:
	mov	d5,#1
	mov.aa	a4,a12
	mov	d4,d9
.L509:
	call	Fee_IncAddressInsideSector
.L510:
	ld.hu	d15,[a14]2
.L799:
	add	d9,d15
.L505:
	st.h	[a15],d9
.L30:
	j	.L31
.L27:
	ld.hu	d4,[a12]12
.L800:
	ld.w	d5,[a12]
	call	Fee_LLUpdateAddressInCache
.L801:
	mov	d8,#1
.L31:
.L26:
	j	.L32
.L7:
	movh.a	a15,#@his(Fee_stMain)
	lea	a15,[a15]@los(Fee_stMain)
	ld.w	d15,[a15]
.L802:
	jne	d15,#0,.L33
.L803:
	call	Fls_17_Pmu_MainFunction
.L33:
	call	Fee_CheckFlsJobResult
.L804:
	j	.L34
.L8:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   301          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   302              /* Verify the data compare result */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   303              if(Fee_GlobInfoWrBlock_st.CompareResult_u8 > 0)
	movh.a	a15,#@his(Fee_GlobInfoWrBlock_st)
	lea	a15,[a15]@los(Fee_GlobInfoWrBlock_st)
.L805:
	ld.bu	d15,[a15]6
.L806:
	jeq	d15,#0,.L35
.L807:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   304              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   305                  /* The compare failed, return an error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   306                  xRetVal_en = FEE_ERROR_E;
	mov	d8,#3
.L808:
	j	.L36
.L35:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   307              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   308              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   309              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   310                  /* Get the physical sector index of the compare address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   311                  xPhySectIdx_u8 = Fee_GetPhysSectorByAddress(Fee_RdWrOrder_st.xCmpAddress);
	lea	a14,[a13]8
	ld.w	d4,[a14]
	call	Fee_GetPhysSectorByAddress
.L511:
	mov	d15,d2
.L513:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   312  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   313                  /* Get the physical sector index of the write address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   314                  xPhyWrSectIdx_u8 = Fee_GetPhysSectorByAddress(Fee_RdWrOrder_st.xWrAddress);
	add.a	a13,#4
	ld.w	d4,[a13]
	call	Fee_GetPhysSectorByAddress
.L512:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   315  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   316                  /* The compare address is already incremented with the number of bytes from the previous compare order
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   317                   * -> if the compare address is now behind the write address the block is not written completely! */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   318                  if ((Fee_RdWrOrder_st.xCmpAddress > Fee_RdWrOrder_st.xWrAddress) &&
	ld.w	d0,[a14]
.L809:
	ld.w	d1,[a13]
.L810:
	jge.u	d1,d0,.L37
.L811:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   319                      (xPhySectIdx_u8 == xPhyWrSectIdx_u8))
	jne	d15,d2,.L38
.L812:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   320                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   321                      /* Abort */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   322                      xRetVal_en = FEE_ERROR_E;
	mov	d8,#3
.L813:
	j	.L39
.L38:
.L37:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   323                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   324                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   325                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   326                      /* Check if there are bytes within the next sector that have to be compared
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   327                       * (the Fee_LLWriteBlock function calls the compare already if one sector is filled up
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   328                       * and continues the programming afterwards. Nevertheless check this here.) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   329                      if(Fee_GlobInfoWrBlock_st.BytesAlrdyCompared_u16 < HeaderInfo_pcst->BlkLength_u16)
	ld.hu	d0,[a15]2
.L814:
	ld.hu	d1,[a12]10
.L815:
	jge.u	d0,d1,.L40
.L816:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   330                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   331                          /* Increment the logical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   332                          xLogSectIdx_u8 = (uint8)(Fee_idxLLSectorOrder_au8[xPhySectIdx_u8] + 1);
	movh.a	a15,#@his(Fee_idxLLSectorOrder_au8)
	lea	a15,[a15]@los(Fee_idxLLSectorOrder_au8)
.L817:
	addsc.a	a15,a15,d15,#0
	ld.bu	d15,[a15]
.L514:
	add	d15,#1
.L818:
	extr.u	d15,d15,#0,#8
.L516:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   333  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   334                          /* Check if switching from last to first sector requires an overflow */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   335                          if(xLogSectIdx_u8 >= FEE_NUM_FLASH_BANKS)
	movh.a	a15,#@his(Fee_NumFlashBanksUsed_u8)
	lea	a15,[a15]@los(Fee_NumFlashBanksUsed_u8)
	ld.bu	d0,[a15]
.L819:
	jlt.u	d15,d0,.L41
.L820:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   336                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   337                              /* Abort, the block cannot continue in the logical sector 0 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   338                              xRetVal_en = FEE_ERROR_E;
	mov	d8,#3
.L821:
	j	.L42
.L41:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   339                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   340                          else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   341                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   342                                 /* Before switching to next sector, check if sector is programmed with data. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   343                              if((Fee_LLSectorOrder_st[xLogSectIdx_u8].SecState_en == FEE_SECTOR_USED_E) ||
	mul	d15,d15,#12
.L517:
	movh.a	a15,#@his(Fee_LLSectorOrder_st)
	lea	a15,[a15]@los(Fee_LLSectorOrder_st)
.L822:
	addsc.a	a15,a15,d15,#0
.L823:
	ld.w	d15,[a15]4
.L824:
	jeq	d15,#2,.L43
.L825:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   344                                 (Fee_LLSectorOrder_st[xLogSectIdx_u8].SecState_en == FEE_SECTOR_FULL_E))
	jne	d15,#3,.L44
.L43:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   345                              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   346                                  /* Get the physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   347                                  xPhySectIdx_u8 = Fee_LLSectorOrder_st[xLogSectIdx_u8].xPhySecIdx_u8;
	ld.bu	d15,[a15]8
.L518:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   348  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   349                                  /* Set the new start address of the new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   350                                  Fee_RdWrOrder_st.xCmpAddress   = Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogStartAddress_u32;
	movh.a	a15,#@his(Fee_FlashProp_st)
	lea	a15,[a15]@los(Fee_FlashProp_st)
.L826:
	sha	d15,#4
.L519:
	addsc.a	a15,a15,d15,#0
.L827:
	ld.w	d15,[a15]8
.L828:
	st.w	[a14],d15
.L829:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   351  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   352                                  /* Set the next state to go on with the data compare */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   353                                  Fee_RdWrOrder_st.Fee_LLCompBlk = FEE_LL_CMP_DATA_SEC_A_E;
	mov	d15,#4
.L830:
	ld.a	a15,[a10]
	st.w	[a15],d15
.L831:
	j	.L45
.L44:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   354                              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   355                              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   356                              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   357                                  /* Abort, the block check as next sector is still not programmed with data. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   358                                  xRetVal_en = FEE_ERROR_E;
	mov	d8,#3
.L45:
.L42:
	j	.L46
.L40:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   359                              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   360                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   361                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   362                      else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   363                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   364                          /* Update the cache with the last header address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   365                          Fee_LLUpdateAddressInCache(HeaderInfo_pcst->FeeIndex_u16, HeaderInfo_pcst->AdrBlkHeader_u32);
	ld.hu	d4,[a12]12
.L832:
	ld.w	d5,[a12]
	call	Fee_LLUpdateAddressInCache
.L515:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   366  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   367                          /* All bytes have been compared without any difference, return success */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   368                          xRetVal_en = FEE_ORDER_FINISHED_E;
	mov	d8,#1
.L46:
.L39:
.L36:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   369                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   370                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   371              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   372          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   373          break;
	j	.L47

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   374  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   375          /* This state should never be reached */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   376          default:
.L9:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   377          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   378              /* Return an error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   379              xRetVal_en = FEE_ABORTED_E;
	mov	d8,#6
.L833:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   380          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   381          break;
	j	.L48

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   382      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   383  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   384  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   385      /* Check if a reset of the state machine is necessary */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   386      if(xRetVal_en != FEE_ORDER_PENDING_E)
.L48:
.L47:
.L34:
.L32:
.L23:
.L15:
.L13:
	jeq	d8,#0,.L49
.L834:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   387      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   388          /* Reset the state machine */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   389          Fee_RdWrOrder_st.Fee_LLCompBlk = FEE_LL_CMP_BLK_INIT_E;
	mov	d15,#0
.L835:
	ld.a	a15,[a10]
	st.w	[a15],d15
.L49:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   390      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   391  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   392      return (xRetVal_en);
	mov	d2,d8
.L520:
	j	.L50

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   393  }
.L50:
	ret
.L403:
	
__Fee_LLCompBlkInFlash_function_end:
	.size	Fee_LLCompBlkInFlash,__Fee_LLCompBlkInFlash_function_end-Fee_LLCompBlkInFlash
.L345:
	; End of function
	
	.sdecl	'.text.rba_FeeFs1_LlBlockHandling.Fee_LLCopyPageBuff2Marker',code,cluster('Fee_LLCopyPageBuff2Marker')
	.sect	'.text.rba_FeeFs1_LlBlockHandling.Fee_LLCopyPageBuff2Marker'
	.align	2
	
	.global	Fee_LLCopyPageBuff2Marker

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   394  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   395  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   396  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   397   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   398   * Fee_LLCopyPageBuff2Marker(): Extract the block header data
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   399   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   400   * This function extracts the block header data out of the page
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   401   * buffer.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   402   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   403   * Hint: Marker structure:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   404   *       {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   405   *          uint16  xPattern;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   406   *          uint8   xIdent;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   407   *          uint8   xContent[3];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   408   *          uint16  xChecksum;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   409   *       }Fee_MarkerProp_t;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   410   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   411   * \param    Marker_pst:        Pointer to the block header that was
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   412   *                                  found in the flash.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   413   * \param    PageBuf_pcu8:      Pointer to the page buffer
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   414   * \return
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   415   * \retval   none
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   416   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   417   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   418   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   419   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   420  FUNC(void, FEE_CODE) Fee_LLCopyPageBuff2Marker(P2VAR(Fee_MarkerProp_t, AUTOMATIC, FEE_APPL_DATA) Marker_pst,
; Function Fee_LLCopyPageBuff2Marker
.L311:
Fee_LLCopyPageBuff2Marker:	.type	func

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   421                                                 P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   422  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   423      /* 0xCAFE <- [0]: CA, [1]: FE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   424      Marker_pst->xPattern     = ((uint16)(((uint16)(PageBuf_pcu8[0])) << 8u) | (uint16)PageBuf_pcu8[1]);
	ld.bu	d15,[a5]
.L1398:
	sha	d0,d15,#8
.L1399:
	ld.bu	d15,[a5]1
.L1400:
	or	d0,d15
.L1401:
	st.h	[a4],d0
.L1402:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   425      Marker_pst->xIdent       = PageBuf_pcu8[2];
	ld.bu	d15,[a5]2
.L1403:
	st.b	[a4]2,d15
.L1404:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   426  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   427      /* 0x02   <- [3]:  0, [4]:  0, [5]: 2 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   428      Marker_pst->xContent[0]  = PageBuf_pcu8[3];
	ld.bu	d15,[a5]3
.L1405:
	st.b	[a4]3,d15
.L1406:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   429      Marker_pst->xContent[1]  = PageBuf_pcu8[4];
	ld.bu	d15,[a5]4
.L1407:
	st.b	[a4]4,d15
.L1408:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   430      Marker_pst->xContent[2]  = PageBuf_pcu8[5];
	ld.bu	d15,[a5]5
.L1409:
	st.b	[a4]5,d15
.L1410:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   431  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   432      /* 0xFA33 <- [6]: FA, [7]: 33 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   433      Marker_pst->xChecksum    = ((uint16)(((uint16)(PageBuf_pcu8[6])) << 8u) | (uint16)PageBuf_pcu8[7]);
	ld.bu	d15,[a5]6
.L1411:
	sha	d0,d15,#8
.L1412:
	ld.bu	d15,[a5]7
.L1413:
	or	d0,d15
.L1414:
	st.h	[a4]6,d0
.L1415:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   434  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   435  }
	ret
.L453:
	
__Fee_LLCopyPageBuff2Marker_function_end:
	.size	Fee_LLCopyPageBuff2Marker,__Fee_LLCopyPageBuff2Marker_function_end-Fee_LLCopyPageBuff2Marker
.L365:
	; End of function
	
	.sdecl	'.text.rba_FeeFs1_LlBlockHandling.Fee_LLPrepMarkerBufWithMarkerData',code,cluster('Fee_LLPrepMarkerBufWithMarkerData')
	.sect	'.text.rba_FeeFs1_LlBlockHandling.Fee_LLPrepMarkerBufWithMarkerData'
	.align	2
	
	.global	Fee_LLPrepMarkerBufWithMarkerData

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   436  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   437  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   438  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   439   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   440   * Fee_LLPrepMarkerBufWithMarkerData(): Prepare the marker buffer with
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   441   *                                      block the header data
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   442   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   443   * This function prepares the marker buffer with the marker data
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   444   * for writing this data to the flash. This is done to ensure the
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   445   * same data interpretation within the complete Fee driver.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   446   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   447   * Hint: Marker structure:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   448   *       {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   449   *          uint16  xPattern;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   450   *          uint8   xIdent;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   451   *          uint8   xContent[3];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   452   *          uint16  xChecksum;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   453   *       }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   454   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   455   * \param    Marker_pcst:  Pointer to the marker structure
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   456   * \param    Data_pu8:     Pointer to the marker buffer that will
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   457   *                         be used to write the data into the flash
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   458   * \return
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   459   * \retval   none
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   460   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   461   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   462   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   463   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   464  FUNC(void, FEE_CODE) Fee_LLPrepMarkerBufWithMarkerData(P2CONST(Fee_MarkerProp_t, AUTOMATIC, FEE_APPL_DATA) Marker_pcst,
; Function Fee_LLPrepMarkerBufWithMarkerData
.L313:
Fee_LLPrepMarkerBufWithMarkerData:	.type	func

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   465                                                         P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) MarkerBuf_pu8)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   466  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   467      /* 0xCAFE <- [0]: CA, [1]: FE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   468      MarkerBuf_pu8[0] = (uint8)(Marker_pcst->xPattern >> 8u);
	ld.hu	d15,[a4]0
.L1376:
	sha	d15,#-8
.L1377:
	st.b	[a5],d15
.L1378:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   469      MarkerBuf_pu8[1] = (uint8)Marker_pcst->xPattern;
	ld.hu	d15,[a4]0
.L1379:
	st.b	[a5]1,d15
.L1380:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   470  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   471      MarkerBuf_pu8[2] = Marker_pcst->xIdent;
	ld.bu	d15,[a4]2
.L1381:
	st.b	[a5]2,d15
.L1382:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   472  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   473      /* 0x02 <- [0]: 0, [1]: 0, [2]: 2 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   474      MarkerBuf_pu8[3] = Marker_pcst->xContent[0];
	ld.bu	d15,[a4]3
.L1383:
	st.b	[a5]3,d15
.L1384:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   475      MarkerBuf_pu8[4] = Marker_pcst->xContent[1];
	ld.bu	d15,[a4]4
.L1385:
	st.b	[a5]4,d15
.L1386:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   476      MarkerBuf_pu8[5] = Marker_pcst->xContent[2];
	ld.bu	d15,[a4]5
.L1387:
	st.b	[a5]5,d15
.L1388:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   477  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   478      /* 0xABCD <- [0]: AB, [1]: CD */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   479      MarkerBuf_pu8[6] = (uint8)(Marker_pcst->xChecksum >> 8u);
	ld.hu	d15,[a4]6
.L1389:
	sha	d15,#-8
.L1390:
	st.b	[a5]6,d15
.L1391:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   480      MarkerBuf_pu8[7] = (uint8)Marker_pcst->xChecksum;
	ld.hu	d15,[a4]6
.L1392:
	st.b	[a5]7,d15
.L1393:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   481  }
	ret
.L449:
	
__Fee_LLPrepMarkerBufWithMarkerData_function_end:
	.size	Fee_LLPrepMarkerBufWithMarkerData,__Fee_LLPrepMarkerBufWithMarkerData_function_end-Fee_LLPrepMarkerBufWithMarkerData
.L360:
	; End of function
	
	.sdecl	'.text.rba_FeeFs1_LlBlockHandling.Fee_LLCopyPageBuff2HeaderMid',code,cluster('Fee_LLCopyPageBuff2HeaderMid')
	.sect	'.text.rba_FeeFs1_LlBlockHandling.Fee_LLCopyPageBuff2HeaderMid'
	.align	2
	
	.global	Fee_LLCopyPageBuff2HeaderMid

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   482  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   483  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   484  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   485   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   486   * Fee_LLCopyPageBuff2HeaderMid(): Extract the rest up to the CRC 32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   487   *                                 of the block header data
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   488   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   489   * This function extracts block status, the Fee index and length from
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   490   * the block header data out of the page buffer.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   491   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   492   * Hint: Block header structure:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   493   *       {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   494   *          uint8   Preamble_au8[3];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   495   *          uint8   BlkStatus_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   496   *          uint16  FeeIndex_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   497   *          uint16  BlkLength_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   498   *          uint16  HdrCrc16_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   499   *          uint32  BlkCrc32_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   500   *       }Fee_BlkHeader_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   501   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   502   * \param    BlkHdr_pst:    Pointer to the block header that was
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   503   *                          found in the flash.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   504   * \param    PageBuf_pcu8:  Pointer to the page buffer
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   505   * \return
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   506   * \retval   none
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   507   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   508   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   509   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   510   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   511  FUNC(void, FEE_CODE) Fee_LLCopyPageBuff2HeaderMid(P2VAR(Fee_BlkHeader_tst, AUTOMATIC, FEE_APPL_DATA) BlkHdr_pst,
; Function Fee_LLCopyPageBuff2HeaderMid
.L315:
Fee_LLCopyPageBuff2HeaderMid:	.type	func

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   512                                                    P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   513  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   514      BlkHdr_pst->BlkStatus_u8    = PageBuf_pcu8[3];
	ld.bu	d15,[a5]3
.L1519:
	st.b	[a4]3,d15
.L1520:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   515  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   516      /* 0xD2E9 <- [4]: D2, [5]: E9 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   517      BlkHdr_pst->FeeIndex_u16    = ((uint16)(((uint16)(PageBuf_pcu8[4])) << 8u)  | (uint16)(PageBuf_pcu8[5]));
	ld.bu	d15,[a5]4
.L1521:
	sha	d0,d15,#8
.L1522:
	ld.bu	d15,[a5]5
.L1523:
	or	d0,d15
.L1524:
	st.h	[a4]4,d0
.L1525:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   518  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   519      /* 0x0008 <- [6]: 00, [7]: 08 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   520      BlkHdr_pst->BlkLength_u16   = ((uint16)(((uint16)(PageBuf_pcu8[6])) << 8u)  | (uint16)(PageBuf_pcu8[7]));
	ld.bu	d15,[a5]6
.L1526:
	sha	d0,d15,#8
.L1527:
	ld.bu	d15,[a5]7
.L1528:
	or	d0,d15
.L1529:
	st.h	[a4]6,d0
.L1530:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   521  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   522      /* 0xABCD <- [8]: AB, [9]: CD */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   523      BlkHdr_pst->HdrCrc16_u16    = ((uint16)(((uint16)(PageBuf_pcu8[8])) << 8u)  | (uint16)(PageBuf_pcu8[9]));
	ld.bu	d15,[a5]8
.L1531:
	sha	d0,d15,#8
.L1532:
	ld.bu	d15,[a5]9
.L1533:
	or	d0,d15
.L1534:
	st.h	[a4]8,d0
.L1535:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   524  }
	ret
.L467:
	
__Fee_LLCopyPageBuff2HeaderMid_function_end:
	.size	Fee_LLCopyPageBuff2HeaderMid,__Fee_LLCopyPageBuff2HeaderMid_function_end-Fee_LLCopyPageBuff2HeaderMid
.L380:
	; End of function
	
	.sdecl	'.text.rba_FeeFs1_LlBlockHandling.Fee_LLCopyPageBuff2HeaderEnd',code,cluster('Fee_LLCopyPageBuff2HeaderEnd')
	.sect	'.text.rba_FeeFs1_LlBlockHandling.Fee_LLCopyPageBuff2HeaderEnd'
	.align	2
	
	.global	Fee_LLCopyPageBuff2HeaderEnd

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   525  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   526  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   527  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   528   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   529   * Fee_LLCopyPageBuff2HeaderEnd(): Extract the CRC 32 out
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   530   *                                 of the block header data
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   531   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   532   * This function extracts CRC32 out of the block header data.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   533   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   534   * Hint: Block header structure:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   535   *       {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   536   *          uint8   Preamble_au8[3];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   537   *          uint8   BlkStatus_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   538   *          uint16  FeeIndex_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   539   *          uint16  BlkLength_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   540   *          uint16  HdrCrc16_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   541   *          uint32  BlkCrc32_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   542   *       }Fee_BlkHeader_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   543   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   544   * \param    BlkHdr_pst:    Pointer to the block header that was
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   545   *                          found in the flash.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   546   * \param    PageBuf_pcu8:  Pointer to the page buffer
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   547   * \return
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   548   * \retval   none
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   549   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   550   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   551   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   552   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   553  FUNC(void, FEE_CODE) Fee_LLCopyPageBuff2HeaderEnd(P2VAR(Fee_BlkHeader_tst, AUTOMATIC, FEE_APPL_DATA) BlkHdr_pst,
; Function Fee_LLCopyPageBuff2HeaderEnd
.L317:
Fee_LLCopyPageBuff2HeaderEnd:	.type	func

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   554                                                    P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   555  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   556      BlkHdr_pst->BlkCrc32_u32    = (uint32)((((uint32)(PageBuf_pcu8[10])) << 24u) |
	ld.bu	d15,[a5]10
.L1540:
	sh	d0,d15,#24
.L1541:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   557                                             (((uint32)(PageBuf_pcu8[11])) << 16u) |
	ld.bu	d15,[a5]11
.L1542:
	sh	d15,d15,#16
.L1543:
	or	d0,d15
.L1544:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   558                                             (((uint32)(PageBuf_pcu8[12])) << 8u)  |
	ld.bu	d15,[a5]12
.L1545:
	sh	d15,d15,#8
.L1546:
	or	d0,d15
.L1547:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   559                                             (((uint32)(PageBuf_pcu8[13]))));
	ld.bu	d15,[a5]13
.L1548:
	or	d0,d15
.L1549:
	st.w	[a4]12,d0
.L1550:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   560  }
	ret
.L471:
	
__Fee_LLCopyPageBuff2HeaderEnd_function_end:
	.size	Fee_LLCopyPageBuff2HeaderEnd,__Fee_LLCopyPageBuff2HeaderEnd_function_end-Fee_LLCopyPageBuff2HeaderEnd
.L385:
	; End of function
	
	.sdecl	'.text.rba_FeeFs1_LlBlockHandling.Fee_LLPrepPageBufWithHdrDataStart',code,cluster('Fee_LLPrepPageBufWithHdrDataStart')
	.sect	'.text.rba_FeeFs1_LlBlockHandling.Fee_LLPrepPageBufWithHdrDataStart'
	.align	2
	
	.global	Fee_LLPrepPageBufWithHdrDataStart

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   561  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   562  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   563  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   564   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   565   * Fee_LLPrepPageBufWithHdrData(): Prepare the page buffer with block
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   566   *                                 header data
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   567   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   568   * This function prepares the page buffer with block header data
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   569   * for writing this data to the flash.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   570   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   571   * Hint: Block header structure:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   572   *       {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   573   *          uint8   Preamble_au8[3];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   574   *          uint8   BlkStatus_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   575   *          uint16  FeeIndex_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   576   *          uint16  BlkLength_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   577   *          uint16  HdrCrc16_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   578   *          uint32  BlkCrc32_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   579   *       }Fee_BlkHeader_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   580   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   581   * \param    HeaderInfo_pst:   Pointer to the block header structure
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   582   *                             that needs to be written into the flash
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   583   * \return
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   584   * \retval   none
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   585   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   586   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   587   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   588   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   589  FUNC(void, FEE_CODE) Fee_LLPrepPageBufWithHdrDataStart(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) HeaderInfo_pst)
; Function Fee_LLPrepPageBufWithHdrDataStart
.L319:
Fee_LLPrepPageBufWithHdrDataStart:	.type	func
	mov.aa	a12,a4
.L522:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   590  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   591      VAR(uint16, AUTOMATIC) xPageCrc_u16 = 0;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   592  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   593      /* Reset the already considered bytes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   594      Fee_GlobInfoWrBlock_st.BytesAlrdyConsid_u16 = 0;
	movh.a	a2,#@his(Fee_GlobInfoWrBlock_st)
	lea	a2,[a2]@los(Fee_GlobInfoWrBlock_st)
.L1420:
	mov	d15,#0
.L1421:
	st.h	[a2],d15
.L1422:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   595  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   596      /* 0xA53C96 -> [0]: A5, [1]: 3C, [2]: 96 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   597      Fee_PageBytePtr_cpu8[0] = (uint8)FEE_BLK_HEADER_PREAMBEL_BYTE_0;
	movh.a	a13,#@his(Fee_PageBytePtr_cpu8)
	lea	a13,[a13]@los(Fee_PageBytePtr_cpu8)
	ld.a	a2,[a13]
.L1423:
	mov	d15,#165
.L1424:
	st.b	[a2],d15
.L1425:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   598      Fee_PageBytePtr_cpu8[1] = (uint8)FEE_BLK_HEADER_PREAMBEL_BYTE_1;
	ld.a	a15,[a13]
.L1426:
	mov	d15,#60
.L1427:
	st.b	[a15]1,d15
.L1428:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   599      Fee_PageBytePtr_cpu8[2] = (uint8)FEE_BLK_HEADER_PREAMBEL_BYTE_2;
	ld.a	a15,[a13]
.L1429:
	mov	d15,#150
.L1430:
	st.b	[a15]2,d15
.L1431:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   600  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   601      Fee_PageBytePtr_cpu8[3] = HeaderInfo_pst->BlkStatus_u8;
	ld.a	a15,[a13]
.L1432:
	ld.bu	d15,[a12]14
.L1433:
	st.b	[a15]3,d15
.L1434:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   602  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   603      /* MSByte: 0xD2E9 -> D2 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   604      Fee_PageBytePtr_cpu8[4] = (uint8)(HeaderInfo_pst->FeeIndex_u16 >> 8u);
	ld.a	a15,[a13]
.L1435:
	ld.hu	d15,[a12]12
.L1436:
	sha	d15,#-8
.L1437:
	st.b	[a15]4,d15
.L1438:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   605      /* LSByte:        -> E9*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   606      Fee_PageBytePtr_cpu8[5] = (uint8)((HeaderInfo_pst->FeeIndex_u16) & 0xFFu);
	ld.a	a15,[a13]
.L1439:
	ld.hu	d15,[a12]12
.L1440:
	st.b	[a15]5,d15
.L1441:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   607  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   608      /* MSByte: 0x08   -> 00 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   609      Fee_PageBytePtr_cpu8[6] = (uint8)(HeaderInfo_pst->BlkLength_u16 >> 8u);
	ld.a	a15,[a13]
.L1442:
	ld.hu	d15,[a12]10
.L1443:
	sha	d15,#-8
.L1444:
	st.b	[a15]6,d15
.L1445:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   610      /* LSByte:        -> 08 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   611      Fee_PageBytePtr_cpu8[7] = (uint8)((HeaderInfo_pst->BlkLength_u16) & 0xFFu);
	ld.a	a15,[a13]
.L1446:
	ld.hu	d15,[a12]10
.L1447:
	st.b	[a15]7,d15
.L1448:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   612  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   613      /* Calculate the CRC over an 8 byte data array */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   614      xPageCrc_u16 = Crc_CalculateCRC16((uint8*)&Fee_PageBytePtr_cpu8[0],
	ld.a	a4,[a13]
.L521:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   615                                            (uint32)(FEE_BLK_HEADER_SIZE-6u),
	mov	d4,#8
.L1449:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   616                                            (uint16)FEE_MARKER_PATTERN,
	mov.u	d5,#51966
.L1450:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   617                                             FALSE);
	mov	d6,#0
	call	Crc_CalculateCRC16
.L523:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   618  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   619      Fee_PageBytePtr_cpu8[8] = (uint8)(xPageCrc_u16 >> 8u);
	ld.a	a15,[a13]
.L1451:
	sha	d15,d2,#-8
.L1452:
	st.b	[a15]8,d15
.L1453:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   620      Fee_PageBytePtr_cpu8[9] = (uint8)(xPageCrc_u16  & 0xFFu);
	ld.a	a15,[a13]
.L1454:
	st.b	[a15]9,d2
.L1455:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   621  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   622      /* Save the header Crc (this is necessary for calculating the block checksum in case no
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   623       * block has been found so far) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   624      HeaderInfo_pst->HdrCrc16_u16 = xPageCrc_u16;
	st.h	[a12]8,d2
.L1456:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   625  }
	ret
.L457:
	
__Fee_LLPrepPageBufWithHdrDataStart_function_end:
	.size	Fee_LLPrepPageBufWithHdrDataStart,__Fee_LLPrepPageBufWithHdrDataStart_function_end-Fee_LLPrepPageBufWithHdrDataStart
.L370:
	; End of function
	
	.sdecl	'.text.rba_FeeFs1_LlBlockHandling.Fee_LLPrepPageBufWithHdrDataEnd',code,cluster('Fee_LLPrepPageBufWithHdrDataEnd')
	.sect	'.text.rba_FeeFs1_LlBlockHandling.Fee_LLPrepPageBufWithHdrDataEnd'
	.align	2
	
	.global	Fee_LLPrepPageBufWithHdrDataEnd

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   626  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   627  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   628  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   629   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   630   * Fee_LLPrepPageBufWithHdrDataEnd(): Prepare the page buffer with block
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   631   *                                    header data
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   632   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   633   * This function prepares the page buffer with block header data
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   634   * for writing this data to the flash.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   635   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   636   * Hint: Block header structure:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   637   *       {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   638   *          uint8   Preamble_au8[3];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   639   *          uint8   BlkStatus_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   640   *          uint16  FeeIndex_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   641   *          uint16  BlkLength_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   642   *          uint16  HdrCrc16_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   643   *          uint32  BlkCrc32_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   644   *       }Fee_BlkHeader_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   645   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   646   * \param    HeaderInfo_pst:   Pointer to the block header structure
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   647   *                             that needs to be written into the flash
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   648   * \param    Data_pcu8:        Pointer to the user data
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   649   * \param    BlkCrc32_u32:     Block checksum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   650   * \return
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   651   * \retval   none
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   652   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   653   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   654   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   655   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   656  FUNC(void, FEE_CODE) Fee_LLPrepPageBufWithHdrDataEnd(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) HeaderInfo_pst,
; Function Fee_LLPrepPageBufWithHdrDataEnd
.L321:
Fee_LLPrepPageBufWithHdrDataEnd:	.type	func
	mov.aa	a6,a4
.L527:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   657                                                         P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) Data_pcu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   658                                                         VAR(uint32, AUTOMATIC) BlkCrc32_u32)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   659  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   660      VAR(uint16, AUTOMATIC) xNumBytes_u16 = 0;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   661      VAR(uint16, AUTOMATIC) i = 0;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   662  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   663      /* Reset the already considered bytes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   664      Fee_GlobInfoWrBlock_st.BytesAlrdyConsid_u16 = 0;
	movh.a	a4,#@his(Fee_GlobInfoWrBlock_st)
.L526:
	lea	a4,[a4]@los(Fee_GlobInfoWrBlock_st)
.L1461:
	mov	d15,#0
.L1462:
	st.h	[a4],d15
.L1463:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   665  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   666      /* Add the block CRC to the page buffer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   667      Fee_PageBytePtr_cpu8[10] = (uint8) (BlkCrc32_u32 >> 24u);
	movh.a	a7,#@his(Fee_PageBytePtr_cpu8)
	lea	a7,[a7]@los(Fee_PageBytePtr_cpu8)
	ld.a	a15,[a7]
.L1464:
	sh	d15,d4,#-24
.L1465:
	st.b	[a15]10,d15
.L1466:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   668      Fee_PageBytePtr_cpu8[11] = (uint8) (BlkCrc32_u32 >> 16u);
	ld.a	a15,[a7]
.L1467:
	sh	d15,d4,#-16
.L1468:
	st.b	[a15]11,d15
.L1469:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   669      Fee_PageBytePtr_cpu8[12] = (uint8) (BlkCrc32_u32 >> 8u);
	ld.a	a15,[a7]
.L1470:
	sh	d15,d4,#-8
.L1471:
	st.b	[a15]12,d15
.L1472:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   670      Fee_PageBytePtr_cpu8[13] = (uint8)  BlkCrc32_u32; // Would be a shift by 0
	ld.a	a15,[a7]
.L1473:
	st.b	[a15]13,d4
.L1474:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   671  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   672      /* Save the block CRC for the verification after writing */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   673      HeaderInfo_pst->BlkCrc32_u32 = BlkCrc32_u32;
	st.w	[a6]4,d4
.L1475:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   674  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   675      /* Depending on the page size the header needs more than 1 page and there might be free space for
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   676       * data behind the header
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   677       * --> copy also data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   678      if((HeaderInfo_pst->BlkStatus_u8 & (uint8)FEE_FLAG_INVALID_MSK) > 0)
	ld.bu	d15,[a6]14
.L1476:
	and	d15,#8
.L1477:
	jeq	d15,#0,.L51
.L1478:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   679      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   680          /* Reset the data length to the number of free bytes after the header data
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   681           * within the same page (length != 0 for filling up the rest of the page
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   682           * with a defined value) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   683          xNumBytes_u16 = FEE_FREE_BYTES_AFTER_HEADER;
	mov	d4,#2
.L524:
	j	.L52
.L51:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   684      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   685      else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   686      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   687          /* Set the block length for filling up the header pages */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   688          xNumBytes_u16 = HeaderInfo_pst->BlkLength_u16;
	ld.hu	d4,[a6]10
.L52:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   689      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   690  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   691      #if(FEE_ROB_FEATURE_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   692      /* Check for an activated block robustness feature */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   693      if((((Fee_BlockProperties_st[Fee_OrderFifo_st[Fee_idxActQueue_u8].BlockPropIdx_u16].Flags_u16 &
	movh.a	a12,#@his(Fee_idxActQueue_u8)
	lea	a12,[a12]@los(Fee_idxActQueue_u8)
.L1479:
	movh.a	a13,#@his(Fee_OrderFifo_st)
	lea	a13,[a13]@los(Fee_OrderFifo_st)
.L1480:
	movh.a	a14,#@his(Fee_BlockProperties_st)
	lea	a14,[a14]@los(Fee_BlockProperties_st)
.L1481:
	ld.bu	d0,[a12]
.L1482:
	mul	d0,d0,#24
	addsc.a	a2,a13,d0,#0
.L1483:
	ld.hu	d0,[a2]6
	sha	d0,#4
.L1484:
	addsc.a	a2,a14,d0,#0
.L1485:
	ld.hu	d0,[a2]2
.L1486:
	and	d0,d0,#32
.L1487:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   694                                            (uint16)FEE_FLAG_ROBUST_ATTR_MSK) >> (uint16)FEE_FLAG_ROBUST_ATTR_BP) > 0) &&
	sha	d0,#-5
.L1488:
	jeq	d0,#0,.L53
.L1489:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   695          ((HeaderInfo_pst->BlkStatus_u8 & (uint8)FEE_FLAG_INVALID_MSK) == 0))
	jne	d15,#0,.L54
.L1490:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   696      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   697          /* Set the block length for filling up the header pages */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   698          xNumBytes_u16 -= FEE_SIZE_OF_BLOCK_CS;
	add	d4,#-4
.L528:
	extr.u	d4,d4,#0,#16
.L54:
.L53:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   699      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   700      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   701  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   702      if(xNumBytes_u16 > FEE_FREE_BYTES_AFTER_HEADER)
	lt.u	d15,d4,#3
.L1491:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   703      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   704          /* Restrict the number of bytes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   705          xNumBytes_u16 = FEE_FREE_BYTES_AFTER_HEADER;
	cmovn	d4,d15,#2
.L55:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   706      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   707  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   708      /* Copy the number of data bytes behind the block header until the last page of the
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   709       * block header is filled up */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   710      for(i=0; i<xNumBytes_u16; i++)
	mov	d15,#0
.L529:
	j	.L56
.L57:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   711      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   712          /* Differ between invalidation and other orders */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   713          if((HeaderInfo_pst->BlkStatus_u8 & (uint8)FEE_FLAG_INVALID_MSK) > 0)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   714          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   715              /* Copy the erase pattern only */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   716              Fee_PageBytePtr_cpu8[FEE_BLK_HEADER_SIZE+i] = 0;
	ld.a	a15,[a7]
.L1492:
	addsc.a	a15,a15,d15,#0
	lea	a15,[a15]14
.L1493:
	ld.bu	d0,[a6]14
.L1494:
	jz.t	d0:3,.L58
.L1495:
	mov	d0,#0
.L1496:
	st.b	[a15],d0
.L1497:
	j	.L59
.L58:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   717          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   718          else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   719          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   720              /* Copy the data bytes to the buffer which is used for writing the header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   721              Fee_PageBytePtr_cpu8[FEE_BLK_HEADER_SIZE+i] = Data_pcu8[i];
	addsc.a	a2,a5,d15,#0
	ld.bu	d0,[a2]
.L1498:
	st.b	[a15],d0
.L1499:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   722  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   723              /* Increment amount of data that has already been considered for writing
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   724               * (only for Non - invalidation orders because block length was overwritten
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   725               * with zero otherwise) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   726              Fee_GlobInfoWrBlock_st.BytesAlrdyConsid_u16++;
	ld.hu	d0,[a4]0
.L1500:
	add	d0,#1
	st.h	[a4],d0
.L59:
	add	d15,#1
.L530:
	extr.u	d15,d15,#0,#16
.L56:
	jlt.u	d15,d4,.L57
.L1501:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   727          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   728      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   729  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   730      #if(FEE_ROB_FEATURE_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   731      /* Check if the robustness checksum start value must be calculated */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   732      if(((Fee_BlockProperties_st[Fee_OrderFifo_st[Fee_idxActQueue_u8].BlockPropIdx_u16].Flags_u16 &
	ld.bu	d15,[a12]
.L531:
	mul	d15,d15,#24
	addsc.a	a15,a13,d15,#0
.L1502:
	ld.hu	d15,[a15]6
	sha	d15,#4
.L1503:
	addsc.a	a15,a14,d15,#0
.L1504:
	ld.hu	d15,[a15]2
.L1505:
	and	d15,#32
.L1506:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   733                                              (uint16)FEE_FLAG_ROBUST_ATTR_MSK) >> (uint16)FEE_FLAG_ROBUST_ATTR_BP) > 0)
	sha	d15,#-5
.L1507:
	jeq	d15,#0,.L60
.L1508:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   734      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   735          /* Save the start value for the robustness checksum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   736           * Hint: Only the data bytes within the header are regarded to far.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   737           *       The robustness checksum is calculated in small pieces using an internal
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   738           *       buffer. The calculation can be done at any time as soon as the user data
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   739           *       has been transfered. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   740          Fee_DataByteStartCrc_u32 = Crc_CalculateCRC32(&Fee_PageBytePtr_cpu8[FEE_BLK_HEADER_SIZE],
	movh.a	a12,#@his(Fee_DataByteStartCrc_u32)
	lea	a12,[a12]@los(Fee_DataByteStartCrc_u32)
.L1509:
	ld.a	a15,[a7]
.L1510:
	lea	a4,[a15]14
.L1511:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   741                                                        (uint32)xNumBytes_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   742                                                        (((uint32)HeaderInfo_pst->HdrCrc16_u16) ^ FEE_MAXUINT32),
	ld.hu	d5,[a6]8
.L1512:
	mov	d15,#-1
.L1513:
	xor	d5,d15
.L1514:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   743                                                        FALSE);
	mov	d6,#0
	call	Crc_CalculateCRC32
.L525:
	st.w	[a12],d2
.L60:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   744      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   745      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   746  }
	ret
.L461:
	
__Fee_LLPrepPageBufWithHdrDataEnd_function_end:
	.size	Fee_LLPrepPageBufWithHdrDataEnd,__Fee_LLPrepPageBufWithHdrDataEnd_function_end-Fee_LLPrepPageBufWithHdrDataEnd
.L375:
	; End of function
	
	.sdecl	'.text.rba_FeeFs1_LlBlockHandling.Fee_LLCopyData2Buffer',code,cluster('Fee_LLCopyData2Buffer')
	.sect	'.text.rba_FeeFs1_LlBlockHandling.Fee_LLCopyData2Buffer'
	.align	2
	
	.global	Fee_LLCopyData2Buffer

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   747  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   748  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   749  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   750   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   751   * Fee_LLCopyData2Buffer(): Read out the block data
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   752   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   753   * This function copies the block data without the header information
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   754   * to a buffer given by the user. Offset and length are considered.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   755   * Offsets != zero are not supported.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   756   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   757   * \param    Fee_GlobInfoLastRdHeader_pcst: Pointer to the latest valid
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   758   *                                  block header content of the block
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   759   *                                  to read
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   760   * \param    DataPtr_pu8:           Pointer to store the requested data
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   761   * \param    DataOffset_u16:        Data offset within the block
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   762   * \param    DataLength_u16:        Data length
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   763   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   764   * \return   Function result
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   765   * \retval   FEE_ORDER_PENDING_E:   Order is still pending
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   766   * \retval   FEE_ABORTED_E:         Order was aborted due to a wrong
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   767   *                                  Fls function call or a busy Fls
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   768   * \retval   FEE_ERROR_E:           A read or write error occured
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   769   * \retval   FEE_ORDER_FINISHED_E:  The block was copied successfully
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   770   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   771   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   772   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   773   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   774  FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLCopyData2Buffer(P2CONST(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Fee_GlobInfoLastRdHeader_pcst,
; Function Fee_LLCopyData2Buffer
.L323:
Fee_LLCopyData2Buffer:	.type	func
	sub.a	a10,#8
.L532:
	mov.aa	a12,a5
.L535:
	mov	d10,d4
.L537:
	mov	d9,d5
.L539:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   775                                                         P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) DataPtr_pu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   776                                                         VAR(uint16, FEE_VAR) DataOffset_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   777                                                         VAR(uint16, FEE_VAR) DataLength_u16)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   778  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   779      VAR(Fee_stRetVal_ten, AUTOMATIC) xRetVal_en = FEE_ORDER_PENDING_E;     /* Function return */
	mov	d8,#0
.L541:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   780      VAR(uint32, FEE_VAR) xNumBytesToSectEnd_u32 = 0;        /* Amount of bytes to the end of the sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   781      VAR(uint16, FEE_VAR) xNumBytesOfsConsid_u16 = 0;        /* Amount of bytes that are not relevant */
	mov	d11,#0
.L542:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   782      VAR(uint8, FEE_VAR)  xLogSectIdx_u8         = 0;        /* Logical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   783      VAR(uint8, FEE_VAR)  xCntSect_u8            = 1;        /* Sector counter */
	mov	d12,#1
.L544:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   784      VAR(uint8, FEE_VAR)  xPhySectIdx_u8         = 0;        /* Physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   785      VAR(boolean, FEE_VAR) xStartAdrFound_b      = FALSE;    /* Indicator for exiting the search loop */
	mov	d13,#0
.L546:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   786  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   787  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   788      /* Switch over state machine */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   789      switch (Fee_RdWrOrder_st.Fee_LLCopyBlk_en)
	movh.a	a13,#@his(Fee_RdWrOrder_st)
	lea	a13,[a13]@los(Fee_RdWrOrder_st)
.L1555:
	lea	a14,[a13]80
	ld.w	d0,[a14]
.L1556:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   790      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   791          /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   792          case FEE_LL_CPY_BLK_INIT_E:
	mov	d15,#0
	jeq	d15,d0,.L61
.L1557:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   793          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   794              /* Reset the amount of bytes that have already been considered for the transfer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   795              Fee_GlobInfoWrBlock_st.BytesAlrdyConsid_u16 = 0;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   796  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   797              /* Identify the sector with the first relevant user data to copy and the amount of
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   798               * bytes that have to be copied in the first run */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   799  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   800              /* Set the data start address with offset = 0 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   801              Fee_RdWrOrder_st.xRdAddress = (uint32)(Fee_GlobInfoLastRdHeader_pcst->AdrBlkHeader_u32 +
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   802                                                    (uint32)FEE_BLK_HEADER_SIZE);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   803  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   804              /* Get the current physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   805              xPhySectIdx_u8 = Fee_GetPhysSectorByAddress(Fee_RdWrOrder_st.xRdAddress);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   806  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   807              /* Get the corresponding logical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   808              xLogSectIdx_u8 = (uint8)(Fee_idxLLSectorOrder_au8[xPhySectIdx_u8]);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   809  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   810              /* Consider the offset for the header sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   811              if((uint32)((Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogEndAddress_u32 + 1u) -
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   812                      Fee_RdWrOrder_st.xRdAddress) <= DataOffset_u16)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   813              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   814                  /* The start address for the read is not within the header sector
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   815                   * --> check any following sectors */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   816                  do
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   817                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   818                      /* Calculate the amount of bytes that are not necessary inside the previous sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   819                      xNumBytesOfsConsid_u16 += (uint16)((Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogEndAddress_u32 + 1u) -
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   820                              Fee_RdWrOrder_st.xRdAddress);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   821  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   822                      /* Increment the logical sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   823                      xLogSectIdx_u8++;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   824  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   825                      /* Sector overflow not necessary because the checksum verification was done before.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   826                       * This would have failed in case s.th. was wrong with the sector order. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   827  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   828                      /* Get the new physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   829                      xPhySectIdx_u8 = Fee_LLSectorOrder_st[xLogSectIdx_u8].xPhySecIdx_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   830  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   831                      /* Increment the amount of checked sectors */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   832                      xCntSect_u8++;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   833  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   834                      /* Check if the data start address is within the next sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   835                      if((((uint32)(Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogEndAddress_u32 + 1u) -
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   836                                    Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogStartAddress_u32)) >
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   837                           (uint32)(DataOffset_u16 - xNumBytesOfsConsid_u16))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   838                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   839                          /* The start address was found within this sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   840  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   841                          /* Set the read start address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   842                          Fee_RdWrOrder_st.xRdAddress = (uint32)((Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogStartAddress_u32 +
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   843                                                                 DataOffset_u16) -
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   844                                                                 xNumBytesOfsConsid_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   845  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   846                          /* End loop */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   847                          xStartAdrFound_b = TRUE;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   848                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   849                      else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   850                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   851                          /* The start address is still not found because of the offset */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   852  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   853                          /* Reset read address to the current sector for next run */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   854                          Fee_RdWrOrder_st.xRdAddress = Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogStartAddress_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   855  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   856                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   857                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   858                  while((xStartAdrFound_b == FALSE) ||
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   859                        (xCntSect_u8 >= FEE_NUM_FLASH_BANKS));
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   860              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   861              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   862              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   863                  /* The start address is within the header sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   864                  /* The offset can be added without causing an sector overflow */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   865                  Fee_RdWrOrder_st.xRdAddress += DataOffset_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   866              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   867  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   868              /* Calculate amount of bytes to the sector end for first read out */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   869              xNumBytesToSectEnd_u32 = (uint32)((Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogEndAddress_u32 + 1u) -
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   870                      Fee_RdWrOrder_st.xRdAddress);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   871  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   872              /* Check if the amount of bytes to read needs to be restricted (sector overflow) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   873              if(xNumBytesToSectEnd_u32 < DataLength_u16)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   874              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   875                  /* Restrict the amount of bytes to read */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   876                  Fee_GlobInfoWrBlock_st.Bytes2Read_u16 = (uint16)xNumBytesToSectEnd_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   877              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   878              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   879              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   880                  /* The complete data can be read out in one step */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   881                  Fee_GlobInfoWrBlock_st.Bytes2Read_u16 = DataLength_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   882              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   883  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   884              /* Set the state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   885              Fee_RdWrOrder_st.Fee_LLCopyBlk_en = FEE_LL_CPY_BLOCK_START_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   886          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   887          /* No break to save time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   888  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   889          /* Read out the data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   890          /* MR12 RULE 16.3 VIOLATION: Time critical position */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   891          case FEE_LL_CPY_BLOCK_START_E:
	mov	d1,#1
	jeq	d1,d0,.L62
.L1558:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   892          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   893              #if (FEE_PRV_DEBUGGING != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   894              Fee_Prv_stModuleTest_st.Fee_DataReadStart_u32 = Mcu_Rb_GetSysTimePart(TIM0);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   895  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   896              Fee_Prv_stModuleTest_st.Fee_DataReadNumBytes_u32 += Fee_GlobInfoWrBlock_st.Bytes2Read_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   897              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   898  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   899              /* Call the Fls interface */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   900              if(Fls_Read(Fee_RdWrOrder_st.xRdAddress,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   901                          &DataPtr_pu8[Fee_GlobInfoWrBlock_st.BytesAlrdyConsid_u16],
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   902                          Fee_GlobInfoWrBlock_st.Bytes2Read_u16) != E_NOT_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   903              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   904                  /* Read order was accepted, set the next state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   905                  Fee_RdWrOrder_st.Fee_LLCopyBlk_en = FEE_LL_CPY_BLOCK_WAIT_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   906  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   907                  /* Increment the amount of already considered data bytes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   908                  Fee_GlobInfoWrBlock_st.BytesAlrdyConsid_u16 = (uint16)((Fee_GlobInfoWrBlock_st.BytesAlrdyConsid_u16 +
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   909                                                                          Fee_GlobInfoWrBlock_st.Bytes2Read_u16));
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   910  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   911                  /* Increment the read address for the next Fls access (overflow is checked automatically) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   912                  Fee_IncAddressInsideSector(&Fee_RdWrOrder_st.xRdAddress, Fee_GlobInfoWrBlock_st.Bytes2Read_u16, TRUE);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   913              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   914              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   915              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   916                  /* Fls did not accept the order due to wrong parameters or an internal busy state.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   917                   * Reset the state machine */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   918                  xRetVal_en = FEE_ABORTED_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   919              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   920          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   921          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   922  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   923          /* Wait for the read order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   924          case FEE_LL_CPY_BLOCK_WAIT_E:
	mov	d1,#2
	jeq	d1,d0,.L63
.L1559:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   925          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   926              /* The next state will be set by the Fee_JobEndNotification () or
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   927               * Fee_JobErrorNotification() function automatically */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   928  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   929              /* Check whether the OS is currently running or not */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   930              if (Fee_stMain == FEE_POLLING_MODE_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   931              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   932                  /* Call the Fls main function manually */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   933                  Fls_MainFunction();
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   934              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   935  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   936              #if (STD_ON == FEE_POLLING_MODE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   937              /* Use the FLS polling mechanism in order to reach the next state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   938              Fee_CheckFlsJobResult();
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   939              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   940          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   941          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   942  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   943          /* Wait for the read order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   944          case FEE_LL_CPY_BLOCK_ERROR_E:
	mov	d1,#3
	jeq	d1,d0,.L64
.L1560:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   945          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   946              /* Verify retry possibility */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   947              if(Fee_RdWrRetries_u8 > 0)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   948              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   949                  /* Decrement retry possibilities */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   950                  Fee_RdWrRetries_u8--;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   951  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   952                  /* Restart the state machine in order to start all over again */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   953                  Fee_RdWrOrder_st.Fee_LLCopyBlk_en = FEE_LL_CPY_BLK_INIT_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   954              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   955              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   956              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   957                  /* Return error, because maximum amount of retries is reached */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   958                  xRetVal_en = FEE_ERROR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   959              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   960          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   961          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   962  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   963          /* Finish the function or the data transfer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   964          case FEE_LL_CPY_BLOCK_FINISHED_E:
	mov	d1,#4
	jeq	d1,d0,.L65
	j	.L66
.L61:
	movh.a	a15,#@his(Fee_GlobInfoWrBlock_st)
	lea	a15,[a15]@los(Fee_GlobInfoWrBlock_st)
	st.a	[a10],a15
.L1561:
	mov	d15,#0
.L1562:
	st.h	[a15],d15
.L1563:
	ld.w	d15,[a4]
.L1564:
	add	d15,d15,#14
.L1565:
	st.w	[a13],d15
.L1566:
	ld.w	d4,[a13]
.L534:
	call	Fee_GetPhysSectorByAddress
.L533:
	mov	d3,d2
.L548:
	movh.a	a15,#@his(Fee_idxLLSectorOrder_au8)
	lea	a15,[a15]@los(Fee_idxLLSectorOrder_au8)
.L1567:
	addsc.a	a15,a15,d3,#0
	ld.bu	d2,[a15]
.L547:
	ld.w	d0,[a13]
.L1568:
	movh.a	a2,#@his(Fee_FlashProp_st)
	lea	a2,[a2]@los(Fee_FlashProp_st)
.L1569:
	sha	d15,d3,#4
.L1570:
	addsc.a	a15,a2,d15,#0
.L1571:
	ld.w	d15,[a15]12
	sub	d1,d15,d0
	add	d1,#1
.L1572:
	jlt.u	d10,d1,.L67
.L68:
.L69:
	sha	d15,d3,#4
.L1573:
	addsc.a	a15,a2,d15,#0
.L1574:
	ld.w	d15,[a15]12
.L1575:
	ld.w	d0,[a13]
.L1576:
	sub	d15,d0
	add	d15,#1
.L1577:
	add	d11,d15
.L543:
	extr.u	d11,d11,#0,#16
.L551:
	add	d2,#1
.L550:
	extr.u	d2,d2,#0,#8
.L552:
	mul	d15,d2,#12
.L1578:
	movh.a	a15,#@his(Fee_LLSectorOrder_st)
	lea	a15,[a15]@los(Fee_LLSectorOrder_st)
.L1579:
	addsc.a	a15,a15,d15,#0
.L1580:
	ld.bu	d3,[a15]8
.L1581:
	add	d12,#1
.L545:
	extr.u	d12,d12,#0,#8
.L553:
	sha	d15,d3,#4
.L1582:
	addsc.a	a15,a2,d15,#0
.L1583:
	ld.w	d0,[a15]8
.L1584:
	ld.w	d15,[a15]12
	sub	d15,d0
	add	d15,#1
.L1585:
	sub	d1,d10,d11
.L1586:
	jge.u	d1,d15,.L70
.L1587:
	add	d0,d10
.L1588:
	sub	d0,d11
.L1589:
	st.w	[a13],d0
.L1590:
	mov	d13,#1
.L1591:
	j	.L71
.L70:
	st.w	[a13],d0
.L71:
	jeq	d13,#0,.L69
.L1592:
	movh.a	a15,#@his(Fee_NumFlashBanksUsed_u8)
	lea	a15,[a15]@los(Fee_NumFlashBanksUsed_u8)
	ld.bu	d15,[a15]
.L1593:
	jge.u	d12,d15,.L68
.L1594:
	j	.L72
.L67:
	add	d10,d0
.L538:
	st.w	[a13],d10
.L72:
	sha	d3,#4
.L549:
	addsc.a	a15,a2,d3,#0
.L1595:
	ld.w	d15,[a15]12
.L1596:
	ld.w	d0,[a13]
.L1597:
	sub	d15,d0
.L554:
	add	d15,#1
.L1598:
	ld.a	a15,[a10]
	add.a	a15,#4
.L1599:
	jge.u	d15,d9,.L73
.L1600:
	st.h	[a15],d15
.L1601:
	j	.L74
.L73:
	st.h	[a15],d9
.L74:
	mov	d15,#1
.L555:
	st.w	[a14],d15
.L62:
	movh.a	a15,#@his(Fee_GlobInfoWrBlock_st)
	lea	a15,[a15]@los(Fee_GlobInfoWrBlock_st)
.L1602:
	ld.hu	d5,[a15]4
	ld.w	d4,[a13]
	ld.hu	d15,[a15]0
	addsc.a	a4,a12,d15,#0
	call	Fls_17_Pmu_Read
.L1603:
	jeq	d2,#1,.L75
.L1604:
	mov	d15,#2
.L1605:
	st.w	[a14],d15
.L1606:
	ld.hu	d4,[a15]4
.L1607:
	ld.hu	d15,[a15]0
.L1608:
	add	d15,d4
.L1609:
	st.h	[a15],d15
.L1610:
	mov	d5,#1
	mov.aa	a4,a13
	call	Fee_IncAddressInsideSector
.L1611:
	j	.L76
.L75:
	mov	d8,#6
.L76:
	j	.L77
.L63:
	movh.a	a15,#@his(Fee_stMain)
	lea	a15,[a15]@los(Fee_stMain)
	ld.w	d15,[a15]
.L1612:
	jne	d15,#0,.L78
.L1613:
	call	Fls_17_Pmu_MainFunction
.L78:
	call	Fee_CheckFlsJobResult
.L1614:
	j	.L79
.L64:
	movh.a	a15,#@his(Fee_RdWrRetries_u8)
	lea	a15,[a15]@los(Fee_RdWrRetries_u8)
	ld.bu	d15,[a15]
.L1615:
	jeq	d15,#0,.L80
.L1616:
	add	d15,#-1
	st.b	[a15],d15
.L1617:
	mov	d15,#0
.L1618:
	st.w	[a14],d15
.L1619:
	j	.L81
.L80:
	mov	d8,#3
.L81:
	j	.L82
.L65:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   965          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   966              #if (FEE_PRV_DEBUGGING != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   967              Fee_Prv_stModuleTest_st.Fee_DataReadEnd_u32 = Mcu_Rb_GetSysTimePart(TIM0);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   968  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   969              Fee_Prv_stModuleTest_st.Fee_DataReadDiff_u32 = MCU_RB_TIM0TICKS_TO_MS(
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   970                      Fee_Prv_stModuleTest_st.Fee_DataReadEnd_u32 -
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   971                      Fee_Prv_stModuleTest_st.Fee_DataReadStart_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   972              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   973  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   974              /* Check if the data transfer is complete */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   975              if(Fee_GlobInfoWrBlock_st.BytesAlrdyConsid_u16 == DataLength_u16)
	movh.a	a12,#@his(Fee_GlobInfoWrBlock_st)
.L536:
	lea	a12,[a12]@los(Fee_GlobInfoWrBlock_st)
.L1620:
	ld.hu	d15,[a12]0
.L1621:
	jne	d15,d9,.L83
.L1622:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   976              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   977                  /* All data was read  out */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   978                  xRetVal_en = FEE_ORDER_FINISHED_E;
	mov	d8,#1
.L1623:
	j	.L84
.L83:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   979              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   980              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   981              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   982                  /* There are still some data bytes left to be transfered
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   983                   * --> switch to the next logical sector and read out more data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   984  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   985                  /* Get the current physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   986                  xPhySectIdx_u8 = Fee_GetPhysSectorByAddress(Fee_RdWrOrder_st.xRdAddress);
	ld.w	d4,[a13]
.L557:
	call	Fee_GetPhysSectorByAddress
.L556:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   987  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   988                  /* Get the corresponding logical sector index and increment it */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   989                  xLogSectIdx_u8 = (uint8)(Fee_idxLLSectorOrder_au8[xPhySectIdx_u8] + 1u);
	movh.a	a15,#@his(Fee_idxLLSectorOrder_au8)
	lea	a15,[a15]@los(Fee_idxLLSectorOrder_au8)
.L1624:
	addsc.a	a15,a15,d2,#0
	ld.bu	d15,[a15]
.L1625:
	add	d15,#1
.L1626:
	extr.u	d15,d15,#0,#8
.L559:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   990  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   991                  /* Sector overflow not necessary because the checksum verification was done before.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   992                   * This would have failed in case s.th. was wrong with the sector order. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   993  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   994                  /* Get the new physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   995                  xPhySectIdx_u8 = Fee_LLSectorOrder_st[xLogSectIdx_u8].xPhySecIdx_u8;
	mul	d15,d15,#12
.L560:
	movh.a	a15,#@his(Fee_LLSectorOrder_st)
	lea	a15,[a15]@los(Fee_LLSectorOrder_st)
.L1627:
	addsc.a	a15,a15,d15,#0
.L1628:
	ld.bu	d15,[a15]8
.L558:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   996  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   997                  /* Set the start address for the read command (it will always be sector aligned
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   998                   * because read orders can be performed until the end of the sector) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	   999                  Fee_RdWrOrder_st.xRdAddress = Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogStartAddress_u32;
	movh.a	a15,#@his(Fee_FlashProp_st)
	lea	a15,[a15]@los(Fee_FlashProp_st)
.L1629:
	sha	d15,#4
.L561:
	addsc.a	a15,a15,d15,#0
.L1630:
	ld.w	d0,[a15]8
.L1631:
	st.w	[a13],d0
.L1632:
	mov.aa	a2,a12
	add.a	a2,#4
.L1633:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1000  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1001                  /* Check if the amount of bytes to read needs to be restricted (sector overflow) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1002                  if((uint16)(DataLength_u16 - Fee_GlobInfoWrBlock_st.BytesAlrdyConsid_u16) >=
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1003                     (uint32)((Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogEndAddress_u32 + 1u) -
	ld.w	d15,[a15]12
	sub	d15,d0
	add	d15,#1
.L1634:
	ld.hu	d0,[a12]0
.L1635:
	sub	d9,d0
.L540:
	extr.u	d0,d9,#0,#16
.L1636:
	jlt.u	d0,d15,.L85
.L1637:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1004                               Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogStartAddress_u32))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1005                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1006                      /* Read back one complete sector first */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1007                      Fee_GlobInfoWrBlock_st.Bytes2Read_u16 = (uint16)((Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogEndAddress_u32 + 1u) -
	st.h	[a2],d15
.L1638:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1008                                                                        Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogStartAddress_u32);
	j	.L86
.L85:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1009                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1010                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1011                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1012                      /* Read back the complete rest of the data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1013                      Fee_GlobInfoWrBlock_st.Bytes2Read_u16 = (uint16)(DataLength_u16 -
	st.h	[a2],d0
.L86:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1014                                                                       Fee_GlobInfoWrBlock_st.BytesAlrdyConsid_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1015                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1016  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1017                  /* Restart the data transfer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1018                  Fee_RdWrOrder_st.Fee_LLCopyBlk_en = FEE_LL_CPY_BLOCK_START_E;
	mov	d15,#1
.L1639:
	st.w	[a14],d15
.L84:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1019              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1020          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1021          break;
	j	.L87

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1022  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1023          default:
.L66:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1024              /* Return error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1025              xRetVal_en = FEE_ERROR_E;
	mov	d8,#3
.L1640:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1026          break;
	j	.L88

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1027      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1028  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1029  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1030      /* Check if the function is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1031      if(xRetVal_en != FEE_ORDER_PENDING_E)
.L88:
.L87:
.L82:
.L79:
.L77:
	jeq	d8,#0,.L89
.L1641:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1032      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1033          /* Reset the state machine */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1034          Fee_RdWrOrder_st.Fee_LLCopyBlk_en = FEE_LL_CPY_BLK_INIT_E;
	mov	d15,#0
.L1642:
	st.w	[a14],d15
.L1643:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1035          /* Retries for write/read and verify after failed compare */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1036          Fee_RdWrRetries_u8 = FEE_MAX_RD_WR_COMP_RETRIES;
	movh.a	a15,#@his(Fee_RdWrRetries_u8)
	lea	a15,[a15]@los(Fee_RdWrRetries_u8)
.L1644:
	mov	d15,#3
.L1645:
	st.b	[a15],d15
.L89:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1037      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1038  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1039      return (xRetVal_en);
	mov	d2,d8
.L562:
	j	.L90

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1040  }
.L90:
	ret
.L474:
	
__Fee_LLCopyData2Buffer_function_end:
	.size	Fee_LLCopyData2Buffer,__Fee_LLCopyData2Buffer_function_end-Fee_LLCopyData2Buffer
.L390:
	; End of function
	
	.sdecl	'.text.rba_FeeFs1_LlBlockHandling.Fee_LLCpyBlkFromFls2Fls',code,cluster('Fee_LLCpyBlkFromFls2Fls')
	.sect	'.text.rba_FeeFs1_LlBlockHandling.Fee_LLCpyBlkFromFls2Fls'
	.align	2
	
	.global	Fee_LLCpyBlkFromFls2Fls

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1041  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1042  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1043  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1044   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1045   * Fee_LLCpyBlkFromFls2Fls(): Copy a block during the sector reorg
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1046   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1047   * This function copies a block during the sector reorganization
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1048   * from one sector to another one.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1049   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1050   * \param    Fee_GlobInfoLastRdHeader_pcst:  Pointer to the latest valid
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1051   *                                  block header content of the block
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1052   *                                  to copy
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1053   *             Fee_WriteTwice_b: For redundant blocks, if both copies must be written or only copy.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1054   *                              TRUE -> Both copies to be written
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1055   *                              FALSE -> Only copy to be written (to avoid complex handling of invalidation for No fall back blocks)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1056   * \return   Function result
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1057   * \retval   FEE_ORDER_PENDING_E:   Order is still pending
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1058   * \retval   FEE_ABORTED_E:         A "sector overflow" occured, the
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1059   *                                  USED sector was erased
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1060   * \retval   FEE_ERROR_E:           A read, write or compare error occured or
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1061   *                                  the order was aborted due to a
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1062   *                                  wrong function call or a busy Fls
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1063   * \retval   FEE_ORDER_FINISHED_E:  The block was copied successfully
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1064   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1065   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1066   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1067   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1068  FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLCpyBlkFromFls2Fls(P2CONST(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Fee_GlobInfoLastRdHeader_pcst, boolean Fee_WriteTwice_b)
; Function Fee_LLCpyBlkFromFls2Fls
.L325:
Fee_LLCpyBlkFromFls2Fls:	.type	func
	sub.a	a10,#16
.L563:
	st.a	[a10]8,a4
.L565:
	mov	d9,d4
.L566:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1069  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1070      VAR(Fee_stRetVal_ten, AUTOMATIC) xRetVal_en = FEE_ORDER_PENDING_E;  /* Function return */
	mov	d8,#0
.L567:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1071      VAR(uint8, AUTOMATIC) xPhySectIdx_u8;                               /* Physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1072      VAR(uint8, AUTOMATIC) xLogSectIdx_u8;                                /* Logical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1073      VAR(uint32, AUTOMATIC) xNumBytes_u32;                               /* Calculated number of bytes (different usage) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1074      static uint32 xHeaderAddr_u32 = FEE_MAXUINT32;                      /* Block header address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1075      static boolean xSectOverflow_b = FALSE;                             /* Sector overflow indicator */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1076      VAR(Fee_stRetVal_ten, AUTOMATIC) xWrMarkerRetVal_en;                /* Return value for writing markers */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1077      VAR(uint16, AUTOMATIC) xCnt_u16;                                    /* Block and sector number counter */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1078      static uint8 xCntRetry_u8 = FEE_MAX_RD_WR_COMP_RETRIES;             /* Retries for write/read and verify after failed compare */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1079      VAR(uint16, AUTOMATIC) xConfigPropTableIdx_u16;                     /* Configuration properties table index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1080      VAR (Fee_stRetVal_ten, AUTOMATIC) xRetValErase_en;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1081      static uint32 cntProgrammedBytes_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1082      uint32 tmpAddr_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1083      uint8* tmpAdd_pu8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1084  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1085      /* Switch over state machine */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1086      switch (Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en)
	movh.a	a15,#@his(Fee_RdWrOrder_st)
	lea	a15,[a15]@los(Fee_RdWrOrder_st)
	st.a	[a10]4,a15
.L1091:
	lea	a2,[a15]48
	st.a	[a10]12,a2
	ld.w	d15,[a15]48
.L1092:
	mov	d0,#26
	jlt	d0,d15,.L91
	mov	d0,#0
	jlt	d15,d0,.L91
	sub	d0,d15,d0
	movh.a	a15,#@his(.1.jmp)
	lea	a15,[a15]@los(.1.jmp)
	addsc.a	a15,a15,d0,#2
	ld.a	a15,[a15]
	ji	a15
.L91:
	j	.L92
.L564:
	
	.sdecl	'.rodata.rba_FeeFs1_LlBlockHandling..1.jmp',data,rom
	.sect	'.rodata.rba_FeeFs1_LlBlockHandling..1.jmp'
	.align	4
.1.jmp:	.type	object
	.word	.L93
	.word	.L94
	.word	.L95
	.word	.L96
	.word	.L97
	.word	.L98
	.word	.L99
	.word	.L100
	.word	.L101
	.word	.L102
	.word	.L103
	.word	.L104
	.word	.L105
	.word	.L106
	.word	.L107
	.word	.L108
	.word	.L109
	.word	.L110
	.word	.L111
	.word	.L112
	.word	.L113
	.word	.L114
	.word	.L115
	.word	.L116
	.word	.L117
	.word	.L118
	.word	.L119
	
	.sect	'.text.rba_FeeFs1_LlBlockHandling.Fee_LLCpyBlkFromFls2Fls'

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1087      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1088          /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1089          case FEE_LL_CPY_FLS2FLS_INIT_E:
.L93:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1090          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1091              /* Reset amount of already copied bytes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1092              Fee_LLSecReorgStruct_st.xNumBytesAlrdyCopied_u16 = 0;
	movh.a	a12,#@his(Fee_LLSecReorgStruct_st)
	lea	a12,[a12]@los(Fee_LLSecReorgStruct_st)
.L1093:
	mov.aa	a2,a12
	add.a	a2,#4
.L1094:
	mov	d0,#0
.L1095:
	st.h	[a2],d0
.L1096:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1093  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1094              /* Copy the block header address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1095              Fee_LLSecReorgStruct_st.xRdAddress_u32 = Fee_GlobInfoLastRdHeader_pcst->AdrBlkHeader_u32;
	ld.a	a15,[a10]8
.L568:
	ld.w	d0,[a15]
.L1097:
	st.w	[a12],d0
.L1098:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1096  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1097              /* Reset the sector overflow indicator */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1098              xSectOverflow_b = FALSE;
	movh.a	a13,#@his(_999002_xSectOverflow_b)
	lea	a13,[a13]@los(_999002_xSectOverflow_b)
.L1099:
	mov	d0,#0
.L1100:
	st.b	[a13],d0
.L1101:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1099  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1100              cntProgrammedBytes_u32 = 0;
	movh.a	a2,#@his(_999004_cntProgrammedBytes_u32)
	lea	a2,[a2]@los(_999004_cntProgrammedBytes_u32)
.L1102:
	mov	d0,#0
.L1103:
	st.w	[a2],d0
.L1104:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1101  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1102              /* Set the next state (could be changed in case of a NoFallback block) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1103              Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en  = FEE_LL_CPY_FLS2FLS_READ_E;
	mov	d15,#1
.L1105:
	ld.a	a14,[a10]4
	st.w	[a14]48,d15
.L1106:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1104  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1105              /* Get the sector index of the write sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1106              xPhySectIdx_u8 = Fee_GetPhysSectorByAddress(Fee_RdWrOrder_st.xWrAddress);
	add.a	a14,#4
	ld.w	d4,[a14]
.L569:
	call	Fee_GetPhysSectorByAddress
.L572:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1107              xLogSectIdx_u8 = (uint8)(Fee_idxLLSectorOrder_au8[xPhySectIdx_u8]);
	movh.a	a2,#@his(Fee_idxLLSectorOrder_au8)
	lea	a2,[a2]@los(Fee_idxLLSectorOrder_au8)
.L1107:
	addsc.a	a15,a2,d2,#0
.L571:
	ld.bu	d9,[a15]
.L570:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1108  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1109  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)    /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1110              /* Initalise the address for 2nd header page and the flag to indicate that first data pages is not yet programmed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1111              Fee_RdWrOrder_st.xHdPg2Address = FEE_NULL;
	ld.a	a15,[a10]4
	lea	a15,[a15]28
.L1108:
	mov	d15,#0
.L1109:
	st.w	[a15],d15
.L1110:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1112              Fee_LLSecReorgStruct_st.xFirstDataPgPgm_u8 = FEE_FIRSTDATAPAGE_NOTPROGRAMMED;
	mov	d15,#0
.L1111:
	st.b	[a12]9,d15
.L1112:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1113  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1114  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1115              #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1116              /* Check if the block has a NoFallback configuration
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1117               * -> independent of the actual layout */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1118              if ((Fee_GlobInfoLastRdHeader_pcst->BlkStatus_u8 & (uint8)FEE_FLAG_NOFALLBACK_MSK) > 0)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1119              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1120                  /* 1. Step:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1121                   * Check if the NoFallback marker and the block header fits into the current logical sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1122  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1123                  /* Calculate number of bytes necessary to store the block header only */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1124                  xNumBytes_u32 = FEE_PAGES_USED_BY_BLK_HEADER * FEE_PAGE_LEN;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1125  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1126                  /* Check if the sector is already filled up */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1127                  if ((((Fee_RdWrOrder_st.xWrAddress + FEE_PAGE_LEN + xNumBytes_u32) - 1u) > Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogEndAddress_u32) &&
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1128                      (Fee_RdWrOrder_st.xWrAddress != Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogEndAddress_u32))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1129                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1130                      /* Fill the sector end with the NoFallback marker pattern */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1131                      if (Fls_Write(Fee_RdWrOrder_st.xWrAddress,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1132                                    Fee_NoFallbackMarkerPattern,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1133                                    (Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogEndAddress_u32 - Fee_RdWrOrder_st.xWrAddress) + 1u) != E_NOT_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1134                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1135                          /* Since there is not enough space to write the NoFallback marker and the block header
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1136                           * -> the write address is set to the end of the logical sector to switch to the next sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1137                          Fee_RdWrOrder_st.xWrAddress = Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogEndAddress_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1138  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1139                          /* Wait for the over programming to finish */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1140                          Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_WAIT_FILL_SECTOR_END_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1141                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1142                      else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1143                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1144                          /* Return an error due to wrong parameters or a busy/not init state of the Fls */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1145                          xRetVal_en = FEE_ABORTED_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1146                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1147  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1148                      /* Do not continue this state due to an error of Fls or to fill up the sector end */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1149                      break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1150                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1151  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1152                  /* 2. Step:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1153                   * In case the function is called for block maintenance during shutdown or a write order possibly
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1154                   * existing copies needs to be invalidated (only for double storage blocks).
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1155                   * This is only necessary in 2 cases:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1156                   *      1. The second copy of an old version is available
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1157                   *          -> This is the case if the write of a new version gets interrupted
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1158                   *      2. After copying the only existing version */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1159                  // the security level bit has the offset 0 --> No shift required
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1160                  if ((Fee_Rb_MaintainRun_b != FALSE) &&
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1161                      ((Fee_GlobInfoLastRdHeader_pcst->BlkStatus_u8 & (uint8)FEE_FLAG_SEC_LEVEL_MSK) == FEE_BLK_INT_DOUBLE_STORAGE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1162                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1163                      if ((Fee_Rb_InvalidateOldCopy_b != FALSE) || (Fee_LLSecReorgStruct_st.xCntCopies_u8 > 0))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1164                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1165                          Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en  = FEE_LL_CPY_FLS2FLS_WRITE_NOFB_MARKER_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1166                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1167                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1168              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1169              /* #if (FEE_NO_FALLBACK_ACTIVE != FALSE) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1170              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1171  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1172  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1173              if((Fee_CalculateNumOfFreeBytesInCurSector(FEE_LL_SECTOR_USED_FOR_WRITING) < (FEE_PAGES_USED_BY_BLK_HEADER * FEE_PAGE_LEN)) ||
	ld.w	d4,[a14]
	call	Fee_CalculateNumOfFreeBytesInCurSector
.L573:
	mov	d15,#16
.L1113:
	jlt.u	d2,d15,.L120
.L1114:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1174                 (Fee_LLSectorOrder_st[xLogSectIdx_u8].SecState_en != FEE_SECTOR_USED_E))
	movh.a	a15,#@his(Fee_LLSectorOrder_st)
	lea	a15,[a15]@los(Fee_LLSectorOrder_st)
.L1115:
	mul	d15,d9,#12
	addsc.a	a15,a15,d15,#0
.L1116:
	ld.w	d15,[a15]4
.L1117:
	jeq	d15,#2,.L121
.L120:
	movh.a	a2,#@his(Fee_LLSectorOrder_st)
	lea	a2,[a2]@los(Fee_LLSectorOrder_st)
.L1118:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1175              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1176                  /* Get the sector index of the sector that will be used for writing
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1177                   * the block header
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1178                   * --> this address will be used to update the cache
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1179                   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1180                   * Currently possible sector states are:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1181                   * - USED (with not enough space left)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1182                   * - ERASED/REQ2ERASE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1183                   * - UNDEF
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1184                   * - FULL */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1185  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1186                  /* Verify the sector state in case the FULL marker has not been written yet
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1187                   * (for e.g. due to resets or in case the sector overlap is caused by the
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1188                   *  sector reorganization itself) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1189                  if(Fee_LLSectorOrder_st[xLogSectIdx_u8].SecState_en != FEE_SECTOR_FULL_E)
	mul	d15,d9,#12
	addsc.a	a15,a2,d15,#0
.L1119:
	ld.w	d15,[a15]4
.L1120:
	jeq	d15,#3,.L122
.L1121:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1190                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1191                      /* Write the FULL marker next */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1192                      Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_WRITE_FULL_MARKER_E;
	mov	d15,#23
.L1122:
	ld.a	a15,[a10]12
	st.w	[a15],d15
.L1123:
	j	.L123
.L122:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1193                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1194                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1195                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1196                      /* Go on in the next sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1197                      xLogSectIdx_u8++;
	add	d9,#1
.L574:
	extr.u	d4,d9,#0,#8
.L575:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1198  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1199                      /* Check if switching from last to first sector requires an overflow */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1200                      if(xLogSectIdx_u8 >= FEE_NUM_FLASH_BANKS)
	movh.a	a15,#@his(Fee_NumFlashBanksUsed_u8)
	lea	a15,[a15]@los(Fee_NumFlashBanksUsed_u8)
	ld.bu	d15,[a15]
.L1124:
	jlt.u	d4,d15,.L124
.L1125:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1201                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1202                          /* Error case: all sectors are full (this assumption is guaranteed by the logical
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1203                           *             sector order mechanism)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1204                           * --> erase the most current sector in order to get the chance to keep data
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1205                           *     that is never written (which will be located in the oldest FULL sector). */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1206  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1207                          /* Reset the logical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1208                          xLogSectIdx_u8 = FEE_NUM_FLASH_BANKS - 1u;
	add	d15,#-1
	extr.u	d4,d15,#0,#8
.L1126:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1209  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1210                          /* Get the new physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1211                          xPhySectIdx_u8 = Fee_LLSectorOrder_st[xLogSectIdx_u8].xPhySecIdx_u8;
	mul	d15,d4,#12
	addsc.a	a15,a2,d15,#0
.L1127:
	ld.bu	d9,[a15]8
.L577:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1212  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1213                          /* Physical sector index and write address are still OK, mark the sector to be erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1214                          Fee_LLSetEraseSector(xLogSectIdx_u8);
	call	Fee_LLSetEraseSector
.L576:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1215  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1216                          /* Set the sector overflow indicator
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1217                           * (--> restart the reorganization after the USED marker has been written) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1218                          xSectOverflow_b = TRUE;
	mov	d15,#1
.L1128:
	st.b	[a13],d15
.L1129:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1219  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1220                          /* Set erase state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1221                          Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_ERASE_SECTOR_E;
	mov	d15,#24
.L1130:
	ld.a	a15,[a10]12
	st.w	[a15],d15
.L1131:
	j	.L125
.L124:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1222                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1223                      else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1224                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1225                          /* It is possible that this logical sector is not erased yet!
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1226                           * In this case, the sector has to be erased first
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1227                           * Hint: it is actually not possible that the next sector after an active FULL sector
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1228                           *       is in the FULL state (error case)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1229                           *       --> erase the most current FULL sector
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1230                           *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1231                           * Currently possible sector states are:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1232                           * - ERASED/REQ2ERASE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1233                           * - UNDEF */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1234  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1235                          /* Get the new physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1236                          xPhySectIdx_u8 = Fee_LLSectorOrder_st[xLogSectIdx_u8].xPhySecIdx_u8;
	mul	d15,d4,#12
	addsc.a	a15,a2,d15,#0
.L1132:
	ld.bu	d9,[a15]8
.L579:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1237  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1238                          /* Verify the sector state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1239                          if(Fee_LLSectorOrder_st[xLogSectIdx_u8].SecState_en == FEE_SECTOR_ERASED_E)
	ld.w	d15,[a15]4
.L1133:
	jne	d15,#1,.L126
.L1134:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1240                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1241                              /* The new logical sector is already erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1242  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1243                              /* Write the used marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1244                              Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_WRITE_USED_MARKER_E;
	mov	d15,#25
.L1135:
	ld.a	a15,[a10]12
	st.w	[a15],d15
.L1136:
	j	.L127
.L126:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1245                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1246                          else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1247                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1248                              /* The new logical sector has to be erased first
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1249                               * Possible sector states:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1250                               * - REQ2ERASE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1251                               * - UNDEF */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1252  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1253                              /* Mark the sector to be erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1254                              Fee_LLSetEraseSector(xLogSectIdx_u8);
	call	Fee_LLSetEraseSector
.L578:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1255  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1256                              /* Set erase state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1257                              Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_ERASE_SECTOR_E;
	mov	d15,#24
.L1137:
	ld.a	a15,[a10]12
	st.w	[a15],d15
.L127:
.L125:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1258                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1259                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1260  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1261                      /* Set the address for writing the next block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1262                      Fee_RdWrOrder_st.xWrAddress = Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogStartAddress_u32;
	movh.a	a15,#@his(Fee_FlashProp_st)
	lea	a15,[a15]@los(Fee_FlashProp_st)
.L1138:
	sha	d9,#4
.L580:
	addsc.a	a15,a15,d9,#0
.L1139:
	ld.w	d15,[a15]8
.L1140:
	st.w	[a14],d15
.L123:
.L121:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1263                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1264              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1265          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1266          break;
	j	.L128

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1267  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1268          #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1269          case FEE_LL_CPY_FLS2FLS_WRITE_NOFB_MARKER_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1270          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1271              if ((Fee_Rb_InvalidateOldCopy_b != FALSE) && (Fee_LLSecReorgStruct_st.xCntCopies_u8 == 0))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1272              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1273                  /* Invalidate the old copy first */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1274                  tmpAddr_u32 = Fee_GlobInfoLastRdHeader_st.AdrBlkHeader_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1275              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1276              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1277              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1278                  /* There is only one existing copy or the old copy is already invalidated */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1279                  tmpAddr_u32 = Fee_GlobInfoLastRdHeader_pcst->AdrBlkHeader_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1280              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1281  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1282              /* Decrement the address for the NoFallback marker in front of the block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1283              tmpAddr_u32 -= FEE_PAGE_LEN;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1284  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1285              /* Write the NoFallback marker to invalidate the old copy before writing any new copy */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1286              if (Fls_Write(tmpAddr_u32, Fee_NoFallbackMarkerPattern, FEE_PAGE_LEN) != E_NOT_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1287              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1288                  /* Wait for the over programming to finish */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1289                  Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_WAIT_WRITE_NOFB_MARKER_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1290              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1291              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1292              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1293                  /* Return an error due to wrong parameters or a busy/not init state of the Fls */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1294                  xRetVal_en = FEE_ABORTED_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1295              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1296          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1297          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1298          #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1299  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1300          /* Read out the complete block (header and data) and finish the function if possible */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1301          case FEE_LL_CPY_FLS2FLS_READ_E:
.L94:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1302          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1303              /* Check if reading of data is necessary */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1304              if(Fee_LLSecReorgStruct_st.xNumBytesAlrdyCopied_u16 < (Fee_GlobInfoLastRdHeader_pcst->BlkLength_u16 +
	ld.a	a15,[a10]8
.L581:
	ld.hu	d0,[a15]10
.L1141:
	add	d0,d0,#14
.L1142:
	movh.a	a13,#@his(Fee_LLSecReorgStruct_st)
	lea	a13,[a13]@los(Fee_LLSecReorgStruct_st)
.L1143:
	mov.aa	a14,a13
	add.a	a14,#4
	ld.hu	d1,[a13]4
.L1144:
	jge	d1,d0,.L129
.L1145:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1305                                                                     (uint16)FEE_BLK_HEADER_SIZE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1306              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1307                  /* There are still bytes left to be read out */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1308                  Fee_LLSecReorgStruct_st.xNumBytesLeftToRdWr_u16 = (uint16)((Fee_GlobInfoLastRdHeader_pcst->BlkLength_u16 +
	mov.aa	a12,a13
	add.a	a12,#6
.L1146:
	sub	d0,d1
.L1147:
	st.h	[a12],d0
.L1148:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1309                                                                              (uint16)FEE_BLK_HEADER_SIZE) -
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1310                                                                              Fee_LLSecReorgStruct_st.xNumBytesAlrdyCopied_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1311  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1312                  /* Ensure the correct alignment */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1313                  /* MR12 RULE 14.2 VIOLATION: The variable is updated and used within the same function itself. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1314                  while((Fee_LLSecReorgStruct_st.xNumBytesLeftToRdWr_u16 % FEE_PAGE_LEN) != 0u)
	j	.L130
.L131:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1315                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1316                      Fee_LLSecReorgStruct_st.xNumBytesLeftToRdWr_u16++;
	ld.hu	d15,[a13]6
.L1149:
	add	d15,#1
	st.h	[a12],d15
.L130:
	ld.hu	d0,[a13]6
	and	d15,d0,#7
.L1150:
	jne	d15,#0,.L131
.L1151:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1317                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1318  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1319                  /* Note: The following combinations for the read and write data are possible:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1320                   *       - The block is greater than the page buffer and must be written in several steps
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1321                   *       - The target sector has not enough space to store the complete block
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1322                   *          -> data cannot be written in one step
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1323                   *       - Original block is stored in the logical sector[0] and [1]
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1324                   *          -> source data cannot be read in one step */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1325  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1326                  /* Check if the block size is bigger than the page buffer size */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1327                  if(Fee_LLSecReorgStruct_st.xNumBytesLeftToRdWr_u16 > FEE_LL_PAGEBUFFSIZE)
	mov	d15,#1024
.L1152:
	jge.u	d15,d0,.L132
.L1153:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1328                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1329                      /* Restrict the bytes to read (it will take several steps to read out this block) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1330                      Fee_LLSecReorgStruct_st.xNumBytesLeftToRdWr_u16 = FEE_LL_PAGEBUFFSIZE;
	st.h	[a12],d15
.L132:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1331                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1332  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1333                  /* Check if there are enough free bytes in the target sector for this block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1334                  xNumBytes_u32 = Fee_CalculateNumOfFreeBytesInCurSector(FEE_LL_SECTOR_USED_FOR_WRITING);
	ld.a	a15,[a10]4
.L584:
	add.a	a15,#4
	ld.w	d4,[a15]
.L582:
	call	Fee_CalculateNumOfFreeBytesInCurSector
.L585:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1335  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1336                  #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1337                  /* In case of a NoFallback block and only before writing the block header
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1338                   * -> restrict the number of free bytes in the target sector due to the NoFallback marker
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1339                   * -> the write address gets incremented right before writing the block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1340                  if ((Fee_GlobInfoLastRdHeader_pcst->BlkStatus_u8 & (uint8)FEE_FLAG_NOFALLBACK_MSK) > 0)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1341                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1342                      /* Ensure that at least 1 Page is available in the target sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1343                      if ((Fee_LLSecReorgStruct_st.xNumBytesAlrdyCopied_u16 == 0) &&
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1344                          (xNumBytes_u32 != 0uL))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1345                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1346                          xNumBytes_u32 -= FEE_PAGE_LEN;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1347                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1348                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1349                  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1350  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1351                  if(Fee_LLSecReorgStruct_st.xNumBytesLeftToRdWr_u16 > xNumBytes_u32)
	ld.hu	d15,[a13]6
.L1154:
	jge.u	d2,d15,.L133
.L1155:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1352                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1353                      /* Restrict the number of bytes to read/write (it will take several steps) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1354                      Fee_LLSecReorgStruct_st.xNumBytesLeftToRdWr_u16 = (uint16)xNumBytes_u32;
	st.h	[a12],d2
.L133:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1355                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1356  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1357                  /* Check if the target sector is already full */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1358                  if(xNumBytes_u32 == 0uL)
	jne	d2,#0,.L134
.L1156:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1359                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1360                      /* Write the FULL_MARKER and the USED MARKER first */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1361                      Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_WRITE_FULL_MARKER_E;
	mov	d15,#23
.L1157:
	ld.a	a15,[a10]12
	st.w	[a15],d15
.L1158:
	j	.L135
.L134:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1362                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1363                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1364                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1365                      /* There is at least some space left in the target sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1366  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1367                      /* Check the number of bytes until the sector end in the read sector is reached */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1368                      xNumBytes_u32 = Fee_CalculateNumOfFreeBytesInCurSector(Fee_LLSecReorgStruct_st.xRdAddress_u32);
	ld.w	d4,[a13]
	call	Fee_CalculateNumOfFreeBytesInCurSector
.L1159:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1369  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1370                      if(Fee_LLSecReorgStruct_st.xNumBytesLeftToRdWr_u16 > xNumBytes_u32)
	ld.hu	d15,[a13]6
.L1160:
	jge.u	d2,d15,.L136
.L1161:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1371                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1372                          /* Restrict the amount of bytes to read
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1373                           * --> Amount of bytes == Amount of bytes to write */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1374                          Fee_LLSecReorgStruct_st.xNumBytesLeftToRdWr_u16 = (uint16)xNumBytes_u32;
	st.h	[a12],d2
.L136:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1375                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1376  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1377                      /* Read out the data (or part of it, or the header) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1378                      if(Fls_Read(Fee_LLSecReorgStruct_st.xRdAddress_u32,
	movh.a	a15,#@his(Fee_PageBytePtr_cpu8)
	lea	a15,[a15]@los(Fee_PageBytePtr_cpu8)
	ld.a	a4,[a15]
	ld.w	d4,[a13]
	ld.hu	d5,[a13]6
	call	Fls_17_Pmu_Read
.L586:
	jeq	d2,#1,.L137
.L1162:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1379                                  (uint8*)&Fee_PageBytePtr_cpu8[0],
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1380                                  Fee_LLSecReorgStruct_st.xNumBytesLeftToRdWr_u16) != E_NOT_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1381                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1382                          /* Set the next state to wait for the read order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1383                          Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_WAIT_READ_E;
	mov	d15,#2
.L1163:
	ld.a	a15,[a10]12
	st.w	[a15],d15
.L1164:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1384  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1385                          /* Increment amount of bytes that have already been considered */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1386                          Fee_LLSecReorgStruct_st.xNumBytesAlrdyCopied_u16 = (uint16)(Fee_LLSecReorgStruct_st.xNumBytesAlrdyCopied_u16 +
	ld.hu	d15,[a13]4
.L1165:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1387                                                                                      Fee_LLSecReorgStruct_st.xNumBytesLeftToRdWr_u16);
	ld.hu	d0,[a13]6
.L1166:
	add	d15,d0
.L1167:
	st.h	[a14],d15
.L1168:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1388  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1389                          /* Increment the read address for the next Fls_Read call */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1390                          Fee_IncAddressInsideSector(&Fee_LLSecReorgStruct_st.xRdAddress_u32,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1391                                                     Fee_LLSecReorgStruct_st.xNumBytesLeftToRdWr_u16,
	ld.hu	d4,[a13]6
.L1169:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1392                                                     TRUE);
	mov	d5,#1
	mov.aa	a4,a13
	call	Fee_IncAddressInsideSector
.L1170:
	j	.L138
.L137:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1393                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1394                      else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1395                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1396                          /* Fls did not accept the order due to wrong parameters or an internal busy state.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1397                           * Invalidate the cache entry */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1398                          Fee_LLUpdateAddressInCache(Fee_GlobInfoLastRdHeader_pcst->FeeIndex_u16,
	ld.a	a15,[a10]8
.L587:
	ld.hu	d4,[a15]12
.L1171:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1399                                                     FEE_CACHE_TMP_INVALID_VALUE);
	mov.u	d5,#51966
	addih	d5,d5,#45054
	call	Fee_LLUpdateAddressInCache
.L1172:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1400  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1401                          /* Reset the state machine (and the upper one) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1402                          xRetVal_en = FEE_ABORTED_E;
	mov	d8,#6
.L138:
.L135:
	j	.L139
.L129:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1403                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1404                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1405              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1406              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1407              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1408  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1409  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)    /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1410                  /* Check if 2nd header page is programmed. xHdPg2Address is set to FEE_MAXUINT32 after the header page 2 programming is initiated. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1411                  if(Fee_RdWrOrder_st.xHdPg2Address != FEE_MAXUINT32)
	ld.a	a15,[a10]4
.L588:
	lea	a15,[a15]28
	ld.w	d15,[a15]
.L1173:
	jeq	d15,#-1,.L140
.L1174:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1412                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1413                      /* 2nd header page is yet to be programmed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1414                      /* Switch to state to program the 2nd header page. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1415                      Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_HDRPG2_WRITE_E;
	mov	d15,#16
.L1175:
	ld.a	a15,[a10]12
	st.w	[a15],d15
.L1176:
	j	.L141
.L140:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1416                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1417                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1418  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1419                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1420                      /* Check if a second copy needs to be transfered (take the info out
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1421                       * of the PFlash, not the DFlash if possible) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1422  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1423                      /* Check if the index can be found */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1424                      if(Fee_SrvBinarySearchInBlockProp(Fee_GlobInfoLastRdHeader_pcst->FeeIndex_u16, &xConfigPropTableIdx_u16) != FALSE)
	ld.a	a15,[a10]8
.L590:
	ld.hu	d4,[a15]12
.L589:
	lea	a4,[a10]0
	call	Fee_SrvBinarySearchInBlockProp
.L1177:
	jeq	d2,#0,.L142
.L1178:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1425                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1426                          /* Take the info out of the config */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1427                          // the security level bit has the offset 0 --> No shift required
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1428                          if(((Fee_BlockProperties_st[xConfigPropTableIdx_u16].Flags_u16 &
	ld.hu	d15,[a10]0
	sha	d15,#4
.L1179:
	movh.a	a15,#@his(Fee_BlockProperties_st)
.L591:
	lea	a15,[a15]@los(Fee_BlockProperties_st)
.L1180:
	addsc.a	a15,a15,d15,#0
.L1181:
	ld.hu	d15,[a15]2
.L1182:
	jz.t	d15:0,.L143
.L1183:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1429                                                          FEE_FLAG_SEC_LEVEL_MSK) ==
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1430                                                              FEE_BLK_INT_DOUBLE_STORAGE) &&
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1431                               (Fee_LLSecReorgStruct_st.xCntCopies_u8 == 0) && (TRUE == Fee_WriteTwice_b))
	lea	a2,[a13]8
	ld.bu	d15,[a2]
.L1184:
	jne	d15,#0,.L144
.L1185:
	jne	d9,#1,.L145
.L1186:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1432                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1433                              /* Write the same data a second time (1st valid copy of the block will be copied twice) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1434                              Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_INIT_E;
	mov	d0,#0
.L1187:
	ld.a	a15,[a10]12
	st.w	[a15],d0
.L1188:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1435                              Fee_LLSecReorgStruct_st.xCntCopies_u8++;
	add	d15,#1
	st.b	[a2],d15
.L1189:
	j	.L146
.L145:
.L144:
.L143:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1436                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1437                          else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1438                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1439                              /* Function is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1440                              xRetVal_en = FEE_ORDER_FINISHED_E;
	mov	d8,#1
.L146:
	j	.L147
.L142:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1441                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1442                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1443                      else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1444                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1445                          /* In case the "afterburner" is running, the available info for unknown blocks is only
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1446                           * available inside the DFlash */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1447                          if(((Fee_GlobInfoLastRdHeader_pcst->BlkStatus_u8 & (uint8)FEE_FLAG_SEC_LEVEL_MSK) ==
	ld.bu	d15,[a15]14
.L1190:
	jz.t	d15:0,.L148
.L1191:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1448                                  FEE_BLK_INT_DOUBLE_STORAGE) &&
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1449                               (Fee_LLSecReorgStruct_st.xCntCopies_u8 == 0) && (TRUE == Fee_WriteTwice_b))
	lea	a2,[a13]8
	ld.bu	d15,[a2]
.L1192:
	jne	d15,#0,.L149
.L1193:
	jne	d9,#1,.L150
.L1194:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1450                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1451                              /* Write the same data a second time (1st valid copy of the block will be copied twice) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1452                              Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_INIT_E;
	mov	d0,#0
.L1195:
	ld.a	a15,[a10]12
.L592:
	st.w	[a15],d0
.L1196:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1453                              Fee_LLSecReorgStruct_st.xCntCopies_u8++;
	add	d15,#1
	st.b	[a2],d15
.L1197:
	j	.L151
.L150:
.L149:
.L148:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1454                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1455                          else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1456                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1457                              /* Function is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1458                              xRetVal_en = FEE_ORDER_FINISHED_E;
	mov	d8,#1
.L151:
.L147:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1459                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1460                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1461  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1462                      /* At least one copy was transfered correctly, update the cache with the current header address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1463                      Fee_LLUpdateAddressInCache(Fee_GlobInfoLastRdHeader_pcst->FeeIndex_u16,
	ld.a	a15,[a10]8
.L593:
	ld.hu	d4,[a15]12
.L1198:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1464                                                 xHeaderAddr_u32);
	movh.a	a15,#@his(_999001_xHeaderAddr_u32)
.L594:
	lea	a15,[a15]@los(_999001_xHeaderAddr_u32)
	ld.w	d5,[a15]
	call	Fee_LLUpdateAddressInCache
.L141:
.L139:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1465                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1466              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1467          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1468          break;
	j	.L152

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1469  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1470  #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1471          /* Wait for the invalidation or filling up the sector to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1472          case FEE_LL_CPY_FLS2FLS_WAIT_FILL_SECTOR_END_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1473          case FEE_LL_CPY_FLS2FLS_WAIT_WRITE_NOFB_MARKER_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1474  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1475          /* Wait for the read order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1476          case FEE_LL_CPY_FLS2FLS_WAIT_READ_E:
.L95:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1477  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)    /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1478          /* Wait for the write order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1479          case FEE_LL_CPY_FLS2FLS_WAIT_HDRPG1_WRITE_E:
.L98:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1480          case FEE_LL_CPY_FLS2FLS_WAIT_HDRPG2_WRITE_E:
.L110:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1481  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1482          case FEE_LL_CPY_FLS2FLS_WAIT_WRITE_E:
.L104:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1483          /* Wait for the verification to finish */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1484  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)    /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1485          case FEE_LL_CPY_FLS2FLS_WAIT_HDRPG1_VERIFY_E:
.L101:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1486          case FEE_LL_CPY_FLS2FLS_WAIT_HDRPG2_VERIFY_E:
.L113:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1487  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1488  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1489          case FEE_LL_CPY_FLS2FLS_WAIT_VERIFY_E:
.L107:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1490          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1491              /* The next state will be set by the Fee_JobEndNotification () or
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1492               * Fee_JobErrorNotification() function automatically */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1493  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1494              /* Check whether the OS is currently running or not */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1495              if (Fee_stMain == FEE_POLLING_MODE_E)
	movh.a	a15,#@his(Fee_stMain)
	lea	a15,[a15]@los(Fee_stMain)
	ld.w	d15,[a15]
.L1199:
	jne	d15,#0,.L153
.L1200:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1496              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1497                  /* Call the Fls main function manually */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1498                  Fls_MainFunction();
	call	Fls_17_Pmu_MainFunction
.L153:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1499              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1500  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1501              #if (STD_ON == FEE_POLLING_MODE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1502              /* Use the FLS polling mechanism in order to reach the next state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1503              Fee_CheckFlsJobResult();
	call	Fee_CheckFlsJobResult
.L1201:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1504              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1505          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1506          break;
	j	.L154

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1507  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1508  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)    /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1509          /* Write the header page 1 into the new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1510          case FEE_LL_CPY_FLS2FLS_HDRPG1_WRITE_E:
.L97:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1511          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1512              #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1513              /* Check if the block has a NoFallback configuration */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1514              if ((Fee_GlobInfoLastRdHeader_pcst->BlkStatus_u8 & (uint8)FEE_FLAG_NOFALLBACK_MSK) > 0)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1515              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1516                  /* Increment the write address with the size of the NoFallback marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1517                  Fee_IncAddressInsideSector(&Fee_RdWrOrder_st.xWrAddress, FEE_PAGE_LEN, TRUE);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1518              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1519              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1520  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1521              /* The data was read, write the header page 1 into the new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1522              if (Fls_Write(Fee_RdWrOrder_st.xWrAddress,
	movh.a	a15,#@his(Fee_PageBytePtr_cpu8)
	lea	a15,[a15]@los(Fee_PageBytePtr_cpu8)
	ld.a	a4,[a15]
.L595:
	ld.a	a12,[a10]4
	add.a	a12,#4
	ld.w	d4,[a12]
.L596:
	mov	d5,#8
	call	Fls_17_Pmu_Write
.L1202:
	jeq	d2,#1,.L155
.L1203:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1523                            (uint8*)&Fee_PageBytePtr_cpu8[0],
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1524                            FEE_PAGE_LEN) != E_NOT_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1525              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1526                  /* Save the header address for the cache update */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1527                  xHeaderAddr_u32 = Fee_RdWrOrder_st.xWrAddress;
	ld.w	d15,[a12]
.L1204:
	movh.a	a2,#@his(_999001_xHeaderAddr_u32)
	lea	a2,[a2]@los(_999001_xHeaderAddr_u32)
.L1205:
	st.w	[a2],d15
.L1206:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1528  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1529                  /* Store the address where the header page 2 must be programmed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1530                  Fee_RdWrOrder_st.xHdPg2Address = Fee_RdWrOrder_st.xWrAddress + FEE_PAGE_LEN;
	ld.a	a15,[a10]4
	lea	a2,[a15]28
.L1207:
	add	d15,d15,#8
.L1208:
	st.w	[a2],d15
.L1209:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1531  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1532                  /* Copy the header page 2 contents into a buffer. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1533                  Fee_SrvMemCopy8(Fee_hdr2Buffer_au8, (Fee_PageBytePtr_cpu8 + FEE_PAGE_LEN), FEE_PAGE_LEN);
	movh.a	a15,#@his(Fee_PageBytePtr_cpu8)
	lea	a15,[a15]@los(Fee_PageBytePtr_cpu8)
	ld.a	a15,[a15]
.L1210:
	movh.a	a4,#@his(Fee_hdr2Buffer_au8)
	lea	a4,[a4]@los(Fee_hdr2Buffer_au8)
.L1211:
	lea	a5,[a15]8
.L1212:
	mov	d4,#8
	call	Fee_SrvMemCopy8
.L1213:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1534  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1535                  /* Reduce the number of bytes to be programmed if there is data also to be programmed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1536                  Fee_LLSecReorgStruct_st.xNumBytesLeftToRdWr_u16 -= FEE_PAGE_LEN * FEE_PAGES_USED_BY_BLK_HEADER;
	movh.a	a15,#@his(Fee_LLSecReorgStruct_st)
	lea	a15,[a15]@los(Fee_LLSecReorgStruct_st)
.L1214:
	mov.aa	a2,a15
	add.a	a2,#6
	ld.hu	d15,[a15]6
.L1215:
	add	d15,d15,#-16
	st.h	[a2],d15
.L1216:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1537  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1538                  /* Even though only one header page is programmed, count that both header pages are programmed.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1539                   * The 2nd header page is left blank and will be programmed after all data pages are written. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1540                  cntProgrammedBytes_u32 += FEE_PAGE_LEN * FEE_PAGES_USED_BY_BLK_HEADER;
	movh.a	a15,#@his(_999004_cntProgrammedBytes_u32)
	lea	a15,[a15]@los(_999004_cntProgrammedBytes_u32)
	ld.w	d15,[a15]
.L1217:
	add	d15,d15,#16
	st.w	[a15],d15
.L1218:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1541  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1542                  /* Set the next state in order to wait until the write order is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1543                  Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_WAIT_HDRPG1_WRITE_E;
	mov	d15,#5
.L1219:
	ld.a	a15,[a10]4
	st.w	[a15]48,d15
.L1220:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1544  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1545                  /* Prepare the compare address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1546                  Fee_RdWrOrder_st.xCmpAddress = Fee_RdWrOrder_st.xWrAddress;
	ld.w	d15,[a12]
.L1221:
	st.w	[a15]8,d15
.L1222:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1547  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1548                  /* Next, data pages will be written. Increment the write address to point to data page. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1549                  Fee_IncAddressInsideSector(&Fee_RdWrOrder_st.xWrAddress,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1550                                             (FEE_PAGE_LEN * FEE_PAGES_USED_BY_BLK_HEADER),
	mov	d4,#16
.L1223:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1551                                             TRUE);
	mov	d5,#1
	mov.aa	a4,a12
	call	Fee_IncAddressInsideSector
.L1224:
	j	.L156
.L155:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1552              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1553              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1554              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1555                  /* Fls did not accept the order due to wrong parameters or an internal busy state.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1556                   * Invalidate the cache entry */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1557                  Fee_LLUpdateAddressInCache(Fee_GlobInfoLastRdHeader_pcst->FeeIndex_u16,
	ld.a	a15,[a10]8
.L597:
	ld.hu	d4,[a15]12
.L1225:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1558                                             FEE_CACHE_TMP_INVALID_VALUE);
	mov.u	d5,#51966
	addih	d5,d5,#45054
	call	Fee_LLUpdateAddressInCache
.L1226:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1559  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1560                  /* Reset the state machine (and the upper one) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1561                  xRetVal_en = FEE_ABORTED_E;
	mov	d8,#6
.L156:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1562              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1563          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1564          break;
	j	.L157

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1565  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1566  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1567          /* Write the data into the new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1568          case FEE_LL_CPY_FLS2FLS_WRITE_E:
.L103:
	movh.a	a15,#@his(Fee_PageBytePtr_cpu8)
	lea	a15,[a15]@los(Fee_PageBytePtr_cpu8)
	ld.a	a4,[a15]
.L598:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1569          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1570  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)    /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1571              /* The data was read from old sector, now write it into the new sector. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1572              /* Check if the buffer contains header information. This is indicated:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1573               * 1. If so far only header was programmed (indicated by cntProgrammedBytes_u32) and
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1574               * 2. This was a first read of the buffer (indicated by flag xFirstDataPgPgm_u8) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1575              if((cntProgrammedBytes_u32 == (FEE_PAGE_LEN * FEE_PAGES_USED_BY_BLK_HEADER)) &&
	movh.a	a12,#@his(_999004_cntProgrammedBytes_u32)
	lea	a12,[a12]@los(_999004_cntProgrammedBytes_u32)
	ld.w	d0,[a12]
.L1227:
	mov	d15,#16
.L1228:
	jne	d15,d0,.L158
.L1229:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1576                 (Fee_LLSecReorgStruct_st.xFirstDataPgPgm_u8 == FEE_FIRSTDATAPAGE_NOTPROGRAMMED))
	movh.a	a15,#@his(Fee_LLSecReorgStruct_st)
	lea	a15,[a15]@los(Fee_LLSecReorgStruct_st)
.L1230:
	ld.bu	d15,[a15]9
.L1231:
	jne	d15,#0,.L159
.L1232:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1577              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1578                  /* Ignore the first 2 pages of the page buffer as it contains header which is already programmed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1579                   tmpAdd_pu8 = (uint8*)&Fee_PageBytePtr_cpu8[0] + (FEE_PAGE_LEN * FEE_PAGES_USED_BY_BLK_HEADER);
	lea	a4,[a4]16
.L1233:
	j	.L160
.L159:
.L158:
	movh.a	a15,#@his(Fee_LLSecReorgStruct_st)
	lea	a15,[a15]@los(Fee_LLSecReorgStruct_st)
.L1234:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1580              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1581              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1582              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1583                   /* Buffer contains only data.*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1584                   tmpAdd_pu8 = (uint8*)&Fee_PageBytePtr_cpu8[0];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1585                   Fee_LLSecReorgStruct_st.xFirstDataPgPgm_u8 = FEE_FIRSTDATAPAGE_PROGRAMMED;
	mov	d15,#1
.L1235:
	st.b	[a15]9,d15
.L160:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1586              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1587  #else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1588              tmpAdd_pu8 = (uint8*)&Fee_PageBytePtr_cpu8[0];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1589  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1590              if (Fls_Write(Fee_RdWrOrder_st.xWrAddress,
	ld.hu	d5,[a15]6
	ld.a	a13,[a10]4
	add.a	a13,#4
	ld.w	d4,[a13]
.L599:
	call	Fls_17_Pmu_Write
.L600:
	jeq	d2,#1,.L161
.L1236:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1591                            tmpAdd_pu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1592                            Fee_LLSecReorgStruct_st.xNumBytesLeftToRdWr_u16) != E_NOT_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1593              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1594                   cntProgrammedBytes_u32 += Fee_LLSecReorgStruct_st.xNumBytesLeftToRdWr_u16;
	ld.hu	d4,[a15]6
.L1237:
	ld.w	d15,[a12]
.L1238:
	add	d15,d4
	st.w	[a12],d15
.L1239:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1595  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1596                   /* Set the next state in order to wait until the write order is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1597                   Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_WAIT_WRITE_E;
	mov	d15,#11
.L1240:
	ld.a	a15,[a10]4
	st.w	[a15]48,d15
.L1241:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1598  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1599                   /* Prepare the compare address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1600                   Fee_RdWrOrder_st.xCmpAddress = Fee_RdWrOrder_st.xWrAddress;
	ld.w	d15,[a13]
.L1242:
	st.w	[a15]8,d15
.L1243:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1601  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1602                   /* Increment the write address for the next call */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1603                   Fee_IncAddressInsideSector(&Fee_RdWrOrder_st.xWrAddress,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1604                                               Fee_LLSecReorgStruct_st.xNumBytesLeftToRdWr_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1605                                               TRUE);
	mov	d5,#1
	mov.aa	a4,a13
	call	Fee_IncAddressInsideSector
.L1244:
	j	.L162
.L161:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1606               }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1607               else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1608               {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1609                   /* Fls did not accept the order due to wrong parameters or an internal busy state.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1610                    * Invalidate the cache entry */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1611                   Fee_LLUpdateAddressInCache(Fee_GlobInfoLastRdHeader_pcst->FeeIndex_u16,
	ld.a	a15,[a10]8
.L601:
	ld.hu	d4,[a15]12
.L1245:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1612                                              FEE_CACHE_TMP_INVALID_VALUE);
	mov.u	d5,#51966
	addih	d5,d5,#45054
	call	Fee_LLUpdateAddressInCache
.L1246:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1613  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1614                   /* Reset the state machine (and the upper one) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1615                   xRetVal_en = FEE_ABORTED_E;
	mov	d8,#6
.L162:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1616                }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1617          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1618          break;
	j	.L163

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1619  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1620  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)    /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1621          /* Write the header page 2 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1622          case FEE_LL_CPY_FLS2FLS_HDRPG2_WRITE_E:
.L109:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1623          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1624              /* The data was read, write the header page 1 into the new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1625              if (Fls_Write(Fee_RdWrOrder_st.xHdPg2Address,
	ld.a	a15,[a10]4
	lea	a12,[a15]28
	ld.w	d4,[a12]
.L603:
	movh.a	a4,#@his(Fee_hdr2Buffer_au8)
.L602:
	lea	a4,[a4]@los(Fee_hdr2Buffer_au8)
	mov	d5,#8
	call	Fls_17_Pmu_Write
.L1247:
	jeq	d2,#1,.L164
.L1248:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1626                            (uint8*)&Fee_hdr2Buffer_au8[0],
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1627                            FEE_PAGE_LEN) != E_NOT_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1628              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1629                  /* Prepare the compare address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1630                  Fee_RdWrOrder_st.xCmpAddress = Fee_RdWrOrder_st.xHdPg2Address;
	ld.w	d15,[a12]
.L1249:
	st.w	[a15]8,d15
.L1250:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1631  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1632                  /* Clear the address to FEE_MAXUINT32 to indicate that the 2nd header page is programmed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1633                  Fee_RdWrOrder_st.xHdPg2Address = FEE_MAXUINT32;
	mov	d15,#-1
.L1251:
	st.w	[a12],d15
.L1252:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1634  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1635                  /* Set the next state in order to wait until the write order is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1636                  Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_WAIT_HDRPG2_WRITE_E;
	mov	d15,#17
.L1253:
	st.w	[a15]48,d15
.L1254:
	j	.L165
.L164:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1637              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1638              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1639              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1640                  /* Fls did not accept the order due to wrong parameters or an internal busy state.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1641                   * Invalidate the cache entry */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1642                  Fee_LLUpdateAddressInCache(Fee_GlobInfoLastRdHeader_pcst->FeeIndex_u16,
	ld.a	a15,[a10]8
.L604:
	ld.hu	d4,[a15]12
.L1255:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1643                                             FEE_CACHE_TMP_INVALID_VALUE);
	mov.u	d5,#51966
	addih	d5,d5,#45054
	call	Fee_LLUpdateAddressInCache
.L1256:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1644  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1645                  /* Reset the state machine (and the upper one) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1646                  xRetVal_en = FEE_ABORTED_E;
	mov	d8,#6
.L165:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1647              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1648          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1649          break;
	j	.L166

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1650  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1651  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1652  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)    /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1653          /* Compare the programmed header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1654          case FEE_LL_CPY_FLS2FLS_HDRPG1_VERIFY_E:
.L100:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1655          case FEE_LL_CPY_FLS2FLS_HDRPG2_VERIFY_E:
.L112:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1656          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1657              /* Check which header page was programmed.*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1658              if (Fee_RdWrOrder_st.xHdPg2Address != FEE_MAXUINT32)
	ld.a	a15,[a10]4
	lea	a12,[a15]28
	ld.w	d15,[a12]
.L1257:
	jeq	d15,#-1,.L167
.L1258:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1659              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1660                  /* Header page 1 was programmed, check against the first page of the header. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1661                  tmpAdd_pu8 = (uint8*)&Fee_PageBytePtr_cpu8[0];
	movh.a	a15,#@his(Fee_PageBytePtr_cpu8)
	lea	a15,[a15]@los(Fee_PageBytePtr_cpu8)
	ld.a	a4,[a15]
.L605:
	j	.L168
.L167:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1662              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1663              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1664              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1665                  /* Header page 2 was programmed, check against the second page of the header. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1666                  tmpAdd_pu8 = (uint8*)&Fee_hdr2Buffer_au8[0];
	movh.a	a4,#@his(Fee_hdr2Buffer_au8)
.L607:
	lea	a4,[a4]@los(Fee_hdr2Buffer_au8)
.L168:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1667              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1668  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1669              /* Set compare order */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1670              if (Fls_Compare(Fee_RdWrOrder_st.xCmpAddress,
	ld.a	a15,[a10]4
	ld.w	d4,[a15]8
.L606:
	mov	d5,#8
	call	Fls_17_Pmu_Compare
.L608:
	jeq	d2,#0,.L169
.L1259:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1671                              tmpAdd_pu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1672                              FEE_PAGE_LEN) != E_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1673              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1674                  /* An error occured due to wrong parameters or a busy/not init state of the Fls */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1675                  xRetVal_en = FEE_ABORTED_E;
	mov	d8,#6
.L1260:
	j	.L170
.L169:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1676              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1677              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1678              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1679                  /* Set the next state to wait for the verification order to finish */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1680                  if (Fee_RdWrOrder_st.xHdPg2Address != FEE_MAXUINT32)
	ld.w	d15,[a12]
.L1261:
	jeq	d15,#-1,.L171
.L1262:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1681                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1682                      Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_WAIT_HDRPG1_VERIFY_E;
	mov	d15,#8
.L1263:
	ld.a	a15,[a10]12
	st.w	[a15],d15
.L1264:
	j	.L172
.L171:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1683                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1684                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1685                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1686                      Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_WAIT_HDRPG2_VERIFY_E;
	mov	d15,#20
.L1265:
	ld.a	a15,[a10]12
	st.w	[a15],d15
.L172:
.L170:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1687                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1688              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1689          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1690          break;
	j	.L173

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1691  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1692  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1693          /* Compare the programmed data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1694          case FEE_LL_CPY_FLS2FLS_VERIFY_E:
.L106:
	movh.a	a15,#@his(Fee_PageBytePtr_cpu8)
	lea	a15,[a15]@los(Fee_PageBytePtr_cpu8)
	ld.a	a4,[a15]
.L609:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1695          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1696              /* Extract the buffer address from where the data must be programmed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1697  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)    /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1698              if(Fee_LLSecReorgStruct_st.xFirstDataPgPgm_u8 == FEE_FIRSTDATAPAGE_NOTPROGRAMMED)
	movh.a	a2,#@his(Fee_LLSecReorgStruct_st)
	lea	a2,[a2]@los(Fee_LLSecReorgStruct_st)
.L1266:
	ld.bu	d15,[a2]9
.L1267:
	jne	d15,#0,.L174
.L1268:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1699              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1700                  /* This is the first data byte programming.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1701                   * Ignore the first 2 pages of the page buffer as it contains header which is already programmed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1702                  tmpAdd_pu8 = Fee_PageBytePtr_cpu8 + (FEE_PAGE_LEN*FEE_PAGES_USED_BY_BLK_HEADER);
	lea	a4,[a4]16
.L1269:
	j	.L175
.L174:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1703              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1704              else
.L175:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1705  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1706              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1707                  tmpAdd_pu8 = (uint8*)&Fee_PageBytePtr_cpu8[0];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1708              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1709  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1710              /* Set compare order */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1711              if (Fls_Compare(Fee_RdWrOrder_st.xCmpAddress,
	ld.a	a15,[a10]4
	ld.w	d4,[a15]8
.L610:
	ld.hu	d5,[a2]6
	call	Fls_17_Pmu_Compare
.L611:
	jeq	d2,#0,.L176
.L1270:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1712                              tmpAdd_pu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1713                              Fee_LLSecReorgStruct_st.xNumBytesLeftToRdWr_u16) != E_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1714              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1715                  /* An error occured due to wrong parameters or a busy/not init state of the Fls */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1716                  xRetVal_en = FEE_ABORTED_E;
	mov	d8,#6
.L1271:
	j	.L177
.L176:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1717              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1718              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1719              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1720                  /* Set the next state to wait for the verification order to finish */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1721                  Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_WAIT_VERIFY_E;
	mov	d15,#14
.L1272:
	ld.a	a15,[a10]12
	st.w	[a15],d15
.L177:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1722              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1723          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1724          break;
	j	.L178

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1725  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1726          /* Write verification error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1727  #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1728          case FEE_LL_CPY_FLS2FLS_FILL_SECTOR_END_ERROR_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1729          case FEE_LL_CPY_FLS2FLS_WRITE_NOFB_MARKER_ERROR_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1730  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1731  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)    /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1732          case FEE_LL_CPY_FLS2FLS_HDRPG1_WRITE_ERROR_E:
.L99:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1733          case FEE_LL_CPY_FLS2FLS_HDRPG2_WRITE_ERROR_E:
.L111:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1734  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1735          case FEE_LL_CPY_FLS2FLS_WRITE_ERROR_E:
.L105:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1736          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1737  #if(FEE_ROBUST_PROG_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1738              /* check if the robust handling for IFX flashes is necessary */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1739              if (Fls_Rb_GetRobustProgStatus(&Fee_IfxRobustProgramming_s.xStartAddress,  &Fee_IfxRobustProgramming_s.DataBuffer, &Fee_IfxRobustProgramming_s.numBytes) == E_NOT_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1740              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1741                  /* Fls_Write was finished without success */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1742                  Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_ROBUST_IFX_HANDLING_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1743                  break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1744              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1745              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1746              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1747                  /* its not a IFX robustness error. Retry the operation. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1748              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1749  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1750          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1751          /* No break required as retry must be triggered. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1752  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1753          /* MR12 RULE 16.3 VIOLATION: Check for retry */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1754  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)    /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1755          case FEE_LL_CPY_FLS2FLS_HDRPG1_VERIFY_ERROR_E:
.L102:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1756          case FEE_LL_CPY_FLS2FLS_HDRPG2_VERIFY_ERROR_E:
.L114:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1757  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1758          case FEE_LL_CPY_FLS2FLS_READ_ERROR_E:
.L96:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1759          case FEE_LL_CPY_FLS2FLS_VERIFY_ERROR_E:
.L108:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1760          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1761              /* Verify retry possibility */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1762              if(xCntRetry_u8 > 0)
	movh.a	a15,#@his(_999003_xCntRetry_u8)
	lea	a15,[a15]@los(_999003_xCntRetry_u8)
	ld.bu	d15,[a15]
.L1273:
	jeq	d15,#0,.L179
.L1274:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1763              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1764                  /* Decrement retry possibilities */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1765                  xCntRetry_u8--;
	add	d15,#-1
	st.b	[a15],d15
.L1275:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1766  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1767                  /* Restart the state machine in order to start all over again with
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1768                   * copying the current block to the new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1769                  Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_INIT_E;
	mov	d15,#0
.L1276:
	ld.a	a15,[a10]12
	st.w	[a15],d15
.L1277:
	j	.L180
.L179:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1770              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1771              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1772              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1773                  /* Invalidate the cache entry */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1774                  Fee_LLUpdateAddressInCache(Fee_GlobInfoLastRdHeader_pcst->FeeIndex_u16,
	ld.a	a15,[a10]8
.L612:
	ld.hu	d4,[a15]12
.L613:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1775                                             FEE_CACHE_TMP_INVALID_VALUE);
	mov.u	d5,#51966
	addih	d5,d5,#45054
	call	Fee_LLUpdateAddressInCache
.L1278:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1776  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1777                  /* Return error, because maximum amount of retries is reached */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1778                  xRetVal_en = FEE_ERROR_E;
	mov	d8,#3
.L180:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1779              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1780          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1781          break;
	j	.L181

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1782  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1783          /* Data transfer is finished, check a possible address overflow */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1784          case FEE_LL_CPY_FLS2FLS_CHECK_ADR_OVERFLOW_E:
.L115:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1785          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1786              /* Data was now read and written successfully. A possible address overflow for the read and
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1787               * write addresses must be handled and the possibility that the write sector is now full */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1788  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1789              /* Get the physical sector index for the next READ order */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1790              xPhySectIdx_u8 = Fee_GetPhysSectorByAddress(Fee_LLSecReorgStruct_st.xRdAddress_u32);
	movh.a	a12,#@his(Fee_LLSecReorgStruct_st)
	lea	a12,[a12]@los(Fee_LLSecReorgStruct_st)
.L1279:
	ld.w	d4,[a12]
.L615:
	call	Fee_GetPhysSectorByAddress
.L614:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1791  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1792              /* Check if the end of the read sector was reached */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1793              if(Fee_LLSecReorgStruct_st.xRdAddress_u32 >= Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogEndAddress_u32)
	movh.a	a13,#@his(Fee_FlashProp_st)
	lea	a13,[a13]@los(Fee_FlashProp_st)
.L1280:
	ld.w	d0,[a12]
.L1281:
	sha	d15,d2,#4
.L1282:
	addsc.a	a15,a13,d15,#0
.L1283:
	ld.w	d15,[a15]12
.L1284:
	jlt.u	d0,d15,.L182
.L1285:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1794              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1795                  /* Switch to next sector and read out the rest of the data, if necessary */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1796  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1797                  /* Get logical sector index and increment it */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1798                  xLogSectIdx_u8 = (uint8)(Fee_idxLLSectorOrder_au8[xPhySectIdx_u8] + 1u);
	movh.a	a15,#@his(Fee_idxLLSectorOrder_au8)
	lea	a15,[a15]@los(Fee_idxLLSectorOrder_au8)
.L1286:
	addsc.a	a15,a15,d2,#0
	ld.bu	d15,[a15]
.L1287:
	add	d15,#1
.L1288:
	extr.u	d15,d15,#0,#8
.L617:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1799  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1800                  /* Overflow handling not necessary */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1801  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1802                  /* Get the new physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1803                  xPhySectIdx_u8 = Fee_LLSectorOrder_st[xLogSectIdx_u8].xPhySecIdx_u8;
	movh.a	a15,#@his(Fee_LLSectorOrder_st)
	lea	a15,[a15]@los(Fee_LLSectorOrder_st)
.L1289:
	mul	d15,d15,#12
.L618:
	addsc.a	a15,a15,d15,#0
.L1290:
	ld.bu	d15,[a15]8
.L616:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1804  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1805                  /* Get the new sector start address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1806                  Fee_LLSecReorgStruct_st.xRdAddress_u32 = Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogStartAddress_u32;
	sha	d15,#4
.L619:
	addsc.a	a15,a13,d15,#0
.L1291:
	ld.w	d15,[a15]8
.L1292:
	st.w	[a12],d15
.L182:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1807              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1808  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1809              /* Get the physical sector index for the next WRITE order */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1810              xPhySectIdx_u8 = Fee_GetPhysSectorByAddress(Fee_RdWrOrder_st.xWrAddress);
	ld.a	a15,[a10]4
	add.a	a15,#4
	ld.w	d4,[a15]
	call	Fee_GetPhysSectorByAddress
.L620:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1811  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1812              /* Check if the end of the write sector was reached */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1813              if(Fee_RdWrOrder_st.xWrAddress >= Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogEndAddress_u32)
	ld.w	d0,[a15]
.L1293:
	sha	d2,#4
.L621:
	addsc.a	a15,a13,d2,#0
.L1294:
	ld.w	d15,[a15]12
.L1295:
	jlt.u	d0,d15,.L183
.L1296:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1814              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1815                  /* The sector is full, write the FULL marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1816                  Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_WRITE_FULL_MARKER_E;
	mov	d15,#23
.L1297:
	ld.a	a15,[a10]12
	st.w	[a15],d15
.L1298:
	j	.L184
.L183:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1817              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1818              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1819              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1820                  /* Go on with reading the rest of the data, function will be finished automatically,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1821                   * if there is no data left */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1822                  Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_READ_E;
	mov	d15,#1
.L1299:
	ld.a	a15,[a10]12
	st.w	[a15],d15
.L184:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1823              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1824          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1825          break;
	j	.L185

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1826  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1827          /* Write the FULL marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1828          case FEE_LL_CPY_FLS2FLS_WRITE_FULL_MARKER_E:
.L116:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1829          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1830              /* Get the physical sector index of the FULL sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1831              xPhySectIdx_u8 = Fee_GetPhysSectorByAddress(Fee_RdWrOrder_st.xWrAddress);
	ld.a	a12,[a10]4
	add.a	a12,#4
	ld.w	d4,[a12]
.L623:
	call	Fee_GetPhysSectorByAddress
.L622:
	mov	d15,d2
.L625:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1832  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1833              /* Write the FULL marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1834              if(Fee_LLWriteMarker(xPhySectIdx_u8, FEE_FULL_MARKER_ID_E) != FEE_ORDER_PENDING_E)
	mov	d5,#3
	mov	d4,d15
.L624:
	call	Fee_LLWriteMarker
.L627:
	jeq	d2,#0,.L186
.L1300:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1835              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1836                  /*
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1837                   * Writing of "FULL" marker was finished
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1838                   * -----------------------------------
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1839                   * --> Set Fee_RdWrOrder_st.xWrAddress to the first empty page in next logical sector
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1840                   * --> Write the USED marker in the next logical sector
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1841                   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1842  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1843                  /* Get the current logical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1844                  xLogSectIdx_u8 = Fee_idxLLSectorOrder_au8[xPhySectIdx_u8];
	movh.a	a2,#@his(Fee_idxLLSectorOrder_au8)
	lea	a2,[a2]@los(Fee_idxLLSectorOrder_au8)
.L1301:
	addsc.a	a2,a2,d15,#0
	ld.bu	d15,[a2]
.L626:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1845  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1846                  /* Increment the logical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1847                  xLogSectIdx_u8 += 1u;
	add	d15,#1
.L628:
	extr.u	d4,d15,#0,#8
.L629:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1848  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1849                  /* Check if switching from last to first sector requires an overflow */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1850                  if (xLogSectIdx_u8 >= FEE_NUM_FLASH_BANKS)
	movh.a	a2,#@his(Fee_NumFlashBanksUsed_u8)
	lea	a2,[a2]@los(Fee_NumFlashBanksUsed_u8)
	ld.bu	d15,[a2]
.L1302:
	jlt.u	d4,d15,.L187
.L1303:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1851                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1852                      /* Reset the logical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1853                      xLogSectIdx_u8 = FEE_NUM_FLASH_BANKS-1u;
	add	d15,#-1
	extr.u	d4,d15,#0,#8
.L187:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1854                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1855  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1856                  /* Get the new physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1857                  xPhySectIdx_u8 = Fee_LLSectorOrder_st[xLogSectIdx_u8].xPhySecIdx_u8;
	movh.a	a15,#@his(Fee_LLSectorOrder_st)
	lea	a15,[a15]@los(Fee_LLSectorOrder_st)
.L1304:
	mul	d15,d4,#12
	addsc.a	a15,a15,d15,#0
.L1305:
	ld.bu	d9,[a15]8
.L583:
	movh.a	a13,#@his(Fee_FlashProp_st)
	lea	a13,[a13]@los(Fee_FlashProp_st)
.L1306:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1858  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1859                  /* Erase the new logical sector if necessary  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1860                  if((Fee_LLSectorOrder_st[xLogSectIdx_u8].SecState_en == FEE_SECTOR_STATE_UNDEF_E) ||
	ld.w	d15,[a15]4
.L1307:
	jeq	d15,#0,.L188
.L1308:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1861                     (Fee_LLSectorOrder_st[xLogSectIdx_u8].SecState_en == FEE_SECTOR_REQUEST2ERASE_E))
	jne	d15,#4,.L189
.L188:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1862                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1863                      /* Mark this sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1864                      Fee_LLSetEraseSector(xLogSectIdx_u8);
	call	Fee_LLSetEraseSector
.L630:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1865  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1866                      /* Save new write address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1867                      Fee_RdWrOrder_st.xWrAddress = Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogStartAddress_u32;
	sha	d9,#4
.L1309:
	addsc.a	a15,a13,d9,#0
.L1310:
	ld.w	d15,[a15]8
.L1311:
	st.w	[a12],d15
.L1312:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1868  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1869                      /* Set erase state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1870                      Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_ERASE_SECTOR_E;
	mov	d15,#24
.L1313:
	ld.a	a15,[a10]12
	st.w	[a15],d15
.L1314:
	j	.L190
.L189:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1871                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1872                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1873                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1874                      /* New logical sector might already be erased which is OK,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1875                       * but check for a "sector overflow" */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1876                      if(Fee_LLSectorOrder_st[xLogSectIdx_u8].SecState_en == FEE_SECTOR_ERASED_E)
	jne	d15,#1,.L191
.L1315:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1877                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1878                          /* Set the new write address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1879                          Fee_RdWrOrder_st.xWrAddress = Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogStartAddress_u32;
	sha	d9,#4
.L1316:
	addsc.a	a15,a13,d9,#0
.L1317:
	ld.w	d15,[a15]8
.L1318:
	st.w	[a12],d15
.L1319:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1880  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1881                          /* Write the USED marker next */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1882                          Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_WRITE_USED_MARKER_E;
	mov	d15,#25
.L1320:
	ld.a	a15,[a10]12
	st.w	[a15],d15
.L1321:
	j	.L192
.L191:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1883                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1884                      else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1885                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1886                          /* Prevent the driver from overwriting already used flash areas by erasing
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1887                           * this sector in case of sector states "FULL" or "USED" (information might get lost)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1888                           * --> erase the formerly "USED" sector, not the oldest "FULL" sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1889  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1890                          /* Get the old physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1891                          xPhySectIdx_u8 = Fee_LLSectorOrder_st[xLogSectIdx_u8].xPhySecIdx_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1892  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1893                          /* Mark the latest sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1894                          Fee_LLSetEraseSector(xLogSectIdx_u8);
	call	Fee_LLSetEraseSector
.L631:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1895  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1896                          /* Save new write address  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1897                          Fee_RdWrOrder_st.xWrAddress = Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogStartAddress_u32;
	sha	d9,#4
.L1322:
	addsc.a	a15,a13,d9,#0
.L1323:
	ld.w	d15,[a15]8
.L1324:
	st.w	[a12],d15
.L1325:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1898  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1899                          /* Set the sector overflow indicator */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1900                          xSectOverflow_b = TRUE;
	movh.a	a15,#@his(_999002_xSectOverflow_b)
	lea	a15,[a15]@los(_999002_xSectOverflow_b)
.L1326:
	mov	d15,#1
.L1327:
	st.b	[a15],d15
.L1328:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1901  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1902                          /* Set erase state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1903                          Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_ERASE_SECTOR_E;
	mov	d15,#24
.L1329:
	ld.a	a15,[a10]12
	st.w	[a15],d15
.L192:
.L190:
.L186:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1904                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1905                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1906              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1907          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1908          break;
	j	.L193

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1909  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1910          /* Erase the sector that will be used as a new USED sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1911          case FEE_LL_CPY_FLS2FLS_ERASE_SECTOR_E:
.L117:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1912          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1913              /* Check the erase sector result */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1914              /* MR12 RULE 10.3 VIOLATION: Not critical warning. (Changing the data type is not hex neutral for JDP) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1915              xRetValErase_en = Fee_LLEraseSector();
	call	Fee_LLEraseSector
.L632:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1916  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1917              /* MR12 RULE 10.4 VIOLATION: Not critical warning. (Changing the data type is not hex neutral for JDP)  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1918              if(xRetValErase_en != FEE_ORDER_PENDING_E)
	jeq	d2,#0,.L194
.L1330:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1919              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1920                  /* If erase order was successfull, then set state to write used marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1921                  /* in error case erase is restarted again.                             */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1922                  /* MR12 RULE 10.4 VIOLATION: Not critical warning. (Changing the data type is not hex neutral for JDP)  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1923                  if (xRetValErase_en == FEE_ORDER_FINISHED_E)
	jne	d2,#1,.L195
.L1331:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1924                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1925                      /* Sector erase is done. New write address was already set before */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1926  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1927                      /* Error reaction for unsuccessfull ERASED marker write order not necessary
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1928                       * --> RAM structure will be set and used for writing the USED marker
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1929                       *     procedure as long as the Fee_Init is not passed again.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1930                       * --> If init is passed, the sector detection will recognize this sector as
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1931                       *     undefined and execute an erase automatically. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1932  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1933                      /* Check if a sector overflow has happened */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1934                      if(xSectOverflow_b != FALSE)
	movh.a	a15,#@his(_999002_xSectOverflow_b)
	lea	a15,[a15]@los(_999002_xSectOverflow_b)
	ld.bu	d15,[a15]
.L1332:
	jeq	d15,#0,.L196
.L1333:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1935                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1936                          /* Invalidate the complete cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1937                          for(xCnt_u16=0; xCnt_u16<FEE_NUM_BLOCKS; xCnt_u16++)
	mov	d9,#0
.L633:
	j	.L197
.L198:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1938                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1939                              /* Invalidate the corresponding cache address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1940                              Fee_LLInvalidateAddressInCache(Fee_BlockProperties_st[xCnt_u16].BlockPersistentId_u16);
	sha	d15,d9,#4
	movh.a	a15,#@his(Fee_BlockProperties_st)
	lea	a15,[a15]@los(Fee_BlockProperties_st)
	addsc.a	a15,a15,d15,#0
	ld.hu	d4,[a15]0
	mov.u	d5,#45054
	addih	d5,d5,#51966
	call	Fee_LLUpdateAddressInCache
.L1334:
	add	d9,#1
.L197:
	jlt.u	d9,#12,.L198
.L1335:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1941                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1942  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1943                          /* Invalidate the complete cache status */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1944                          for(xCnt_u16=0; xCnt_u16<FEE_NUM_FLASH_BANKS; xCnt_u16++)
	mov	d15,#0
.L634:
	j	.L199
.L200:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1945                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1946                              /* Invalidate the corresponding physical sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1947                              Fee_LLEraseCacheStForSect((uint8)xCnt_u16);
	extr.u	d4,d15,#0,#8
	call	Fee_LLEraseCacheStForSect
.L1336:
	add	d15,#1
.L635:
	extr.u	d15,d15,#0,#16
.L199:
	movh.a	a15,#@his(Fee_NumFlashBanksUsed_u8)
	lea	a15,[a15]@los(Fee_NumFlashBanksUsed_u8)
	ld.bu	d0,[a15]
.L1337:
	jlt.u	d15,d0,.L200
.L196:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1948                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1949  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1950                          /* If robust sector flow feature is activated, then skip writing of the used marker as this will be used later. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1951                          #if defined (FEE_PRV_ROBUST_SECT_OVERFLOW)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1952                          Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_ROBUST_SECT_OVERFLOW_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1953                          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1954                          #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1955                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1956  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1957                      /* Write the USED marker next */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1958                      Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_WRITE_USED_MARKER_E;
	mov	d15,#25
.L1338:
	ld.a	a15,[a10]12
	st.w	[a15],d15
.L195:
.L194:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1959                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1960              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1961  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1962          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1963          break;
	j	.L201

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1964  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1965          /* Write the USED marker to the new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1966          case FEE_LL_CPY_FLS2FLS_WRITE_USED_MARKER_E:
.L118:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1967          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1968              /* Get the new physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1969              xPhySectIdx_u8 = Fee_GetPhysSectorByAddress(Fee_RdWrOrder_st.xWrAddress);
	ld.a	a15,[a10]4
	add.a	a15,#4
	ld.w	d4,[a15]
.L637:
	call	Fee_GetPhysSectorByAddress
.L636:
	mov	d9,d2
.L638:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1970  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1971              /* Mark the cache status for this sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1972              Fee_LLUpdateCacheStForSect(xPhySectIdx_u8);
	mov	d4,d9
.L639:
	call	Fee_LLUpdateCacheStForSect
.L641:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1973  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1974              /* Write the USED marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1975              xWrMarkerRetVal_en = Fee_LLWriteMarker(xPhySectIdx_u8, FEE_USED_MARKER_ID_E);
	mov	d5,#2
	mov	d4,d9
.L642:
	call	Fee_LLWriteMarker
.L643:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1976  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1977              /* Check the write USED marker result */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1978              if(xWrMarkerRetVal_en != FEE_ORDER_PENDING_E)
	jeq	d2,#0,.L202
.L1339:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1979              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1980                  /* Setting the write address to the first empty page in the next logical sector
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1981                   * was already set in the the previous state (FEE_LL_CPY_FLS2FLS_WRITE_FULL_MARKER_E) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1982  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1983                  /* Verify whether it was possible to write the USED marker or not */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1984                  if(xWrMarkerRetVal_en == FEE_ORDER_FINISHED_E)
	jne	d2,#1,.L203
.L1340:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1985                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1986                      /* Check for a sector overflow . But if Robust sector overflow is enabled, the control will not come here after erase
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1987                       * but go directly to the robust sector flow state. Hence, below check is required only when robust feature is not active. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1988                      #if ! (defined (FEE_PRV_ROBUST_SECT_OVERFLOW))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1989                      if(xSectOverflow_b != FALSE)
	movh.a	a15,#@his(_999002_xSectOverflow_b)
	lea	a15,[a15]@los(_999002_xSectOverflow_b)
	ld.bu	d15,[a15]
.L1341:
	jeq	d15,#0,.L204
.L1342:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1990                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1991                          /* Due to a "sector overflow" the USED sector was erased instead of
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1992                           * the oldest FULL sector, return an abortion of the copy process */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1993                          xRetVal_en = FEE_ABORTED_E;
	mov	d8,#6
.L1343:
	j	.L205
.L204:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1994                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1995                      else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1996                      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1997                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1998                          /* Write Marker with the start-Address as Payload. This marker is more or less the double storage
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  1999                           * of the USED Marker and contains the Address of the first  blockheader */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2000                          tmpAddr_u32 = Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogStartAddress_u32;
	movh.a	a15,#@his(Fee_FlashProp_st)
	lea	a15,[a15]@los(Fee_FlashProp_st)
.L1344:
	sha	d9,#4
.L640:
	addsc.a	a15,a15,d9,#0
.L1345:
	ld.w	d0,[a15]8
.L645:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2001  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2002                          if (cntProgrammedBytes_u32 > 0uL)
	movh.a	a2,#@his(_999004_cntProgrammedBytes_u32)
	lea	a2,[a2]@los(_999004_cntProgrammedBytes_u32)
	ld.w	d15,[a2]
.L1346:
	jeq	d15,#0,.L206
.L1347:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2003                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2004                              /* Calculate how many bytes have to be written in the "new" sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2005                              tmpAddr_u32 += (Fee_GlobInfoLastRdHeader_pcst->BlkLength_u16 + (uint16)FEE_BLK_HEADER_SIZE) - cntProgrammedBytes_u32;
	ld.a	a2,[a10]8
.L646:
	ld.hu	d1,[a2]10
.L1348:
	add	d1,d1,#14
.L1349:
	sub	d1,d15
.L1350:
	add	d0,d1
.L1351:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2006  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2007                              /* Ensure correct page alignment */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2008                              while ((tmpAddr_u32 % FEE_PAGE_LEN) != 0u)
	j	.L207
.L208:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2009                              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2010                                  tmpAddr_u32++;
	add	d0,#1
.L207:
	and	d15,d0,#7
.L1352:
	jne	d15,#0,.L208
.L1353:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2011                              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2012  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2013                              /* Check if the block is maybe greater then 1 sector and so the sector contains programmed pages, but no blockheader */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2014                              if (tmpAddr_u32 >= Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogEndAddress_u32)
	ld.w	d15,[a15]12
.L1354:
	lt.u	d15,d0,d15
.L1355:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2015                              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2016                                  tmpAddr_u32 = FEE_MAXUINT32;
	cmovn	d0,d15,#-1
.L209:
	j	.L210
.L206:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2017                              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2018                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2019                          else
.L210:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2020                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2021                              /* First blockheader will be stored on the first page of the logic sector.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2022                               * -> No additional correction required */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2023                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2024  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2025                          Fee_RdWrOrder_st.xStartAddrNextSector_u32 = tmpAddr_u32;
	ld.a	a15,[a10]4
	st.w	[a15]24,d0
.L1356:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2026                          Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_WRITE_START_MARKER_E;
	mov	d15,#26
.L1357:
	st.w	[a15]48,d15
.L205:
	j	.L211
.L203:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2027                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2028                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2029                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2030                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2031                      /* The marker section is full/not readable/writeable or the Fls order was not accepted.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2032                       * --> The complete sector has to be erased again. Otherwise there might be
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2033                       *     data getting lost in the future! */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2034  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2035                      /* Get corresponding logical sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2036                      xLogSectIdx_u8 = Fee_idxLLSectorOrder_au8[xPhySectIdx_u8];
	movh.a	a15,#@his(Fee_idxLLSectorOrder_au8)
	lea	a15,[a15]@los(Fee_idxLLSectorOrder_au8)
.L1358:
	addsc.a	a15,a15,d9,#0
	ld.bu	d4,[a15]
.L647:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2037  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2038                      /* Mark this sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2039                      Fee_LLSetEraseSector(xLogSectIdx_u8);
	call	Fee_LLSetEraseSector
.L644:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2040  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2041                      /* Set erase state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2042                      Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_ERASE_SECTOR_E;
	mov	d15,#24
.L1359:
	ld.a	a15,[a10]12
	st.w	[a15],d15
.L211:
.L202:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2043                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2044              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2045          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2046          break;
	j	.L212

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2047  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2048         case FEE_LL_CPY_FLS2FLS_WRITE_START_MARKER_E:
.L119:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2049         {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2050              /* Get the new physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2051              xPhySectIdx_u8 = Fee_GetPhysSectorByAddress(Fee_RdWrOrder_st.xWrAddress);
	ld.a	a15,[a10]4
	add.a	a15,#4
	ld.w	d4,[a15]
.L649:
	call	Fee_GetPhysSectorByAddress
.L648:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2052  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2053              /* Write the USED marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2054              xWrMarkerRetVal_en = Fee_LLWriteMarker(xPhySectIdx_u8, FEE_START_MARKER_ID_E);
	mov	d5,#5
	mov	d4,d2
.L651:
	call	Fee_LLWriteMarker
.L650:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2055  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2056              /* Check the write USED marker result */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2057              if(xWrMarkerRetVal_en != FEE_ORDER_PENDING_E)
	jeq	d2,#0,.L213
.L1360:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2058              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2059                  /* Go on with the block transfer in case it is necessary. Otherwise
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2060                   * the function will be finished automatically. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2061                  Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_READ_E;
	mov	d15,#1
.L1361:
	ld.a	a15,[a10]12
	st.w	[a15],d15
.L213:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2062              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2063          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2064         break;
	j	.L214

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2065  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2066          #if(FEE_ROBUST_PROG_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2067          case FEE_LL_CPY_FLS2FLS_ROBUST_IFX_HANDLING_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2068          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2069              /* Get the new physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2070              xPhySectIdx_u8 = Fee_GetPhysSectorByAddress(Fee_RdWrOrder_st.xWrAddress);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2071  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2072              /* Get corresponding logical sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2073              xLogSectIdx_u8 = Fee_idxLLSectorOrder_au8[xPhySectIdx_u8];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2074  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2075              if (Fee_RobIfxHandling(xLogSectIdx_u8) != FEE_ORDER_PENDING_E){
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2076                  xRetVal_en = FEE_ERROR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2077              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2078          }break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2079          #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2080  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2081          #if defined (FEE_PRV_ROBUST_SECT_OVERFLOW)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2082          case FEE_LL_CPY_FLS2FLS_ROBUST_SECT_OVERFLOW_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2083          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2084              if (Fee_LlRobustSectorOverflow() != FEE_ORDER_PENDING_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2085              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2086                  /* Return error to start a retry of complete sector reorganisation. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2087                  xRetVal_en = FEE_ERROR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2088              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2089          }break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2090          #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2091  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2092          /* Default case should never be reached */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2093          default:
.L92:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2094              /* Return error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2095              xRetVal_en = FEE_ERROR_E;
	mov	d8,#3
.L1362:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2096          break;
	j	.L215

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2097      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2098  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2099      /* Check if the function is finished (with or without success) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2100      if(xRetVal_en != FEE_ORDER_PENDING_E)
.L215:
.L214:
.L212:
.L201:
.L193:
.L185:
.L181:
.L178:
.L173:
.L166:
.L163:
.L157:
.L154:
.L152:
.L128:
	jeq	d8,#0,.L216
.L1363:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2101      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2102          Fee_RdWrOrder_st.Fee_LLCpyBlkFls2Fls_en = FEE_LL_CPY_FLS2FLS_INIT_E;
	mov	d15,#0
.L1364:
	ld.a	a15,[a10]12
	st.w	[a15],d15
.L1365:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2103  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2104          /* These are additional resets (cannot be reset in the init state) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2105          Fee_LLSecReorgStruct_st.xCntCopies_u8 = 0;
	movh.a	a15,#@his(Fee_LLSecReorgStruct_st)
	lea	a15,[a15]@los(Fee_LLSecReorgStruct_st)
.L1366:
	lea	a15,[a15]8
.L1367:
	mov	d15,#0
.L1368:
	st.b	[a15],d15
.L1369:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2106          xCntRetry_u8 = FEE_MAX_RD_WR_COMP_RETRIES;
	movh.a	a15,#@his(_999003_xCntRetry_u8)
	lea	a15,[a15]@los(_999003_xCntRetry_u8)
.L1370:
	mov	d15,#3
.L1371:
	st.b	[a15],d15
.L216:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2107      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2108  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2109      return (xRetVal_en);
	mov	d2,d8
.L652:
	j	.L217

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2110  }
.L217:
	ret
.L435:
	
__Fee_LLCpyBlkFromFls2Fls_function_end:
	.size	Fee_LLCpyBlkFromFls2Fls,__Fee_LLCpyBlkFromFls2Fls_function_end-Fee_LLCpyBlkFromFls2Fls
.L355:
	; End of function
	
	.sdecl	'.text.rba_FeeFs1_LlBlockHandling.Fee_LLCalcBlkCrcInFlash',code,cluster('Fee_LLCalcBlkCrcInFlash')
	.sect	'.text.rba_FeeFs1_LlBlockHandling.Fee_LLCalcBlkCrcInFlash'
	.align	2
	
	.global	Fee_LLCalcBlkCrcInFlash

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2111  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2112  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2113  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2114   ***********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2115   * Fee_SectorOverflow(): Handles the sector overflow situation during sector reorganisation.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2116   * This function is called only when there is not enough space to transfer all the old data to new sector during sector
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2117   * reorganisation (this situation may arrise due to continous resets and sector being fully occupied).
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2118   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2119   * The design is different for Renasas controllers and all other controllers for following reasons:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2120   * 1. No Fall back feature leaves a page blank before the header. During the copy operation this page must be left blank.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2121   *    This means that a bulk programming is not possible. Page must be first checked if its blank, then transfered.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2122   * 2. It is not possible to give the source address as Flash area when placing write request, the data must be first
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2123   *    read out in internal buffer and then this buffer must be given for programming. Junk data might be written if
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2124   *    the flash address is given as source address (hardware doesnt allow read from one flash area when flash operation
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2125   *    is going on).
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2126   * Hence, for Renasas controllers, the design is to erase the sectors after the HSR (sectors are small and 64bytes).
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2127   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2128   * For all other controllers, this function copies data till HSR in the last but one sector information to next sector.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2129   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2130   * \param    none:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2131   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2132   * \return   Function result
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2133   * \retval   FEE_ORDER_PENDING_E    : Operation is ongoing
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2134   * \retval   FEE_ABORTED_E          : Order was aborted due to incorrect parameters for FLS function.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2135   * \retval   FEE_ERROR_E            :
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2136   * \retval   FEE_ORDER_FINISHED_E   : Sector rearrangement is completed. Sector reorg can now be retried.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2137   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2138   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2139   ***********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2140   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2141  #if defined (FEE_PRV_ROBUST_SECT_OVERFLOW)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2142  FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LlRobustSectorOverflow(void)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2143  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2144      VAR(Fee_stRetVal_ten, AUTOMATIC)    xRetVal_en      = FEE_ORDER_PENDING_E;  /* Function return */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2145      VAR(Fee_stRetVal_ten, AUTOMATIC)    xTmpRetVal_en   = FEE_ORDER_PENDING_E;  /* Temporary return value of llErase Function */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2146      VAR(uint8,   AUTOMATIC)             xLogSecIdx_u8;                          /* Index of the logical sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2147      VAR(uint8,   AUTOMATIC)             xPhySectIdx_u8;                         /* Index of the physical sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2148      static VAR(Fls_LengthType, FEE_VAR) xDataSize_uo;                           /* Size of data to be copied. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2149      static VAR(Fls_LengthType, FEE_VAR) xCntPgmSize_uo;                         /* Amount of bytes copied in one step. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2150  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2151      switch (Fee_RdWrOrder_st.Fee_LLRobustSectOverflow_en)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2152      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2153          case FEE_LL_ROBUST_SECTOR_OVERFLOW_INIT_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2154          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2155              /* Data must be copied from last but one sector, compute the start address of this sector. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2156              xLogSecIdx_u8 = FEE_NUM_FLASH_BANKS_AVAILABLE - 2u;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2157  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2158              /* Get the physical sector index of the Last but one sector. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2159              xPhySectIdx_u8 = Fee_LLSectorOrder_st[xLogSecIdx_u8].xPhySecIdx_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2160  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2161              /* Update Read address to start of the last but one sector (skip the sector header area). */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2162              Fee_RdWrOrder_st.xRdAddress = Fee_FlashProp_st[xPhySectIdx_u8].Fee_PhysStartAddress_u32 + FEE_SEC_HEADER_SIZE;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2163  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2164              /* Last sector is the sector that will be currently worked upon. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2165              xLogSecIdx_u8 = FEE_NUM_FLASH_BANKS_AVAILABLE - 1u;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2166  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2167              /* Get the physical sector index of the Last sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2168              xPhySectIdx_u8 = Fee_LLSectorOrder_st[xLogSecIdx_u8].xPhySecIdx_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2169  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2170              /* Update Write address to start of the last sector (skip the sector header area). */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2171              Fee_RdWrOrder_st.xWrAddress = Fee_FlashProp_st[xPhySectIdx_u8].Fee_PhysStartAddress_u32 + FEE_SEC_HEADER_SIZE;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2172  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2173              /* Compute the amount of bytes to be copied (from top of the sector till HSR) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2174              xDataSize_uo = (((FEE_PHYS_SEC_END0 + 1u) - FEE_PHYS_SEC_START0)*2u) - FEE_REQUIRED_FREE_SPACE_BEFORE_HARD_SR;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2175  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2176              /* Round it to the nearest page size. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2177              while ((xDataSize_uo % FEE_PAGE_LEN) != 0u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2178              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2179                  xDataSize_uo++;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2180              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2181  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2182              Fee_RdWrOrder_st.Fee_LLRobustSectOverflow_en = FEE_LL_ROBUST_SECTOR_OVERFLOW_WR_CM_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2183          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2184          /* No break to save time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2185  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2186          /* MR12 RULE 16.3 VIOLATION: Time critical position */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2187          case FEE_LL_ROBUST_SECTOR_OVERFLOW_WR_CM_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2188          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2189              xPhySectIdx_u8 = Fee_LLSectorOrder_st[FEE_NUM_FLASH_BANKS_AVAILABLE - 1u].xPhySecIdx_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2190  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2191              /* Write the CLONE_START marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2192              if(Fee_LLWriteMarker(xPhySectIdx_u8, FEE_CLONE_START_MARKER_ID_E) != FEE_ORDER_PENDING_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2193              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2194                  /* in the sector header, there is the information available, that a clone procedure has started. Now it
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2195                   * is allowed to write data in this sector. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2196                  Fee_RdWrOrder_st.Fee_LLRobustSectOverflow_en = FEE_LL_ROBUST_SECTOR_OVERFLOW_PREPARE_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2197              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2198          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2199          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2200  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2201          case FEE_LL_ROBUST_SECTOR_OVERFLOW_PREPARE_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2202          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2203              /* For Renesas the entire operation is done one page at a time, as blank pages maybe there due to no fall back feature and these pages must be left blank in the new sector as well. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2204              #if ( defined(RBA_FLSRH850P1xC_FLASH) || defined(RBA_FLSV850R1x_FLASH) || defined(RBA_FLSRH850xx_FLASH) )
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2205              xCntPgmSize_uo = FEE_PAGE_LEN;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2206  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2207              Fee_RdWrOrder_st.Fee_LLRobustSectOverflow_en = FEE_LL_ROBUST_SECTOR_OVERFLOW_BLANK_CHK_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2208              #else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2209              /* At maximum FEE_LL_PAGEBUFFSIZE bytes can be read in one step. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2210              if (xDataSize_uo > FEE_LL_PAGEBUFFSIZE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2211              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2212                  xCntPgmSize_uo = FEE_LL_PAGEBUFFSIZE;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2213              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2214              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2215              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2216                  xCntPgmSize_uo = xDataSize_uo;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2217              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2218  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2219              Fee_RdWrOrder_st.Fee_LLRobustSectOverflow_en = FEE_LL_ROBUST_SECTOR_OVERFLOW_COPY_DATA_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2220              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2221  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2222          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2223          /* No break to save time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2224  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2225          /* For Renesas controllers, first check if the page is blank or not before transfering the information. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2226          /* MR12 RULE 16.3 VIOLATION: Time critical position */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2227          #if ( defined(RBA_FLSRH850P1xC_FLASH) || defined(RBA_FLSV850R1x_FLASH) || defined(RBA_FLSRH850xx_FLASH) )
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2228          case FEE_LL_ROBUST_SECTOR_OVERFLOW_BLANK_CHK_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2229          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2230              if (Fls_Rb_BlankCheck(Fee_RdWrOrder_st.xRdAddress, NULL_PTR, xCntPgmSize_uo) != E_NOT_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2231              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2232                  /* Blank check order accepted, go to wait state. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2233                  Fee_RdWrOrder_st.Fee_LLRobustSectOverflow_en = FEE_LL_ROBUST_SECTOR_OVERFLOW_BLANK_CHK_WAIT_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2234              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2235              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2236              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2237                  xRetVal_en = FEE_ABORTED_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2238              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2239          }break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2240          #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2241  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2242          /* Page is not blank and has data, read this data to transfer it to new sector. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2243          /* MR12 RULE 16.3 VIOLATION: Time critical position */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2244          case FEE_LL_ROBUST_SECTOR_OVERFLOW_READ_PAGE_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2245          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2246              if (Fls_Read(Fee_RdWrOrder_st.xRdAddress, (uint8*)&Fee_PageBytePtr_cpu8[0], xCntPgmSize_uo) != E_NOT_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2247              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2248                  /* Read request accepted, go to wait state. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2249                  Fee_RdWrOrder_st.Fee_LLRobustSectOverflow_en = FEE_LL_ROBUST_SECTOR_OVERFLOW_READ_PAGE_WAIT_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2250              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2251              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2252              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2253                  xRetVal_en = FEE_ABORTED_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2254              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2255          }break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2256  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2257          /* Tranfer the data to new sector. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2258          case FEE_LL_ROBUST_SECTOR_OVERFLOW_COPY_DATA_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2259          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2260              if (Fls_Write(Fee_RdWrOrder_st.xWrAddress, (uint8*)&Fee_PageBytePtr_cpu8[0], xCntPgmSize_uo) != E_NOT_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2261              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2262                  /* Write request accepted, go to wait state. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2263                  Fee_RdWrOrder_st.Fee_LLRobustSectOverflow_en = FEE_LL_ROBUST_SECTOR_OVERFLOW_COPY_DATA_WAIT_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2264              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2265              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2266              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2267                  xRetVal_en = FEE_ABORTED_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2268              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2269          }break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2270  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2271          /* Verify if the data copy was correct. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2272          case FEE_LL_ROBUST_SECTOR_OVERFLOW_VERIFY_DATA_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2273          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2274              if (Fls_Compare(Fee_RdWrOrder_st.xWrAddress, (uint8*)&Fee_PageBytePtr_cpu8[0], xCntPgmSize_uo) != E_NOT_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2275              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2276                  /* Compare request accepted, go to wait state. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2277                  Fee_RdWrOrder_st.Fee_LLRobustSectOverflow_en = FEE_LL_ROBUST_SECTOR_OVERFLOW_VERIFY_DATA_WAIT_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2278              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2279              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2280              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2281                  xRetVal_en = FEE_ABORTED_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2282              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2283          }break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2284  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2285          /* Wait for the order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2286          #if ( defined(RBA_FLSRH850P1xC_FLASH) || defined(RBA_FLSV850R1x_FLASH) || defined(RBA_FLSRH850xx_FLASH) )
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2287          case FEE_LL_ROBUST_SECTOR_OVERFLOW_BLANK_CHK_WAIT_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2288          #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2289  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2290          case FEE_LL_ROBUST_SECTOR_OVERFLOW_READ_PAGE_WAIT_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2291          case FEE_LL_ROBUST_SECTOR_OVERFLOW_COPY_DATA_WAIT_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2292          case FEE_LL_ROBUST_SECTOR_OVERFLOW_VERIFY_DATA_WAIT_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2293          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2294              /* switching state from WAIT --> DONE/ERROR will be done in
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2295               * Fee_JobEndNotification and Fee_JobErrorNotification */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2296  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2297              /* Check whether the OS is currently running or not */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2298              if(Fee_stMain == FEE_POLLING_MODE_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2299              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2300                  /* Call the Fls main function manually */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2301                  Fls_MainFunction();
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2302              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2303  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2304              #if (STD_ON == FEE_POLLING_MODE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2305              /* Use the FLS polling mechanism in order to reach the next state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2306              Fee_CheckFlsJobResult();
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2307              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2308          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2309          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2310  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2311          /* Page transfer was successful, check if there are more bytes to be transfered. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2312          case FEE_LL_ROBUST_SECTOR_OVERFLOW_VERIFY_SUCCESS_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2313          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2314              /* Data transfer was successful, increment the read and write addresses and decrement the amount of bytes transfered.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2315               * There is no need to handle the sector overflow situation, as this will never occur in this function. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2316              Fee_RdWrOrder_st.xWrAddress += xCntPgmSize_uo;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2317              Fee_RdWrOrder_st.xRdAddress += xCntPgmSize_uo;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2318              xDataSize_uo -= xCntPgmSize_uo;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2319  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2320              /* Check if all bytes are transfered. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2321              if (xDataSize_uo != 0u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2322              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2323                  /* Some more data yet to be transfered, continue with the transfer of data. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2324                  Fee_RdWrOrder_st.Fee_LLRobustSectOverflow_en = FEE_LL_ROBUST_SECTOR_OVERFLOW_PREPARE_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2325              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2326              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2327              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2328                  /* Data transfer is complete. Go to next state to write used marker. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2329                  Fee_RdWrOrder_st.Fee_LLRobustSectOverflow_en = FEE_LL_ROBUST_SECTOR_OVERFLOW_WR_UM_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2330              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2331          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2332          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2333  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2334          /* All information is transfered to new sector, mark this sector to be used and then swap the sector order. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2335          case FEE_LL_ROBUST_SECTOR_OVERFLOW_WR_UM_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2336          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2337              /* Get the physical sector index of the FULL sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2338              xPhySectIdx_u8 = Fee_GetPhysSectorByAddress(Fee_RdWrOrder_st.xWrAddress);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2339  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2340              /* Write the CLONE_START marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2341              if(Fee_LLWriteMarker(xPhySectIdx_u8, FEE_USED_MARKER_ID_E) != FEE_ORDER_PENDING_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2342              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2343                  /* In the sector header, there is the information available, that a clone procedure has started. Now it
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2344                   * is allowed to write data in this sector. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2345                  Fee_RdWrOrder_st.Fee_LLRobustSectOverflow_en = FEE_LL_ROBUST_SECTOR_OVERFLOW_SORT_SECT_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2346              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2347          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2348          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2349  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2350          /* Swap the sector order. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2351          case FEE_LL_ROBUST_SECTOR_OVERFLOW_SORT_SECT_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2352          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2353              /* Cache invalidation is not requried as this is already done in the state FEE_LL_CPY_FLS2FLS_ERASE_SECTOR_E of Fee_LLCpyBlkFls2Fls().*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2354  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2355              /* Put the old sector at the end of the sector list and mark the sector with request to erase marker.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2356               * In this error case only the last 2 sectors have to be swapped. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2357              /* Back up the information for last but one sector. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2358              xLogSecIdx_u8 = FEE_NUM_FLASH_BANKS_AVAILABLE - 2u;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2359              xPhySectIdx_u8 = Fee_LLSectorOrder_st[xLogSecIdx_u8].xPhySecIdx_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2360  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2361              /* Reorganize the sector order */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2362              Fee_LLSectorOrder_st[xLogSecIdx_u8] = Fee_LLSectorOrder_st[xLogSecIdx_u8 + 1u];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2363              /* Reorganize the array Ram table */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2364              Fee_idxLLSectorOrder_au8[Fee_LLSectorOrder_st[xLogSecIdx_u8].xPhySecIdx_u8] = xLogSecIdx_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2365  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2366              /* Update the state information of the last sector in the ring with the data of the sector with the wordline failure. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2367              Fee_LLSectorOrder_st[xLogSecIdx_u8 + 1u].xPhySecIdx_u8   = xPhySectIdx_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2368              Fee_idxLLSectorOrder_au8[xPhySectIdx_u8] = xLogSecIdx_u8 + 1u;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2369  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2370              /* mark the last sector as ready to erase */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2371              Fee_LLSetEraseSector(FEE_NUM_FLASH_BANKS-1);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2372  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2373              xRetVal_en = FEE_ORDER_FINISHED_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2374          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2375          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2376  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2377          /* Error state for all kinds of error (read error, blank check error, write error, blank check error and erase error.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2378           * In all these error case, the safest thing to do is retry the complete operation, starting with an erase of the latest sector. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2379          case FEE_LL_ROBUST_SECTOR_OVERFLOW_ERROR_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2380          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2381              /* Prepare the erase request for the last sector. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2382              xLogSecIdx_u8 = FEE_NUM_FLASH_BANKS_AVAILABLE - 1u;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2383  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2384              Fee_LLSetEraseSector(xLogSecIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2385  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2386              Fee_RdWrOrder_st.Fee_LLRobustSectOverflow_en = FEE_LL_ROBUST_SECTOR_OVERFLOW_ERASE_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2387          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2388          /* No break to save time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2389  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2390          /* MR12 RULE 16.3 VIOLATION: Time critical position */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2391          case FEE_LL_ROBUST_SECTOR_OVERFLOW_ERASE_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2392          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2393              xTmpRetVal_en = Fee_LLEraseSector();
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2394              if(xTmpRetVal_en == FEE_ORDER_PENDING_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2395              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2396                  /* Erase is ongoing. do nothing till it is completed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2397              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2398              else if(xTmpRetVal_en == FEE_ORDER_FINISHED_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2399              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2400                  /* Erase is completed successfully, re-start the transfer operation from beginnning. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2401                  Fee_RdWrOrder_st.Fee_LLRobustSectOverflow_en = FEE_LL_ROBUST_SECTOR_OVERFLOW_INIT_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2402              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2403              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2404              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2405                  /* Erase was not successful, retry the erase operation. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2406                  Fee_RdWrOrder_st.Fee_LLRobustSectOverflow_en = FEE_LL_ROBUST_SECTOR_OVERFLOW_ERROR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2407              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2408          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2409          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2410  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2411          default:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2412              /* Return with error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2413              xRetVal_en = FEE_ERROR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2414          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2415      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2416  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2417      /* Check if order was finished with or without success */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2418      if (xRetVal_en != FEE_ORDER_PENDING_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2419      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2420          /* Reset state machine */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2421          Fee_RdWrOrder_st.Fee_LLRobustSectOverflow_en = FEE_LL_ROBUST_SECTOR_OVERFLOW_INIT_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2422      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2423  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2424      return (xRetVal_en);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2425  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2426  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2427  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2428   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2429   * Fee_LLCalcBlkCrcInFlash(): Calculate the block checksum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2430   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2431   * This function calculates the block checksum in the flash.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2432   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2433   * \param    HeaderInfo_pcst:        Pointer to the block header that was
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2434   *                                  found in the flash.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2435   * \return   Function result
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2436   * \retval   FEE_ORDER_PENDING_E:   Order is still pending
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2437   * \retval   FEE_ABORTED_E:         Order was aborted due to a wrong
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2438   *                                  FLS compare function call
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2439   * \retval   FEE_ERROR_E:           The checksum is wrong or a read
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2440   *                                  error occured
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2441   * \retval   FEE_ORDER_FINISHED_E:  The checksum is correct (either
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2442   *                                  standard or rob checksum)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2443   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2444   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2445   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2446   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2447  FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLCalcBlkCrcInFlash(P2CONST(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) HeaderInfo_pcst)
; Function Fee_LLCalcBlkCrcInFlash
.L327:
Fee_LLCalcBlkCrcInFlash:	.type	func
	sub.a	a10,#16
.L653:
	st.a	[a10],a4
.L655:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2448  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2449      VAR(Fee_stRetVal_ten, AUTOMATIC) xRetVal_en = FEE_ORDER_PENDING_E;  /* Function return */
	mov	d8,#0
.L656:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2450      VAR(uint8, AUTOMATIC) xPhySectIdx_u8 = 0;                           /* Physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2451      VAR(uint8, AUTOMATIC) xPhyWrSectIdx_u8 = 0;                         /* Physical sector index of the write address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2452      VAR(uint8, AUTOMATIC) xLogSectIdx_u8 = 0;                           /* Logical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2453      VAR(uint16, AUTOMATIC) xDataBlkLength_u16  = 0;                     /* Temporary data length */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2454      static uint16 xNumBytes_u16 = 0;                                    /* Amount of data bytes to use for the calculation */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2455      static uint32 xBlkCrc32_u32 = 0;                                    /* Block CRC */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2456      static uint16 xConfigPropTableIdx_u16 = 0;                          /* Respective block properties index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2457      static boolean xFirstCRCRunDone_b = FALSE;                          /* Indication for the first CRC run */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2458  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2459      #if(FEE_ROB_FEATURE_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2460      VAR(uint8, AUTOMATIC) i_u8 = 0;                                     /* Loop counter */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2461      VAR(uint32, AUTOMATIC) xNumBytesLeft_32 = 0;                        /* Number of bytes left for the current sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2462      static uint32 xBlkRobCrc32_u32 = 0;                                 /* Robustness block CRC */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2463      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2464  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2465  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2466      /* Switch over the state machine */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2467      switch (Fee_RdWrOrder_st.Fee_LLCalcCrcBlk_en)
	movh.a	a15,#@his(Fee_RdWrOrder_st)
	lea	a15,[a15]@los(Fee_RdWrOrder_st)
	st.a	[a10]4,a15
.L840:
	lea	a2,[a15]84
	st.a	[a10]8,a2
	ld.w	d0,[a15]84
.L841:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2468      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2469          /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2470          case FEE_LL_CRC_BLK_INIT_E:
	mov	d15,#0
	jeq	d15,d0,.L218
.L842:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2471          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2472              /* Get the block header address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2473              Fee_RdWrOrder_st.xCrcAddress = HeaderInfo_pcst->AdrBlkHeader_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2474  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2475              /* Reset variables */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2476              xBlkCrc32_u32      = 0;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2477              xFirstCRCRunDone_b = FALSE;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2478              Fee_GlobInfoWrBlock_st.BytesAlrdyCompared_u16 = 0;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2479  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2480              #if(FEE_FAST_CACHE_INIT_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2481              (void)Fee_SrvBinarySearchInBlockPropFast(HeaderInfo_pcst->FeeIndex_u16, &xConfigPropTableIdx_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2482              #else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2483              /* Get the current block properties index in case a sector reorganization is running
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2484               * (no order queue entry available) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2485              (void)Fee_SrvBinarySearchInBlockProp(HeaderInfo_pcst->FeeIndex_u16, &xConfigPropTableIdx_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2486              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2487  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2488              /* Identify the correct number of bytes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2489              if(HeaderInfo_pcst->BlkLength_u16 > FEE_LL_PAGEBUFFSIZE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2490              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2491                  /* Restrict the number of bytes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2492                  xNumBytes_u16 = FEE_LL_PAGEBUFFSIZE;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2493              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2494              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2495              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2496                  /* The block length can be used unrestricted */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2497                  xNumBytes_u16 = HeaderInfo_pcst->BlkLength_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2498              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2499  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2500              /* Reset the page buffer to make sure no wrong data remains inside */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2501              Fee_SrvMemSet8((uint8*)&Fee_PageBytePtr_cpu8[0], (uint8)FEE_ERASE_PATTERN, xNumBytes_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2502  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2503              /* Set next state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2504              Fee_RdWrOrder_st.Fee_LLCalcCrcBlk_en  = FEE_LL_CRC_RD_HD_PAGE_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2505          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2506          /* No break to save time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2507  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2508          /* Read the header page */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2509          /* MR12 RULE 16.3 VIOLATION: Time critical position */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2510          case FEE_LL_CRC_RD_HD_PAGE_E:
	mov	d1,#1
	jeq	d1,d0,.L219
.L843:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2511          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2512              /* Get the number of data bytes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2513              xNumBytes_u16 = HeaderInfo_pcst->BlkLength_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2514  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2515              /* Check for the robustness configuration of this block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2516              if((((HeaderInfo_pcst->BlkStatus_u8 & (uint8)FEE_FLAG_ROBUST_ATTR_MSK) >> (uint8)FEE_FLAG_ROBUST_ATTR_BP) > 0) &&
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2517                  ((HeaderInfo_pcst->BlkStatus_u8 & (uint8)FEE_FLAG_INVALID_MSK) == 0))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2518              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2519                  /* Adapt the block length for checking the regular checksum first */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2520                  xNumBytes_u16 -= FEE_SIZE_OF_BLOCK_CS;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2521              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2522  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2523              if(xNumBytes_u16 > FEE_FREE_BYTES_AFTER_HEADER)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2524              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2525                  /* During the header page read routine only some data bytes are located
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2526                   * behind the header within the same page */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2527                  xNumBytes_u16 = FEE_FREE_BYTES_AFTER_HEADER;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2528              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2529  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2530              /* Read back the block header pages (no need for an overflow check since the header will
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2531               * always be located within one sector only) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2532              if(Fls_Read(Fee_RdWrOrder_st.xCrcAddress,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2533                          (uint8*)&Fee_PageBytePtr_cpu8[0],
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2534                          (FEE_PAGE_LEN * FEE_PAGES_USED_BY_BLK_HEADER)) != E_NOT_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2535              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2536                  /* Set the next state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2537                  Fee_RdWrOrder_st.Fee_LLCalcCrcBlk_en = FEE_LL_CRC_RD_PAGE_WAIT_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2538  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2539                  /* Increment the read address for the next Fls access (overflow is checked automatically) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2540                  Fee_IncAddressInsideSector(&Fee_RdWrOrder_st.xCrcAddress, (FEE_PAGE_LEN * FEE_PAGES_USED_BY_BLK_HEADER), TRUE);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2541              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2542              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2543              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2544                  /* Abort the function due to invalid Fls parameters or a busy Fls */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2545                  xRetVal_en = FEE_ABORTED_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2546              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2547          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2548          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2549  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2550          /* Wait for the read function to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2551          case FEE_LL_CRC_RD_PAGE_WAIT_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2552  #if(FEE_ROB_FEATURE_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2553          case FEE_LL_CRC_RD_ROB_PAGE_WAIT_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2554  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2555          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2556              /* The next state will be set by the Fee_JobEndNotification () or
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2557               * Fee_JobErrorNotification() function automatically */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2558  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2559              /* Check whether the OS is currently running or not */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2560              if (Fee_stMain == FEE_POLLING_MODE_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2561              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2562                  /* Call the Fls main function manually */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2563                  Fls_MainFunction();
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2564              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2565  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2566              #if (STD_ON == FEE_POLLING_MODE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2567              /* Use the FLS polling mechanism in order to reach the next state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2568              Fee_CheckFlsJobResult();
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2569              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2570          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2571          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2572  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2573          /* Read error case */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2574          case FEE_LL_CRC_RD_ERROR_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2575          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2576              /* Verify retry possibility */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2577              if(Fee_RdWrRetries_u8 > 0)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2578              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2579                  /* Decrement retry possibilities */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2580                  Fee_RdWrRetries_u8--;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2581  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2582                  /* No matter when the read error happened (for reading the header
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2583                   * or the data), restart from the beginning */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2584                  Fee_RdWrOrder_st.Fee_LLCalcCrcBlk_en = FEE_LL_CRC_BLK_INIT_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2585              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2586              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2587              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2588                  /* The maximum amount of retries was reached. Do not invalidate the
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2589                   * cache since the root cause for the read failure is not clear */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2590                  Fee_LLUpdateAddressInCache(HeaderInfo_pcst->FeeIndex_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2591                                             FEE_CACHE_TMP_INVALID_VALUE);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2592  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2593                  /* Return error
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2594                   * --> Sector reorganization: Search for older copies
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2595                   * --> Read blocks: Search for older copies (independent from
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2596                   *     forced read / normal read) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2597                  xRetVal_en = FEE_ERROR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2598              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2599          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2600          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2601  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2602          /* Check for an overlap of the CRC address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2603          case FEE_LL_CRC_CHECK_OVERLAP_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2604  #if(FEE_ROB_FEATURE_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2605          case FEE_LL_CRC_CHECK_OVERLAP_ROB_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2606  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2607          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2608              /* Set the next state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2609  #if(FEE_ROB_FEATURE_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2610              if(Fee_RdWrOrder_st.Fee_LLCalcCrcBlk_en == FEE_LL_CRC_CHECK_OVERLAP_ROB_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2611              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2612                  Fee_RdWrOrder_st.Fee_LLCalcCrcBlk_en = FEE_LL_CRC_RD_ROB_PAGE_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2613                  xDataBlkLength_u16 = FEE_SIZE_OF_BLOCK_CS;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2614              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2615              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2616  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2617              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2618                  Fee_RdWrOrder_st.Fee_LLCalcCrcBlk_en = FEE_LL_CRC_RD_PAGE_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2619                  xDataBlkLength_u16 = HeaderInfo_pcst->BlkLength_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2620              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2621  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2622              /* Get the physical sector index of the CRC address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2623              xPhySectIdx_u8 = Fee_GetPhysSectorByAddress(Fee_RdWrOrder_st.xCrcAddress);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2624  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2625              /* Get the physical sector index of the write address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2626              xPhyWrSectIdx_u8 = Fee_GetPhysSectorByAddress(Fee_RdWrOrder_st.xWrAddress);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2627  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2628              /* The CRC address is already incremented with the number of bytes from the previous read order
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2629               * -> if the CRC address is now behind the write address the block is not written completely! */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2630              if ((Fee_RdWrOrder_st.xCrcAddress > Fee_RdWrOrder_st.xWrAddress) &&
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2631                  (xPhySectIdx_u8 == xPhyWrSectIdx_u8))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2632              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2633                  /* Abort */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2634                  xRetVal_en = FEE_ERROR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2635              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2636  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2637              /* Check if there are still bytes left to be checked */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2638              if((Fee_GlobInfoWrBlock_st.BytesAlrdyCompared_u16 + xNumBytes_u16) < xDataBlkLength_u16)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2639              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2640                  /* Check if the address behind the current block header is located at the very
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2641                   * end of the current sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2642                  if(Fee_RdWrOrder_st.xCrcAddress >= Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogEndAddress_u32)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2643                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2644                      /* The corresponding data is located in the next logical sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2645                      xLogSectIdx_u8 = (uint8)(Fee_idxLLSectorOrder_au8[xPhySectIdx_u8] + 1);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2646  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2647                      /* Check if switching from last to first sector requires an overflow */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2648                      if (xLogSectIdx_u8 >= FEE_NUM_FLASH_BANKS)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2649                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2650                          /* Abort, the block cannot continue in the logical sector 0 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2651                          xRetVal_en = FEE_ERROR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2652                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2653                      else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2654                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2655                          /* Before switching to next sector, check if next sector is programmed with data and if there are more data to be read. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2656                          if((Fee_LLSectorOrder_st[xLogSectIdx_u8].SecState_en == FEE_SECTOR_USED_E) ||
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2657                             (Fee_LLSectorOrder_st[xLogSectIdx_u8].SecState_en == FEE_SECTOR_FULL_E))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2658                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2659                              /* Get the new physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2660                              xPhySectIdx_u8 = Fee_LLSectorOrder_st[xLogSectIdx_u8].xPhySecIdx_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2661  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2662                              /* Set the new start address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2663                              Fee_RdWrOrder_st.xCrcAddress = Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogStartAddress_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2664                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2665                          else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2666                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2667                              /* Abort, the block check as next sector is still not programmed with data. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2668                              xRetVal_en = FEE_ERROR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2669                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2670                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2671                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2672              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2673              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2674              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2675                  /* There wont be any more reads in the next sector as all bytes are read.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2676                     Its important that the driver continues with the next step and checks if the checksum matches. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2677              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2678          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2679          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2680  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2681          /* Calculate the block checksums */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2682          case FEE_LL_CRC_RD_PAGE_E:
	mov	d1,#2
	jeq	d1,d0,.L220
.L844:
	mov	d1,#3
	jeq	d1,d0,.L221
.L845:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2683          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2684              /* Check if this is a normal data page or not */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2685              if (xFirstCRCRunDone_b == FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2686              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2687                  /* This is the first time that this function is called
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2688                   * --> block header information + data bytes are available in the page buffer
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2689                   * --> get the start value for the data CRC */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2690  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2691                  /* Calculate the checksum beginning with the data bytes position (the page buffer contains some
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2692                   * data bytes which are not protected by the header checksum but by the block checksum only) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2693                  xBlkCrc32_u32 = Crc_CalculateCRC32((uint8*)&Fee_PageBytePtr_cpu8[FEE_BLK_HEADER_SIZE],
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2694                                                      (uint32)xNumBytes_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2695                                                      (((uint32)HeaderInfo_pcst->HdrCrc16_u16) ^ FEE_MAXUINT32),
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2696                                                      FALSE);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2697  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2698                  /* Indicate that the first CRC run has been performed already */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2699                  xFirstCRCRunDone_b = TRUE;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2700              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2701              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2702              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2703                  /* This is a normal data page
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2704                   * --> only data bytes are available in the page buffer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2705  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2706                  /* XOR for the start value is necessary if the calculation is done over multiple steps
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2707                   * and done by the CRC routine itself (AR40 Rev2) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2708  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2709                  /* Calculate the checksum over the complete page buffer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2710                  xBlkCrc32_u32 = Crc_CalculateCRC32((uint8*)&Fee_PageBytePtr_cpu8[0],
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2711                                                     (uint32)xNumBytes_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2712                                                      xBlkCrc32_u32,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2713                                                      FALSE);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2714              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2715  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2716              /* Increment the amount of bytes that have already been considered */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2717              Fee_GlobInfoWrBlock_st.BytesAlrdyCompared_u16 = (uint16)(Fee_GlobInfoWrBlock_st.BytesAlrdyCompared_u16 +
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2718                                                                       xNumBytes_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2719  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2720              #if(FEE_ROB_FEATURE_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2721              /* Check for the robustness configuration of this block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2722              if((((HeaderInfo_pcst->BlkStatus_u8 & (uint8)FEE_FLAG_ROBUST_ATTR_MSK) >> (uint8)FEE_FLAG_ROBUST_ATTR_BP) > 0) &&
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2723                 ((HeaderInfo_pcst->BlkStatus_u8 & (uint8)FEE_FLAG_INVALID_MSK) == 0))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2724              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2725                  /* Adapt the block length for checking the regular checksum first */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2726                  xDataBlkLength_u16 = HeaderInfo_pcst->BlkLength_u16 - FEE_SIZE_OF_BLOCK_CS;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2727              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2728              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2729              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2730              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2731                  /* The regular length can be taken */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2732                  xDataBlkLength_u16 = HeaderInfo_pcst->BlkLength_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2733              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2734  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2735              /* Check if there are still bytes left to be checked */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2736              if (Fee_GlobInfoWrBlock_st.BytesAlrdyCompared_u16 < xDataBlkLength_u16)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2737              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2738                  /* Calculate the number of bytes which need to be read next */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2739                  xNumBytes_u16 = (uint16)(xDataBlkLength_u16 -
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2740                                           Fee_GlobInfoWrBlock_st.BytesAlrdyCompared_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2741  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2742                  /* Check for a buffer overflow */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2743                  if (xNumBytes_u16 > FEE_LL_CRC_CALC_RESTRICTION)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2744                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2745                      /* Restrict the number of bytes to read */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2746                      xNumBytes_u16 = FEE_LL_CRC_CALC_RESTRICTION;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2747                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2748  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2749                  /* Check if the current sector has enough bytes left */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2750                  if(Fee_CalculateNumOfFreeBytesInCurSector(FEE_LL_SECTOR_USED_FOR_CRC_CALC) < xNumBytes_u16)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2751                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2752                      /* Restrict the number of bytes to read */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2753                      xNumBytes_u16 = (uint16)(Fee_CalculateNumOfFreeBytesInCurSector(FEE_LL_SECTOR_USED_FOR_CRC_CALC));
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2754                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2755  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2756                  /* Read the data bytes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2757                  if(Fls_Read(Fee_RdWrOrder_st.xCrcAddress, (uint8*)&Fee_PageBytePtr_cpu8[0], xNumBytes_u16) != E_NOT_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2758                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2759                      /* Set the next state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2760                      Fee_RdWrOrder_st.Fee_LLCalcCrcBlk_en = FEE_LL_CRC_RD_PAGE_WAIT_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2761  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2762                      /* Increment the read address for the next Fls access (overflow is checked automatically) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2763                      Fee_IncAddressInsideSector(&Fee_RdWrOrder_st.xCrcAddress, xNumBytes_u16, FALSE);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2764                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2765                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2766                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2767                      /* Abort the function due to invalid Fls parameters or a busy Fls */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2768                      xRetVal_en = FEE_ABORTED_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2769                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2770              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2771              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2772              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2773                  /* Reading of this block is finished, verify the data checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2774                  if(xBlkCrc32_u32 == HeaderInfo_pcst->BlkCrc32_u32)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2775                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2776                      /* Update the address in the cache (the function will not change any
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2777                       * entries in case an unknown block is checked during an
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2778                       * "afterburner" run in the reorganization) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2779                      Fee_LLUpdateAddressInCache(HeaderInfo_pcst->FeeIndex_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2780                                                 HeaderInfo_pcst->AdrBlkHeader_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2781  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2782  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2783                      /* The calculated checksum is equal compared to the checksum in the block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2784                      xRetVal_en = FEE_ORDER_FINISHED_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2785                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2786                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2787                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2788                      /* The calculated checksum is different compared to the checksum in the block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2789  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2790                      #if(FEE_ROB_FEATURE_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2791                      /* Check for the availability of the robustness checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2792                      if(((HeaderInfo_pcst->BlkStatus_u8 & (uint8)FEE_FLAG_ROBUST_ATTR_MSK) >> (uint8)FEE_FLAG_ROBUST_ATTR_BP) > 0)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2793                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2794                          /* Read out the robustness checksum next */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2795                          Fee_RdWrOrder_st.Fee_LLCalcCrcBlk_en = FEE_LL_CRC_RD_ROB_PAGE_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2796  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2797                          /* Reset variables */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2798                          xNumBytes_u16 = 0;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2799                          Fee_GlobInfoWrBlock_st.BytesAlrdyCompared_u16 = 0;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2800                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2801                      else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2802                      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2803                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2804                          /* Check the necessity of marking the cache invalid temporarily.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2805                           * This is necessary in all cases (standard read and sector reorg for known blocks)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2806                           * besides a forced read action. An update of the cache for unknown blocks during the
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2807                           * sector reorganization does not effect the cache. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2808                          if((Fee_Rb_WorkingState_en == FEE_RB_READ_MODE_E) &&
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2809                             (Fee_OrderFifo_st[Fee_idxActQueue_u8].Mode_en == FEE_FORCED_READ_ORDER))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2810                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2811                              /* Do not mark the cache as temporary invalid for not loosing the block
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2812                               * during a reorganization after an interruption */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2813                              ;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2814                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2815                          else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2816                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2817                              /* Update the cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2818                              Fee_LLUpdateAddressInCache(HeaderInfo_pcst->FeeIndex_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2819                                                         FEE_CACHE_TMP_INVALID_VALUE);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2820                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2821  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2822                          /* Set return value */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2823                          xRetVal_en = FEE_ERROR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2824                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2825                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2826              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2827          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2828          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2829  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2830          #if(FEE_ROB_FEATURE_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2831          /* Retry with the robustness checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2832          case FEE_LL_CRC_RD_ROB_PAGE_E:
	mov	d1,#4
	jeq	d1,d0,.L222
.L846:
	mov	d1,#5
	jeq	d1,d0,.L223
.L847:
	mov	d15,#6
	jeq	d15,d0,.L224
.L848:
	mov	d15,#7
	jeq	d15,d0,.L225
.L849:
	mov	d15,#8
	jeq	d15,d0,.L226
	j	.L227
.L218:
	lea	a15,[a15]12
.L850:
	ld.a	a2,[a10]
.L654:
	ld.w	d15,[a2]
.L851:
	st.w	[a15],d15
.L852:
	movh.a	a15,#@his(_999006_xBlkCrc32_u32)
	lea	a15,[a15]@los(_999006_xBlkCrc32_u32)
.L853:
	mov	d15,#0
.L854:
	st.w	[a15],d15
.L855:
	movh.a	a15,#@his(_999008_xFirstCRCRunDone_b)
	lea	a15,[a15]@los(_999008_xFirstCRCRunDone_b)
.L856:
	mov	d15,#0
.L857:
	st.b	[a15],d15
.L858:
	movh.a	a15,#@his(Fee_GlobInfoWrBlock_st)
	lea	a15,[a15]@los(Fee_GlobInfoWrBlock_st)
.L859:
	add.a	a15,#2
.L860:
	mov	d15,#0
.L861:
	st.h	[a15],d15
.L862:
	ld.a	a15,[a10]
.L657:
	ld.hu	d0,[a15]12
.L863:
	movh.a	a15,#@his(_999007_xConfigPropTableIdx_u16)
.L658:
	lea	a15,[a15]@los(_999007_xConfigPropTableIdx_u16)
.L425:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     1  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     2  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     3  #ifndef RBA_FEEFS1_PRV_H
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     4  #define RBA_FEEFS1_PRV_H
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     5  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     6  #if(defined(FEE_PRV_CFG_SELECTED_FS) && (1 == FEE_PRV_CFG_SELECTED_FS))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     7  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     8  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     9   **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    10   * \moduledescription
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    11   *           AUTOSAR FEE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    12   *           According to Document Version 3.0.0, Part of Release 4.0, Revision 2
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    13   * \scope    INTERN
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    15   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    16  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    17  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    18  /*
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    19  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    20  * Defines/Macros
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    21  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    22  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    23  /* General defines */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    24  #define FEE_MAXUINT32               (0xFFFFFFFFuL)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    25  #define FEE_MAXUINT16               (0xFFFFu)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    26  #define FEE_NULL                    (0u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    27  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    28  #define FEE_MARKER_PATTERN          0xCAFEu                 /* Pattern to identify a marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    29  #define FEE_NUM_MARKER_IN_HEADER    (FEE_NUM_MARKER_E - 1)  /* A sector has at least 4 states:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    30                                                                 ERASED -> USED -> FULL -> ERASE_REQ
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    31                                                                 Value is also in used in Fee_Process.pm */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    32  #define FEE_NO_SEC_IDX_FOUND        0xFFu                   /* No active sector / matching flash bank found */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    33  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    34  #define FEE_MARKER_SIZE             8u                      /* Each marker has a size of 8 Bytes (fix value is used in Fee_Process.pm) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    35  #define FEE_MARKER_CS_SIZE          2u                      /* Size of CRC16 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    36  #define FEE_LL_DATABUFFSIZE         256u                    /* Size of the internal data buffer used for writing */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    37                                                              /* (The page buffer size is auto generated) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    38  #define FEE_LL_CRC_CALC_RESTRICTION FEE_LL_DATABUFFSIZE     /* Restriction for the Crc calculation */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    39  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    40  #define FEE_FREE_PAGES_FOR_ERASED_ST    1u                  /* Number of pages containing the erased value */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    41  #define FEE_SIZE_OF_BLOCK_CS            4                   /* Size of block checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    42  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    43  /* Special values for sector change counter within the RAM array */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    44  #define FEE_SEC_CHANGE_CNT_RESET_REQ  0xFFFFFFFFuL
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    45  #define FEE_SEC_CHANGE_CNT_UNDEF      FEE_SEC_CHANGE_CNT_RESET_REQ
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    46  #define FEE_SEC_CHANGE_CNT_ERASED     (FEE_SEC_CHANGE_CNT_RESET_REQ - 1u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    47  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    48  /* Mask for accessing block flags in the configuration and in the block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    49  #define FEE_FLAG_SEC_LEVEL_MSK      0x0001u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    50  #define FEE_FLAG_SEC_LEVEL_BP       0u       /* Security level setting is bit 0 within the block flags */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    51  #define FEE_BLK_INT_DOUBLE_STORAGE  1u       /* Internal double block storage definition */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    52  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    53  #define FEE_FLAG_DATAFILTERTYPE_ATTR_MSK      0x0006u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    54  #define FEE_FLAG_DATAFILTERTYPE_ATTR_BP       1u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    55  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    56  #define FEE_FLAG_INVALID_MSK        0x08u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    57  #define FEE_FLAG_INVALID_BP         3u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    58  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    59  #define FEE_FLAG_SURV_ATTR_MSK      0x0010u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    60  #define FEE_FLAG_SURV_ATTR_BP       4u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    61  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    62  #define FEE_FLAG_ROBUST_ATTR_MSK    0x0020
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    63  #define FEE_FLAG_ROBUST_ATTR_BP     5
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    64  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    65  #define FEE_FLAG_NOFALLBACK_MSK     0x0040u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    66  #define FEE_FLAG_NOFALLBACK_BP      6u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    67  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    68  #define FEE_MASK_BIT7               (uint8)0x80
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    69  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    70  /* Mask for accessing block flags (upper byte only) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    71  #define FEE_FLAG_JOBTYPE_MSK        0x0300u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    72  #define FEE_FLAG_JOBTYPE_BP         8u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    73  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    74  #define FEE_FLAG_JOBPRIO_MSK        0x0400u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    75  #define FEE_FLAG_JOBPRIO_BP         10u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    76  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    77  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    78  /* Macros for the conversion of the Sec Level settings:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    79   * Internal storage level:      Sec Level 1  --> 0 / Sec Level 2 --> 1
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    80   * User Config storage level:   Sec Level 1  --> 1 / Sec Level 2 --> 2 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    81  #define FEE_INT_TO_USER_STORAGE_TYPE(SEC_LEVEL) ((SEC_LEVEL) + 1u)   /* Convert the Sec Level setting from
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    82                                                                         header/properties == internal to user config format */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    83  #define FEE_CNT_FIRST_COPY          0u       /* Internal counter value for first copy */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    84  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    85  /* Erase actions */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    86  #define FEE_NO_SECTOR_TO_ERASE      0xFFu    /* No sector has to be erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    87  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    88  /* Block header validation */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    89  #define FEE_BLK_HEADER_PREAMBEL             0xA53C96uL                                  /* Pattern of preambel */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    90  #define FEE_BLK_HEADER_PREAMBEL_BYTE_2      (FEE_BLK_HEADER_PREAMBEL & 0xFFu)           /* 0x96 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    91  #define FEE_BLK_HEADER_PREAMBEL_BYTE_1      ((FEE_BLK_HEADER_PREAMBEL >> 8u) & 0xFFu)   /* 0x3C */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    92  #define FEE_BLK_HEADER_PREAMBEL_BYTE_0      ((FEE_BLK_HEADER_PREAMBEL >> 16u) & 0xFFu)  /* 0xA5 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    93  #define FEE_BLK_HEADER_SIZE                 14u                                         /* Size of block header in bytes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    94  #define FEE_BKL_HEADER_REDUCTION            FEE_VIRTUAL_PAGE_SIZE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    95  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    96  /* Calculation of free byte in current sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    97  #define FEE_LL_SECTOR_USED_FOR_WRITING      Fee_RdWrOrder_st.xWrAddress
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    98  #define FEE_LL_SECTOR_USED_FOR_READING      Fee_RdWrOrder_st.xRdAddress
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    99  #define FEE_LL_SECTOR_USED_FOR_COMPARING    Fee_RdWrOrder_st.xCmpAddress
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   100  #define FEE_LL_SECTOR_USED_FOR_CRC_CALC     Fee_RdWrOrder_st.xCrcAddress
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   101  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   102  /* Cache usage*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   103  #define FEE_INVLD_BLOCK_PROP_IDX        0xFFFFFFFFuL    /* Invalid Fee Idx that can be passed to the block header search function
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   104                                                             in order to ignore the cache during the init phase */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   105  #define FEE_USE_CACHED_ACCESS               0x01u       /* Use the cache method for finding the next block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   106  #define FEE_USE_MANUAL_ACCESS               0x00u       /* Search manually for headers */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   107  #define FEE_UPDATE_CACHE_IN_INIT            0x01u       /* Update the cache for fast access in init */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   108  #define FEE_NO_CACHE_UPDATE                 0x00u       /* Do not use the fast access method (only evaluated blocks are added to the cache) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   109  #define FEE_CACHE_UPD_NOT_COMP_FOR_SECT     0x00u       /* The respective sector was not completely checked */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   110  #define FEE_CACHE_UPD_COMP_FOR_SECT         0x01u       /* The respective sector was checked completely */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   111  #define FEE_CACHE_UPD_COMP_FOR_ALL_SECT     0x02u       /* All sectors have been checked completely */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   112  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   113  #define Fee_LLInvalidateAddressInCache(FEEIDX) Fee_LLUpdateAddressInCache(FEEIDX, FEE_CACHE_INIT_VALUE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   114  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   115  /* Fee init defines */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   116  #define FEE_PRV_ST_INIT_RUNNING             0x00u       /* Module is still uninitialized */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   117  #define FEE_PRV_ST_INIT_DONE                0x01u       /* Module has been initialized */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   118  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   119  /* Fee reorganization defines */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   120  #define FEE_PRV_ST_REORG_IDLE               0x00u       /* No reorganization is running */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   121  #define FEE_PRV_ST_REORG_STANDARD_RUNNING   0x01u       /* Standard reorganization is running */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   122  #define FEE_PRV_ST_REORG_AFTERB_RUNNING     0x02u       /* "Afterburner" of the reorganization is runnning */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   123  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   124  /* Amount of sectors used by the emulation  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   125  #define FEE_NUM_FLASH_BANKS         Fee_NumFlashBanksUsed_u8  /* Number of sectors which can be used by the Fee */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   126  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   127  #if (FEE_RB_ADDONS_CCAS == TRUE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   128  #define FEE_RB_REQUEST_STOP_MODE            TRUE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   129  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   130  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   131  #if(FEE_ROBUST_PROG_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   132  #define FEE_ROBMARKER_BUFF_SIZE             96u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   133  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   134  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   135  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)     /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   136  #define FEE_FIRSTDATAPAGE_NOTPROGRAMMED 0x00u            /* First data pages in Fee_LlFls2FlsCopy is not yet programmed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   137  #define FEE_FIRSTDATAPAGE_PROGRAMMED     0x01u            /* First data pages in Fee_LlFls2FlsCopy is programmed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   138  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   139  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   140  /*
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   141  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   142  * Type definitions
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   143  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   144  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   145  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   146  /* Order priority */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   147  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   148  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   149      FEE_NORMAL_PRIO_E = 0,      /* e.g. if FeeImmediateData is configured to no */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   150      FEE_HIGH_PRIO_E   = 1       /* e.g. if FeeImmediateData is configured to yes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   151  }Fee_HlPriority_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   152  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   153  /* This enumerator list contains the index inside the order queue.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   154   * Attention: The order in the enumerator is from Low (FEE_ADAPTER_JOB) to High (FEE_INTERNAL_JOB).
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   155   *            Do not change this order!
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   156   * */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   157  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   158  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   159      FEE_INTERNAL_JOB,           /* Internal job (reorganization or sector erase) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   160      FEE_NVM_JOB,                /* Nvm job */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   161      FEE_ADAPTER_JOB,            /* Adapter job (e.g. Mx17 Eep) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   162      FEE_QUEUE_SIZE              /* Size of the Fee internal queue (each job type has 1 entry) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   163  }Fee_HlJobType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   164  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   165  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   166  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   167      uint8*  DataBufferPtr_pu8;  /* Pointer to the read- or write-buffer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   168      uint16  FeeIdx_u16;         /* FeeRbBlockPersistentId */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   169      uint16  BlockPropIdx_u16;   /* Respective block properties table index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   170      uint16  Offset_u16;         /* Offset inside block (could be != 0 only for read-orders --> R4.0 Rev1) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   171      uint16  Length_u16;         /* Block length, only required for element-read-jobs */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   172      Fee_HlMode_ten Mode_en;     /* Type of this order: Read, Write, Invalidate */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   173      Fee_HlPriority_ten Prio_en; /* Priority out of the configuration */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   174      uint8   SecLevel_u8;        /* Security level out of the configuration */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   175  }Fee_OrderFifo_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   176  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   177  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   178  /* Hint:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   179   * For calculation of the sector order (old -> new -> erased -> undef) the sector change counter is a valid criteria.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   180   * The lowest valid value points to the eldest data, the most current value to the most current data.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   181   * These following defines are used for an implicit sorting:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   182   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   183   *  +------+------+------+------+------+------+------+------+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   184   *  |MarkerPattern|Ident | marker content     |marker CRC16 |
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   185   *  +------+------+------+------+------+------+------+------+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   186   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   187   *  Sector headers: 12 times available as default
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   188   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   189   *      +------+------+------+------+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   190   *    0 |Erased| Used | Full |Erase |
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   191   *      +------+------+------+------+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   192   *    4 |      |      |      |      |
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   193   *      +------+------+------+------+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   194   *    8 |      |      |      |      |
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   195   *      +------+------+------+------+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   196   *      |<---->|
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   197   *        Page
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   198   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   199   * Erased:  Sector was erased successfully. This marker also contains the sector erase counter
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   200   * Used:    Sector contains user data. This marker will be written first before data is written into a sector.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   201   *          This marker also contains the sector change counter.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   202   * Full:    Sector is completely full and must not be considered for searching for the first empty page.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   203   *          This marker also contains the sector change counter.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   204   * Erase:   Sector contains no valid data anymore and can be erased in the background task.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   205   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   206   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   207  enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   208  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   209      FEE_ERASED_MARKER_ID_E = 0x01u, /* Sector was erased successfully */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   210      FEE_USED_MARKER_ID_E,           /* Sector was used to store data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   211      FEE_FULL_MARKER_ID_E,           /* Sector is full */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   212      FEE_ERASE_REQUEST_ID_E,         /* Sector should be erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   213      FEE_START_MARKER_ID_E,            /* Double storage of USED marker, contains address of first blockheader */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   214      FEE_CLONE_START_MARKER_ID_E,    /* Marker to indicate that cloning of a defect sector has startet in this sector --> Ifx robust programming */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   215      FEE_RESERVED_MARKER_ID1_E,      /* Reserved range marker space in the sector header, currently not used! */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   216      FEE_RESERVED_MARKER_ID2_E,      /*    "       "     "      "   "    "      "         "      "    "   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   217      FEE_RESERVED_MARKER_ID3_E,      /*    "       "     "      "   "    "      "         "      "    "   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   218      FEE_RESERVED_MARKER_ID4_E,      /*    "       "     "      "   "    "      "         "      "    "   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   219      FEE_RESERVED_MARKER_ID5_E,      /*    "       "     "      "   "    "      "         "      "    "   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   220      FEE_RESERVED_MARKER_ID6_E,      /*    "       "     "      "   "    "      "         "      "    "   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   221      FEE_NUM_MARKER_E                /* Amount of required markers in the sector header + 1 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   222  };
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   223  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   224  /* Sector marker structure */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   225  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   226  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   227      uint16  xPattern;               /* Static marker pattern: 0xCAFE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   228      uint8   xIdent;                 /* Ident to identify the marker: 0x01 Erased-Marker, 0x02 Used-Marker, 0x03 Full-Marker, 0x04 Erase-Request */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   229      uint8   xContent[3];            /* Sector change counter */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   230      uint16  xChecksum;              /* Crc16 checksum, calculation over Patter, Ident and content */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   231  }Fee_MarkerProp_t;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   232  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   233  /* Sector detection type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   234  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   235  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   236      uint32  SecChngCnt_u32;         /* Sector change counter */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   237      uint8   ctErasedMarker_u8;      /* Number of found ERASED markers */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   238      uint8   ctUsedMarker_u8;        /* Number of found USED markers */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   239      uint8   ctFullMarker_u8;        /* Number of found FULL markers */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   240      uint8   ctEraseReq_u8;          /* Number of found ERASE requests */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   241      uint32  xStartAddr_u32;         /* Address of first blockheader in the sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   242      uint8   ctCloneMarker_u8;       /* Cloning of data has started (only Ifx robust programming algorithm */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   243  }Fee_stSecDet_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   244  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   245  /* Sector states */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   246  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   247  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   248      FEE_SECTOR_STATE_UNDEF_E        = 0,                      /* undefined sector-state --> no marker found */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   249      FEE_SECTOR_ERASED_E             = FEE_ERASED_MARKER_ID_E, /* sector was erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   250      FEE_SECTOR_USED_E               = FEE_USED_MARKER_ID_E,   /* sector was used to write data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   251      FEE_SECTOR_FULL_E               = FEE_FULL_MARKER_ID_E,   /* sector is full */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   252      FEE_SECTOR_REQUEST2ERASE_E      = FEE_ERASE_REQUEST_ID_E, /* sector could be erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   253      FEE_SECTOR_CONSIDERED_E         = FEE_NUM_MARKER_E        /* sector was considered in function Fee_LLDetectActiveSector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   254  }Fee_SectorState_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   255  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   256  /* Sector order after sort sequence */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   257  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   258  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   259      uint32 SecChngCnt_u32;                  /* Sector change counter */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   260      Fee_SectorState_ten SecState_en;        /* Sector state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   261      uint8 xPhySecIdx_u8;                    /* Sector index (physical sector) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   262  }Fee_LLSectorOrder_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   263  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   264  /* Fee internal return types */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   265  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   266  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   267      FEE_ORDER_PENDING_E,            /* The order is still pending*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   268      FEE_ORDER_FINISHED_E,           /* The order was finished without error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   269      FEE_BLOCK_INVALIDATED_E,        /* The block was invalidated in the block status */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   270      FEE_ERROR_E,                    /* An error occured, maybe data in flash was not valid */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   271      FEE_SECTORCHANGE_E,             /* A sector change has to be done */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   272      FEE_SECTORFULL_E,               /* The sector is full */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   273      FEE_ABORTED_E,                  /* An order was aborted*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   274      FEE_ERASE_SECTOR_E,             /* The sector must be erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   275      FEE_SEARCH_ABORTED_E,           /* Searching was aborted */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   276      FEE_NUM_RET_VAL_E               /* Number of return values */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   277  }Fee_stRetVal_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   278  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   279  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   280  /* Flash properties */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   281  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   282  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   283      uint32  Fee_PhysStartAddress_u32;       /* Physical sector: start address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   284      uint32  Fee_PhysEndAddress_u32;         /* physical sector: end address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   285      uint32  Fee_LogStartAddress_u32;        /* logical sector: start address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   286      uint32  Fee_LogEndAddress_u32;          /* logical sector: end address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   287  }Fee_FlashProp_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   288  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   289  /* Block properties for all Fee blocks
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   290   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   291   * Status Flags:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   292   * Block flags will help to specify a more detailed block configuration. The low Byte of these block flags is also stored
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   293   * in the flash (status byte inside the block header). This information (in Flash) can be used to read/write the layout
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   294   * without configuration (PAV, CB).
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   295   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   296   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   297   *                                                 |<----- Block Status Byte in Block Header ----->|
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   298   * |<---------------------------------------- Block Flags ---------------------------------------->|
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   299   *    F     E     D     C     B     A     9     8  |  7     6     5     4     3     2     1     0  |
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   300   * +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   301   * |     |     |     |     |     |Prio-| Job type  |     |     | Rob |Surv.|(Inv)| DataFilter| Sec-|
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   302   * |     |     |     |     |     |rity |           |     |     |Attr.|Attr.|     |    Type   | lvl |
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   303   * +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   304   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   305   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   306   *  0  ... SecurityLevel      => 0...SingleStorage, 1...DoubleStorage
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   307   * 1+2 ... Data Filter Type   => 0...Dynamic:         Anybody can erase this block (e.g. during migration)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   308   *                               1...Static:          Only certain users (e.g. repair shops) can erase this block
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   309   *                               2...Permanent:       Only very certain users (e.g. OEM) can erase this block
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   310   *                               3...Super Permanent: Block can never be erased
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   311   *  3 .... Invalid            => 0...Block OK, 1...Block is invalid  --> can be changed by function Fee_InvalidateBlock
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   312   *  4 .... Survival Attribute => 0...No survival, 1... Survival (even without being part of the layout)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   313   *  5 .... Robustness Attribute (Robustness against data modification during write execution)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   314   *                            => 0...Deactivated:     No additional checksum is used
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   315   *                            => 1...Activated:       Additional checksum is used
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   316   * 8+9 ... TypeOfBlock        => 0...InternalJob, 1...NvmJob, 2...AdapterJob (e.g. Mx17 Eep adapter)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   317   *  A .... Priority           => Job priority:        0...FEE_NORMAL_PRIO_E --> FeeImmediateData = No
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   318   *                                                    1...FEE_HIGH_PRIO_E   --> FeeImmediateData = Yes
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   319   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   320  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   321  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   322      uint16 BlockPersistentId_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   323      uint16 Flags_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   324      uint16 Length_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   325      void (* const JobEndNotification_pfn) (void);      /* callback function, will be called if a job was successfully finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   326      void (* const JobErrorNotification_pfn) (void);    /* callback function, will be called if a job was finished with an error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   327  }Fee_BlockPropertiesType_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   328  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   329  /* Job types corresponding to the queue index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   330  enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   331  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   332      FEE_JOB_TYPE_INTERNAL_E = 0,            /* Internal job index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   333      FEE_JOB_TYPE_NVM_E      = 1,            /* NvM job index  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   334      FEE_JOB_TYPE_ADAPTER_E  = 2             /* Adapter job index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   335  };
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   336  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   337  /* State machine types for the function Fee_LLWriteMarker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   338  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   339  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   340      FEE_LL_MARKER_INIT_E,                   /* Init state                                    */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   341      FEE_LL_MARKER_BLK_CHK_E,                /* Perform a blank check over one page           */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   342      FEE_LL_MARKER_BLK_CHK_WAIT_E,           /* Wait for the blank check order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   343      FEE_LL_MARKER_BLK_CHK_ERROR_E,          /* Differences detected                          */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   344      FEE_LL_MARKER_BLK_CHK_FINISHED_E,       /* Start write order of the marker               */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   345      FEE_LL_MARKER_WRITE_WAIT_E,             /* Wait for the write order to be finished       */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   346      FEE_LL_MARKER_WRITE_ERROR_E,            /* Read or write error                           */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   347      FEE_LL_MARKER_VERIFY_E,                 /* Verify written marker                         */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   348      FEE_LL_MARKER_VERIFY_WAIT_E,            /* Wait for verify marker                        */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   349      FEE_LL_MARKER_VERIFY_FINISHED_E         /* Verify marker finished                        */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   350  }Fee_LLWrMarkerType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   351  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   352  /* State machine types for the function Fee_HLWriteBlock and Fee_HLReadBlock */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   353  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   354  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   355      FEE_HL_RDWR_BLK_INIT_E,                 /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   356      FEE_HL_SEARCH_BLK_HDR_E,                /* Search block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   357      FEE_HL_READ_BLK_HDR_WAIT_E,                  /* Read block header for redundant blocks */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   358      FEE_HL_CHECK_BLK_HDR_E,                 /* Check block header for redundant blocks */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   359      FEE_HL_CALC_BLK_CS_E,                   /* Calculate the user checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   360      FEE_HL_CHECK_BLK_CS_E,                  /* Verify the block checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   361      FEE_HL_RD_DATA_FROM_BLK_E,              /* Read the block data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   362      FEE_HL_COMP_BLK_E,                      /* Compare the complete block data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   363  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   364      /* Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   365      #if (defined(RBA_FLSIFX_FLASH) || defined(RBA_FLSJDP_FLASH))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   366      FEE_HL_RD_WAIT_FOR_FLS_E,               /* Wait for the Fls to overstamp an invalid header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   367      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   368      /* END Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   369  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   370      FEE_HL_WR_BLK_E                         /* Write the block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   371  }Fee_HLRdWrBlockType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   372  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   373  /* State machine types for the function Fee_LLWriteBlock */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   374  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   375  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   376      FEE_LL_WR_BLK_INIT_E,                   /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   377      FEE_LL_WR_WRITEHEADER_E,                /* Write the header (and first data bytes) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   378      FEE_LL_WR_SIZECHECK_HSR_E,              /* check for space until HSR */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   379      #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   380      FEE_LL_WR_BLANKCHECK_NOFB_WR_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   381      FEE_LL_WR_BLANKCHECK_NOFB_WR_WAIT_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   382      FEE_LL_WR_WRITE_NOFB_MARKER_E,          /* Write the NoFallback marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   383      FEE_LL_WR_WRITE_NOFB_MARKER_WAIT_E,     /* Wait until the programming of the NoFallback marker is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   384      FEE_LL_WR_FILL_SECTOR_END_E,            /* Changes the active sector and fills the empty pages if necessary */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   385      FEE_LL_WR_FILL_SECTOR_END_WAIT_E,       /* Wait until the write order to fill the empty pages is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   386      FEE_LL_WR_FILL_SECTOR_END_ERROR_E,      /* Errors during write occured */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   387      FEE_LL_WR_WRITE_NOFB_MARKER_ERROR_E,    /* Errors during write occured */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   388      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   389      FEE_LL_WR_WRITEHEADER_WAIT_E,           /* Wait until the write order is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   390      FEE_LL_WR_VERIFYHEADER_E,               /* Verify the header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   391      FEE_LL_WR_VERIFYHEADER_WAIT_E,          /* Wait for the verification to end */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   392      FEE_LL_WR_VERIFYHEADER_ERROR_E,         /* Verify error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   393      FEE_LL_WR_WRITEDATA_SEC_A_E,            /* Write the data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   394      FEE_LL_WR_WAIT_WRITEDATA_SEC_A_E,       /* Wait until the write order is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   395      FEE_LL_WR_WRITE_ERROR_E,                /* Error during write (header or data page writes) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   396  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   397      FEE_LL_WR_WRITE_FULL_MARKER_E,          /* Write the FULL marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   398      FEE_LL_WR_ERASE_SECTOR_E,               /* Erase a sector and write the ERASED marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   399      FEE_LL_WR_WRITE_USED_MARKER_E,          /* Write the USED marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   400      FEE_LL_WR_WRITE_START_MARKER_E,         /* Write the START marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   401  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   402      /* Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   403      #if (defined(RBA_FLSIFX_FLASH) || defined(RBA_FLSJDP_FLASH))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   404      FEE_LL_WR_WAIT_FOR_FLS_OVERPROGRAMMING_E,   /* Wait for the Fls to overstamp an invalid header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   405      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   406      /* END Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   407  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   408      #if(FEE_ROBUST_PROG_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   409      FEE_LL_WR_WRITEDATA_IFX_HANDLING_E,     /* robust Ifx handling in case of wordline fails */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   410      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   411      FEE_LL_WR_VERIFY_BLK_E                  /* Verify the complete data including the block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   412  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   413      /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   414      #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   415      ,FEE_LL_WR_WRITEHDRPG2_E,                /* Write the 2nd header page. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   416      FEE_LL_WR_WAIT_WRITEHDRPG2_E            /* Wait until 2nd header page write is completed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   417      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   418  }Fee_LLWrBlockType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   419  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   420  /* State machine types for the function Fee_LLCompBlkInFlash */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   421  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   422  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   423      FEE_LL_CMP_BLK_INIT_E,                  /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   424      FEE_LL_CMP_HEADER_E,                    /* Compare the complete block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   425      FEE_LL_CMP_WAIT_HEADER_E,               /* Wait for the compare to finish */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   426      FEE_LL_CMP_CHECK_OVERLAP_E,             /* Check for an overlap */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   427      FEE_LL_CMP_DATA_SEC_A_E,                /* Check the header compare result and compare the data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   428      FEE_LL_CMP_WAIT_DATA_SEC_A_E,           /* Wait for the compare to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   429      FEE_LL_CMP_FINISHED_E                   /* Verify the data compare result and reset the state machine */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   430  }Fee_LLCmpBlkType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   431  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   432  /* State machine types for the function Fee_LLCopyData2Buffer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   433  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   434  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   435      FEE_LL_CPY_BLK_INIT_E,                  /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   436      FEE_LL_CPY_BLOCK_START_E,               /* Read out the data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   437      FEE_LL_CPY_BLOCK_WAIT_E,                /* Wait for the read order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   438      FEE_LL_CPY_BLOCK_ERROR_E,               /* Error in the read function */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   439      FEE_LL_CPY_BLOCK_FINISHED_E             /* Finish the function or the data transfer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   440  }Fee_LLCpyBlkType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   441  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   442  /* State machine types for the function Fee_LLCalcBlkCrcInFlash */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   443  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   444  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   445      FEE_LL_CRC_BLK_INIT_E,                  /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   446      FEE_LL_CRC_RD_HD_PAGE_E,                /* Read the header page */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   447      FEE_LL_CRC_RD_PAGE_E,                   /* Calculate the block checksums */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   448      FEE_LL_CRC_CHECK_OVERLAP_E,             /* Check for an overlap */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   449      #if(FEE_ROB_FEATURE_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   450      FEE_LL_CRC_RD_ROB_PAGE_E,               /* Retry with the robustness checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   451      FEE_LL_CRC_CHECK_OVERLAP_ROB_E,         /* Check for an overlap */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   452      FEE_LL_CRC_RD_ROB_PAGE_WAIT_E,          /* Wait until the read access is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   453      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   454      FEE_LL_CRC_RD_PAGE_WAIT_E,              /* Wait until the read access is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   455      FEE_LL_CRC_RD_ERROR_E                   /* Read error case */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   456  }Fee_LLCalcCrcBlkType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   457  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   458  /* State machine types for reading */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   459  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   460  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   461      FEE_LL_INIT_READ_E                      /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   462      ,FEE_LL_BLANK_CHECK_E                    /* Perform a blank check */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   463      ,FEE_LL_BLANK_CHECK_WAIT_E                /* Wait for the blank check to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   464      ,FEE_LL_READ_PAGE_E                     /* Read pages */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   465      ,FEE_LL_WAIT_READ_PAGE_E                /* Wait for the read order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   466      ,FEE_LL_READ_ERROR_E                    /* Error reaction for read error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   467      ,FEE_LL_READ_FINISHED_E                 /* Finish state machine */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   468      #if (FEE_HEADER_RECHECK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   469      #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   470      ,FEE_LL_NOFALLBACK_MARKER_CHECK_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   471      ,FEE_LL_NOFALLBACK_MARKER_CHECK_WAIT_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   472      ,FEE_LL_NOFALLBACK_MARKER_CHECK_FAILED_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   473      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   474      ,FEE_LL_RECHECK_HEADER_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   475      ,FEE_LL_RECHECK_HEADER_WAIT_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   476      ,FEE_LL_RECHECK_HEADER_FAILED_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   477      ,FEE_LL_RECHECK_HEADER_FINISHED_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   478      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   479  } Fee_LLRdStateType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   480  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   481  /* States for function Fee_LLCheckErasePattern */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   482  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   483  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   484      FEE_LL_INIT_BLANK_CHECK_E,              /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   485      FEE_LL_PERFORM_BLANK_CHECK_E,           /* Perform a blank check */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   486      FEE_LL_WAIT_PERFORM_BLANK_CHECK_E,      /* Wait for the blank check order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   487      FEE_LL_BLANK_CHECK_ERROR_E,             /* Differences detected */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   488      FEE_LL_BLANK_CHECK_FINISHED_E           /* Finish state machine with success */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   489  } Fee_LLBlankCheckType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   490  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   491  /* State of function Fee_Prv_LLFindEmptyPage */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   492  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   493  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   494      #if ( defined(RBA_FLSRH850P1xC_FLASH) || defined(RBA_FLSV850R1x_FLASH) || defined(RBA_FLSRH850xx_FLASH) )
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   495      FEE_LL_FINDEMPTYPGE_INIT_E,             /* Initalize find empty page state machine  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   496      FEE_LL_FINDEMPTYPGE_CHECK_E,            /* Begin a blank check                      */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   497      FEE_LL_FINDEMPTYPGE_WAIT_E,             /* Wait until the blank check finished      */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   498      FEE_LL_FINDEMPTYPGE_RESULT_BLANK_E,     /* Checked chunk was completely blank       */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   499      FEE_LL_FINDEMPTYPGE_RESULT_NOT_BLANK_E  /* Checked chunk was not completely blank   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   500      #else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   501      FEE_LL_FIND_CURRENT_SECTOR_E,           /* Evaluate the sector with most current values */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   502      FEE_LL_FIND_LAST_HEADER_E,              /* Search the last block header in the active sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   503      FEE_LL_FINISHED_E                       /* Function finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   504      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   505  }Fee_LLFndEmptyPgeType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   506  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   507  /* State of the function Fee_LLSearchSpecifiedBlkHeader */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   508  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   509  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   510      FEE_LL_SEARCHBLK_INIT_E,                /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   511      FEE_LL_SEARCHBLK_BLK_HEADER_E           /* Search for the next block header*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   512  }Fee_LLSearchBlkHdrType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   513  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   514  #if(FEE_FAST_CACHE_INIT_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   515  /* State of the function Fee_BuildUpCache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   516  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   517  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   518      FEE_LL_BLD_UP_CACHE_INIT_E,             /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   519      FEE_LL_BLD_UP_CACHE_READ_E              /* Read out data directly if possible */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   520  }Fee_LLBuildUpCache_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   521  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   522  /* State of the function Fee_BuildUpCacheForAllSect */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   523  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   524  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   525      FEE_LL_BLD_UP_CACHE_ALL_SECT_INIT_E,/* Init case */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   526      FEE_LL_BLD_UP_CACHE_ALL_SECT_DO_E   /* Build up the cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   527  }Fee_LLBuildUpCacheAllSect_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   528  /* FEE_FAST_CACHE_INIT_ACTIVE != FALSE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   529  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   530  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   531  #if((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   532  #if (FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE == 0)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   533  /* Unknown blcok sector reorganiation without cache: State of the function Fee_LLSearchUnknBlkHeader */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   534  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   535  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   536      FEE_LL_SEARCHUNKNBLK_INIT_E,            /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   537      FEE_LL_SEARCHUNKNBLK_UNKN_BLK_HEADER_E, /* Search the next unknown block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   538      FEE_LL_SEARCHUNKNBLK_SPEC_BLK_HEADER_E  /* Search the next specific block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   539  }Fee_LLSearchUnknBlkHdrType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   540  #else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   541  /* Unknown block sector reorganiation with cache: states of cache build up function Fee_BuildUpCacheUnknownBlk */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   542  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   543  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   544      FEE_LL_BLD_UP_CACHE_UNKOWN_BLK_INIT_E,             /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   545      FEE_LL_BLD_UP_CACHE_UNKOWN_BLK_READ_E,             /* Read out data directly if possible */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   546      FEE_LL_BLD_UP_CACHE_UNKOWN_BLK_VALIDATEDATA_E      /* Validate the data CRC of the uknown block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   547  }Fee_LLBuildUpUnknownBlkCache_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   548  #endif /* End of (FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE == 0) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   549  #endif /* End of ((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE)) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   550  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   551  /* States for the function Fee_LLSectorReorganization */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   552  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   553  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   554      FEE_LL_REORG_INIT_E,                    /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   555      FEE_LL_REORG_PREP_SEARCH_BLK_E,         /* Prepare the next block search */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   556      FEE_LL_REORG_SEARCH_BLK_E,              /* Search for a specific block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   557      FEE_LL_REORG_CHECK_BLOCK_CS_E,          /* Evaluate the block checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   558      FEE_LL_REORG_REDUNDANT_BLK_CHK_E,       /* Check if redundant copy is not lost during sector reorg. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   559      FEE_LL_REORG_WRITE_BLOCK_E,             /* Write a block into the latest sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   560  #if((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   561      FEE_LL_REORG_SEARCH_UNK_BLK_E,          /* Search for an unknown block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   562   #if(FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE != 0) /* Unknown blcok sector reorganiation with cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   563      FEE_LL_REORG_CACHEBUILDUP_UNK_BLK_E,    /* Building of cache for unknown block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   564      FEE_LL_REORG_SEARCH_UNK_HDRBLK_WAIT_E,            /* Wait till reading of unknown block header is finished. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   565      FEE_LL_REORG_SEARCH_UNK_HDRBLK_READ_ERROR_E,    /* Failure during read of unknown block header. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   566      FEE_LL_REORG_SEARCH_UNK_HDRBLK_READ_FINISHED_E,    /* Unknown block header read successful. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   567   #endif /* End of (FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE != 0) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   568  #endif /* End of ((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE)) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   569  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   570      /* Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   571      #if (defined(RBA_FLSIFX_FLASH) || defined(RBA_FLSJDP_FLASH))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   572      FEE_LL_REORG_WAIT_FOR_FLS_E,            /* Wait for the Fls to overstamp an invalid header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   573      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   574      /* END Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   575  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   576      FEE_LL_REORG_FINISHED_E                 /* Function finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   577  }Fee_LLSecReorgType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   578  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   579  /* States for the function Fee_LLRedundantCpyChk */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   580  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   581  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   582      FEE_LL_REDUNDANT_CPY_CHK_INIT_E,            /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   583      FEE_LL_REDUNDANT_CPY_CHK_SEARCH_HDR_E,      /* Search header of redundant copy */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   584      FEE_LL_REDUNDANT_CPY_CHK_BLK_CS_E           /* Validate data CRC of redundant copy */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   585  }Fee_LLRedundantCpyChk_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   586  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   587  /* States for the function Fee_LLCpyBlkFromFls2Fls */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   588  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   589  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   590      FEE_LL_CPY_FLS2FLS_INIT_E,                      /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   591  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   592      #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   593      FEE_LL_CPY_FLS2FLS_WRITE_NOFB_MARKER_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   594      FEE_LL_CPY_FLS2FLS_WAIT_WRITE_NOFB_MARKER_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   595      FEE_LL_CPY_FLS2FLS_WRITE_NOFB_MARKER_ERROR_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   596      FEE_LL_CPY_FLS2FLS_WAIT_FILL_SECTOR_END_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   597      FEE_LL_CPY_FLS2FLS_FILL_SECTOR_END_ERROR_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   598      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   599  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   600      FEE_LL_CPY_FLS2FLS_READ_E,                      /* Read out the complete block (header and data) and finish the function if possible */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   601      FEE_LL_CPY_FLS2FLS_WAIT_READ_E,                 /* Wait for the read order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   602      FEE_LL_CPY_FLS2FLS_READ_ERROR_E,                /* Read error state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   603  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   604      /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   605      #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   606      FEE_LL_CPY_FLS2FLS_HDRPG1_WRITE_E,              /* Write the header page 1 into the new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   607      FEE_LL_CPY_FLS2FLS_WAIT_HDRPG1_WRITE_E,         /* Wait for the header page 1 write order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   608      FEE_LL_CPY_FLS2FLS_HDRPG1_WRITE_ERROR_E,        /* Write error state for header page 1 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   609      FEE_LL_CPY_FLS2FLS_HDRPG1_VERIFY_E,             /* Compare the header page 1 write */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   610      FEE_LL_CPY_FLS2FLS_WAIT_HDRPG1_VERIFY_E,        /* Wait for the header page 1 verification to finish */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   611      FEE_LL_CPY_FLS2FLS_HDRPG1_VERIFY_ERROR_E,       /* Verification error for header page 1 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   612      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   613  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   614      FEE_LL_CPY_FLS2FLS_WRITE_E,                     /* Write the data into the new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   615      FEE_LL_CPY_FLS2FLS_WAIT_WRITE_E,                /* Wait for the write order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   616      FEE_LL_CPY_FLS2FLS_WRITE_ERROR_E,               /* Write error state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   617      FEE_LL_CPY_FLS2FLS_VERIFY_E,                    /* Compare the programmed data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   618      FEE_LL_CPY_FLS2FLS_WAIT_VERIFY_E,               /* Wait for the verification to finish */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   619      FEE_LL_CPY_FLS2FLS_VERIFY_ERROR_E,              /* Verification error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   620  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   621      /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   622      #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   623      FEE_LL_CPY_FLS2FLS_HDRPG2_WRITE_E,              /* Write the header page 2 into the new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   624      FEE_LL_CPY_FLS2FLS_WAIT_HDRPG2_WRITE_E,         /* Wait for the header page 2 write order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   625      FEE_LL_CPY_FLS2FLS_HDRPG2_WRITE_ERROR_E,        /* Write error state for header page 2 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   626      FEE_LL_CPY_FLS2FLS_HDRPG2_VERIFY_E,             /* Compare the header page 2 write */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   627      FEE_LL_CPY_FLS2FLS_WAIT_HDRPG2_VERIFY_E,        /* Wait for the header page 2 verification to finish */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   628      FEE_LL_CPY_FLS2FLS_HDRPG2_VERIFY_ERROR_E,       /* Verification error for header page 2 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   629      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   630  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   631      FEE_LL_CPY_FLS2FLS_CHECK_ADR_OVERFLOW_E,        /* Data transfer is finished, check a possible address overflow */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   632      FEE_LL_CPY_FLS2FLS_WRITE_FULL_MARKER_E,         /* Write the FULL marker to the "old" sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   633      FEE_LL_CPY_FLS2FLS_ERASE_SECTOR_E,              /* Erase the sector that will be used as a new USED sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   634      FEE_LL_CPY_FLS2FLS_WRITE_USED_MARKER_E,         /* Write the USED marker to new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   635  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   636      #if(FEE_ROBUST_PROG_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   637      FEE_LL_CPY_FLS2FLS_ROBUST_IFX_HANDLING_E,       /* robust Ifx handling in case of wordline fails */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   638      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   639  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   640      #if defined (FEE_PRV_ROBUST_SECT_OVERFLOW)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   641      FEE_LL_CPY_FLS2FLS_ROBUST_SECT_OVERFLOW_E,      /* Robust sector reorganisation when sector overflow occurs during sector reorg. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   642      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   643  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   644      FEE_LL_CPY_FLS2FLS_WRITE_START_MARKER_E         /* Write the START marker to the new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   645  }Fee_LLCpyBlkFls2Fls_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   646  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   647  /* States for the function Fee_LlRobustSectorOverflow */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   648  #if defined (FEE_PRV_ROBUST_SECT_OVERFLOW)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   649  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   650  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   651      FEE_LL_ROBUST_SECTOR_OVERFLOW_INIT_E,           /* Init state. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   652      FEE_LL_ROBUST_SECTOR_OVERFLOW_WR_CM_E,          /* Write Clone marker in the latest sector. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   653      FEE_LL_ROBUST_SECTOR_OVERFLOW_PREPARE_E,        /* Compute the address and number of bytes for the operation. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   654  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   655      #if ( defined(RBA_FLSRH850P1xC_FLASH) || defined(RBA_FLSV850R1x_FLASH) || defined(RBA_FLSRH850xx_FLASH) )
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   656      FEE_LL_ROBUST_SECTOR_OVERFLOW_BLANK_CHK_E,      /* Check if the page is blank, transfer only programmed pages. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   657      FEE_LL_ROBUST_SECTOR_OVERFLOW_BLANK_CHK_WAIT_E, /* Wait for Blank check operation to complete. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   658      #endif /* #if ( defined(RBA_FLSRH850P1xC_FLASH) || defined(RBA_FLSV850R1x_FLASH) || defined(RBA_FLSRH850xx_FLASH) ) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   659  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   660      FEE_LL_ROBUST_SECTOR_OVERFLOW_READ_PAGE_E,      /* Read out the programmed page in an internal buffer. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   661      FEE_LL_ROBUST_SECTOR_OVERFLOW_READ_PAGE_WAIT_E, /* Wait for Read operation to complete. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   662      FEE_LL_ROBUST_SECTOR_OVERFLOW_COPY_DATA_E,      /* Copy data to new sector. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   663      FEE_LL_ROBUST_SECTOR_OVERFLOW_COPY_DATA_WAIT_E, /* Wait for Write operation to complete. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   664      FEE_LL_ROBUST_SECTOR_OVERFLOW_VERIFY_DATA_E,    /* Verify the copied data. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   665      FEE_LL_ROBUST_SECTOR_OVERFLOW_VERIFY_DATA_WAIT_E,/* Wait for Verify operation to complete. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   666      FEE_LL_ROBUST_SECTOR_OVERFLOW_VERIFY_SUCCESS_E, /* Check if more bytes are left to be programmed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   667      FEE_LL_ROBUST_SECTOR_OVERFLOW_WR_UM_E,          /* Write Used marker in the latest sector. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   668      FEE_LL_ROBUST_SECTOR_OVERFLOW_SORT_SECT_E,      /* Sort sectors */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   669      FEE_LL_ROBUST_SECTOR_OVERFLOW_ERROR_E,          /* Error state for all kinds of error in this state machine. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   670      FEE_LL_ROBUST_SECTOR_OVERFLOW_ERASE_E           /* Re-erase the older sector, this state is reached for error handling. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   671  }Fee_LLRobustSectOverflow_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   672  #endif /* #if defined (FEE_PRV_ROBUST_SECT_OVERFLOW) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   673  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   674  /* Read / write order type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   675  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   676  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   677      uint32                              xRdAddress;                     /* Address for reading (Fee_LLReadBlock) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   678      uint32                              xWrAddress;                     /* Address for writing (Fee_LLWriteBlock) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   679      uint32                              xCmpAddress;                    /* Address for comparing (Fee_LLCompBlkInFlash) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   680      uint32                              xCrcAddress;                    /* Address for the CRC (Fee_LLCompBlkInFlash) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   681      uint32                              xCpyAddress;                    /* Address for copying (Fee_LLCompBlkInFlash) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   682      uint32                              AdrHdSearchStart_u32;           /* Start address for the header search after reloads */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   683      uint32                              xStartAddrNextSector_u32;        /* Payload of START-Marker, contains the expected address of the 1. blockheader */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   684  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   685  /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   686  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   687      uint32                              xHdPg2Address;                   /* Address for writing the header 2nd page. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   688  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   689  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   690  #if !( defined(RBA_FLSRH850P1xC_FLASH) || defined(RBA_FLSV850R1x_FLASH) || defined(RBA_FLSRH850xx_FLASH) )
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   691      uint32                              LastProgrammedAddress_u32;        /* Last programmed page during cache build up. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   692      uint32                              LastValidHdrAddress_u32;          /* Last valid header found during cache build up. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   693  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   694  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   695      Fee_LLSecReorgType_ten              Fee_LLSecReorg_en;                /* State machine for the sector reorganization */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   696      Fee_LLRedundantCpyChk_ten           Fee_LLRedundantCpyChk_en;         /* State machine for checking redundant copy */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   697      Fee_LLCpyBlkFls2Fls_ten             Fee_LLCpyBlkFls2Fls_en;           /* State machine for copying one block from one sector to another one */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   698  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   699  #if defined (FEE_PRV_ROBUST_SECT_OVERFLOW)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   700      Fee_LLRobustSectOverflow_ten        Fee_LLRobustSectOverflow_en;      /* LL state machine for Robust sector overflow */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   701  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   702  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   703      Fee_HLRdWrBlockType_ten             Fee_HLWrBlock_en;                  /* HL state machine for writing a block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   704  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   705  #if(FEE_RB_MAINTAIN != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   706      Fee_HLRdWrBlockType_ten             Fee_HLMtBlock_en;                  /* HL state machine for maintaining a block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   707   #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   708  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   709      Fee_LLWrBlockType_ten               Fee_LLWrBlock_en;                  /* LL State machine for writing a block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   710      Fee_HLRdWrBlockType_ten             Fee_HLRdBlock;                     /* state machine for reading a block High Level */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   711      Fee_LLWrBlockType_ten               Fee_LLNextUsedWrBlock_en;          /* LL state for saving the next write state if a USED marker is necessary in between */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   712      Fee_LLWrBlockType_ten               Fee_LLNextEraseWrBlock_en;         /* LL state for saving the next write state if an erase operation is necessary in between */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   713      Fee_LLCmpBlkType_ten                Fee_LLCompBlk;                     /* LL state machine for comparing data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   714      Fee_LLCpyBlkType_ten                Fee_LLCopyBlk_en;                  /* LL state machine for copying data from the flash to the user buffer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   715      Fee_LLCalcCrcBlkType_ten            Fee_LLCalcCrcBlk_en;               /* LL state machine for calculating the checksum of a block inside the flash */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   716      Fee_LLWrMarkerType_ten              Fee_LLWrMarker_en;                 /* LL state machine for writing a sector marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   717      Fee_LLRdStateType_ten               Fee_LLRdState_en;                  /* LL state machine to read a specified address in the sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   718      Fee_LLBlankCheckType_ten            Fee_LLBlankCheckState_en;          /* LL State machine to perform a blank check */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   719      Fee_LLFndEmptyPgeType_ten           Fee_LLFindEmptyPageState_en;       /* LL state machine to find an empty page within one sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   720      Fee_LLSearchBlkHdrType_ten          Fee_LLSearchBlkHdr_en;             /* LL state machine to find a specified block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   721  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   722  #if((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   723   #if(FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE == 0) /* Unknown block sector reorganiation without cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   724      Fee_LLSearchUnknBlkHdrType_ten      Fee_LLSearchUnknBlkHdr_en;          /* LL state machine to find an unknown block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   725   #else /* Unknown blcok sector reorganiation with cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   726      uint32                              Fee_UnknownBlkCacheAdd_u32;         /* Address till where the cache for unknown block is scanned */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   727      uint16                              Fee_UnknownBlkCacheIdx_u16;         /* Index till which the cache for unknown block is built */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   728      Fee_LLBuildUpUnknownBlkCache_ten    Fee_LLBuildUpCacheUnknownBlk_en;    /* LL state machine to build up the cache for unknown blocks */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   729   #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   730  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   731  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   732  #if(FEE_FAST_CACHE_INIT_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   733      Fee_LLBuildUpCache_ten              Fee_LLBuildUpCache_en;              /* LL state machine to build up the cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   734      Fee_LLBuildUpCacheAllSect_ten       Fee_LLBuildUpCacheAllSect_en;       /* LL state machine to build up the cache for all sectors */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   735  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   736  } Fee_RdWrOrder_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   737  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   738  /* Block header info type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   739  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   740  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   741      uint32 AdrBlkHeader_u32;    /* Read address for for the function Fee_LLReadBlock and Fee_LLCpyBlkFromFls2Fls */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   742      uint32 BlkCrc32_u32;        /* Block data checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   743      uint16 HdrCrc16_u16;        /* Block header checksum (start value for block data checksum) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   744      uint16 BlkLength_u16;       /* Extracted block length from the block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   745      uint16 FeeIndex_u16;        /* Fee Index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   746      uint8  BlkStatus_u8;        /* Block status */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   747  }Fee_GlobInfoLastRdHeader_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   748  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   749  /* Block write type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   750  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   751  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   752      uint16  BytesAlrdyConsid_u16;   /* Write offset in user data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   753      uint16  BytesAlrdyCompared_u16;    /* Number of bytes already compared */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   754      uint16  Bytes2Read_u16;          /* Number of bytes to read */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   755      uint8   CompareResult_u8;       /* Result of last Fls_Compare */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   756      uint8   cntWriteRetry_u8;       /* Count number of write retries */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   757      uint8   cntCopies_u8;           /* Count number of written copies */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   758  }Fee_GlobInfoWrBlock_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   759  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   760  /* Sector reorganization type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   761  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   762  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   763      uint32 xRdAddress_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   764      uint16 xNumBytesAlrdyCopied_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   765      uint16 xNumBytesLeftToRdWr_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   766      uint8  xCntCopies_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   767  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)    /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   768      uint8  xFirstDataPgPgm_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   769  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   770  }Fee_LLSecReorgStruct_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   771  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   772  /* Erase sector types */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   773  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   774  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   775      FEE_ERASESEC_IDLE_E = 0,        /* Idle state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   776      FEE_ERASESEC_CHECK_CACHE_E,     /* Check of cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   777      FEE_ERASESEC_START_E,           /* Erase sequence started */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   778      FEE_ERASESEC_DO_E,              /* Wait until erasing was finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   779      FEE_ERASESEC_WRITE_MARKER_E,    /* Write the sector ERASED marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   780      FEE_ERASESEC_ERROR_E            /* Error state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   781  }Fee_LLEraseStateType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   782  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   783  /* Erase Order type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   784  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   785  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   786      Fee_LLEraseStateType_ten EraseState_en; /* State machine state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   787      uint8   xPhySectorIdx_u8;               /* Idx of sector that should get erased  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   788  }Fee_LLEraseOrderType_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   789  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   790  /* Block header structure */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   791  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   792  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   793      uint8   Preamble_au8[3];    /* Preambel (0xA53C96) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   794      uint8   BlkStatus_u8;       /* Block status, contains information like security level, etc. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   795      uint16  FeeIndex_u16;       /* FeeIndex */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   796      uint16  BlkLength_u16;      /* Block length without header and block checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   797      uint16  HdrCrc16_u16;       /* Header checksum, start value is 0xCAFE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   798      uint32  BlkCrc32_u32;       /* Block data checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   799  }Fee_BlkHeader_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   800  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   801  /* Linked function structure */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   802  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   803  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   804      void(* Fee_ResetUsedSectors_pfn)(void);     /* Function for resetting the amount of used sectors */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   805  }Fee_LinkedFunctions_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   806  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   807  #if (FEE_PRV_DEBUG_MONITOR != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   808  #define FEE_DBM_ERROR_ENTRIES   15
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   809  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   810  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   811  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   812      FEE_DBM_ERROR_ERASE_FCT_E,        /* Used in function Fee_LLEraseSector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   813      FEE_DBM_ERROR_LLMARKER_FCT_E,     /* USed in function Fee_LLWriteMarker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   814      FEE_DBM_ERROR_XX_E                /* not used yet....                   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   815  } Fee_DebugMonitoringFct_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   816  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   817  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   818  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   819      uint32                       xSecChngCntVal;             /* value of sector change counter while error occurs */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   820      uint16                       FeeBlkIdx;                  /* if the error couldn't be assigned to a NvmBlock, this is 0xFFFF */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   821      Fee_DebugMonitoringFct_ten   xError;                     /* error number */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   822      uint8                        xErrorInfo;                 /* error info, if necessary */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   823  } FeeDBMErrInfo_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   824  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   825  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   826  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   827      FeeDBMErrInfo_tst  xErrorEntry[FEE_DBM_ERROR_ENTRIES];  /* array of a structure with detail info to the errors */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   828      uint8   idxNewEntry;                /* index points on the next free entry in the xErrorEntry buffer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   829      uint8   ctBuffOverflow;             /* counter countrs how often the FEE_DBM_ERROR_ENTRIES error overflow. Startvalue is 1, used for ProtRAM validation! */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   830  } Fee_DebugMonitoring_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   831  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   832  #define FEE_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   833  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   834  extern Fee_DebugMonitoring_tst Fee_DebugMonitoring;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   835  #define FEE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   836  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   837  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   838  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   839  #if(FEE_ROBUST_PROG_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   840  /* Ifx robust programming */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   841  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   842  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   843      FEE_ROB_IFX_INIT,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   844      FEE_ROB_IFX_MARK_SECTOR,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   845      FEE_ROB_IFX_STORE_BUFFER,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   846      FEE_ROB_IFX_STORE_BUFFER_WAIT,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   847      FEE_ROB_IFX_COPY_DATA,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   848      FEE_ROB_IFX_STORE_COPY_WAIT,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   849      FEE_ROB_IFX_ERASE_SECTOR,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   850      FEE_ROB_IFX_WRITE_USED_MARK_SECTOR,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   851      FEE_ROB_SORT_SECTOR,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   852      FEE_ROB_IFX_FINISHED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   853  }Fee_RobIfxHdl_e;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   854  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   855  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   856  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   857      Fls_AddressType xStartAddress;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   858      uint8* DataBuffer;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   859      Fls_LengthType numBytes;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   860      uint16 offInBuf_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   861  }Fee_IfxRobustProgramming_t;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   862  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   863  #define FEE_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   864  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   865  extern Fee_IfxRobustProgramming_t Fee_IfxRobustProgramming_s;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   866  extern Fee_RobIfxHdl_e Fee_RobIfxHdl;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   867  #define FEE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   868  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   869  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   870  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   871  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   872  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_RobIfxHandling(uint8 xActLogWrSect_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   873  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   874  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   875  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   876  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   877  #if ((FEE_RB_MAINTAIN != FALSE) && (FEE_NO_FALLBACK_ACTIVE != FALSE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   878  /* Additional MainFunction write states in case NoFallback is activated */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   879  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   880  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   881      FEE_WRITE_NOFB_IDLE_E = 0,      /* Idle state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   882      FEE_WRITE_NOFB_MAINTAIN_E,      /* Maintain a NoFallback block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   883      FEE_WRITE_NOFB_BLOCK_E          /* Write a NoFallback block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   884  }Fee_WriteStateNoFb_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   885  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   886  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   887  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   888  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   889      uint32 Fee_Totalfree_bytes;    /* Total number of free bytes  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   890      uint32 Fee_hardThreshold;      /* Hard Threshold configures */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   891      uint32 Fee_softThershold;      /* Soft therosold configured*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   892  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   893  }Fee_FreeByte_thrshold_t;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   894  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   895  /*
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   896  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   897  * Extern declarations
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   898  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   899  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   900  /* Structures and variables */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   901  #define FEE_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   902  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   903  extern CONST(Fee_FlashProp_tst, FEE_CONST)          Fee_FlashProp_st[FEE_NUM_FLASH_BANKS_AVAILABLE];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   904  extern CONST (MemIf_JobResultType, AUTOMATIC)       Fee_JobTypeMapping[FEE_NUM_RET_VAL_E];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   905  extern CONST (Fee_LinkedFunctions_tst, FEE_CONST)   Fee_LinkedFunctions_cst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   906  #define FEE_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   907  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   908  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   909  #define FEE_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   910  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   911  extern P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA)       Fee_PageBytePtr_cpu8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   912  extern VAR(Fee_RdWrOrder_tst, AUTOMATIC)            Fee_RdWrOrder_st;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   913  extern VAR(Fee_LLSectorOrder_tst, AUTOMATIC)        Fee_LLSectorOrder_st[FEE_NUM_FLASH_BANKS_AVAILABLE];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   914  extern VAR(Fee_LLEraseOrderType_tst, AUTOMATIC)     Fee_LLEraseOrder_st;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   915  extern VAR(Fee_OrderFifo_tst, AUTOMATIC)            Fee_OrderFifo_st[FEE_QUEUE_SIZE];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   916  extern VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC) Fee_GlobInfoLastRdHeader_st;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   917  extern VAR(Fee_GlobInfoWrBlock_tst, FEE_VAR)        Fee_GlobInfoWrBlock_st;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   918  extern VAR(Fee_LLSecReorgStruct_tst, FEE_VAR)       Fee_LLSecReorgStruct_st;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   919  extern VAR(MemIf_JobResultType, AUTOMATIC)          Fee_JobResult[FEE_QUEUE_SIZE];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   920  #define FEE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   921  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   922  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   923  #define FEE_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   924  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   925  extern CONSTP2VAR(uint8, AUTOMATIC, FEE_APPL_DATA)  Fee_MarkerBufBytePtr_cpu8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   926  extern CONSTP2VAR(uint8, AUTOMATIC, FEE_APPL_DATA)  Fee_DataBytePtr_cpu8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   927  #define FEE_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   928  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   929  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   930  #define FEE_START_SEC_VAR_INIT_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   931  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   932  extern VAR(uint8, FEE_VAR)                          Fee_Prv_stInit_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   933  extern VAR(uint8, FEE_VAR)                          Fee_Prv_stReorg_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   934  extern VAR(uint8, FEE_VAR)                          Fee_NumFlashBanksUsed_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   935  extern VAR(uint8, AUTOMATIC)                        Fee_idxActQueueBackUp;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   936  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   937  /* Buffer to hold 2nd header page contents. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   938  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)    /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   939  extern VAR(uint8, AUTOMATIC) Fee_hdr2Buffer_au8[FEE_PAGE_LEN];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   940  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   941  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   942  /* Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   943  #if (defined(RBA_FLSIFX_FLASH) || defined(RBA_FLSJDP_FLASH))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   944  extern VAR(uint8, AUTOMATIC)                        Fee_hdrBuffer_au8[FEE_PAGE_LEN];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   945  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   946  /* END Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   947  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   948  #define FEE_STOP_SEC_VAR_INIT_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   949  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   950  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   951  #define FEE_START_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   952  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   953  extern VAR(MemIf_StatusType, FEE_VAR)               Fee_GlobModuleState_st;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   954  extern VAR(Fee_Rb_WorkingStateType_ten, AUTOMATIC)  Fee_Rb_WorkingStateBackUp_en;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   955  #define FEE_STOP_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   956  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   957  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   958  #define FEE_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   959  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   960  extern VAR(uint8, AUTOMATIC)                        Fee_idxLLSectorOrder_au8[FEE_NUM_FLASH_BANKS_AVAILABLE];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   961  extern VAR(uint8, FEE_VAR)                          Fee_idxActQueue_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   962  extern VAR(uint8, FEE_CONST)                        Fee_CacheUpdCompForSect_au8[FEE_NUM_FLASH_BANKS_AVAILABLE];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   963  extern VAR(uint8, AUTOMATIC)                        Fee_RdWrRetries_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   964  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   965  #if (FEE_RB_ACT_ERASE_SUSPENSION != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   966  extern VAR(boolean, AUTOMATIC) Fee_Prv_stSuspendActiv_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   967  extern VAR(boolean, AUTOMATIC) Fee_Prv_stHardReOrgErase_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   968  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   969  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   970  #if (FEE_RB_ADDONS_CCAS == TRUE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   971  extern VAR(boolean, AUTOMATIC) Fee_Rb_stRequestStopMode_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   972  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   973  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   974  #define FEE_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   975  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   976  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   977  #define FEE_START_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   978  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   979  extern VAR(uint32, AUTOMATIC)                       Fee_llMarkerPageBuf_au32[FEE_SEC_HEADER_SIZE / 4u];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   980  extern VAR(uint32, FEE_CONST)                       Fee_Cache_au32[FEE_NUM_BLOCKS];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   981  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   982  #if(FEE_ROB_FEATURE_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   983  extern VAR(uint32, AUTOMATIC)                       Fee_DataByteStartCrc_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   984  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   985  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   986  #define FEE_STOP_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   987  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   988  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   989  #define FEE_START_SEC_VAR_CLEARED_SECURED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   990  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   991  extern VAR(uint32, AUTOMATIC)                       Fee_llPageBuf_au32[(FEE_LL_PAGEBUFFSIZE / 4u) + 2u];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   992  extern VAR(uint32, AUTOMATIC)                       Fee_llDataBuf_au32[FEE_LL_DATABUFFSIZE / 4u];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   993  #define FEE_STOP_SEC_VAR_CLEARED_SECURED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   994  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   995  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   996  #ifdef FEE_PRV_USE_ROM_TABLE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   997  #define FEE_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   998  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   999  extern CONST(Fee_BlockPropertiesType_tst, FEE_CONST)  Fee_BlockProperties_st[FEE_NUM_BLOCKS];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1000  #define FEE_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1001  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1002  #else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1003  #define FEE_START_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1004  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1005  extern VAR(Fee_BlockPropertiesType_tst, AUTOMATIC)  Fee_BlockProperties_st[FEE_NUM_BLOCKS];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1006  #define FEE_STOP_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1007  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1008  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1009  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1010  #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1011  #define FEE_START_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1012  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1013  extern Fee_WriteStateNoFb_ten Fee_WriteStateNoFb_en;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1014  #define FEE_STOP_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1015  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1016  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1017  #define FEE_START_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1018  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1019  extern VAR(uint32, AUTOMATIC)   Fee_Rb_NoFallback_RemAdr_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1020  #define FEE_STOP_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1021  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1022  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1023  #define FEE_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1024  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1025  extern VAR(boolean, AUTOMATIC)  Fee_Rb_NoFallback_LastBlockCfg_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1026  extern VAR(boolean, AUTOMATIC)  Fee_Rb_InvalidateOldCopy_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1027  extern VAR(boolean, AUTOMATIC)  Fee_Rb_MaintainRun_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1028  #define FEE_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1029  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1030  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1031  #define FEE_START_SEC_CONST_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1032  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1033  extern const uint8 Fee_NoFallbackMarkerPattern[FEE_PAGES_USED_BY_BLK_HEADER * FEE_PAGE_LEN];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1034  #define FEE_STOP_SEC_CONST_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1035  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1036  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1037  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1038  #if((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) && (FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE != 0))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1039  /* Unknown blcok sector reorganiation with cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1040  #define FEE_START_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1041  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1042  extern VAR(uint32, AUTOMATIC) Fee_UnknownBlkCache_Addr_au32[FEE_RB_ACT_UNKNOWN_BLK_CACHE_ARRAY_SIZE];   /* Address of unknown block. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1043  #define FEE_STOP_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1044  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1045  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1046  #define FEE_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1047  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1048  extern VAR(uint16, AUTOMATIC) Fee_UnknownBlkCache_FeeIndex_u16[FEE_RB_ACT_UNKNOWN_BLK_CACHE_ARRAY_SIZE]; /* Index of unknown block. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1049  #define FEE_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1050  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1051  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1052  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1053  /* Lower Layer functions of the Fee */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1054  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1055  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1056  extern FUNC(uint32, FEE_CODE) Fee_CalculateNumOfFreeBytesInCurSector(VAR(uint32, FEE_VAR) DataEndAdr_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1057  extern FUNC(void, FEE_CODE)   Fee_InitVarAndState(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1058  extern FUNC(void, FEE_CODE)   Fee_InitCache(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1059  extern FUNC(void, FEE_CODE)   Fee_InitOrderFifoBuffer(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1060  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1061  /* Active sector detection */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1062  extern FUNC(void ,FEE_CODE)   Fee_LLSearchSectors(P2VAR(Fee_stSecDet_tst, AUTOMATIC, FEE_APPL_DATA) Fee_stSecDet_ps);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1063  extern FUNC(uint8, FEE_CODE)  Fee_LLDetectActiveSector(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1064  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLFindEmptyPage(uint8 PhySectIdxUsedSect_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1065  extern FUNC(uint8, FEE_CODE)  Fee_GetMostCurrentSectorIdx(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1066  extern FUNC(void, FEE_CODE)   Fee_CheckErasedSectorEmpty(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1067  extern FUNC(uint8, FEE_CODE)  Fee_GetPhysSectorByAddress(VAR(uint32, AUTOMATIC) Address_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1068  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1069  /* Marker handling */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1070  extern FUNC(Fee_stRetVal_ten,FEE_CODE)  Fee_LLWriteMarker(VAR(uint8, AUTOMATIC) PhySectIdx_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1071                                                            VAR(uint8, AUTOMATIC) MarkerID_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1072  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1073  /* Erase functions */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1074  extern FUNC(Fee_stRetVal_ten,FEE_CODE)  Fee_LLEraseSector(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1075  extern FUNC(void,FEE_CODE)              Fee_LLSetEraseSector(VAR(uint8, AUTOMATIC) EraseLogIdx);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1076  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1077  /* Block header access */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1078  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLSearchNextBlkHeader(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Fee_GlobInfoLastRdHeader_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1079                                                                    VAR(uint8, AUTOMATIC) CachedAccess_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1080                                                                    VAR(uint8, AUTOMATIC) FastCacheUpdate_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1081                                                                    VAR(boolean, AUTOMATIC) xForcePageBufReload_b,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1082                                                                    VAR(uint32, AUTOMATIC) strAddrHdrSearch);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1083  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1084  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLSearchSpecifiedBlkHeader(VAR(uint16, AUTOMATIC) FeeIdx_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1085                                                                         P2VAR(uint32, AUTOMATIC, FEE_APPL_DATA) LastHdrAddr_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1086                                                                         P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) GlobBlkHdr_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1087                                                                         VAR(boolean, AUTOMATIC) SearchRetry_b);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1088  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1089  #if((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1090  /* Unknown blcok sector reorganiation without cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1091  #if(FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE == 0)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1092  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLSearchUnknownBlkHeader(P2VAR(uint32, AUTOMATIC, FEE_APPL_DATA) StartHdrAddr_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1093                                                                       P2VAR(uint32, AUTOMATIC, FEE_APPL_DATA) LastHdrAddr_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1094                                                                       P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) GlobBlkHdr_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1095                                                                       P2VAR(boolean, AUTOMATIC, FEE_APPL_DATA) SearchRetry_ptr);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1096  #else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1097  /* Unknown blcok sector reorganiation with cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1098  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_BuildUpCacheUnknownBlk(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1099  #endif /* (FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE == 0) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1100  #endif /* ((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE)) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1101  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1102  extern FUNC(uint32, FEE_CODE) Fee_LLGetSecStartAddress(VAR(uint8, AUTOMATIC) xPhySectorIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1103  extern FUNC(uint32, FEE_CODE) Fee_LLGetSecEndAddress(VAR(uint8, AUTOMATIC) xPhySectorIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1104  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1105  /* Verification and handling of blocks */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1106  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLCompBlkInFlash(P2CONST(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) HeaderInfo_pcst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1107                                                               P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) Data_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1108  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLCalcBlkCrcInFlash(P2CONST(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) HeaderInfo_pcst);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1109  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLCpyBlkFromFls2Fls(P2CONST(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Fee_GlobInfoLastRdHeader_pcst, boolean Fee_WriteTwice_b);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1110  #if defined (FEE_PRV_ROBUST_SECT_OVERFLOW)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1111  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LlRobustSectorOverflow(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1112  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1113  extern FUNC(void, FEE_CODE)             Fee_LLPrepMarkerBufWithMarkerData(P2CONST(Fee_MarkerProp_t, AUTOMATIC, FEE_APPL_DATA) Marker_pcst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1114                                                                            P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) MarkerBuf_pu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1115  extern FUNC(void, FEE_CODE)             Fee_LLCopyPageBuff2Marker(P2VAR(Fee_MarkerProp_t, AUTOMATIC, FEE_APPL_DATA) Marker_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1116                                                                    P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1117  extern FUNC(void, FEE_CODE)             Fee_LLPrepPageBufWithHdrDataStart(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) HeaderInfo_pst);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1118  extern FUNC(void, FEE_CODE)             Fee_LLPrepPageBufWithHdrDataEnd(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) HeaderInfo_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1119                                                                                 P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) Data_pcu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1120                                                                                 VAR(uint32, AUTOMATIC) BlkCrc32_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1121  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1122  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1123  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1124  LOCAL_INLINE FUNC(void, FEE_CODE)       Fee_LLCopyPageBuff2HeaderStart(P2VAR(Fee_BlkHeader_tst, AUTOMATIC, FEE_APPL_DATA) BlkHdr_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1125                                                                         P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1126  #if(FEE_FAST_CACHE_INIT_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1127  LOCAL_INLINE FUNC(void, FEE_CODE)       Fee_LLCopyPageBuff2HeaderIdxAndCrc(P2VAR(Fee_BlkHeader_tst, AUTOMATIC, FEE_APPL_DATA) BlkHdr_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1128                                                                             P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1129  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1130  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1131  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1132  #if !( defined(RBA_FLSRH850P1xC_FLASH) || defined(RBA_FLSV850R1x_FLASH) || defined(RBA_FLSRH850xx_FLASH) )
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1133  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_SearchLastBlkHeader(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Fee_GlobInfoLastRdHeader_ptr);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1134  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1135  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1136  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1137  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1138  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1139  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1140  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1141  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1142  extern FUNC(uint32, FEE_CODE)           Fee_SearchHighestCacheEntry(VAR(uint32,FEE_VAR) UpperBoundary_u32, VAR(uint8, FEE_VAR) SectIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1143  extern FUNC(void, FEE_CODE)             Fee_InvalidateCacheByAddress(VAR(uint32,FEE_VAR) xAddress_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1144  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1145  extern FUNC(void, FEE_CODE)             Fee_LLCopyPageBuff2HeaderMid(P2VAR(Fee_BlkHeader_tst, AUTOMATIC, FEE_APPL_DATA) BlkHdr_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1146                                                                       P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1147  extern FUNC(void, FEE_CODE)             Fee_LLCopyPageBuff2HeaderEnd(P2VAR(Fee_BlkHeader_tst, AUTOMATIC, FEE_APPL_DATA) BlkHdr_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1148                                                                       P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1149  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLCopyData2Buffer(P2CONST(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Fee_GlobInfoLastRdHeader_pcst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1150                                                                    P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) DataPtr_pu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1151                                                                    VAR(uint16, FEE_VAR) DataOffset_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1152                                                                    VAR(uint16, FEE_VAR) DataLength_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1153  extern FUNC(void, FEE_CODE)             Fee_IncAddressInsideSector(P2VAR(uint32, AUTOMATIC, FEE_APPL_DATA) Address_u32,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1154                                                                     VAR(uint16, FEE_VAR) numBytes_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1155                                                                     VAR(boolean, FEE_VAR) EnsurePageAlign_b);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1156  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1157  /* Sector reorganization */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1158  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLCheckReorganizationNeed(VAR(uint32, AUTOMATIC) Threshold_u32,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1159                                                                        VAR(uint16, AUTOMATIC) DataLength_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1160  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLSectorReorganization(P2VAR(boolean, AUTOMATIC, FEE_APPL_DATA) SectReorgInterSt_pb);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1161  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1162  /* Block writes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1163  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_HLWriteBlock(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1164  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLWriteBlock(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Info_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1165                                                           P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) Data_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1166  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1167  /* Block reading */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1168  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_HLReadBlock(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1169  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLReadBlock(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Info_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1170                                                          P2VAR(uint8,AUTOMATIC, FEE_APPL_DATA) Data_ptr);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1171   #if(FEE_RB_MAINTAIN != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1172      /* Block maintaining*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1173      extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_HLMaintainBlock(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1174   #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1175  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1176  /* Order handling */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1177  extern FUNC(Std_ReturnType, FEE_CODE)   Fee_HLPlaceOrder(VAR(uint16, AUTOMATIC) Blocknumber_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1178                                                           VAR(uint16, AUTOMATIC) Offset_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1179                                                           P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) DataBufferPtr_pu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1180                                                           VAR(uint16, AUTOMATIC) Length_16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1181                                                           VAR(Fee_HlMode_ten, AUTOMATIC) Mode_en);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1182  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1183  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1184  /* Cache handling */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1185  extern FUNC(uint32, FEE_CODE) Fee_LLGetAddressFromCache(VAR(uint16, AUTOMATIC) FeeIdx_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1186  extern FUNC(boolean, FEE_CODE) Fee_LLCheckAddressInCache(VAR(uint32, AUTOMATIC) AdrInSector_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1187  extern FUNC(void, FEE_CODE)   Fee_LLUpdateAddressInCache(VAR(uint16, AUTOMATIC) FeeIdx_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1188                                                           VAR(uint32, AUTOMATIC) Addr_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1189  extern FUNC(void, FEE_CODE)  Fee_LLUpdateCacheStForSect(VAR(uint8, AUTOMATIC) PhySecIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1190  extern FUNC(void, FEE_CODE)  Fee_LLEraseCacheStForSect(VAR(uint8, AUTOMATIC) PhySecIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1191  extern FUNC(uint8, FEE_CODE) Fee_LLGetCacheUpdateStForSect(VAR(uint8, AUTOMATIC) PhySecIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1192  extern FUNC(uint8, FEE_CODE) Fee_LLGetCacheUpdateStForAllSect(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1193  extern FUNC(boolean, FEE_CODE) Fee_SrvBinarySearchInBlockProp(VAR(uint16, AUTOMATIC) FeeIdx_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1194                                                                P2VAR(uint16, AUTOMATIC, FEE_APPL_DATA) CacheIdx_pu16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1195  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1196  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1197  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1198  #if(FEE_FAST_CACHE_INIT_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1199  LOCAL_INLINE FUNC(boolean, FEE_CODE) Fee_SrvBinarySearchInBlockPropFast(VAR(uint16, AUTOMATIC) FeeIdx_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1200                                                                          P2VAR(uint16, AUTOMATIC, FEE_APPL_DATA) CacheIdx_pu16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1201  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1202  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1203  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1204  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_BuildUpCache(VAR(uint32, AUTOMATIC) StartAdr_u32,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1205                                                           VAR(uint32, AUTOMATIC) EndAdr_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1206  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_BuildUpCacheForAllSect(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1207  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1208  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1209  /* FEE_FAST_CACHE_INIT_ACTIVE != FALSE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1210  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1211  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1212  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1213  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1214  /* Services */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1215  extern FUNC(void, FEE_CODE)  Fee_SrvMemSet8(P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) xDest_pu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1216                                              VAR(uint32, FEE_VAR) xPattern_u32,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1217                                              VAR(uint32, FEE_VAR) numBytes_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1218  extern FUNC(void, FEE_CODE)  Fee_SrvMemCopy8(P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) xDest_pu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1219                                               P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) xSrc_pcu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1220                                               VAR(uint32, FEE_VAR) numBytes_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1221  extern FUNC(void, FEE_CODE)  Fee_SrvSetFifoMode(VAR(Fee_HlMode_ten, AUTOMATIC) Mode_en,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1222                                                  VAR(uint16, AUTOMATIC) xJobType_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1223  extern FUNC(Fee_HlMode_ten, FEE_CODE) Fee_SrvGetFifoMode(VAR(uint16, AUTOMATIC) xJobType_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1224  extern FUNC(void, FEE_CODE)           Fee_LoadNextOrder(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1225  extern FUNC(uint8, FEE_CODE)          Fee_SearchNextOrder(boolean isIntOrder_b);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1226  extern FUNC(void, FEE_CODE)           Fee_UpdateStatus(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1227  extern FUNC(void, FEE_CODE)           Fee_TriggerHardSectorReorg(VAR(Fee_Rb_WorkingStateType_ten, FEE_VAR) WorkingState_en);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1228  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1229  extern FUNC(Std_ReturnType, FEE_CODE) Fee_CheckBlockCfg(VAR(uint8, AUTOMATIC)  ApiId_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1230                                                             VAR(uint16, AUTOMATIC) BlockNum_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1231  extern FUNC(Std_ReturnType, FEE_CODE) Fee_CheckModuleSt(VAR(uint8, AUTOMATIC)  ApiId_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1232  extern FUNC(Std_ReturnType, FEE_CODE) Fee_CheckAdrPtr(VAR(uint8, AUTOMATIC) ApiId_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1233                                                        P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) DataBufferPtr_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1234  extern FUNC(Std_ReturnType, FEE_CODE) Fee_CheckBlkOfs(VAR(uint8, AUTOMATIC) ApiId_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1235                                                        VAR(uint16, AUTOMATIC) BlockNum_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1236                                                        VAR(uint16, AUTOMATIC) BlockOfs_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1237  extern FUNC(Std_ReturnType, FEE_CODE) Fee_CheckBlkLen(VAR(uint8, AUTOMATIC) ApiId_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1238                                                        VAR(uint16, AUTOMATIC) BlockNum_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1239                                                        VAR(uint16, AUTOMATIC) BlockOfs_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1240                                                        VAR(uint16, AUTOMATIC) BlockLen_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1241  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1242  /* Miscellaneous */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1243  extern FUNC(void, FEE_CODE)   Fee_CheckFlsJobResult(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1244  extern void (* Fee_Prv_ResetUsedSectors_pfn)(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1245  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1246  #if (FEE_PRV_DEBUG_MONITOR != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1247  extern FUNC(void ,FEE_CODE) Fee_DBM_RepError(VAR(uint16,FEE_VAR) FeeBlkIdx, VAR(Fee_DebugMonitoringFct_ten,FEE_VAR) xError, VAR(uint8,FEE_VAR) xErrorInfo);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1248  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1249  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1250  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1251  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1252  /*
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1253  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1254  * Inline functions (Necessary for fastening up the start up time)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1255  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1256  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1257  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1258   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1259   * Fee_LLCopyPageBuff2HeaderStart(): Extract the start of the block header data
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1260   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1261   * This function extracts the preamble of the block header data out
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1262   * of the page buffer (called every 8th byte of the flash).
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1263   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1264   * Hint: Block header structure:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1265   *       {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1266   *          uint8   Preamble_au8[3];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1267   *          uint8   BlkStatus_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1268   *          uint16  FeeIndex_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1269   *          uint16  BlkLength_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1270   *          uint16  HdrCrc16_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1271   *          uint32  BlkCrc32_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1272   *       }Fee_BlkHeader_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1273   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1274   * \param    BlkHdr_pst:    Pointer to the block header that was
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1275   *                          found in the flash.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1276   * \param    PageBuf_pu8:   Pointer to the page buffer
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1277   * \return
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1278   * \retval   none
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1279   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1280   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1281   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1282   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1283  LOCAL_INLINE FUNC(void, FEE_CODE) Fee_LLCopyPageBuff2HeaderStart(P2VAR(Fee_BlkHeader_tst, AUTOMATIC, FEE_APPL_DATA) BlkHdr_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1284                                                                   P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1285  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1286      BlkHdr_pst->Preamble_au8[0] = PageBuf_pcu8[0];      /* 0xA53C96 <- [0]: A5, [1]: 3C, [2]: 96 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1287      BlkHdr_pst->Preamble_au8[1] = PageBuf_pcu8[1];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1288      BlkHdr_pst->Preamble_au8[2] = PageBuf_pcu8[2];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1289  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1290  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1291  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1292  #if(FEE_FAST_CACHE_INIT_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1293  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1294   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1295   * Fee_LLCopyPageBuff2HeaderIdxAndCrc(): Extract the header checksum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1296   *  and the block index out of the block header data
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1297   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1298   * This function extracts the block header data out of the page buffer.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1299   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1300   * Hint: Block header structure:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1301   *       {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1302   *          uint8   Preamble_au8[3];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1303   *          uint8   BlkStatus_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1304   *          uint16  FeeIndex_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1305   *          uint16  BlkLength_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1306   *          uint16  HdrCrc16_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1307   *          uint32  BlkCrc32_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1308   *       }Fee_BlkHeader_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1309   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1310   * \param    BlkHdr_pst:    Pointer to the block header that was
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1311   *                          found in the flash.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1312   * \param    PageBuf_pcu8:  Pointer to the page buffer
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1313   * \return
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1314   * \retval   none
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1315   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1316   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1317   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1318   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1319  LOCAL_INLINE FUNC(void, FEE_CODE) Fee_LLCopyPageBuff2HeaderIdxAndCrc(P2VAR(Fee_BlkHeader_tst, AUTOMATIC, FEE_APPL_DATA) BlkHdr_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1320                                                                       P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1321  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1322      /* 0xD2E9 <- [4]: D2, [5]: E9 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1323      BlkHdr_pst->FeeIndex_u16    = (uint16)((uint16)(((uint16)(PageBuf_pcu8[4])) << 8u)  | (uint16)(PageBuf_pcu8[5]));
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1324  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1325      /* 0xABCD <- [8]: AB, [9]: CD */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1326      BlkHdr_pst->HdrCrc16_u16    = (uint16)((uint16)(((uint16)(PageBuf_pcu8[8])) << 8u)  | (uint16)(PageBuf_pcu8[9]));
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1327  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1328  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1329  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1330  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1331   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1332   * Fee_SrvBinarySearchInBlockProp(): Get the respective index out of
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1333   *                                   the block properties table
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1334   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1335   * This function searches for the respective block properties table
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1336   * index. In case unknown blocks are searched, the function will
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1337   * return with a negative response.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1338   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1339   * \param    FeeIdx_u16:    Fee index (persistent ID)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1340   * \param    CacheIdx_pu16: Pointer for the result
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1341   * \return   Success of the function
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1342   * \retval   FALSE: Corresponding index was not found
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1343   * \retval   TRUE:  Corresponding index was found
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1344   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1345   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1346   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1347   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1348   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1349  LOCAL_INLINE FUNC(boolean, FEE_CODE) Fee_SrvBinarySearchInBlockPropFast(VAR(uint16, AUTOMATIC) FeeIdx_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1350                                                                          P2VAR(uint16, AUTOMATIC, FEE_APPL_DATA) CacheIdx_pu16)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1351  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1352      VAR(boolean, AUTOMATIC)  xFuncRet_b = FALSE;    /* Function return value */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1353      VAR(uint16, AUTOMATIC)  xMid_u16;               /* Mid index for the search */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1354      VAR(uint16, AUTOMATIC)  xLeft_u16 = 0;          /* Left index for the search */
	mov	d1,#0
.L659:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1355      VAR(uint16, AUTOMATIC)  xRight_u16 = FEE_NUM_BLOCKS - 1u; /* Right index for the search */
	mov	d2,#11

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1398      while(xRight_u16 >= xLeft_u16);      (inlined)
.L228:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1356  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1357      /* Loop until the value is found */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1358      do
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1359      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1360          /* Divide search area by two */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1361          xMid_u16 = (uint16)(xLeft_u16 + ((xRight_u16 - xLeft_u16) / 2));
	sub	d15,d2,d1
.L864:
	mov	d3,#2
.L865:
	div	e4,d15,d3
.L866:
	add	d15,d1,d4
.L867:
	extr.u	d15,d15,#0,#16
.L661:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1362  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1363          /* Check the cache content */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1364          if(Fee_BlockProperties_st[xMid_u16].BlockPersistentId_u16 == FeeIdx_u16)
	sha	d3,d15,#4
.L868:
	movh.a	a2,#@his(Fee_BlockProperties_st)
	lea	a2,[a2]@los(Fee_BlockProperties_st)
.L869:
	addsc.a	a2,a2,d3,#0
.L870:
	ld.hu	d3,[a2]0
.L871:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1364          if(Fee_BlockProperties_st[xMid_u16].BlockPersistentId_u16 == FeeIdx_u16)      (inlined)
	jne	d3,d0,.L229
.L872:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1365          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1366              /* Index was found, set return value */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1367              *CacheIdx_pu16 = xMid_u16;
	st.h	[a15],d15
.L873:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1373              return xFuncRet_b;      (inlined)
	j	.L230

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1364          if(Fee_BlockProperties_st[xMid_u16].BlockPersistentId_u16 == FeeIdx_u16)      (inlined)
.L229:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1377          if(Fee_BlockProperties_st[xMid_u16].BlockPersistentId_u16 > FeeIdx_u16)      (inlined)
	jge.u	d0,d3,.L231
.L874:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1380              if(xMid_u16 != 0)      (inlined)
	jeq	d15,#0,.L232
.L875:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1368  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1369              /* Return positive response */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1370              xFuncRet_b = TRUE;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1371  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1372              /* Leave the loop */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1373              return xFuncRet_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1374          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1375  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1376          /* Check the current array index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1377          if(Fee_BlockProperties_st[xMid_u16].BlockPersistentId_u16 > FeeIdx_u16)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1378          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1379              /* Check if the lowest array position is reached */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1380              if(xMid_u16 != 0)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1381              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1382                  /* Reduce the right limit to the left */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1383                  xRight_u16 = (uint16)(xMid_u16 - 1u);
	add	d2,d15,#-1
.L876:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1383                  xRight_u16 = (uint16)(xMid_u16 - 1u);      (inlined)
	j	.L233

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1380              if(xMid_u16 != 0)      (inlined)
.L232:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1388                  return xFuncRet_b;      (inlined)
	j	.L234

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1385              else      (inlined)
.L233:
	j	.L235

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1377          if(Fee_BlockProperties_st[xMid_u16].BlockPersistentId_u16 > FeeIdx_u16)      (inlined)
.L231:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1384              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1385              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1386              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1387                  /* Leave the loop with a negative response */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1388                  return xFuncRet_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1389              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1390          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1391          else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1392          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1393              /* Reduce the left limit to the right (upper limit is
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1394               * safe because of the loop condition) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1395              xLeft_u16 = (uint16)(xMid_u16 + 1u);
	add	d15,#1
.L662:
	extr.u	d1,d15,#0,#16

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1391          else      (inlined)
.L235:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1398      while(xRight_u16 >= xLeft_u16);      (inlined)
	jge.u	d2,d1,.L228
.L877:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1400      return xFuncRet_b;      (inlined)
	j	.L236

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1401  }      (inlined)
.L236:
.L234:
.L230:
	movh.a	a15,#@his(_999005_xNumBytes_u16)
	lea	a15,[a15]@los(_999005_xNumBytes_u16)
.L878:
	mov	d0,#1024
.L879:
	ld.a	a2,[a10]
.L663:
	ld.hu	d1,[a2]10
.L660:
	ge.u	d15,d0,d1
.L880:
	cmov	d0,d15,d1
	st.h	[a15],d0
.L881:
	j	.L238
.L237:
	st.h	[a15],d1
.L238:
	movh.a	a2,#@his(Fee_PageBytePtr_cpu8)
.L664:
	lea	a2,[a2]@los(Fee_PageBytePtr_cpu8)
	ld.a	a4,[a2]
.L882:
	mov	d4,#0
.L883:
	ld.hu	d5,[a15]0
	call	Fee_SrvMemSet8
.L665:
	mov	d15,#1
.L884:
	ld.a	a15,[a10]8
	st.w	[a15],d15
.L219:
	movh.a	a2,#@his(_999005_xNumBytes_u16)
	lea	a2,[a2]@los(_999005_xNumBytes_u16)
.L885:
	ld.a	a15,[a10]4
	lea	a12,[a15]12
.L886:
	movh.a	a4,#@his(Fee_PageBytePtr_cpu8)
	lea	a4,[a4]@los(Fee_PageBytePtr_cpu8)
.L887:
	ld.a	a15,[a10]
.L666:
	ld.hu	d15,[a15]10
.L888:
	st.h	[a2],d15
.L889:
	ld.bu	d15,[a15]14
.L890:
	and	d0,d15,#32
.L891:
	sha	d0,#-5
.L892:
	jeq	d0,#0,.L239
.L893:
	jnz.t	d15:3,.L240
.L894:
	ld.hu	d15,[a2]0
.L895:
	add	d15,#-4
	st.h	[a2],d15
.L240:
.L239:
	ld.hu	d15,[a2]0
.L896:
	jlt.u	d15,#3,.L241
.L897:
	mov	d15,#2
.L898:
	st.h	[a2],d15
.L241:
	ld.w	d4,[a12]
	ld.a	a4,[a4]
	mov	d5,#16
	call	Fls_17_Pmu_Read
.L899:
	jeq	d2,#1,.L242
.L900:
	mov	d15,#7
.L901:
	ld.a	a15,[a10]8
.L667:
	st.w	[a15],d15
.L902:
	mov	d4,#16
.L903:
	mov	d5,#1
	mov.aa	a4,a12
	call	Fee_IncAddressInsideSector
.L904:
	j	.L243
.L242:
	mov	d8,#6
.L243:
	j	.L244
.L225:
.L224:
	movh.a	a15,#@his(Fee_stMain)
	lea	a15,[a15]@los(Fee_stMain)
	ld.w	d15,[a15]
.L905:
	jne	d15,#0,.L245
.L906:
	call	Fls_17_Pmu_MainFunction
.L245:
	call	Fee_CheckFlsJobResult
.L907:
	j	.L246
.L226:
	movh.a	a15,#@his(Fee_RdWrRetries_u8)
	lea	a15,[a15]@los(Fee_RdWrRetries_u8)
	ld.bu	d15,[a15]
.L908:
	jeq	d15,#0,.L247
.L909:
	add	d15,#-1
	st.b	[a15],d15
.L910:
	mov	d15,#0
.L911:
	ld.a	a15,[a10]8
	st.w	[a15],d15
.L912:
	j	.L248
.L247:
	ld.a	a15,[a10]
.L668:
	ld.hu	d4,[a15]12
.L913:
	mov.u	d5,#51966
	addih	d5,d5,#45054
	call	Fee_LLUpdateAddressInCache
.L914:
	mov	d8,#3
.L248:
	j	.L249
.L221:
.L223:
	jne	d0,#5,.L250
.L915:
	mov	d15,#4
.L916:
	ld.a	a15,[a10]8
	st.w	[a15],d15
.L917:
	mov	d9,#4
.L670:
	j	.L251
.L250:
	mov	d15,#2
.L918:
	ld.a	a15,[a10]8
	st.w	[a15],d15
.L919:
	ld.a	a15,[a10]
.L669:
	ld.hu	d9,[a15]10
.L251:
	ld.a	a15,[a10]4
	lea	a12,[a15]12
	ld.w	d4,[a12]
	call	Fee_GetPhysSectorByAddress
.L671:
	mov	d10,d2
.L673:
	add.a	a15,#4
	ld.w	d4,[a15]
	call	Fee_GetPhysSectorByAddress
.L672:
	ld.w	d0,[a12]
.L920:
	ld.w	d1,[a15]
.L921:
	jge.u	d1,d0,.L252
.L922:
	eq	d15,d10,d2
.L923:
	cmov	d8,d15,#3
.L253:
.L252:
	movh.a	a15,#@his(Fee_GlobInfoWrBlock_st)
	lea	a15,[a15]@los(Fee_GlobInfoWrBlock_st)
.L924:
	add.a	a15,#2
.L925:
	movh.a	a2,#@his(_999005_xNumBytes_u16)
	lea	a2,[a2]@los(_999005_xNumBytes_u16)
.L926:
	ld.hu	d1,[a15]0
.L927:
	ld.hu	d2,[a2]0
.L675:
	add	d1,d2
.L928:
	jge	d1,d9,.L254
.L929:
	movh.a	a2,#@his(Fee_FlashProp_st)
	lea	a2,[a2]@los(Fee_FlashProp_st)
.L930:
	sha	d15,d10,#4
.L931:
	addsc.a	a15,a2,d15,#0
.L932:
	ld.w	d15,[a15]12
.L933:
	jlt.u	d0,d15,.L255
.L934:
	movh.a	a15,#@his(Fee_idxLLSectorOrder_au8)
	lea	a15,[a15]@los(Fee_idxLLSectorOrder_au8)
.L935:
	addsc.a	a15,a15,d10,#0
	ld.bu	d15,[a15]
.L936:
	add	d15,#1
.L937:
	extr.u	d15,d15,#0,#8
.L676:
	movh.a	a15,#@his(Fee_NumFlashBanksUsed_u8)
	lea	a15,[a15]@los(Fee_NumFlashBanksUsed_u8)
	ld.bu	d0,[a15]
.L938:
	jlt.u	d15,d0,.L256
.L939:
	mov	d8,#3
.L940:
	j	.L257
.L256:
	mul	d15,d15,#12
.L677:
	movh.a	a15,#@his(Fee_LLSectorOrder_st)
	lea	a15,[a15]@los(Fee_LLSectorOrder_st)
.L941:
	addsc.a	a15,a15,d15,#0
.L942:
	ld.w	d15,[a15]4
.L943:
	jeq	d15,#2,.L258
.L944:
	jne	d15,#3,.L259
.L258:
	ld.bu	d15,[a15]8
.L674:
	sha	d15,#4
.L678:
	addsc.a	a15,a2,d15,#0
.L945:
	ld.w	d15,[a15]8
.L946:
	st.w	[a12],d15
.L947:
	j	.L260
.L259:
	mov	d8,#3
.L260:
.L257:
.L255:
	j	.L261
.L254:
.L261:
	j	.L262
.L220:
	movh.a	a12,#@his(_999006_xBlkCrc32_u32)
	lea	a12,[a12]@los(_999006_xBlkCrc32_u32)
.L948:
	movh.a	a13,#@his(Fee_PageBytePtr_cpu8)
	lea	a13,[a13]@los(Fee_PageBytePtr_cpu8)
	ld.a	a4,[a13]
.L679:
	movh.a	a14,#@his(_999005_xNumBytes_u16)
	lea	a14,[a14]@los(_999005_xNumBytes_u16)
	ld.hu	d4,[a14]0
.L949:
	movh.a	a15,#@his(_999008_xFirstCRCRunDone_b)
	lea	a15,[a15]@los(_999008_xFirstCRCRunDone_b)
	ld.bu	d15,[a15]
.L950:
	jne	d15,#0,.L263
.L951:
	lea	a4,[a4]14
.L952:
	ld.a	a2,[a10]
.L680:
	ld.hu	d5,[a2]8
.L953:
	mov	d15,#-1
.L954:
	xor	d5,d15
.L955:
	mov	d6,#0
	call	Crc_CalculateCRC32
.L681:
	st.w	[a12],d2
.L956:
	mov	d15,#1
.L957:
	st.b	[a15],d15
.L958:
	j	.L264
.L263:
	ld.w	d5,[a12]
.L959:
	mov	d6,#0
	call	Crc_CalculateCRC32
.L960:
	st.w	[a12],d2
.L264:
	movh.a	a2,#@his(Fee_GlobInfoWrBlock_st)
	lea	a2,[a2]@los(Fee_GlobInfoWrBlock_st)
.L961:
	add.a	a2,#2
	ld.hu	d15,[a2]0
.L962:
	ld.hu	d0,[a14]0
.L963:
	add	d15,d0
.L964:
	st.h	[a2],d15
.L965:
	ld.a	a15,[a10]
.L682:
	ld.hu	d0,[a15]10
.L684:
	ld.bu	d15,[a15]14
.L966:
	and	d1,d15,#32
.L967:
	sha	d1,#-5
.L968:
	jeq	d1,#0,.L265
.L969:
	jnz.t	d15:3,.L266
.L970:
	add	d0,#-4
.L685:
	extr.u	d0,d0,#0,#16
.L686:
	j	.L267
.L266:
.L265:
.L267:
	ld.hu	d15,[a2]0
.L971:
	jge.u	d15,d0,.L268
.L972:
	sub	d0,d15
.L687:
	st.h	[a14],d0
.L973:
	mov	d15,#256
.L974:
	ld.hu	d0,[a14]0
.L975:
	jge.u	d15,d0,.L269
.L976:
	st.h	[a14],d15
.L269:
	ld.a	a15,[a10]4
.L683:
	lea	a12,[a15]12
	ld.w	d4,[a12]
	call	Fee_CalculateNumOfFreeBytesInCurSector
.L977:
	ld.hu	d15,[a14]0
.L978:
	jge.u	d2,d15,.L270
.L979:
	ld.w	d4,[a12]
	call	Fee_CalculateNumOfFreeBytesInCurSector
.L980:
	st.h	[a14],d2
.L270:
	ld.w	d4,[a12]
	ld.a	a4,[a13]
	ld.hu	d5,[a14]0
	call	Fls_17_Pmu_Read
.L981:
	jeq	d2,#1,.L271
.L982:
	mov	d15,#7
.L983:
	ld.a	a15,[a10]8
	st.w	[a15],d15
.L984:
	ld.hu	d4,[a14]0
.L985:
	mov	d5,#0
	mov.aa	a4,a12
	call	Fee_IncAddressInsideSector
.L986:
	j	.L272
.L271:
	mov	d8,#6
.L272:
	j	.L273
.L268:
	ld.w	d0,[a12]
.L689:
	ld.w	d15,[a15]4
.L987:
	jne	d15,d0,.L274
.L988:
	ld.hu	d4,[a15]12
.L989:
	ld.w	d5,[a15]
	call	Fee_LLUpdateAddressInCache
.L990:
	mov	d8,#1
.L991:
	j	.L275
.L274:
	jeq	d1,#0,.L276
.L992:
	mov	d15,#4
.L993:
	ld.a	a15,[a10]8
.L688:
	st.w	[a15],d15
.L994:
	mov	d15,#0
.L995:
	st.h	[a14],d15
.L996:
	mov	d15,#0
.L997:
	st.h	[a2],d15
.L998:
	j	.L277
.L276:
	movh.a	a15,#@his(Fee_Rb_WorkingState_en)
.L690:
	lea	a15,[a15]@los(Fee_Rb_WorkingState_en)
	ld.w	d15,[a15]
.L999:
	jne	d15,#2,.L278
.L1000:
	movh.a	a15,#@his(Fee_idxActQueue_u8)
	lea	a15,[a15]@los(Fee_idxActQueue_u8)
	ld.bu	d15,[a15]
.L1001:
	mul	d15,d15,#24
.L1002:
	movh.a	a15,#@his(Fee_OrderFifo_st)
	lea	a15,[a15]@los(Fee_OrderFifo_st)
.L1003:
	addsc.a	a15,a15,d15,#0
.L1004:
	ld.w	d15,[a15]12
.L1005:
	jne	d15,#5,.L279
.L1006:
	j	.L280
.L279:
.L278:
	ld.a	a15,[a10]
.L691:
	ld.hu	d4,[a15]12
.L1007:
	mov.u	d5,#51966
	addih	d5,d5,#45054
	call	Fee_LLUpdateAddressInCache
.L280:
	mov	d8,#3
.L277:
.L275:
.L273:
	j	.L281
.L222:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2833          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2834              /* Only read out the robustness checksum now and compare it */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2835  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2836              /* Check if this is the first call of this function */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2837              if (xNumBytes_u16 != 0)
	movh.a	a12,#@his(_999005_xNumBytes_u16)
	lea	a12,[a12]@los(_999005_xNumBytes_u16)
	ld.hu	d0,[a12]0
.L1008:
	jeq	d0,#0,.L282
.L1009:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2838              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2839                  /* This is the second time that this function is called
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2840                   * --> The first part of the robustness checksum was located in a different sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2841  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2842                  /* Loop over the CRC bytes (size is already restricted to the number of CS bytes) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2843                  for(i_u8=0; i_u8<xNumBytes_u16; i_u8++)
	mov	d15,#0
.L692:
	movh.a	a15,#@his(Fee_GlobInfoWrBlock_st)
	lea	a15,[a15]@los(Fee_GlobInfoWrBlock_st)
.L1010:
	add.a	a15,#2
.L1011:
	j	.L283
.L284:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2844                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2845                      /* Shift the robustness crc result */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2846                      xBlkRobCrc32_u32 |= ((uint32)(((uint32)(Fee_PageBytePtr_cpu8[i_u8])) << (24 -
	movh.a	a2,#@his(Fee_PageBytePtr_cpu8)
	lea	a2,[a2]@los(Fee_PageBytePtr_cpu8)
	ld.a	a2,[a2]
.L1012:
	movh.a	a4,#@his(_999009_xBlkRobCrc32_u32)
	lea	a4,[a4]@los(_999009_xBlkRobCrc32_u32)
	ld.w	d1,[a4]
.L1013:
	addsc.a	a2,a2,d15,#0
	ld.bu	d2,[a2]
.L1014:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2847                                                          ((i_u8 + Fee_GlobInfoWrBlock_st.BytesAlrdyCompared_u16)*8))));
	ld.hu	d3,[a15]0
.L1015:
	add	d3,d15
	sha	d3,#3
.L1016:
	rsub	d3,d3,#24
.L1017:
	sh	d2,d2,d3
.L1018:
	or	d1,d2
	st.w	[a4],d1
.L1019:
	add	d15,#1
.L693:
	extr.u	d15,d15,#0,#8
.L283:
	jlt.u	d15,d0,.L284
.L282:
	movh.a	a13,#@his(Fee_GlobInfoWrBlock_st)
	lea	a13,[a13]@los(Fee_GlobInfoWrBlock_st)
.L1020:
	add.a	a13,#2
.L1021:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2848                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2849              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2850  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2851              /* Increment the amount of bytes that have already been considered */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2852              Fee_GlobInfoWrBlock_st.BytesAlrdyCompared_u16 = (uint16)(Fee_GlobInfoWrBlock_st.BytesAlrdyCompared_u16 +
	ld.hu	d15,[a13]0
.L1022:
	add	d0,d15
.L1023:
	st.h	[a13],d0
.L1024:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2853                                                                       xNumBytes_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2854  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2855              /* Check if there are still bytes left to be checked */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2856              if (Fee_GlobInfoWrBlock_st.BytesAlrdyCompared_u16 < FEE_SIZE_OF_BLOCK_CS)
	ld.hu	d15,[a13]0
.L1025:
	jge.u	d15,#4,.L285
.L1026:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2857              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2858                  /* Calculate the number of bytes which need to be read next */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2859                  xNumBytes_u16 = (uint16)(FEE_SIZE_OF_BLOCK_CS - Fee_GlobInfoWrBlock_st.BytesAlrdyCompared_u16);
	rsub	d15,d15,#4
.L1027:
	st.h	[a12],d15
.L1028:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2860  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2861                  /* Check if the current sector has enough bytes left, get the corresponding physical sector
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2862                   * of the Crc address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2863                  xPhySectIdx_u8 = Fee_GetPhysSectorByAddress(FEE_LL_SECTOR_USED_FOR_CRC_CALC);
	ld.a	a15,[a10]4
	lea	a14,[a15]12
	ld.w	d4,[a14]
	call	Fee_GetPhysSectorByAddress
.L694:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2864  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2865                  /* Calculate the number of bytes until the sector end address is reached */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2866                  xNumBytesLeft_32 = (Fee_FlashProp_st[xPhySectIdx_u8].Fee_PhysEndAddress_u32 + 1u) -
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2867                                                                          FEE_LL_SECTOR_USED_FOR_CRC_CALC;
	ld.w	d0,[a14]
.L1029:
	movh.a	a2,#@his(Fee_FlashProp_st)
	lea	a2,[a2]@los(Fee_FlashProp_st)
.L1030:
	sha	d15,d2,#4
.L1031:
	addsc.a	a15,a2,d15,#0
.L1032:
	ld.w	d15,[a15]4
	sub	d15,d0
.L696:
	add	d15,#1
.L1033:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2868  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2869                  /* Check if the current sector has enough bytes left */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2870                  if(xNumBytesLeft_32 < xNumBytes_u16)
	ld.hu	d1,[a12]0
.L1034:
	jge.u	d15,d1,.L286
.L1035:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2871                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2872                      /* Restrict the number of bytes to read */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2873                      xNumBytes_u16 = (uint16)xNumBytesLeft_32;
	st.h	[a12],d15
.L286:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2874                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2875  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2876                  /* Check if xCrcAddress must be corrected for the boundary condition when the first byte of the checksum is the last byte of the sector.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2877                   * Fee_GlobInfoWrBlock_st.BytesAlrdyCompared_u16 == 0 is required to be checked, so that this operation is performed only once when reading the first byte of the CRC. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2878                  if ((Fee_RdWrOrder_st.xCrcAddress == Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogStartAddress_u32) &&
	ld.w	d15,[a15]8
.L697:
	jne	d15,d0,.L287
.L1036:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2879                      (Fee_GlobInfoWrBlock_st.BytesAlrdyCompared_u16 == 0u))
	ld.hu	d15,[a13]0
.L1037:
	jne	d15,#0,.L288
.L1038:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2880                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2881                      /* Differentiate between the siutation when all 4 CRC bytes are present in the last page or only 3 bytes. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2882                      if(((HeaderInfo_pcst->BlkLength_u16 - FEE_FREE_BYTES_AFTER_HEADER) % FEE_PAGE_LEN) == 3u)
	ld.a	a15,[a10]
.L698:
	ld.hu	d15,[a15]10
.L1039:
	add	d15,#-2
	and	d15,#7
.L1040:
	jne	d15,#3,.L289
.L1041:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2883                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2884                          /* Read only the last byte from the sector first. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2885                          xLogSectIdx_u8 = (uint8)(Fee_idxLLSectorOrder_au8[xPhySectIdx_u8] - 1u);
	movh.a	a15,#@his(Fee_idxLLSectorOrder_au8)
.L699:
	lea	a15,[a15]@los(Fee_idxLLSectorOrder_au8)
.L1042:
	addsc.a	a15,a15,d2,#0
	ld.bu	d15,[a15]
.L1043:
	add	d15,#-1
.L1044:
	extr.u	d15,d15,#0,#8
.L700:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2886  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2887                          /* Get the new physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2888                          xPhySectIdx_u8 = Fee_LLSectorOrder_st[xLogSectIdx_u8].xPhySecIdx_u8;
	mul	d15,d15,#12
.L701:
	movh.a	a15,#@his(Fee_LLSectorOrder_st)
	lea	a15,[a15]@los(Fee_LLSectorOrder_st)
.L1045:
	addsc.a	a15,a15,d15,#0
.L1046:
	ld.bu	d15,[a15]8
.L695:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2889  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2890                          /* Set the new start address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2891                          Fee_RdWrOrder_st.xCrcAddress = Fee_FlashProp_st[xPhySectIdx_u8].Fee_PhysEndAddress_u32;
	sha	d15,#4
.L702:
	addsc.a	a15,a2,d15,#0
.L1047:
	ld.w	d15,[a15]4
.L1048:
	st.w	[a14],d15
.L1049:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2892  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2893                          xNumBytes_u16 = 1u;
	mov	d15,#1
.L1050:
	st.h	[a12],d15
.L289:
.L288:
.L287:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2894                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2895                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2896  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2897                  /* Read the checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2898                  if(Fls_Read(Fee_RdWrOrder_st.xCrcAddress, (uint8*)&Fee_PageBytePtr_cpu8[0], xNumBytes_u16) != E_NOT_OK)
	movh.a	a15,#@his(Fee_PageBytePtr_cpu8)
	lea	a15,[a15]@los(Fee_PageBytePtr_cpu8)
	ld.w	d4,[a14]
	ld.a	a4,[a15]
	ld.hu	d5,[a12]0
	call	Fls_17_Pmu_Read
.L1051:
	jeq	d2,#1,.L290
.L1052:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2899                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2900                      /* Set the next state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2901                      Fee_RdWrOrder_st.Fee_LLCalcCrcBlk_en = FEE_LL_CRC_RD_ROB_PAGE_WAIT_E;
	mov	d15,#6
.L1053:
	ld.a	a15,[a10]8
	st.w	[a15],d15
.L1054:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2902  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2903                      /* Increment the read address for the next Fls access (overflow is checked automatically) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2904                      Fee_IncAddressInsideSector(&Fee_RdWrOrder_st.xCrcAddress, xNumBytes_u16, FALSE);
	ld.hu	d4,[a12]0
.L1055:
	mov	d5,#0
	mov.aa	a4,a14
	call	Fee_IncAddressInsideSector
.L1056:
	j	.L291
.L290:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2905                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2906                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2907                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2908                      /* Abort the function due to invalid Fls parameters or a busy Fls */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2909                      xRetVal_en = FEE_ABORTED_E;
	mov	d8,#6
.L291:
	j	.L292
.L285:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2910                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2911              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2912              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2913              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2914                  /* Reading is finished, compare the checksums */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2915                  if(xBlkRobCrc32_u32 == xBlkCrc32_u32)
	movh.a	a15,#@his(_999006_xBlkCrc32_u32)
	lea	a15,[a15]@los(_999006_xBlkCrc32_u32)
.L1057:
	movh.a	a2,#@his(_999009_xBlkRobCrc32_u32)
	lea	a2,[a2]@los(_999009_xBlkRobCrc32_u32)
	ld.w	d15,[a2]
.L1058:
	ld.w	d0,[a15]
.L1059:
	jne	d15,d0,.L293
.L1060:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2916                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2917                      /* Update the address in the cache (the function will not change any
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2918                       * entries in case an unknown block is checked during an
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2919                       * "afterburner" run in the reorganization) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2920                      Fee_LLUpdateAddressInCache(HeaderInfo_pcst->FeeIndex_u16,
	ld.a	a15,[a10]
.L703:
	ld.hu	d4,[a15]12
.L1061:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2921                                                 HeaderInfo_pcst->AdrBlkHeader_u32);
	ld.w	d5,[a15]
	call	Fee_LLUpdateAddressInCache
.L1062:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2922  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2923  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2924                      /* The calculated checksum is equal compared to the checksum in the block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2925                      xRetVal_en = FEE_ORDER_FINISHED_E;
	mov	d8,#1
.L1063:
	j	.L294
.L293:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2926                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2927                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2928                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2929                      /* Check the necessity of marking the cache as temporary invalid.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2930                       * This is necessary in all cases (standard read and sector reorg for known blocks)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2931                       * besides a forced read action. An update of the cache for unkown blocks during the
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2932                       * sector reorganization does not effect the cache. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2933                      if((Fee_Rb_WorkingState_en == FEE_RB_READ_MODE_E) &&
	movh.a	a15,#@his(Fee_Rb_WorkingState_en)
	lea	a15,[a15]@los(Fee_Rb_WorkingState_en)
	ld.w	d15,[a15]
.L1064:
	jne	d15,#2,.L295
.L1065:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2934                         (Fee_OrderFifo_st[Fee_idxActQueue_u8].Mode_en == FEE_FORCED_READ_ORDER))
	movh.a	a15,#@his(Fee_idxActQueue_u8)
	lea	a15,[a15]@los(Fee_idxActQueue_u8)
	ld.bu	d15,[a15]
.L1066:
	mul	d15,d15,#24
.L1067:
	movh.a	a15,#@his(Fee_OrderFifo_st)
	lea	a15,[a15]@los(Fee_OrderFifo_st)
.L1068:
	addsc.a	a15,a15,d15,#0
.L1069:
	ld.w	d15,[a15]12
.L1070:
	jne	d15,#5,.L296
.L1071:
	j	.L297
.L296:
.L295:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2935                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2936                          /* Do not mark the cache as temporary invalid for not loosing the block
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2937                           * during a reorganization after an interruption */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2938                          ;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2939                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2940                      else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2941                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2942                          /* Update the cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2943                          Fee_LLUpdateAddressInCache(HeaderInfo_pcst->FeeIndex_u16,
	ld.a	a15,[a10]
.L704:
	ld.hu	d4,[a15]12
.L1072:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2944                                                     FEE_CACHE_TMP_INVALID_VALUE);
	mov.u	d5,#51966
	addih	d5,d5,#45054
	call	Fee_LLUpdateAddressInCache
.L297:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2945                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2946  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2947                      /* Set return value */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2948                      xRetVal_en = FEE_ERROR_E;
	mov	d8,#3
.L294:
.L292:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2949                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2950              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2951          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2952          break;
	j	.L298

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2953          /* FEE_ROB_FEATURE_ACTIVE != FALSE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2954          #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2955  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2956          /* Default state should never be reached */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2957          default:
.L227:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2958          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2959              /* Check if this is a "standard" reorganization case */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2960              if(Fee_Prv_stReorg_u8 == FEE_PRV_ST_REORG_STANDARD_RUNNING)
	movh.a	a15,#@his(Fee_Prv_stReorg_u8)
	lea	a15,[a15]@los(Fee_Prv_stReorg_u8)
	ld.bu	d15,[a15]
.L1073:
	jne	d15,#1,.L299
.L1074:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2961              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2962                  /* Invalidate the cache entry (this is important for the
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2963                   * sector reorganization. The cache should never point into an
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2964                   * erased sector. This block will be skipped anyhow and
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2965                   * the eldest FULL sector will be erased afterwards) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2966                  Fee_LLInvalidateAddressInCache(HeaderInfo_pcst->FeeIndex_u16);
	ld.a	a15,[a10]
.L705:
	ld.hu	d4,[a15]12
	mov.u	d5,#45054
	addih	d5,d5,#51966
	call	Fee_LLUpdateAddressInCache
.L299:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2967              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2968  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2969              /* Set return value (wrong Fls access and default is the
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2970               * same return for this function) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2971              xRetVal_en = FEE_ABORTED_E;
	mov	d8,#6
.L1075:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2972          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2973          break;
	j	.L300

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2974      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2975  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2976      /* Check the function return */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2977      if(xRetVal_en != FEE_ORDER_PENDING_E)
.L300:
.L298:
.L281:
.L262:
.L249:
.L246:
.L244:
	jeq	d8,#0,.L301
.L1076:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2978      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2979          /* Reset the state machine */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2980          Fee_RdWrOrder_st.Fee_LLCalcCrcBlk_en = FEE_LL_CRC_BLK_INIT_E;
	mov	d15,#0
.L1077:
	ld.a	a15,[a10]8
	st.w	[a15],d15
.L1078:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2981  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2982          /* Retries for reading the header and the data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2983          Fee_RdWrRetries_u8 = FEE_MAX_RD_WR_COMP_RETRIES;
	movh.a	a15,#@his(Fee_RdWrRetries_u8)
	lea	a15,[a15]@los(Fee_RdWrRetries_u8)
.L1079:
	mov	d15,#3
.L1080:
	st.b	[a15],d15
.L1081:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2984  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2985          #if(FEE_ROB_FEATURE_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2986          /* Init the robustness checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2987          xBlkRobCrc32_u32 = 0;
	movh.a	a15,#@his(_999009_xBlkRobCrc32_u32)
	lea	a15,[a15]@los(_999009_xBlkRobCrc32_u32)
.L1082:
	mov	d15,#0
.L1083:
	st.w	[a15],d15
.L1084:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2988          #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2989  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2990          /* Init the array index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2991          xConfigPropTableIdx_u16 = 0;
	movh.a	a15,#@his(_999007_xConfigPropTableIdx_u16)
	lea	a15,[a15]@los(_999007_xConfigPropTableIdx_u16)
.L1085:
	mov	d15,#0
.L1086:
	st.h	[a15],d15
.L301:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2992      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2993  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2994      return (xRetVal_en);
	mov	d2,d8
.L706:
	j	.L302

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2995  }
.L302:
	ret
.L415:
	
__Fee_LLCalcBlkCrcInFlash_function_end:
	.size	Fee_LLCalcBlkCrcInFlash,__Fee_LLCalcBlkCrcInFlash_function_end-Fee_LLCalcBlkCrcInFlash
.L350:
	; End of function
	
	.sdecl	'.text.rba_FeeFs1_LlBlockHandling.Fee_CalculateNumOfFreeBytesInCurSector',code,cluster('Fee_CalculateNumOfFreeBytesInCurSector')
	.sect	'.text.rba_FeeFs1_LlBlockHandling.Fee_CalculateNumOfFreeBytesInCurSector'
	.align	2
	
	.global	Fee_CalculateNumOfFreeBytesInCurSector

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2996  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2997  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2998  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  2999   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3000   * Fee_CalculateNumOfFreeBytesInCurSector(): Calculate the amount of
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3001   *              bytes until the end of the respective sector is reached
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3002   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3003   * This function calculates the amount of bytes until the respective
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3004   * sector end address is reached depending on the user address.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3005   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3006   * \param    DataEndAdr_u32:        Last data address within one sector
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3007   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3008   * \return   Function result
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3009   * \retval   xNumFreeBytes_u32:     Number of free bytes until the
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3010   *                                  sector end address
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3011   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3012   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3013   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3014   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3015  FUNC(uint32, FEE_CODE) Fee_CalculateNumOfFreeBytesInCurSector(VAR(uint32, FEE_VAR) DataEndAdr_u32)
; Function Fee_CalculateNumOfFreeBytesInCurSector
.L329:
Fee_CalculateNumOfFreeBytesInCurSector:	.type	func
	mov	d8,d4
.L708:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3016  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3017      VAR(uint8, AUTOMATIC)  xPhySecIdx_u8;               /* Physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3018      VAR(uint32, AUTOMATIC) xNumFreeBytes_u32;           /* Amount of free bytes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3019  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3020      /* Get the corresponding physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3021      xPhySecIdx_u8 = Fee_GetPhysSectorByAddress(DataEndAdr_u32);
	mov	d4,d8
	call	Fee_GetPhysSectorByAddress
.L707:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3022  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3023      /* Calculate the number of bytes until the sector end address is reached */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3024      xNumFreeBytes_u32 = (Fee_FlashProp_st[xPhySecIdx_u8].Fee_PhysEndAddress_u32 + 1u) - DataEndAdr_u32;
	sha	d2,#4
.L709:
	movh.a	a15,#@his(Fee_FlashProp_st)
	lea	a15,[a15]@los(Fee_FlashProp_st)
.L722:
	addsc.a	a15,a15,d2,#0
.L723:
	ld.w	d15,[a15]4
	sub	d15,d8
	add	d2,d15,#1
.L710:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3025  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3026      /* Do only consider complete pages */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3027      if(xNumFreeBytes_u32 < FEE_PAGE_LEN)
	ge.u	d15,d2,#8
.L724:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3028      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3029          /* Reset the amount of bytes because only complete pages can be written */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3030          xNumFreeBytes_u32 = 0;
	cmovn	d2,d15,#0
.L303:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3031      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3032  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3033      return (xNumFreeBytes_u32);
	j	.L304

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3034  }
.L304:
	ret
.L397:
	
__Fee_CalculateNumOfFreeBytesInCurSector_function_end:
	.size	Fee_CalculateNumOfFreeBytesInCurSector,__Fee_CalculateNumOfFreeBytesInCurSector_function_end-Fee_CalculateNumOfFreeBytesInCurSector
.L340:
	; End of function
	
	.sdecl	'.text.rba_FeeFs1_LlBlockHandling.Fee_CheckFlsJobResult',code,cluster('Fee_CheckFlsJobResult')
	.sect	'.text.rba_FeeFs1_LlBlockHandling.Fee_CheckFlsJobResult'
	.align	2
	
	.global	Fee_CheckFlsJobResult

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3035  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3036  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3037  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3038   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3039   * Fee_CheckFlsJobResult(): Poll the Fls job result
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3040   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3041   * This function polls the Fls job result in case the callback
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3042   * notifications are not used and the polling module's polling mode
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3043   * is used instead.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3044   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3045   * \param    none
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3046   * \return   none
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3047   * \retval
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3048   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3049   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3050   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3051   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3052  #if (STD_ON == FEE_POLLING_MODE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3053  FUNC(void, FEE_CODE) Fee_CheckFlsJobResult(void)
; Function Fee_CheckFlsJobResult
.L331:
Fee_CheckFlsJobResult:	.type	func

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3054  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3055      VAR(MemIf_JobResultType, AUTOMATIC) FlsJobResult = MEMIF_JOB_PENDING;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3056  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3057      /* Get the job result of the last Fls order */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3058      FlsJobResult = Fls_GetJobResult();
	call	Fls_17_Pmu_GetJobResult
.L711:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3059  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3060      /* Check if the result is still pending or not */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3061      if(FlsJobResult != MEMIF_JOB_PENDING)
	jeq	d2,#2,.L305
.L1650:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3062      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3063          /* The last order was finished with or without success,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3064           * it is possible to check the result now */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3065          if(FlsJobResult == MEMIF_JOB_OK)
	jne	d2,#0,.L306
.L1651:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3066          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3067              /* Job was finished without any errors, call the Fee internal
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3068               * function to switch the respective state machine */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3069              Fee_SwitchJobEndNotification();
	call	Fee_SwitchJobEndNotification
.L712:
	j	.L307
.L306:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3070          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3071          else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3072          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3073              /* Job was finished with an error, call the Fee internal
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3074               * function to switch the respective state machine */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3075              Fee_SwitchJobErrorNotification();
	call	Fee_SwitchJobErrorNotification
.L307:
.L305:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3076          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3077      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3078  }
	ret
.L486:
	
__Fee_CheckFlsJobResult_function_end:
	.size	Fee_CheckFlsJobResult,__Fee_CheckFlsJobResult_function_end-Fee_CheckFlsJobResult
.L395:
	; End of function
	
	.sdecl	'.data.rba_FeeFs1_LlBlockHandling._999001_xHeaderAddr_u32',data,cluster('_999001_xHeaderAddr_u32')
	.sect	'.data.rba_FeeFs1_LlBlockHandling._999001_xHeaderAddr_u32'
	.align	4
_999001_xHeaderAddr_u32:	.type	object
	.size	_999001_xHeaderAddr_u32,4
	.word	-1
	.sdecl	'.data.rba_FeeFs1_LlBlockHandling._999002_xSectOverflow_b',data,cluster('_999002_xSectOverflow_b')
	.sect	'.data.rba_FeeFs1_LlBlockHandling._999002_xSectOverflow_b'
_999002_xSectOverflow_b:	.type	object
	.size	_999002_xSectOverflow_b,1
	.space	1
	.sdecl	'.data.rba_FeeFs1_LlBlockHandling._999003_xCntRetry_u8',data,cluster('_999003_xCntRetry_u8')
	.sect	'.data.rba_FeeFs1_LlBlockHandling._999003_xCntRetry_u8'
_999003_xCntRetry_u8:	.type	object
	.size	_999003_xCntRetry_u8,1
	.byte	3
	.sdecl	'.bss.rba_FeeFs1_LlBlockHandling._999004_cntProgrammedBytes_u32',data,cluster('_999004_cntProgrammedBytes_u32')
	.sect	'.bss.rba_FeeFs1_LlBlockHandling._999004_cntProgrammedBytes_u32'
	.align	4
_999004_cntProgrammedBytes_u32:	.type	object
	.size	_999004_cntProgrammedBytes_u32,4
	.space	4
	.sdecl	'.data.rba_FeeFs1_LlBlockHandling._999005_xNumBytes_u16',data,cluster('_999005_xNumBytes_u16')
	.sect	'.data.rba_FeeFs1_LlBlockHandling._999005_xNumBytes_u16'
	.align	2
_999005_xNumBytes_u16:	.type	object
	.size	_999005_xNumBytes_u16,2
	.space	2
	.sdecl	'.data.rba_FeeFs1_LlBlockHandling._999006_xBlkCrc32_u32',data,cluster('_999006_xBlkCrc32_u32')
	.sect	'.data.rba_FeeFs1_LlBlockHandling._999006_xBlkCrc32_u32'
	.align	4
_999006_xBlkCrc32_u32:	.type	object
	.size	_999006_xBlkCrc32_u32,4
	.space	4
	.sdecl	'.data.rba_FeeFs1_LlBlockHandling._999007_xConfigPropTableIdx_u16',data,cluster('_999007_xConfigPropTableIdx_u16')
	.sect	'.data.rba_FeeFs1_LlBlockHandling._999007_xConfigPropTableIdx_u16'
	.align	2
_999007_xConfigPropTableIdx_u16:	.type	object
	.size	_999007_xConfigPropTableIdx_u16,2
	.space	2
	.sdecl	'.data.rba_FeeFs1_LlBlockHandling._999008_xFirstCRCRunDone_b',data,cluster('_999008_xFirstCRCRunDone_b')
	.sect	'.data.rba_FeeFs1_LlBlockHandling._999008_xFirstCRCRunDone_b'
_999008_xFirstCRCRunDone_b:	.type	object
	.size	_999008_xFirstCRCRunDone_b,1
	.space	1
	.sdecl	'.data.rba_FeeFs1_LlBlockHandling._999009_xBlkRobCrc32_u32',data,cluster('_999009_xBlkRobCrc32_u32')
	.sect	'.data.rba_FeeFs1_LlBlockHandling._999009_xBlkRobCrc32_u32'
	.align	4
_999009_xBlkRobCrc32_u32:	.type	object
	.size	_999009_xBlkRobCrc32_u32,4
	.space	4
	.calls	'Fee_LLCompBlkInFlash','Fls_17_Pmu_Compare'
	.calls	'Fee_LLCompBlkInFlash','Fee_IncAddressInsideSector'
	.calls	'Fee_LLCompBlkInFlash','Fls_17_Pmu_MainFunction'
	.calls	'Fee_LLCompBlkInFlash','Fee_CheckFlsJobResult'
	.calls	'Fee_LLCompBlkInFlash','Fee_GetPhysSectorByAddress'
	.calls	'Fee_LLCompBlkInFlash','Fee_CalculateNumOfFreeBytesInCurSector'
	.calls	'Fee_LLCompBlkInFlash','Fee_LLUpdateAddressInCache'
	.calls	'Fee_LLPrepPageBufWithHdrDataStart','Crc_CalculateCRC16'
	.calls	'Fee_LLPrepPageBufWithHdrDataEnd','Crc_CalculateCRC32'
	.calls	'Fee_LLCopyData2Buffer','Fee_GetPhysSectorByAddress'
	.calls	'Fee_LLCopyData2Buffer','Fls_17_Pmu_Read'
	.calls	'Fee_LLCopyData2Buffer','Fee_IncAddressInsideSector'
	.calls	'Fee_LLCopyData2Buffer','Fls_17_Pmu_MainFunction'
	.calls	'Fee_LLCopyData2Buffer','Fee_CheckFlsJobResult'
	.calls	'Fee_LLCpyBlkFromFls2Fls','Fee_GetPhysSectorByAddress'
	.calls	'Fee_LLCpyBlkFromFls2Fls','Fee_CalculateNumOfFreeBytesInCurSector'
	.calls	'Fee_LLCpyBlkFromFls2Fls','Fee_LLSetEraseSector'
	.calls	'Fee_LLCpyBlkFromFls2Fls','Fls_17_Pmu_Read'
	.calls	'Fee_LLCpyBlkFromFls2Fls','Fee_IncAddressInsideSector'
	.calls	'Fee_LLCpyBlkFromFls2Fls','Fee_LLUpdateAddressInCache'
	.calls	'Fee_LLCpyBlkFromFls2Fls','Fee_SrvBinarySearchInBlockProp'
	.calls	'Fee_LLCpyBlkFromFls2Fls','Fls_17_Pmu_MainFunction'
	.calls	'Fee_LLCpyBlkFromFls2Fls','Fee_CheckFlsJobResult'
	.calls	'Fee_LLCpyBlkFromFls2Fls','Fls_17_Pmu_Write'
	.calls	'Fee_LLCpyBlkFromFls2Fls','Fee_SrvMemCopy8'
	.calls	'Fee_LLCpyBlkFromFls2Fls','Fls_17_Pmu_Compare'
	.calls	'Fee_LLCpyBlkFromFls2Fls','Fee_LLWriteMarker'
	.calls	'Fee_LLCpyBlkFromFls2Fls','Fee_LLEraseSector'
	.calls	'Fee_LLCpyBlkFromFls2Fls','Fee_LLEraseCacheStForSect'
	.calls	'Fee_LLCpyBlkFromFls2Fls','Fee_LLUpdateCacheStForSect'
	.calls	'Fee_LLCalcBlkCrcInFlash','Fee_SrvMemSet8'
	.calls	'Fee_LLCalcBlkCrcInFlash','Fls_17_Pmu_Read'
	.calls	'Fee_LLCalcBlkCrcInFlash','Fee_IncAddressInsideSector'
	.calls	'Fee_LLCalcBlkCrcInFlash','Fls_17_Pmu_MainFunction'
	.calls	'Fee_LLCalcBlkCrcInFlash','Fee_CheckFlsJobResult'
	.calls	'Fee_LLCalcBlkCrcInFlash','Fee_LLUpdateAddressInCache'
	.calls	'Fee_LLCalcBlkCrcInFlash','Fee_GetPhysSectorByAddress'
	.calls	'Fee_LLCalcBlkCrcInFlash','Crc_CalculateCRC32'
	.calls	'Fee_LLCalcBlkCrcInFlash','Fee_CalculateNumOfFreeBytesInCurSector'
	.calls	'Fee_CalculateNumOfFreeBytesInCurSector','Fee_GetPhysSectorByAddress'
	.calls	'Fee_CheckFlsJobResult','Fls_17_Pmu_GetJobResult'
	.calls	'Fee_CheckFlsJobResult','Fee_SwitchJobEndNotification'
	.calls	'Fee_CheckFlsJobResult','Fee_SwitchJobErrorNotification'
	.calls	'Fee_LLCompBlkInFlash','',8
	.calls	'Fee_LLCopyPageBuff2Marker','',0
	.calls	'Fee_LLPrepMarkerBufWithMarkerData','',0
	.calls	'Fee_LLCopyPageBuff2HeaderMid','',0
	.calls	'Fee_LLCopyPageBuff2HeaderEnd','',0
	.calls	'Fee_LLPrepPageBufWithHdrDataStart','',0
	.calls	'Fee_LLPrepPageBufWithHdrDataEnd','',0
	.calls	'Fee_LLCopyData2Buffer','',8
	.calls	'Fee_LLCpyBlkFromFls2Fls','',16
	.calls	'Fee_LLCalcBlkCrcInFlash','',16
	.calls	'Fee_CalculateNumOfFreeBytesInCurSector','',0
	.extern	Fls_17_Pmu_Write
	.extern	Fls_17_Pmu_Compare
	.extern	Fls_17_Pmu_GetJobResult
	.extern	Fls_17_Pmu_MainFunction
	.extern	Fls_17_Pmu_Read
	.extern	Fee_Rb_WorkingState_en
	.extern	Fee_stMain
	.extern	Fee_FlashProp_st
	.extern	Fee_PageBytePtr_cpu8
	.extern	Fee_RdWrOrder_st
	.extern	Fee_LLSectorOrder_st
	.extern	Fee_OrderFifo_st
	.extern	Fee_GlobInfoWrBlock_st
	.extern	Fee_LLSecReorgStruct_st
	.extern	Fee_Prv_stReorg_u8
	.extern	Fee_NumFlashBanksUsed_u8
	.extern	Fee_hdr2Buffer_au8
	.extern	Fee_idxLLSectorOrder_au8
	.extern	Fee_idxActQueue_u8
	.extern	Fee_RdWrRetries_u8
	.extern	Fee_DataByteStartCrc_u32
	.extern	Fee_BlockProperties_st
	.extern	Fee_GetPhysSectorByAddress
	.extern	Fee_LLWriteMarker
	.extern	Fee_LLEraseSector
	.extern	Fee_LLSetEraseSector
	.extern	Fee_IncAddressInsideSector
	.extern	Fee_LLUpdateAddressInCache
	.extern	Fee_LLUpdateCacheStForSect
	.extern	Fee_LLEraseCacheStForSect
	.extern	Fee_SrvBinarySearchInBlockProp
	.extern	Fee_SrvMemSet8
	.extern	Fee_SrvMemCopy8
	.extern	Fee_SwitchJobEndNotification
	.extern	Fee_SwitchJobErrorNotification
	.extern	Crc_CalculateCRC16
	.extern	Crc_CalculateCRC32
	.calls	'Fee_CheckFlsJobResult','',0
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L333:
	.word	19125
	.half	3
	.word	.L334
	.byte	4
.L332:
	.byte	1
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L335
.L399:
	.byte	2
	.byte	'unsigned char',0,1,8
.L409:
	.byte	2
	.byte	'unsigned short int',0,2,7,3
	.word	176
.L424:
	.byte	4
	.byte	'Fee_SrvBinarySearchInBlockPropFast',0,3,1,197,10,38
	.word	159
	.byte	1,1
.L426:
	.byte	5
	.byte	'FeeIdx_u16',0,1,197,10,96
	.word	176
.L428:
	.byte	5
	.byte	'CacheIdx_pu16',0,1,198,10,113
	.word	198
.L430:
	.byte	6,0
.L396:
	.byte	2
	.byte	'unsigned int',0,4,7,4
	.byte	'Fee_SrvRoundUp',0,3,1,140,11,21
	.word	295
	.byte	1,1,5
	.byte	'value_u32',0,1,140,11,43
	.word	295
	.byte	5
	.byte	'stepsize_u32',0,1,140,11,62
	.word	295
	.byte	6,0,7
	.word	159
.L406:
	.byte	3
	.word	381
	.byte	8
	.byte	'Fls_17_Pmu_Write',0,2,184,6,23
	.word	159
	.byte	1,1,1,1,5
	.byte	'TargetAddress',0,2,184,6,57
	.word	295
	.byte	5
	.byte	'SourceAddressPtr',0,2,185,6,47
	.word	386
	.byte	5
	.byte	'Length',0,2,186,6,49
	.word	295
	.byte	0,8
	.byte	'Fls_17_Pmu_Compare',0,2,216,6,23
	.word	159
	.byte	1,1,1,1,5
	.byte	'SourceAddress',0,2,216,6,59
	.word	295
	.byte	5
	.byte	'TargetAddressPtr',0,2,217,6,42
	.word	386
	.byte	5
	.byte	'Length',0,2,218,6,44
	.word	295
	.byte	0
.L487:
	.byte	9,3,31,9,4,10
	.byte	'MEMIF_JOB_OK',0,0,10
	.byte	'MEMIF_JOB_FAILED',0,1,10
	.byte	'MEMIF_JOB_PENDING',0,2,10
	.byte	'MEMIF_JOB_CANCELED',0,3,10
	.byte	'MEMIF_BLOCK_INCONSISTENT',0,4,10
	.byte	'MEMIF_BLOCK_INVALID',0,5,0,11
	.byte	'Fls_17_Pmu_GetJobResult',0,2,233,7,28
	.word	585
	.byte	1,1,1,1,12
	.byte	'Fls_17_Pmu_MainFunction',0,2,134,8,13,1,1,1,1
.L447:
	.byte	3
	.word	159
	.byte	8
	.byte	'Fls_17_Pmu_Read',0,2,192,8,23
	.word	159
	.byte	1,1,1,1,5
	.byte	'SourceAddress',0,2,192,8,56
	.word	295
	.byte	5
	.byte	'TargetAddressPtr',0,2,193,8,40
	.word	785
	.byte	5
	.byte	'Length',0,2,194,8,48
	.word	295
	.byte	0,8
	.byte	'Fee_GetPhysSectorByAddress',0,1,171,8,31
	.word	159
	.byte	1,1,1,1,5
	.byte	'Address_u32',0,1,171,8,81
	.word	295
	.byte	0
.L402:
	.byte	9,1,137,2,9,4,10
	.byte	'FEE_ORDER_PENDING_E',0,0,10
	.byte	'FEE_ORDER_FINISHED_E',0,1,10
	.byte	'FEE_BLOCK_INVALIDATED_E',0,2,10
	.byte	'FEE_ERROR_E',0,3,10
	.byte	'FEE_SECTORCHANGE_E',0,4,10
	.byte	'FEE_SECTORFULL_E',0,5,10
	.byte	'FEE_ABORTED_E',0,6,10
	.byte	'FEE_ERASE_SECTOR_E',0,7,10
	.byte	'FEE_SEARCH_ABORTED_E',0,8,10
	.byte	'FEE_NUM_RET_VAL_E',0,9,0,8
	.byte	'Fee_LLWriteMarker',0,1,174,8,41
	.word	947
	.byte	1,1,1,1,5
	.byte	'PhySectIdx_u8',0,1,174,8,81
	.word	159
	.byte	5
	.byte	'MarkerID_u8',0,1,175,8,81
	.word	159
	.byte	0,11
	.byte	'Fee_LLEraseSector',0,1,178,8,41
	.word	947
	.byte	1,1,1,1,13
	.byte	'Fee_LLSetEraseSector',0,1,179,8,41,1,1,1,1,5
	.byte	'EraseLogIdx',0,1,179,8,84
	.word	159
	.byte	0,14,1,227,5,9,16,15
	.byte	'AdrBlkHeader_u32',0
	.word	295
	.byte	4,2,35,0,15
	.byte	'BlkCrc32_u32',0
	.word	295
	.byte	4,2,35,4,15
	.byte	'HdrCrc16_u16',0
	.word	176
	.byte	2,2,35,8,15
	.byte	'BlkLength_u16',0
	.word	176
	.byte	2,2,35,10,15
	.byte	'FeeIndex_u16',0
	.word	176
	.byte	2,2,35,12,15
	.byte	'BlkStatus_u8',0
	.word	159
	.byte	1,2,35,14,0,7
	.word	1318
.L404:
	.byte	3
	.word	1462
	.byte	16,3
	.word	159
	.byte	17,2,0,14,1,225,1,9,8,15
	.byte	'xPattern',0
	.word	176
	.byte	2,2,35,0,15
	.byte	'xIdent',0
	.word	159
	.byte	1,2,35,2,15
	.byte	'xContent',0
	.word	1472
	.byte	3,2,35,3,15
	.byte	'xChecksum',0
	.word	176
	.byte	2,2,35,6,0,7
	.word	1481
.L450:
	.byte	3
	.word	1559
.L454:
	.byte	3
	.word	1481
.L458:
	.byte	3
	.word	1318
	.byte	14,1,151,6,9,16,15
	.byte	'Preamble_au8',0
	.word	1472
	.byte	3,2,35,0,15
	.byte	'BlkStatus_u8',0
	.word	159
	.byte	1,2,35,3,15
	.byte	'FeeIndex_u16',0
	.word	176
	.byte	2,2,35,4,15
	.byte	'BlkLength_u16',0
	.word	176
	.byte	2,2,35,6,15
	.byte	'HdrCrc16_u16',0
	.word	176
	.byte	2,2,35,8,15
	.byte	'BlkCrc32_u32',0
	.word	295
	.byte	4,2,35,12,0
.L468:
	.byte	3
	.word	1579
	.byte	3
	.word	295
	.byte	13
	.byte	'Fee_IncAddressInsideSector',0,1,129,9,41,1,1,1,1,5
	.byte	'Address_u32',0,1,129,9,108
	.word	1724
	.byte	5
	.byte	'numBytes_u16',0,1,130,9,89
	.word	176
	.byte	5
	.byte	'EnsurePageAlign_b',0,1,131,9,90
	.word	159
	.byte	0,13
	.byte	'Fee_LLUpdateAddressInCache',0,1,163,9,31,1,1,1,1,5
	.byte	'FeeIdx_u16',0,1,163,9,81
	.word	176
	.byte	5
	.byte	'Addr_u32',0,1,164,9,81
	.word	295
	.byte	0,13
	.byte	'Fee_LLUpdateCacheStForSect',0,1,165,9,30,1,1,1,1,5
	.byte	'PhySecIdx_u8',0,1,165,9,79
	.word	159
	.byte	0,13
	.byte	'Fee_LLEraseCacheStForSect',0,1,166,9,30,1,1,1,1,5
	.byte	'PhySecIdx_u8',0,1,166,9,78
	.word	159
	.byte	0,8
	.byte	'Fee_SrvBinarySearchInBlockProp',0,1,169,9,32
	.word	159
	.byte	1,1,1,1,5
	.byte	'FeeIdx_u16',0,1,169,9,86
	.word	176
	.byte	5
	.byte	'CacheIdx_pu16',0,1,170,9,103
	.word	198
	.byte	0,18
	.word	203
	.byte	19
	.word	250
	.byte	19
	.word	270
	.byte	6,0,13
	.byte	'Fee_SrvMemSet8',0,1,191,9,30,1,1,1,1,5
	.byte	'xDest_pu8',0,1,191,9,84
	.word	785
	.byte	5
	.byte	'xPattern_u32',0,1,192,9,66
	.word	295
	.byte	5
	.byte	'numBytes_u32',0,1,193,9,66
	.word	295
	.byte	0,13
	.byte	'Fee_SrvMemCopy8',0,1,194,9,30,1,1,1,1,5
	.byte	'xDest_pu8',0,1,194,9,85
	.word	785
	.byte	5
	.byte	'xSrc_pcu8',0,1,195,9,87
	.word	386
	.byte	5
	.byte	'numBytes_u32',0,1,196,9,67
	.word	295
	.byte	0,18
	.word	311
	.byte	19
	.word	338
	.byte	19
	.word	357
	.byte	6,0,12
	.byte	'Fee_SwitchJobEndNotification',0,4,59,29,1,1,1,1,12
	.byte	'Fee_SwitchJobErrorNotification',0,4,88,29,1,1,1,1,8
	.byte	'Crc_CalculateCRC16',0,5,80,15
	.word	176
	.byte	1,1,1,1,5
	.byte	'Crc_DataPtr',0,5,80,47
	.word	386
	.byte	5
	.byte	'Crc_Length',0,5,80,67
	.word	295
	.byte	5
	.byte	'Crc_StartValue16',0,5,80,86
	.word	176
	.byte	5
	.byte	'Crc_IsFirstCall',0,5,81,42
	.word	159
	.byte	0,8
	.byte	'Crc_CalculateCRC32',0,6,80,15
	.word	295
	.byte	1,1,1,1,5
	.byte	'Crc_DataPtr',0,6,80,47
	.word	386
	.byte	5
	.byte	'Crc_Length',0,6,80,67
	.word	295
	.byte	5
	.byte	'Crc_StartValue32',0,6,80,86
	.word	295
	.byte	5
	.byte	'Crc_IsFirstCall',0,6,81,42
	.word	159
	.byte	0,20,1,3
	.word	2640
	.byte	21
	.byte	'__codeptr',0,7,1,1
	.word	2642
	.byte	2
	.byte	'char',0,1,6,21
	.byte	'sint8',0,8,76,25
	.word	2665
	.byte	21
	.byte	'uint8',0,8,81,25
	.word	159
	.byte	21
	.byte	'uint16',0,8,91,25
	.word	176
	.byte	21
	.byte	'uint32',0,8,106,24
	.word	295
	.byte	2
	.byte	'unsigned long long int',0,8,7,21
	.byte	'uint64',0,8,111,30
	.word	2731
	.byte	21
	.byte	'boolean',0,8,127,25
	.word	159
	.byte	21
	.byte	'StatusType',0,9,191,1,27
	.word	159
	.byte	21
	.byte	'Std_ReturnType',0,9,199,1,15
	.word	159
	.byte	14,9,206,1,9,8,15
	.byte	'vendorID',0
	.word	176
	.byte	2,2,35,0,15
	.byte	'moduleID',0
	.word	176
	.byte	2,2,35,2,15
	.byte	'sw_major_version',0
	.word	159
	.byte	1,2,35,4,15
	.byte	'sw_minor_version',0
	.word	159
	.byte	1,2,35,5,15
	.byte	'sw_patch_version',0
	.word	159
	.byte	1,2,35,6,0,21
	.byte	'Std_VersionInfoType',0,9,213,1,3
	.word	2832
	.byte	14,10,93,9,8,15
	.byte	'Class',0
	.word	159
	.byte	1,2,35,0,15
	.byte	'TIN',0
	.word	159
	.byte	1,2,35,1,15
	.byte	'ReturnAddress',0
	.word	295
	.byte	4,2,35,4,0,21
	.byte	'OsTrapInfoType',0,10,97,3
	.word	2982
	.byte	16,68
	.word	295
	.byte	17,16,0,14,10,154,1,9,68,15
	.byte	'store',0
	.word	3062
	.byte	68,2,35,0,0,16,68
	.word	3071
	.byte	17,0,0,21
	.byte	'Os_JumpBufType',0,10,156,1,3
	.word	3093
	.byte	21
	.byte	'Os_StackTraceType',0,10,174,1,18
	.word	295
	.byte	14,10,175,1,9,8,15
	.byte	'sp',0
	.word	295
	.byte	4,2,35,0,15
	.byte	'ctx',0
	.word	295
	.byte	4,2,35,4,0,21
	.byte	'Os_StackValueType',0,10,175,1,63
	.word	3153
	.byte	21
	.byte	'Os_StackSizeType',0,10,176,1,27
	.word	3153
	.byte	22,1,1,3
	.word	3238
	.byte	21
	.byte	'Os_VoidVoidFunctionType',0,10,179,1,16
	.word	3241
	.byte	21
	.byte	'ApplicationType',0,10,193,1,23
	.word	159
	.byte	23
	.byte	'Os_ApplicationConfigurationType_s',0,10,198,1,16,2,15
	.byte	'app_id',0
	.word	159
	.byte	1,2,35,0,15
	.byte	'access',0
	.word	159
	.byte	1,2,35,1,0,21
	.byte	'Os_ApplicationConfigurationType',0,10,201,1,3
	.word	3304
	.byte	21
	.byte	'Os_CoreStateType',0,10,203,1,16
	.word	295
	.byte	21
	.byte	'AreaIdType',0,10,204,1,16
	.word	176
	.byte	21
	.byte	'Os_PeripheralAddressType',0,10,212,1,22
	.word	295
	.byte	21
	.byte	'TickType',0,10,221,1,22
	.word	295
	.byte	21
	.byte	'Os_StopwatchTickType',0,10,225,1,22
	.word	295
	.byte	21
	.byte	'Os_Lockable',0,10,234,1,18
	.word	1724
	.byte	21
	.byte	'CoreIdType',0,10,236,1,16
	.word	176
	.byte	21
	.byte	'SpinlockIdType',0,10,237,1,16
	.word	176
	.byte	9,10,239,1,9,4,10
	.byte	'TRYTOGETSPINLOCK_SUCCESS',0,0,10
	.byte	'TRYTOGETSPINLOCK_NOSUCCESS',0,1,0,21
	.byte	'TryToGetSpinlockType',0,10,239,1,74
	.word	3611
	.byte	9,10,174,2,9,4,10
	.byte	'APPLICATION_ACCESSIBLE',0,0,10
	.byte	'APPLICATION_RESTARTING',0,1,10
	.byte	'APPLICATION_TERMINATED',0,2,0,21
	.byte	'ApplicationStateType',0,10,174,2,92
	.word	3704
	.byte	24
	.byte	'void',0,3
	.word	3816
	.byte	25,1,1,26
	.word	159
	.byte	26
	.word	3822
	.byte	0,3
	.word	3827
	.byte	21
	.byte	'Os_FunctionEntryType',0,10,183,2,16
	.word	3841
	.byte	23
	.byte	'Os_MeterInfoType_s',0,10,193,2,16,48,15
	.byte	'elapsed',0
	.word	295
	.byte	4,2,35,0,15
	.byte	'previous',0
	.word	295
	.byte	4,2,35,4,15
	.byte	'max',0
	.word	295
	.byte	4,2,35,8,15
	.byte	'cumulative',0
	.word	295
	.byte	4,2,35,12,15
	.byte	'stackbase',0
	.word	3153
	.byte	8,2,35,16,15
	.byte	'stackusage',0
	.word	3153
	.byte	8,2,35,24,15
	.byte	'stackmax',0
	.word	3153
	.byte	8,2,35,32,15
	.byte	'stackbudget',0
	.word	3153
	.byte	8,2,35,40,0,21
	.byte	'Os_MeterInfoType',0,10,202,2,3
	.word	3876
	.byte	3
	.word	3876
	.byte	21
	.byte	'Os_MeterInfoRefType',0,10,203,2,50
	.word	4074
	.byte	21
	.byte	'EventMaskType',0,10,206,2,15
	.word	159
	.byte	21
	.byte	'Os_imaskType',0,10,211,2,16
	.word	295
	.byte	23
	.byte	'Os_ISRDynType_s',0,10,213,2,16,48,15
	.byte	'meter',0
	.word	3876
	.byte	48,2,35,0,0,21
	.byte	'Os_ISRDynType',0,10,215,2,3
	.word	4153
	.byte	3
	.word	4153
	.byte	7
	.word	4214
	.byte	23
	.byte	'Os_ISRType_s',0,10,216,2,16,24,15
	.byte	'entry_function',0
	.word	3246
	.byte	4,2,35,0,15
	.byte	'dynamic',0
	.word	4219
	.byte	4,2,35,4,15
	.byte	'imask',0
	.word	295
	.byte	4,2,35,8,15
	.byte	'stackbudget',0
	.word	3153
	.byte	8,2,35,12,15
	.byte	'access',0
	.word	159
	.byte	1,2,35,20,15
	.byte	'application',0
	.word	159
	.byte	1,2,35,21,0,21
	.byte	'Os_ISRType',0,10,223,2,3
	.word	4224
	.byte	3
	.word	3238
	.byte	7
	.word	4224
	.byte	3
	.word	4383
	.byte	21
	.byte	'ISRType',0,10,224,2,46
	.word	4388
	.byte	21
	.byte	'Os_bitmask',0,10,239,2,22
	.word	295
	.byte	21
	.byte	'Os_pset0Type',0,10,240,2,20
	.word	295
	.byte	21
	.byte	'Os_pset1Type',0,10,241,2,20
	.word	295
	.byte	21
	.byte	'Os_pset2Type',0,10,242,2,20
	.word	295
	.byte	27,10,243,2,9,4,15
	.byte	'p0',0
	.word	295
	.byte	4,2,35,0,15
	.byte	'p1',0
	.word	295
	.byte	4,2,35,0,15
	.byte	'p2',0
	.word	295
	.byte	4,2,35,0,0,21
	.byte	'Os_psetType',0,10,247,2,3
	.word	4496
	.byte	27,10,249,2,9,4,15
	.byte	't0',0
	.word	295
	.byte	4,2,35,0,15
	.byte	't1',0
	.word	295
	.byte	4,2,35,0,15
	.byte	't2',0
	.word	295
	.byte	4,2,35,0,0,21
	.byte	'Os_tpmaskType',0,10,253,2,3
	.word	4560
	.byte	21
	.byte	'Os_ActivationCountType',0,10,254,2,23
	.word	159
	.byte	23
	.byte	'Os_TaskDynType_s',0,10,128,3,16,120,15
	.byte	'terminate_jump_buf',0
	.word	3102
	.byte	68,2,35,0,15
	.byte	'meter',0
	.word	3876
	.byte	48,2,35,68,15
	.byte	'activation_count',0
	.word	159
	.byte	1,2,35,116,0,21
	.byte	'Os_TaskDynType',0,10,132,3,3
	.word	4658
	.byte	16,68
	.word	3071
	.byte	17,0,0,3
	.word	4658
	.byte	7
	.word	4784
	.byte	23
	.byte	'Os_TaskType_s',0,10,134,3,16,40,15
	.byte	'dynamic',0
	.word	4789
	.byte	4,2,35,0,15
	.byte	'entry_function',0
	.word	3246
	.byte	4,2,35,4,15
	.byte	'pset',0
	.word	4496
	.byte	4,2,35,8,15
	.byte	'base_tpmask',0
	.word	4560
	.byte	4,2,35,12,15
	.byte	'tpmask',0
	.word	4560
	.byte	4,2,35,16,15
	.byte	'core_id',0
	.word	176
	.byte	2,2,35,20,15
	.byte	'index',0
	.word	295
	.byte	4,2,35,24,15
	.byte	'stackbudget',0
	.word	3153
	.byte	8,2,35,28,15
	.byte	'activation_count',0
	.word	159
	.byte	1,2,35,36,15
	.byte	'access',0
	.word	159
	.byte	1,2,35,37,15
	.byte	'application',0
	.word	159
	.byte	1,2,35,38,0,21
	.byte	'Os_TaskType',0,10,146,3,3
	.word	4794
	.byte	7
	.word	4794
	.byte	3
	.word	5044
	.byte	21
	.byte	'TaskType',0,10,147,3,47
	.word	5049
	.byte	28
	.byte	'Os_TaskStateType',0,10,155,3,6,4,10
	.byte	'SUSPENDED',0,0,10
	.byte	'READY',0,1,10
	.byte	'WAITING',0,2,10
	.byte	'RUNNING',0,3,0,21
	.byte	'TaskStateType',0,10,156,3,31
	.word	5072
	.byte	27,10,167,3,3,4,15
	.byte	'tpmask',0
	.word	4560
	.byte	4,2,35,0,0,23
	.byte	'Os_ResourceDynType_s',0,10,166,3,16,4,15
	.byte	'saved_priority',0
	.word	5159
	.byte	4,2,35,0,0,21
	.byte	'Os_ResourceDynType',0,10,170,3,3
	.word	5182
	.byte	3
	.word	5182
	.byte	7
	.word	5262
	.byte	23
	.byte	'Os_ResourceType_s',0,10,171,3,16,12,15
	.byte	'dynamic',0
	.word	5267
	.byte	4,2,35,0,15
	.byte	'tpmask',0
	.word	4560
	.byte	4,2,35,4,15
	.byte	'access',0
	.word	159
	.byte	1,2,35,8,0,21
	.byte	'Os_ResourceType',0,10,175,3,3
	.word	5272
	.byte	14,10,181,3,9,12,15
	.byte	'maxallowedvalue',0
	.word	295
	.byte	4,2,35,0,15
	.byte	'ticksperbase',0
	.word	295
	.byte	4,2,35,4,15
	.byte	'mincycle',0
	.word	295
	.byte	4,2,35,8,0,21
	.byte	'AlarmBaseType',0,10,185,3,3
	.word	5371
	.byte	14,10,206,3,9,8,15
	.byte	'Running',0
	.word	159
	.byte	1,2,35,0,15
	.byte	'Pending',0
	.word	159
	.byte	1,2,35,1,15
	.byte	'Delay',0
	.word	295
	.byte	4,2,35,4,0,21
	.byte	'Os_CounterStatusType',0,10,210,3,3
	.word	5466
	.byte	29
	.word	159
	.byte	1,1,3
	.word	5552
	.byte	21
	.byte	'Os_CounterIncrAdvType',0,10,217,3,22
	.word	5559
	.byte	23
	.byte	's_swd',0,10,222,3,12,4,15
	.byte	'count',0
	.word	295
	.byte	4,2,35,0,0,27,10,221,3,3,4,15
	.byte	'sw',0
	.word	5595
	.byte	4,2,35,0,0,23
	.byte	'Os_CounterDynType_s',0,10,220,3,16,4,15
	.byte	'type_dependent',0
	.word	5623
	.byte	4,2,35,0,0,21
	.byte	'Os_CounterDynType',0,10,226,3,3
	.word	5642
	.byte	3
	.word	5642
	.byte	7
	.word	5720
	.byte	23
	.byte	'Os_CounterType_s',0,10,227,3,16,28,15
	.byte	'dynamic',0
	.word	5725
	.byte	4,2,35,0,15
	.byte	'advincr',0
	.word	5564
	.byte	4,2,35,4,15
	.byte	'base',0
	.word	5371
	.byte	12,2,35,8,15
	.byte	'core',0
	.word	3822
	.byte	4,2,35,20,15
	.byte	'access',0
	.word	159
	.byte	1,2,35,24,15
	.byte	'application',0
	.word	159
	.byte	1,2,35,25,0,21
	.byte	'Os_CounterType',0,10,234,3,3
	.word	5730
	.byte	3
	.word	5552
	.byte	7
	.word	5730
	.byte	3
	.word	5882
	.byte	21
	.byte	'CounterType',0,10,235,3,52
	.word	5887
	.byte	28
	.byte	'Os_ScheduleTableStatusType',0,10,240,3,6,4,10
	.byte	'SCHEDULETABLE_STOPPED',0,0,10
	.byte	'SCHEDULETABLE_NEXT',0,1,10
	.byte	'SCHEDULETABLE_WAITING',0,2,10
	.byte	'SCHEDULETABLE_RUNNING',0,3,10
	.byte	'SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS',0,4,0,21
	.byte	'ScheduleTableStatusType',0,10,241,3,41
	.word	5913
	.byte	7
	.word	.L713-.L333
	.byte	3
	.word	6113
	.byte	21
	.byte	'ScheduleTableType',0,10,128,4,58
	.word	6118
	.byte	23
	.byte	'Os_ScheduleTableDynType_s',0,10,130,4,16,16,15
	.byte	'match',0
	.word	295
	.byte	4,2,35,0,15
	.byte	'next',0
	.word	6123
	.byte	4,2,35,4,15
	.byte	'state',0
	.word	5913
	.byte	4,2,35,8,15
	.byte	'config',0
	.word	176
	.byte	2,2,35,12,0,3
	.word	6150
	.byte	7
	.word	6243
.L713:
	.byte	23
	.byte	'Os_ScheduleTableType_s',0,10,247,3,16,16,15
	.byte	'dynamic',0
	.word	6248
	.byte	4,2,35,0,15
	.byte	'counter',0
	.word	5892
	.byte	4,2,35,4,15
	.byte	'repeat',0
	.word	159
	.byte	1,2,35,8,15
	.byte	'config',0
	.word	176
	.byte	2,2,35,10,15
	.byte	'initial',0
	.word	159
	.byte	1,2,35,12,15
	.byte	'access',0
	.word	159
	.byte	1,2,35,13,15
	.byte	'application',0
	.word	159
	.byte	1,2,35,14,0,21
	.byte	'Os_ScheduleTableType',0,10,255,3,3
	.word	6253
	.byte	7
	.word	6253
	.byte	3
	.word	6433
	.byte	7
	.word	5730
	.byte	3
	.word	6443
	.byte	30
	.word	3546
	.byte	30
	.word	4496
	.byte	30
	.word	4393
	.byte	30
	.word	5054
	.byte	30
	.word	4560
	.byte	30
	.word	159
	.byte	30
	.word	5054
	.byte	23
	.byte	'Os_ControlledCoreType_s',0,10,251,6,16,112,15
	.byte	'TrapInfo',0
	.word	2982
	.byte	8,2,35,0,15
	.byte	'lock_taskaccess',0
	.word	6453
	.byte	4,2,35,8,15
	.byte	'ReadyTasks',0
	.word	6458
	.byte	4,2,35,12,15
	.byte	'RunningISR',0
	.word	6463
	.byte	4,2,35,16,15
	.byte	'RunningTask',0
	.word	6468
	.byte	4,2,35,20,15
	.byte	'RunningTPMask',0
	.word	6473
	.byte	4,2,35,24,15
	.byte	'CurrentMeteredObject',0
	.word	4079
	.byte	4,2,35,28,15
	.byte	'IdleMeter',0
	.word	3876
	.byte	48,2,35,32,15
	.byte	'AppAccess',0
	.word	159
	.byte	1,2,35,80,15
	.byte	'AppOverride',0
	.word	6478
	.byte	1,2,35,81,15
	.byte	'GetStackValueAdjust',0
	.word	3153
	.byte	8,2,35,84,15
	.byte	'InErrorHook',0
	.word	159
	.byte	1,2,35,92,15
	.byte	'ChainTaskRef',0
	.word	6483
	.byte	4,2,35,96,15
	.byte	'GetStackUsageAdjust',0
	.word	3153
	.byte	8,2,35,100,15
	.byte	'InProtectionHook',0
	.word	159
	.byte	1,2,35,108,15
	.byte	'CoreIsActive',0
	.word	159
	.byte	1,2,35,109,15
	.byte	'InShutdownHook',0
	.word	159
	.byte	1,2,35,110,0,21
	.byte	'Os_ControlledCoreType',0,10,141,7,3
	.word	6488
	.byte	3
	.word	295
	.byte	7
	.word	4224
	.byte	3
	.word	6944
	.byte	7
	.word	4794
	.byte	3
	.word	6954
	.byte	3
	.word	3876
	.byte	23
	.byte	'Os_AnyCoreType_s',0,10,151,7,16,96,15
	.byte	'DisableAllImask',0
	.word	295
	.byte	4,2,35,0,15
	.byte	'SuspendAllImask',0
	.word	295
	.byte	4,2,35,4,15
	.byte	'SuspendOSImask',0
	.word	295
	.byte	4,2,35,8,15
	.byte	'DisableAllCount',0
	.word	295
	.byte	4,2,35,12,15
	.byte	'SuspendAllCount',0
	.word	295
	.byte	4,2,35,16,15
	.byte	'SuspendOSCount',0
	.word	295
	.byte	4,2,35,20,15
	.byte	'RestartJumpBuf',0
	.word	3102
	.byte	68,2,35,24,15
	.byte	'Restartable',0
	.word	159
	.byte	1,2,35,92,0,21
	.byte	'Os_AnyCoreType',0,10,160,7,3
	.word	6969
	.byte	21
	.byte	'unsigned_int',0,11,116,22
	.word	295
	.byte	21
	.byte	'MemIf_JobResultType',0,3,39,2
	.word	585
	.byte	9,3,41,9,4,10
	.byte	'MEMIF_MODE_SLOW',0,0,10
	.byte	'MEMIF_MODE_FAST',0,1,0,21
	.byte	'MemIf_ModeType',0,3,45,2
	.word	7259
	.byte	21
	.byte	'PduIdType',0,12,22,19
	.word	176
	.byte	21
	.byte	'PduLengthType',0,12,26,19
	.word	176
	.byte	9,13,113,9,4,10
	.byte	'TP_DATACONF',0,0,10
	.byte	'TP_DATARETRY',0,1,10
	.byte	'TP_CONFPENDING',0,2,0,21
	.byte	'TpDataStateType',0,13,118,3
	.word	7364
	.byte	21
	.byte	'Can_IdType',0,14,32,16
	.word	295
	.byte	21
	.byte	'Can_HwHandleType',0,14,43,16
	.word	176
	.byte	21
	.byte	'Can_TxObjPriorityClassType',0,15,219,3,16
	.word	295
	.byte	23
	.byte	'Can_TxHwObjectConfigType',0,15,231,3,16,8,15
	.byte	'MsgObjId',0
	.word	159
	.byte	1,2,35,0,15
	.byte	'HwControllerId',0
	.word	159
	.byte	1,2,35,1,15
	.byte	'TxObjPriorityClass',0
	.word	295
	.byte	4,2,35,4,0,21
	.byte	'Can_TxHwObjectConfigType',0,15,252,3,3
	.word	7520
	.byte	23
	.byte	'Can_RxHwObjectConfigType',0,15,129,4,16,12,15
	.byte	'MaskRef',0
	.word	295
	.byte	4,2,35,0,15
	.byte	'MsgId',0
	.word	295
	.byte	4,2,35,4,15
	.byte	'MsgObjId',0
	.word	159
	.byte	1,2,35,8,15
	.byte	'HwControllerId',0
	.word	159
	.byte	1,2,35,9,0,21
	.byte	'Can_RxHwObjectConfigType',0,15,147,4,3
	.word	7656
	.byte	16,4
	.word	159
	.byte	17,3,0,23
	.byte	'Can_ControllerMOMapConfigType',0,15,181,4,16,4,15
	.byte	'ControllerMOMap',0
	.word	7796
	.byte	4,2,35,0,0,21
	.byte	'Can_ControllerMOMapConfigType',0,15,184,4,3
	.word	7805
	.byte	23
	.byte	'Can_NPCRValueType',0,15,188,4,16,2,15
	.byte	'Can_NPCRValue',0
	.word	176
	.byte	2,2,35,0,0,21
	.byte	'Can_NPCRValueType',0,15,191,4,3
	.word	7906
	.byte	23
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,15,194,4,16,8,15
	.byte	'CanControllerBaudrate',0
	.word	295
	.byte	4,2,35,0,15
	.byte	'CanControllerBaudrateCfg',0
	.word	176
	.byte	2,2,35,4,0,21
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,15,198,4,3
	.word	7981
	.byte	7
	.word	7981
	.byte	3
	.word	8146
	.byte	23
	.byte	'Can_BaudrateConfigPtrType',0,15,201,4,16,4,15
	.byte	'Can_kBaudrateConfigPtr',0
	.word	8151
	.byte	4,2,35,0,0,21
	.byte	'Can_BaudrateConfigPtrType',0,15,204,4,3
	.word	8156
	.byte	23
	.byte	'Can_EventHandlingType',0,15,226,4,16,4,15
	.byte	'CanEventType',0
	.word	7796
	.byte	4,2,35,0,0,21
	.byte	'Can_EventHandlingType',0,15,229,4,3
	.word	8256
	.byte	21
	.byte	'Rte_TransformerErrorCode',0,16,130,1,15
	.word	159
	.byte	21
	.byte	'Rte_TransformerClass',0,16,131,1,15
	.word	159
	.byte	14,16,168,1,9,12,15
	.byte	'in',0
	.word	3822
	.byte	4,2,35,0,15
	.byte	'out',0
	.word	3822
	.byte	4,2,35,4,15
	.byte	'used',0
	.word	176
	.byte	2,2,35,8,15
	.byte	'lost_data',0
	.word	159
	.byte	1,2,35,10,0,21
	.byte	'Rte_QDynType',0,16,173,1,3
	.word	8402
	.byte	9,16,175,1,9,4,10
	.byte	'RTE_DRA',0,0,10
	.byte	'RTE_WOWP',0,1,10
	.byte	'RTE_TASK',0,2,10
	.byte	'RTE_ARE',0,3,10
	.byte	'RTE_EV',0,4,10
	.byte	'RTE_MSI',0,5,0,21
	.byte	'Rte_NotificationType',0,16,182,1,3
	.word	8489
	.byte	16,128,8
	.word	159
	.byte	17,255,7,0,21
	.byte	'Impl_NVM_DstPtrType_1024',0,17,50,15
	.word	8587
	.byte	21
	.byte	'CanIf_u32_impl',0,17,69,16
	.word	295
	.byte	21
	.byte	'CanIf_u16_impl',0,17,71,16
	.word	176
	.byte	21
	.byte	'CanIf_u8_impl',0,17,73,15
	.word	159
	.byte	21
	.byte	'CanIf_ControllerModeType_Enum_impl',0,17,88,15
	.word	159
	.byte	21
	.byte	'CanIf_PduModeType_Enum_impl',0,17,90,15
	.word	159
	.byte	14,17,92,9,2,15
	.byte	'DeviceMode',0
	.word	159
	.byte	1,2,35,0,15
	.byte	'ChannelMode',0
	.word	159
	.byte	1,2,35,1,0,21
	.byte	'CanIf_ControllerStateType_struct_impl',0,17,95,3
	.word	8778
	.byte	21
	.byte	'CanIf_NotifStatusType_Enum_impl',0,17,100,15
	.word	159
	.byte	21
	.byte	'CanSM_boolean_Impl',0,17,120,15
	.word	159
	.byte	21
	.byte	'CanSM_u8_Impl',0,17,123,15
	.word	159
	.byte	21
	.byte	'CanSM_BusOffRecoveryStateType_Enum_impl',0,17,128,1,15
	.word	159
	.byte	21
	.byte	'CanSM_NetworkModeStateType_Enum_impl',0,17,132,1,15
	.word	159
	.byte	21
	.byte	'CanSM_u16_Impl',0,17,136,1,16
	.word	176
	.byte	21
	.byte	'CanSM_TimerStateType_Enum_impl',0,17,138,1,15
	.word	159
	.byte	14,17,140,1,9,4,15
	.byte	'cntTick_u16',0
	.word	176
	.byte	2,2,35,0,15
	.byte	'stTimer',0
	.word	159
	.byte	1,2,35,2,0,21
	.byte	'CanSM_TimerConfig_tst_struct_impl',0,17,143,1,3
	.word	9119
	.byte	21
	.byte	'Com_impl_u16',0,17,154,1,16
	.word	176
	.byte	21
	.byte	'Com_impl_u8',0,17,157,1,15
	.word	159
	.byte	21
	.byte	'ComM_uint32_Impl',0,17,173,1,16
	.word	295
	.byte	21
	.byte	'ComM_uint16_Impl',0,17,175,1,16
	.word	176
	.byte	21
	.byte	'ComM_uint8_Impl',0,17,177,1,15
	.word	159
	.byte	21
	.byte	'ComM_bool_Impl',0,17,179,1,15
	.word	159
	.byte	14,17,181,1,9,24,15
	.byte	'ChannelState_e',0
	.word	295
	.byte	4,2,35,0,15
	.byte	'LightTimeoutCtr_u32',0
	.word	295
	.byte	4,2,35,4,15
	.byte	'MinFullComTimeoutCtr_u16',0
	.word	176
	.byte	2,2,35,8,15
	.byte	'ChannelMode_u8',0
	.word	159
	.byte	1,2,35,10,15
	.byte	'BusSmMode_u8',0
	.word	159
	.byte	1,2,35,11,15
	.byte	'UserRequestCtr_u8',0
	.word	159
	.byte	1,2,35,12,15
	.byte	'PassiveRequestState_u8',0
	.word	159
	.byte	1,2,35,13,15
	.byte	'PncRequestCtr_u8',0
	.word	159
	.byte	1,2,35,14,15
	.byte	'InhibitionReqStatus_u8',0
	.word	159
	.byte	1,2,35,15,15
	.byte	'NmNetworkRequestStatus_b',0
	.word	159
	.byte	1,2,35,16,15
	.byte	'DiagnosticRequestState_b',0
	.word	159
	.byte	1,2,35,17,15
	.byte	'CommunicationAllowed_b',0
	.word	159
	.byte	1,2,35,18,15
	.byte	'NmBusSleepIndicationStatus_b',0
	.word	159
	.byte	1,2,35,19,15
	.byte	'NmPrepareBusSleepIndicationStatus_b',0
	.word	159
	.byte	1,2,35,20,15
	.byte	'NmNetworkModeStatus_b',0
	.word	159
	.byte	1,2,35,21,0,21
	.byte	'ComM_ChannelStruct_Impl',0,17,197,1,3
	.word	9351
	.byte	14,17,206,1,9,10,15
	.byte	'WakeUpInhibitionCtr_u16',0
	.word	176
	.byte	2,2,35,0,15
	.byte	'LimitToNoComCtr_u16',0
	.word	176
	.byte	2,2,35,2,15
	.byte	'RequestedUserMode_t',0
	.word	159
	.byte	1,2,35,4,15
	.byte	'IndicatedUserMode_t',0
	.word	159
	.byte	1,2,35,5,15
	.byte	'numChannelsInFullCom_u8',0
	.word	159
	.byte	1,2,35,6,15
	.byte	'numChannelsInSilentCom_u8',0
	.word	159
	.byte	1,2,35,7,15
	.byte	'numChannelsInNoCom_u8',0
	.word	159
	.byte	1,2,35,8,0,21
	.byte	'ComM_UserStruct_Impl',0,17,214,1,3
	.word	9855
	.byte	21
	.byte	'Dcm_IOOperationResponseType',0,17,252,1,15
	.word	159
	.byte	21
	.byte	'Dcm_RequestDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspRequestRoutineResultsOutSignal_0PrimitivType',0
	.byte	17,138,2,15
	.word	159
	.byte	21
	.byte	'Dcm_StartDataIn_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineInSignalPrimitivType',0,17,146,2,15
	.word	159
	.byte	21
	.byte	'Dcm_StartDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineOutSignalPrimitivType',0,17,150,2,15
	.word	159
	.byte	21
	.byte	'Dcm_StopDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStopRoutineOutSignalPrimitivType',0,17,154,2,15
	.word	159
	.byte	21
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockNative_1024_Type',0,17,243,3,34
	.word	8598
	.byte	16,128,8
	.word	159
	.byte	17,255,7,0,21
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockRedundant_1024_Type',0,17,246,3,34
	.word	8598
	.byte	21
	.byte	'Fls_AddressType',0,2,171,3,16
	.word	295
	.byte	21
	.byte	'Fls_LengthType',0,2,173,3,16
	.word	295
	.byte	23
	.byte	'Fls_JobStartType',0,2,175,3,16,1,31
	.byte	'Reserved1',0,1
	.word	159
	.byte	1,7,2,35,0,31
	.byte	'Write',0,1
	.word	159
	.byte	1,6,2,35,0,31
	.byte	'Erase',0,1
	.word	159
	.byte	1,5,2,35,0,31
	.byte	'Read',0,1
	.word	159
	.byte	1,4,2,35,0,31
	.byte	'Compare',0,1
	.word	159
	.byte	1,3,2,35,0,31
	.byte	'Reserved2',0,1
	.word	159
	.byte	3,0,2,35,0,0,21
	.byte	'Fls_JobStartType',0,2,183,3,3
	.word	10722
	.byte	21
	.byte	'Fls_17_Pmu_Job_Type',0,2,187,3,15
	.word	159
	.byte	16,2
	.word	159
	.byte	17,1,0,23
	.byte	'Fls_17_Pmu_StateType',0,2,198,3,16,48,15
	.byte	'FlsReadAddress',0
	.word	295
	.byte	4,2,35,0,15
	.byte	'FlsWriteAddress',0
	.word	295
	.byte	4,2,35,4,15
	.byte	'FlsEraseTimeoutCycleCount',0
	.word	295
	.byte	4,2,35,8,15
	.byte	'FlsWriteTimeoutCycleCount',0
	.word	295
	.byte	4,2,35,12,15
	.byte	'FlsReadLength',0
	.word	295
	.byte	4,2,35,16,15
	.byte	'FlsWriteLength',0
	.word	295
	.byte	4,2,35,20,15
	.byte	'FlsReadBufferPtr',0
	.word	785
	.byte	4,2,35,24,15
	.byte	'FlsWriteBufferPtr',0
	.word	386
	.byte	4,2,35,28,15
	.byte	'FlsJobResult',0
	.word	585
	.byte	4,2,35,32,15
	.byte	'FlsMode',0
	.word	7259
	.byte	4,2,35,36,15
	.byte	'NotifCaller',0
	.word	159
	.byte	1,2,35,40,15
	.byte	'JobStarted',0
	.word	10722
	.byte	1,2,35,41,15
	.byte	'FlsJobType',0
	.word	10912
	.byte	2,2,35,42,15
	.byte	'FlsOper',0
	.word	159
	.byte	1,2,35,44,15
	.byte	'FlsTimeoutErr',0
	.word	159
	.byte	1,2,35,45,15
	.byte	'FlsTimeoutControl',0
	.word	159
	.byte	1,2,35,46,0,21
	.byte	'Fls_17_Pmu_StateType',0,2,130,4,3
	.word	10921
	.byte	21
	.byte	'Fls_NotifFunctionPtrType',0,2,137,4,16
	.word	3241
	.byte	7
	.word	295
	.byte	3
	.word	11399
	.byte	25,1,1,26
	.word	295
	.byte	26
	.word	295
	.byte	26
	.word	11404
	.byte	26
	.word	159
	.byte	0,3
	.word	11409
	.byte	21
	.byte	'Fls_WriteCmdPtrType',0,2,139,4,16
	.word	11433
	.byte	25,1,1,26
	.word	295
	.byte	0,3
	.word	11467
	.byte	21
	.byte	'Fls_EraseCmdPtrType',0,2,144,4,16
	.word	11476
	.byte	9,18,115,9,4,10
	.byte	'FEE_POLLING_MODE_E',0,0,10
	.byte	'FEE_NORMAL_MODE_E',0,1,0,21
	.byte	'Fee_stMainType',0,18,119,2
	.word	11510
	.byte	9,18,122,9,4,10
	.byte	'FEE_NO_ORDER',0,0,10
	.byte	'FEE_READ_ORDER',0,1,10
	.byte	'FEE_WRITE_ORDER',0,2,10
	.byte	'FEE_INVALIDATE_ORDER',0,3,10
	.byte	'FEE_MAINTAIN_ORDER',0,4,10
	.byte	'FEE_FORCED_READ_ORDER',0,5,0,21
	.byte	'Fee_HlMode_ten',0,18,132,1,2
	.word	11580
	.byte	9,18,170,1,9,4,10
	.byte	'FEE_RB_IDLE_E',0,0,10
	.byte	'FEE_RB_WRITE_MODE_E',0,1,10
	.byte	'FEE_RB_READ_MODE_E',0,2,10
	.byte	'FEE_RB_INVALIDATE_MODE_E',0,3,10
	.byte	'FEE_RB_MAINTAIN_MODE_E',0,4,10
	.byte	'FEE_RB_SOFT_SECTOR_REORG_MODE_E',0,5,10
	.byte	'FEE_RB_HARD_SECTOR_REORG_MODE_E',0,6,10
	.byte	'FEE_RB_SECTOR_ERASE_E',0,7,10
	.byte	'FEE_RB_STOPMODE_E',0,8,0,21
	.byte	'Fee_Rb_WorkingStateType_ten',0,18,183,1,2
	.word	11728
	.byte	32
	.byte	'Fee_Rb_WorkingState_en',0,18,202,1,50
	.word	11728
	.byte	1,1,32
	.byte	'Fee_stMain',0,18,203,1,39
	.word	11510
	.byte	1,1,9,1,147,1,9,4,10
	.byte	'FEE_NORMAL_PRIO_E',0,0,10
	.byte	'FEE_HIGH_PRIO_E',0,1,0,21
	.byte	'Fee_HlPriority_ten',0,1,151,1,2
	.word	12051
	.byte	14,1,165,1,9,24,15
	.byte	'DataBufferPtr_pu8',0
	.word	785
	.byte	4,2,35,0,15
	.byte	'FeeIdx_u16',0
	.word	176
	.byte	2,2,35,4,15
	.byte	'BlockPropIdx_u16',0
	.word	176
	.byte	2,2,35,6,15
	.byte	'Offset_u16',0
	.word	176
	.byte	2,2,35,8,15
	.byte	'Length_u16',0
	.word	176
	.byte	2,2,35,10,15
	.byte	'Mode_en',0
	.word	11580
	.byte	4,2,35,12,15
	.byte	'Prio_en',0
	.word	12051
	.byte	4,2,35,16,15
	.byte	'SecLevel_u8',0
	.word	159
	.byte	1,2,35,20,0,21
	.byte	'Fee_OrderFifo_tst',0,1,175,1,2
	.word	12124
	.byte	21
	.byte	'Fee_MarkerProp_t',0,1,231,1,2
	.word	1481
	.byte	9,1,246,1,9,4,10
	.byte	'FEE_SECTOR_STATE_UNDEF_E',0,0,10
	.byte	'FEE_SECTOR_ERASED_E',0,1,10
	.byte	'FEE_SECTOR_USED_E',0,2,10
	.byte	'FEE_SECTOR_FULL_E',0,3,10
	.byte	'FEE_SECTOR_REQUEST2ERASE_E',0,4,10
	.byte	'FEE_SECTOR_CONSIDERED_E',0,13,0,21
	.byte	'Fee_SectorState_ten',0,1,254,1,2
	.word	12352
	.byte	14,1,129,2,9,12,15
	.byte	'SecChngCnt_u32',0
	.word	295
	.byte	4,2,35,0,15
	.byte	'SecState_en',0
	.word	12352
	.byte	4,2,35,4,15
	.byte	'xPhySecIdx_u8',0
	.word	159
	.byte	1,2,35,8,0,21
	.byte	'Fee_LLSectorOrder_tst',0,1,134,2,2
	.word	12532
	.byte	21
	.byte	'Fee_stRetVal_ten',0,1,149,2,2
	.word	947
	.byte	14,1,153,2,9,16,15
	.byte	'Fee_PhysStartAddress_u32',0
	.word	295
	.byte	4,2,35,0,15
	.byte	'Fee_PhysEndAddress_u32',0
	.word	295
	.byte	4,2,35,4,15
	.byte	'Fee_LogStartAddress_u32',0
	.word	295
	.byte	4,2,35,8,15
	.byte	'Fee_LogEndAddress_u32',0
	.word	295
	.byte	4,2,35,12,0,21
	.byte	'Fee_FlashProp_tst',0,1,159,2,2
	.word	12664
	.byte	7
	.word	3241
	.byte	7
	.word	3241
	.byte	14,1,192,2,9,16,15
	.byte	'BlockPersistentId_u16',0
	.word	176
	.byte	2,2,35,0,15
	.byte	'Flags_u16',0
	.word	176
	.byte	2,2,35,2,15
	.byte	'Length_u16',0
	.word	176
	.byte	2,2,35,4,15
	.byte	'JobEndNotification_pfn',0
	.word	12828
	.byte	4,2,35,8,15
	.byte	'JobErrorNotification_pfn',0
	.word	12833
	.byte	4,2,35,12,0,21
	.byte	'Fee_BlockPropertiesType_tst',0,1,199,2,2
	.word	12838
	.byte	9,1,210,2,9,4,10
	.byte	'FEE_LL_MARKER_INIT_E',0,0,10
	.byte	'FEE_LL_MARKER_BLK_CHK_E',0,1,10
	.byte	'FEE_LL_MARKER_BLK_CHK_WAIT_E',0,2,10
	.byte	'FEE_LL_MARKER_BLK_CHK_ERROR_E',0,3,10
	.byte	'FEE_LL_MARKER_BLK_CHK_FINISHED_E',0,4,10
	.byte	'FEE_LL_MARKER_WRITE_WAIT_E',0,5,10
	.byte	'FEE_LL_MARKER_WRITE_ERROR_E',0,6,10
	.byte	'FEE_LL_MARKER_VERIFY_E',0,7,10
	.byte	'FEE_LL_MARKER_VERIFY_WAIT_E',0,8,10
	.byte	'FEE_LL_MARKER_VERIFY_FINISHED_E',0,9,0,21
	.byte	'Fee_LLWrMarkerType_ten',0,1,222,2,2
	.word	13018
	.byte	9,1,225,2,9,4,10
	.byte	'FEE_HL_RDWR_BLK_INIT_E',0,0,10
	.byte	'FEE_HL_SEARCH_BLK_HDR_E',0,1,10
	.byte	'FEE_HL_READ_BLK_HDR_WAIT_E',0,2,10
	.byte	'FEE_HL_CHECK_BLK_HDR_E',0,3,10
	.byte	'FEE_HL_CALC_BLK_CS_E',0,4,10
	.byte	'FEE_HL_CHECK_BLK_CS_E',0,5,10
	.byte	'FEE_HL_RD_DATA_FROM_BLK_E',0,6,10
	.byte	'FEE_HL_COMP_BLK_E',0,7,10
	.byte	'FEE_HL_WR_BLK_E',0,8,0,21
	.byte	'Fee_HLRdWrBlockType_ten',0,1,243,2,2
	.word	13352
	.byte	9,1,246,2,9,4,10
	.byte	'FEE_LL_WR_BLK_INIT_E',0,0,10
	.byte	'FEE_LL_WR_WRITEHEADER_E',0,1,10
	.byte	'FEE_LL_WR_SIZECHECK_HSR_E',0,2,10
	.byte	'FEE_LL_WR_WRITEHEADER_WAIT_E',0,3,10
	.byte	'FEE_LL_WR_VERIFYHEADER_E',0,4,10
	.byte	'FEE_LL_WR_VERIFYHEADER_WAIT_E',0,5,10
	.byte	'FEE_LL_WR_VERIFYHEADER_ERROR_E',0,6,10
	.byte	'FEE_LL_WR_WRITEDATA_SEC_A_E',0,7,10
	.byte	'FEE_LL_WR_WAIT_WRITEDATA_SEC_A_E',0,8,10
	.byte	'FEE_LL_WR_WRITE_ERROR_E',0,9,10
	.byte	'FEE_LL_WR_WRITE_FULL_MARKER_E',0,10,10
	.byte	'FEE_LL_WR_ERASE_SECTOR_E',0,11,10
	.byte	'FEE_LL_WR_WRITE_USED_MARKER_E',0,12,10
	.byte	'FEE_LL_WR_WRITE_START_MARKER_E',0,13,10
	.byte	'FEE_LL_WR_VERIFY_BLK_E',0,14,10
	.byte	'FEE_LL_WR_WRITEHDRPG2_E',0,15,10
	.byte	'FEE_LL_WR_WAIT_WRITEHDRPG2_E',0,16,0,21
	.byte	'Fee_LLWrBlockType_ten',0,1,162,3,2
	.word	13610
	.byte	9,1,165,3,9,4,10
	.byte	'FEE_LL_CMP_BLK_INIT_E',0,0,10
	.byte	'FEE_LL_CMP_HEADER_E',0,1,10
	.byte	'FEE_LL_CMP_WAIT_HEADER_E',0,2,10
	.byte	'FEE_LL_CMP_CHECK_OVERLAP_E',0,3,10
	.byte	'FEE_LL_CMP_DATA_SEC_A_E',0,4,10
	.byte	'FEE_LL_CMP_WAIT_DATA_SEC_A_E',0,5,10
	.byte	'FEE_LL_CMP_FINISHED_E',0,6,0,21
	.byte	'Fee_LLCmpBlkType_ten',0,1,174,3,2
	.word	14145
	.byte	9,1,177,3,9,4,10
	.byte	'FEE_LL_CPY_BLK_INIT_E',0,0,10
	.byte	'FEE_LL_CPY_BLOCK_START_E',0,1,10
	.byte	'FEE_LL_CPY_BLOCK_WAIT_E',0,2,10
	.byte	'FEE_LL_CPY_BLOCK_ERROR_E',0,3,10
	.byte	'FEE_LL_CPY_BLOCK_FINISHED_E',0,4,0,21
	.byte	'Fee_LLCpyBlkType_ten',0,1,184,3,2
	.word	14365
	.byte	9,1,187,3,9,4,10
	.byte	'FEE_LL_CRC_BLK_INIT_E',0,0,10
	.byte	'FEE_LL_CRC_RD_HD_PAGE_E',0,1,10
	.byte	'FEE_LL_CRC_RD_PAGE_E',0,2,10
	.byte	'FEE_LL_CRC_CHECK_OVERLAP_E',0,3,10
	.byte	'FEE_LL_CRC_RD_ROB_PAGE_E',0,4,10
	.byte	'FEE_LL_CRC_CHECK_OVERLAP_ROB_E',0,5,10
	.byte	'FEE_LL_CRC_RD_ROB_PAGE_WAIT_E',0,6,10
	.byte	'FEE_LL_CRC_RD_PAGE_WAIT_E',0,7,10
	.byte	'FEE_LL_CRC_RD_ERROR_E',0,8,0,21
	.byte	'Fee_LLCalcCrcBlkType_ten',0,1,200,3,2
	.word	14536
	.byte	9,1,203,3,9,4,10
	.byte	'FEE_LL_INIT_READ_E',0,0,10
	.byte	'FEE_LL_BLANK_CHECK_E',0,1,10
	.byte	'FEE_LL_BLANK_CHECK_WAIT_E',0,2,10
	.byte	'FEE_LL_READ_PAGE_E',0,3,10
	.byte	'FEE_LL_WAIT_READ_PAGE_E',0,4,10
	.byte	'FEE_LL_READ_ERROR_E',0,5,10
	.byte	'FEE_LL_READ_FINISHED_E',0,6,0,21
	.byte	'Fee_LLRdStateType_ten',0,1,223,3,3
	.word	14823
	.byte	9,1,226,3,9,4,10
	.byte	'FEE_LL_INIT_BLANK_CHECK_E',0,0,10
	.byte	'FEE_LL_PERFORM_BLANK_CHECK_E',0,1,10
	.byte	'FEE_LL_WAIT_PERFORM_BLANK_CHECK_E',0,2,10
	.byte	'FEE_LL_BLANK_CHECK_ERROR_E',0,3,10
	.byte	'FEE_LL_BLANK_CHECK_FINISHED_E',0,4,0,21
	.byte	'Fee_LLBlankCheckType_ten',0,1,233,3,3
	.word	15027
	.byte	9,1,236,3,9,4,10
	.byte	'FEE_LL_FIND_CURRENT_SECTOR_E',0,0,10
	.byte	'FEE_LL_FIND_LAST_HEADER_E',0,1,10
	.byte	'FEE_LL_FINISHED_E',0,2,0,21
	.byte	'Fee_LLFndEmptyPgeType_ten',0,1,249,3,2
	.word	15224
	.byte	9,1,252,3,9,4,10
	.byte	'FEE_LL_SEARCHBLK_INIT_E',0,0,10
	.byte	'FEE_LL_SEARCHBLK_BLK_HEADER_E',0,1,0,21
	.byte	'Fee_LLSearchBlkHdrType_ten',0,1,128,4,2
	.word	15345
	.byte	9,1,132,4,9,4,10
	.byte	'FEE_LL_BLD_UP_CACHE_INIT_E',0,0,10
	.byte	'FEE_LL_BLD_UP_CACHE_READ_E',0,1,0,21
	.byte	'Fee_LLBuildUpCache_ten',0,1,136,4,2
	.word	15446
	.byte	9,1,139,4,9,4,10
	.byte	'FEE_LL_BLD_UP_CACHE_ALL_SECT_INIT_E',0,0,10
	.byte	'FEE_LL_BLD_UP_CACHE_ALL_SECT_DO_E',0,1,0,21
	.byte	'Fee_LLBuildUpCacheAllSect_ten',0,1,143,4,2
	.word	15543
	.byte	9,1,168,4,9,4,10
	.byte	'FEE_LL_REORG_INIT_E',0,0,10
	.byte	'FEE_LL_REORG_PREP_SEARCH_BLK_E',0,1,10
	.byte	'FEE_LL_REORG_SEARCH_BLK_E',0,2,10
	.byte	'FEE_LL_REORG_CHECK_BLOCK_CS_E',0,3,10
	.byte	'FEE_LL_REORG_REDUNDANT_BLK_CHK_E',0,4,10
	.byte	'FEE_LL_REORG_WRITE_BLOCK_E',0,5,10
	.byte	'FEE_LL_REORG_FINISHED_E',0,6,0,21
	.byte	'Fee_LLSecReorgType_ten',0,1,193,4,2
	.word	15663
	.byte	9,1,196,4,9,4,10
	.byte	'FEE_LL_REDUNDANT_CPY_CHK_INIT_E',0,0,10
	.byte	'FEE_LL_REDUNDANT_CPY_CHK_SEARCH_HDR_E',0,1,10
	.byte	'FEE_LL_REDUNDANT_CPY_CHK_BLK_CS_E',0,2,0,21
	.byte	'Fee_LLRedundantCpyChk_ten',0,1,201,4,2
	.word	15907
	.byte	9,1,204,4,9,4,10
	.byte	'FEE_LL_CPY_FLS2FLS_INIT_E',0,0,10
	.byte	'FEE_LL_CPY_FLS2FLS_READ_E',0,1,10
	.byte	'FEE_LL_CPY_FLS2FLS_WAIT_READ_E',0,2,10
	.byte	'FEE_LL_CPY_FLS2FLS_READ_ERROR_E',0,3,10
	.byte	'FEE_LL_CPY_FLS2FLS_HDRPG1_WRITE_E',0,4,10
	.byte	'FEE_LL_CPY_FLS2FLS_WAIT_HDRPG1_WRITE_E',0,5,10
	.byte	'FEE_LL_CPY_FLS2FLS_HDRPG1_WRITE_ERROR_E',0,6,10
	.byte	'FEE_LL_CPY_FLS2FLS_HDRPG1_VERIFY_E',0,7,10
	.byte	'FEE_LL_CPY_FLS2FLS_WAIT_HDRPG1_VERIFY_E',0,8,10
	.byte	'FEE_LL_CPY_FLS2FLS_HDRPG1_VERIFY_ERROR_E',0,9,10
	.byte	'FEE_LL_CPY_FLS2FLS_WRITE_E',0,10,10
	.byte	'FEE_LL_CPY_FLS2FLS_WAIT_WRITE_E',0,11,10
	.byte	'FEE_LL_CPY_FLS2FLS_WRITE_ERROR_E',0,12,10
	.byte	'FEE_LL_CPY_FLS2FLS_VERIFY_E',0,13,10
	.byte	'FEE_LL_CPY_FLS2FLS_WAIT_VERIFY_E',0,14,10
	.byte	'FEE_LL_CPY_FLS2FLS_VERIFY_ERROR_E',0,15,10
	.byte	'FEE_LL_CPY_FLS2FLS_HDRPG2_WRITE_E',0,16,10
	.byte	'FEE_LL_CPY_FLS2FLS_WAIT_HDRPG2_WRITE_E',0,17,10
	.byte	'FEE_LL_CPY_FLS2FLS_HDRPG2_WRITE_ERROR_E',0,18,10
	.byte	'FEE_LL_CPY_FLS2FLS_HDRPG2_VERIFY_E',0,19,10
	.byte	'FEE_LL_CPY_FLS2FLS_WAIT_HDRPG2_VERIFY_E',0,20,10
	.byte	'FEE_LL_CPY_FLS2FLS_HDRPG2_VERIFY_ERROR_E',0,21,10
	.byte	'FEE_LL_CPY_FLS2FLS_CHECK_ADR_OVERFLOW_E',0,22,10
	.byte	'FEE_LL_CPY_FLS2FLS_WRITE_FULL_MARKER_E',0,23,10
	.byte	'FEE_LL_CPY_FLS2FLS_ERASE_SECTOR_E',0,24,10
	.byte	'FEE_LL_CPY_FLS2FLS_WRITE_USED_MARKER_E',0,25,10
	.byte	'FEE_LL_CPY_FLS2FLS_WRITE_START_MARKER_E',0,26,0,21
	.byte	'Fee_LLCpyBlkFls2Fls_ten',0,1,133,5,2
	.word	16059
	.byte	14,1,163,5,9,116,15
	.byte	'xRdAddress',0
	.word	295
	.byte	4,2,35,0,15
	.byte	'xWrAddress',0
	.word	295
	.byte	4,2,35,4,15
	.byte	'xCmpAddress',0
	.word	295
	.byte	4,2,35,8,15
	.byte	'xCrcAddress',0
	.word	295
	.byte	4,2,35,12,15
	.byte	'xCpyAddress',0
	.word	295
	.byte	4,2,35,16,15
	.byte	'AdrHdSearchStart_u32',0
	.word	295
	.byte	4,2,35,20,15
	.byte	'xStartAddrNextSector_u32',0
	.word	295
	.byte	4,2,35,24,15
	.byte	'xHdPg2Address',0
	.word	295
	.byte	4,2,35,28,15
	.byte	'LastProgrammedAddress_u32',0
	.word	295
	.byte	4,2,35,32,15
	.byte	'LastValidHdrAddress_u32',0
	.word	295
	.byte	4,2,35,36,15
	.byte	'Fee_LLSecReorg_en',0
	.word	15663
	.byte	4,2,35,40,15
	.byte	'Fee_LLRedundantCpyChk_en',0
	.word	15907
	.byte	4,2,35,44,15
	.byte	'Fee_LLCpyBlkFls2Fls_en',0
	.word	16059
	.byte	4,2,35,48,15
	.byte	'Fee_HLWrBlock_en',0
	.word	13352
	.byte	4,2,35,52,15
	.byte	'Fee_HLMtBlock_en',0
	.word	13352
	.byte	4,2,35,56,15
	.byte	'Fee_LLWrBlock_en',0
	.word	13610
	.byte	4,2,35,60,15
	.byte	'Fee_HLRdBlock',0
	.word	13352
	.byte	4,2,35,64,15
	.byte	'Fee_LLNextUsedWrBlock_en',0
	.word	13610
	.byte	4,2,35,68,15
	.byte	'Fee_LLNextEraseWrBlock_en',0
	.word	13610
	.byte	4,2,35,72,15
	.byte	'Fee_LLCompBlk',0
	.word	14145
	.byte	4,2,35,76,15
	.byte	'Fee_LLCopyBlk_en',0
	.word	14365
	.byte	4,2,35,80,15
	.byte	'Fee_LLCalcCrcBlk_en',0
	.word	14536
	.byte	4,2,35,84,15
	.byte	'Fee_LLWrMarker_en',0
	.word	13018
	.byte	4,2,35,88,15
	.byte	'Fee_LLRdState_en',0
	.word	14823
	.byte	4,2,35,92,15
	.byte	'Fee_LLBlankCheckState_en',0
	.word	15027
	.byte	4,2,35,96,15
	.byte	'Fee_LLFindEmptyPageState_en',0
	.word	15224
	.byte	4,2,35,100,15
	.byte	'Fee_LLSearchBlkHdr_en',0
	.word	15345
	.byte	4,2,35,104,15
	.byte	'Fee_LLBuildUpCache_en',0
	.word	15446
	.byte	4,2,35,108,15
	.byte	'Fee_LLBuildUpCacheAllSect_en',0
	.word	15543
	.byte	4,2,35,112,0,21
	.byte	'Fee_RdWrOrder_tst',0,1,224,5,3
	.word	17105
	.byte	21
	.byte	'Fee_GlobInfoLastRdHeader_tst',0,1,235,5,2
	.word	1318
	.byte	14,1,238,5,9,10,15
	.byte	'BytesAlrdyConsid_u16',0
	.word	176
	.byte	2,2,35,0,15
	.byte	'BytesAlrdyCompared_u16',0
	.word	176
	.byte	2,2,35,2,15
	.byte	'Bytes2Read_u16',0
	.word	176
	.byte	2,2,35,4,15
	.byte	'CompareResult_u8',0
	.word	159
	.byte	1,2,35,6,15
	.byte	'cntWriteRetry_u8',0
	.word	159
	.byte	1,2,35,7,15
	.byte	'cntCopies_u8',0
	.word	159
	.byte	1,2,35,8,0,21
	.byte	'Fee_GlobInfoWrBlock_tst',0,1,246,5,2
	.word	18000
	.byte	14,1,249,5,9,12,15
	.byte	'xRdAddress_u32',0
	.word	295
	.byte	4,2,35,0,15
	.byte	'xNumBytesAlrdyCopied_u16',0
	.word	176
	.byte	2,2,35,4,15
	.byte	'xNumBytesLeftToRdWr_u16',0
	.word	176
	.byte	2,2,35,6,15
	.byte	'xCntCopies_u8',0
	.word	159
	.byte	1,2,35,8,15
	.byte	'xFirstDataPgPgm_u8',0
	.word	159
	.byte	1,2,35,9,0,21
	.byte	'Fee_LLSecReorgStruct_tst',0,1,130,6,2
	.word	18200
	.byte	9,1,133,6,9,4,10
	.byte	'FEE_ERASESEC_IDLE_E',0,0,10
	.byte	'FEE_ERASESEC_CHECK_CACHE_E',0,1,10
	.byte	'FEE_ERASESEC_START_E',0,2,10
	.byte	'FEE_ERASESEC_DO_E',0,3,10
	.byte	'FEE_ERASESEC_WRITE_MARKER_E',0,4,10
	.byte	'FEE_ERASESEC_ERROR_E',0,5,0,21
	.byte	'Fee_LLEraseStateType_ten',0,1,141,6,2
	.word	18383
	.byte	21
	.byte	'Fee_BlkHeader_tst',0,1,159,6,2
	.word	1579
	.byte	16,32
	.word	12664
	.byte	17,1,0,7
	.word	18598
	.byte	32
	.byte	'Fee_FlashProp_st',0,1,135,7,53
	.word	18607
	.byte	1,1,32
	.byte	'Fee_PageBytePtr_cpu8',0,1,143,7,53
	.word	785
	.byte	1,1,32
	.byte	'Fee_RdWrOrder_st',0,1,144,7,53
	.word	17105
	.byte	1,1,16,24
	.word	12532
	.byte	17,1,0,32
	.byte	'Fee_LLSectorOrder_st',0,1,145,7,53
	.word	18700
	.byte	1,1,16,72
	.word	12124
	.byte	17,2,0,32
	.byte	'Fee_OrderFifo_st',0,1,147,7,53
	.word	18741
	.byte	1,1,32
	.byte	'Fee_GlobInfoWrBlock_st',0,1,149,7,53
	.word	18000
	.byte	1,1,32
	.byte	'Fee_LLSecReorgStruct_st',0,1,150,7,53
	.word	18200
	.byte	1,1,32
	.byte	'Fee_Prv_stReorg_u8',0,1,165,7,53
	.word	159
	.byte	1,1,32
	.byte	'Fee_NumFlashBanksUsed_u8',0,1,166,7,53
	.word	159
	.byte	1,1,16,8
	.word	159
	.byte	17,7,0,32
	.byte	'Fee_hdr2Buffer_au8',0,1,171,7,30
	.word	18913
	.byte	1,1,32
	.byte	'Fee_idxLLSectorOrder_au8',0,1,192,7,53
	.word	10912
	.byte	1,1,32
	.byte	'Fee_idxActQueue_u8',0,1,193,7,53
	.word	159
	.byte	1,1,32
	.byte	'Fee_RdWrRetries_u8',0,1,195,7,53
	.word	159
	.byte	1,1,32
	.byte	'Fee_DataByteStartCrc_u32',0,1,215,7,53
	.word	295
	.byte	1,1,16,192,1
	.word	12838
	.byte	17,11,0,32
	.byte	'Fee_BlockProperties_st',0,1,237,7,53
	.word	19084
	.byte	1,1,0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L334:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,36,0,3,8,11,15,62,15,0,0,3,15,0,73,19,0,0,4,46,1,3,8,32
	.byte	13,58,15,59,15,57,15,73,19,54,15,39,12,0,0,5,5,0,3,8,58,15,59,15,57,15,73,19,0,0,6,11,0,0,0,7,38,0,73
	.byte	19,0,0,8,46,1,3,8,58,15,59,15,57,15,73,19,54,15,39,12,63,12,60,12,0,0,9,4,1,58,15,59,15,57,15,11,15,0
	.byte	0,10,40,0,3,8,28,13,0,0,11,46,0,3,8,58,15,59,15,57,15,73,19,54,15,39,12,63,12,60,12,0,0,12,46,0,3,8,58
	.byte	15,59,15,57,15,54,15,39,12,63,12,60,12,0,0,13,46,1,3,8,58,15,59,15,57,15,54,15,39,12,63,12,60,12,0,0,14
	.byte	19,1,58,15,59,15,57,15,11,15,0,0,15,13,0,3,8,73,19,11,15,56,9,0,0,16,1,1,11,15,73,19,0,0,17,33,0,47,15
	.byte	0,0,18,46,1,49,19,0,0,19,5,0,49,19,0,0,20,21,0,54,15,0,0,21,22,0,3,8,58,15,59,15,57,15,73,19,0,0,22,21
	.byte	0,54,15,39,12,0,0,23,19,1,3,8,58,15,59,15,57,15,11,15,0,0,24,59,0,3,8,0,0,25,21,1,54,15,39,12,0,0,26,5
	.byte	0,73,19,0,0,27,23,1,58,15,59,15,57,15,11,15,0,0,28,4,1,3,8,58,15,59,15,57,15,11,15,0,0,29,21,0,73,19,54
	.byte	15,39,12,0,0,30,53,0,73,19,0,0,31,13,0,3,8,11,15,73,19,13,15,12,15,56,9,0,0,32,52,0,3,8,58,15,59,15,57
	.byte	15,73,19,63,12,60,12,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L335:
	.word	.L715-.L714
.L714:
	.half	3
	.word	.L717-.L716
.L716:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_Prv.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Fls\\inc\\Fls_17_Pmu.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\MemIf\\api\\MemIf_Types.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_Cbk.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Crc\\Crc_16.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Crc\\Crc_32.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Platform\\Platform_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Std_Types.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\RTOS_T\\Gen\\inc\\Os.h',0,0,0,0
	.byte	'.\\Integration\\TargetIntegration\\TC275\\Include\\Mcal_TcLib.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Can_GeneralTypes.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Can_17_MCanP\\inc\\Can_17_MCanP.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Type.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Fee\\api\\Fee.h',0,0,0,0,0
.L717:
.L715:
	.sdecl	'.debug_info',debug,cluster('Fee_CalculateNumOfFreeBytesInCurSector')
	.sect	'.debug_info'
.L336:
	.word	325
	.half	3
	.word	.L337
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L339,.L338
	.byte	2
	.word	.L332
	.byte	3
	.byte	'Fee_CalculateNumOfFreeBytesInCurSector',0,1,199,23,24
	.word	.L396
	.byte	1,1,1
	.word	.L329,.L397,.L328
	.byte	4
	.byte	'DataEndAdr_u32',0,1,199,23,84
	.word	.L396,.L398
	.byte	5
	.word	.L329,.L397
	.byte	6
	.byte	'xPhySecIdx_u8',0,1,201,23,28
	.word	.L399,.L400
	.byte	6
	.byte	'xNumFreeBytes_u32',0,1,202,23,28
	.word	.L396,.L401
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('Fee_CalculateNumOfFreeBytesInCurSector')
	.sect	'.debug_abbrev'
.L337:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('Fee_CalculateNumOfFreeBytesInCurSector')
	.sect	'.debug_line'
.L338:
	.word	.L719-.L718
.L718:
	.half	3
	.word	.L721-.L720
.L720:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c',0,0,0,0,0
.L721:
	.byte	5,24,7,0,5,2
	.word	.L329
	.byte	3,198,23,1,5,48,9
	.half	.L708-.L329
	.byte	3,6,1,5,43,9
	.half	.L707-.L708
	.byte	3,3,1,5,26,9
	.half	.L709-.L707
	.byte	1,5,42,9
	.half	.L722-.L709
	.byte	1,5,57,9
	.half	.L723-.L722
	.byte	1,5,5,9
	.half	.L710-.L723
	.byte	3,3,1,5,27,9
	.half	.L724-.L710
	.byte	3,3,1,5,5,9
	.half	.L303-.L724
	.byte	3,3,1,5,1,9
	.half	.L304-.L303
	.byte	3,1,1,7,9
	.half	.L340-.L304
	.byte	0,1,1
.L719:
	.sdecl	'.debug_ranges',debug,cluster('Fee_CalculateNumOfFreeBytesInCurSector')
	.sect	'.debug_ranges'
.L339:
	.word	-1,.L329,0,.L340-.L329,0,0
	.sdecl	'.debug_info',debug,cluster('Fee_LLCompBlkInFlash')
	.sect	'.debug_info'
.L341:
	.word	426
	.half	3
	.word	.L342
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L344,.L343
	.byte	2
	.word	.L332
	.byte	3
	.byte	'Fee_LLCompBlkInFlash',0,1,73,34
	.word	.L402
	.byte	1,1,1
	.word	.L309,.L403,.L308
	.byte	4
	.byte	'HeaderInfo_pcst',0,1,73,119
	.word	.L404,.L405
	.byte	4
	.byte	'Data_pcu8',0,1,74,96
	.word	.L406,.L407
	.byte	5
	.word	.L309,.L403
	.byte	6
	.byte	'xRetVal_en',0,1,76,38
	.word	.L402,.L408
	.byte	6
	.byte	'xNumBytes_u16',0,1,77,28
	.word	.L409,.L410
	.byte	6
	.byte	'xLogSectIdx_u8',0,1,78,28
	.word	.L399,.L411
	.byte	6
	.byte	'xPhySectIdx_u8',0,1,79,28
	.word	.L399,.L412
	.byte	6
	.byte	'xPhyWrSectIdx_u8',0,1,80,28
	.word	.L399,.L413
	.byte	6
	.byte	'xCmpLen_u16',0,1,81,28
	.word	.L409,.L414
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('Fee_LLCompBlkInFlash')
	.sect	'.debug_abbrev'
.L342:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('Fee_LLCompBlkInFlash')
	.sect	'.debug_line'
.L343:
	.word	.L726-.L725
.L725:
	.half	3
	.word	.L728-.L727
.L727:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c',0,0,0,0,0
.L728:
	.byte	5,34,7,0,5,2
	.word	.L309
	.byte	3,200,0,1,5,49,9
	.half	.L494-.L309
	.byte	3,3,1,5,12,9
	.half	.L495-.L494
	.byte	3,8,1,5,28,9
	.half	.L729-.L495
	.byte	1,5,14,9
	.half	.L730-.L729
	.byte	3,3,1,9
	.half	.L731-.L730
	.byte	3,13,1,9
	.half	.L732-.L731
	.byte	3,37,1,9
	.half	.L733-.L732
	.byte	3,21,1,9
	.half	.L734-.L733
	.byte	3,57,1,9
	.half	.L735-.L734
	.byte	3,192,0,1,9
	.half	.L736-.L735
	.byte	3,21,1,5,13,9
	.half	.L2-.L736
	.byte	3,175,126,1,5,35,9
	.half	.L737-.L2
	.byte	1,5,61,9
	.half	.L738-.L737
	.byte	1,5,59,9
	.half	.L739-.L738
	.byte	1,5,46,9
	.half	.L740-.L739
	.byte	3,3,1,5,44,9
	.half	.L741-.L740
	.byte	1,5,13,9
	.half	.L3-.L741
	.byte	3,125,1,5,55,9
	.half	.L742-.L3
	.byte	3,12,1,5,53,9
	.half	.L743-.L742
	.byte	1,5,29,9
	.half	.L744-.L743
	.byte	3,3,1,5,59,9
	.half	.L745-.L744
	.byte	1,5,42,9
	.half	.L746-.L745
	.byte	1,5,63,9
	.half	.L747-.L746
	.byte	3,2,1,5,46,9
	.half	.L748-.L747
	.byte	1,5,61,9
	.half	.L496-.L748
	.byte	3,2,1,5,13,9
	.half	.L749-.L496
	.byte	1,5,29,9
	.half	.L750-.L749
	.byte	3,2,1,5,17,9
	.half	.L10-.L750
	.byte	3,5,1,5,13,9
	.half	.L490-.L10
	.byte	1,5,28,7,9
	.half	.L751-.L490
	.byte	3,5,1,5,43,9
	.half	.L752-.L751
	.byte	1,5,50,9
	.half	.L11-.L752
	.byte	3,5,1,5,48,9
	.half	.L753-.L11
	.byte	1,5,88,9
	.half	.L754-.L753
	.byte	3,4,1,5,9,9
	.half	.L12-.L754
	.byte	3,3,1,5,17,9
	.half	.L4-.L12
	.byte	3,10,1,5,13,9
	.half	.L755-.L4
	.byte	1,5,17,7,9
	.half	.L756-.L755
	.byte	3,3,1,5,34,9
	.half	.L14-.L756
	.byte	3,5,1,5,9,9
	.half	.L757-.L14
	.byte	3,3,1,5,46,9
	.half	.L5-.L757
	.byte	3,6,1,5,44,9
	.half	.L758-.L5
	.byte	1,5,79,9
	.half	.L759-.L758
	.byte	3,3,1,5,16,9
	.half	.L760-.L759
	.byte	1,5,38,9
	.half	.L761-.L760
	.byte	1,5,13,9
	.half	.L762-.L761
	.byte	1,5,77,7,9
	.half	.L763-.L762
	.byte	3,4,1,5,52,9
	.half	.L499-.L763
	.byte	3,4,1,5,36,9
	.half	.L764-.L499
	.byte	1,5,69,9
	.half	.L765-.L764
	.byte	1,5,68,9
	.half	.L766-.L765
	.byte	1,5,84,9
	.half	.L767-.L766
	.byte	1,5,17,9
	.half	.L768-.L767
	.byte	1,5,46,7,9
	.half	.L769-.L768
	.byte	3,3,1,5,70,9
	.half	.L770-.L769
	.byte	1,5,87,9
	.half	.L771-.L770
	.byte	1,5,38,9
	.half	.L772-.L771
	.byte	1,5,42,9
	.half	.L501-.L772
	.byte	3,3,1,5,21,9
	.half	.L773-.L501
	.byte	1,5,36,7,9
	.half	.L774-.L773
	.byte	3,3,1,5,49,9
	.half	.L775-.L774
	.byte	1,9
	.half	.L18-.L775
	.byte	3,5,1,5,29,9
	.half	.L502-.L18
	.byte	1,5,49,9
	.half	.L776-.L502
	.byte	1,5,65,9
	.half	.L777-.L776
	.byte	1,5,28,9
	.half	.L778-.L777
	.byte	1,5,78,7,9
	.half	.L779-.L778
	.byte	3,1,1,5,82,7,9
	.half	.L20-.L779
	.byte	3,3,1,5,77,9
	.half	.L500-.L20
	.byte	3,3,1,5,76,9
	.half	.L503-.L500
	.byte	1,5,92,9
	.half	.L780-.L503
	.byte	1,5,58,9
	.half	.L781-.L780
	.byte	1,5,96,9
	.half	.L782-.L781
	.byte	3,125,1,5,40,9
	.half	.L21-.L782
	.byte	3,8,1,5,29,9
	.half	.L783-.L21
	.byte	3,1,1,5,17,9
	.half	.L17-.L783
	.byte	3,101,1,5,13,9
	.half	.L6-.L17
	.byte	3,175,127,1,5,39,9
	.half	.L784-.L6
	.byte	3,255,0,1,5,13,9
	.half	.L785-.L784
	.byte	1,5,28,7,9
	.half	.L786-.L785
	.byte	3,3,1,5,41,9
	.half	.L787-.L786
	.byte	1,5,76,9
	.half	.L25-.L787
	.byte	3,6,1,5,36,9
	.half	.L788-.L25
	.byte	1,5,17,9
	.half	.L789-.L788
	.byte	1,5,77,7,9
	.half	.L790-.L789
	.byte	3,3,1,5,37,9
	.half	.L791-.L790
	.byte	1,5,64,9
	.half	.L504-.L791
	.byte	3,5,1,5,21,9
	.half	.L792-.L504
	.byte	1,5,88,7,9
	.half	.L793-.L792
	.byte	3,3,1,5,41,9
	.half	.L794-.L793
	.byte	1,5,24,9
	.half	.L28-.L794
	.byte	3,4,1,5,21,9
	.half	.L507-.L28
	.byte	1,5,36,7,9
	.half	.L795-.L507
	.byte	3,5,1,5,51,9
	.half	.L796-.L795
	.byte	1,5,58,9
	.half	.L29-.L796
	.byte	3,5,1,5,56,9
	.half	.L797-.L29
	.byte	1,5,98,9
	.half	.L798-.L797
	.byte	3,4,1,5,104,9
	.half	.L510-.L798
	.byte	3,3,1,5,128,1,9
	.half	.L799-.L510
	.byte	1,5,71,9
	.half	.L505-.L799
	.byte	1,5,21,9
	.half	.L30-.L505
	.byte	3,118,1,5,63,9
	.half	.L27-.L30
	.byte	3,20,1,5,94,9
	.half	.L800-.L27
	.byte	1,5,32,9
	.half	.L801-.L800
	.byte	3,3,1,5,9,9
	.half	.L26-.L801
	.byte	3,4,1,5,17,9
	.half	.L7-.L26
	.byte	3,10,1,5,13,9
	.half	.L802-.L7
	.byte	1,5,17,7,9
	.half	.L803-.L802
	.byte	3,3,1,5,34,9
	.half	.L33-.L803
	.byte	3,5,1,5,9,9
	.half	.L804-.L33
	.byte	3,3,1,5,16,9
	.half	.L8-.L804
	.byte	3,6,1,5,38,9
	.half	.L805-.L8
	.byte	1,5,13,9
	.half	.L806-.L805
	.byte	1,5,28,7,9
	.half	.L807-.L806
	.byte	3,3,1,5,41,9
	.half	.L808-.L807
	.byte	1,5,77,9
	.half	.L35-.L808
	.byte	3,5,1,5,32,9
	.half	.L511-.L35
	.byte	1,5,79,9
	.half	.L513-.L511
	.byte	3,3,1,5,38,9
	.half	.L512-.L513
	.byte	3,4,1,5,69,9
	.half	.L809-.L512
	.byte	1,5,21,9
	.half	.L810-.L809
	.byte	1,5,37,7,9
	.half	.L811-.L810
	.byte	3,1,1,5,32,7,9
	.half	.L812-.L811
	.byte	3,3,1,5,45,9
	.half	.L813-.L812
	.byte	1,5,46,9
	.half	.L37-.L813
	.byte	3,7,1,5,87,9
	.half	.L814-.L37
	.byte	1,5,21,9
	.half	.L815-.L814
	.byte	1,5,50,7,9
	.half	.L816-.L815
	.byte	3,3,1,5,74,9
	.half	.L817-.L816
	.byte	1,5,91,9
	.half	.L514-.L817
	.byte	1,5,42,9
	.half	.L818-.L514
	.byte	1,5,46,9
	.half	.L516-.L818
	.byte	3,3,1,5,25,9
	.half	.L819-.L516
	.byte	1,5,40,7,9
	.half	.L820-.L819
	.byte	3,3,1,5,53,9
	.half	.L821-.L820
	.byte	1,9
	.half	.L41-.L821
	.byte	3,5,1,5,33,9
	.half	.L517-.L41
	.byte	1,5,53,9
	.half	.L822-.L517
	.byte	1,5,69,9
	.half	.L823-.L822
	.byte	1,5,32,9
	.half	.L824-.L823
	.byte	1,5,82,7,9
	.half	.L825-.L824
	.byte	3,1,1,5,86,7,9
	.half	.L43-.L825
	.byte	3,3,1,5,66,9
	.half	.L518-.L43
	.byte	3,3,1,5,83,9
	.half	.L826-.L518
	.byte	1,5,82,9
	.half	.L519-.L826
	.byte	1,5,98,9
	.half	.L827-.L519
	.byte	1,5,64,9
	.half	.L828-.L827
	.byte	1,5,66,9
	.half	.L829-.L828
	.byte	3,3,1,5,64,9
	.half	.L830-.L829
	.byte	1,5,100,9
	.half	.L831-.L830
	.byte	3,122,1,5,44,9
	.half	.L44-.L831
	.byte	3,11,1,5,25,9
	.half	.L42-.L44
	.byte	3,110,1,5,67,9
	.half	.L40-.L42
	.byte	3,25,1,5,98,9
	.half	.L832-.L40
	.byte	1,5,36,9
	.half	.L515-.L832
	.byte	3,3,1,5,9,9
	.half	.L36-.L515
	.byte	3,5,1,5,24,9
	.half	.L9-.L36
	.byte	3,6,1,5,9,9
	.half	.L833-.L9
	.byte	3,2,1,5,5,9
	.half	.L13-.L833
	.byte	3,5,1,5,42,7,9
	.half	.L834-.L13
	.byte	3,3,1,5,40,9
	.half	.L835-.L834
	.byte	1,5,5,9
	.half	.L49-.L835
	.byte	3,3,1,5,1,9
	.half	.L50-.L49
	.byte	3,1,1,7,9
	.half	.L345-.L50
	.byte	0,1,1
.L726:
	.sdecl	'.debug_ranges',debug,cluster('Fee_LLCompBlkInFlash')
	.sect	'.debug_ranges'
.L344:
	.word	-1,.L309,0,.L345-.L309,0,0
	.sdecl	'.debug_info',debug,cluster('Fee_LLCalcBlkCrcInFlash')
	.sect	'.debug_info'
.L346:
	.word	745
	.half	3
	.word	.L347
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L349,.L348
	.byte	2
	.word	.L332
	.byte	3
	.byte	'Fee_LLCalcBlkCrcInFlash',0,1,143,19,34
	.word	.L402
	.byte	1,1,1
	.word	.L327,.L415,.L326
	.byte	4
	.byte	'HeaderInfo_pcst',0,1,143,19,122
	.word	.L404,.L416
	.byte	5
	.word	.L327,.L415
	.byte	6
	.byte	'xRetVal_en',0,1,145,19,38
	.word	.L402,.L417
	.byte	6
	.byte	'xPhySectIdx_u8',0,1,146,19,27
	.word	.L399,.L418
	.byte	6
	.byte	'xPhyWrSectIdx_u8',0,1,147,19,27
	.word	.L399,.L419
	.byte	6
	.byte	'xLogSectIdx_u8',0,1,148,19,27
	.word	.L399,.L420
	.byte	6
	.byte	'xDataBlkLength_u16',0,1,149,19,28
	.word	.L409,.L421
	.byte	7
	.byte	'xNumBytes_u16',0,1,150,19,19
	.word	.L409
	.byte	5,3
	.word	_999005_xNumBytes_u16
	.byte	7
	.byte	'xBlkCrc32_u32',0,1,151,19,19
	.word	.L396
	.byte	5,3
	.word	_999006_xBlkCrc32_u32
	.byte	7
	.byte	'xConfigPropTableIdx_u16',0,1,152,19,19
	.word	.L409
	.byte	5,3
	.word	_999007_xConfigPropTableIdx_u16
	.byte	7
	.byte	'xFirstCRCRunDone_b',0,1,153,19,20
	.word	.L399
	.byte	5,3
	.word	_999008_xFirstCRCRunDone_b
	.byte	6
	.byte	'i_u8',0,1,156,19,27
	.word	.L399,.L422
	.byte	6
	.byte	'xNumBytesLeft_32',0,1,157,19,28
	.word	.L396,.L423
	.byte	7
	.byte	'xBlkRobCrc32_u32',0,1,158,19,19
	.word	.L396
	.byte	5,3
	.word	_999009_xBlkRobCrc32_u32
	.byte	8
	.word	.L424,.L425,.L230
	.byte	9
	.word	.L426,.L427
	.byte	9
	.word	.L428,.L429
	.byte	10
	.word	.L430,.L425,.L230
	.byte	6
	.byte	'xFuncRet_b',0,2,200,10,30
	.word	.L399,.L431
	.byte	6
	.byte	'xMid_u16',0,2,201,10,29
	.word	.L409,.L432
	.byte	6
	.byte	'xLeft_u16',0,2,202,10,29
	.word	.L409,.L433
	.byte	6
	.byte	'xRight_u16',0,2,203,10,29
	.word	.L409,.L434
	.byte	0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('Fee_LLCalcBlkCrcInFlash')
	.sect	'.debug_abbrev'
.L347:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,7,52,0,3,8,58,15,59,15,57,15,73,16,2,9,0,0,8,29,1,49,16,17,1
	.byte	18,1,0,0,9,5,0,49,16,2,6,0,0,10,11,1,49,16,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('Fee_LLCalcBlkCrcInFlash')
	.sect	'.debug_line'
.L348:
	.word	.L837-.L836
.L836:
	.half	3
	.word	.L839-.L838
.L838:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_Prv.h',0,0,0,0,0
.L839:
	.byte	5,34,7,0,5,2
	.word	.L327
	.byte	3,142,19,1,5,49,9
	.half	.L655-.L327
	.byte	3,2,1,5,13,9
	.half	.L656-.L655
	.byte	3,18,1,5,29,9
	.half	.L840-.L656
	.byte	1,5,14,9
	.half	.L841-.L840
	.byte	3,3,1,9
	.half	.L842-.L841
	.byte	3,40,1,9
	.half	.L843-.L842
	.byte	3,172,1,1,9
	.half	.L844-.L843
	.byte	3,177,127,1,9
	.half	.L845-.L844
	.byte	3,229,1,1,9
	.half	.L846-.L845
	.byte	3,157,126,1,9
	.half	.L847-.L846
	.byte	3,76,1,9
	.half	.L848-.L847
	.byte	3,126,1,9
	.half	.L849-.L848
	.byte	3,23,1,5,29,9
	.half	.L218-.L849
	.byte	3,155,127,1,5,59,9
	.half	.L850-.L218
	.byte	1,5,42,9
	.half	.L851-.L850
	.byte	1,5,13,9
	.half	.L852-.L851
	.byte	3,3,1,5,34,9
	.half	.L853-.L852
	.byte	1,5,32,9
	.half	.L854-.L853
	.byte	1,5,13,9
	.half	.L855-.L854
	.byte	3,1,1,5,34,9
	.half	.L856-.L855
	.byte	1,5,32,9
	.half	.L857-.L856
	.byte	1,5,13,9
	.half	.L858-.L857
	.byte	3,1,1,5,35,9
	.half	.L859-.L858
	.byte	1,5,61,9
	.half	.L860-.L859
	.byte	1,5,59,9
	.half	.L861-.L860
	.byte	1,5,69,9
	.half	.L862-.L861
	.byte	3,3,1,5,86,9
	.half	.L863-.L862
	.byte	1,4,2,5,39,9
	.half	.L425-.L863
	.byte	3,153,119,1,5,40,9
	.half	.L659-.L425
	.byte	3,1,1,5,54,9
	.half	.L228-.L659
	.byte	3,6,1,5,69,9
	.half	.L864-.L228
	.byte	1,5,67,9
	.half	.L865-.L864
	.byte	1,5,39,9
	.half	.L866-.L865
	.byte	1,5,20,9
	.half	.L867-.L866
	.byte	1,5,35,9
	.half	.L661-.L867
	.byte	3,3,1,5,12,9
	.half	.L868-.L661
	.byte	1,5,34,9
	.half	.L869-.L868
	.byte	1,5,44,9
	.half	.L870-.L869
	.byte	1,5,9,9
	.half	.L871-.L870
	.byte	1,5,28,7,9
	.half	.L872-.L871
	.byte	3,3,1,5,13,9
	.half	.L873-.L872
	.byte	3,6,1,5,9,9
	.half	.L229-.L873
	.byte	3,4,1,5,13,7,9
	.half	.L874-.L229
	.byte	3,3,1,5,48,7,9
	.half	.L875-.L874
	.byte	3,3,1,5,53,9
	.half	.L876-.L875
	.byte	1,5,17,9
	.half	.L232-.L876
	.byte	3,5,1,5,13,9
	.half	.L233-.L232
	.byte	3,125,1,5,43,9
	.half	.L231-.L233
	.byte	3,10,1,5,25,9
	.half	.L662-.L231
	.byte	1,5,35,9
	.half	.L235-.L662
	.byte	3,3,1,5,5,7,9
	.half	.L877-.L235
	.byte	3,2,1,4,1,5,17,9
	.half	.L230-.L877
	.byte	3,196,8,1,5,49,9
	.half	.L878-.L230
	.byte	3,125,1,5,31,9
	.half	.L879-.L878
	.byte	1,5,13,9
	.half	.L660-.L879
	.byte	1,5,31,9
	.half	.L880-.L660
	.byte	3,3,1,5,52,9
	.half	.L881-.L880
	.byte	1,5,31,9
	.half	.L237-.L881
	.byte	3,5,1,5,37,9
	.half	.L238-.L237
	.byte	3,4,1,5,62,9
	.half	.L882-.L238
	.byte	1,5,88,9
	.half	.L883-.L882
	.byte	1,5,53,9
	.half	.L665-.L883
	.byte	3,3,1,5,51,9
	.half	.L884-.L665
	.byte	1,5,17,9
	.half	.L219-.L884
	.byte	3,116,1,5,29,9
	.half	.L885-.L219
	.byte	3,109,1,5,37,9
	.half	.L886-.L885
	.byte	3,28,1,5,44,9
	.half	.L887-.L886
	.byte	3,12,1,5,27,9
	.half	.L888-.L887
	.byte	1,5,34,9
	.half	.L889-.L888
	.byte	3,3,1,5,49,9
	.half	.L890-.L889
	.byte	1,5,84,9
	.half	.L891-.L890
	.byte	1,5,16,9
	.half	.L892-.L891
	.byte	1,5,80,7,9
	.half	.L893-.L892
	.byte	3,1,1,5,17,7,9
	.half	.L894-.L893
	.byte	3,3,1,5,31,9
	.half	.L895-.L894
	.byte	1,5,16,9
	.half	.L239-.L895
	.byte	3,3,1,5,13,9
	.half	.L896-.L239
	.byte	1,5,33,7,9
	.half	.L897-.L896
	.byte	3,4,1,5,31,9
	.half	.L898-.L897
	.byte	1,5,16,9
	.half	.L241-.L898
	.byte	3,5,1,5,13,9
	.half	.L899-.L241
	.byte	1,5,56,7,9
	.half	.L900-.L899
	.byte	3,5,1,5,54,9
	.half	.L901-.L900
	.byte	1,5,89,9
	.half	.L902-.L901
	.byte	3,3,1,5,122,9
	.half	.L903-.L902
	.byte	1,5,81,9
	.half	.L904-.L903
	.byte	3,125,1,5,28,9
	.half	.L242-.L904
	.byte	3,8,1,5,9,9
	.half	.L243-.L242
	.byte	3,3,1,5,17,9
	.half	.L224-.L243
	.byte	3,12,1,5,13,9
	.half	.L905-.L224
	.byte	1,5,17,7,9
	.half	.L906-.L905
	.byte	3,3,1,5,34,9
	.half	.L245-.L906
	.byte	3,5,1,5,9,9
	.half	.L907-.L245
	.byte	3,3,1,5,16,9
	.half	.L226-.L907
	.byte	3,6,1,5,13,9
	.half	.L908-.L226
	.byte	1,5,35,7,9
	.half	.L909-.L908
	.byte	3,3,1,5,56,9
	.half	.L910-.L909
	.byte	3,4,1,5,54,9
	.half	.L911-.L910
	.byte	1,5,37,9
	.half	.L912-.L911
	.byte	3,124,1,5,59,9
	.half	.L247-.L912
	.byte	3,10,1,5,44,9
	.half	.L913-.L247
	.byte	3,1,1,5,28,9
	.half	.L914-.L913
	.byte	3,6,1,5,9,9
	.half	.L248-.L914
	.byte	3,3,1,5,13,9
	.half	.L223-.L248
	.byte	3,10,1,5,56,7,9
	.half	.L915-.L223
	.byte	3,2,1,5,54,9
	.half	.L916-.L915
	.byte	1,5,36,9
	.half	.L917-.L916
	.byte	3,1,1,5,80,9
	.half	.L670-.L917
	.byte	3,127,1,5,56,9
	.half	.L250-.L670
	.byte	3,6,1,5,54,9
	.half	.L918-.L250
	.byte	1,5,53,9
	.half	.L919-.L918
	.byte	3,1,1,5,73,9
	.half	.L251-.L919
	.byte	3,4,1,5,28,9
	.half	.L671-.L251
	.byte	1,5,75,9
	.half	.L673-.L671
	.byte	3,3,1,5,34,9
	.half	.L672-.L673
	.byte	3,4,1,5,65,9
	.half	.L920-.L672
	.byte	1,5,17,9
	.half	.L921-.L920
	.byte	1,5,33,7,9
	.half	.L922-.L921
	.byte	3,1,1,5,28,9
	.half	.L923-.L922
	.byte	3,3,1,5,17,9
	.half	.L252-.L923
	.byte	3,4,1,5,39,9
	.half	.L924-.L252
	.byte	1,5,65,9
	.half	.L925-.L924
	.byte	1,5,39,9
	.half	.L926-.L925
	.byte	1,5,65,9
	.half	.L927-.L926
	.byte	1,5,63,9
	.half	.L675-.L927
	.byte	1,5,13,9
	.half	.L928-.L675
	.byte	1,5,52,7,9
	.half	.L929-.L928
	.byte	3,4,1,5,69,9
	.half	.L930-.L929
	.byte	1,5,68,9
	.half	.L931-.L930
	.byte	1,5,84,9
	.half	.L932-.L931
	.byte	1,5,17,9
	.half	.L933-.L932
	.byte	1,5,46,7,9
	.half	.L934-.L933
	.byte	3,3,1,5,70,9
	.half	.L935-.L934
	.byte	1,5,87,9
	.half	.L936-.L935
	.byte	1,5,38,9
	.half	.L937-.L936
	.byte	1,5,43,9
	.half	.L676-.L937
	.byte	3,3,1,5,21,9
	.half	.L938-.L676
	.byte	1,5,36,7,9
	.half	.L939-.L938
	.byte	3,3,1,5,49,9
	.half	.L940-.L939
	.byte	1,9
	.half	.L256-.L940
	.byte	3,5,1,5,29,9
	.half	.L677-.L256
	.byte	1,5,49,9
	.half	.L941-.L677
	.byte	1,5,65,9
	.half	.L942-.L941
	.byte	1,5,28,9
	.half	.L943-.L942
	.byte	1,5,78,7,9
	.half	.L944-.L943
	.byte	3,1,1,5,82,7,9
	.half	.L258-.L944
	.byte	3,3,1,5,77,9
	.half	.L674-.L258
	.byte	3,3,1,5,76,9
	.half	.L678-.L674
	.byte	1,5,92,9
	.half	.L945-.L678
	.byte	1,5,58,9
	.half	.L946-.L945
	.byte	1,5,96,9
	.half	.L947-.L946
	.byte	3,125,1,5,40,9
	.half	.L259-.L947
	.byte	3,8,1,5,17,9
	.half	.L255-.L259
	.byte	3,102,1,5,9,9
	.half	.L261-.L255
	.byte	3,37,1,5,13,9
	.half	.L220-.L261
	.byte	3,181,126,1,5,37,9
	.half	.L948-.L220
	.byte	3,25,1,5,61,9
	.half	.L679-.L948
	.byte	3,193,1,1,5,17,9
	.half	.L949-.L679
	.byte	3,119,1,5,13,9
	.half	.L950-.L949
	.byte	1,5,81,7,9
	.half	.L951-.L950
	.byte	3,8,1,5,78,9
	.half	.L952-.L951
	.byte	3,2,1,5,96,9
	.half	.L953-.L952
	.byte	1,5,94,9
	.half	.L954-.L953
	.byte	1,5,53,9
	.half	.L955-.L954
	.byte	3,1,1,5,31,9
	.half	.L681-.L955
	.byte	3,125,1,5,38,9
	.half	.L956-.L681
	.byte	3,6,1,5,36,9
	.half	.L957-.L956
	.byte	1,5,59,9
	.half	.L958-.L957
	.byte	3,125,1,5,53,9
	.half	.L263-.L958
	.byte	3,16,1,9
	.half	.L959-.L263
	.byte	3,1,1,5,31,9
	.half	.L960-.L959
	.byte	3,125,1,5,70,9
	.half	.L264-.L960
	.byte	3,7,1,5,92,9
	.half	.L961-.L264
	.byte	1,5,70,9
	.half	.L962-.L961
	.byte	3,1,1,5,116,9
	.half	.L963-.L962
	.byte	3,127,1,5,59,9
	.half	.L964-.L963
	.byte	1,5,53,9
	.half	.L965-.L964
	.byte	3,9,1,5,34,9
	.half	.L684-.L965
	.byte	3,124,1,5,49,9
	.half	.L966-.L684
	.byte	1,5,84,9
	.half	.L967-.L966
	.byte	1,5,16,9
	.half	.L968-.L967
	.byte	1,5,79,7,9
	.half	.L969-.L968
	.byte	3,1,1,5,69,7,9
	.half	.L970-.L969
	.byte	3,3,1,5,91,9
	.half	.L686-.L970
	.byte	1,5,39,9
	.half	.L267-.L686
	.byte	3,10,1,5,13,9
	.half	.L971-.L267
	.byte	1,5,61,7,9
	.half	.L972-.L971
	.byte	3,3,1,5,31,9
	.half	.L687-.L972
	.byte	1,5,37,9
	.half	.L973-.L687
	.byte	3,4,1,5,21,9
	.half	.L974-.L973
	.byte	1,5,17,9
	.half	.L975-.L974
	.byte	1,5,35,7,9
	.half	.L976-.L975
	.byte	3,3,1,5,59,9
	.half	.L269-.L976
	.byte	3,4,1,5,94,9
	.half	.L977-.L269
	.byte	1,5,17,9
	.half	.L978-.L977
	.byte	1,5,85,7,9
	.half	.L979-.L978
	.byte	3,3,1,5,35,9
	.half	.L980-.L979
	.byte	1,5,20,9
	.half	.L270-.L980
	.byte	3,4,1,5,17,9
	.half	.L981-.L270
	.byte	1,5,60,7,9
	.half	.L982-.L981
	.byte	3,3,1,5,58,9
	.half	.L983-.L982
	.byte	1,5,79,9
	.half	.L984-.L983
	.byte	3,3,1,5,94,9
	.half	.L985-.L984
	.byte	1,5,85,9
	.half	.L986-.L985
	.byte	3,125,1,5,32,9
	.half	.L271-.L986
	.byte	3,8,1,5,17,9
	.half	.L272-.L271
	.byte	3,125,1,5,20,9
	.half	.L268-.L272
	.byte	3,9,1,5,52,9
	.half	.L689-.L268
	.byte	1,5,17,9
	.half	.L987-.L689
	.byte	1,5,63,7,9
	.half	.L988-.L987
	.byte	3,5,1,9
	.half	.L989-.L988
	.byte	3,1,1,5,32,9
	.half	.L990-.L989
	.byte	3,4,1,5,82,9
	.half	.L991-.L990
	.byte	3,124,1,5,21,9
	.half	.L274-.L991
	.byte	3,12,1,5,64,7,9
	.half	.L992-.L274
	.byte	3,3,1,5,62,9
	.half	.L993-.L992
	.byte	1,5,41,9
	.half	.L994-.L993
	.byte	3,3,1,5,39,9
	.half	.L995-.L994
	.byte	1,5,73,9
	.half	.L996-.L995
	.byte	3,1,1,5,71,9
	.half	.L997-.L996
	.byte	1,5,88,9
	.half	.L998-.L997
	.byte	3,124,1,5,29,9
	.half	.L276-.L998
	.byte	3,13,1,5,28,9
	.half	.L999-.L276
	.byte	1,5,46,7,9
	.half	.L1000-.L999
	.byte	3,1,1,5,45,9
	.half	.L1001-.L1000
	.byte	1,5,29,9
	.half	.L1002-.L1001
	.byte	1,5,45,9
	.half	.L1003-.L1002
	.byte	1,5,65,9
	.half	.L1004-.L1003
	.byte	1,5,74,9
	.half	.L1005-.L1004
	.byte	1,7,9
	.half	.L1006-.L1005
	.byte	1,5,71,9
	.half	.L278-.L1006
	.byte	3,9,1,5,56,9
	.half	.L1007-.L278
	.byte	3,1,1,5,36,9
	.half	.L280-.L1007
	.byte	3,4,1,5,9,9
	.half	.L273-.L280
	.byte	3,5,1,5,17,9
	.half	.L222-.L273
	.byte	3,9,1,5,13,9
	.half	.L1008-.L222
	.byte	1,5,25,7,9
	.half	.L1009-.L1008
	.byte	3,6,1,5,13,9
	.half	.L692-.L1009
	.byte	3,147,125,1,5,35,9
	.half	.L1010-.L692
	.byte	1,5,47,9
	.half	.L1011-.L1010
	.byte	3,237,2,1,5,61,9
	.half	.L284-.L1011
	.byte	3,3,1,5,21,9
	.half	.L1012-.L284
	.byte	1,5,81,9
	.half	.L1013-.L1012
	.byte	1,5,88,9
	.half	.L1014-.L1013
	.byte	3,1,1,5,64,9
	.half	.L1015-.L1014
	.byte	1,5,97,9
	.half	.L1016-.L1015
	.byte	3,127,1,5,90,9
	.half	.L1017-.L1016
	.byte	1,5,38,9
	.half	.L1018-.L1017
	.byte	1,5,53,9
	.half	.L1019-.L1018
	.byte	3,125,1,5,47,9
	.half	.L283-.L1019
	.byte	1,5,13,7,9
	.half	.L282-.L283
	.byte	3,147,125,1,5,35,9
	.half	.L1020-.L282
	.byte	1,5,92,9
	.half	.L1021-.L1020
	.byte	3,246,2,1,5,116,9
	.half	.L1022-.L1021
	.byte	1,5,59,9
	.half	.L1023-.L1022
	.byte	1,5,39,9
	.half	.L1024-.L1023
	.byte	3,4,1,5,13,9
	.half	.L1025-.L1024
	.byte	1,5,63,7,9
	.half	.L1026-.L1025
	.byte	3,3,1,5,31,9
	.half	.L1027-.L1026
	.byte	1,5,61,9
	.half	.L1028-.L1027
	.byte	3,4,1,5,73,9
	.half	.L694-.L1028
	.byte	3,4,1,5,37,9
	.half	.L1029-.L694
	.byte	3,127,1,5,54,9
	.half	.L1030-.L1029
	.byte	1,5,53,9
	.half	.L1031-.L1030
	.byte	1,5,69,9
	.half	.L1032-.L1031
	.byte	1,5,39,9
	.half	.L1033-.L1032
	.byte	3,4,1,5,17,9
	.half	.L1034-.L1033
	.byte	1,5,35,7,9
	.half	.L1035-.L1034
	.byte	3,3,1,5,86,9
	.half	.L286-.L1035
	.byte	3,5,1,5,21,9
	.half	.L697-.L286
	.byte	1,5,44,7,9
	.half	.L1036-.L697
	.byte	3,1,1,5,68,9
	.half	.L1037-.L1036
	.byte	1,5,41,7,9
	.half	.L1038-.L1037
	.byte	3,3,1,5,57,9
	.half	.L1039-.L1038
	.byte	1,5,21,9
	.half	.L1040-.L1039
	.byte	1,5,50,7,9
	.half	.L1041-.L1040
	.byte	3,3,1,5,74,9
	.half	.L1042-.L1041
	.byte	1,5,91,9
	.half	.L1043-.L1042
	.byte	1,5,42,9
	.half	.L1044-.L1043
	.byte	1,5,62,9
	.half	.L700-.L1044
	.byte	3,3,1,5,42,9
	.half	.L701-.L700
	.byte	1,5,62,9
	.half	.L1045-.L701
	.byte	1,5,78,9
	.half	.L1046-.L1045
	.byte	1,5,73,9
	.half	.L695-.L1046
	.byte	3,3,1,5,72,9
	.half	.L702-.L695
	.byte	1,5,88,9
	.half	.L1047-.L702
	.byte	1,5,54,9
	.half	.L1048-.L1047
	.byte	1,5,41,9
	.half	.L1049-.L1048
	.byte	3,2,1,5,39,9
	.half	.L1050-.L1049
	.byte	1,5,20,9
	.half	.L287-.L1050
	.byte	3,5,1,5,17,9
	.half	.L1051-.L287
	.byte	1,5,60,7,9
	.half	.L1052-.L1051
	.byte	3,3,1,5,58,9
	.half	.L1053-.L1052
	.byte	1,5,79,9
	.half	.L1054-.L1053
	.byte	3,3,1,5,94,9
	.half	.L1055-.L1054
	.byte	1,5,89,9
	.half	.L1056-.L1055
	.byte	3,125,1,5,32,9
	.half	.L290-.L1056
	.byte	3,8,1,5,17,9
	.half	.L291-.L290
	.byte	3,125,1,5,40,9
	.half	.L285-.L291
	.byte	3,9,1,5,20,9
	.half	.L1057-.L285
	.byte	1,5,40,9
	.half	.L1058-.L1057
	.byte	1,5,17,9
	.half	.L1059-.L1058
	.byte	1,5,63,7,9
	.half	.L1060-.L1059
	.byte	3,5,1,9
	.half	.L1061-.L1060
	.byte	3,1,1,5,32,9
	.half	.L1062-.L1061
	.byte	3,4,1,5,82,9
	.half	.L1063-.L1062
	.byte	3,124,1,5,25,9
	.half	.L293-.L1063
	.byte	3,12,1,5,24,9
	.half	.L1064-.L293
	.byte	1,5,42,7,9
	.half	.L1065-.L1064
	.byte	3,1,1,5,41,9
	.half	.L1066-.L1065
	.byte	1,5,25,9
	.half	.L1067-.L1066
	.byte	1,5,41,9
	.half	.L1068-.L1067
	.byte	1,5,61,9
	.half	.L1069-.L1068
	.byte	1,5,70,9
	.half	.L1070-.L1069
	.byte	1,7,9
	.half	.L1071-.L1070
	.byte	1,5,67,9
	.half	.L295-.L1071
	.byte	3,9,1,5,52,9
	.half	.L1072-.L295
	.byte	3,1,1,5,32,9
	.half	.L297-.L1072
	.byte	3,4,1,5,9,9
	.half	.L292-.L297
	.byte	3,4,1,5,16,9
	.half	.L227-.L292
	.byte	3,8,1,5,13,9
	.half	.L1073-.L227
	.byte	1,5,17,7,9
	.half	.L1074-.L1073
	.byte	3,6,1,5,24,9
	.half	.L299-.L1074
	.byte	3,5,1,5,9,9
	.half	.L1075-.L299
	.byte	3,2,1,5,5,9
	.half	.L244-.L1075
	.byte	3,4,1,5,48,7,9
	.half	.L1076-.L244
	.byte	3,3,1,5,46,9
	.half	.L1077-.L1076
	.byte	1,5,9,9
	.half	.L1078-.L1077
	.byte	3,3,1,5,30,9
	.half	.L1079-.L1078
	.byte	1,5,28,9
	.half	.L1080-.L1079
	.byte	1,5,9,9
	.half	.L1081-.L1080
	.byte	3,4,1,5,28,9
	.half	.L1082-.L1081
	.byte	1,5,26,9
	.half	.L1083-.L1082
	.byte	1,5,9,9
	.half	.L1084-.L1083
	.byte	3,4,1,5,35,9
	.half	.L1085-.L1084
	.byte	1,5,33,9
	.half	.L1086-.L1085
	.byte	1,5,5,9
	.half	.L301-.L1086
	.byte	3,3,1,5,1,9
	.half	.L302-.L301
	.byte	3,1,1,7,9
	.half	.L350-.L302
	.byte	0,1,1
.L837:
	.sdecl	'.debug_ranges',debug,cluster('Fee_LLCalcBlkCrcInFlash')
	.sect	'.debug_ranges'
.L349:
	.word	-1,.L327,0,.L350-.L327,0,0
	.sdecl	'.debug_info',debug,cluster('Fee_LLCpyBlkFromFls2Fls')
	.sect	'.debug_info'
.L351:
	.word	702
	.half	3
	.word	.L352
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L354,.L353
	.byte	2
	.word	.L332
	.byte	3
	.byte	'Fee_LLCpyBlkFromFls2Fls',0,1,172,8,34
	.word	.L402
	.byte	1,1,1
	.word	.L325,.L435,.L324
	.byte	4
	.byte	'Fee_GlobInfoLastRdHeader_pcst',0,1,172,8,122
	.word	.L404,.L436
	.byte	4
	.byte	'Fee_WriteTwice_b',0,1,172,8,161,1
	.word	.L399,.L437
	.byte	5
	.word	.L325,.L435
	.byte	6
	.byte	'xRetVal_en',0,1,174,8,38
	.word	.L402,.L438
	.byte	6
	.byte	'xPhySectIdx_u8',0,1,175,8,27
	.word	.L399,.L439
	.byte	6
	.byte	'xLogSectIdx_u8',0,1,176,8,27
	.word	.L399,.L440
	.byte	6
	.byte	'xNumBytes_u32',0,1,177,8,28
	.word	.L396,.L441
	.byte	7
	.byte	'xHeaderAddr_u32',0,1,178,8,19
	.word	.L396
	.byte	5,3
	.word	_999001_xHeaderAddr_u32
	.byte	7
	.byte	'xSectOverflow_b',0,1,179,8,20
	.word	.L399
	.byte	5,3
	.word	_999002_xSectOverflow_b
	.byte	6
	.byte	'xWrMarkerRetVal_en',0,1,180,8,38
	.word	.L402,.L442
	.byte	6
	.byte	'xCnt_u16',0,1,181,8,28
	.word	.L409,.L443
	.byte	7
	.byte	'xCntRetry_u8',0,1,182,8,18
	.word	.L399
	.byte	5,3
	.word	_999003_xCntRetry_u8
	.byte	6
	.byte	'xConfigPropTableIdx_u16',0,1,183,8,28
	.word	.L409,.L444
	.byte	6
	.byte	'xRetValErase_en',0,1,184,8,39
	.word	.L402,.L445
	.byte	7
	.byte	'cntProgrammedBytes_u32',0,1,185,8,19
	.word	.L396
	.byte	5,3
	.word	_999004_cntProgrammedBytes_u32
	.byte	6
	.byte	'tmpAddr_u32',0,1,186,8,12
	.word	.L396,.L446
	.byte	6
	.byte	'tmpAdd_pu8',0,1,187,8,12
	.word	.L447,.L448
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('Fee_LLCpyBlkFromFls2Fls')
	.sect	'.debug_abbrev'
.L352:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,7,52,0,3,8,58,15,59,15,57,15,73,16,2,9,0,0,0
	.sdecl	'.debug_line',debug,cluster('Fee_LLCpyBlkFromFls2Fls')
	.sect	'.debug_line'
.L353:
	.word	.L1088-.L1087
.L1087:
	.half	3
	.word	.L1090-.L1089
.L1089:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c',0,0,0,0,0
.L1090:
	.byte	5,34,7,0,5,2
	.word	.L325
	.byte	3,171,8,1,5,49,9
	.half	.L566-.L325
	.byte	3,2,1,5,13,9
	.half	.L567-.L566
	.byte	3,16,1,5,29,9
	.half	.L1091-.L567
	.byte	1,5,5,9
	.half	.L1092-.L1091
	.byte	1,5,13,9
	.half	.L93-.L1092
	.byte	3,6,1,5,36,9
	.half	.L1093-.L93
	.byte	1,5,64,9
	.half	.L1094-.L1093
	.byte	1,5,62,9
	.half	.L1095-.L1094
	.byte	1,5,83,9
	.half	.L1096-.L1095
	.byte	3,3,1,5,52,9
	.half	.L1097-.L1096
	.byte	1,5,13,9
	.half	.L1098-.L1097
	.byte	3,3,1,5,31,9
	.half	.L1099-.L1098
	.byte	1,5,29,9
	.half	.L1100-.L1099
	.byte	1,5,13,9
	.half	.L1101-.L1100
	.byte	3,2,1,5,38,9
	.half	.L1102-.L1101
	.byte	1,5,36,9
	.half	.L1103-.L1102
	.byte	1,5,56,9
	.half	.L1104-.L1103
	.byte	3,3,1,5,54,9
	.half	.L1105-.L1104
	.byte	1,5,73,9
	.half	.L1106-.L1105
	.byte	3,3,1,5,38,9
	.half	.L572-.L1106
	.byte	3,1,1,5,62,9
	.half	.L1107-.L572
	.byte	1,5,29,9
	.half	.L570-.L1107
	.byte	3,4,1,5,46,9
	.half	.L1108-.L570
	.byte	1,5,44,9
	.half	.L1109-.L1108
	.byte	1,5,58,9
	.half	.L1110-.L1109
	.byte	3,1,1,5,56,9
	.half	.L1111-.L1110
	.byte	1,9
	.half	.L1112-.L1111
	.byte	3,61,1,5,120,9
	.half	.L573-.L1112
	.byte	1,5,16,9
	.half	.L1113-.L573
	.byte	1,5,17,7,9
	.half	.L1114-.L1113
	.byte	3,1,1,5,37,9
	.half	.L1115-.L1114
	.byte	1,5,53,9
	.half	.L1116-.L1115
	.byte	1,5,66,9
	.half	.L1117-.L1116
	.byte	1,5,17,7,9
	.half	.L120-.L1117
	.byte	1,5,40,9
	.half	.L1118-.L120
	.byte	3,15,1,5,56,9
	.half	.L1119-.L1118
	.byte	1,5,17,9
	.half	.L1120-.L1119
	.byte	1,5,63,7,9
	.half	.L1121-.L1120
	.byte	3,3,1,5,61,9
	.half	.L1122-.L1121
	.byte	1,5,101,9
	.half	.L1123-.L1122
	.byte	1,5,35,9
	.half	.L122-.L1123
	.byte	3,5,1,5,42,9
	.half	.L575-.L122
	.byte	3,3,1,5,21,9
	.half	.L1124-.L575
	.byte	1,5,62,7,9
	.half	.L1125-.L1124
	.byte	3,8,1,9
	.half	.L1126-.L1125
	.byte	3,3,1,5,78,9
	.half	.L1127-.L1126
	.byte	1,5,46,9
	.half	.L577-.L1127
	.byte	3,3,1,5,43,9
	.half	.L576-.L577
	.byte	3,4,1,5,41,9
	.half	.L1128-.L576
	.byte	1,5,67,9
	.half	.L1129-.L1128
	.byte	3,3,1,5,65,9
	.half	.L1130-.L1129
	.byte	1,5,66,9
	.half	.L1131-.L1130
	.byte	3,115,1,5,62,9
	.half	.L124-.L1131
	.byte	3,28,1,5,78,9
	.half	.L1132-.L124
	.byte	1,5,64,9
	.half	.L579-.L1132
	.byte	3,3,1,5,25,9
	.half	.L1133-.L579
	.byte	1,5,71,7,9
	.half	.L1134-.L1133
	.byte	3,5,1,5,69,9
	.half	.L1135-.L1134
	.byte	1,5,109,9
	.half	.L1136-.L1135
	.byte	1,5,50,9
	.half	.L126-.L1136
	.byte	3,10,1,5,71,9
	.half	.L578-.L126
	.byte	3,3,1,5,69,9
	.half	.L1137-.L578
	.byte	1,5,51,9
	.half	.L125-.L1137
	.byte	3,5,1,5,68,9
	.half	.L1138-.L125
	.byte	1,5,67,9
	.half	.L580-.L1138
	.byte	1,5,83,9
	.half	.L1139-.L580
	.byte	1,5,49,9
	.half	.L1140-.L1139
	.byte	1,5,9,9
	.half	.L121-.L1140
	.byte	3,4,1,5,97,9
	.half	.L94-.L121
	.byte	3,38,1,5,113,9
	.half	.L1141-.L94
	.byte	1,5,16,9
	.half	.L1142-.L1141
	.byte	1,5,39,9
	.half	.L1143-.L1142
	.byte	1,5,13,9
	.half	.L1144-.L1143
	.byte	1,5,40,7,9
	.half	.L1145-.L1144
	.byte	3,4,1,5,106,9
	.half	.L1146-.L1145
	.byte	1,5,65,9
	.half	.L1147-.L1146
	.byte	1,5,93,9
	.half	.L1148-.L1147
	.byte	3,6,1,5,44,9
	.half	.L131-.L1148
	.byte	3,2,1,5,68,9
	.half	.L1149-.L131
	.byte	1,5,47,9
	.half	.L130-.L1149
	.byte	3,126,1,5,93,9
	.half	.L1150-.L130
	.byte	1,5,70,7,9
	.half	.L1151-.L1150
	.byte	3,13,1,5,17,9
	.half	.L1152-.L1151
	.byte	1,5,69,7,9
	.half	.L1153-.L1152
	.byte	3,3,1,5,72,9
	.half	.L132-.L1153
	.byte	3,4,1,5,43,9
	.half	.L585-.L132
	.byte	3,17,1,5,17,9
	.half	.L1154-.L585
	.byte	1,5,69,7,9
	.half	.L1155-.L1154
	.byte	3,3,1,5,17,9
	.half	.L133-.L1155
	.byte	3,4,1,5,63,7,9
	.half	.L1156-.L133
	.byte	3,3,1,5,61,9
	.half	.L1157-.L1156
	.byte	1,5,101,9
	.half	.L1158-.L1157
	.byte	1,5,99,9
	.half	.L134-.L1158
	.byte	3,7,1,5,47,9
	.half	.L1159-.L134
	.byte	3,2,1,5,21,9
	.half	.L1160-.L1159
	.byte	1,5,73,7,9
	.half	.L1161-.L1160
	.byte	3,4,1,5,24,9
	.half	.L136-.L1161
	.byte	3,4,1,5,21,9
	.half	.L586-.L136
	.byte	1,5,67,7,9
	.half	.L1162-.L586
	.byte	3,5,1,5,65,9
	.half	.L1163-.L1162
	.byte	1,5,108,9
	.half	.L1164-.L1163
	.byte	3,3,1,9
	.half	.L1165-.L1164
	.byte	3,1,1,5,134,1,9
	.half	.L1166-.L1165
	.byte	3,127,1,5,74,9
	.half	.L1167-.L1166
	.byte	1,5,75,9
	.half	.L1168-.L1167
	.byte	3,5,1,5,52,9
	.half	.L1169-.L1168
	.byte	3,1,1,5,97,9
	.half	.L1170-.L1169
	.byte	3,119,1,5,81,9
	.half	.L137-.L1170
	.byte	3,15,1,5,52,9
	.half	.L1171-.L137
	.byte	3,1,1,5,36,9
	.half	.L1172-.L1171
	.byte	3,3,1,5,17,9
	.half	.L135-.L1172
	.byte	3,89,1,5,36,9
	.half	.L129-.L135
	.byte	3,48,1,5,17,9
	.half	.L1173-.L129
	.byte	1,5,63,7,9
	.half	.L1174-.L1173
	.byte	3,4,1,5,61,9
	.half	.L1175-.L1174
	.byte	1,5,96,9
	.half	.L1176-.L1175
	.byte	1,5,84,9
	.half	.L140-.L1176
	.byte	3,9,1,5,101,9
	.half	.L589-.L140
	.byte	1,5,21,9
	.half	.L1177-.L589
	.byte	1,5,53,7,9
	.half	.L1178-.L1177
	.byte	3,4,1,5,30,9
	.half	.L1179-.L1178
	.byte	1,5,52,9
	.half	.L1180-.L1179
	.byte	1,5,77,9
	.half	.L1181-.L1180
	.byte	1,5,28,9
	.half	.L1182-.L1181
	.byte	1,5,54,7,9
	.half	.L1183-.L1182
	.byte	3,3,1,5,69,9
	.half	.L1184-.L1183
	.byte	1,5,84,7,9
	.half	.L1185-.L1184
	.byte	1,5,71,7,9
	.half	.L1186-.L1185
	.byte	3,3,1,5,69,9
	.half	.L1187-.L1186
	.byte	1,5,66,9
	.half	.L1188-.L1187
	.byte	3,1,1,5,96,9
	.half	.L1189-.L1188
	.byte	3,127,1,5,40,9
	.half	.L143-.L1189
	.byte	3,6,1,5,25,9
	.half	.L146-.L143
	.byte	3,125,1,5,59,9
	.half	.L142-.L146
	.byte	3,10,1,5,28,9
	.half	.L1190-.L142
	.byte	1,5,54,7,9
	.half	.L1191-.L1190
	.byte	3,2,1,5,69,9
	.half	.L1192-.L1191
	.byte	1,5,84,7,9
	.half	.L1193-.L1192
	.byte	1,5,71,7,9
	.half	.L1194-.L1193
	.byte	3,3,1,5,69,9
	.half	.L1195-.L1194
	.byte	1,5,66,9
	.half	.L1196-.L1195
	.byte	3,1,1,5,96,9
	.half	.L1197-.L1196
	.byte	3,127,1,5,40,9
	.half	.L148-.L1197
	.byte	3,6,1,5,77,9
	.half	.L147-.L148
	.byte	3,5,1,5,48,9
	.half	.L1198-.L147
	.byte	3,1,1,5,9,9
	.half	.L139-.L1198
	.byte	3,4,1,5,17,9
	.half	.L107-.L139
	.byte	3,27,1,5,13,9
	.half	.L1199-.L107
	.byte	1,5,17,7,9
	.half	.L1200-.L1199
	.byte	3,3,1,5,34,9
	.half	.L153-.L1200
	.byte	3,5,1,5,9,9
	.half	.L1201-.L153
	.byte	3,3,1,5,17,9
	.half	.L97-.L1201
	.byte	3,16,1,5,13,9
	.half	.L1202-.L97
	.byte	1,5,51,7,9
	.half	.L1203-.L1202
	.byte	3,5,1,5,17,9
	.half	.L1204-.L1203
	.byte	1,5,33,9
	.half	.L1205-.L1204
	.byte	1,9
	.half	.L1206-.L1205
	.byte	3,3,1,5,78,9
	.half	.L1207-.L1206
	.byte	1,5,48,9
	.half	.L1208-.L1207
	.byte	1,5,54,9
	.half	.L1209-.L1208
	.byte	3,3,1,5,33,9
	.half	.L1210-.L1209
	.byte	1,5,75,9
	.half	.L1211-.L1210
	.byte	1,5,92,9
	.half	.L1212-.L1211
	.byte	1,5,17,9
	.half	.L1213-.L1212
	.byte	3,3,1,5,40,9
	.half	.L1214-.L1213
	.byte	1,5,65,9
	.half	.L1215-.L1214
	.byte	1,5,17,9
	.half	.L1216-.L1215
	.byte	3,4,1,5,40,9
	.half	.L1217-.L1216
	.byte	1,5,59,9
	.half	.L1218-.L1217
	.byte	3,3,1,5,57,9
	.half	.L1219-.L1218
	.byte	1,5,64,9
	.half	.L1220-.L1219
	.byte	3,3,1,5,46,9
	.half	.L1221-.L1220
	.byte	1,5,58,9
	.half	.L1222-.L1221
	.byte	3,4,1,5,44,9
	.half	.L1223-.L1222
	.byte	3,1,1,5,62,9
	.half	.L1224-.L1223
	.byte	3,104,1,5,73,9
	.half	.L155-.L1224
	.byte	3,30,1,5,44,9
	.half	.L1225-.L155
	.byte	3,1,1,5,28,9
	.half	.L1226-.L1225
	.byte	3,3,1,5,9,9
	.half	.L156-.L1226
	.byte	3,3,1,5,24,9
	.half	.L103-.L156
	.byte	3,198,126,1,5,17,9
	.half	.L598-.L103
	.byte	3,197,1,1,5,57,9
	.half	.L1227-.L598
	.byte	1,5,16,9
	.half	.L1228-.L1227
	.byte	1,5,17,7,9
	.half	.L1229-.L1228
	.byte	3,1,1,5,40,9
	.half	.L1230-.L1229
	.byte	1,5,60,9
	.half	.L1231-.L1230
	.byte	1,5,64,7,9
	.half	.L1232-.L1231
	.byte	3,3,1,5,111,9
	.half	.L1233-.L1232
	.byte	1,5,13,9
	.half	.L158-.L1233
	.byte	3,153,124,1,5,63,9
	.half	.L1234-.L158
	.byte	3,237,3,1,5,61,9
	.half	.L1235-.L1234
	.byte	1,5,17,9
	.half	.L160-.L1235
	.byte	3,5,1,5,13,9
	.half	.L600-.L160
	.byte	1,5,67,7,9
	.half	.L1236-.L600
	.byte	3,4,1,5,18,9
	.half	.L1237-.L1236
	.byte	1,5,41,9
	.half	.L1238-.L1237
	.byte	1,5,60,9
	.half	.L1239-.L1238
	.byte	3,3,1,5,58,9
	.half	.L1240-.L1239
	.byte	1,5,65,9
	.half	.L1241-.L1240
	.byte	3,3,1,5,47,9
	.half	.L1242-.L1241
	.byte	1,5,46,9
	.half	.L1243-.L1242
	.byte	3,5,1,5,91,9
	.half	.L1244-.L1243
	.byte	3,117,1,5,74,9
	.half	.L161-.L1244
	.byte	3,17,1,5,45,9
	.half	.L1245-.L161
	.byte	3,1,1,5,29,9
	.half	.L1246-.L1245
	.byte	3,3,1,5,9,9
	.half	.L162-.L1246
	.byte	3,3,1,5,17,9
	.half	.L109-.L162
	.byte	3,7,1,5,13,9
	.half	.L1247-.L109
	.byte	1,5,64,7,9
	.half	.L1248-.L1247
	.byte	3,5,1,5,46,9
	.half	.L1249-.L1248
	.byte	1,5,50,9
	.half	.L1250-.L1249
	.byte	3,3,1,5,48,9
	.half	.L1251-.L1250
	.byte	1,5,59,9
	.half	.L1252-.L1251
	.byte	3,3,1,5,57,9
	.half	.L1253-.L1252
	.byte	1,5,78,9
	.half	.L1254-.L1253
	.byte	3,122,1,5,73,9
	.half	.L164-.L1254
	.byte	3,12,1,5,44,9
	.half	.L1255-.L164
	.byte	3,1,1,5,28,9
	.half	.L1256-.L1255
	.byte	3,3,1,5,9,9
	.half	.L165-.L1256
	.byte	3,3,1,5,33,9
	.half	.L112-.L165
	.byte	3,9,1,5,13,9
	.half	.L1257-.L112
	.byte	1,5,39,7,9
	.half	.L1258-.L1257
	.byte	3,3,1,5,62,9
	.half	.L605-.L1258
	.byte	1,5,39,9
	.half	.L167-.L605
	.byte	3,5,1,5,17,9
	.half	.L168-.L167
	.byte	3,4,1,5,13,9
	.half	.L608-.L168
	.byte	1,5,28,7,9
	.half	.L1259-.L608
	.byte	3,5,1,5,43,9
	.half	.L1260-.L1259
	.byte	1,5,37,9
	.half	.L169-.L1260
	.byte	3,5,1,5,17,9
	.half	.L1261-.L169
	.byte	1,5,63,7,9
	.half	.L1262-.L1261
	.byte	3,2,1,5,61,9
	.half	.L1263-.L1262
	.byte	1,5,102,9
	.half	.L1264-.L1263
	.byte	1,5,63,9
	.half	.L171-.L1264
	.byte	3,4,1,5,61,9
	.half	.L1265-.L171
	.byte	1,5,9,9
	.half	.L170-.L1265
	.byte	3,4,1,5,24,9
	.half	.L106-.L170
	.byte	3,200,125,1,5,16,9
	.half	.L609-.L106
	.byte	3,192,2,1,5,39,9
	.half	.L1266-.L609
	.byte	1,5,13,9
	.half	.L1267-.L1266
	.byte	1,5,51,7,9
	.half	.L1268-.L1267
	.byte	3,4,1,5,96,9
	.half	.L1269-.L1268
	.byte	1,5,17,9
	.half	.L175-.L1269
	.byte	3,9,1,5,13,9
	.half	.L611-.L175
	.byte	1,5,28,7,9
	.half	.L1270-.L611
	.byte	3,5,1,5,43,9
	.half	.L1271-.L1270
	.byte	1,5,59,9
	.half	.L176-.L1271
	.byte	3,5,1,5,57,9
	.half	.L1272-.L176
	.byte	1,5,9,9
	.half	.L177-.L1272
	.byte	3,3,1,5,16,9
	.half	.L108-.L177
	.byte	3,38,1,5,13,9
	.half	.L1273-.L108
	.byte	1,5,29,7,9
	.half	.L1274-.L1273
	.byte	3,3,1,5,59,9
	.half	.L1275-.L1274
	.byte	3,4,1,5,57,9
	.half	.L1276-.L1275
	.byte	1,5,31,9
	.half	.L1277-.L1276
	.byte	3,124,1,5,73,9
	.half	.L179-.L1277
	.byte	3,9,1,5,44,9
	.half	.L613-.L179
	.byte	3,1,1,5,28,9
	.half	.L1278-.L613
	.byte	3,3,1,5,9,9
	.half	.L180-.L1278
	.byte	3,3,1,5,57,9
	.half	.L115-.L180
	.byte	3,9,1,5,80,9
	.half	.L1279-.L115
	.byte	1,5,58,9
	.half	.L614-.L1279
	.byte	3,3,1,5,39,9
	.half	.L1280-.L614
	.byte	1,5,75,9
	.half	.L1281-.L1280
	.byte	1,5,74,9
	.half	.L1282-.L1281
	.byte	1,5,90,9
	.half	.L1283-.L1282
	.byte	1,5,13,9
	.half	.L1284-.L1283
	.byte	1,5,42,7,9
	.half	.L1285-.L1284
	.byte	3,5,1,5,66,9
	.half	.L1286-.L1285
	.byte	1,5,83,9
	.half	.L1287-.L1286
	.byte	1,5,34,9
	.half	.L1288-.L1287
	.byte	1,9
	.half	.L617-.L1288
	.byte	3,5,1,5,54,9
	.half	.L1289-.L617
	.byte	1,5,70,9
	.half	.L1290-.L1289
	.byte	1,5,75,9
	.half	.L616-.L1290
	.byte	3,3,1,5,74,9
	.half	.L619-.L616
	.byte	1,5,90,9
	.half	.L1291-.L619
	.byte	1,5,56,9
	.half	.L1292-.L1291
	.byte	1,5,73,9
	.half	.L182-.L1292
	.byte	3,4,1,5,32,9
	.half	.L620-.L182
	.byte	3,3,1,5,64,9
	.half	.L1293-.L620
	.byte	1,5,63,9
	.half	.L621-.L1293
	.byte	1,5,79,9
	.half	.L1294-.L621
	.byte	1,5,13,9
	.half	.L1295-.L1294
	.byte	1,5,59,7,9
	.half	.L1296-.L1295
	.byte	3,3,1,5,57,9
	.half	.L1297-.L1296
	.byte	1,5,97,9
	.half	.L1298-.L1297
	.byte	1,5,59,9
	.half	.L183-.L1298
	.byte	3,6,1,5,57,9
	.half	.L1299-.L183
	.byte	1,5,9,9
	.half	.L184-.L1299
	.byte	3,3,1,5,73,9
	.half	.L116-.L184
	.byte	3,6,1,5,28,9
	.half	.L622-.L116
	.byte	1,5,50,9
	.half	.L625-.L622
	.byte	3,3,1,5,13,9
	.half	.L627-.L625
	.byte	1,5,34,7,9
	.half	.L1300-.L627
	.byte	3,10,1,5,58,9
	.half	.L1301-.L1300
	.byte	1,5,32,9
	.half	.L626-.L1301
	.byte	3,3,1,5,39,9
	.half	.L629-.L626
	.byte	3,3,1,5,17,9
	.half	.L1302-.L629
	.byte	1,5,57,7,9
	.half	.L1303-.L1302
	.byte	3,3,1,5,34,9
	.half	.L187-.L1303
	.byte	3,4,1,5,54,9
	.half	.L1304-.L187
	.byte	1,5,70,9
	.half	.L1305-.L1304
	.byte	1,5,51,9
	.half	.L583-.L1305
	.byte	3,173,123,1,5,57,9
	.half	.L1306-.L583
	.byte	3,214,4,1,5,20,9
	.half	.L1307-.L1306
	.byte	1,5,70,7,9
	.half	.L1308-.L1307
	.byte	3,1,1,5,42,7,9
	.half	.L188-.L1308
	.byte	3,3,1,5,68,9
	.half	.L630-.L188
	.byte	3,3,1,5,67,9
	.half	.L1309-.L630
	.byte	1,5,83,9
	.half	.L1310-.L1309
	.byte	1,5,49,9
	.half	.L1311-.L1310
	.byte	1,5,63,9
	.half	.L1312-.L1311
	.byte	3,3,1,5,61,9
	.half	.L1313-.L1312
	.byte	1,5,57,9
	.half	.L1314-.L1313
	.byte	3,122,1,5,21,9
	.half	.L189-.L1314
	.byte	3,12,1,5,72,7,9
	.half	.L1315-.L189
	.byte	3,3,1,5,71,9
	.half	.L1316-.L1315
	.byte	1,5,87,9
	.half	.L1317-.L1316
	.byte	1,5,53,9
	.half	.L1318-.L1317
	.byte	1,5,67,9
	.half	.L1319-.L1318
	.byte	3,3,1,5,65,9
	.half	.L1320-.L1319
	.byte	1,5,111,9
	.half	.L1321-.L1320
	.byte	3,125,1,5,46,9
	.half	.L191-.L1321
	.byte	3,15,1,5,72,9
	.half	.L631-.L191
	.byte	3,3,1,5,71,9
	.half	.L1322-.L631
	.byte	1,5,87,9
	.half	.L1323-.L1322
	.byte	1,5,53,9
	.half	.L1324-.L1323
	.byte	1,5,25,9
	.half	.L1325-.L1324
	.byte	3,3,1,5,43,9
	.half	.L1326-.L1325
	.byte	1,5,41,9
	.half	.L1327-.L1326
	.byte	1,5,67,9
	.half	.L1328-.L1327
	.byte	3,3,1,5,65,9
	.half	.L1329-.L1328
	.byte	1,5,9,9
	.half	.L186-.L1329
	.byte	3,5,1,5,48,9
	.half	.L117-.L186
	.byte	3,7,1,5,13,9
	.half	.L632-.L117
	.byte	3,3,1,5,17,7,9
	.half	.L1330-.L632
	.byte	3,5,1,5,24,7,9
	.half	.L1331-.L1330
	.byte	3,11,1,5,21,9
	.half	.L1332-.L1331
	.byte	1,5,37,7,9
	.half	.L1333-.L1332
	.byte	3,3,1,5,64,9
	.half	.L633-.L1333
	.byte	1,5,29,9
	.half	.L198-.L633
	.byte	3,3,1,5,74,9
	.half	.L1334-.L198
	.byte	3,125,1,5,64,9
	.half	.L197-.L1334
	.byte	1,5,37,7,9
	.half	.L1335-.L197
	.byte	3,7,1,5,69,9
	.half	.L634-.L1335
	.byte	1,5,55,9
	.half	.L200-.L634
	.byte	3,3,1,5,79,9
	.half	.L1336-.L200
	.byte	3,125,1,5,50,9
	.half	.L199-.L1336
	.byte	1,5,69,9
	.half	.L1337-.L199
	.byte	1,5,63,7,9
	.half	.L196-.L1337
	.byte	3,14,1,5,61,9
	.half	.L1338-.L196
	.byte	1,5,9,9
	.half	.L194-.L1338
	.byte	3,5,1,5,73,9
	.half	.L118-.L194
	.byte	3,6,1,5,28,9
	.half	.L636-.L118
	.byte	1,5,40,9
	.half	.L638-.L636
	.byte	3,3,1,5,68,9
	.half	.L641-.L638
	.byte	3,3,1,5,13,9
	.half	.L643-.L641
	.byte	3,3,1,5,17,7,9
	.half	.L1339-.L643
	.byte	3,6,1,5,24,7,9
	.half	.L1340-.L1339
	.byte	3,5,1,5,21,9
	.half	.L1341-.L1340
	.byte	1,5,36,7,9
	.half	.L1342-.L1341
	.byte	3,4,1,5,51,9
	.half	.L1343-.L1342
	.byte	1,5,39,9
	.half	.L204-.L1343
	.byte	3,7,1,5,56,9
	.half	.L1344-.L204
	.byte	1,5,55,9
	.half	.L640-.L1344
	.byte	1,5,71,9
	.half	.L1345-.L640
	.byte	1,5,29,9
	.half	.L645-.L1345
	.byte	3,2,1,5,25,9
	.half	.L1346-.L645
	.byte	1,5,74,7,9
	.half	.L1347-.L1346
	.byte	3,3,1,5,90,9
	.half	.L1348-.L1347
	.byte	1,5,121,9
	.half	.L1349-.L1348
	.byte	1,5,41,9
	.half	.L1350-.L1349
	.byte	1,5,70,9
	.half	.L1351-.L1350
	.byte	3,3,1,5,44,9
	.half	.L208-.L1351
	.byte	3,2,1,5,37,9
	.half	.L207-.L208
	.byte	3,126,1,5,70,9
	.half	.L1352-.L207
	.byte	1,5,80,7,9
	.half	.L1353-.L1352
	.byte	3,6,1,5,29,9
	.half	.L1354-.L1353
	.byte	1,5,45,9
	.half	.L1355-.L1354
	.byte	3,2,1,5,29,9
	.half	.L209-.L1355
	.byte	3,126,1,5,67,9
	.half	.L210-.L209
	.byte	3,11,1,9
	.half	.L1356-.L210
	.byte	3,1,1,5,65,9
	.half	.L1357-.L1356
	.byte	1,5,21,9
	.half	.L205-.L1357
	.byte	3,97,1,5,38,9
	.half	.L203-.L205
	.byte	3,41,1,5,62,9
	.half	.L1358-.L203
	.byte	1,5,42,9
	.half	.L647-.L1358
	.byte	3,3,1,5,63,9
	.half	.L644-.L647
	.byte	3,3,1,5,61,9
	.half	.L1359-.L644
	.byte	1,5,9,9
	.half	.L202-.L1359
	.byte	3,4,1,5,73,9
	.half	.L119-.L202
	.byte	3,5,1,5,68,9
	.half	.L648-.L119
	.byte	3,3,1,5,13,9
	.half	.L650-.L648
	.byte	3,3,1,5,59,7,9
	.half	.L1360-.L650
	.byte	3,4,1,5,57,9
	.half	.L1361-.L1360
	.byte	1,5,8,9
	.half	.L213-.L1361
	.byte	3,3,1,5,24,9
	.half	.L92-.L213
	.byte	3,31,1,5,9,9
	.half	.L1362-.L92
	.byte	3,1,1,5,5,9
	.half	.L128-.L1362
	.byte	3,4,1,5,51,7,9
	.half	.L1363-.L128
	.byte	3,2,1,5,49,9
	.half	.L1364-.L1363
	.byte	1,5,9,9
	.half	.L1365-.L1364
	.byte	3,3,1,5,32,9
	.half	.L1366-.L1365
	.byte	1,5,49,9
	.half	.L1367-.L1366
	.byte	1,5,47,9
	.half	.L1368-.L1367
	.byte	1,5,9,9
	.half	.L1369-.L1368
	.byte	3,1,1,5,24,9
	.half	.L1370-.L1369
	.byte	1,5,22,9
	.half	.L1371-.L1370
	.byte	1,5,5,9
	.half	.L216-.L1371
	.byte	3,3,1,5,1,9
	.half	.L217-.L216
	.byte	3,1,1,7,9
	.half	.L355-.L217
	.byte	0,1,1
.L1088:
	.sdecl	'.debug_ranges',debug,cluster('Fee_LLCpyBlkFromFls2Fls')
	.sect	'.debug_ranges'
.L354:
	.word	-1,.L325,0,.L355-.L325,0,0
	.sdecl	'.debug_info',debug,cluster('Fee_LLPrepMarkerBufWithMarkerData')
	.sect	'.debug_info'
.L356:
	.word	281
	.half	3
	.word	.L357
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L359,.L358
	.byte	2
	.word	.L332
	.byte	3
	.byte	'Fee_LLPrepMarkerBufWithMarkerData',0,1,208,3,22,1,1,1
	.word	.L313,.L449,.L312
	.byte	4
	.byte	'Marker_pcst',0,1,208,3,108
	.word	.L450,.L451
	.byte	4
	.byte	'MarkerBuf_pu8',0,1,209,3,95
	.word	.L447,.L452
	.byte	5
	.word	.L313,.L449
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('Fee_LLPrepMarkerBufWithMarkerData')
	.sect	'.debug_abbrev'
.L357:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('Fee_LLPrepMarkerBufWithMarkerData')
	.sect	'.debug_line'
.L358:
	.word	.L1373-.L1372
.L1372:
	.half	3
	.word	.L1375-.L1374
.L1374:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c',0,0,0,0,0
.L1375:
	.byte	5,43,7,0,5,2
	.word	.L313
	.byte	3,211,3,1,5,54,9
	.half	.L1376-.L313
	.byte	1,5,22,9
	.half	.L1377-.L1376
	.byte	1,5,42,9
	.half	.L1378-.L1377
	.byte	3,1,1,5,22,9
	.half	.L1379-.L1378
	.byte	1,5,35,9
	.half	.L1380-.L1379
	.byte	3,2,1,5,22,9
	.half	.L1381-.L1380
	.byte	1,5,45,9
	.half	.L1382-.L1381
	.byte	3,3,1,5,22,9
	.half	.L1383-.L1382
	.byte	1,5,45,9
	.half	.L1384-.L1383
	.byte	3,1,1,5,22,9
	.half	.L1385-.L1384
	.byte	1,5,45,9
	.half	.L1386-.L1385
	.byte	3,1,1,5,22,9
	.half	.L1387-.L1386
	.byte	1,5,43,9
	.half	.L1388-.L1387
	.byte	3,3,1,5,55,9
	.half	.L1389-.L1388
	.byte	1,5,22,9
	.half	.L1390-.L1389
	.byte	1,5,42,9
	.half	.L1391-.L1390
	.byte	3,1,1,5,22,9
	.half	.L1392-.L1391
	.byte	1,5,1,9
	.half	.L1393-.L1392
	.byte	3,1,1,7,9
	.half	.L360-.L1393
	.byte	0,1,1
.L1373:
	.sdecl	'.debug_ranges',debug,cluster('Fee_LLPrepMarkerBufWithMarkerData')
	.sect	'.debug_ranges'
.L359:
	.word	-1,.L313,0,.L360-.L313,0,0
	.sdecl	'.debug_info',debug,cluster('Fee_LLCopyPageBuff2Marker')
	.sect	'.debug_info'
.L361:
	.word	271
	.half	3
	.word	.L362
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L364,.L363
	.byte	2
	.word	.L332
	.byte	3
	.byte	'Fee_LLCopyPageBuff2Marker',0,1,164,3,22,1,1,1
	.word	.L311,.L453,.L310
	.byte	4
	.byte	'Marker_pst',0,1,164,3,98
	.word	.L454,.L455
	.byte	4
	.byte	'PageBuf_pcu8',0,1,165,3,89
	.word	.L406,.L456
	.byte	5
	.word	.L311,.L453
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('Fee_LLCopyPageBuff2Marker')
	.sect	'.debug_abbrev'
.L362:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('Fee_LLCopyPageBuff2Marker')
	.sect	'.debug_line'
.L363:
	.word	.L1395-.L1394
.L1394:
	.half	3
	.word	.L1397-.L1396
.L1396:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c',0,0,0,0,0
.L1397:
	.byte	5,64,7,0,5,2
	.word	.L311
	.byte	3,167,3,1,5,70,9
	.half	.L1398-.L311
	.byte	1,5,99,9
	.half	.L1399-.L1398
	.byte	1,5,77,9
	.half	.L1400-.L1399
	.byte	1,5,30,9
	.half	.L1401-.L1400
	.byte	1,5,44,9
	.half	.L1402-.L1401
	.byte	3,1,1,5,30,9
	.half	.L1403-.L1402
	.byte	1,5,44,9
	.half	.L1404-.L1403
	.byte	3,3,1,5,30,9
	.half	.L1405-.L1404
	.byte	1,5,44,9
	.half	.L1406-.L1405
	.byte	3,1,1,5,30,9
	.half	.L1407-.L1406
	.byte	1,5,44,9
	.half	.L1408-.L1407
	.byte	3,1,1,5,30,9
	.half	.L1409-.L1408
	.byte	1,5,64,9
	.half	.L1410-.L1409
	.byte	3,3,1,5,70,9
	.half	.L1411-.L1410
	.byte	1,5,99,9
	.half	.L1412-.L1411
	.byte	1,5,77,9
	.half	.L1413-.L1412
	.byte	1,5,30,9
	.half	.L1414-.L1413
	.byte	1,5,1,9
	.half	.L1415-.L1414
	.byte	3,2,1,7,9
	.half	.L365-.L1415
	.byte	0,1,1
.L1395:
	.sdecl	'.debug_ranges',debug,cluster('Fee_LLCopyPageBuff2Marker')
	.sect	'.debug_ranges'
.L364:
	.word	-1,.L311,0,.L365-.L311,0,0
	.sdecl	'.debug_info',debug,cluster('Fee_LLPrepPageBufWithHdrDataStart')
	.sect	'.debug_info'
.L366:
	.word	284
	.half	3
	.word	.L367
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L369,.L368
	.byte	2
	.word	.L332
	.byte	3
	.byte	'Fee_LLPrepPageBufWithHdrDataStart',0,1,205,4,22,1,1,1
	.word	.L319,.L457,.L318
	.byte	4
	.byte	'HeaderInfo_pst',0,1,205,4,118
	.word	.L458,.L459
	.byte	5
	.word	.L319,.L457
	.byte	6
	.byte	'xPageCrc_u16',0,1,207,4,28
	.word	.L409,.L460
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('Fee_LLPrepPageBufWithHdrDataStart')
	.sect	'.debug_abbrev'
.L367:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,52,0,3
	.byte	8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('Fee_LLPrepPageBufWithHdrDataStart')
	.sect	'.debug_line'
.L368:
	.word	.L1417-.L1416
.L1416:
	.half	3
	.word	.L1419-.L1418
.L1418:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c',0,0,0,0,0
.L1419:
	.byte	5,22,7,0,5,2
	.word	.L319
	.byte	3,204,4,1,5,5,9
	.half	.L522-.L319
	.byte	3,5,1,5,51,9
	.half	.L1420-.L522
	.byte	1,5,49,9
	.half	.L1421-.L1420
	.byte	1,5,5,9
	.half	.L1422-.L1421
	.byte	3,3,1,5,31,9
	.half	.L1423-.L1422
	.byte	1,5,29,9
	.half	.L1424-.L1423
	.byte	1,5,5,9
	.half	.L1425-.L1424
	.byte	3,1,1,5,31,9
	.half	.L1426-.L1425
	.byte	1,5,29,9
	.half	.L1427-.L1426
	.byte	1,5,5,9
	.half	.L1428-.L1427
	.byte	3,1,1,5,31,9
	.half	.L1429-.L1428
	.byte	1,5,29,9
	.half	.L1430-.L1429
	.byte	1,5,5,9
	.half	.L1431-.L1430
	.byte	3,2,1,5,45,9
	.half	.L1432-.L1431
	.byte	1,5,29,9
	.half	.L1433-.L1432
	.byte	1,5,5,9
	.half	.L1434-.L1433
	.byte	3,3,1,5,53,9
	.half	.L1435-.L1434
	.byte	1,5,68,9
	.half	.L1436-.L1435
	.byte	1,5,29,9
	.half	.L1437-.L1436
	.byte	1,5,5,9
	.half	.L1438-.L1437
	.byte	3,2,1,5,54,9
	.half	.L1439-.L1438
	.byte	1,5,29,9
	.half	.L1440-.L1439
	.byte	1,5,5,9
	.half	.L1441-.L1440
	.byte	3,3,1,5,53,9
	.half	.L1442-.L1441
	.byte	1,5,69,9
	.half	.L1443-.L1442
	.byte	1,5,29,9
	.half	.L1444-.L1443
	.byte	1,5,5,9
	.half	.L1445-.L1444
	.byte	3,2,1,5,54,9
	.half	.L1446-.L1445
	.byte	1,5,29,9
	.half	.L1447-.L1446
	.byte	1,5,48,9
	.half	.L1448-.L1447
	.byte	3,3,1,5,71,9
	.half	.L521-.L1448
	.byte	3,1,1,5,43,9
	.half	.L1449-.L521
	.byte	3,1,1,5,44,9
	.half	.L1450-.L1449
	.byte	3,1,1,5,5,9
	.half	.L523-.L1450
	.byte	3,2,1,5,52,9
	.half	.L1451-.L523
	.byte	1,5,29,9
	.half	.L1452-.L1451
	.byte	1,5,5,9
	.half	.L1453-.L1452
	.byte	3,1,1,5,29,9
	.half	.L1454-.L1453
	.byte	1,5,34,9
	.half	.L1455-.L1454
	.byte	3,4,1,5,1,9
	.half	.L1456-.L1455
	.byte	3,1,1,7,9
	.half	.L370-.L1456
	.byte	0,1,1
.L1417:
	.sdecl	'.debug_ranges',debug,cluster('Fee_LLPrepPageBufWithHdrDataStart')
	.sect	'.debug_ranges'
.L369:
	.word	-1,.L319,0,.L370-.L319,0,0
	.sdecl	'.debug_info',debug,cluster('Fee_LLPrepPageBufWithHdrDataEnd')
	.sect	'.debug_info'
.L371:
	.word	347
	.half	3
	.word	.L372
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L374,.L373
	.byte	2
	.word	.L332
	.byte	3
	.byte	'Fee_LLPrepPageBufWithHdrDataEnd',0,1,144,5,22,1,1,1
	.word	.L321,.L461,.L320
	.byte	4
	.byte	'HeaderInfo_pst',0,1,144,5,116
	.word	.L458,.L462
	.byte	4
	.byte	'Data_pcu8',0,1,145,5,97
	.word	.L406,.L463
	.byte	4
	.byte	'BlkCrc32_u32',0,1,146,5,79
	.word	.L396,.L464
	.byte	5
	.word	.L321,.L461
	.byte	6
	.byte	'xNumBytes_u16',0,1,148,5,28
	.word	.L409,.L465
	.byte	6
	.byte	'i',0,1,149,5,28
	.word	.L409,.L466
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('Fee_LLPrepPageBufWithHdrDataEnd')
	.sect	'.debug_abbrev'
.L372:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6,52,0,3
	.byte	8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('Fee_LLPrepPageBufWithHdrDataEnd')
	.sect	'.debug_line'
.L373:
	.word	.L1458-.L1457
.L1457:
	.half	3
	.word	.L1460-.L1459
.L1459:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c',0,0,0,0,0
.L1460:
	.byte	5,22,7,0,5,2
	.word	.L321
	.byte	3,143,5,1,5,5,9
	.half	.L527-.L321
	.byte	3,8,1,5,51,9
	.half	.L1461-.L527
	.byte	1,5,49,9
	.half	.L1462-.L1461
	.byte	1,5,5,9
	.half	.L1463-.L1462
	.byte	3,3,1,5,54,9
	.half	.L1464-.L1463
	.byte	1,5,30,9
	.half	.L1465-.L1464
	.byte	1,5,5,9
	.half	.L1466-.L1465
	.byte	3,1,1,5,54,9
	.half	.L1467-.L1466
	.byte	1,5,30,9
	.half	.L1468-.L1467
	.byte	1,5,5,9
	.half	.L1469-.L1468
	.byte	3,1,1,5,54,9
	.half	.L1470-.L1469
	.byte	1,5,30,9
	.half	.L1471-.L1470
	.byte	1,5,5,9
	.half	.L1472-.L1471
	.byte	3,1,1,5,30,9
	.half	.L1473-.L1472
	.byte	1,5,34,9
	.half	.L1474-.L1473
	.byte	3,3,1,5,23,9
	.half	.L1475-.L1474
	.byte	3,5,1,5,38,9
	.half	.L1476-.L1475
	.byte	1,5,5,9
	.half	.L1477-.L1476
	.byte	1,5,23,7,9
	.half	.L1478-.L1477
	.byte	3,5,1,5,52,9
	.half	.L524-.L1478
	.byte	1,5,39,9
	.half	.L51-.L524
	.byte	3,5,1,5,51,9
	.half	.L52-.L51
	.byte	3,5,1,5,34,9
	.half	.L1479-.L52
	.byte	1,5,11,9
	.half	.L1480-.L1479
	.byte	1,5,51,9
	.half	.L1481-.L1480
	.byte	1,5,50,9
	.half	.L1482-.L1481
	.byte	1,5,70,9
	.half	.L1483-.L1482
	.byte	1,5,33,9
	.half	.L1484-.L1483
	.byte	1,5,88,9
	.half	.L1485-.L1484
	.byte	1,5,99,9
	.half	.L1486-.L1485
	.byte	1,5,77,9
	.half	.L1487-.L1486
	.byte	3,1,1,5,8,9
	.half	.L1488-.L1487
	.byte	3,127,1,5,71,7,9
	.half	.L1489-.L1488
	.byte	3,2,1,5,23,7,9
	.half	.L1490-.L1489
	.byte	3,3,1,5,5,9
	.half	.L53-.L1490
	.byte	3,4,1,5,23,9
	.half	.L1491-.L53
	.byte	3,3,1,5,10,9
	.half	.L55-.L1491
	.byte	3,5,1,5,29,9
	.half	.L529-.L55
	.byte	1,5,13,9
	.half	.L57-.L529
	.byte	3,6,1,5,33,9
	.half	.L1492-.L57
	.byte	1,5,27,9
	.half	.L1493-.L1492
	.byte	3,125,1,5,9,9
	.half	.L1494-.L1493
	.byte	1,5,59,7,9
	.half	.L1495-.L1494
	.byte	3,3,1,5,57,9
	.half	.L1496-.L1495
	.byte	1,5,60,9
	.half	.L1497-.L1496
	.byte	1,5,68,9
	.half	.L58-.L1497
	.byte	3,5,1,5,57,9
	.half	.L1498-.L58
	.byte	1,5,35,9
	.half	.L1499-.L1498
	.byte	3,5,1,5,56,9
	.half	.L1500-.L1499
	.byte	1,5,32,9
	.half	.L59-.L1500
	.byte	3,112,1,5,29,9
	.half	.L56-.L59
	.byte	1,5,50,7,9
	.half	.L1501-.L56
	.byte	3,22,1,5,49,9
	.half	.L531-.L1501
	.byte	1,5,69,9
	.half	.L1502-.L531
	.byte	1,5,32,9
	.half	.L1503-.L1502
	.byte	1,5,87,9
	.half	.L1504-.L1503
	.byte	1,5,98,9
	.half	.L1505-.L1504
	.byte	1,5,79,9
	.half	.L1506-.L1505
	.byte	3,1,1,5,5,9
	.half	.L1507-.L1506
	.byte	3,127,1,5,9,7,9
	.half	.L1508-.L1507
	.byte	3,8,1,5,56,9
	.half	.L1509-.L1508
	.byte	1,5,76,9
	.half	.L1510-.L1509
	.byte	1,5,79,9
	.half	.L1511-.L1510
	.byte	3,2,1,5,97,9
	.half	.L1512-.L1511
	.byte	1,5,95,9
	.half	.L1513-.L1512
	.byte	1,5,55,9
	.half	.L1514-.L1513
	.byte	3,1,1,5,34,9
	.half	.L525-.L1514
	.byte	3,125,1,5,1,9
	.half	.L60-.L525
	.byte	3,6,1,7,9
	.half	.L375-.L60
	.byte	0,1,1
.L1458:
	.sdecl	'.debug_ranges',debug,cluster('Fee_LLPrepPageBufWithHdrDataEnd')
	.sect	'.debug_ranges'
.L374:
	.word	-1,.L321,0,.L375-.L321,0,0
	.sdecl	'.debug_info',debug,cluster('Fee_LLCopyPageBuff2HeaderMid')
	.sect	'.debug_info'
.L376:
	.word	274
	.half	3
	.word	.L377
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L379,.L378
	.byte	2
	.word	.L332
	.byte	3
	.byte	'Fee_LLCopyPageBuff2HeaderMid',0,1,255,3,22,1,1,1
	.word	.L315,.L467,.L314
	.byte	4
	.byte	'BlkHdr_pst',0,1,255,3,102
	.word	.L468,.L469
	.byte	4
	.byte	'PageBuf_pcu8',0,1,128,4,92
	.word	.L406,.L470
	.byte	5
	.word	.L315,.L467
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('Fee_LLCopyPageBuff2HeaderMid')
	.sect	'.debug_abbrev'
.L377:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('Fee_LLCopyPageBuff2HeaderMid')
	.sect	'.debug_line'
.L378:
	.word	.L1516-.L1515
.L1515:
	.half	3
	.word	.L1518-.L1517
.L1517:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c',0,0,0,0,0
.L1518:
	.byte	5,47,7,0,5,2
	.word	.L315
	.byte	3,129,4,1,5,33,9
	.half	.L1519-.L315
	.byte	1,5,67,9
	.half	.L1520-.L1519
	.byte	3,3,1,5,73,9
	.half	.L1521-.L1520
	.byte	1,5,104,9
	.half	.L1522-.L1521
	.byte	1,5,81,9
	.half	.L1523-.L1522
	.byte	1,5,33,9
	.half	.L1524-.L1523
	.byte	1,5,67,9
	.half	.L1525-.L1524
	.byte	3,3,1,5,73,9
	.half	.L1526-.L1525
	.byte	1,5,104,9
	.half	.L1527-.L1526
	.byte	1,5,81,9
	.half	.L1528-.L1527
	.byte	1,5,33,9
	.half	.L1529-.L1528
	.byte	1,5,67,9
	.half	.L1530-.L1529
	.byte	3,3,1,5,73,9
	.half	.L1531-.L1530
	.byte	1,5,104,9
	.half	.L1532-.L1531
	.byte	1,5,81,9
	.half	.L1533-.L1532
	.byte	1,5,33,9
	.half	.L1534-.L1533
	.byte	1,5,1,9
	.half	.L1535-.L1534
	.byte	3,1,1,7,9
	.half	.L380-.L1535
	.byte	0,1,1
.L1516:
	.sdecl	'.debug_ranges',debug,cluster('Fee_LLCopyPageBuff2HeaderMid')
	.sect	'.debug_ranges'
.L379:
	.word	-1,.L315,0,.L380-.L315,0,0
	.sdecl	'.debug_info',debug,cluster('Fee_LLCopyPageBuff2HeaderEnd')
	.sect	'.debug_info'
.L381:
	.word	274
	.half	3
	.word	.L382
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L384,.L383
	.byte	2
	.word	.L332
	.byte	3
	.byte	'Fee_LLCopyPageBuff2HeaderEnd',0,1,169,4,22,1,1,1
	.word	.L317,.L471,.L316
	.byte	4
	.byte	'BlkHdr_pst',0,1,169,4,102
	.word	.L468,.L472
	.byte	4
	.byte	'PageBuf_pcu8',0,1,170,4,92
	.word	.L406,.L473
	.byte	5
	.word	.L317,.L471
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('Fee_LLCopyPageBuff2HeaderEnd')
	.sect	'.debug_abbrev'
.L382:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('Fee_LLCopyPageBuff2HeaderEnd')
	.sect	'.debug_line'
.L383:
	.word	.L1537-.L1536
.L1536:
	.half	3
	.word	.L1539-.L1538
.L1538:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c',0,0,0,0,0
.L1539:
	.byte	5,67,7,0,5,2
	.word	.L317
	.byte	3,171,4,1,5,74,9
	.half	.L1540-.L317
	.byte	1,5,67,9
	.half	.L1541-.L1540
	.byte	3,1,1,5,74,9
	.half	.L1542-.L1541
	.byte	1,5,82,9
	.half	.L1543-.L1542
	.byte	3,127,1,5,67,9
	.half	.L1544-.L1543
	.byte	3,2,1,5,74,9
	.half	.L1545-.L1544
	.byte	1,5,82,9
	.half	.L1546-.L1545
	.byte	3,127,1,5,67,9
	.half	.L1547-.L1546
	.byte	3,2,1,5,82,9
	.half	.L1548-.L1547
	.byte	3,127,1,5,33,9
	.half	.L1549-.L1548
	.byte	3,126,1,5,1,9
	.half	.L1550-.L1549
	.byte	3,4,1,7,9
	.half	.L385-.L1550
	.byte	0,1,1
.L1537:
	.sdecl	'.debug_ranges',debug,cluster('Fee_LLCopyPageBuff2HeaderEnd')
	.sect	'.debug_ranges'
.L384:
	.word	-1,.L317,0,.L385-.L317,0,0
	.sdecl	'.debug_info',debug,cluster('Fee_LLCopyData2Buffer')
	.sect	'.debug_info'
.L386:
	.word	553
	.half	3
	.word	.L387
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L389,.L388
	.byte	2
	.word	.L332
	.byte	3
	.byte	'Fee_LLCopyData2Buffer',0,1,134,6,34
	.word	.L402
	.byte	1,1,1
	.word	.L323,.L474,.L322
	.byte	4
	.byte	'Fee_GlobInfoLastRdHeader_pcst',0,1,134,6,120
	.word	.L404,.L475
	.byte	4
	.byte	'DataPtr_pu8',0,1,135,6,95
	.word	.L447,.L476
	.byte	4
	.byte	'DataOffset_u16',0,1,136,6,77
	.word	.L409,.L477
	.byte	4
	.byte	'DataLength_u16',0,1,137,6,77
	.word	.L409,.L478
	.byte	5
	.word	.L323,.L474
	.byte	6
	.byte	'xRetVal_en',0,1,139,6,38
	.word	.L402,.L479
	.byte	6
	.byte	'xNumBytesToSectEnd_u32',0,1,140,6,26
	.word	.L396,.L480
	.byte	6
	.byte	'xNumBytesOfsConsid_u16',0,1,141,6,26
	.word	.L409,.L481
	.byte	6
	.byte	'xLogSectIdx_u8',0,1,142,6,26
	.word	.L399,.L482
	.byte	6
	.byte	'xCntSect_u8',0,1,143,6,26
	.word	.L399,.L483
	.byte	6
	.byte	'xPhySectIdx_u8',0,1,144,6,26
	.word	.L399,.L484
	.byte	6
	.byte	'xStartAdrFound_b',0,1,145,6,27
	.word	.L399,.L485
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('Fee_LLCopyData2Buffer')
	.sect	'.debug_abbrev'
.L387:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('Fee_LLCopyData2Buffer')
	.sect	'.debug_line'
.L388:
	.word	.L1552-.L1551
.L1551:
	.half	3
	.word	.L1554-.L1553
.L1553:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c',0,0,0,0,0
.L1554:
	.byte	5,34,7,0,5,2
	.word	.L323
	.byte	3,133,6,1,5,49,9
	.half	.L539-.L323
	.byte	3,5,1,9
	.half	.L541-.L539
	.byte	3,2,1,9
	.half	.L542-.L541
	.byte	3,2,1,9
	.half	.L544-.L542
	.byte	3,2,1,5,13,9
	.half	.L546-.L544
	.byte	3,4,1,5,29,9
	.half	.L1555-.L546
	.byte	1,5,14,9
	.half	.L1556-.L1555
	.byte	3,3,1,9
	.half	.L1557-.L1556
	.byte	3,227,0,1,9
	.half	.L1558-.L1557
	.byte	3,33,1,9
	.half	.L1559-.L1558
	.byte	3,20,1,9
	.half	.L1560-.L1559
	.byte	3,20,1,5,13,9
	.half	.L61-.L1560
	.byte	3,215,126,1,5,59,9
	.half	.L1561-.L61
	.byte	1,5,57,9
	.half	.L1562-.L1561
	.byte	1,5,81,9
	.half	.L1563-.L1562
	.byte	3,6,1,5,100,9
	.half	.L1564-.L1563
	.byte	1,5,41,9
	.half	.L1565-.L1564
	.byte	1,5,73,9
	.half	.L1566-.L1565
	.byte	3,4,1,5,28,9
	.half	.L533-.L1566
	.byte	1,5,38,9
	.half	.L548-.L533
	.byte	3,3,1,5,62,9
	.half	.L1567-.L548
	.byte	1,5,37,9
	.half	.L547-.L1567
	.byte	3,4,1,5,26,9
	.half	.L1568-.L547
	.byte	3,127,1,5,43,9
	.half	.L1569-.L1568
	.byte	1,5,42,9
	.half	.L1570-.L1569
	.byte	1,5,58,9
	.half	.L1571-.L1570
	.byte	1,5,13,9
	.half	.L1572-.L1571
	.byte	1,5,74,7,9
	.half	.L69-.L1572
	.byte	3,8,1,5,73,9
	.half	.L1573-.L69
	.byte	1,5,89,9
	.half	.L1574-.L1573
	.byte	1,5,45,9
	.half	.L1575-.L1574
	.byte	3,1,1,5,89,9
	.half	.L1576-.L1575
	.byte	3,127,1,5,44,9
	.half	.L1577-.L1576
	.byte	1,5,35,9
	.half	.L551-.L1577
	.byte	3,4,1,5,58,9
	.half	.L552-.L551
	.byte	3,6,1,5,38,9
	.half	.L1578-.L552
	.byte	1,5,58,9
	.half	.L1579-.L1578
	.byte	1,5,74,9
	.half	.L1580-.L1579
	.byte	1,5,32,9
	.half	.L1581-.L1580
	.byte	3,3,1,5,52,9
	.half	.L553-.L1581
	.byte	3,4,1,5,51,9
	.half	.L1582-.L553
	.byte	1,5,67,9
	.half	.L1583-.L1582
	.byte	1,9
	.half	.L1584-.L1583
	.byte	3,127,1,5,50,9
	.half	.L1585-.L1584
	.byte	3,2,1,5,21,9
	.half	.L1586-.L1585
	.byte	3,126,1,5,122,7,9
	.half	.L1587-.L1586
	.byte	3,7,1,5,80,9
	.half	.L1588-.L1587
	.byte	3,1,1,5,53,9
	.half	.L1589-.L1588
	.byte	3,127,1,5,42,9
	.half	.L1590-.L1589
	.byte	3,5,1,5,87,9
	.half	.L1591-.L1590
	.byte	3,125,1,5,53,9
	.half	.L70-.L1591
	.byte	3,10,1,5,23,9
	.half	.L71-.L70
	.byte	3,4,1,5,39,7,9
	.half	.L1592-.L71
	.byte	3,1,1,5,36,9
	.half	.L1593-.L1592
	.byte	1,7,9
	.half	.L1594-.L1593
	.byte	1,5,45,9
	.half	.L67-.L1594
	.byte	3,6,1,5,65,9
	.half	.L72-.L67
	.byte	3,4,1,5,64,9
	.half	.L549-.L72
	.byte	1,5,80,9
	.half	.L1595-.L549
	.byte	1,5,37,9
	.half	.L1596-.L1595
	.byte	3,1,1,5,80,9
	.half	.L1597-.L1596
	.byte	3,127,1,5,39,9
	.half	.L1598-.L1597
	.byte	3,7,1,5,13,9
	.half	.L1599-.L1598
	.byte	3,125,1,5,55,7,9
	.half	.L1600-.L1599
	.byte	3,3,1,5,87,9
	.half	.L1601-.L1600
	.byte	1,5,55,9
	.half	.L73-.L1601
	.byte	3,5,1,5,49,9
	.half	.L74-.L73
	.byte	3,4,1,5,47,9
	.half	.L555-.L74
	.byte	1,5,13,9
	.half	.L62-.L555
	.byte	3,166,127,1,5,16,9
	.half	.L1602-.L62
	.byte	3,233,0,1,5,13,9
	.half	.L1603-.L1602
	.byte	1,5,53,7,9
	.half	.L1604-.L1603
	.byte	3,5,1,5,51,9
	.half	.L1605-.L1604
	.byte	1,5,95,9
	.half	.L1606-.L1605
	.byte	3,4,1,9
	.half	.L1607-.L1606
	.byte	3,127,1,5,117,9
	.half	.L1608-.L1607
	.byte	1,5,61,9
	.half	.L1609-.L1608
	.byte	1,5,113,9
	.half	.L1610-.L1609
	.byte	3,4,1,5,76,9
	.half	.L1611-.L1610
	.byte	3,121,1,5,28,9
	.half	.L75-.L1611
	.byte	3,13,1,5,9,9
	.half	.L76-.L75
	.byte	3,3,1,5,17,9
	.half	.L63-.L76
	.byte	3,9,1,5,13,9
	.half	.L1612-.L63
	.byte	1,5,17,7,9
	.half	.L1613-.L1612
	.byte	3,3,1,5,34,9
	.half	.L78-.L1613
	.byte	3,5,1,5,9,9
	.half	.L1614-.L78
	.byte	3,3,1,5,16,9
	.half	.L64-.L1614
	.byte	3,6,1,5,13,9
	.half	.L1615-.L64
	.byte	1,5,35,7,9
	.half	.L1616-.L1615
	.byte	3,3,1,5,53,9
	.half	.L1617-.L1616
	.byte	3,3,1,5,51,9
	.half	.L1618-.L1617
	.byte	1,5,37,9
	.half	.L1619-.L1618
	.byte	3,125,1,5,28,9
	.half	.L80-.L1619
	.byte	3,8,1,5,9,9
	.half	.L81-.L80
	.byte	3,3,1,5,16,9
	.half	.L65-.L81
	.byte	3,14,1,5,38,9
	.half	.L1620-.L65
	.byte	1,5,13,9
	.half	.L1621-.L1620
	.byte	1,5,28,7,9
	.half	.L1622-.L1621
	.byte	3,3,1,5,50,9
	.half	.L1623-.L1622
	.byte	1,5,77,9
	.half	.L83-.L1623
	.byte	3,8,1,5,42,9
	.half	.L556-.L83
	.byte	3,3,1,5,66,9
	.half	.L1624-.L556
	.byte	1,5,83,9
	.half	.L1625-.L1624
	.byte	1,5,34,9
	.half	.L1626-.L1625
	.byte	1,5,54,9
	.half	.L559-.L1626
	.byte	3,6,1,5,34,9
	.half	.L560-.L559
	.byte	1,5,54,9
	.half	.L1627-.L560
	.byte	1,5,70,9
	.half	.L1628-.L1627
	.byte	1,5,47,9
	.half	.L558-.L1628
	.byte	3,4,1,5,64,9
	.half	.L1629-.L558
	.byte	1,5,63,9
	.half	.L561-.L1629
	.byte	1,5,79,9
	.half	.L1630-.L561
	.byte	1,5,45,9
	.half	.L1631-.L1630
	.byte	1,5,39,9
	.half	.L1632-.L1631
	.byte	3,133,127,1,5,62,9
	.half	.L1633-.L1632
	.byte	3,255,0,1,5,68,9
	.half	.L1634-.L1633
	.byte	3,127,1,5,44,9
	.half	.L1635-.L1634
	.byte	1,5,20,9
	.half	.L540-.L1635
	.byte	1,5,17,9
	.half	.L1636-.L540
	.byte	1,5,59,7,9
	.half	.L1637-.L1636
	.byte	3,5,1,5,128,1,9
	.half	.L1638-.L1637
	.byte	3,1,1,5,59,9
	.half	.L85-.L1638
	.byte	3,5,1,5,53,9
	.half	.L86-.L85
	.byte	3,5,1,5,51,9
	.half	.L1639-.L86
	.byte	1,5,9,9
	.half	.L84-.L1639
	.byte	3,3,1,5,24,9
	.half	.L66-.L84
	.byte	3,4,1,5,9,9
	.half	.L1640-.L66
	.byte	3,1,1,5,5,9
	.half	.L77-.L1640
	.byte	3,5,1,5,45,7,9
	.half	.L1641-.L77
	.byte	3,3,1,5,43,9
	.half	.L1642-.L1641
	.byte	1,5,9,9
	.half	.L1643-.L1642
	.byte	3,2,1,5,30,9
	.half	.L1644-.L1643
	.byte	1,5,28,9
	.half	.L1645-.L1644
	.byte	1,5,5,9
	.half	.L89-.L1645
	.byte	3,3,1,5,1,9
	.half	.L90-.L89
	.byte	3,1,1,7,9
	.half	.L390-.L90
	.byte	0,1,1
.L1552:
	.sdecl	'.debug_ranges',debug,cluster('Fee_LLCopyData2Buffer')
	.sect	'.debug_ranges'
.L389:
	.word	-1,.L323,0,.L390-.L323,0,0
	.sdecl	'.debug_info',debug,cluster('Fee_CheckFlsJobResult')
	.sect	'.debug_info'
.L391:
	.word	244
	.half	3
	.word	.L392
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L394,.L393
	.byte	2
	.word	.L332
	.byte	3
	.byte	'Fee_CheckFlsJobResult',0,1,237,23,22,1,1,1
	.word	.L331,.L486,.L330
	.byte	4
	.word	.L331,.L486
	.byte	5
	.byte	'FlsJobResult',0,1,239,23,41
	.word	.L487,.L488
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('Fee_CheckFlsJobResult')
	.sect	'.debug_abbrev'
.L392:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,11,1,17,1,18,1,0,0,5,52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('Fee_CheckFlsJobResult')
	.sect	'.debug_line'
.L393:
	.word	.L1647-.L1646
.L1646:
	.half	3
	.word	.L1649-.L1648
.L1648:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlBlockHandling.c',0,0,0,0,0
.L1649:
	.byte	5,36,7,0,5,2
	.word	.L331
	.byte	3,241,23,1,5,5,9
	.half	.L711-.L331
	.byte	3,3,1,5,9,7,9
	.half	.L1650-.L711
	.byte	3,4,1,5,41,7,9
	.half	.L1651-.L1650
	.byte	3,4,1,5,43,9
	.half	.L712-.L1651
	.byte	1,9
	.half	.L306-.L712
	.byte	3,6,1,5,1,9
	.half	.L305-.L306
	.byte	3,3,1,7,9
	.half	.L395-.L305
	.byte	0,1,1
.L1647:
	.sdecl	'.debug_ranges',debug,cluster('Fee_CheckFlsJobResult')
	.sect	'.debug_ranges'
.L394:
	.word	-1,.L331,0,.L395-.L331,0,0
	.sdecl	'.debug_loc',debug,cluster('Fee_CalculateNumOfFreeBytesInCurSector')
	.sect	'.debug_loc'
.L398:
	.word	-1,.L329,0,.L707-.L329
	.half	1
	.byte	84
	.word	.L708-.L329,.L397-.L329
	.half	1
	.byte	88
	.word	0,0
.L328:
	.word	-1,.L329,0,.L397-.L329
	.half	2
	.byte	138,0
	.word	0,0
.L401:
	.word	-1,.L329,.L710-.L329,.L397-.L329
	.half	1
	.byte	82
	.word	0,0
.L400:
	.word	-1,.L329,.L707-.L329,.L709-.L329
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('Fee_CheckFlsJobResult')
	.sect	'.debug_loc'
.L330:
	.word	-1,.L331,0,.L486-.L331
	.half	2
	.byte	138,0
	.word	0,0
.L488:
	.word	-1,.L331,.L711-.L331,.L712-.L331
	.half	1
	.byte	82
	.word	.L306-.L331,.L305-.L331
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('Fee_LLCalcBlkCrcInFlash')
	.sect	'.debug_loc'
.L429:
	.word	0,0
.L427:
	.word	0,0
.L326:
	.word	-1,.L327,0,.L653-.L327
	.half	2
	.byte	138,0
	.word	.L653-.L327,.L415-.L327
	.half	2
	.byte	138,16
	.word	.L415-.L327,.L415-.L327
	.half	2
	.byte	138,0
	.word	0,0
.L416:
	.word	-1,.L327,0,.L654-.L327
	.half	1
	.byte	100
	.word	.L655-.L327,.L237-.L327
	.half	2
	.byte	145,112
	.word	.L654-.L327,.L657-.L327
	.half	1
	.byte	98
	.word	.L657-.L327,.L658-.L327
	.half	1
	.byte	111
	.word	.L663-.L327,.L237-.L327
	.half	1
	.byte	98
	.word	.L238-.L327,.L664-.L327
	.half	1
	.byte	98
	.word	.L238-.L327,.L415-.L327
	.half	2
	.byte	145,112
	.word	.L666-.L327,.L667-.L327
	.half	1
	.byte	111
	.word	.L242-.L327,.L243-.L327
	.half	1
	.byte	111
	.word	.L224-.L327,.L245-.L327
	.half	1
	.byte	100
	.word	.L226-.L327,.L668-.L327
	.half	1
	.byte	100
	.word	.L668-.L327,.L248-.L327
	.half	1
	.byte	111
	.word	.L223-.L327,.L669-.L327
	.half	1
	.byte	100
	.word	.L669-.L327,.L251-.L327
	.half	1
	.byte	111
	.word	.L220-.L327,.L679-.L327
	.half	1
	.byte	100
	.word	.L680-.L327,.L681-.L327
	.half	1
	.byte	98
	.word	.L682-.L327,.L683-.L327
	.half	1
	.byte	111
	.word	.L268-.L327,.L688-.L327
	.half	1
	.byte	111
	.word	.L276-.L327,.L690-.L327
	.half	1
	.byte	111
	.word	.L691-.L327,.L280-.L327
	.half	1
	.byte	111
	.word	.L222-.L327,.L284-.L327
	.half	1
	.byte	100
	.word	.L698-.L327,.L699-.L327
	.half	1
	.byte	111
	.word	.L703-.L327,.L293-.L327
	.half	1
	.byte	111
	.word	.L704-.L327,.L297-.L327
	.half	1
	.byte	111
	.word	.L227-.L327,.L705-.L327
	.half	1
	.byte	100
	.word	.L705-.L327,.L299-.L327
	.half	1
	.byte	111
	.word	0,0
.L422:
	.word	-1,.L327,.L692-.L327,.L693-.L327
	.half	1
	.byte	95
	.word	.L283-.L327,.L282-.L327
	.half	1
	.byte	95
	.word	0,0
.L421:
	.word	-1,.L327,.L670-.L327,.L250-.L327
	.half	1
	.byte	89
	.word	.L251-.L327,.L220-.L327
	.half	1
	.byte	89
	.word	.L684-.L327,.L685-.L327
	.half	5
	.byte	144,32,157,32,0
	.word	.L686-.L327,.L687-.L327
	.half	5
	.byte	144,32,157,32,0
	.word	.L268-.L327,.L689-.L327
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L431:
	.word	0,0
.L433:
	.word	-1,.L327,.L659-.L327,.L660-.L327
	.half	1
	.byte	81
	.word	0,0
.L420:
	.word	-1,.L327,.L676-.L327,.L677-.L327
	.half	1
	.byte	95
	.word	.L700-.L327,.L701-.L327
	.half	1
	.byte	95
	.word	0,0
.L432:
	.word	-1,.L327,.L661-.L327,.L662-.L327
	.half	1
	.byte	95
	.word	0,0
.L423:
	.word	-1,.L327,.L696-.L327,.L697-.L327
	.half	1
	.byte	95
	.word	0,0
.L418:
	.word	-1,.L327,.L671-.L327,.L672-.L327
	.half	1
	.byte	82
	.word	.L673-.L327,.L674-.L327
	.half	1
	.byte	90
	.word	.L674-.L327,.L678-.L327
	.half	1
	.byte	95
	.word	.L259-.L327,.L255-.L327
	.half	1
	.byte	90
	.word	.L694-.L327,.L695-.L327
	.half	1
	.byte	82
	.word	.L695-.L327,.L702-.L327
	.half	1
	.byte	95
	.word	0,0
.L419:
	.word	-1,.L327,.L672-.L327,.L675-.L327
	.half	1
	.byte	82
	.word	0,0
.L417:
	.word	-1,.L327,.L656-.L327,.L237-.L327
	.half	1
	.byte	88
	.word	.L238-.L327,.L415-.L327
	.half	1
	.byte	88
	.word	.L706-.L327,.L415-.L327
	.half	1
	.byte	82
	.word	0,0
.L434:
	.word	-1,.L327,.L228-.L327,.L237-.L327
	.half	1
	.byte	82
	.word	.L238-.L327,.L665-.L327
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('Fee_LLCompBlkInFlash')
	.sect	'.debug_loc'
.L407:
	.word	-1,.L309,0,.L490-.L309
	.half	1
	.byte	101
	.word	.L494-.L309,.L403-.L309
	.half	2
	.byte	145,124
	.word	.L4-.L309,.L14-.L309
	.half	1
	.byte	101
	.word	.L5-.L309,.L499-.L309
	.half	1
	.byte	101
	.word	.L506-.L309,.L507-.L309
	.half	1
	.byte	98
	.word	.L7-.L309,.L33-.L309
	.half	1
	.byte	101
	.word	.L8-.L309,.L511-.L309
	.half	1
	.byte	101
	.word	.L9-.L309,.L13-.L309
	.half	1
	.byte	101
	.word	0,0
.L308:
	.word	-1,.L309,0,.L489-.L309
	.half	2
	.byte	138,0
	.word	.L489-.L309,.L403-.L309
	.half	2
	.byte	138,8
	.word	.L403-.L309,.L403-.L309
	.half	2
	.byte	138,0
	.word	0,0
.L405:
	.word	-1,.L309,0,.L491-.L309
	.half	1
	.byte	100
	.word	.L492-.L309,.L493-.L309
	.half	1
	.byte	108
	.word	.L4-.L309,.L14-.L309
	.half	1
	.byte	100
	.word	.L5-.L309,.L499-.L309
	.half	1
	.byte	100
	.word	.L27-.L309,.L26-.L309
	.half	1
	.byte	108
	.word	.L7-.L309,.L33-.L309
	.half	1
	.byte	100
	.word	.L7-.L309,.L13-.L309
	.half	1
	.byte	108
	.word	.L8-.L309,.L511-.L309
	.half	1
	.byte	100
	.word	.L9-.L309,.L13-.L309
	.half	1
	.byte	100
	.word	0,0
.L414:
	.word	-1,.L309,.L496-.L309,.L4-.L309
	.half	1
	.byte	89
	.word	.L497-.L309,.L490-.L309
	.half	1
	.byte	85
	.word	.L498-.L309,.L12-.L309
	.half	1
	.byte	84
	.word	0,0
.L411:
	.word	-1,.L309,.L501-.L309,.L502-.L309
	.half	1
	.byte	95
	.word	.L516-.L309,.L517-.L309
	.half	1
	.byte	95
	.word	0,0
.L410:
	.word	-1,.L309,.L504-.L309,.L505-.L309
	.half	1
	.byte	89
	.word	.L508-.L309,.L507-.L309
	.half	1
	.byte	85
	.word	.L509-.L309,.L510-.L309
	.half	1
	.byte	84
	.word	0,0
.L412:
	.word	-1,.L309,.L499-.L309,.L500-.L309
	.half	1
	.byte	82
	.word	.L500-.L309,.L503-.L309
	.half	1
	.byte	95
	.word	.L21-.L309,.L17-.L309
	.half	1
	.byte	82
	.word	.L511-.L309,.L512-.L309
	.half	1
	.byte	82
	.word	.L513-.L309,.L514-.L309
	.half	1
	.byte	95
	.word	.L518-.L309,.L519-.L309
	.half	1
	.byte	95
	.word	.L40-.L309,.L36-.L309
	.half	1
	.byte	95
	.word	0,0
.L413:
	.word	-1,.L309,.L512-.L309,.L515-.L309
	.half	1
	.byte	82
	.word	0,0
.L408:
	.word	-1,.L309,.L495-.L309,.L403-.L309
	.half	1
	.byte	88
	.word	.L520-.L309,.L403-.L309
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('Fee_LLCopyData2Buffer')
	.sect	'.debug_loc'
.L478:
	.word	-1,.L323,0,.L533-.L323
	.half	1
	.byte	85
	.word	.L539-.L323,.L540-.L323
	.half	1
	.byte	89
	.word	.L63-.L323,.L78-.L323
	.half	1
	.byte	85
	.word	.L64-.L323,.L556-.L323
	.half	1
	.byte	85
	.word	.L66-.L323,.L77-.L323
	.half	1
	.byte	85
	.word	.L66-.L323,.L77-.L323
	.half	1
	.byte	89
	.word	0,0
.L477:
	.word	-1,.L323,0,.L534-.L323
	.half	1
	.byte	84
	.word	.L537-.L323,.L538-.L323
	.half	1
	.byte	90
	.word	.L63-.L323,.L78-.L323
	.half	1
	.byte	84
	.word	.L63-.L323,.L77-.L323
	.half	1
	.byte	90
	.word	.L64-.L323,.L557-.L323
	.half	1
	.byte	84
	.word	.L66-.L323,.L77-.L323
	.half	1
	.byte	84
	.word	0,0
.L476:
	.word	-1,.L323,0,.L533-.L323
	.half	1
	.byte	101
	.word	.L535-.L323,.L536-.L323
	.half	1
	.byte	108
	.word	.L63-.L323,.L78-.L323
	.half	1
	.byte	101
	.word	.L64-.L323,.L556-.L323
	.half	1
	.byte	101
	.word	.L66-.L323,.L77-.L323
	.half	1
	.byte	108
	.word	.L66-.L323,.L77-.L323
	.half	1
	.byte	101
	.word	0,0
.L475:
	.word	-1,.L323,0,.L533-.L323
	.half	1
	.byte	100
	.word	.L63-.L323,.L78-.L323
	.half	1
	.byte	100
	.word	.L64-.L323,.L556-.L323
	.half	1
	.byte	100
	.word	.L66-.L323,.L77-.L323
	.half	1
	.byte	100
	.word	0,0
.L322:
	.word	-1,.L323,0,.L532-.L323
	.half	2
	.byte	138,0
	.word	.L532-.L323,.L474-.L323
	.half	2
	.byte	138,8
	.word	.L474-.L323,.L474-.L323
	.half	2
	.byte	138,0
	.word	0,0
.L483:
	.word	-1,.L323,.L544-.L323,.L545-.L323
	.half	1
	.byte	92
	.word	.L553-.L323,.L474-.L323
	.half	1
	.byte	92
	.word	0,0
.L482:
	.word	-1,.L323,.L547-.L323,.L550-.L323
	.half	1
	.byte	82
	.word	.L552-.L323,.L62-.L323
	.half	1
	.byte	82
	.word	.L559-.L323,.L560-.L323
	.half	1
	.byte	95
	.word	0,0
.L481:
	.word	-1,.L323,.L542-.L323,.L543-.L323
	.half	1
	.byte	91
	.word	.L551-.L323,.L474-.L323
	.half	1
	.byte	91
	.word	0,0
.L480:
	.word	-1,.L323,.L554-.L323,.L555-.L323
	.half	1
	.byte	95
	.word	0,0
.L484:
	.word	-1,.L323,.L533-.L323,.L547-.L323
	.half	1
	.byte	82
	.word	.L548-.L323,.L549-.L323
	.half	1
	.byte	83
	.word	.L556-.L323,.L558-.L323
	.half	1
	.byte	82
	.word	.L558-.L323,.L561-.L323
	.half	1
	.byte	95
	.word	0,0
.L479:
	.word	-1,.L323,.L541-.L323,.L474-.L323
	.half	1
	.byte	88
	.word	.L562-.L323,.L474-.L323
	.half	1
	.byte	82
	.word	0,0
.L485:
	.word	-1,.L323,.L546-.L323,.L474-.L323
	.half	1
	.byte	93
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('Fee_LLCopyPageBuff2HeaderEnd')
	.sect	'.debug_loc'
.L472:
	.word	-1,.L317,0,.L471-.L317
	.half	1
	.byte	100
	.word	0,0
.L316:
	.word	-1,.L317,0,.L471-.L317
	.half	2
	.byte	138,0
	.word	0,0
.L473:
	.word	-1,.L317,0,.L471-.L317
	.half	1
	.byte	101
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('Fee_LLCopyPageBuff2HeaderMid')
	.sect	'.debug_loc'
.L469:
	.word	-1,.L315,0,.L467-.L315
	.half	1
	.byte	100
	.word	0,0
.L314:
	.word	-1,.L315,0,.L467-.L315
	.half	2
	.byte	138,0
	.word	0,0
.L470:
	.word	-1,.L315,0,.L467-.L315
	.half	1
	.byte	101
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('Fee_LLCopyPageBuff2Marker')
	.sect	'.debug_loc'
.L310:
	.word	-1,.L311,0,.L453-.L311
	.half	2
	.byte	138,0
	.word	0,0
.L455:
	.word	-1,.L311,0,.L453-.L311
	.half	1
	.byte	100
	.word	0,0
.L456:
	.word	-1,.L311,0,.L453-.L311
	.half	1
	.byte	101
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('Fee_LLCpyBlkFromFls2Fls')
	.sect	'.debug_loc'
.L436:
	.word	-1,.L325,0,.L564-.L325
	.half	1
	.byte	100
	.word	.L565-.L325,.L564-.L325
	.half	2
	.byte	145,120
	.word	.L93-.L325,.L568-.L325
	.half	1
	.byte	100
	.word	.L93-.L325,.L435-.L325
	.half	2
	.byte	145,120
	.word	.L568-.L325,.L571-.L325
	.half	1
	.byte	111
	.word	.L94-.L325,.L581-.L325
	.half	1
	.byte	100
	.word	.L581-.L325,.L584-.L325
	.half	1
	.byte	111
	.word	.L587-.L325,.L135-.L325
	.half	1
	.byte	111
	.word	.L129-.L325,.L588-.L325
	.half	1
	.byte	111
	.word	.L590-.L325,.L591-.L325
	.half	1
	.byte	111
	.word	.L142-.L325,.L592-.L325
	.half	1
	.byte	111
	.word	.L148-.L325,.L147-.L325
	.half	1
	.byte	111
	.word	.L593-.L325,.L594-.L325
	.half	1
	.byte	111
	.word	.L107-.L325,.L153-.L325
	.half	1
	.byte	100
	.word	.L97-.L325,.L595-.L325
	.half	1
	.byte	100
	.word	.L597-.L325,.L156-.L325
	.half	1
	.byte	111
	.word	.L103-.L325,.L598-.L325
	.half	1
	.byte	100
	.word	.L601-.L325,.L162-.L325
	.half	1
	.byte	111
	.word	.L109-.L325,.L602-.L325
	.half	1
	.byte	100
	.word	.L604-.L325,.L165-.L325
	.half	1
	.byte	111
	.word	.L112-.L325,.L605-.L325
	.half	1
	.byte	100
	.word	.L167-.L325,.L607-.L325
	.half	1
	.byte	100
	.word	.L106-.L325,.L609-.L325
	.half	1
	.byte	100
	.word	.L108-.L325,.L612-.L325
	.half	1
	.byte	100
	.word	.L612-.L325,.L180-.L325
	.half	1
	.byte	111
	.word	.L115-.L325,.L614-.L325
	.half	1
	.byte	100
	.word	.L116-.L325,.L622-.L325
	.half	1
	.byte	100
	.word	.L117-.L325,.L632-.L325
	.half	1
	.byte	100
	.word	.L118-.L325,.L636-.L325
	.half	1
	.byte	100
	.word	.L646-.L325,.L210-.L325
	.half	1
	.byte	98
	.word	.L119-.L325,.L648-.L325
	.half	1
	.byte	100
	.word	.L92-.L325,.L128-.L325
	.half	1
	.byte	100
	.word	0,0
.L324:
	.word	-1,.L325,0,.L563-.L325
	.half	2
	.byte	138,0
	.word	.L563-.L325,.L435-.L325
	.half	2
	.byte	138,16
	.word	.L435-.L325,.L435-.L325
	.half	2
	.byte	138,0
	.word	0,0
.L437:
	.word	-1,.L325,0,.L564-.L325
	.half	1
	.byte	84
	.word	.L566-.L325,.L564-.L325
	.half	1
	.byte	89
	.word	.L93-.L325,.L569-.L325
	.half	1
	.byte	84
	.word	.L93-.L325,.L570-.L325
	.half	1
	.byte	89
	.word	.L94-.L325,.L582-.L325
	.half	1
	.byte	84
	.word	.L94-.L325,.L583-.L325
	.half	1
	.byte	89
	.word	.L129-.L325,.L589-.L325
	.half	1
	.byte	84
	.word	.L107-.L325,.L153-.L325
	.half	1
	.byte	84
	.word	.L97-.L325,.L596-.L325
	.half	1
	.byte	84
	.word	.L103-.L325,.L599-.L325
	.half	1
	.byte	84
	.word	.L109-.L325,.L603-.L325
	.half	1
	.byte	84
	.word	.L112-.L325,.L606-.L325
	.half	1
	.byte	84
	.word	.L106-.L325,.L610-.L325
	.half	1
	.byte	84
	.word	.L108-.L325,.L613-.L325
	.half	1
	.byte	84
	.word	.L115-.L325,.L615-.L325
	.half	1
	.byte	84
	.word	.L116-.L325,.L623-.L325
	.half	1
	.byte	84
	.word	.L117-.L325,.L632-.L325
	.half	1
	.byte	84
	.word	.L117-.L325,.L633-.L325
	.half	1
	.byte	89
	.word	.L118-.L325,.L637-.L325
	.half	1
	.byte	84
	.word	.L118-.L325,.L638-.L325
	.half	1
	.byte	89
	.word	.L119-.L325,.L649-.L325
	.half	1
	.byte	84
	.word	.L119-.L325,.L128-.L325
	.half	1
	.byte	89
	.word	.L92-.L325,.L128-.L325
	.half	1
	.byte	84
	.word	0,0
.L448:
	.word	-1,.L325,.L598-.L325,.L600-.L325
	.half	1
	.byte	100
	.word	.L605-.L325,.L167-.L325
	.half	1
	.byte	100
	.word	.L607-.L325,.L608-.L325
	.half	1
	.byte	100
	.word	.L609-.L325,.L611-.L325
	.half	1
	.byte	100
	.word	0,0
.L446:
	.word	-1,.L325,.L645-.L325,.L205-.L325
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L443:
	.word	-1,.L325,.L633-.L325,.L634-.L325
	.half	1
	.byte	89
	.word	.L634-.L325,.L635-.L325
	.half	1
	.byte	95
	.word	.L199-.L325,.L196-.L325
	.half	1
	.byte	95
	.word	0,0
.L444:
	.word	-1,.L325,0,.L564-.L325
	.half	2
	.byte	145,112
	.word	.L93-.L325,.L435-.L325
	.half	2
	.byte	145,112
	.word	0,0
.L440:
	.word	-1,.L325,.L570-.L325,.L574-.L325
	.half	1
	.byte	89
	.word	.L575-.L325,.L576-.L325
	.half	1
	.byte	84
	.word	.L124-.L325,.L578-.L325
	.half	1
	.byte	84
	.word	.L617-.L325,.L618-.L325
	.half	1
	.byte	95
	.word	.L626-.L325,.L628-.L325
	.half	1
	.byte	95
	.word	.L629-.L325,.L630-.L325
	.half	1
	.byte	84
	.word	.L189-.L325,.L631-.L325
	.half	1
	.byte	84
	.word	.L647-.L325,.L644-.L325
	.half	1
	.byte	84
	.word	0,0
.L441:
	.word	-1,.L325,.L585-.L325,.L586-.L325
	.half	1
	.byte	82
	.word	0,0
.L439:
	.word	-1,.L325,.L572-.L325,.L573-.L325
	.half	1
	.byte	82
	.word	.L577-.L325,.L124-.L325
	.half	1
	.byte	89
	.word	.L579-.L325,.L580-.L325
	.half	1
	.byte	89
	.word	.L614-.L325,.L616-.L325
	.half	1
	.byte	82
	.word	.L616-.L325,.L619-.L325
	.half	1
	.byte	95
	.word	.L620-.L325,.L621-.L325
	.half	1
	.byte	82
	.word	.L622-.L325,.L624-.L325
	.half	1
	.byte	82
	.word	.L625-.L325,.L626-.L325
	.half	1
	.byte	95
	.word	.L624-.L325,.L627-.L325
	.half	1
	.byte	84
	.word	.L636-.L325,.L639-.L325
	.half	1
	.byte	82
	.word	.L638-.L325,.L640-.L325
	.half	1
	.byte	89
	.word	.L639-.L325,.L641-.L325
	.half	1
	.byte	84
	.word	.L642-.L325,.L643-.L325
	.half	1
	.byte	84
	.word	.L203-.L325,.L202-.L325
	.half	1
	.byte	89
	.word	.L648-.L325,.L650-.L325
	.half	1
	.byte	82
	.word	.L651-.L325,.L650-.L325
	.half	1
	.byte	84
	.word	0,0
.L445:
	.word	-1,.L325,.L632-.L325,.L198-.L325
	.half	1
	.byte	82
	.word	0,0
.L438:
	.word	-1,.L325,.L567-.L325,.L564-.L325
	.half	1
	.byte	88
	.word	.L93-.L325,.L435-.L325
	.half	1
	.byte	88
	.word	.L652-.L325,.L435-.L325
	.half	1
	.byte	82
	.word	0,0
.L442:
	.word	-1,.L325,.L643-.L325,.L644-.L325
	.half	1
	.byte	82
	.word	.L650-.L325,.L92-.L325
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('Fee_LLPrepMarkerBufWithMarkerData')
	.sect	'.debug_loc'
.L312:
	.word	-1,.L313,0,.L449-.L313
	.half	2
	.byte	138,0
	.word	0,0
.L452:
	.word	-1,.L313,0,.L449-.L313
	.half	1
	.byte	101
	.word	0,0
.L451:
	.word	-1,.L313,0,.L449-.L313
	.half	1
	.byte	100
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('Fee_LLPrepPageBufWithHdrDataEnd')
	.sect	'.debug_loc'
.L464:
	.word	-1,.L321,0,.L524-.L321
	.half	1
	.byte	84
	.word	.L51-.L321,.L52-.L321
	.half	1
	.byte	84
	.word	0,0
.L463:
	.word	-1,.L321,0,.L525-.L321
	.half	1
	.byte	101
	.word	0,0
.L320:
	.word	-1,.L321,0,.L461-.L321
	.half	2
	.byte	138,0
	.word	0,0
.L462:
	.word	-1,.L321,0,.L526-.L321
	.half	1
	.byte	100
	.word	.L527-.L321,.L525-.L321
	.half	1
	.byte	102
	.word	0,0
.L466:
	.word	-1,.L321,.L529-.L321,.L530-.L321
	.half	1
	.byte	95
	.word	.L56-.L321,.L531-.L321
	.half	1
	.byte	95
	.word	0,0
.L465:
	.word	-1,.L321,.L524-.L321,.L51-.L321
	.half	1
	.byte	84
	.word	.L52-.L321,.L528-.L321
	.half	1
	.byte	84
	.word	.L53-.L321,.L525-.L321
	.half	1
	.byte	84
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('Fee_LLPrepPageBufWithHdrDataStart')
	.sect	'.debug_loc'
.L318:
	.word	-1,.L319,0,.L457-.L319
	.half	2
	.byte	138,0
	.word	0,0
.L459:
	.word	-1,.L319,0,.L521-.L319
	.half	1
	.byte	100
	.word	.L522-.L319,.L457-.L319
	.half	1
	.byte	108
	.word	0,0
.L460:
	.word	-1,.L319,.L523-.L319,.L457-.L319
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_frame',debug
	.sect	'.debug_frame'
.L1652:
	.word	48
	.word	-1
	.byte	3,0,2,1,27,12,26,0,8,27,8,26,8,28,8,29,8,30,8,31,8,34,8,35,8,32,8,33,8,16,8,17,8,24,8,25,8,36,8,37,8,38
	.byte	8,39
	.sdecl	'.debug_frame',debug,cluster('Fee_LLCompBlkInFlash')
	.sect	'.debug_frame'
	.word	36
	.word	.L1652,.L309,.L403-.L309
	.byte	4
	.word	(.L489-.L309)/2
	.byte	19,8,22,26,3,19,138,8,4
	.word	(.L403-.L489)/2
	.byte	19,0,8,26,0,0
	.sdecl	'.debug_frame',debug,cluster('Fee_LLCopyPageBuff2Marker')
	.sect	'.debug_frame'
	.word	20
	.word	.L1652,.L311,.L453-.L311
	.byte	8,18,8,19,8,22,8,23
	.sdecl	'.debug_frame',debug,cluster('Fee_LLPrepMarkerBufWithMarkerData')
	.sect	'.debug_frame'
	.word	20
	.word	.L1652,.L313,.L449-.L313
	.byte	8,18,8,19,8,22,8,23
	.sdecl	'.debug_frame',debug,cluster('Fee_LLCopyPageBuff2HeaderMid')
	.sect	'.debug_frame'
	.word	20
	.word	.L1652,.L315,.L467-.L315
	.byte	8,18,8,19,8,22,8,23
	.sdecl	'.debug_frame',debug,cluster('Fee_LLCopyPageBuff2HeaderEnd')
	.sect	'.debug_frame'
	.word	20
	.word	.L1652,.L317,.L471-.L317
	.byte	8,18,8,19,8,22,8,23
	.sdecl	'.debug_frame',debug,cluster('Fee_LLPrepPageBufWithHdrDataStart')
	.sect	'.debug_frame'
	.word	12
	.word	.L1652,.L319,.L457-.L319
	.sdecl	'.debug_frame',debug,cluster('Fee_LLPrepPageBufWithHdrDataEnd')
	.sect	'.debug_frame'
	.word	12
	.word	.L1652,.L321,.L461-.L321
	.sdecl	'.debug_frame',debug,cluster('Fee_LLCopyData2Buffer')
	.sect	'.debug_frame'
	.word	36
	.word	.L1652,.L323,.L474-.L323
	.byte	4
	.word	(.L532-.L323)/2
	.byte	19,8,22,26,3,19,138,8,4
	.word	(.L474-.L532)/2
	.byte	19,0,8,26,0,0
	.sdecl	'.debug_frame',debug,cluster('Fee_LLCpyBlkFromFls2Fls')
	.sect	'.debug_frame'
	.word	36
	.word	.L1652,.L325,.L435-.L325
	.byte	4
	.word	(.L563-.L325)/2
	.byte	19,16,22,26,3,19,138,16,4
	.word	(.L435-.L563)/2
	.byte	19,0,8,26,0,0
	.sdecl	'.debug_frame',debug,cluster('Fee_LLCalcBlkCrcInFlash')
	.sect	'.debug_frame'
	.word	36
	.word	.L1652,.L327,.L415-.L327
	.byte	4
	.word	(.L653-.L327)/2
	.byte	19,16,22,26,3,19,138,16,4
	.word	(.L415-.L653)/2
	.byte	19,0,8,26,0,0
	.sdecl	'.debug_frame',debug,cluster('Fee_CalculateNumOfFreeBytesInCurSector')
	.sect	'.debug_frame'
	.word	12
	.word	.L1652,.L329,.L397-.L329
	.sdecl	'.debug_frame',debug,cluster('Fee_CheckFlsJobResult')
	.sect	'.debug_frame'
	.word	12
	.word	.L1652,.L331,.L486-.L331

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3079  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3080  /* FEE_POLLING_MODE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3081  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3082  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3083  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3084  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3085  /* FEE_PRESENT */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3086  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3087  /* 1 == FEE_PRV_CFG_SELECTED_FS */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3088  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3089  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3090  /*<BASDKey>
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3091  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3092  * $History__:$
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3093  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlBlockHandling.c	  3094  </BASDKey>*/

	; Module end
