	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 19053136 SN 09001910"
	.compiler_invocation	"ctc -f cc15728a -c99 --integer-enumeration -D__CPU__=tc27x -D__CPU_TC27X__ --core=tc1.6.x --eabi-compliant --fp-model=-float -D_TASKING_C_TRICORE_=1 -I.\\output\\inc -g2 -t4 --language=-comments,-gcc,+volatile,-strings --default-near-size=0 -O2ROPYGKLF-predict --default-a1-size=0 --default-a0-size=0 --source --switch=auto -o output\\objs\\BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\rba_FeeFs1_MainFunction.src BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_MainFunction.c"
	.compiler_name		"ctc"
	;source	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_MainFunction.c'

	
$TC16X
	
	.sdecl	'.text.rba_FeeFs1_MainFunction.Fee_MainFunction',code,cluster('Fee_MainFunction')
	.sect	'.text.rba_FeeFs1_MainFunction.Fee_MainFunction'
	.align	2
	
	.global	Fee_MainFunction

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	     1  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	     2  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	     3  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	     4  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	     5   **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	     6   * \moduledescription
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	     7   *           AUTOSAR FEE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	     8   *           According to Document Version 3.0.0, Part of Release 4.0, Revision 2
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	     9   * \scope    INTERN
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    10   **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    11   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    12  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    13  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    14  /*
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    15   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    16   * Includes
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    17   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    18   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    19  #include "Fee.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    20  #include "rba_FeeFs1_Prv.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    21  #include "Fls.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    22  #if (!defined(FLS_AR_RELEASE_MAJOR_VERSION) || (FLS_AR_RELEASE_MAJOR_VERSION != FEE_AR_RELEASE_MAJOR_VERSION))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    23      #error "AUTOSAR major version undefined or mismatched"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    24  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    25  #if (!defined(FLS_AR_RELEASE_MINOR_VERSION) || ((FLS_AR_RELEASE_MINOR_VERSION != 0) && (FLS_AR_RELEASE_MINOR_VERSION != 2)))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    26      #error "AUTOSAR minor version undefined or mismatched"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    27  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    28  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    29  #if (FEE_PRV_DEBUGGING != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    30  #include "Mcu.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    31  /* FEE_PRV_DEBUGGING */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    32  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    33  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    34  #if(defined(FEE_PRV_CFG_SELECTED_FS) && (1 == FEE_PRV_CFG_SELECTED_FS))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    35  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    36  #define FEE_PRV_REQ_STOPMODE 1
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    37  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    38  #if (FEE_PRESENT == 1)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    39  /* Job mapping table */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    40  #define FEE_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    41  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    42  CONST (MemIf_JobResultType, AUTOMATIC) Fee_JobTypeMapping[FEE_NUM_RET_VAL_E] =
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    43  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    44      MEMIF_JOB_PENDING,        /* FEE_ORDER_PENDING_E will be mapped to MEMIF_JOB_PENDING */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    45      MEMIF_JOB_OK,             /* FEE_ORDER_FINISHED_E will be mapped to MEMIF_JOB_OK
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    46                                   (e.g. after writing or reading a block successfully)*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    47      MEMIF_BLOCK_INVALID,      /* FEE_BLOCK_INVALIDATED_E will be mapped to MEMIF_BLOCK_INVALID
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    48                                   (e.g. after reading back an invalidated block successfully) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    49      MEMIF_BLOCK_INCONSISTENT, /* FEE_ERROR_E will be mapped to MEMIF_BLOCK_INCONSISTENT
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    50                                   (e.g. if the block is not consistent in the flash) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    51      MEMIF_JOB_PENDING,        /* FEE_SECTORCHANGE_E will be mapped to MEMIF_JOB_PENDING */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    52      MEMIF_JOB_PENDING,        /* FEE_SECTORFULL_E will be mapped to MEMIF_JOB_PENDING */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    53      MEMIF_JOB_FAILED,         /* FEE_ABORTED_E  will be mapped to MEMIF_JOB_FAILED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    54                                   (e.g. if not reachable states were called or the Fee/Fls
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    55                                    are not intialized yet or a HW failure occured) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    56      MEMIF_JOB_PENDING,        /* FEE_ERASE_SECTOR_E will be mapped to MEMIF_JOB_PENDING */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    57      MEMIF_JOB_PENDING         /* FEE_SEARCH_ABORTED_E will be mapped to MEMIF_JOB_PENDING
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    58                                   (cannot be reached by any upper layer functions)*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    59  };
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    60  #define FEE_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    61  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    62  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    63  #if (FEE_RB_ADDONS_CCAS != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    64  #define FEE_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    65  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    66  VAR(boolean, AUTOMATIC) Fee_Rb_stRequestStopMode_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    67  #define FEE_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    68  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    69  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    70  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    71  #if (FEE_RB_ACT_ERASE_SUSPENSION != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    72  #define FEE_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    73  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    74  VAR(boolean, AUTOMATIC) Fee_Prv_stSuspendActiv_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    75  VAR(boolean, AUTOMATIC) Fee_Prv_stHardReOrgErase_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    76  #define FEE_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    77  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    78  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    79  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    80  #define FEE_START_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    81  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    82  /* MR12 RULE 1504 VIOLATION: This is no function declaration but a variable only with an external linkage */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    83  VAR(Fee_Rb_WorkingStateType_ten, AUTOMATIC) Fee_Rb_WorkingStateBackUp_en = FEE_RB_IDLE_E;    /* Backup of the working state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    84  #define FEE_STOP_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    85  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    86  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    87  #define FEE_START_SEC_VAR_INIT_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    88  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    89  VAR(uint8, AUTOMATIC) Fee_idxActQueueBackUp = (uint8)FEE_QUEUE_SIZE;    /* Backup queue index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    90  #define FEE_STOP_SEC_VAR_INIT_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    91  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    92  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    93  #if (FEE_PRV_DEBUG_MONITOR != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    94  #define FEE_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    95  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    96  VAR(Fee_DebugMonitoring_tst, AUTOMATIC)  Fee_DebugMonitoring;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    97  #define FEE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    98  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	    99  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   100  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   101  /* Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   102  #if (defined(RBA_FLSIFX_FLASH) || defined(RBA_FLSJDP_FLASH))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   103  #define FEE_START_SEC_VAR_INIT_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   104  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   105  VAR(uint8, AUTOMATIC) Fee_hdrBuffer_au8[FEE_PAGE_LEN] = {0};
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   106  #define FEE_STOP_SEC_VAR_INIT_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   107  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   108  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   109  /* END Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   110  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   111  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   112  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   113   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   114   * Fee_MainFunction(): Main function of the module
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   115   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   116   * This function handles the requested orders and the internal
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   117   * management operations. It has to be called cyclically by the
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   118   * Fee's environment.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   119   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   120   * \param    none
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   121   * \return
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   122   * \retval   none
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   123   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   124   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   125   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   126   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   127  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   128  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   129  FUNC(void, FEE_CODE) Fee_MainFunction(void)
; Function Fee_MainFunction
.L102:
Fee_MainFunction:	.type	func
	sub.a	a10,#8
.L195:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   130  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   131      VAR(uint8, AUTOMATIC) i;                                                        /* Loop counter */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   132      VAR(Fee_stRetVal_ten, AUTOMATIC) xRetVal = FEE_ORDER_PENDING_E;                 /* Order return value */
	mov	d8,#0
.L196:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   133      VAR(boolean, AUTOMATIC) stSectReorgInt_b;          /* Indicates an interruptable sector reorganization status */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   134      VAR(boolean, AUTOMATIC)  tmpContinueToErase_b = TRUE;
	mov	d0,#1
.L198:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   135      #if (FEE_RB_ACT_ERASE_SUSPENSION != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   136      VAR(Fls_Rb_stSuspend_ten, AUTOMATIC) xRetSuspendVal;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   137      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   138      /* Following requirements are handeled implicitly by the main function working mechanism:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   139       *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   140       * FEE169:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   141       * If the module initialization (started in the function Fee_Init) is completed in the module s main function, the
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   142       * function Fee_MainFunction shall set the module status from MEMIF_BUSY_INTERNAL to MEMIF_IDLE once initialization
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   143       * of the module has been successfully finished.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   144       *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   145       * FEE179:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   146       * If the current module status is MEMIF_BUSY_INTERNAL and if the internal management operation can be suspended
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   147       * without jeopardizing the data consistency: the function Fee_MainFunction shall save all information which are
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   148       * necessary to resume the internal management operation, suspend the internal management operation and start
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   149       * processing the job requested by the upper layer.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   150       *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   151       * FEE180:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   152       * If the current module status is MEMIF_BUSY_INTERNAL and if the internal management operation can be aborted
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   153       * without jeopardizing the data consistency: the function Fee_MainFunction shall save all information which are
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   154       * necessary to restart the internal management operation, abort the internal management operation and start
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   155       * processing the job requested by the upper layer.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   156       *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   157       * FEE181:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   158       * If an internal management operation has been suspended because of a job request from the upper layer, the
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   159       * function Fee_MainFunction shall resume this internal management operation once the job requested by the upper
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   160       * layer has been finished.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   161       *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   162       * FEE182:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   163       * If an internal management operation has been aborted because of a job request from the upper layer, the function
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   164       * Fee_MainFunction shall restart this internal management operation once the job requested by the upper layer has
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   165       * been finished.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   166       * */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   167  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   168      /* FEE057:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   169       * The function Fee_MainFunction shall asynchronously handle the read / write / erase / invalidate jobs
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   170       * requested by the upper layer and internal management operations.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   171       * */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   172      /* Switch over the internal working state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   173      switch (Fee_Rb_WorkingState_en)
	movh.a	a12,#@his(Fee_Rb_WorkingState_en)
	lea	a12,[a12]@los(Fee_Rb_WorkingState_en)
	ld.w	d1,[a12]
.L242:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   174      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   175          #if (FEE_RB_ADDONS_CCAS == TRUE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   176          /* Stop mode */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   177          case FEE_RB_STOPMODE_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   178          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   179              Fee_Rb_stRequestStopMode_b = FEE_RB_REQUEST_STOP_MODE;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   180          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   181          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   182          #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   183  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   184          /* Idle state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   185          case FEE_RB_IDLE_E:
	mov	d15,#0
	jeq	d15,d1,.L2
.L243:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   186          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   187              #if (FEE_RB_ACT_ERASE_SUSPENSION != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   188             /* Reset hard reorg erase marker, only relevant for the support of the suspend feature */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   189              Fee_Prv_stHardReOrgErase_b = FALSE;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   190              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   191  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   192  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   193              /* Search new order in queue */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   194              Fee_idxActQueue_u8 = Fee_SearchNextOrder(TRUE);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   195  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   196              /* Check if any user orders have to be processed */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   197              if(Fee_idxActQueue_u8 != (uint8)FEE_QUEUE_SIZE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   198              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   199                  Fee_LoadNextOrder();
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   200              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   201              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   202              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   203                  /* No user orders are in the queue, check if at least one sector should be erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   204                  for (i=0;i<FEE_NUM_FLASH_BANKS;i++)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   205                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   206                      /* Check relevant sector states */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   207                      if(((Fee_LLSectorOrder_st[i].SecState_en == FEE_SECTOR_REQUEST2ERASE_E) ||
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   208                          (Fee_LLSectorOrder_st[i].SecState_en == FEE_SECTOR_STATE_UNDEF_E)) &&
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   209                          (Fee_Prv_stInit_u8 == FEE_PRV_ST_INIT_DONE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   210                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   211                          /* Set the job type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   212                          Fee_idxActQueue_u8 = (uint8)FEE_INTERNAL_JOB;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   213  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   214                          /* Mark a logical sector for an erase request in the global erase structure */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   215                          Fee_LLSetEraseSector(i);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   216  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   217                          /* Set the internal working state to erase */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   218                          Fee_Rb_WorkingState_en = FEE_RB_SECTOR_ERASE_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   219  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   220                          /* Leave the loop */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   221                          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   222                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   223                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   224  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   225                  /* Check for the necessity of a sector reorganization and perform at least
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   226                   * one block transfer before executing the next user order (do not perform this
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   227                   * during the ECU's initialization state in order to save time) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   228                  if(((Fee_LLCheckReorganizationNeed(FEE_REQUIRED_FREE_SPACE_BEFORE_SOFT_SR, 0) == FEE_SECTORFULL_E) &&
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   229                      (Fee_Rb_WorkingState_en != FEE_RB_SECTOR_ERASE_E)) &&
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   230                      (Fee_Prv_stInit_u8 == FEE_PRV_ST_INIT_DONE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   231                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   232                      /* Set the job type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   233                      Fee_idxActQueue_u8 = (uint8)FEE_INTERNAL_JOB;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   234  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   235                      /* Set internal working state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   236                      Fee_Rb_WorkingState_en = FEE_RB_SOFT_SECTOR_REORG_MODE_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   237  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   238                      /* Leave this case */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   239                      break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   240                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   241              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   242  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   243              #if (FEE_RB_ADDONS_CCAS == TRUE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   244              /* Check for a stop mode request */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   245              if (Fee_Rb_stRequestStopMode_b == FEE_RB_REQUEST_STOP_MODE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   246              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   247                  /* Activate the stop mode due to a user request from the CC-AS adapter
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   248                   * --> no other orders should be executed anymore */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   249                  Fee_Rb_WorkingState_en = FEE_RB_STOPMODE_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   250              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   251              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   252          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   253          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   254  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   255          /* A write or invalidate order was found */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   256          case FEE_RB_WRITE_MODE_E:
	mov	d2,#1
	jeq	d2,d1,.L3
.L244:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   257          case FEE_RB_INVALIDATE_MODE_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   258          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   259              /* In case of NoFallback blocks a maintenance must be carried out before */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   260              #if ((FEE_RB_MAINTAIN != FALSE) && (FEE_NO_FALLBACK_ACTIVE != FALSE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   261              switch (Fee_WriteStateNoFb_en)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   262              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   263                  /* Check the properties of the block and decide if the block has to be maintained first */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   264                  case FEE_WRITE_NOFB_IDLE_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   265                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   266                      /* Only double storage blocks with a NoFallback configuration have to be maintained */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   267                      // Shift of Flags not required, offset for security level is 0
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   268                      if (((Fee_BlockProperties_st[Fee_OrderFifo_st[Fee_idxActQueue_u8].BlockPropIdx_u16].Flags_u16 &
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   269                              FEE_FLAG_SEC_LEVEL_MSK) == FEE_BLK_INT_DOUBLE_STORAGE) &&
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   270                          ((Fee_BlockProperties_st[Fee_OrderFifo_st[Fee_idxActQueue_u8].BlockPropIdx_u16].Flags_u16 & FEE_FLAG_NOFALLBACK_MSK) > 0u))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   271                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   272                          Fee_WriteStateNoFb_en = FEE_WRITE_NOFB_MAINTAIN_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   273                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   274                      else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   275                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   276                          Fee_WriteStateNoFb_en = FEE_WRITE_NOFB_BLOCK_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   277                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   278                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   279                  break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   280  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   281                  /* Maintain the NoFallback block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   282                  case FEE_WRITE_NOFB_MAINTAIN_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   283                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   284                      xRetVal = Fee_HLMaintainBlock();
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   285  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   286                      if (xRetVal != FEE_ORDER_PENDING_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   287                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   288                          /* Proceed directly with the write order independent of a successful state
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   289                           * -> Fee_HLMaintainBlock() also fails in case the block is not available on the medium */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   290                          Fee_WriteStateNoFb_en = FEE_WRITE_NOFB_BLOCK_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   291  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   292                          /* Order is not finished --> reset xRetVal to PENDING */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   293                          xRetVal = FEE_ORDER_PENDING_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   294                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   295                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   296                  break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   297  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   298                  /* Write the block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   299                  case FEE_WRITE_NOFB_BLOCK_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   300                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   301                      /* Call the high level write function for order processing */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   302                      xRetVal = Fee_HLWriteBlock();
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   303  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   304                      if (xRetVal != FEE_ORDER_PENDING_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   305                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   306                          /* Check if a sector reorganization needs to be executed
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   307                           * Hint: SECTORFULL is also returned in case the write order would exceed the HSR threshold */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   308                          if(xRetVal == FEE_SECTORFULL_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   309                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   310                              /* Order is not finished --> reset xRetVal to PENDING */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   311                              xRetVal = FEE_ORDER_PENDING_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   312  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   313                              /* After Reorg return to init --> enforce maintain to be executed again after the reorg*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   314                              Fee_WriteStateNoFb_en = FEE_WRITE_NOFB_IDLE_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   315  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   316                              /*trigger a reorganization */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   317                              Fee_TriggerHardSectorReorg(Fee_Rb_WorkingState_en);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   318                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   319                          else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   320                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   321                              /* The order was either finished successfully or with an error
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   322                               * -> Reset the write state in both cases */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   323                              Fee_WriteStateNoFb_en = FEE_WRITE_NOFB_IDLE_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   324                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   325                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   326                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   327                  break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   328  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   329                  default:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   330                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   331                      xRetVal = FEE_ERROR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   332                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   333                  break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   334              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   335              #else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   336              /* Call the high level write function for order processing */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   337              xRetVal = Fee_HLWriteBlock();
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   338  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   339              /* Check if a sector reorganization needs to be executed
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   340               * Hint: SECTORFULL is also returned in case the write order would exceed the HSR threshold */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   341              if(xRetVal == FEE_SECTORFULL_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   342              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   343                  /* Order is not finished --> reset xRetVal to PENDING */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   344                  xRetVal = FEE_ORDER_PENDING_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   345  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   346                  /* Save the current working state and trigger a reorganization */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   347                  Fee_TriggerHardSectorReorg(Fee_Rb_WorkingState_en);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   348              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   349              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   350          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   351          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   352  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   353          #if (FEE_RB_MAINTAIN != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   354          case FEE_RB_MAINTAIN_MODE_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   355          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   356              /* Call the high level write function for order processing */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   357              xRetVal = Fee_HLMaintainBlock();
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   358          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   359          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   360          /* FEE_RB_MAINTAIN != FALSE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   361          #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   362  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   363          /* A read order was found */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   364          case FEE_RB_READ_MODE_E:
	mov	d2,#2
	jeq	d2,d1,.L4
.L245:
	mov	d2,#3
	jeq	d2,d1,.L5
.L246:
	mov	d2,#4
	jeq	d2,d1,.L6
.L247:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   365          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   366              /* Deviation from Autosar SWS:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   367               * ===========================
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   368               * - Whether a block is invalidated or not is checked in the function Fee_HLReadBlock
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   369               * - The block checksum is verified in the function Fee_HLReadBlock
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   370               *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   371               * FEE075:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   372               * The function Fee_MainFunction shall check whether the block requested for reading has been
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   373               * invalidated by the upper layer module. If so, the function Fee_MainFunction shall set the job result
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   374               * to MEMIF_BLOCK_INVALID and call the job error notification function if configured.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   375               *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   376               * FEE023:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   377               * The function Fee_MainFunction shall check the consistency of the logical block being read before
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   378               * notifying the caller. If an inconsistency of the read data is detected, the function Fee_MainFunction
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   379               * shall set the job result to MEMIF_BLOCK_INCONSISTENT and call the error notification routine of the
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   380               * upper layer if configured.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   381               *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   382               * Note: In this case the upper layer must not use the contents of the data buffer.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   383               * */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   384  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   385              /* Call the high level write function for order processing */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   386              xRetVal = Fee_HLReadBlock();
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   387          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   388          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   389  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   390          /* An internal erase order was found */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   391          case FEE_RB_SECTOR_ERASE_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   392          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   393              #if (FEE_RB_ACT_ERASE_SUSPENSION != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   394              /* Check the Fls suspend status */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   395              xRetSuspendVal = Fls_Rb_GetSuspendStatus();
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   396  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   397              /* Check if the suspend is already active ("accept and execute orders") */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   398              if(Fee_Prv_stSuspendActiv_b != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   399              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   400                  /* Verify the suspend state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   401                  if(xRetSuspendVal == FLS_RB_ST_SUSPEND_IDLE_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   402                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   403                      /* Reset the suspend done indicator */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   404                      Fee_Prv_stSuspendActiv_b = FALSE;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   405                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   406                  else if (xRetSuspendVal == FLS_RB_ST_RESUME_REQUESTED_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   407                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   408                      /* Wait until it is resumed */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   409                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   410                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   411                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   412                      /* Resume now */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   413                      if(Fls_Rb_Resume(FEE_PHYS_SEC_START0) != E_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   414                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   415                          /* Do not continue to erase in order to avoid a double erase for the same sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   416                          tmpContinueToErase_b = FALSE;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   417                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   418                      else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   419                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   420                          /* Go on with the regular erase sequence */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   421                          tmpContinueToErase_b = TRUE;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   422                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   423                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   424              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   425              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   426              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   427                  /* Suspension not active: check if it's accepted, all other suspend status will be
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   428                   * ignored and go further to erase as usual */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   429                  if(xRetSuspendVal == FLS_RB_ST_SUSPEND_ACC_AND_EXEC_ORDERS_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   430                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   431                      /* Suspend is accepted:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   432                       * --> Set the status of suspend,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   433                       * --> Don't continue to erase
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   434                       * --> Load the new order and execute it */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   435                      Fee_Prv_stSuspendActiv_b = TRUE;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   436                      tmpContinueToErase_b = FALSE;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   437                      Fee_LoadNextOrder();
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   438                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   439              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   440              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   441              if(tmpContinueToErase_b)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   442              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   443                  /* Call the low level erase function for order processing */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   444                  if(Fee_LLEraseSector() != FEE_ORDER_PENDING_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   445                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   446                      /* Check if a former user order has to be proceeded (this might be the case if
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   447                       * a hard sector reorganization triggered the erase procedure) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   448                      if(Fee_Rb_WorkingStateBackUp_en != FEE_RB_IDLE_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   449                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   450                          /* Go on with the original working state and queue index which triggered the sector reorg */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   451                          Fee_Rb_WorkingState_en  = Fee_Rb_WorkingStateBackUp_en;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   452                          Fee_idxActQueue_u8      = Fee_idxActQueueBackUp;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   453  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   454                          /* Reset the backup working type and queue index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   455                          Fee_Rb_WorkingStateBackUp_en = FEE_RB_IDLE_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   456                          Fee_idxActQueueBackUp        = (uint8)FEE_QUEUE_SIZE;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   457                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   458                      else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   459                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   460                          /* Reset the internal working status */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   461                          Fee_Rb_WorkingState_en = FEE_RB_IDLE_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   462                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   463                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   464                  #if (FEE_RB_ACT_ERASE_SUSPENSION != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   465                  else if(!Fee_Prv_stHardReOrgErase_b)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   466                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   467                      /* Search new order in queue */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   468                      Fee_idxActQueue_u8 = Fee_SearchNextOrder(FALSE);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   469  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   470                      /* Check for available higher prio orders */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   471                      if(Fee_idxActQueue_u8 != FEE_QUEUE_SIZE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   472                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   473                          /* Verify the Fls main state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   474                          if((Fee_Prv_stSuspendActiv_b == FALSE) && (Fls_GetStatus() != MEMIF_IDLE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   475                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   476                              /* A suspend is necessary, pass the target address for the subsequent order */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   477                              if(Fls_Rb_Suspend(FEE_PHYS_SEC_START0) != E_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   478                              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   479                                  /* Do nothing, stay in this erase statement */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   480                              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   481                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   482                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   483                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   484                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   485                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   486                      /* Do nothing */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   487                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   488                  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   489              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   490          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   491          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   492  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   493          /* An internal soft reorganization order was found (checked if currently no user order is available) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   494          case FEE_RB_SOFT_SECTOR_REORG_MODE_E:
	mov	d15,#5
	jeq	d15,d1,.L7
.L248:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   495          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   496              /* Call the low level reorganization function for order processing */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   497              if(Fee_LLSectorReorganization(&stSectReorgInt_b) != FEE_ORDER_PENDING_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   498              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   499                  /* Reorganization is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   500                  Fee_Rb_WorkingState_en = FEE_RB_IDLE_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   501              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   502              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   503              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   504                  /* Check for interruptability of the reorganization */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   505                  if(stSectReorgInt_b != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   506                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   507                      /* Reset the internal working status although the reorganization
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   508                       * might not be finished yet completely
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   509                       * --> allow user orders to happen in between */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   510                      Fee_Rb_WorkingState_en = FEE_RB_IDLE_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   511                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   512              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   513          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   514          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   515  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   516          /* An internal hard reorganization order was found (checked if a user order was currently placed) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   517          case FEE_RB_HARD_SECTOR_REORG_MODE_E:
	mov	d15,#6
	jeq	d15,d1,.L8
.L249:
	mov	d15,#7
	jeq	d15,d1,.L9
	j	.L10
.L2:
	movh.a	a15,#@his(Fee_idxActQueue_u8)
	lea	a15,[a15]@los(Fee_idxActQueue_u8)
.L250:
	mov	d4,#1
	call	Fee_SearchNextOrder
.L199:
	st.b	[a15],d2
.L251:
	movh.a	a15,#@his(Fee_idxActQueue_u8)
	lea	a15,[a15]@los(Fee_idxActQueue_u8)
	ld.bu	d15,[a15]
.L252:
	jeq	d15,#3,.L11
.L253:
	call	Fee_LoadNextOrder
.L254:
	j	.L12
.L11:
	mov	d4,#0
.L200:
	j	.L13
.L14:
	mul	d15,d4,#12
.L255:
	movh.a	a15,#@his(Fee_LLSectorOrder_st)
	lea	a15,[a15]@los(Fee_LLSectorOrder_st)
.L256:
	addsc.a	a15,a15,d15,#0
.L257:
	ld.w	d15,[a15]4
.L258:
	jeq	d15,#4,.L15
.L259:
	jne	d15,#0,.L16
.L15:
	movh.a	a15,#@his(Fee_Prv_stInit_u8)
	lea	a15,[a15]@los(Fee_Prv_stInit_u8)
	ld.bu	d15,[a15]
.L260:
	jne	d15,#1,.L17
.L261:
	movh.a	a15,#@his(Fee_idxActQueue_u8)
	lea	a15,[a15]@los(Fee_idxActQueue_u8)
.L262:
	mov	d15,#0
.L263:
	st.b	[a15],d15
.L264:
	call	Fee_LLSetEraseSector
.L201:
	mov	d15,#7
.L265:
	st.w	[a12],d15
.L266:
	j	.L18
.L17:
.L16:
	add	d4,#1
.L202:
	extr.u	d4,d4,#0,#8
.L13:
	movh.a	a15,#@his(Fee_NumFlashBanksUsed_u8)
	lea	a15,[a15]@los(Fee_NumFlashBanksUsed_u8)
	ld.bu	d15,[a15]
.L267:
	jlt.u	d4,d15,.L14
.L18:
	mov	d4,#16392
.L268:
	mov	d5,#0
	call	Fee_LLCheckReorganizationNeed
.L269:
	jne	d2,#5,.L19
.L270:
	ld.w	d15,[a12]
.L271:
	jeq	d15,#7,.L20
.L272:
	movh.a	a15,#@his(Fee_Prv_stInit_u8)
	lea	a15,[a15]@los(Fee_Prv_stInit_u8)
	ld.bu	d15,[a15]
.L273:
	jne	d15,#1,.L21
.L274:
	movh.a	a15,#@his(Fee_idxActQueue_u8)
	lea	a15,[a15]@los(Fee_idxActQueue_u8)
.L275:
	mov	d15,#0
.L276:
	st.b	[a15],d15
.L277:
	mov	d15,#5
.L278:
	st.w	[a12],d15
.L279:
	j	.L22
.L21:
.L20:
.L19:
.L12:
	j	.L23
.L3:
.L5:
	call	Fee_HLWriteBlock
.L197:
	mov	d8,d2
.L204:
	jne	d8,#5,.L24
.L280:
	mov	d8,#0
.L203:
	ld.w	d4,[a12]
	call	Fee_TriggerHardSectorReorg
.L24:
	j	.L25
.L6:
	call	Fee_HLMaintainBlock
.L205:
	mov	d8,d2
.L206:
	j	.L26
.L4:
	call	Fee_HLReadBlock
.L207:
	mov	d8,d2
.L208:
	j	.L27
.L9:
	jeq	d0,#0,.L28
.L281:
	call	Fee_LLEraseSector
.L209:
	jeq	d2,#0,.L29
.L282:
	movh.a	a15,#@his(Fee_Rb_WorkingStateBackUp_en)
	lea	a15,[a15]@los(Fee_Rb_WorkingStateBackUp_en)
	ld.w	d15,[a15]
.L283:
	jeq	d15,#0,.L30
.L284:
	st.w	[a12],d15
.L285:
	movh.a	a2,#@his(Fee_idxActQueueBackUp)
	lea	a2,[a2]@los(Fee_idxActQueueBackUp)
.L286:
	movh.a	a4,#@his(Fee_idxActQueue_u8)
	lea	a4,[a4]@los(Fee_idxActQueue_u8)
.L287:
	ld.bu	d15,[a2]
.L288:
	st.b	[a4],d15
.L289:
	mov	d15,#0
.L290:
	st.w	[a15],d15
.L291:
	mov	d15,#3
.L292:
	st.b	[a2],d15
.L293:
	j	.L31
.L30:
	mov	d15,#0
.L294:
	st.w	[a12],d15
.L31:
.L29:
.L28:
	j	.L32
.L7:
	lea	a4,[a10]0
	call	Fee_LLSectorReorganization
.L210:
	jeq	d2,#0,.L33
.L295:
	mov	d15,#0
.L296:
	st.w	[a12],d15
.L297:
	j	.L34
.L33:
	ld.bu	d15,[a10]
.L298:
	jeq	d15,#0,.L35
.L299:
	mov	d15,#0
.L300:
	st.w	[a12],d15
.L35:
.L34:
	j	.L36
.L8:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   518          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   519              /* Call the low level reorganization function for order processing */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   520              if (Fee_LLSectorReorganization(&stSectReorgInt_b) != FEE_ORDER_PENDING_E)
	lea	a4,[a10]0
	call	Fee_LLSectorReorganization
.L211:
	jeq	d2,#0,.L37
.L301:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   521              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   522                  /* Go on with the original working state and queue index which triggered the sector reorg */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   523                  Fee_Rb_WorkingState_en = Fee_Rb_WorkingStateBackUp_en;
	movh.a	a15,#@his(Fee_Rb_WorkingStateBackUp_en)
	lea	a15,[a15]@los(Fee_Rb_WorkingStateBackUp_en)
	ld.w	d15,[a15]
.L302:
	st.w	[a12],d15
.L303:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   524                  Fee_idxActQueue_u8     = Fee_idxActQueueBackUp;
	movh.a	a2,#@his(Fee_idxActQueueBackUp)
	lea	a2,[a2]@los(Fee_idxActQueueBackUp)
.L304:
	movh.a	a4,#@his(Fee_idxActQueue_u8)
	lea	a4,[a4]@los(Fee_idxActQueue_u8)
.L305:
	ld.bu	d15,[a2]
.L306:
	st.b	[a4],d15
.L307:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   525  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   526                  /* Reset the backup working type and queue index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   527                  Fee_Rb_WorkingStateBackUp_en = FEE_RB_IDLE_E;
	mov	d15,#0
.L308:
	st.w	[a15],d15
.L309:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   528                  Fee_idxActQueueBackUp        = (uint8)FEE_QUEUE_SIZE;
	mov	d15,#3
.L310:
	st.b	[a2],d15
.L37:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   529              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   530          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   531          break;
	j	.L38

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   532  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   533          /* Default state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   534          default:
.L10:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   535          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   536              /* Should never be reached, reset internal working status */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   537              Fee_Rb_WorkingState_en = FEE_RB_IDLE_E;
	mov	d15,#0
.L311:
	st.w	[a12],d15
.L312:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   538          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   539          break;
	j	.L39

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   540      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   541  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   542      /* Note:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   543       * The Nvm believes that he is the only user of the Fee
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   544       * --> Function call of Fee_GetJobResult should show the result for the last job which was started by the Nvm only.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   545       */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   546  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   547      /* FEE142: (requirement of function Fee_JobEndNotification)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   548       * If the job result is currently MEMIF_JOB_PENDING, the function Fee_JobEndNotification shall set the job
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   549       * result to MEMIF_JOB_OK, else it shall leave the job result untouched.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   550       *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   551       * FEE143: (requirement of function Fee_JobErrorNotification)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   552       * If the job result is currently MEMIF_JOB_PENDING, the function Fee_JobErrorNotification shall set the job
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   553       * result to MEMIF_JOB_OK, else it shall leave the job result untouched.*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   554  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   555      /* Verify the current job owner */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   556      if (Fee_idxActQueue_u8 < (uint8)FEE_QUEUE_SIZE)
.L39:
.L38:
.L36:
.L32:
.L27:
.L26:
.L25:
.L23:
.L22:
	movh.a	a15,#@his(Fee_idxActQueue_u8)
	lea	a15,[a15]@los(Fee_idxActQueue_u8)
	ld.bu	d15,[a15]
.L313:
	jge.u	d15,#3,.L40
.L314:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   557      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   558          Fee_JobResult[Fee_idxActQueue_u8] = Fee_JobTypeMapping[xRetVal];
	movh.a	a15,#@his(Fee_JobResult)
	lea	a15,[a15]@los(Fee_JobResult)
.L315:
	addsc.a	a15,a15,d15,#2
.L316:
	movh.a	a2,#@his(Fee_JobTypeMapping)
	lea	a2,[a2]@los(Fee_JobTypeMapping)
.L317:
	addsc.a	a2,a2,d8,#2
	ld.w	d15,[a2]
.L318:
	st.w	[a15],d15
.L319:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   559  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   560          /* For Write, Invalidate and Maintain jobs, if the request failed then return MEMIF_JOB_FAILED.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   561           * Above table may map the return value to MEMIF_BLOCK_INCONSISTENT, which is not a possible failure value for these requests.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   562           * Change done here instead of correcting the table, as the table is used for read request as well.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   563           * Also, for debugging purpose to have different internal return values for different error scenarios,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   564           * FEE_ERROR_E: for real hardware failures, FEE_ABORTED_E: for software failures like code reaching unreachable parts of the software. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   565          if((Fee_JobResult[Fee_idxActQueue_u8] == MEMIF_BLOCK_INCONSISTENT) &&
	ld.w	d15,[a15]
.L320:
	jne	d15,#4,.L41
.L321:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   566             ((Fee_Rb_WorkingState_en == FEE_RB_WRITE_MODE_E) || (Fee_Rb_WorkingState_en == FEE_RB_INVALIDATE_MODE_E)
	ld.w	d15,[a12]
.L322:
	jeq	d15,#1,.L42
.L323:
	jeq	d15,#3,.L43
.L324:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   567          #if (FEE_RB_MAINTAIN != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   568              || (Fee_Rb_WorkingState_en == FEE_RB_MAINTAIN_MODE_E)
	jne	d15,#4,.L44
.L43:
.L42:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   569          #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   570             ))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   571          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   572              Fee_JobResult[Fee_idxActQueue_u8] = MEMIF_JOB_FAILED;
	mov	d15,#1
.L325:
	st.w	[a15],d15
.L326:
	j	.L45
.L44:
.L41:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   573          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   574          else
.L45:
.L40:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   575          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   576              /* Either the operation is still ongoing or completed successfuly or the request is not a write or invalidate requests.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   577               * In all these cases, do nothing, as status is already updated correctly. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   578          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   579      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   580  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   581      /* Check the Fee order status independent from the job type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   582      if(xRetVal != FEE_ORDER_PENDING_E)
	jeq	d8,#0,.L46
.L327:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   583      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   584          /* A read, write or invalidate order was finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   585  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   586          /* Switch over the job result */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   587          switch(xRetVal)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   588          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   589              /* Job finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   590              case FEE_ORDER_FINISHED_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   591              case FEE_BLOCK_INVALIDATED_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   592              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   593                  /* Check if a job end notification was configured for the currently finished order */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   594                  if (Fee_BlockProperties_st[Fee_OrderFifo_st[Fee_idxActQueue_u8].BlockPropIdx_u16].JobEndNotification_pfn != NULL_PTR)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   595                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   596                      /* Call the user's job end notification */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   597                      Fee_BlockProperties_st[Fee_OrderFifo_st[Fee_idxActQueue_u8].BlockPropIdx_u16].JobEndNotification_pfn();
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   598                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   599              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   600              break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   601  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   602              /* Job aborted with error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   603              case FEE_ABORTED_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   604              case FEE_ERROR_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   605              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   606                  /* Check if a job end error was configured for the currently finished order */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   607                  if (Fee_BlockProperties_st[Fee_OrderFifo_st[Fee_idxActQueue_u8].BlockPropIdx_u16].JobErrorNotification_pfn != NULL_PTR)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   608                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   609                      /* Call the user's job error notification */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   610                      Fee_BlockProperties_st[Fee_OrderFifo_st[Fee_idxActQueue_u8].BlockPropIdx_u16].JobErrorNotification_pfn();
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   611                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   612              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   613              break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   614  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   615              /* Other cases */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   616              case FEE_ORDER_PENDING_E:
	mov	d15,#0
	jeq	d15,d8,.L47
.L328:
	mov	d15,#1
	jeq	d15,d8,.L48
.L329:
	mov	d15,#2
	jeq	d15,d8,.L49
.L330:
	mov	d15,#3
	jeq	d15,d8,.L50
.L331:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   617              case FEE_SECTORCHANGE_E:
	mov	d15,#4
	jeq	d15,d8,.L51
.L332:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   618              case FEE_SECTORFULL_E:
	mov	d15,#5
	jeq	d15,d8,.L52
.L333:
	mov	d15,#6
	jeq	d15,d8,.L53
	j	.L54
.L48:
.L49:
	movh.a	a15,#@his(Fee_idxActQueue_u8)
	lea	a15,[a15]@los(Fee_idxActQueue_u8)
	ld.bu	d15,[a15]
.L334:
	mul	d15,d15,#24
.L335:
	movh.a	a15,#@his(Fee_OrderFifo_st)
	lea	a15,[a15]@los(Fee_OrderFifo_st)
.L336:
	addsc.a	a15,a15,d15,#0
.L337:
	ld.hu	d15,[a15]6
	sha	d15,#4
.L338:
	movh.a	a15,#@his(Fee_BlockProperties_st)
	lea	a15,[a15]@los(Fee_BlockProperties_st)
.L339:
	addsc.a	a15,a15,d15,#0
.L340:
	ld.a	a15,[a15]8
.L341:
	jz.a	a15,.L55
.L342:
	calli	a15
.L55:
	j	.L56
.L53:
.L50:
	movh.a	a15,#@his(Fee_idxActQueue_u8)
	lea	a15,[a15]@los(Fee_idxActQueue_u8)
	ld.bu	d15,[a15]
.L343:
	mul	d15,d15,#24
.L344:
	movh.a	a15,#@his(Fee_OrderFifo_st)
	lea	a15,[a15]@los(Fee_OrderFifo_st)
.L345:
	addsc.a	a15,a15,d15,#0
.L346:
	ld.hu	d15,[a15]6
	sha	d15,#4
.L347:
	movh.a	a15,#@his(Fee_BlockProperties_st)
	lea	a15,[a15]@los(Fee_BlockProperties_st)
.L348:
	addsc.a	a15,a15,d15,#0
.L349:
	ld.a	a15,[a15]12
.L350:
	jz.a	a15,.L57
.L351:
	calli	a15
.L57:
	j	.L58
.L47:
.L51:
.L52:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   619              default:
.L54:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   620              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   621                  /* Cases should never be reached */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   622              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   623              break;
	j	.L59

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   624          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   625  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   626  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   627          /* A read, write or invalidate order was finished, reset respective queue entry and index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   628          Fee_SrvSetFifoMode(FEE_NO_ORDER, Fee_idxActQueue_u8);
.L59:
.L58:
.L56:
	mov	d4,#0
.L352:
	movh.a	a15,#@his(Fee_idxActQueue_u8)
	lea	a15,[a15]@los(Fee_idxActQueue_u8)
	ld.bu	d5,[a15]
	call	Fee_SrvSetFifoMode
.L353:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   629          Fee_idxActQueue_u8 = (uint8)FEE_QUEUE_SIZE;
	movh.a	a15,#@his(Fee_idxActQueue_u8)
	lea	a15,[a15]@los(Fee_idxActQueue_u8)
.L354:
	mov	d15,#3
.L355:
	st.b	[a15],d15
.L356:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   630  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   631          #if (FEE_PRV_DEBUGGING != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   632          if ((Fee_Rb_WorkingState_en == FEE_RB_WRITE_MODE_E) ||
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   633              (Fee_Rb_WorkingState_en == FEE_RB_INVALIDATE_MODE_E))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   634          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   635  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   636              Fee_Prv_stModuleTest_st.Fee_WriteTimeEnd_u32 = Mcu_Rb_GetSysTimePart(TIM0);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   637  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   638              Fee_Prv_stModuleTest_st.Fee_WriteTimeDiff_u32 = MCU_RB_TIM0TICKS_TO_MS(
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   639                                      Fee_Prv_stModuleTest_st.Fee_WriteTimeEnd_u32 -
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   640                                      Fee_Prv_stModuleTest_st.Fee_WriteTimeStart_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   641          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   642  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   643          if(Fee_Rb_WorkingState_en == FEE_RB_READ_MODE_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   644          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   645              Fee_Prv_stModuleTest_st.Fee_ReadTimeEnd_u32 = Mcu_Rb_GetSysTimePart(TIM0);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   646  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   647                              Fee_Prv_stModuleTest_st.Fee_ReadTimeDiff_u32 = MCU_RB_TIM0TICKS_TO_MS(
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   648                                      Fee_Prv_stModuleTest_st.Fee_ReadTimeEnd_u32 -
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   649                                      Fee_Prv_stModuleTest_st.Fee_ReadTimeStart_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   650          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   651          #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   652  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   653  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   654          /* Reset working state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   655          Fee_Rb_WorkingState_en = FEE_RB_IDLE_E;
	mov	d15,#0
.L357:
	st.w	[a12],d15
.L46:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   656      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   657  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   658      /* Update module state, based on newest information in Main-Function */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   659      Fee_UpdateStatus();
	call	Fee_UpdateStatus
.L358:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   660  }
	ret
.L139:
	
__Fee_MainFunction_function_end:
	.size	Fee_MainFunction,__Fee_MainFunction_function_end-Fee_MainFunction
.L117:
	; End of function
	
	.sdecl	'.text.rba_FeeFs1_MainFunction.Fee_LoadNextOrder',code,cluster('Fee_LoadNextOrder')
	.sect	'.text.rba_FeeFs1_MainFunction.Fee_LoadNextOrder'
	.align	2
	
	.global	Fee_LoadNextOrder

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   661  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   662  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   663  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   664   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   665   * Fee_SrvLoadNextOrder(): load next possible order in queue
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   666   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   667   * This function loads the next orders from the queue.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   668   * It has to be called only internally by the Fee's module.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   669   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   670   * \param    none
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   671   * \return
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   672   * \retval   none
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   673   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   674   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   675   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   676   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   677  /* MR12 RULE 1505 VIOLATION: This function is used within the same file and has no external linkage */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   678  void Fee_LoadNextOrder(void)
; Function Fee_LoadNextOrder
.L104:
Fee_LoadNextOrder:	.type	func

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   679  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   680      uint16 Length_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   681  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   682      /* Switch over order modes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   683      switch(Fee_OrderFifo_st[Fee_idxActQueue_u8].Mode_en)
	movh.a	a15,#@his(Fee_idxActQueue_u8)
	lea	a15,[a15]@los(Fee_idxActQueue_u8)
	ld.bu	d15,[a15]
.L363:
	mul	d15,d15,#24
.L364:
	movh.a	a15,#@his(Fee_OrderFifo_st)
	lea	a15,[a15]@los(Fee_OrderFifo_st)
.L365:
	addsc.a	a15,a15,d15,#0
.L366:
	ld.w	d15,[a15]12
.L367:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   684      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   685          /* A read order has to be processed */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   686          case FEE_READ_ORDER:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   687          case FEE_FORCED_READ_ORDER:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   688          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   689              /* Set internal working state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   690              Fee_Rb_WorkingState_en = FEE_RB_READ_MODE_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   691  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   692              #if (FEE_PRV_DEBUGGING != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   693              Fee_Prv_stModuleTest_st.Fee_ReadTimeStart_u32 = Mcu_Rb_GetSysTimePart(TIM0);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   694              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   695          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   696          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   697  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   698          /* A write- or invalidate order has to be processed */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   699          case FEE_WRITE_ORDER:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   700          case FEE_INVALIDATE_ORDER:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   701          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   702              uint16 dataLen_u16 , blockPropIdx_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   703              boolean noFbActive_b , doubleSecActive_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   704  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   705  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   706              if (Fee_OrderFifo_st[Fee_idxActQueue_u8].Mode_en == FEE_INVALIDATE_ORDER)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   707              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   708                  dataLen_u16 = 0u;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   709              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   710              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   711              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   712                  dataLen_u16 = Fee_OrderFifo_st[Fee_idxActQueue_u8].Length_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   713              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   714  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   715  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   716              blockPropIdx_u16 = Fee_OrderFifo_st[Fee_idxActQueue_u8].BlockPropIdx_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   717  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   718              doubleSecActive_b = (Fee_BlockProperties_st[blockPropIdx_u16].Flags_u16 & FEE_FLAG_SEC_LEVEL_MSK) > 0u;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   719  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   720              #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   721              noFbActive_b  = (Fee_BlockProperties_st[blockPropIdx_u16].Flags_u16 & FEE_FLAG_NOFALLBACK_MSK) > 0u;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   722              #else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   723              noFbActive_b = FALSE;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   724              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   725  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   726              // Currently the size of a block is limited to one sector size
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   727              //and even doubled in size it cannot overpass the MAXUINT16
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   728              Length_u16 = (uint16) Fee_SrvCalcSpaceNeededForWrite(dataLen_u16 , doubleSecActive_b , noFbActive_b);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   729  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   730  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   731              /* Check for the necessity of a hard sector reorganization before executing any write orders.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   732               * Do not consider the security level because the low level function will check for enough
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   733               * space copy wise so the first copy might get written before the HSR is triggered.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   734               * --> Additional check in HLD in order to fasten up reaction time
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   735               * --> Hint: SECTORFULL is returned in case the respective threshold is already reached */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   736              if (Fee_LLCheckReorganizationNeed(FEE_REQUIRED_FREE_SPACE_BEFORE_HARD_SR, Length_u16) == FEE_SECTORFULL_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   737              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   738                  /* Save the current working state and queue index in order to come back afterwards */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   739                  if (Fee_OrderFifo_st[Fee_idxActQueue_u8].Mode_en == FEE_WRITE_ORDER)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   740                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   741                      /* Save the current working state and trigger a reorganization */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   742                      Fee_TriggerHardSectorReorg(FEE_RB_WRITE_MODE_E);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   743                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   744                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   745                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   746                      /* Save the current working state and trigger a reorganization */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   747                      Fee_TriggerHardSectorReorg(FEE_RB_INVALIDATE_MODE_E);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   748                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   749              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   750              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   751              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   752                  /* Set internal working state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   753                  if (Fee_OrderFifo_st[Fee_idxActQueue_u8].Mode_en == FEE_WRITE_ORDER)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   754                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   755                      Fee_Rb_WorkingState_en = FEE_RB_WRITE_MODE_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   756                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   757                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   758                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   759                      Fee_Rb_WorkingState_en = FEE_RB_INVALIDATE_MODE_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   760                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   761              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   762          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   763          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   764  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   765          #if(FEE_RB_MAINTAIN != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   766          case FEE_MAINTAIN_ORDER:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   767          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   768              uint16 dataLen_u16 , blockPropIdx_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   769              boolean noFbActive_b , doubleSecActive_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   770  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   771              /* Check for the necessity of a hard sector reorganization before executing any write orders.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   772               * Do not consider the security level because the low level function will check for enough
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   773               * space copy wise so the first copy might get written before the HSR is triggered.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   774               * --> Additional check in HLD in order to fasten up reaction time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   775              dataLen_u16 = Fee_OrderFifo_st[Fee_idxActQueue_u8].Length_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   776  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   777              blockPropIdx_u16 = Fee_OrderFifo_st[Fee_idxActQueue_u8].BlockPropIdx_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   778  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   779              doubleSecActive_b = (Fee_BlockProperties_st[blockPropIdx_u16].Flags_u16 & FEE_FLAG_SEC_LEVEL_MSK) > 0u;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   780  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   781              #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   782                  noFbActive_b  = (Fee_BlockProperties_st[blockPropIdx_u16].Flags_u16 & FEE_FLAG_NOFALLBACK_MSK) > 0u;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   783              #else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   784                  noFbActive_b = FALSE;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   785              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   786  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   787              Length_u16 = (uint16) Fee_SrvCalcSpaceNeededForWrite(dataLen_u16 , doubleSecActive_b , noFbActive_b);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   788  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   789              if(Fee_LLCheckReorganizationNeed(FEE_REQUIRED_FREE_SPACE_BEFORE_HARD_SR,Length_u16) == FEE_SECTORFULL_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   790              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   791                  /* Save the current working state and trigger a reorganization */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   792                  Fee_TriggerHardSectorReorg(FEE_RB_MAINTAIN_MODE_E);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   793              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   794              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   795              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   796                  /* Set internal working state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   797                  Fee_Rb_WorkingState_en = FEE_RB_MAINTAIN_MODE_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   798  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   799                  /* Set global module status to busy */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   800                  Fee_GlobModuleState_st = MEMIF_BUSY;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   801              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   802          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   803          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   804          /* FEE_RB_MAINTAIN != FALSE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   805          #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   806  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   807          /* No order has to be processed */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   808          case FEE_NO_ORDER:
	mov	d0,#0
	jeq	d15,d0,.L60
.L368:
	mov	d0,#1
	jeq	d15,d0,.L61
.L369:
	mov	d0,#2
	jeq	d15,d0,.L62
.L370:
	mov	d0,#3
	jeq	d15,d0,.L63
.L371:
	mov	d0,#4
	jeq	d15,d0,.L64
.L372:
	mov	d0,#5
	jeq	d15,d0,.L65
	j	.L66
.L61:
.L65:
	movh.a	a15,#@his(Fee_Rb_WorkingState_en)
	lea	a15,[a15]@los(Fee_Rb_WorkingState_en)
.L373:
	mov	d15,#2
.L374:
	st.w	[a15],d15
.L375:
	j	.L67
.L62:
.L63:
	jne	d15,#3,.L68
.L376:
	mov	d0,#0
.L212:
	j	.L69
.L68:
	ld.hu	d0,[a15]10
.L69:
	ld.hu	d15,[a15]6
.L214:
	sha	d15,#4
.L215:
	movh.a	a15,#@his(Fee_BlockProperties_st)
	lea	a15,[a15]@los(Fee_BlockProperties_st)
.L377:
	addsc.a	a15,a15,d15,#0
.L378:
	ld.hu	d15,[a15]2
.L379:
	and	d15,#1
.L380:
	ne	d1,d15,#0
.L216:
	mov	d2,#0
.L156:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     1  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     2  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     3  #ifndef RBA_FEEFS1_PRV_H
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     4  #define RBA_FEEFS1_PRV_H
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     5  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     6  #if(defined(FEE_PRV_CFG_SELECTED_FS) && (1 == FEE_PRV_CFG_SELECTED_FS))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     7  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     8  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     9   **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    10   * \moduledescription
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    11   *           AUTOSAR FEE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    12   *           According to Document Version 3.0.0, Part of Release 4.0, Revision 2
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    13   * \scope    INTERN
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    15   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    16  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    17  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    18  /*
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    19  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    20  * Defines/Macros
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    21  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    22  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    23  /* General defines */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    24  #define FEE_MAXUINT32               (0xFFFFFFFFuL)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    25  #define FEE_MAXUINT16               (0xFFFFu)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    26  #define FEE_NULL                    (0u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    27  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    28  #define FEE_MARKER_PATTERN          0xCAFEu                 /* Pattern to identify a marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    29  #define FEE_NUM_MARKER_IN_HEADER    (FEE_NUM_MARKER_E - 1)  /* A sector has at least 4 states:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    30                                                                 ERASED -> USED -> FULL -> ERASE_REQ
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    31                                                                 Value is also in used in Fee_Process.pm */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    32  #define FEE_NO_SEC_IDX_FOUND        0xFFu                   /* No active sector / matching flash bank found */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    33  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    34  #define FEE_MARKER_SIZE             8u                      /* Each marker has a size of 8 Bytes (fix value is used in Fee_Process.pm) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    35  #define FEE_MARKER_CS_SIZE          2u                      /* Size of CRC16 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    36  #define FEE_LL_DATABUFFSIZE         256u                    /* Size of the internal data buffer used for writing */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    37                                                              /* (The page buffer size is auto generated) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    38  #define FEE_LL_CRC_CALC_RESTRICTION FEE_LL_DATABUFFSIZE     /* Restriction for the Crc calculation */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    39  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    40  #define FEE_FREE_PAGES_FOR_ERASED_ST    1u                  /* Number of pages containing the erased value */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    41  #define FEE_SIZE_OF_BLOCK_CS            4                   /* Size of block checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    42  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    43  /* Special values for sector change counter within the RAM array */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    44  #define FEE_SEC_CHANGE_CNT_RESET_REQ  0xFFFFFFFFuL
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    45  #define FEE_SEC_CHANGE_CNT_UNDEF      FEE_SEC_CHANGE_CNT_RESET_REQ
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    46  #define FEE_SEC_CHANGE_CNT_ERASED     (FEE_SEC_CHANGE_CNT_RESET_REQ - 1u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    47  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    48  /* Mask for accessing block flags in the configuration and in the block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    49  #define FEE_FLAG_SEC_LEVEL_MSK      0x0001u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    50  #define FEE_FLAG_SEC_LEVEL_BP       0u       /* Security level setting is bit 0 within the block flags */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    51  #define FEE_BLK_INT_DOUBLE_STORAGE  1u       /* Internal double block storage definition */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    52  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    53  #define FEE_FLAG_DATAFILTERTYPE_ATTR_MSK      0x0006u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    54  #define FEE_FLAG_DATAFILTERTYPE_ATTR_BP       1u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    55  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    56  #define FEE_FLAG_INVALID_MSK        0x08u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    57  #define FEE_FLAG_INVALID_BP         3u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    58  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    59  #define FEE_FLAG_SURV_ATTR_MSK      0x0010u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    60  #define FEE_FLAG_SURV_ATTR_BP       4u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    61  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    62  #define FEE_FLAG_ROBUST_ATTR_MSK    0x0020
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    63  #define FEE_FLAG_ROBUST_ATTR_BP     5
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    64  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    65  #define FEE_FLAG_NOFALLBACK_MSK     0x0040u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    66  #define FEE_FLAG_NOFALLBACK_BP      6u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    67  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    68  #define FEE_MASK_BIT7               (uint8)0x80
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    69  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    70  /* Mask for accessing block flags (upper byte only) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    71  #define FEE_FLAG_JOBTYPE_MSK        0x0300u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    72  #define FEE_FLAG_JOBTYPE_BP         8u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    73  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    74  #define FEE_FLAG_JOBPRIO_MSK        0x0400u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    75  #define FEE_FLAG_JOBPRIO_BP         10u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    76  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    77  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    78  /* Macros for the conversion of the Sec Level settings:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    79   * Internal storage level:      Sec Level 1  --> 0 / Sec Level 2 --> 1
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    80   * User Config storage level:   Sec Level 1  --> 1 / Sec Level 2 --> 2 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    81  #define FEE_INT_TO_USER_STORAGE_TYPE(SEC_LEVEL) ((SEC_LEVEL) + 1u)   /* Convert the Sec Level setting from
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    82                                                                         header/properties == internal to user config format */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    83  #define FEE_CNT_FIRST_COPY          0u       /* Internal counter value for first copy */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    84  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    85  /* Erase actions */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    86  #define FEE_NO_SECTOR_TO_ERASE      0xFFu    /* No sector has to be erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    87  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    88  /* Block header validation */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    89  #define FEE_BLK_HEADER_PREAMBEL             0xA53C96uL                                  /* Pattern of preambel */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    90  #define FEE_BLK_HEADER_PREAMBEL_BYTE_2      (FEE_BLK_HEADER_PREAMBEL & 0xFFu)           /* 0x96 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    91  #define FEE_BLK_HEADER_PREAMBEL_BYTE_1      ((FEE_BLK_HEADER_PREAMBEL >> 8u) & 0xFFu)   /* 0x3C */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    92  #define FEE_BLK_HEADER_PREAMBEL_BYTE_0      ((FEE_BLK_HEADER_PREAMBEL >> 16u) & 0xFFu)  /* 0xA5 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    93  #define FEE_BLK_HEADER_SIZE                 14u                                         /* Size of block header in bytes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    94  #define FEE_BKL_HEADER_REDUCTION            FEE_VIRTUAL_PAGE_SIZE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    95  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    96  /* Calculation of free byte in current sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    97  #define FEE_LL_SECTOR_USED_FOR_WRITING      Fee_RdWrOrder_st.xWrAddress
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    98  #define FEE_LL_SECTOR_USED_FOR_READING      Fee_RdWrOrder_st.xRdAddress
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    99  #define FEE_LL_SECTOR_USED_FOR_COMPARING    Fee_RdWrOrder_st.xCmpAddress
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   100  #define FEE_LL_SECTOR_USED_FOR_CRC_CALC     Fee_RdWrOrder_st.xCrcAddress
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   101  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   102  /* Cache usage*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   103  #define FEE_INVLD_BLOCK_PROP_IDX        0xFFFFFFFFuL    /* Invalid Fee Idx that can be passed to the block header search function
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   104                                                             in order to ignore the cache during the init phase */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   105  #define FEE_USE_CACHED_ACCESS               0x01u       /* Use the cache method for finding the next block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   106  #define FEE_USE_MANUAL_ACCESS               0x00u       /* Search manually for headers */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   107  #define FEE_UPDATE_CACHE_IN_INIT            0x01u       /* Update the cache for fast access in init */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   108  #define FEE_NO_CACHE_UPDATE                 0x00u       /* Do not use the fast access method (only evaluated blocks are added to the cache) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   109  #define FEE_CACHE_UPD_NOT_COMP_FOR_SECT     0x00u       /* The respective sector was not completely checked */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   110  #define FEE_CACHE_UPD_COMP_FOR_SECT         0x01u       /* The respective sector was checked completely */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   111  #define FEE_CACHE_UPD_COMP_FOR_ALL_SECT     0x02u       /* All sectors have been checked completely */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   112  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   113  #define Fee_LLInvalidateAddressInCache(FEEIDX) Fee_LLUpdateAddressInCache(FEEIDX, FEE_CACHE_INIT_VALUE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   114  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   115  /* Fee init defines */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   116  #define FEE_PRV_ST_INIT_RUNNING             0x00u       /* Module is still uninitialized */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   117  #define FEE_PRV_ST_INIT_DONE                0x01u       /* Module has been initialized */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   118  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   119  /* Fee reorganization defines */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   120  #define FEE_PRV_ST_REORG_IDLE               0x00u       /* No reorganization is running */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   121  #define FEE_PRV_ST_REORG_STANDARD_RUNNING   0x01u       /* Standard reorganization is running */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   122  #define FEE_PRV_ST_REORG_AFTERB_RUNNING     0x02u       /* "Afterburner" of the reorganization is runnning */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   123  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   124  /* Amount of sectors used by the emulation  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   125  #define FEE_NUM_FLASH_BANKS         Fee_NumFlashBanksUsed_u8  /* Number of sectors which can be used by the Fee */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   126  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   127  #if (FEE_RB_ADDONS_CCAS == TRUE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   128  #define FEE_RB_REQUEST_STOP_MODE            TRUE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   129  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   130  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   131  #if(FEE_ROBUST_PROG_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   132  #define FEE_ROBMARKER_BUFF_SIZE             96u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   133  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   134  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   135  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)     /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   136  #define FEE_FIRSTDATAPAGE_NOTPROGRAMMED 0x00u            /* First data pages in Fee_LlFls2FlsCopy is not yet programmed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   137  #define FEE_FIRSTDATAPAGE_PROGRAMMED     0x01u            /* First data pages in Fee_LlFls2FlsCopy is programmed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   138  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   139  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   140  /*
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   141  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   142  * Type definitions
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   143  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   144  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   145  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   146  /* Order priority */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   147  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   148  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   149      FEE_NORMAL_PRIO_E = 0,      /* e.g. if FeeImmediateData is configured to no */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   150      FEE_HIGH_PRIO_E   = 1       /* e.g. if FeeImmediateData is configured to yes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   151  }Fee_HlPriority_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   152  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   153  /* This enumerator list contains the index inside the order queue.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   154   * Attention: The order in the enumerator is from Low (FEE_ADAPTER_JOB) to High (FEE_INTERNAL_JOB).
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   155   *            Do not change this order!
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   156   * */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   157  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   158  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   159      FEE_INTERNAL_JOB,           /* Internal job (reorganization or sector erase) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   160      FEE_NVM_JOB,                /* Nvm job */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   161      FEE_ADAPTER_JOB,            /* Adapter job (e.g. Mx17 Eep) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   162      FEE_QUEUE_SIZE              /* Size of the Fee internal queue (each job type has 1 entry) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   163  }Fee_HlJobType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   164  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   165  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   166  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   167      uint8*  DataBufferPtr_pu8;  /* Pointer to the read- or write-buffer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   168      uint16  FeeIdx_u16;         /* FeeRbBlockPersistentId */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   169      uint16  BlockPropIdx_u16;   /* Respective block properties table index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   170      uint16  Offset_u16;         /* Offset inside block (could be != 0 only for read-orders --> R4.0 Rev1) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   171      uint16  Length_u16;         /* Block length, only required for element-read-jobs */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   172      Fee_HlMode_ten Mode_en;     /* Type of this order: Read, Write, Invalidate */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   173      Fee_HlPriority_ten Prio_en; /* Priority out of the configuration */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   174      uint8   SecLevel_u8;        /* Security level out of the configuration */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   175  }Fee_OrderFifo_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   176  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   177  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   178  /* Hint:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   179   * For calculation of the sector order (old -> new -> erased -> undef) the sector change counter is a valid criteria.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   180   * The lowest valid value points to the eldest data, the most current value to the most current data.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   181   * These following defines are used for an implicit sorting:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   182   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   183   *  +------+------+------+------+------+------+------+------+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   184   *  |MarkerPattern|Ident | marker content     |marker CRC16 |
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   185   *  +------+------+------+------+------+------+------+------+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   186   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   187   *  Sector headers: 12 times available as default
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   188   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   189   *      +------+------+------+------+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   190   *    0 |Erased| Used | Full |Erase |
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   191   *      +------+------+------+------+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   192   *    4 |      |      |      |      |
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   193   *      +------+------+------+------+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   194   *    8 |      |      |      |      |
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   195   *      +------+------+------+------+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   196   *      |<---->|
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   197   *        Page
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   198   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   199   * Erased:  Sector was erased successfully. This marker also contains the sector erase counter
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   200   * Used:    Sector contains user data. This marker will be written first before data is written into a sector.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   201   *          This marker also contains the sector change counter.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   202   * Full:    Sector is completely full and must not be considered for searching for the first empty page.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   203   *          This marker also contains the sector change counter.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   204   * Erase:   Sector contains no valid data anymore and can be erased in the background task.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   205   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   206   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   207  enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   208  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   209      FEE_ERASED_MARKER_ID_E = 0x01u, /* Sector was erased successfully */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   210      FEE_USED_MARKER_ID_E,           /* Sector was used to store data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   211      FEE_FULL_MARKER_ID_E,           /* Sector is full */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   212      FEE_ERASE_REQUEST_ID_E,         /* Sector should be erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   213      FEE_START_MARKER_ID_E,            /* Double storage of USED marker, contains address of first blockheader */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   214      FEE_CLONE_START_MARKER_ID_E,    /* Marker to indicate that cloning of a defect sector has startet in this sector --> Ifx robust programming */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   215      FEE_RESERVED_MARKER_ID1_E,      /* Reserved range marker space in the sector header, currently not used! */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   216      FEE_RESERVED_MARKER_ID2_E,      /*    "       "     "      "   "    "      "         "      "    "   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   217      FEE_RESERVED_MARKER_ID3_E,      /*    "       "     "      "   "    "      "         "      "    "   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   218      FEE_RESERVED_MARKER_ID4_E,      /*    "       "     "      "   "    "      "         "      "    "   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   219      FEE_RESERVED_MARKER_ID5_E,      /*    "       "     "      "   "    "      "         "      "    "   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   220      FEE_RESERVED_MARKER_ID6_E,      /*    "       "     "      "   "    "      "         "      "    "   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   221      FEE_NUM_MARKER_E                /* Amount of required markers in the sector header + 1 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   222  };
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   223  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   224  /* Sector marker structure */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   225  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   226  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   227      uint16  xPattern;               /* Static marker pattern: 0xCAFE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   228      uint8   xIdent;                 /* Ident to identify the marker: 0x01 Erased-Marker, 0x02 Used-Marker, 0x03 Full-Marker, 0x04 Erase-Request */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   229      uint8   xContent[3];            /* Sector change counter */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   230      uint16  xChecksum;              /* Crc16 checksum, calculation over Patter, Ident and content */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   231  }Fee_MarkerProp_t;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   232  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   233  /* Sector detection type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   234  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   235  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   236      uint32  SecChngCnt_u32;         /* Sector change counter */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   237      uint8   ctErasedMarker_u8;      /* Number of found ERASED markers */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   238      uint8   ctUsedMarker_u8;        /* Number of found USED markers */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   239      uint8   ctFullMarker_u8;        /* Number of found FULL markers */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   240      uint8   ctEraseReq_u8;          /* Number of found ERASE requests */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   241      uint32  xStartAddr_u32;         /* Address of first blockheader in the sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   242      uint8   ctCloneMarker_u8;       /* Cloning of data has started (only Ifx robust programming algorithm */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   243  }Fee_stSecDet_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   244  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   245  /* Sector states */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   246  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   247  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   248      FEE_SECTOR_STATE_UNDEF_E        = 0,                      /* undefined sector-state --> no marker found */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   249      FEE_SECTOR_ERASED_E             = FEE_ERASED_MARKER_ID_E, /* sector was erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   250      FEE_SECTOR_USED_E               = FEE_USED_MARKER_ID_E,   /* sector was used to write data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   251      FEE_SECTOR_FULL_E               = FEE_FULL_MARKER_ID_E,   /* sector is full */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   252      FEE_SECTOR_REQUEST2ERASE_E      = FEE_ERASE_REQUEST_ID_E, /* sector could be erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   253      FEE_SECTOR_CONSIDERED_E         = FEE_NUM_MARKER_E        /* sector was considered in function Fee_LLDetectActiveSector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   254  }Fee_SectorState_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   255  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   256  /* Sector order after sort sequence */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   257  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   258  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   259      uint32 SecChngCnt_u32;                  /* Sector change counter */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   260      Fee_SectorState_ten SecState_en;        /* Sector state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   261      uint8 xPhySecIdx_u8;                    /* Sector index (physical sector) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   262  }Fee_LLSectorOrder_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   263  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   264  /* Fee internal return types */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   265  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   266  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   267      FEE_ORDER_PENDING_E,            /* The order is still pending*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   268      FEE_ORDER_FINISHED_E,           /* The order was finished without error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   269      FEE_BLOCK_INVALIDATED_E,        /* The block was invalidated in the block status */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   270      FEE_ERROR_E,                    /* An error occured, maybe data in flash was not valid */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   271      FEE_SECTORCHANGE_E,             /* A sector change has to be done */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   272      FEE_SECTORFULL_E,               /* The sector is full */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   273      FEE_ABORTED_E,                  /* An order was aborted*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   274      FEE_ERASE_SECTOR_E,             /* The sector must be erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   275      FEE_SEARCH_ABORTED_E,           /* Searching was aborted */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   276      FEE_NUM_RET_VAL_E               /* Number of return values */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   277  }Fee_stRetVal_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   278  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   279  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   280  /* Flash properties */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   281  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   282  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   283      uint32  Fee_PhysStartAddress_u32;       /* Physical sector: start address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   284      uint32  Fee_PhysEndAddress_u32;         /* physical sector: end address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   285      uint32  Fee_LogStartAddress_u32;        /* logical sector: start address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   286      uint32  Fee_LogEndAddress_u32;          /* logical sector: end address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   287  }Fee_FlashProp_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   288  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   289  /* Block properties for all Fee blocks
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   290   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   291   * Status Flags:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   292   * Block flags will help to specify a more detailed block configuration. The low Byte of these block flags is also stored
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   293   * in the flash (status byte inside the block header). This information (in Flash) can be used to read/write the layout
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   294   * without configuration (PAV, CB).
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   295   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   296   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   297   *                                                 |<----- Block Status Byte in Block Header ----->|
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   298   * |<---------------------------------------- Block Flags ---------------------------------------->|
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   299   *    F     E     D     C     B     A     9     8  |  7     6     5     4     3     2     1     0  |
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   300   * +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   301   * |     |     |     |     |     |Prio-| Job type  |     |     | Rob |Surv.|(Inv)| DataFilter| Sec-|
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   302   * |     |     |     |     |     |rity |           |     |     |Attr.|Attr.|     |    Type   | lvl |
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   303   * +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   304   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   305   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   306   *  0  ... SecurityLevel      => 0...SingleStorage, 1...DoubleStorage
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   307   * 1+2 ... Data Filter Type   => 0...Dynamic:         Anybody can erase this block (e.g. during migration)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   308   *                               1...Static:          Only certain users (e.g. repair shops) can erase this block
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   309   *                               2...Permanent:       Only very certain users (e.g. OEM) can erase this block
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   310   *                               3...Super Permanent: Block can never be erased
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   311   *  3 .... Invalid            => 0...Block OK, 1...Block is invalid  --> can be changed by function Fee_InvalidateBlock
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   312   *  4 .... Survival Attribute => 0...No survival, 1... Survival (even without being part of the layout)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   313   *  5 .... Robustness Attribute (Robustness against data modification during write execution)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   314   *                            => 0...Deactivated:     No additional checksum is used
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   315   *                            => 1...Activated:       Additional checksum is used
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   316   * 8+9 ... TypeOfBlock        => 0...InternalJob, 1...NvmJob, 2...AdapterJob (e.g. Mx17 Eep adapter)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   317   *  A .... Priority           => Job priority:        0...FEE_NORMAL_PRIO_E --> FeeImmediateData = No
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   318   *                                                    1...FEE_HIGH_PRIO_E   --> FeeImmediateData = Yes
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   319   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   320  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   321  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   322      uint16 BlockPersistentId_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   323      uint16 Flags_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   324      uint16 Length_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   325      void (* const JobEndNotification_pfn) (void);      /* callback function, will be called if a job was successfully finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   326      void (* const JobErrorNotification_pfn) (void);    /* callback function, will be called if a job was finished with an error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   327  }Fee_BlockPropertiesType_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   328  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   329  /* Job types corresponding to the queue index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   330  enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   331  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   332      FEE_JOB_TYPE_INTERNAL_E = 0,            /* Internal job index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   333      FEE_JOB_TYPE_NVM_E      = 1,            /* NvM job index  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   334      FEE_JOB_TYPE_ADAPTER_E  = 2             /* Adapter job index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   335  };
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   336  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   337  /* State machine types for the function Fee_LLWriteMarker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   338  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   339  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   340      FEE_LL_MARKER_INIT_E,                   /* Init state                                    */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   341      FEE_LL_MARKER_BLK_CHK_E,                /* Perform a blank check over one page           */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   342      FEE_LL_MARKER_BLK_CHK_WAIT_E,           /* Wait for the blank check order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   343      FEE_LL_MARKER_BLK_CHK_ERROR_E,          /* Differences detected                          */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   344      FEE_LL_MARKER_BLK_CHK_FINISHED_E,       /* Start write order of the marker               */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   345      FEE_LL_MARKER_WRITE_WAIT_E,             /* Wait for the write order to be finished       */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   346      FEE_LL_MARKER_WRITE_ERROR_E,            /* Read or write error                           */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   347      FEE_LL_MARKER_VERIFY_E,                 /* Verify written marker                         */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   348      FEE_LL_MARKER_VERIFY_WAIT_E,            /* Wait for verify marker                        */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   349      FEE_LL_MARKER_VERIFY_FINISHED_E         /* Verify marker finished                        */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   350  }Fee_LLWrMarkerType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   351  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   352  /* State machine types for the function Fee_HLWriteBlock and Fee_HLReadBlock */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   353  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   354  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   355      FEE_HL_RDWR_BLK_INIT_E,                 /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   356      FEE_HL_SEARCH_BLK_HDR_E,                /* Search block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   357      FEE_HL_READ_BLK_HDR_WAIT_E,                  /* Read block header for redundant blocks */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   358      FEE_HL_CHECK_BLK_HDR_E,                 /* Check block header for redundant blocks */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   359      FEE_HL_CALC_BLK_CS_E,                   /* Calculate the user checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   360      FEE_HL_CHECK_BLK_CS_E,                  /* Verify the block checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   361      FEE_HL_RD_DATA_FROM_BLK_E,              /* Read the block data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   362      FEE_HL_COMP_BLK_E,                      /* Compare the complete block data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   363  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   364      /* Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   365      #if (defined(RBA_FLSIFX_FLASH) || defined(RBA_FLSJDP_FLASH))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   366      FEE_HL_RD_WAIT_FOR_FLS_E,               /* Wait for the Fls to overstamp an invalid header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   367      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   368      /* END Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   369  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   370      FEE_HL_WR_BLK_E                         /* Write the block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   371  }Fee_HLRdWrBlockType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   372  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   373  /* State machine types for the function Fee_LLWriteBlock */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   374  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   375  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   376      FEE_LL_WR_BLK_INIT_E,                   /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   377      FEE_LL_WR_WRITEHEADER_E,                /* Write the header (and first data bytes) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   378      FEE_LL_WR_SIZECHECK_HSR_E,              /* check for space until HSR */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   379      #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   380      FEE_LL_WR_BLANKCHECK_NOFB_WR_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   381      FEE_LL_WR_BLANKCHECK_NOFB_WR_WAIT_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   382      FEE_LL_WR_WRITE_NOFB_MARKER_E,          /* Write the NoFallback marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   383      FEE_LL_WR_WRITE_NOFB_MARKER_WAIT_E,     /* Wait until the programming of the NoFallback marker is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   384      FEE_LL_WR_FILL_SECTOR_END_E,            /* Changes the active sector and fills the empty pages if necessary */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   385      FEE_LL_WR_FILL_SECTOR_END_WAIT_E,       /* Wait until the write order to fill the empty pages is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   386      FEE_LL_WR_FILL_SECTOR_END_ERROR_E,      /* Errors during write occured */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   387      FEE_LL_WR_WRITE_NOFB_MARKER_ERROR_E,    /* Errors during write occured */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   388      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   389      FEE_LL_WR_WRITEHEADER_WAIT_E,           /* Wait until the write order is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   390      FEE_LL_WR_VERIFYHEADER_E,               /* Verify the header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   391      FEE_LL_WR_VERIFYHEADER_WAIT_E,          /* Wait for the verification to end */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   392      FEE_LL_WR_VERIFYHEADER_ERROR_E,         /* Verify error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   393      FEE_LL_WR_WRITEDATA_SEC_A_E,            /* Write the data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   394      FEE_LL_WR_WAIT_WRITEDATA_SEC_A_E,       /* Wait until the write order is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   395      FEE_LL_WR_WRITE_ERROR_E,                /* Error during write (header or data page writes) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   396  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   397      FEE_LL_WR_WRITE_FULL_MARKER_E,          /* Write the FULL marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   398      FEE_LL_WR_ERASE_SECTOR_E,               /* Erase a sector and write the ERASED marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   399      FEE_LL_WR_WRITE_USED_MARKER_E,          /* Write the USED marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   400      FEE_LL_WR_WRITE_START_MARKER_E,         /* Write the START marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   401  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   402      /* Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   403      #if (defined(RBA_FLSIFX_FLASH) || defined(RBA_FLSJDP_FLASH))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   404      FEE_LL_WR_WAIT_FOR_FLS_OVERPROGRAMMING_E,   /* Wait for the Fls to overstamp an invalid header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   405      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   406      /* END Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   407  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   408      #if(FEE_ROBUST_PROG_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   409      FEE_LL_WR_WRITEDATA_IFX_HANDLING_E,     /* robust Ifx handling in case of wordline fails */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   410      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   411      FEE_LL_WR_VERIFY_BLK_E                  /* Verify the complete data including the block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   412  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   413      /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   414      #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   415      ,FEE_LL_WR_WRITEHDRPG2_E,                /* Write the 2nd header page. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   416      FEE_LL_WR_WAIT_WRITEHDRPG2_E            /* Wait until 2nd header page write is completed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   417      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   418  }Fee_LLWrBlockType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   419  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   420  /* State machine types for the function Fee_LLCompBlkInFlash */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   421  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   422  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   423      FEE_LL_CMP_BLK_INIT_E,                  /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   424      FEE_LL_CMP_HEADER_E,                    /* Compare the complete block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   425      FEE_LL_CMP_WAIT_HEADER_E,               /* Wait for the compare to finish */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   426      FEE_LL_CMP_CHECK_OVERLAP_E,             /* Check for an overlap */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   427      FEE_LL_CMP_DATA_SEC_A_E,                /* Check the header compare result and compare the data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   428      FEE_LL_CMP_WAIT_DATA_SEC_A_E,           /* Wait for the compare to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   429      FEE_LL_CMP_FINISHED_E                   /* Verify the data compare result and reset the state machine */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   430  }Fee_LLCmpBlkType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   431  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   432  /* State machine types for the function Fee_LLCopyData2Buffer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   433  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   434  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   435      FEE_LL_CPY_BLK_INIT_E,                  /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   436      FEE_LL_CPY_BLOCK_START_E,               /* Read out the data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   437      FEE_LL_CPY_BLOCK_WAIT_E,                /* Wait for the read order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   438      FEE_LL_CPY_BLOCK_ERROR_E,               /* Error in the read function */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   439      FEE_LL_CPY_BLOCK_FINISHED_E             /* Finish the function or the data transfer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   440  }Fee_LLCpyBlkType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   441  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   442  /* State machine types for the function Fee_LLCalcBlkCrcInFlash */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   443  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   444  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   445      FEE_LL_CRC_BLK_INIT_E,                  /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   446      FEE_LL_CRC_RD_HD_PAGE_E,                /* Read the header page */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   447      FEE_LL_CRC_RD_PAGE_E,                   /* Calculate the block checksums */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   448      FEE_LL_CRC_CHECK_OVERLAP_E,             /* Check for an overlap */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   449      #if(FEE_ROB_FEATURE_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   450      FEE_LL_CRC_RD_ROB_PAGE_E,               /* Retry with the robustness checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   451      FEE_LL_CRC_CHECK_OVERLAP_ROB_E,         /* Check for an overlap */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   452      FEE_LL_CRC_RD_ROB_PAGE_WAIT_E,          /* Wait until the read access is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   453      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   454      FEE_LL_CRC_RD_PAGE_WAIT_E,              /* Wait until the read access is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   455      FEE_LL_CRC_RD_ERROR_E                   /* Read error case */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   456  }Fee_LLCalcCrcBlkType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   457  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   458  /* State machine types for reading */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   459  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   460  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   461      FEE_LL_INIT_READ_E                      /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   462      ,FEE_LL_BLANK_CHECK_E                    /* Perform a blank check */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   463      ,FEE_LL_BLANK_CHECK_WAIT_E                /* Wait for the blank check to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   464      ,FEE_LL_READ_PAGE_E                     /* Read pages */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   465      ,FEE_LL_WAIT_READ_PAGE_E                /* Wait for the read order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   466      ,FEE_LL_READ_ERROR_E                    /* Error reaction for read error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   467      ,FEE_LL_READ_FINISHED_E                 /* Finish state machine */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   468      #if (FEE_HEADER_RECHECK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   469      #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   470      ,FEE_LL_NOFALLBACK_MARKER_CHECK_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   471      ,FEE_LL_NOFALLBACK_MARKER_CHECK_WAIT_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   472      ,FEE_LL_NOFALLBACK_MARKER_CHECK_FAILED_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   473      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   474      ,FEE_LL_RECHECK_HEADER_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   475      ,FEE_LL_RECHECK_HEADER_WAIT_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   476      ,FEE_LL_RECHECK_HEADER_FAILED_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   477      ,FEE_LL_RECHECK_HEADER_FINISHED_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   478      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   479  } Fee_LLRdStateType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   480  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   481  /* States for function Fee_LLCheckErasePattern */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   482  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   483  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   484      FEE_LL_INIT_BLANK_CHECK_E,              /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   485      FEE_LL_PERFORM_BLANK_CHECK_E,           /* Perform a blank check */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   486      FEE_LL_WAIT_PERFORM_BLANK_CHECK_E,      /* Wait for the blank check order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   487      FEE_LL_BLANK_CHECK_ERROR_E,             /* Differences detected */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   488      FEE_LL_BLANK_CHECK_FINISHED_E           /* Finish state machine with success */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   489  } Fee_LLBlankCheckType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   490  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   491  /* State of function Fee_Prv_LLFindEmptyPage */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   492  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   493  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   494      #if ( defined(RBA_FLSRH850P1xC_FLASH) || defined(RBA_FLSV850R1x_FLASH) || defined(RBA_FLSRH850xx_FLASH) )
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   495      FEE_LL_FINDEMPTYPGE_INIT_E,             /* Initalize find empty page state machine  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   496      FEE_LL_FINDEMPTYPGE_CHECK_E,            /* Begin a blank check                      */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   497      FEE_LL_FINDEMPTYPGE_WAIT_E,             /* Wait until the blank check finished      */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   498      FEE_LL_FINDEMPTYPGE_RESULT_BLANK_E,     /* Checked chunk was completely blank       */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   499      FEE_LL_FINDEMPTYPGE_RESULT_NOT_BLANK_E  /* Checked chunk was not completely blank   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   500      #else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   501      FEE_LL_FIND_CURRENT_SECTOR_E,           /* Evaluate the sector with most current values */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   502      FEE_LL_FIND_LAST_HEADER_E,              /* Search the last block header in the active sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   503      FEE_LL_FINISHED_E                       /* Function finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   504      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   505  }Fee_LLFndEmptyPgeType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   506  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   507  /* State of the function Fee_LLSearchSpecifiedBlkHeader */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   508  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   509  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   510      FEE_LL_SEARCHBLK_INIT_E,                /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   511      FEE_LL_SEARCHBLK_BLK_HEADER_E           /* Search for the next block header*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   512  }Fee_LLSearchBlkHdrType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   513  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   514  #if(FEE_FAST_CACHE_INIT_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   515  /* State of the function Fee_BuildUpCache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   516  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   517  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   518      FEE_LL_BLD_UP_CACHE_INIT_E,             /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   519      FEE_LL_BLD_UP_CACHE_READ_E              /* Read out data directly if possible */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   520  }Fee_LLBuildUpCache_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   521  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   522  /* State of the function Fee_BuildUpCacheForAllSect */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   523  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   524  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   525      FEE_LL_BLD_UP_CACHE_ALL_SECT_INIT_E,/* Init case */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   526      FEE_LL_BLD_UP_CACHE_ALL_SECT_DO_E   /* Build up the cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   527  }Fee_LLBuildUpCacheAllSect_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   528  /* FEE_FAST_CACHE_INIT_ACTIVE != FALSE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   529  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   530  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   531  #if((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   532  #if (FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE == 0)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   533  /* Unknown blcok sector reorganiation without cache: State of the function Fee_LLSearchUnknBlkHeader */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   534  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   535  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   536      FEE_LL_SEARCHUNKNBLK_INIT_E,            /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   537      FEE_LL_SEARCHUNKNBLK_UNKN_BLK_HEADER_E, /* Search the next unknown block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   538      FEE_LL_SEARCHUNKNBLK_SPEC_BLK_HEADER_E  /* Search the next specific block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   539  }Fee_LLSearchUnknBlkHdrType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   540  #else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   541  /* Unknown block sector reorganiation with cache: states of cache build up function Fee_BuildUpCacheUnknownBlk */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   542  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   543  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   544      FEE_LL_BLD_UP_CACHE_UNKOWN_BLK_INIT_E,             /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   545      FEE_LL_BLD_UP_CACHE_UNKOWN_BLK_READ_E,             /* Read out data directly if possible */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   546      FEE_LL_BLD_UP_CACHE_UNKOWN_BLK_VALIDATEDATA_E      /* Validate the data CRC of the uknown block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   547  }Fee_LLBuildUpUnknownBlkCache_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   548  #endif /* End of (FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE == 0) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   549  #endif /* End of ((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE)) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   550  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   551  /* States for the function Fee_LLSectorReorganization */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   552  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   553  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   554      FEE_LL_REORG_INIT_E,                    /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   555      FEE_LL_REORG_PREP_SEARCH_BLK_E,         /* Prepare the next block search */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   556      FEE_LL_REORG_SEARCH_BLK_E,              /* Search for a specific block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   557      FEE_LL_REORG_CHECK_BLOCK_CS_E,          /* Evaluate the block checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   558      FEE_LL_REORG_REDUNDANT_BLK_CHK_E,       /* Check if redundant copy is not lost during sector reorg. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   559      FEE_LL_REORG_WRITE_BLOCK_E,             /* Write a block into the latest sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   560  #if((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   561      FEE_LL_REORG_SEARCH_UNK_BLK_E,          /* Search for an unknown block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   562   #if(FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE != 0) /* Unknown blcok sector reorganiation with cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   563      FEE_LL_REORG_CACHEBUILDUP_UNK_BLK_E,    /* Building of cache for unknown block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   564      FEE_LL_REORG_SEARCH_UNK_HDRBLK_WAIT_E,            /* Wait till reading of unknown block header is finished. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   565      FEE_LL_REORG_SEARCH_UNK_HDRBLK_READ_ERROR_E,    /* Failure during read of unknown block header. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   566      FEE_LL_REORG_SEARCH_UNK_HDRBLK_READ_FINISHED_E,    /* Unknown block header read successful. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   567   #endif /* End of (FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE != 0) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   568  #endif /* End of ((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE)) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   569  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   570      /* Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   571      #if (defined(RBA_FLSIFX_FLASH) || defined(RBA_FLSJDP_FLASH))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   572      FEE_LL_REORG_WAIT_FOR_FLS_E,            /* Wait for the Fls to overstamp an invalid header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   573      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   574      /* END Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   575  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   576      FEE_LL_REORG_FINISHED_E                 /* Function finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   577  }Fee_LLSecReorgType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   578  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   579  /* States for the function Fee_LLRedundantCpyChk */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   580  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   581  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   582      FEE_LL_REDUNDANT_CPY_CHK_INIT_E,            /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   583      FEE_LL_REDUNDANT_CPY_CHK_SEARCH_HDR_E,      /* Search header of redundant copy */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   584      FEE_LL_REDUNDANT_CPY_CHK_BLK_CS_E           /* Validate data CRC of redundant copy */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   585  }Fee_LLRedundantCpyChk_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   586  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   587  /* States for the function Fee_LLCpyBlkFromFls2Fls */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   588  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   589  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   590      FEE_LL_CPY_FLS2FLS_INIT_E,                      /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   591  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   592      #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   593      FEE_LL_CPY_FLS2FLS_WRITE_NOFB_MARKER_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   594      FEE_LL_CPY_FLS2FLS_WAIT_WRITE_NOFB_MARKER_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   595      FEE_LL_CPY_FLS2FLS_WRITE_NOFB_MARKER_ERROR_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   596      FEE_LL_CPY_FLS2FLS_WAIT_FILL_SECTOR_END_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   597      FEE_LL_CPY_FLS2FLS_FILL_SECTOR_END_ERROR_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   598      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   599  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   600      FEE_LL_CPY_FLS2FLS_READ_E,                      /* Read out the complete block (header and data) and finish the function if possible */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   601      FEE_LL_CPY_FLS2FLS_WAIT_READ_E,                 /* Wait for the read order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   602      FEE_LL_CPY_FLS2FLS_READ_ERROR_E,                /* Read error state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   603  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   604      /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   605      #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   606      FEE_LL_CPY_FLS2FLS_HDRPG1_WRITE_E,              /* Write the header page 1 into the new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   607      FEE_LL_CPY_FLS2FLS_WAIT_HDRPG1_WRITE_E,         /* Wait for the header page 1 write order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   608      FEE_LL_CPY_FLS2FLS_HDRPG1_WRITE_ERROR_E,        /* Write error state for header page 1 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   609      FEE_LL_CPY_FLS2FLS_HDRPG1_VERIFY_E,             /* Compare the header page 1 write */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   610      FEE_LL_CPY_FLS2FLS_WAIT_HDRPG1_VERIFY_E,        /* Wait for the header page 1 verification to finish */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   611      FEE_LL_CPY_FLS2FLS_HDRPG1_VERIFY_ERROR_E,       /* Verification error for header page 1 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   612      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   613  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   614      FEE_LL_CPY_FLS2FLS_WRITE_E,                     /* Write the data into the new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   615      FEE_LL_CPY_FLS2FLS_WAIT_WRITE_E,                /* Wait for the write order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   616      FEE_LL_CPY_FLS2FLS_WRITE_ERROR_E,               /* Write error state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   617      FEE_LL_CPY_FLS2FLS_VERIFY_E,                    /* Compare the programmed data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   618      FEE_LL_CPY_FLS2FLS_WAIT_VERIFY_E,               /* Wait for the verification to finish */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   619      FEE_LL_CPY_FLS2FLS_VERIFY_ERROR_E,              /* Verification error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   620  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   621      /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   622      #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   623      FEE_LL_CPY_FLS2FLS_HDRPG2_WRITE_E,              /* Write the header page 2 into the new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   624      FEE_LL_CPY_FLS2FLS_WAIT_HDRPG2_WRITE_E,         /* Wait for the header page 2 write order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   625      FEE_LL_CPY_FLS2FLS_HDRPG2_WRITE_ERROR_E,        /* Write error state for header page 2 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   626      FEE_LL_CPY_FLS2FLS_HDRPG2_VERIFY_E,             /* Compare the header page 2 write */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   627      FEE_LL_CPY_FLS2FLS_WAIT_HDRPG2_VERIFY_E,        /* Wait for the header page 2 verification to finish */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   628      FEE_LL_CPY_FLS2FLS_HDRPG2_VERIFY_ERROR_E,       /* Verification error for header page 2 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   629      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   630  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   631      FEE_LL_CPY_FLS2FLS_CHECK_ADR_OVERFLOW_E,        /* Data transfer is finished, check a possible address overflow */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   632      FEE_LL_CPY_FLS2FLS_WRITE_FULL_MARKER_E,         /* Write the FULL marker to the "old" sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   633      FEE_LL_CPY_FLS2FLS_ERASE_SECTOR_E,              /* Erase the sector that will be used as a new USED sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   634      FEE_LL_CPY_FLS2FLS_WRITE_USED_MARKER_E,         /* Write the USED marker to new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   635  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   636      #if(FEE_ROBUST_PROG_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   637      FEE_LL_CPY_FLS2FLS_ROBUST_IFX_HANDLING_E,       /* robust Ifx handling in case of wordline fails */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   638      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   639  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   640      #if defined (FEE_PRV_ROBUST_SECT_OVERFLOW)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   641      FEE_LL_CPY_FLS2FLS_ROBUST_SECT_OVERFLOW_E,      /* Robust sector reorganisation when sector overflow occurs during sector reorg. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   642      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   643  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   644      FEE_LL_CPY_FLS2FLS_WRITE_START_MARKER_E         /* Write the START marker to the new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   645  }Fee_LLCpyBlkFls2Fls_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   646  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   647  /* States for the function Fee_LlRobustSectorOverflow */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   648  #if defined (FEE_PRV_ROBUST_SECT_OVERFLOW)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   649  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   650  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   651      FEE_LL_ROBUST_SECTOR_OVERFLOW_INIT_E,           /* Init state. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   652      FEE_LL_ROBUST_SECTOR_OVERFLOW_WR_CM_E,          /* Write Clone marker in the latest sector. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   653      FEE_LL_ROBUST_SECTOR_OVERFLOW_PREPARE_E,        /* Compute the address and number of bytes for the operation. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   654  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   655      #if ( defined(RBA_FLSRH850P1xC_FLASH) || defined(RBA_FLSV850R1x_FLASH) || defined(RBA_FLSRH850xx_FLASH) )
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   656      FEE_LL_ROBUST_SECTOR_OVERFLOW_BLANK_CHK_E,      /* Check if the page is blank, transfer only programmed pages. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   657      FEE_LL_ROBUST_SECTOR_OVERFLOW_BLANK_CHK_WAIT_E, /* Wait for Blank check operation to complete. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   658      #endif /* #if ( defined(RBA_FLSRH850P1xC_FLASH) || defined(RBA_FLSV850R1x_FLASH) || defined(RBA_FLSRH850xx_FLASH) ) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   659  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   660      FEE_LL_ROBUST_SECTOR_OVERFLOW_READ_PAGE_E,      /* Read out the programmed page in an internal buffer. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   661      FEE_LL_ROBUST_SECTOR_OVERFLOW_READ_PAGE_WAIT_E, /* Wait for Read operation to complete. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   662      FEE_LL_ROBUST_SECTOR_OVERFLOW_COPY_DATA_E,      /* Copy data to new sector. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   663      FEE_LL_ROBUST_SECTOR_OVERFLOW_COPY_DATA_WAIT_E, /* Wait for Write operation to complete. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   664      FEE_LL_ROBUST_SECTOR_OVERFLOW_VERIFY_DATA_E,    /* Verify the copied data. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   665      FEE_LL_ROBUST_SECTOR_OVERFLOW_VERIFY_DATA_WAIT_E,/* Wait for Verify operation to complete. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   666      FEE_LL_ROBUST_SECTOR_OVERFLOW_VERIFY_SUCCESS_E, /* Check if more bytes are left to be programmed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   667      FEE_LL_ROBUST_SECTOR_OVERFLOW_WR_UM_E,          /* Write Used marker in the latest sector. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   668      FEE_LL_ROBUST_SECTOR_OVERFLOW_SORT_SECT_E,      /* Sort sectors */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   669      FEE_LL_ROBUST_SECTOR_OVERFLOW_ERROR_E,          /* Error state for all kinds of error in this state machine. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   670      FEE_LL_ROBUST_SECTOR_OVERFLOW_ERASE_E           /* Re-erase the older sector, this state is reached for error handling. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   671  }Fee_LLRobustSectOverflow_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   672  #endif /* #if defined (FEE_PRV_ROBUST_SECT_OVERFLOW) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   673  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   674  /* Read / write order type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   675  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   676  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   677      uint32                              xRdAddress;                     /* Address for reading (Fee_LLReadBlock) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   678      uint32                              xWrAddress;                     /* Address for writing (Fee_LLWriteBlock) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   679      uint32                              xCmpAddress;                    /* Address for comparing (Fee_LLCompBlkInFlash) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   680      uint32                              xCrcAddress;                    /* Address for the CRC (Fee_LLCompBlkInFlash) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   681      uint32                              xCpyAddress;                    /* Address for copying (Fee_LLCompBlkInFlash) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   682      uint32                              AdrHdSearchStart_u32;           /* Start address for the header search after reloads */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   683      uint32                              xStartAddrNextSector_u32;        /* Payload of START-Marker, contains the expected address of the 1. blockheader */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   684  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   685  /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   686  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   687      uint32                              xHdPg2Address;                   /* Address for writing the header 2nd page. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   688  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   689  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   690  #if !( defined(RBA_FLSRH850P1xC_FLASH) || defined(RBA_FLSV850R1x_FLASH) || defined(RBA_FLSRH850xx_FLASH) )
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   691      uint32                              LastProgrammedAddress_u32;        /* Last programmed page during cache build up. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   692      uint32                              LastValidHdrAddress_u32;          /* Last valid header found during cache build up. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   693  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   694  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   695      Fee_LLSecReorgType_ten              Fee_LLSecReorg_en;                /* State machine for the sector reorganization */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   696      Fee_LLRedundantCpyChk_ten           Fee_LLRedundantCpyChk_en;         /* State machine for checking redundant copy */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   697      Fee_LLCpyBlkFls2Fls_ten             Fee_LLCpyBlkFls2Fls_en;           /* State machine for copying one block from one sector to another one */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   698  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   699  #if defined (FEE_PRV_ROBUST_SECT_OVERFLOW)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   700      Fee_LLRobustSectOverflow_ten        Fee_LLRobustSectOverflow_en;      /* LL state machine for Robust sector overflow */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   701  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   702  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   703      Fee_HLRdWrBlockType_ten             Fee_HLWrBlock_en;                  /* HL state machine for writing a block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   704  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   705  #if(FEE_RB_MAINTAIN != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   706      Fee_HLRdWrBlockType_ten             Fee_HLMtBlock_en;                  /* HL state machine for maintaining a block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   707   #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   708  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   709      Fee_LLWrBlockType_ten               Fee_LLWrBlock_en;                  /* LL State machine for writing a block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   710      Fee_HLRdWrBlockType_ten             Fee_HLRdBlock;                     /* state machine for reading a block High Level */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   711      Fee_LLWrBlockType_ten               Fee_LLNextUsedWrBlock_en;          /* LL state for saving the next write state if a USED marker is necessary in between */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   712      Fee_LLWrBlockType_ten               Fee_LLNextEraseWrBlock_en;         /* LL state for saving the next write state if an erase operation is necessary in between */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   713      Fee_LLCmpBlkType_ten                Fee_LLCompBlk;                     /* LL state machine for comparing data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   714      Fee_LLCpyBlkType_ten                Fee_LLCopyBlk_en;                  /* LL state machine for copying data from the flash to the user buffer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   715      Fee_LLCalcCrcBlkType_ten            Fee_LLCalcCrcBlk_en;               /* LL state machine for calculating the checksum of a block inside the flash */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   716      Fee_LLWrMarkerType_ten              Fee_LLWrMarker_en;                 /* LL state machine for writing a sector marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   717      Fee_LLRdStateType_ten               Fee_LLRdState_en;                  /* LL state machine to read a specified address in the sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   718      Fee_LLBlankCheckType_ten            Fee_LLBlankCheckState_en;          /* LL State machine to perform a blank check */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   719      Fee_LLFndEmptyPgeType_ten           Fee_LLFindEmptyPageState_en;       /* LL state machine to find an empty page within one sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   720      Fee_LLSearchBlkHdrType_ten          Fee_LLSearchBlkHdr_en;             /* LL state machine to find a specified block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   721  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   722  #if((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   723   #if(FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE == 0) /* Unknown block sector reorganiation without cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   724      Fee_LLSearchUnknBlkHdrType_ten      Fee_LLSearchUnknBlkHdr_en;          /* LL state machine to find an unknown block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   725   #else /* Unknown blcok sector reorganiation with cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   726      uint32                              Fee_UnknownBlkCacheAdd_u32;         /* Address till where the cache for unknown block is scanned */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   727      uint16                              Fee_UnknownBlkCacheIdx_u16;         /* Index till which the cache for unknown block is built */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   728      Fee_LLBuildUpUnknownBlkCache_ten    Fee_LLBuildUpCacheUnknownBlk_en;    /* LL state machine to build up the cache for unknown blocks */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   729   #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   730  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   731  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   732  #if(FEE_FAST_CACHE_INIT_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   733      Fee_LLBuildUpCache_ten              Fee_LLBuildUpCache_en;              /* LL state machine to build up the cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   734      Fee_LLBuildUpCacheAllSect_ten       Fee_LLBuildUpCacheAllSect_en;       /* LL state machine to build up the cache for all sectors */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   735  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   736  } Fee_RdWrOrder_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   737  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   738  /* Block header info type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   739  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   740  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   741      uint32 AdrBlkHeader_u32;    /* Read address for for the function Fee_LLReadBlock and Fee_LLCpyBlkFromFls2Fls */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   742      uint32 BlkCrc32_u32;        /* Block data checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   743      uint16 HdrCrc16_u16;        /* Block header checksum (start value for block data checksum) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   744      uint16 BlkLength_u16;       /* Extracted block length from the block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   745      uint16 FeeIndex_u16;        /* Fee Index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   746      uint8  BlkStatus_u8;        /* Block status */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   747  }Fee_GlobInfoLastRdHeader_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   748  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   749  /* Block write type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   750  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   751  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   752      uint16  BytesAlrdyConsid_u16;   /* Write offset in user data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   753      uint16  BytesAlrdyCompared_u16;    /* Number of bytes already compared */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   754      uint16  Bytes2Read_u16;          /* Number of bytes to read */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   755      uint8   CompareResult_u8;       /* Result of last Fls_Compare */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   756      uint8   cntWriteRetry_u8;       /* Count number of write retries */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   757      uint8   cntCopies_u8;           /* Count number of written copies */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   758  }Fee_GlobInfoWrBlock_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   759  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   760  /* Sector reorganization type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   761  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   762  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   763      uint32 xRdAddress_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   764      uint16 xNumBytesAlrdyCopied_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   765      uint16 xNumBytesLeftToRdWr_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   766      uint8  xCntCopies_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   767  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)    /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   768      uint8  xFirstDataPgPgm_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   769  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   770  }Fee_LLSecReorgStruct_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   771  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   772  /* Erase sector types */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   773  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   774  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   775      FEE_ERASESEC_IDLE_E = 0,        /* Idle state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   776      FEE_ERASESEC_CHECK_CACHE_E,     /* Check of cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   777      FEE_ERASESEC_START_E,           /* Erase sequence started */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   778      FEE_ERASESEC_DO_E,              /* Wait until erasing was finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   779      FEE_ERASESEC_WRITE_MARKER_E,    /* Write the sector ERASED marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   780      FEE_ERASESEC_ERROR_E            /* Error state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   781  }Fee_LLEraseStateType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   782  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   783  /* Erase Order type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   784  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   785  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   786      Fee_LLEraseStateType_ten EraseState_en; /* State machine state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   787      uint8   xPhySectorIdx_u8;               /* Idx of sector that should get erased  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   788  }Fee_LLEraseOrderType_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   789  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   790  /* Block header structure */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   791  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   792  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   793      uint8   Preamble_au8[3];    /* Preambel (0xA53C96) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   794      uint8   BlkStatus_u8;       /* Block status, contains information like security level, etc. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   795      uint16  FeeIndex_u16;       /* FeeIndex */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   796      uint16  BlkLength_u16;      /* Block length without header and block checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   797      uint16  HdrCrc16_u16;       /* Header checksum, start value is 0xCAFE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   798      uint32  BlkCrc32_u32;       /* Block data checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   799  }Fee_BlkHeader_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   800  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   801  /* Linked function structure */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   802  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   803  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   804      void(* Fee_ResetUsedSectors_pfn)(void);     /* Function for resetting the amount of used sectors */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   805  }Fee_LinkedFunctions_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   806  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   807  #if (FEE_PRV_DEBUG_MONITOR != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   808  #define FEE_DBM_ERROR_ENTRIES   15
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   809  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   810  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   811  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   812      FEE_DBM_ERROR_ERASE_FCT_E,        /* Used in function Fee_LLEraseSector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   813      FEE_DBM_ERROR_LLMARKER_FCT_E,     /* USed in function Fee_LLWriteMarker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   814      FEE_DBM_ERROR_XX_E                /* not used yet....                   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   815  } Fee_DebugMonitoringFct_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   816  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   817  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   818  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   819      uint32                       xSecChngCntVal;             /* value of sector change counter while error occurs */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   820      uint16                       FeeBlkIdx;                  /* if the error couldn't be assigned to a NvmBlock, this is 0xFFFF */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   821      Fee_DebugMonitoringFct_ten   xError;                     /* error number */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   822      uint8                        xErrorInfo;                 /* error info, if necessary */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   823  } FeeDBMErrInfo_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   824  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   825  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   826  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   827      FeeDBMErrInfo_tst  xErrorEntry[FEE_DBM_ERROR_ENTRIES];  /* array of a structure with detail info to the errors */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   828      uint8   idxNewEntry;                /* index points on the next free entry in the xErrorEntry buffer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   829      uint8   ctBuffOverflow;             /* counter countrs how often the FEE_DBM_ERROR_ENTRIES error overflow. Startvalue is 1, used for ProtRAM validation! */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   830  } Fee_DebugMonitoring_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   831  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   832  #define FEE_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   833  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   834  extern Fee_DebugMonitoring_tst Fee_DebugMonitoring;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   835  #define FEE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   836  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   837  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   838  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   839  #if(FEE_ROBUST_PROG_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   840  /* Ifx robust programming */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   841  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   842  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   843      FEE_ROB_IFX_INIT,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   844      FEE_ROB_IFX_MARK_SECTOR,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   845      FEE_ROB_IFX_STORE_BUFFER,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   846      FEE_ROB_IFX_STORE_BUFFER_WAIT,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   847      FEE_ROB_IFX_COPY_DATA,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   848      FEE_ROB_IFX_STORE_COPY_WAIT,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   849      FEE_ROB_IFX_ERASE_SECTOR,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   850      FEE_ROB_IFX_WRITE_USED_MARK_SECTOR,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   851      FEE_ROB_SORT_SECTOR,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   852      FEE_ROB_IFX_FINISHED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   853  }Fee_RobIfxHdl_e;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   854  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   855  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   856  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   857      Fls_AddressType xStartAddress;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   858      uint8* DataBuffer;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   859      Fls_LengthType numBytes;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   860      uint16 offInBuf_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   861  }Fee_IfxRobustProgramming_t;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   862  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   863  #define FEE_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   864  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   865  extern Fee_IfxRobustProgramming_t Fee_IfxRobustProgramming_s;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   866  extern Fee_RobIfxHdl_e Fee_RobIfxHdl;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   867  #define FEE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   868  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   869  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   870  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   871  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   872  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_RobIfxHandling(uint8 xActLogWrSect_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   873  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   874  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   875  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   876  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   877  #if ((FEE_RB_MAINTAIN != FALSE) && (FEE_NO_FALLBACK_ACTIVE != FALSE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   878  /* Additional MainFunction write states in case NoFallback is activated */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   879  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   880  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   881      FEE_WRITE_NOFB_IDLE_E = 0,      /* Idle state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   882      FEE_WRITE_NOFB_MAINTAIN_E,      /* Maintain a NoFallback block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   883      FEE_WRITE_NOFB_BLOCK_E          /* Write a NoFallback block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   884  }Fee_WriteStateNoFb_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   885  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   886  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   887  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   888  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   889      uint32 Fee_Totalfree_bytes;    /* Total number of free bytes  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   890      uint32 Fee_hardThreshold;      /* Hard Threshold configures */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   891      uint32 Fee_softThershold;      /* Soft therosold configured*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   892  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   893  }Fee_FreeByte_thrshold_t;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   894  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   895  /*
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   896  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   897  * Extern declarations
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   898  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   899  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   900  /* Structures and variables */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   901  #define FEE_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   902  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   903  extern CONST(Fee_FlashProp_tst, FEE_CONST)          Fee_FlashProp_st[FEE_NUM_FLASH_BANKS_AVAILABLE];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   904  extern CONST (MemIf_JobResultType, AUTOMATIC)       Fee_JobTypeMapping[FEE_NUM_RET_VAL_E];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   905  extern CONST (Fee_LinkedFunctions_tst, FEE_CONST)   Fee_LinkedFunctions_cst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   906  #define FEE_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   907  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   908  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   909  #define FEE_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   910  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   911  extern P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA)       Fee_PageBytePtr_cpu8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   912  extern VAR(Fee_RdWrOrder_tst, AUTOMATIC)            Fee_RdWrOrder_st;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   913  extern VAR(Fee_LLSectorOrder_tst, AUTOMATIC)        Fee_LLSectorOrder_st[FEE_NUM_FLASH_BANKS_AVAILABLE];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   914  extern VAR(Fee_LLEraseOrderType_tst, AUTOMATIC)     Fee_LLEraseOrder_st;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   915  extern VAR(Fee_OrderFifo_tst, AUTOMATIC)            Fee_OrderFifo_st[FEE_QUEUE_SIZE];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   916  extern VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC) Fee_GlobInfoLastRdHeader_st;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   917  extern VAR(Fee_GlobInfoWrBlock_tst, FEE_VAR)        Fee_GlobInfoWrBlock_st;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   918  extern VAR(Fee_LLSecReorgStruct_tst, FEE_VAR)       Fee_LLSecReorgStruct_st;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   919  extern VAR(MemIf_JobResultType, AUTOMATIC)          Fee_JobResult[FEE_QUEUE_SIZE];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   920  #define FEE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   921  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   922  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   923  #define FEE_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   924  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   925  extern CONSTP2VAR(uint8, AUTOMATIC, FEE_APPL_DATA)  Fee_MarkerBufBytePtr_cpu8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   926  extern CONSTP2VAR(uint8, AUTOMATIC, FEE_APPL_DATA)  Fee_DataBytePtr_cpu8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   927  #define FEE_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   928  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   929  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   930  #define FEE_START_SEC_VAR_INIT_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   931  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   932  extern VAR(uint8, FEE_VAR)                          Fee_Prv_stInit_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   933  extern VAR(uint8, FEE_VAR)                          Fee_Prv_stReorg_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   934  extern VAR(uint8, FEE_VAR)                          Fee_NumFlashBanksUsed_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   935  extern VAR(uint8, AUTOMATIC)                        Fee_idxActQueueBackUp;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   936  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   937  /* Buffer to hold 2nd header page contents. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   938  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)    /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   939  extern VAR(uint8, AUTOMATIC) Fee_hdr2Buffer_au8[FEE_PAGE_LEN];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   940  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   941  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   942  /* Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   943  #if (defined(RBA_FLSIFX_FLASH) || defined(RBA_FLSJDP_FLASH))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   944  extern VAR(uint8, AUTOMATIC)                        Fee_hdrBuffer_au8[FEE_PAGE_LEN];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   945  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   946  /* END Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   947  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   948  #define FEE_STOP_SEC_VAR_INIT_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   949  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   950  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   951  #define FEE_START_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   952  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   953  extern VAR(MemIf_StatusType, FEE_VAR)               Fee_GlobModuleState_st;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   954  extern VAR(Fee_Rb_WorkingStateType_ten, AUTOMATIC)  Fee_Rb_WorkingStateBackUp_en;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   955  #define FEE_STOP_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   956  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   957  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   958  #define FEE_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   959  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   960  extern VAR(uint8, AUTOMATIC)                        Fee_idxLLSectorOrder_au8[FEE_NUM_FLASH_BANKS_AVAILABLE];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   961  extern VAR(uint8, FEE_VAR)                          Fee_idxActQueue_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   962  extern VAR(uint8, FEE_CONST)                        Fee_CacheUpdCompForSect_au8[FEE_NUM_FLASH_BANKS_AVAILABLE];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   963  extern VAR(uint8, AUTOMATIC)                        Fee_RdWrRetries_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   964  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   965  #if (FEE_RB_ACT_ERASE_SUSPENSION != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   966  extern VAR(boolean, AUTOMATIC) Fee_Prv_stSuspendActiv_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   967  extern VAR(boolean, AUTOMATIC) Fee_Prv_stHardReOrgErase_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   968  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   969  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   970  #if (FEE_RB_ADDONS_CCAS == TRUE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   971  extern VAR(boolean, AUTOMATIC) Fee_Rb_stRequestStopMode_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   972  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   973  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   974  #define FEE_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   975  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   976  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   977  #define FEE_START_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   978  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   979  extern VAR(uint32, AUTOMATIC)                       Fee_llMarkerPageBuf_au32[FEE_SEC_HEADER_SIZE / 4u];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   980  extern VAR(uint32, FEE_CONST)                       Fee_Cache_au32[FEE_NUM_BLOCKS];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   981  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   982  #if(FEE_ROB_FEATURE_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   983  extern VAR(uint32, AUTOMATIC)                       Fee_DataByteStartCrc_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   984  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   985  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   986  #define FEE_STOP_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   987  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   988  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   989  #define FEE_START_SEC_VAR_CLEARED_SECURED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   990  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   991  extern VAR(uint32, AUTOMATIC)                       Fee_llPageBuf_au32[(FEE_LL_PAGEBUFFSIZE / 4u) + 2u];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   992  extern VAR(uint32, AUTOMATIC)                       Fee_llDataBuf_au32[FEE_LL_DATABUFFSIZE / 4u];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   993  #define FEE_STOP_SEC_VAR_CLEARED_SECURED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   994  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   995  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   996  #ifdef FEE_PRV_USE_ROM_TABLE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   997  #define FEE_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   998  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   999  extern CONST(Fee_BlockPropertiesType_tst, FEE_CONST)  Fee_BlockProperties_st[FEE_NUM_BLOCKS];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1000  #define FEE_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1001  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1002  #else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1003  #define FEE_START_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1004  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1005  extern VAR(Fee_BlockPropertiesType_tst, AUTOMATIC)  Fee_BlockProperties_st[FEE_NUM_BLOCKS];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1006  #define FEE_STOP_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1007  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1008  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1009  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1010  #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1011  #define FEE_START_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1012  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1013  extern Fee_WriteStateNoFb_ten Fee_WriteStateNoFb_en;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1014  #define FEE_STOP_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1015  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1016  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1017  #define FEE_START_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1018  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1019  extern VAR(uint32, AUTOMATIC)   Fee_Rb_NoFallback_RemAdr_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1020  #define FEE_STOP_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1021  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1022  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1023  #define FEE_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1024  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1025  extern VAR(boolean, AUTOMATIC)  Fee_Rb_NoFallback_LastBlockCfg_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1026  extern VAR(boolean, AUTOMATIC)  Fee_Rb_InvalidateOldCopy_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1027  extern VAR(boolean, AUTOMATIC)  Fee_Rb_MaintainRun_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1028  #define FEE_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1029  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1030  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1031  #define FEE_START_SEC_CONST_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1032  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1033  extern const uint8 Fee_NoFallbackMarkerPattern[FEE_PAGES_USED_BY_BLK_HEADER * FEE_PAGE_LEN];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1034  #define FEE_STOP_SEC_CONST_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1035  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1036  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1037  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1038  #if((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) && (FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE != 0))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1039  /* Unknown blcok sector reorganiation with cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1040  #define FEE_START_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1041  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1042  extern VAR(uint32, AUTOMATIC) Fee_UnknownBlkCache_Addr_au32[FEE_RB_ACT_UNKNOWN_BLK_CACHE_ARRAY_SIZE];   /* Address of unknown block. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1043  #define FEE_STOP_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1044  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1045  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1046  #define FEE_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1047  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1048  extern VAR(uint16, AUTOMATIC) Fee_UnknownBlkCache_FeeIndex_u16[FEE_RB_ACT_UNKNOWN_BLK_CACHE_ARRAY_SIZE]; /* Index of unknown block. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1049  #define FEE_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1050  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1051  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1052  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1053  /* Lower Layer functions of the Fee */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1054  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1055  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1056  extern FUNC(uint32, FEE_CODE) Fee_CalculateNumOfFreeBytesInCurSector(VAR(uint32, FEE_VAR) DataEndAdr_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1057  extern FUNC(void, FEE_CODE)   Fee_InitVarAndState(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1058  extern FUNC(void, FEE_CODE)   Fee_InitCache(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1059  extern FUNC(void, FEE_CODE)   Fee_InitOrderFifoBuffer(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1060  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1061  /* Active sector detection */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1062  extern FUNC(void ,FEE_CODE)   Fee_LLSearchSectors(P2VAR(Fee_stSecDet_tst, AUTOMATIC, FEE_APPL_DATA) Fee_stSecDet_ps);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1063  extern FUNC(uint8, FEE_CODE)  Fee_LLDetectActiveSector(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1064  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLFindEmptyPage(uint8 PhySectIdxUsedSect_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1065  extern FUNC(uint8, FEE_CODE)  Fee_GetMostCurrentSectorIdx(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1066  extern FUNC(void, FEE_CODE)   Fee_CheckErasedSectorEmpty(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1067  extern FUNC(uint8, FEE_CODE)  Fee_GetPhysSectorByAddress(VAR(uint32, AUTOMATIC) Address_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1068  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1069  /* Marker handling */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1070  extern FUNC(Fee_stRetVal_ten,FEE_CODE)  Fee_LLWriteMarker(VAR(uint8, AUTOMATIC) PhySectIdx_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1071                                                            VAR(uint8, AUTOMATIC) MarkerID_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1072  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1073  /* Erase functions */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1074  extern FUNC(Fee_stRetVal_ten,FEE_CODE)  Fee_LLEraseSector(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1075  extern FUNC(void,FEE_CODE)              Fee_LLSetEraseSector(VAR(uint8, AUTOMATIC) EraseLogIdx);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1076  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1077  /* Block header access */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1078  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLSearchNextBlkHeader(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Fee_GlobInfoLastRdHeader_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1079                                                                    VAR(uint8, AUTOMATIC) CachedAccess_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1080                                                                    VAR(uint8, AUTOMATIC) FastCacheUpdate_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1081                                                                    VAR(boolean, AUTOMATIC) xForcePageBufReload_b,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1082                                                                    VAR(uint32, AUTOMATIC) strAddrHdrSearch);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1083  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1084  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLSearchSpecifiedBlkHeader(VAR(uint16, AUTOMATIC) FeeIdx_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1085                                                                         P2VAR(uint32, AUTOMATIC, FEE_APPL_DATA) LastHdrAddr_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1086                                                                         P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) GlobBlkHdr_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1087                                                                         VAR(boolean, AUTOMATIC) SearchRetry_b);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1088  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1089  #if((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1090  /* Unknown blcok sector reorganiation without cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1091  #if(FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE == 0)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1092  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLSearchUnknownBlkHeader(P2VAR(uint32, AUTOMATIC, FEE_APPL_DATA) StartHdrAddr_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1093                                                                       P2VAR(uint32, AUTOMATIC, FEE_APPL_DATA) LastHdrAddr_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1094                                                                       P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) GlobBlkHdr_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1095                                                                       P2VAR(boolean, AUTOMATIC, FEE_APPL_DATA) SearchRetry_ptr);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1096  #else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1097  /* Unknown blcok sector reorganiation with cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1098  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_BuildUpCacheUnknownBlk(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1099  #endif /* (FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE == 0) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1100  #endif /* ((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE)) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1101  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1102  extern FUNC(uint32, FEE_CODE) Fee_LLGetSecStartAddress(VAR(uint8, AUTOMATIC) xPhySectorIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1103  extern FUNC(uint32, FEE_CODE) Fee_LLGetSecEndAddress(VAR(uint8, AUTOMATIC) xPhySectorIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1104  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1105  /* Verification and handling of blocks */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1106  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLCompBlkInFlash(P2CONST(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) HeaderInfo_pcst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1107                                                               P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) Data_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1108  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLCalcBlkCrcInFlash(P2CONST(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) HeaderInfo_pcst);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1109  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLCpyBlkFromFls2Fls(P2CONST(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Fee_GlobInfoLastRdHeader_pcst, boolean Fee_WriteTwice_b);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1110  #if defined (FEE_PRV_ROBUST_SECT_OVERFLOW)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1111  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LlRobustSectorOverflow(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1112  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1113  extern FUNC(void, FEE_CODE)             Fee_LLPrepMarkerBufWithMarkerData(P2CONST(Fee_MarkerProp_t, AUTOMATIC, FEE_APPL_DATA) Marker_pcst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1114                                                                            P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) MarkerBuf_pu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1115  extern FUNC(void, FEE_CODE)             Fee_LLCopyPageBuff2Marker(P2VAR(Fee_MarkerProp_t, AUTOMATIC, FEE_APPL_DATA) Marker_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1116                                                                    P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1117  extern FUNC(void, FEE_CODE)             Fee_LLPrepPageBufWithHdrDataStart(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) HeaderInfo_pst);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1118  extern FUNC(void, FEE_CODE)             Fee_LLPrepPageBufWithHdrDataEnd(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) HeaderInfo_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1119                                                                                 P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) Data_pcu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1120                                                                                 VAR(uint32, AUTOMATIC) BlkCrc32_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1121  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1122  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1123  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1124  LOCAL_INLINE FUNC(void, FEE_CODE)       Fee_LLCopyPageBuff2HeaderStart(P2VAR(Fee_BlkHeader_tst, AUTOMATIC, FEE_APPL_DATA) BlkHdr_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1125                                                                         P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1126  #if(FEE_FAST_CACHE_INIT_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1127  LOCAL_INLINE FUNC(void, FEE_CODE)       Fee_LLCopyPageBuff2HeaderIdxAndCrc(P2VAR(Fee_BlkHeader_tst, AUTOMATIC, FEE_APPL_DATA) BlkHdr_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1128                                                                             P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1129  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1130  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1131  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1132  #if !( defined(RBA_FLSRH850P1xC_FLASH) || defined(RBA_FLSV850R1x_FLASH) || defined(RBA_FLSRH850xx_FLASH) )
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1133  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_SearchLastBlkHeader(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Fee_GlobInfoLastRdHeader_ptr);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1134  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1135  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1136  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1137  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1138  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1139  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1140  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1141  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1142  extern FUNC(uint32, FEE_CODE)           Fee_SearchHighestCacheEntry(VAR(uint32,FEE_VAR) UpperBoundary_u32, VAR(uint8, FEE_VAR) SectIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1143  extern FUNC(void, FEE_CODE)             Fee_InvalidateCacheByAddress(VAR(uint32,FEE_VAR) xAddress_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1144  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1145  extern FUNC(void, FEE_CODE)             Fee_LLCopyPageBuff2HeaderMid(P2VAR(Fee_BlkHeader_tst, AUTOMATIC, FEE_APPL_DATA) BlkHdr_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1146                                                                       P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1147  extern FUNC(void, FEE_CODE)             Fee_LLCopyPageBuff2HeaderEnd(P2VAR(Fee_BlkHeader_tst, AUTOMATIC, FEE_APPL_DATA) BlkHdr_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1148                                                                       P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1149  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLCopyData2Buffer(P2CONST(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Fee_GlobInfoLastRdHeader_pcst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1150                                                                    P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) DataPtr_pu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1151                                                                    VAR(uint16, FEE_VAR) DataOffset_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1152                                                                    VAR(uint16, FEE_VAR) DataLength_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1153  extern FUNC(void, FEE_CODE)             Fee_IncAddressInsideSector(P2VAR(uint32, AUTOMATIC, FEE_APPL_DATA) Address_u32,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1154                                                                     VAR(uint16, FEE_VAR) numBytes_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1155                                                                     VAR(boolean, FEE_VAR) EnsurePageAlign_b);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1156  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1157  /* Sector reorganization */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1158  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLCheckReorganizationNeed(VAR(uint32, AUTOMATIC) Threshold_u32,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1159                                                                        VAR(uint16, AUTOMATIC) DataLength_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1160  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLSectorReorganization(P2VAR(boolean, AUTOMATIC, FEE_APPL_DATA) SectReorgInterSt_pb);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1161  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1162  /* Block writes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1163  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_HLWriteBlock(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1164  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLWriteBlock(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Info_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1165                                                           P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) Data_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1166  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1167  /* Block reading */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1168  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_HLReadBlock(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1169  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLReadBlock(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Info_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1170                                                          P2VAR(uint8,AUTOMATIC, FEE_APPL_DATA) Data_ptr);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1171   #if(FEE_RB_MAINTAIN != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1172      /* Block maintaining*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1173      extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_HLMaintainBlock(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1174   #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1175  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1176  /* Order handling */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1177  extern FUNC(Std_ReturnType, FEE_CODE)   Fee_HLPlaceOrder(VAR(uint16, AUTOMATIC) Blocknumber_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1178                                                           VAR(uint16, AUTOMATIC) Offset_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1179                                                           P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) DataBufferPtr_pu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1180                                                           VAR(uint16, AUTOMATIC) Length_16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1181                                                           VAR(Fee_HlMode_ten, AUTOMATIC) Mode_en);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1182  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1183  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1184  /* Cache handling */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1185  extern FUNC(uint32, FEE_CODE) Fee_LLGetAddressFromCache(VAR(uint16, AUTOMATIC) FeeIdx_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1186  extern FUNC(boolean, FEE_CODE) Fee_LLCheckAddressInCache(VAR(uint32, AUTOMATIC) AdrInSector_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1187  extern FUNC(void, FEE_CODE)   Fee_LLUpdateAddressInCache(VAR(uint16, AUTOMATIC) FeeIdx_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1188                                                           VAR(uint32, AUTOMATIC) Addr_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1189  extern FUNC(void, FEE_CODE)  Fee_LLUpdateCacheStForSect(VAR(uint8, AUTOMATIC) PhySecIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1190  extern FUNC(void, FEE_CODE)  Fee_LLEraseCacheStForSect(VAR(uint8, AUTOMATIC) PhySecIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1191  extern FUNC(uint8, FEE_CODE) Fee_LLGetCacheUpdateStForSect(VAR(uint8, AUTOMATIC) PhySecIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1192  extern FUNC(uint8, FEE_CODE) Fee_LLGetCacheUpdateStForAllSect(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1193  extern FUNC(boolean, FEE_CODE) Fee_SrvBinarySearchInBlockProp(VAR(uint16, AUTOMATIC) FeeIdx_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1194                                                                P2VAR(uint16, AUTOMATIC, FEE_APPL_DATA) CacheIdx_pu16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1195  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1196  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1197  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1198  #if(FEE_FAST_CACHE_INIT_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1199  LOCAL_INLINE FUNC(boolean, FEE_CODE) Fee_SrvBinarySearchInBlockPropFast(VAR(uint16, AUTOMATIC) FeeIdx_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1200                                                                          P2VAR(uint16, AUTOMATIC, FEE_APPL_DATA) CacheIdx_pu16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1201  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1202  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1203  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1204  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_BuildUpCache(VAR(uint32, AUTOMATIC) StartAdr_u32,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1205                                                           VAR(uint32, AUTOMATIC) EndAdr_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1206  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_BuildUpCacheForAllSect(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1207  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1208  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1209  /* FEE_FAST_CACHE_INIT_ACTIVE != FALSE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1210  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1211  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1212  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1213  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1214  /* Services */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1215  extern FUNC(void, FEE_CODE)  Fee_SrvMemSet8(P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) xDest_pu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1216                                              VAR(uint32, FEE_VAR) xPattern_u32,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1217                                              VAR(uint32, FEE_VAR) numBytes_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1218  extern FUNC(void, FEE_CODE)  Fee_SrvMemCopy8(P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) xDest_pu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1219                                               P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) xSrc_pcu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1220                                               VAR(uint32, FEE_VAR) numBytes_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1221  extern FUNC(void, FEE_CODE)  Fee_SrvSetFifoMode(VAR(Fee_HlMode_ten, AUTOMATIC) Mode_en,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1222                                                  VAR(uint16, AUTOMATIC) xJobType_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1223  extern FUNC(Fee_HlMode_ten, FEE_CODE) Fee_SrvGetFifoMode(VAR(uint16, AUTOMATIC) xJobType_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1224  extern FUNC(void, FEE_CODE)           Fee_LoadNextOrder(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1225  extern FUNC(uint8, FEE_CODE)          Fee_SearchNextOrder(boolean isIntOrder_b);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1226  extern FUNC(void, FEE_CODE)           Fee_UpdateStatus(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1227  extern FUNC(void, FEE_CODE)           Fee_TriggerHardSectorReorg(VAR(Fee_Rb_WorkingStateType_ten, FEE_VAR) WorkingState_en);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1228  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1229  extern FUNC(Std_ReturnType, FEE_CODE) Fee_CheckBlockCfg(VAR(uint8, AUTOMATIC)  ApiId_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1230                                                             VAR(uint16, AUTOMATIC) BlockNum_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1231  extern FUNC(Std_ReturnType, FEE_CODE) Fee_CheckModuleSt(VAR(uint8, AUTOMATIC)  ApiId_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1232  extern FUNC(Std_ReturnType, FEE_CODE) Fee_CheckAdrPtr(VAR(uint8, AUTOMATIC) ApiId_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1233                                                        P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) DataBufferPtr_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1234  extern FUNC(Std_ReturnType, FEE_CODE) Fee_CheckBlkOfs(VAR(uint8, AUTOMATIC) ApiId_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1235                                                        VAR(uint16, AUTOMATIC) BlockNum_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1236                                                        VAR(uint16, AUTOMATIC) BlockOfs_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1237  extern FUNC(Std_ReturnType, FEE_CODE) Fee_CheckBlkLen(VAR(uint8, AUTOMATIC) ApiId_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1238                                                        VAR(uint16, AUTOMATIC) BlockNum_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1239                                                        VAR(uint16, AUTOMATIC) BlockOfs_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1240                                                        VAR(uint16, AUTOMATIC) BlockLen_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1241  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1242  /* Miscellaneous */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1243  extern FUNC(void, FEE_CODE)   Fee_CheckFlsJobResult(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1244  extern void (* Fee_Prv_ResetUsedSectors_pfn)(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1245  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1246  #if (FEE_PRV_DEBUG_MONITOR != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1247  extern FUNC(void ,FEE_CODE) Fee_DBM_RepError(VAR(uint16,FEE_VAR) FeeBlkIdx, VAR(Fee_DebugMonitoringFct_ten,FEE_VAR) xError, VAR(uint8,FEE_VAR) xErrorInfo);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1248  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1249  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1250  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1251  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1252  /*
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1253  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1254  * Inline functions (Necessary for fastening up the start up time)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1255  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1256  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1257  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1258   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1259   * Fee_LLCopyPageBuff2HeaderStart(): Extract the start of the block header data
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1260   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1261   * This function extracts the preamble of the block header data out
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1262   * of the page buffer (called every 8th byte of the flash).
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1263   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1264   * Hint: Block header structure:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1265   *       {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1266   *          uint8   Preamble_au8[3];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1267   *          uint8   BlkStatus_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1268   *          uint16  FeeIndex_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1269   *          uint16  BlkLength_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1270   *          uint16  HdrCrc16_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1271   *          uint32  BlkCrc32_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1272   *       }Fee_BlkHeader_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1273   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1274   * \param    BlkHdr_pst:    Pointer to the block header that was
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1275   *                          found in the flash.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1276   * \param    PageBuf_pu8:   Pointer to the page buffer
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1277   * \return
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1278   * \retval   none
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1279   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1280   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1281   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1282   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1283  LOCAL_INLINE FUNC(void, FEE_CODE) Fee_LLCopyPageBuff2HeaderStart(P2VAR(Fee_BlkHeader_tst, AUTOMATIC, FEE_APPL_DATA) BlkHdr_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1284                                                                   P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1285  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1286      BlkHdr_pst->Preamble_au8[0] = PageBuf_pcu8[0];      /* 0xA53C96 <- [0]: A5, [1]: 3C, [2]: 96 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1287      BlkHdr_pst->Preamble_au8[1] = PageBuf_pcu8[1];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1288      BlkHdr_pst->Preamble_au8[2] = PageBuf_pcu8[2];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1289  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1290  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1291  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1292  #if(FEE_FAST_CACHE_INIT_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1293  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1294   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1295   * Fee_LLCopyPageBuff2HeaderIdxAndCrc(): Extract the header checksum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1296   *  and the block index out of the block header data
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1297   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1298   * This function extracts the block header data out of the page buffer.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1299   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1300   * Hint: Block header structure:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1301   *       {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1302   *          uint8   Preamble_au8[3];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1303   *          uint8   BlkStatus_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1304   *          uint16  FeeIndex_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1305   *          uint16  BlkLength_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1306   *          uint16  HdrCrc16_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1307   *          uint32  BlkCrc32_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1308   *       }Fee_BlkHeader_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1309   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1310   * \param    BlkHdr_pst:    Pointer to the block header that was
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1311   *                          found in the flash.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1312   * \param    PageBuf_pcu8:  Pointer to the page buffer
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1313   * \return
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1314   * \retval   none
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1315   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1316   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1317   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1318   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1319  LOCAL_INLINE FUNC(void, FEE_CODE) Fee_LLCopyPageBuff2HeaderIdxAndCrc(P2VAR(Fee_BlkHeader_tst, AUTOMATIC, FEE_APPL_DATA) BlkHdr_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1320                                                                       P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1321  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1322      /* 0xD2E9 <- [4]: D2, [5]: E9 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1323      BlkHdr_pst->FeeIndex_u16    = (uint16)((uint16)(((uint16)(PageBuf_pcu8[4])) << 8u)  | (uint16)(PageBuf_pcu8[5]));
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1324  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1325      /* 0xABCD <- [8]: AB, [9]: CD */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1326      BlkHdr_pst->HdrCrc16_u16    = (uint16)((uint16)(((uint16)(PageBuf_pcu8[8])) << 8u)  | (uint16)(PageBuf_pcu8[9]));
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1327  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1328  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1329  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1330  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1331   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1332   * Fee_SrvBinarySearchInBlockProp(): Get the respective index out of
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1333   *                                   the block properties table
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1334   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1335   * This function searches for the respective block properties table
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1336   * index. In case unknown blocks are searched, the function will
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1337   * return with a negative response.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1338   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1339   * \param    FeeIdx_u16:    Fee index (persistent ID)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1340   * \param    CacheIdx_pu16: Pointer for the result
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1341   * \return   Success of the function
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1342   * \retval   FALSE: Corresponding index was not found
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1343   * \retval   TRUE:  Corresponding index was found
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1344   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1345   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1346   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1347   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1348   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1349  LOCAL_INLINE FUNC(boolean, FEE_CODE) Fee_SrvBinarySearchInBlockPropFast(VAR(uint16, AUTOMATIC) FeeIdx_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1350                                                                          P2VAR(uint16, AUTOMATIC, FEE_APPL_DATA) CacheIdx_pu16)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1351  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1352      VAR(boolean, AUTOMATIC)  xFuncRet_b = FALSE;    /* Function return value */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1353      VAR(uint16, AUTOMATIC)  xMid_u16;               /* Mid index for the search */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1354      VAR(uint16, AUTOMATIC)  xLeft_u16 = 0;          /* Left index for the search */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1355      VAR(uint16, AUTOMATIC)  xRight_u16 = FEE_NUM_BLOCKS - 1u; /* Right index for the search */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1356  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1357      /* Loop until the value is found */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1358      do
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1359      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1360          /* Divide search area by two */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1361          xMid_u16 = (uint16)(xLeft_u16 + ((xRight_u16 - xLeft_u16) / 2));
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1362  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1363          /* Check the cache content */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1364          if(Fee_BlockProperties_st[xMid_u16].BlockPersistentId_u16 == FeeIdx_u16)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1365          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1366              /* Index was found, set return value */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1367              *CacheIdx_pu16 = xMid_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1368  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1369              /* Return positive response */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1370              xFuncRet_b = TRUE;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1371  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1372              /* Leave the loop */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1373              return xFuncRet_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1374          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1375  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1376          /* Check the current array index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1377          if(Fee_BlockProperties_st[xMid_u16].BlockPersistentId_u16 > FeeIdx_u16)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1378          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1379              /* Check if the lowest array position is reached */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1380              if(xMid_u16 != 0)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1381              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1382                  /* Reduce the right limit to the left */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1383                  xRight_u16 = (uint16)(xMid_u16 - 1u);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1384              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1385              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1386              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1387                  /* Leave the loop with a negative response */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1388                  return xFuncRet_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1389              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1390          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1391          else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1392          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1393              /* Reduce the left limit to the right (upper limit is
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1394               * safe because of the loop condition) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1395              xLeft_u16 = (uint16)(xMid_u16 + 1u);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1396          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1397      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1398      while(xRight_u16 >= xLeft_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1399  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1400      return xFuncRet_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1401  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1402  /* FEE_FAST_CACHE_INIT_ACTIVE != FALSE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1403  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1404  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1405  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1406  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1407   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1408   * Fee_SrvRoundUp():
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1409   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1410   * This function takes the parameter value and rounds it up to the next
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1411   * multiple of the stepsize.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1412   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1413   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1414   * \param    value_u32: value to be rounded up
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1415   * \param    stepsize_u32: atomic steps to be made during the rounding
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1416   * \return   value rounded up to a multiple of the stepsize
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1417   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1418   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1419   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1420  LOCAL_INLINE uint32 Fee_SrvRoundUp(uint32 value_u32 , uint32 stepsize_u32)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1421  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1422      uint32 modValue_u32, retVal_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1423  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1424      retVal_u32 = value_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1425  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1426      modValue_u32 = value_u32 % stepsize_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1427  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1428      if(modValue_u32 != 0u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1429      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1430          retVal_u32 += stepsize_u32 - modValue_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1431      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1432  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1433      return retVal_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1434  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1435  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1436  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1437   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1438   * Fee_SrvCalcSpaceNeededForWrite():
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1439   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1440   * This function calculates the space required to perform a write operation based on a given block configuration
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1441   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1442   * \param    blockLen_u16:       data length to be writen
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1443   * \param    securityLevel_b:    single or double stored block?
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1444   * \param    noFallback_b: is the block configured as NoFallback?
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1445   * \return   space needed to write the block
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1446   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1447   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1448   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1449  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1450  LOCAL_INLINE uint32 Fee_SrvCalcSpaceNeededForWrite(uint16  blockLen_u16 , boolean securityLevel_b , boolean noFallback_b)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1451  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1452      uint32 neededSpace_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1453  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1454      // for all block types: blkSize + HdrSize
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1455      neededSpace_u32 = (uint32)FEE_BLOCK_OVERHEAD + (uint32)(blockLen_u16);
	add	d0,d0,#14
.L213:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1456  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1457  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1458  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1459      // force a page alignment of header and data size
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1460      neededSpace_u32 = Fee_SrvRoundUp(neededSpace_u32 , (uint32)FEE_PAGE_LEN);
	mov	d15,#8
.L168:
	div.u	e4,d0,d15
.L218:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1428      if(modValue_u32 != 0u)      (inlined)
	jeq	d5,#0,.L70
.L381:
	rsub	d15,d5,#8
.L382:
	add	d0,d15

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1428      if(modValue_u32 != 0u)      (inlined)
.L70:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1433      return retVal_u32;      (inlined)
	j	.L71

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1434  }      (inlined)
.L71:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1461  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1462  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1463  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1464      // for NoFallback blocks: add one page space for the NoFB header
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1465      // If NoFallback is deactivated, the parameter shall be loaded with FALSE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1466      if (noFallback_b)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1467      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1468          neededSpace_u32 += (uint32)FEE_PAGE_LEN;
	cadd	d0,d2,d0,#8

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1466      if (noFallback_b)      (inlined)
.L72:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1473      if(securityLevel_b)      (inlined)
	jeq	d1,#0,.L73
.L383:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1469      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1470  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1471  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1472      // double security blocks: check for space writing both block copies
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1473      if(securityLevel_b)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1474      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1475          neededSpace_u32 *= 2u;
	sh	d0,#1

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1473      if(securityLevel_b)      (inlined)
.L73:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1478      return neededSpace_u32;      (inlined)
	j	.L74

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1479  }      (inlined)
.L74:
	extr.u	d5,d0,#0,#16
.L157:
	mov	d4,#16392
.L384:
	call	Fee_LLCheckReorganizationNeed
.L217:
	jne	d2,#5,.L75
.L385:
	movh.a	a15,#@his(Fee_idxActQueue_u8)
	lea	a15,[a15]@los(Fee_idxActQueue_u8)
	ld.bu	d15,[a15]
.L386:
	mul	d15,d15,#24
.L387:
	movh.a	a15,#@his(Fee_OrderFifo_st)
	lea	a15,[a15]@los(Fee_OrderFifo_st)
.L388:
	addsc.a	a15,a15,d15,#0
.L389:
	ld.w	d15,[a15]12
.L390:
	jne	d15,#2,.L76
.L391:
	mov	d4,#1
	call	Fee_TriggerHardSectorReorg
.L392:
	j	.L77
.L76:
	mov	d4,#3
	call	Fee_TriggerHardSectorReorg
.L77:
	j	.L78
.L75:
	movh.a	a2,#@his(Fee_Rb_WorkingState_en)
	lea	a2,[a2]@los(Fee_Rb_WorkingState_en)
.L150:
	movh.a	a15,#@his(Fee_idxActQueue_u8)
	lea	a15,[a15]@los(Fee_idxActQueue_u8)
	ld.bu	d15,[a15]
.L393:
	mul	d15,d15,#24
.L394:
	movh.a	a15,#@his(Fee_OrderFifo_st)
	lea	a15,[a15]@los(Fee_OrderFifo_st)
.L395:
	addsc.a	a15,a15,d15,#0
.L396:
	ld.w	d15,[a15]12
.L397:
	jne	d15,#2,.L79
.L398:
	mov	d15,#1
.L399:
	st.w	[a2],d15
.L400:
	j	.L80
.L79:
	mov	d15,#3
.L401:
	st.w	[a2],d15
.L80:
.L78:
	j	.L81
.L64:
	ld.hu	d0,[a15]10
.L219:
	ld.hu	d15,[a15]6
.L221:
	sha	d15,#4
.L222:
	movh.a	a15,#@his(Fee_BlockProperties_st)
	lea	a15,[a15]@los(Fee_BlockProperties_st)
.L402:
	addsc.a	a15,a15,d15,#0
.L403:
	ld.hu	d15,[a15]2
.L404:
	and	d15,#1
.L405:
	ne	d1,d15,#0
.L223:
	mov	d2,#0
.L180:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     1  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     2  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     3  #ifndef RBA_FEEFS1_PRV_H
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     4  #define RBA_FEEFS1_PRV_H
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     5  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     6  #if(defined(FEE_PRV_CFG_SELECTED_FS) && (1 == FEE_PRV_CFG_SELECTED_FS))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     7  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     8  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     9   **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    10   * \moduledescription
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    11   *           AUTOSAR FEE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    12   *           According to Document Version 3.0.0, Part of Release 4.0, Revision 2
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    13   * \scope    INTERN
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    15   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    16  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    17  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    18  /*
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    19  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    20  * Defines/Macros
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    21  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    22  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    23  /* General defines */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    24  #define FEE_MAXUINT32               (0xFFFFFFFFuL)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    25  #define FEE_MAXUINT16               (0xFFFFu)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    26  #define FEE_NULL                    (0u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    27  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    28  #define FEE_MARKER_PATTERN          0xCAFEu                 /* Pattern to identify a marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    29  #define FEE_NUM_MARKER_IN_HEADER    (FEE_NUM_MARKER_E - 1)  /* A sector has at least 4 states:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    30                                                                 ERASED -> USED -> FULL -> ERASE_REQ
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    31                                                                 Value is also in used in Fee_Process.pm */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    32  #define FEE_NO_SEC_IDX_FOUND        0xFFu                   /* No active sector / matching flash bank found */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    33  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    34  #define FEE_MARKER_SIZE             8u                      /* Each marker has a size of 8 Bytes (fix value is used in Fee_Process.pm) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    35  #define FEE_MARKER_CS_SIZE          2u                      /* Size of CRC16 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    36  #define FEE_LL_DATABUFFSIZE         256u                    /* Size of the internal data buffer used for writing */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    37                                                              /* (The page buffer size is auto generated) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    38  #define FEE_LL_CRC_CALC_RESTRICTION FEE_LL_DATABUFFSIZE     /* Restriction for the Crc calculation */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    39  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    40  #define FEE_FREE_PAGES_FOR_ERASED_ST    1u                  /* Number of pages containing the erased value */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    41  #define FEE_SIZE_OF_BLOCK_CS            4                   /* Size of block checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    42  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    43  /* Special values for sector change counter within the RAM array */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    44  #define FEE_SEC_CHANGE_CNT_RESET_REQ  0xFFFFFFFFuL
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    45  #define FEE_SEC_CHANGE_CNT_UNDEF      FEE_SEC_CHANGE_CNT_RESET_REQ
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    46  #define FEE_SEC_CHANGE_CNT_ERASED     (FEE_SEC_CHANGE_CNT_RESET_REQ - 1u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    47  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    48  /* Mask for accessing block flags in the configuration and in the block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    49  #define FEE_FLAG_SEC_LEVEL_MSK      0x0001u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    50  #define FEE_FLAG_SEC_LEVEL_BP       0u       /* Security level setting is bit 0 within the block flags */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    51  #define FEE_BLK_INT_DOUBLE_STORAGE  1u       /* Internal double block storage definition */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    52  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    53  #define FEE_FLAG_DATAFILTERTYPE_ATTR_MSK      0x0006u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    54  #define FEE_FLAG_DATAFILTERTYPE_ATTR_BP       1u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    55  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    56  #define FEE_FLAG_INVALID_MSK        0x08u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    57  #define FEE_FLAG_INVALID_BP         3u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    58  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    59  #define FEE_FLAG_SURV_ATTR_MSK      0x0010u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    60  #define FEE_FLAG_SURV_ATTR_BP       4u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    61  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    62  #define FEE_FLAG_ROBUST_ATTR_MSK    0x0020
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    63  #define FEE_FLAG_ROBUST_ATTR_BP     5
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    64  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    65  #define FEE_FLAG_NOFALLBACK_MSK     0x0040u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    66  #define FEE_FLAG_NOFALLBACK_BP      6u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    67  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    68  #define FEE_MASK_BIT7               (uint8)0x80
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    69  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    70  /* Mask for accessing block flags (upper byte only) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    71  #define FEE_FLAG_JOBTYPE_MSK        0x0300u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    72  #define FEE_FLAG_JOBTYPE_BP         8u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    73  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    74  #define FEE_FLAG_JOBPRIO_MSK        0x0400u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    75  #define FEE_FLAG_JOBPRIO_BP         10u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    76  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    77  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    78  /* Macros for the conversion of the Sec Level settings:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    79   * Internal storage level:      Sec Level 1  --> 0 / Sec Level 2 --> 1
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    80   * User Config storage level:   Sec Level 1  --> 1 / Sec Level 2 --> 2 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    81  #define FEE_INT_TO_USER_STORAGE_TYPE(SEC_LEVEL) ((SEC_LEVEL) + 1u)   /* Convert the Sec Level setting from
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    82                                                                         header/properties == internal to user config format */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    83  #define FEE_CNT_FIRST_COPY          0u       /* Internal counter value for first copy */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    84  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    85  /* Erase actions */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    86  #define FEE_NO_SECTOR_TO_ERASE      0xFFu    /* No sector has to be erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    87  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    88  /* Block header validation */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    89  #define FEE_BLK_HEADER_PREAMBEL             0xA53C96uL                                  /* Pattern of preambel */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    90  #define FEE_BLK_HEADER_PREAMBEL_BYTE_2      (FEE_BLK_HEADER_PREAMBEL & 0xFFu)           /* 0x96 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    91  #define FEE_BLK_HEADER_PREAMBEL_BYTE_1      ((FEE_BLK_HEADER_PREAMBEL >> 8u) & 0xFFu)   /* 0x3C */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    92  #define FEE_BLK_HEADER_PREAMBEL_BYTE_0      ((FEE_BLK_HEADER_PREAMBEL >> 16u) & 0xFFu)  /* 0xA5 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    93  #define FEE_BLK_HEADER_SIZE                 14u                                         /* Size of block header in bytes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    94  #define FEE_BKL_HEADER_REDUCTION            FEE_VIRTUAL_PAGE_SIZE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    95  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    96  /* Calculation of free byte in current sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    97  #define FEE_LL_SECTOR_USED_FOR_WRITING      Fee_RdWrOrder_st.xWrAddress
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    98  #define FEE_LL_SECTOR_USED_FOR_READING      Fee_RdWrOrder_st.xRdAddress
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    99  #define FEE_LL_SECTOR_USED_FOR_COMPARING    Fee_RdWrOrder_st.xCmpAddress
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   100  #define FEE_LL_SECTOR_USED_FOR_CRC_CALC     Fee_RdWrOrder_st.xCrcAddress
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   101  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   102  /* Cache usage*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   103  #define FEE_INVLD_BLOCK_PROP_IDX        0xFFFFFFFFuL    /* Invalid Fee Idx that can be passed to the block header search function
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   104                                                             in order to ignore the cache during the init phase */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   105  #define FEE_USE_CACHED_ACCESS               0x01u       /* Use the cache method for finding the next block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   106  #define FEE_USE_MANUAL_ACCESS               0x00u       /* Search manually for headers */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   107  #define FEE_UPDATE_CACHE_IN_INIT            0x01u       /* Update the cache for fast access in init */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   108  #define FEE_NO_CACHE_UPDATE                 0x00u       /* Do not use the fast access method (only evaluated blocks are added to the cache) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   109  #define FEE_CACHE_UPD_NOT_COMP_FOR_SECT     0x00u       /* The respective sector was not completely checked */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   110  #define FEE_CACHE_UPD_COMP_FOR_SECT         0x01u       /* The respective sector was checked completely */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   111  #define FEE_CACHE_UPD_COMP_FOR_ALL_SECT     0x02u       /* All sectors have been checked completely */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   112  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   113  #define Fee_LLInvalidateAddressInCache(FEEIDX) Fee_LLUpdateAddressInCache(FEEIDX, FEE_CACHE_INIT_VALUE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   114  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   115  /* Fee init defines */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   116  #define FEE_PRV_ST_INIT_RUNNING             0x00u       /* Module is still uninitialized */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   117  #define FEE_PRV_ST_INIT_DONE                0x01u       /* Module has been initialized */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   118  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   119  /* Fee reorganization defines */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   120  #define FEE_PRV_ST_REORG_IDLE               0x00u       /* No reorganization is running */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   121  #define FEE_PRV_ST_REORG_STANDARD_RUNNING   0x01u       /* Standard reorganization is running */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   122  #define FEE_PRV_ST_REORG_AFTERB_RUNNING     0x02u       /* "Afterburner" of the reorganization is runnning */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   123  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   124  /* Amount of sectors used by the emulation  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   125  #define FEE_NUM_FLASH_BANKS         Fee_NumFlashBanksUsed_u8  /* Number of sectors which can be used by the Fee */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   126  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   127  #if (FEE_RB_ADDONS_CCAS == TRUE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   128  #define FEE_RB_REQUEST_STOP_MODE            TRUE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   129  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   130  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   131  #if(FEE_ROBUST_PROG_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   132  #define FEE_ROBMARKER_BUFF_SIZE             96u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   133  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   134  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   135  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)     /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   136  #define FEE_FIRSTDATAPAGE_NOTPROGRAMMED 0x00u            /* First data pages in Fee_LlFls2FlsCopy is not yet programmed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   137  #define FEE_FIRSTDATAPAGE_PROGRAMMED     0x01u            /* First data pages in Fee_LlFls2FlsCopy is programmed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   138  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   139  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   140  /*
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   141  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   142  * Type definitions
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   143  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   144  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   145  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   146  /* Order priority */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   147  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   148  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   149      FEE_NORMAL_PRIO_E = 0,      /* e.g. if FeeImmediateData is configured to no */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   150      FEE_HIGH_PRIO_E   = 1       /* e.g. if FeeImmediateData is configured to yes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   151  }Fee_HlPriority_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   152  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   153  /* This enumerator list contains the index inside the order queue.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   154   * Attention: The order in the enumerator is from Low (FEE_ADAPTER_JOB) to High (FEE_INTERNAL_JOB).
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   155   *            Do not change this order!
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   156   * */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   157  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   158  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   159      FEE_INTERNAL_JOB,           /* Internal job (reorganization or sector erase) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   160      FEE_NVM_JOB,                /* Nvm job */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   161      FEE_ADAPTER_JOB,            /* Adapter job (e.g. Mx17 Eep) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   162      FEE_QUEUE_SIZE              /* Size of the Fee internal queue (each job type has 1 entry) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   163  }Fee_HlJobType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   164  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   165  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   166  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   167      uint8*  DataBufferPtr_pu8;  /* Pointer to the read- or write-buffer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   168      uint16  FeeIdx_u16;         /* FeeRbBlockPersistentId */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   169      uint16  BlockPropIdx_u16;   /* Respective block properties table index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   170      uint16  Offset_u16;         /* Offset inside block (could be != 0 only for read-orders --> R4.0 Rev1) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   171      uint16  Length_u16;         /* Block length, only required for element-read-jobs */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   172      Fee_HlMode_ten Mode_en;     /* Type of this order: Read, Write, Invalidate */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   173      Fee_HlPriority_ten Prio_en; /* Priority out of the configuration */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   174      uint8   SecLevel_u8;        /* Security level out of the configuration */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   175  }Fee_OrderFifo_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   176  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   177  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   178  /* Hint:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   179   * For calculation of the sector order (old -> new -> erased -> undef) the sector change counter is a valid criteria.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   180   * The lowest valid value points to the eldest data, the most current value to the most current data.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   181   * These following defines are used for an implicit sorting:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   182   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   183   *  +------+------+------+------+------+------+------+------+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   184   *  |MarkerPattern|Ident | marker content     |marker CRC16 |
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   185   *  +------+------+------+------+------+------+------+------+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   186   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   187   *  Sector headers: 12 times available as default
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   188   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   189   *      +------+------+------+------+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   190   *    0 |Erased| Used | Full |Erase |
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   191   *      +------+------+------+------+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   192   *    4 |      |      |      |      |
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   193   *      +------+------+------+------+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   194   *    8 |      |      |      |      |
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   195   *      +------+------+------+------+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   196   *      |<---->|
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   197   *        Page
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   198   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   199   * Erased:  Sector was erased successfully. This marker also contains the sector erase counter
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   200   * Used:    Sector contains user data. This marker will be written first before data is written into a sector.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   201   *          This marker also contains the sector change counter.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   202   * Full:    Sector is completely full and must not be considered for searching for the first empty page.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   203   *          This marker also contains the sector change counter.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   204   * Erase:   Sector contains no valid data anymore and can be erased in the background task.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   205   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   206   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   207  enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   208  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   209      FEE_ERASED_MARKER_ID_E = 0x01u, /* Sector was erased successfully */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   210      FEE_USED_MARKER_ID_E,           /* Sector was used to store data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   211      FEE_FULL_MARKER_ID_E,           /* Sector is full */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   212      FEE_ERASE_REQUEST_ID_E,         /* Sector should be erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   213      FEE_START_MARKER_ID_E,            /* Double storage of USED marker, contains address of first blockheader */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   214      FEE_CLONE_START_MARKER_ID_E,    /* Marker to indicate that cloning of a defect sector has startet in this sector --> Ifx robust programming */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   215      FEE_RESERVED_MARKER_ID1_E,      /* Reserved range marker space in the sector header, currently not used! */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   216      FEE_RESERVED_MARKER_ID2_E,      /*    "       "     "      "   "    "      "         "      "    "   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   217      FEE_RESERVED_MARKER_ID3_E,      /*    "       "     "      "   "    "      "         "      "    "   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   218      FEE_RESERVED_MARKER_ID4_E,      /*    "       "     "      "   "    "      "         "      "    "   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   219      FEE_RESERVED_MARKER_ID5_E,      /*    "       "     "      "   "    "      "         "      "    "   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   220      FEE_RESERVED_MARKER_ID6_E,      /*    "       "     "      "   "    "      "         "      "    "   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   221      FEE_NUM_MARKER_E                /* Amount of required markers in the sector header + 1 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   222  };
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   223  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   224  /* Sector marker structure */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   225  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   226  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   227      uint16  xPattern;               /* Static marker pattern: 0xCAFE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   228      uint8   xIdent;                 /* Ident to identify the marker: 0x01 Erased-Marker, 0x02 Used-Marker, 0x03 Full-Marker, 0x04 Erase-Request */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   229      uint8   xContent[3];            /* Sector change counter */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   230      uint16  xChecksum;              /* Crc16 checksum, calculation over Patter, Ident and content */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   231  }Fee_MarkerProp_t;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   232  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   233  /* Sector detection type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   234  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   235  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   236      uint32  SecChngCnt_u32;         /* Sector change counter */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   237      uint8   ctErasedMarker_u8;      /* Number of found ERASED markers */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   238      uint8   ctUsedMarker_u8;        /* Number of found USED markers */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   239      uint8   ctFullMarker_u8;        /* Number of found FULL markers */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   240      uint8   ctEraseReq_u8;          /* Number of found ERASE requests */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   241      uint32  xStartAddr_u32;         /* Address of first blockheader in the sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   242      uint8   ctCloneMarker_u8;       /* Cloning of data has started (only Ifx robust programming algorithm */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   243  }Fee_stSecDet_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   244  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   245  /* Sector states */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   246  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   247  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   248      FEE_SECTOR_STATE_UNDEF_E        = 0,                      /* undefined sector-state --> no marker found */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   249      FEE_SECTOR_ERASED_E             = FEE_ERASED_MARKER_ID_E, /* sector was erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   250      FEE_SECTOR_USED_E               = FEE_USED_MARKER_ID_E,   /* sector was used to write data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   251      FEE_SECTOR_FULL_E               = FEE_FULL_MARKER_ID_E,   /* sector is full */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   252      FEE_SECTOR_REQUEST2ERASE_E      = FEE_ERASE_REQUEST_ID_E, /* sector could be erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   253      FEE_SECTOR_CONSIDERED_E         = FEE_NUM_MARKER_E        /* sector was considered in function Fee_LLDetectActiveSector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   254  }Fee_SectorState_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   255  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   256  /* Sector order after sort sequence */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   257  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   258  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   259      uint32 SecChngCnt_u32;                  /* Sector change counter */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   260      Fee_SectorState_ten SecState_en;        /* Sector state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   261      uint8 xPhySecIdx_u8;                    /* Sector index (physical sector) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   262  }Fee_LLSectorOrder_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   263  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   264  /* Fee internal return types */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   265  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   266  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   267      FEE_ORDER_PENDING_E,            /* The order is still pending*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   268      FEE_ORDER_FINISHED_E,           /* The order was finished without error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   269      FEE_BLOCK_INVALIDATED_E,        /* The block was invalidated in the block status */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   270      FEE_ERROR_E,                    /* An error occured, maybe data in flash was not valid */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   271      FEE_SECTORCHANGE_E,             /* A sector change has to be done */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   272      FEE_SECTORFULL_E,               /* The sector is full */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   273      FEE_ABORTED_E,                  /* An order was aborted*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   274      FEE_ERASE_SECTOR_E,             /* The sector must be erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   275      FEE_SEARCH_ABORTED_E,           /* Searching was aborted */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   276      FEE_NUM_RET_VAL_E               /* Number of return values */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   277  }Fee_stRetVal_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   278  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   279  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   280  /* Flash properties */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   281  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   282  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   283      uint32  Fee_PhysStartAddress_u32;       /* Physical sector: start address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   284      uint32  Fee_PhysEndAddress_u32;         /* physical sector: end address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   285      uint32  Fee_LogStartAddress_u32;        /* logical sector: start address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   286      uint32  Fee_LogEndAddress_u32;          /* logical sector: end address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   287  }Fee_FlashProp_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   288  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   289  /* Block properties for all Fee blocks
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   290   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   291   * Status Flags:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   292   * Block flags will help to specify a more detailed block configuration. The low Byte of these block flags is also stored
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   293   * in the flash (status byte inside the block header). This information (in Flash) can be used to read/write the layout
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   294   * without configuration (PAV, CB).
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   295   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   296   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   297   *                                                 |<----- Block Status Byte in Block Header ----->|
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   298   * |<---------------------------------------- Block Flags ---------------------------------------->|
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   299   *    F     E     D     C     B     A     9     8  |  7     6     5     4     3     2     1     0  |
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   300   * +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   301   * |     |     |     |     |     |Prio-| Job type  |     |     | Rob |Surv.|(Inv)| DataFilter| Sec-|
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   302   * |     |     |     |     |     |rity |           |     |     |Attr.|Attr.|     |    Type   | lvl |
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   303   * +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   304   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   305   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   306   *  0  ... SecurityLevel      => 0...SingleStorage, 1...DoubleStorage
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   307   * 1+2 ... Data Filter Type   => 0...Dynamic:         Anybody can erase this block (e.g. during migration)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   308   *                               1...Static:          Only certain users (e.g. repair shops) can erase this block
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   309   *                               2...Permanent:       Only very certain users (e.g. OEM) can erase this block
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   310   *                               3...Super Permanent: Block can never be erased
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   311   *  3 .... Invalid            => 0...Block OK, 1...Block is invalid  --> can be changed by function Fee_InvalidateBlock
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   312   *  4 .... Survival Attribute => 0...No survival, 1... Survival (even without being part of the layout)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   313   *  5 .... Robustness Attribute (Robustness against data modification during write execution)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   314   *                            => 0...Deactivated:     No additional checksum is used
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   315   *                            => 1...Activated:       Additional checksum is used
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   316   * 8+9 ... TypeOfBlock        => 0...InternalJob, 1...NvmJob, 2...AdapterJob (e.g. Mx17 Eep adapter)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   317   *  A .... Priority           => Job priority:        0...FEE_NORMAL_PRIO_E --> FeeImmediateData = No
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   318   *                                                    1...FEE_HIGH_PRIO_E   --> FeeImmediateData = Yes
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   319   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   320  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   321  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   322      uint16 BlockPersistentId_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   323      uint16 Flags_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   324      uint16 Length_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   325      void (* const JobEndNotification_pfn) (void);      /* callback function, will be called if a job was successfully finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   326      void (* const JobErrorNotification_pfn) (void);    /* callback function, will be called if a job was finished with an error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   327  }Fee_BlockPropertiesType_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   328  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   329  /* Job types corresponding to the queue index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   330  enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   331  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   332      FEE_JOB_TYPE_INTERNAL_E = 0,            /* Internal job index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   333      FEE_JOB_TYPE_NVM_E      = 1,            /* NvM job index  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   334      FEE_JOB_TYPE_ADAPTER_E  = 2             /* Adapter job index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   335  };
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   336  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   337  /* State machine types for the function Fee_LLWriteMarker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   338  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   339  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   340      FEE_LL_MARKER_INIT_E,                   /* Init state                                    */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   341      FEE_LL_MARKER_BLK_CHK_E,                /* Perform a blank check over one page           */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   342      FEE_LL_MARKER_BLK_CHK_WAIT_E,           /* Wait for the blank check order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   343      FEE_LL_MARKER_BLK_CHK_ERROR_E,          /* Differences detected                          */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   344      FEE_LL_MARKER_BLK_CHK_FINISHED_E,       /* Start write order of the marker               */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   345      FEE_LL_MARKER_WRITE_WAIT_E,             /* Wait for the write order to be finished       */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   346      FEE_LL_MARKER_WRITE_ERROR_E,            /* Read or write error                           */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   347      FEE_LL_MARKER_VERIFY_E,                 /* Verify written marker                         */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   348      FEE_LL_MARKER_VERIFY_WAIT_E,            /* Wait for verify marker                        */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   349      FEE_LL_MARKER_VERIFY_FINISHED_E         /* Verify marker finished                        */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   350  }Fee_LLWrMarkerType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   351  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   352  /* State machine types for the function Fee_HLWriteBlock and Fee_HLReadBlock */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   353  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   354  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   355      FEE_HL_RDWR_BLK_INIT_E,                 /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   356      FEE_HL_SEARCH_BLK_HDR_E,                /* Search block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   357      FEE_HL_READ_BLK_HDR_WAIT_E,                  /* Read block header for redundant blocks */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   358      FEE_HL_CHECK_BLK_HDR_E,                 /* Check block header for redundant blocks */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   359      FEE_HL_CALC_BLK_CS_E,                   /* Calculate the user checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   360      FEE_HL_CHECK_BLK_CS_E,                  /* Verify the block checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   361      FEE_HL_RD_DATA_FROM_BLK_E,              /* Read the block data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   362      FEE_HL_COMP_BLK_E,                      /* Compare the complete block data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   363  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   364      /* Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   365      #if (defined(RBA_FLSIFX_FLASH) || defined(RBA_FLSJDP_FLASH))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   366      FEE_HL_RD_WAIT_FOR_FLS_E,               /* Wait for the Fls to overstamp an invalid header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   367      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   368      /* END Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   369  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   370      FEE_HL_WR_BLK_E                         /* Write the block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   371  }Fee_HLRdWrBlockType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   372  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   373  /* State machine types for the function Fee_LLWriteBlock */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   374  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   375  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   376      FEE_LL_WR_BLK_INIT_E,                   /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   377      FEE_LL_WR_WRITEHEADER_E,                /* Write the header (and first data bytes) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   378      FEE_LL_WR_SIZECHECK_HSR_E,              /* check for space until HSR */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   379      #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   380      FEE_LL_WR_BLANKCHECK_NOFB_WR_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   381      FEE_LL_WR_BLANKCHECK_NOFB_WR_WAIT_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   382      FEE_LL_WR_WRITE_NOFB_MARKER_E,          /* Write the NoFallback marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   383      FEE_LL_WR_WRITE_NOFB_MARKER_WAIT_E,     /* Wait until the programming of the NoFallback marker is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   384      FEE_LL_WR_FILL_SECTOR_END_E,            /* Changes the active sector and fills the empty pages if necessary */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   385      FEE_LL_WR_FILL_SECTOR_END_WAIT_E,       /* Wait until the write order to fill the empty pages is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   386      FEE_LL_WR_FILL_SECTOR_END_ERROR_E,      /* Errors during write occured */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   387      FEE_LL_WR_WRITE_NOFB_MARKER_ERROR_E,    /* Errors during write occured */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   388      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   389      FEE_LL_WR_WRITEHEADER_WAIT_E,           /* Wait until the write order is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   390      FEE_LL_WR_VERIFYHEADER_E,               /* Verify the header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   391      FEE_LL_WR_VERIFYHEADER_WAIT_E,          /* Wait for the verification to end */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   392      FEE_LL_WR_VERIFYHEADER_ERROR_E,         /* Verify error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   393      FEE_LL_WR_WRITEDATA_SEC_A_E,            /* Write the data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   394      FEE_LL_WR_WAIT_WRITEDATA_SEC_A_E,       /* Wait until the write order is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   395      FEE_LL_WR_WRITE_ERROR_E,                /* Error during write (header or data page writes) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   396  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   397      FEE_LL_WR_WRITE_FULL_MARKER_E,          /* Write the FULL marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   398      FEE_LL_WR_ERASE_SECTOR_E,               /* Erase a sector and write the ERASED marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   399      FEE_LL_WR_WRITE_USED_MARKER_E,          /* Write the USED marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   400      FEE_LL_WR_WRITE_START_MARKER_E,         /* Write the START marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   401  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   402      /* Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   403      #if (defined(RBA_FLSIFX_FLASH) || defined(RBA_FLSJDP_FLASH))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   404      FEE_LL_WR_WAIT_FOR_FLS_OVERPROGRAMMING_E,   /* Wait for the Fls to overstamp an invalid header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   405      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   406      /* END Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   407  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   408      #if(FEE_ROBUST_PROG_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   409      FEE_LL_WR_WRITEDATA_IFX_HANDLING_E,     /* robust Ifx handling in case of wordline fails */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   410      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   411      FEE_LL_WR_VERIFY_BLK_E                  /* Verify the complete data including the block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   412  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   413      /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   414      #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   415      ,FEE_LL_WR_WRITEHDRPG2_E,                /* Write the 2nd header page. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   416      FEE_LL_WR_WAIT_WRITEHDRPG2_E            /* Wait until 2nd header page write is completed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   417      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   418  }Fee_LLWrBlockType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   419  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   420  /* State machine types for the function Fee_LLCompBlkInFlash */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   421  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   422  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   423      FEE_LL_CMP_BLK_INIT_E,                  /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   424      FEE_LL_CMP_HEADER_E,                    /* Compare the complete block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   425      FEE_LL_CMP_WAIT_HEADER_E,               /* Wait for the compare to finish */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   426      FEE_LL_CMP_CHECK_OVERLAP_E,             /* Check for an overlap */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   427      FEE_LL_CMP_DATA_SEC_A_E,                /* Check the header compare result and compare the data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   428      FEE_LL_CMP_WAIT_DATA_SEC_A_E,           /* Wait for the compare to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   429      FEE_LL_CMP_FINISHED_E                   /* Verify the data compare result and reset the state machine */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   430  }Fee_LLCmpBlkType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   431  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   432  /* State machine types for the function Fee_LLCopyData2Buffer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   433  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   434  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   435      FEE_LL_CPY_BLK_INIT_E,                  /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   436      FEE_LL_CPY_BLOCK_START_E,               /* Read out the data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   437      FEE_LL_CPY_BLOCK_WAIT_E,                /* Wait for the read order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   438      FEE_LL_CPY_BLOCK_ERROR_E,               /* Error in the read function */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   439      FEE_LL_CPY_BLOCK_FINISHED_E             /* Finish the function or the data transfer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   440  }Fee_LLCpyBlkType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   441  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   442  /* State machine types for the function Fee_LLCalcBlkCrcInFlash */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   443  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   444  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   445      FEE_LL_CRC_BLK_INIT_E,                  /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   446      FEE_LL_CRC_RD_HD_PAGE_E,                /* Read the header page */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   447      FEE_LL_CRC_RD_PAGE_E,                   /* Calculate the block checksums */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   448      FEE_LL_CRC_CHECK_OVERLAP_E,             /* Check for an overlap */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   449      #if(FEE_ROB_FEATURE_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   450      FEE_LL_CRC_RD_ROB_PAGE_E,               /* Retry with the robustness checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   451      FEE_LL_CRC_CHECK_OVERLAP_ROB_E,         /* Check for an overlap */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   452      FEE_LL_CRC_RD_ROB_PAGE_WAIT_E,          /* Wait until the read access is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   453      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   454      FEE_LL_CRC_RD_PAGE_WAIT_E,              /* Wait until the read access is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   455      FEE_LL_CRC_RD_ERROR_E                   /* Read error case */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   456  }Fee_LLCalcCrcBlkType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   457  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   458  /* State machine types for reading */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   459  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   460  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   461      FEE_LL_INIT_READ_E                      /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   462      ,FEE_LL_BLANK_CHECK_E                    /* Perform a blank check */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   463      ,FEE_LL_BLANK_CHECK_WAIT_E                /* Wait for the blank check to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   464      ,FEE_LL_READ_PAGE_E                     /* Read pages */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   465      ,FEE_LL_WAIT_READ_PAGE_E                /* Wait for the read order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   466      ,FEE_LL_READ_ERROR_E                    /* Error reaction for read error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   467      ,FEE_LL_READ_FINISHED_E                 /* Finish state machine */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   468      #if (FEE_HEADER_RECHECK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   469      #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   470      ,FEE_LL_NOFALLBACK_MARKER_CHECK_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   471      ,FEE_LL_NOFALLBACK_MARKER_CHECK_WAIT_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   472      ,FEE_LL_NOFALLBACK_MARKER_CHECK_FAILED_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   473      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   474      ,FEE_LL_RECHECK_HEADER_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   475      ,FEE_LL_RECHECK_HEADER_WAIT_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   476      ,FEE_LL_RECHECK_HEADER_FAILED_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   477      ,FEE_LL_RECHECK_HEADER_FINISHED_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   478      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   479  } Fee_LLRdStateType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   480  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   481  /* States for function Fee_LLCheckErasePattern */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   482  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   483  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   484      FEE_LL_INIT_BLANK_CHECK_E,              /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   485      FEE_LL_PERFORM_BLANK_CHECK_E,           /* Perform a blank check */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   486      FEE_LL_WAIT_PERFORM_BLANK_CHECK_E,      /* Wait for the blank check order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   487      FEE_LL_BLANK_CHECK_ERROR_E,             /* Differences detected */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   488      FEE_LL_BLANK_CHECK_FINISHED_E           /* Finish state machine with success */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   489  } Fee_LLBlankCheckType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   490  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   491  /* State of function Fee_Prv_LLFindEmptyPage */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   492  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   493  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   494      #if ( defined(RBA_FLSRH850P1xC_FLASH) || defined(RBA_FLSV850R1x_FLASH) || defined(RBA_FLSRH850xx_FLASH) )
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   495      FEE_LL_FINDEMPTYPGE_INIT_E,             /* Initalize find empty page state machine  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   496      FEE_LL_FINDEMPTYPGE_CHECK_E,            /* Begin a blank check                      */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   497      FEE_LL_FINDEMPTYPGE_WAIT_E,             /* Wait until the blank check finished      */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   498      FEE_LL_FINDEMPTYPGE_RESULT_BLANK_E,     /* Checked chunk was completely blank       */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   499      FEE_LL_FINDEMPTYPGE_RESULT_NOT_BLANK_E  /* Checked chunk was not completely blank   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   500      #else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   501      FEE_LL_FIND_CURRENT_SECTOR_E,           /* Evaluate the sector with most current values */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   502      FEE_LL_FIND_LAST_HEADER_E,              /* Search the last block header in the active sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   503      FEE_LL_FINISHED_E                       /* Function finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   504      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   505  }Fee_LLFndEmptyPgeType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   506  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   507  /* State of the function Fee_LLSearchSpecifiedBlkHeader */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   508  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   509  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   510      FEE_LL_SEARCHBLK_INIT_E,                /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   511      FEE_LL_SEARCHBLK_BLK_HEADER_E           /* Search for the next block header*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   512  }Fee_LLSearchBlkHdrType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   513  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   514  #if(FEE_FAST_CACHE_INIT_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   515  /* State of the function Fee_BuildUpCache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   516  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   517  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   518      FEE_LL_BLD_UP_CACHE_INIT_E,             /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   519      FEE_LL_BLD_UP_CACHE_READ_E              /* Read out data directly if possible */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   520  }Fee_LLBuildUpCache_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   521  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   522  /* State of the function Fee_BuildUpCacheForAllSect */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   523  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   524  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   525      FEE_LL_BLD_UP_CACHE_ALL_SECT_INIT_E,/* Init case */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   526      FEE_LL_BLD_UP_CACHE_ALL_SECT_DO_E   /* Build up the cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   527  }Fee_LLBuildUpCacheAllSect_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   528  /* FEE_FAST_CACHE_INIT_ACTIVE != FALSE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   529  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   530  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   531  #if((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   532  #if (FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE == 0)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   533  /* Unknown blcok sector reorganiation without cache: State of the function Fee_LLSearchUnknBlkHeader */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   534  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   535  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   536      FEE_LL_SEARCHUNKNBLK_INIT_E,            /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   537      FEE_LL_SEARCHUNKNBLK_UNKN_BLK_HEADER_E, /* Search the next unknown block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   538      FEE_LL_SEARCHUNKNBLK_SPEC_BLK_HEADER_E  /* Search the next specific block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   539  }Fee_LLSearchUnknBlkHdrType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   540  #else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   541  /* Unknown block sector reorganiation with cache: states of cache build up function Fee_BuildUpCacheUnknownBlk */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   542  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   543  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   544      FEE_LL_BLD_UP_CACHE_UNKOWN_BLK_INIT_E,             /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   545      FEE_LL_BLD_UP_CACHE_UNKOWN_BLK_READ_E,             /* Read out data directly if possible */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   546      FEE_LL_BLD_UP_CACHE_UNKOWN_BLK_VALIDATEDATA_E      /* Validate the data CRC of the uknown block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   547  }Fee_LLBuildUpUnknownBlkCache_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   548  #endif /* End of (FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE == 0) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   549  #endif /* End of ((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE)) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   550  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   551  /* States for the function Fee_LLSectorReorganization */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   552  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   553  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   554      FEE_LL_REORG_INIT_E,                    /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   555      FEE_LL_REORG_PREP_SEARCH_BLK_E,         /* Prepare the next block search */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   556      FEE_LL_REORG_SEARCH_BLK_E,              /* Search for a specific block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   557      FEE_LL_REORG_CHECK_BLOCK_CS_E,          /* Evaluate the block checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   558      FEE_LL_REORG_REDUNDANT_BLK_CHK_E,       /* Check if redundant copy is not lost during sector reorg. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   559      FEE_LL_REORG_WRITE_BLOCK_E,             /* Write a block into the latest sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   560  #if((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   561      FEE_LL_REORG_SEARCH_UNK_BLK_E,          /* Search for an unknown block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   562   #if(FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE != 0) /* Unknown blcok sector reorganiation with cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   563      FEE_LL_REORG_CACHEBUILDUP_UNK_BLK_E,    /* Building of cache for unknown block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   564      FEE_LL_REORG_SEARCH_UNK_HDRBLK_WAIT_E,            /* Wait till reading of unknown block header is finished. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   565      FEE_LL_REORG_SEARCH_UNK_HDRBLK_READ_ERROR_E,    /* Failure during read of unknown block header. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   566      FEE_LL_REORG_SEARCH_UNK_HDRBLK_READ_FINISHED_E,    /* Unknown block header read successful. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   567   #endif /* End of (FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE != 0) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   568  #endif /* End of ((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE)) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   569  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   570      /* Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   571      #if (defined(RBA_FLSIFX_FLASH) || defined(RBA_FLSJDP_FLASH))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   572      FEE_LL_REORG_WAIT_FOR_FLS_E,            /* Wait for the Fls to overstamp an invalid header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   573      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   574      /* END Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   575  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   576      FEE_LL_REORG_FINISHED_E                 /* Function finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   577  }Fee_LLSecReorgType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   578  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   579  /* States for the function Fee_LLRedundantCpyChk */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   580  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   581  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   582      FEE_LL_REDUNDANT_CPY_CHK_INIT_E,            /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   583      FEE_LL_REDUNDANT_CPY_CHK_SEARCH_HDR_E,      /* Search header of redundant copy */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   584      FEE_LL_REDUNDANT_CPY_CHK_BLK_CS_E           /* Validate data CRC of redundant copy */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   585  }Fee_LLRedundantCpyChk_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   586  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   587  /* States for the function Fee_LLCpyBlkFromFls2Fls */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   588  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   589  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   590      FEE_LL_CPY_FLS2FLS_INIT_E,                      /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   591  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   592      #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   593      FEE_LL_CPY_FLS2FLS_WRITE_NOFB_MARKER_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   594      FEE_LL_CPY_FLS2FLS_WAIT_WRITE_NOFB_MARKER_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   595      FEE_LL_CPY_FLS2FLS_WRITE_NOFB_MARKER_ERROR_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   596      FEE_LL_CPY_FLS2FLS_WAIT_FILL_SECTOR_END_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   597      FEE_LL_CPY_FLS2FLS_FILL_SECTOR_END_ERROR_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   598      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   599  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   600      FEE_LL_CPY_FLS2FLS_READ_E,                      /* Read out the complete block (header and data) and finish the function if possible */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   601      FEE_LL_CPY_FLS2FLS_WAIT_READ_E,                 /* Wait for the read order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   602      FEE_LL_CPY_FLS2FLS_READ_ERROR_E,                /* Read error state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   603  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   604      /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   605      #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   606      FEE_LL_CPY_FLS2FLS_HDRPG1_WRITE_E,              /* Write the header page 1 into the new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   607      FEE_LL_CPY_FLS2FLS_WAIT_HDRPG1_WRITE_E,         /* Wait for the header page 1 write order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   608      FEE_LL_CPY_FLS2FLS_HDRPG1_WRITE_ERROR_E,        /* Write error state for header page 1 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   609      FEE_LL_CPY_FLS2FLS_HDRPG1_VERIFY_E,             /* Compare the header page 1 write */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   610      FEE_LL_CPY_FLS2FLS_WAIT_HDRPG1_VERIFY_E,        /* Wait for the header page 1 verification to finish */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   611      FEE_LL_CPY_FLS2FLS_HDRPG1_VERIFY_ERROR_E,       /* Verification error for header page 1 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   612      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   613  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   614      FEE_LL_CPY_FLS2FLS_WRITE_E,                     /* Write the data into the new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   615      FEE_LL_CPY_FLS2FLS_WAIT_WRITE_E,                /* Wait for the write order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   616      FEE_LL_CPY_FLS2FLS_WRITE_ERROR_E,               /* Write error state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   617      FEE_LL_CPY_FLS2FLS_VERIFY_E,                    /* Compare the programmed data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   618      FEE_LL_CPY_FLS2FLS_WAIT_VERIFY_E,               /* Wait for the verification to finish */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   619      FEE_LL_CPY_FLS2FLS_VERIFY_ERROR_E,              /* Verification error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   620  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   621      /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   622      #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   623      FEE_LL_CPY_FLS2FLS_HDRPG2_WRITE_E,              /* Write the header page 2 into the new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   624      FEE_LL_CPY_FLS2FLS_WAIT_HDRPG2_WRITE_E,         /* Wait for the header page 2 write order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   625      FEE_LL_CPY_FLS2FLS_HDRPG2_WRITE_ERROR_E,        /* Write error state for header page 2 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   626      FEE_LL_CPY_FLS2FLS_HDRPG2_VERIFY_E,             /* Compare the header page 2 write */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   627      FEE_LL_CPY_FLS2FLS_WAIT_HDRPG2_VERIFY_E,        /* Wait for the header page 2 verification to finish */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   628      FEE_LL_CPY_FLS2FLS_HDRPG2_VERIFY_ERROR_E,       /* Verification error for header page 2 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   629      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   630  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   631      FEE_LL_CPY_FLS2FLS_CHECK_ADR_OVERFLOW_E,        /* Data transfer is finished, check a possible address overflow */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   632      FEE_LL_CPY_FLS2FLS_WRITE_FULL_MARKER_E,         /* Write the FULL marker to the "old" sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   633      FEE_LL_CPY_FLS2FLS_ERASE_SECTOR_E,              /* Erase the sector that will be used as a new USED sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   634      FEE_LL_CPY_FLS2FLS_WRITE_USED_MARKER_E,         /* Write the USED marker to new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   635  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   636      #if(FEE_ROBUST_PROG_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   637      FEE_LL_CPY_FLS2FLS_ROBUST_IFX_HANDLING_E,       /* robust Ifx handling in case of wordline fails */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   638      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   639  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   640      #if defined (FEE_PRV_ROBUST_SECT_OVERFLOW)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   641      FEE_LL_CPY_FLS2FLS_ROBUST_SECT_OVERFLOW_E,      /* Robust sector reorganisation when sector overflow occurs during sector reorg. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   642      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   643  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   644      FEE_LL_CPY_FLS2FLS_WRITE_START_MARKER_E         /* Write the START marker to the new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   645  }Fee_LLCpyBlkFls2Fls_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   646  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   647  /* States for the function Fee_LlRobustSectorOverflow */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   648  #if defined (FEE_PRV_ROBUST_SECT_OVERFLOW)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   649  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   650  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   651      FEE_LL_ROBUST_SECTOR_OVERFLOW_INIT_E,           /* Init state. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   652      FEE_LL_ROBUST_SECTOR_OVERFLOW_WR_CM_E,          /* Write Clone marker in the latest sector. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   653      FEE_LL_ROBUST_SECTOR_OVERFLOW_PREPARE_E,        /* Compute the address and number of bytes for the operation. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   654  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   655      #if ( defined(RBA_FLSRH850P1xC_FLASH) || defined(RBA_FLSV850R1x_FLASH) || defined(RBA_FLSRH850xx_FLASH) )
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   656      FEE_LL_ROBUST_SECTOR_OVERFLOW_BLANK_CHK_E,      /* Check if the page is blank, transfer only programmed pages. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   657      FEE_LL_ROBUST_SECTOR_OVERFLOW_BLANK_CHK_WAIT_E, /* Wait for Blank check operation to complete. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   658      #endif /* #if ( defined(RBA_FLSRH850P1xC_FLASH) || defined(RBA_FLSV850R1x_FLASH) || defined(RBA_FLSRH850xx_FLASH) ) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   659  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   660      FEE_LL_ROBUST_SECTOR_OVERFLOW_READ_PAGE_E,      /* Read out the programmed page in an internal buffer. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   661      FEE_LL_ROBUST_SECTOR_OVERFLOW_READ_PAGE_WAIT_E, /* Wait for Read operation to complete. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   662      FEE_LL_ROBUST_SECTOR_OVERFLOW_COPY_DATA_E,      /* Copy data to new sector. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   663      FEE_LL_ROBUST_SECTOR_OVERFLOW_COPY_DATA_WAIT_E, /* Wait for Write operation to complete. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   664      FEE_LL_ROBUST_SECTOR_OVERFLOW_VERIFY_DATA_E,    /* Verify the copied data. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   665      FEE_LL_ROBUST_SECTOR_OVERFLOW_VERIFY_DATA_WAIT_E,/* Wait for Verify operation to complete. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   666      FEE_LL_ROBUST_SECTOR_OVERFLOW_VERIFY_SUCCESS_E, /* Check if more bytes are left to be programmed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   667      FEE_LL_ROBUST_SECTOR_OVERFLOW_WR_UM_E,          /* Write Used marker in the latest sector. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   668      FEE_LL_ROBUST_SECTOR_OVERFLOW_SORT_SECT_E,      /* Sort sectors */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   669      FEE_LL_ROBUST_SECTOR_OVERFLOW_ERROR_E,          /* Error state for all kinds of error in this state machine. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   670      FEE_LL_ROBUST_SECTOR_OVERFLOW_ERASE_E           /* Re-erase the older sector, this state is reached for error handling. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   671  }Fee_LLRobustSectOverflow_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   672  #endif /* #if defined (FEE_PRV_ROBUST_SECT_OVERFLOW) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   673  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   674  /* Read / write order type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   675  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   676  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   677      uint32                              xRdAddress;                     /* Address for reading (Fee_LLReadBlock) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   678      uint32                              xWrAddress;                     /* Address for writing (Fee_LLWriteBlock) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   679      uint32                              xCmpAddress;                    /* Address for comparing (Fee_LLCompBlkInFlash) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   680      uint32                              xCrcAddress;                    /* Address for the CRC (Fee_LLCompBlkInFlash) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   681      uint32                              xCpyAddress;                    /* Address for copying (Fee_LLCompBlkInFlash) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   682      uint32                              AdrHdSearchStart_u32;           /* Start address for the header search after reloads */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   683      uint32                              xStartAddrNextSector_u32;        /* Payload of START-Marker, contains the expected address of the 1. blockheader */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   684  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   685  /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   686  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   687      uint32                              xHdPg2Address;                   /* Address for writing the header 2nd page. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   688  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   689  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   690  #if !( defined(RBA_FLSRH850P1xC_FLASH) || defined(RBA_FLSV850R1x_FLASH) || defined(RBA_FLSRH850xx_FLASH) )
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   691      uint32                              LastProgrammedAddress_u32;        /* Last programmed page during cache build up. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   692      uint32                              LastValidHdrAddress_u32;          /* Last valid header found during cache build up. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   693  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   694  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   695      Fee_LLSecReorgType_ten              Fee_LLSecReorg_en;                /* State machine for the sector reorganization */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   696      Fee_LLRedundantCpyChk_ten           Fee_LLRedundantCpyChk_en;         /* State machine for checking redundant copy */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   697      Fee_LLCpyBlkFls2Fls_ten             Fee_LLCpyBlkFls2Fls_en;           /* State machine for copying one block from one sector to another one */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   698  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   699  #if defined (FEE_PRV_ROBUST_SECT_OVERFLOW)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   700      Fee_LLRobustSectOverflow_ten        Fee_LLRobustSectOverflow_en;      /* LL state machine for Robust sector overflow */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   701  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   702  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   703      Fee_HLRdWrBlockType_ten             Fee_HLWrBlock_en;                  /* HL state machine for writing a block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   704  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   705  #if(FEE_RB_MAINTAIN != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   706      Fee_HLRdWrBlockType_ten             Fee_HLMtBlock_en;                  /* HL state machine for maintaining a block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   707   #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   708  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   709      Fee_LLWrBlockType_ten               Fee_LLWrBlock_en;                  /* LL State machine for writing a block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   710      Fee_HLRdWrBlockType_ten             Fee_HLRdBlock;                     /* state machine for reading a block High Level */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   711      Fee_LLWrBlockType_ten               Fee_LLNextUsedWrBlock_en;          /* LL state for saving the next write state if a USED marker is necessary in between */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   712      Fee_LLWrBlockType_ten               Fee_LLNextEraseWrBlock_en;         /* LL state for saving the next write state if an erase operation is necessary in between */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   713      Fee_LLCmpBlkType_ten                Fee_LLCompBlk;                     /* LL state machine for comparing data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   714      Fee_LLCpyBlkType_ten                Fee_LLCopyBlk_en;                  /* LL state machine for copying data from the flash to the user buffer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   715      Fee_LLCalcCrcBlkType_ten            Fee_LLCalcCrcBlk_en;               /* LL state machine for calculating the checksum of a block inside the flash */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   716      Fee_LLWrMarkerType_ten              Fee_LLWrMarker_en;                 /* LL state machine for writing a sector marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   717      Fee_LLRdStateType_ten               Fee_LLRdState_en;                  /* LL state machine to read a specified address in the sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   718      Fee_LLBlankCheckType_ten            Fee_LLBlankCheckState_en;          /* LL State machine to perform a blank check */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   719      Fee_LLFndEmptyPgeType_ten           Fee_LLFindEmptyPageState_en;       /* LL state machine to find an empty page within one sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   720      Fee_LLSearchBlkHdrType_ten          Fee_LLSearchBlkHdr_en;             /* LL state machine to find a specified block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   721  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   722  #if((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   723   #if(FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE == 0) /* Unknown block sector reorganiation without cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   724      Fee_LLSearchUnknBlkHdrType_ten      Fee_LLSearchUnknBlkHdr_en;          /* LL state machine to find an unknown block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   725   #else /* Unknown blcok sector reorganiation with cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   726      uint32                              Fee_UnknownBlkCacheAdd_u32;         /* Address till where the cache for unknown block is scanned */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   727      uint16                              Fee_UnknownBlkCacheIdx_u16;         /* Index till which the cache for unknown block is built */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   728      Fee_LLBuildUpUnknownBlkCache_ten    Fee_LLBuildUpCacheUnknownBlk_en;    /* LL state machine to build up the cache for unknown blocks */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   729   #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   730  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   731  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   732  #if(FEE_FAST_CACHE_INIT_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   733      Fee_LLBuildUpCache_ten              Fee_LLBuildUpCache_en;              /* LL state machine to build up the cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   734      Fee_LLBuildUpCacheAllSect_ten       Fee_LLBuildUpCacheAllSect_en;       /* LL state machine to build up the cache for all sectors */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   735  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   736  } Fee_RdWrOrder_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   737  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   738  /* Block header info type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   739  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   740  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   741      uint32 AdrBlkHeader_u32;    /* Read address for for the function Fee_LLReadBlock and Fee_LLCpyBlkFromFls2Fls */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   742      uint32 BlkCrc32_u32;        /* Block data checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   743      uint16 HdrCrc16_u16;        /* Block header checksum (start value for block data checksum) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   744      uint16 BlkLength_u16;       /* Extracted block length from the block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   745      uint16 FeeIndex_u16;        /* Fee Index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   746      uint8  BlkStatus_u8;        /* Block status */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   747  }Fee_GlobInfoLastRdHeader_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   748  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   749  /* Block write type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   750  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   751  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   752      uint16  BytesAlrdyConsid_u16;   /* Write offset in user data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   753      uint16  BytesAlrdyCompared_u16;    /* Number of bytes already compared */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   754      uint16  Bytes2Read_u16;          /* Number of bytes to read */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   755      uint8   CompareResult_u8;       /* Result of last Fls_Compare */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   756      uint8   cntWriteRetry_u8;       /* Count number of write retries */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   757      uint8   cntCopies_u8;           /* Count number of written copies */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   758  }Fee_GlobInfoWrBlock_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   759  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   760  /* Sector reorganization type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   761  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   762  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   763      uint32 xRdAddress_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   764      uint16 xNumBytesAlrdyCopied_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   765      uint16 xNumBytesLeftToRdWr_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   766      uint8  xCntCopies_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   767  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)    /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   768      uint8  xFirstDataPgPgm_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   769  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   770  }Fee_LLSecReorgStruct_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   771  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   772  /* Erase sector types */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   773  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   774  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   775      FEE_ERASESEC_IDLE_E = 0,        /* Idle state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   776      FEE_ERASESEC_CHECK_CACHE_E,     /* Check of cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   777      FEE_ERASESEC_START_E,           /* Erase sequence started */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   778      FEE_ERASESEC_DO_E,              /* Wait until erasing was finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   779      FEE_ERASESEC_WRITE_MARKER_E,    /* Write the sector ERASED marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   780      FEE_ERASESEC_ERROR_E            /* Error state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   781  }Fee_LLEraseStateType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   782  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   783  /* Erase Order type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   784  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   785  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   786      Fee_LLEraseStateType_ten EraseState_en; /* State machine state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   787      uint8   xPhySectorIdx_u8;               /* Idx of sector that should get erased  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   788  }Fee_LLEraseOrderType_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   789  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   790  /* Block header structure */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   791  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   792  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   793      uint8   Preamble_au8[3];    /* Preambel (0xA53C96) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   794      uint8   BlkStatus_u8;       /* Block status, contains information like security level, etc. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   795      uint16  FeeIndex_u16;       /* FeeIndex */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   796      uint16  BlkLength_u16;      /* Block length without header and block checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   797      uint16  HdrCrc16_u16;       /* Header checksum, start value is 0xCAFE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   798      uint32  BlkCrc32_u32;       /* Block data checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   799  }Fee_BlkHeader_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   800  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   801  /* Linked function structure */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   802  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   803  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   804      void(* Fee_ResetUsedSectors_pfn)(void);     /* Function for resetting the amount of used sectors */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   805  }Fee_LinkedFunctions_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   806  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   807  #if (FEE_PRV_DEBUG_MONITOR != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   808  #define FEE_DBM_ERROR_ENTRIES   15
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   809  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   810  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   811  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   812      FEE_DBM_ERROR_ERASE_FCT_E,        /* Used in function Fee_LLEraseSector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   813      FEE_DBM_ERROR_LLMARKER_FCT_E,     /* USed in function Fee_LLWriteMarker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   814      FEE_DBM_ERROR_XX_E                /* not used yet....                   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   815  } Fee_DebugMonitoringFct_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   816  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   817  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   818  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   819      uint32                       xSecChngCntVal;             /* value of sector change counter while error occurs */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   820      uint16                       FeeBlkIdx;                  /* if the error couldn't be assigned to a NvmBlock, this is 0xFFFF */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   821      Fee_DebugMonitoringFct_ten   xError;                     /* error number */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   822      uint8                        xErrorInfo;                 /* error info, if necessary */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   823  } FeeDBMErrInfo_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   824  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   825  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   826  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   827      FeeDBMErrInfo_tst  xErrorEntry[FEE_DBM_ERROR_ENTRIES];  /* array of a structure with detail info to the errors */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   828      uint8   idxNewEntry;                /* index points on the next free entry in the xErrorEntry buffer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   829      uint8   ctBuffOverflow;             /* counter countrs how often the FEE_DBM_ERROR_ENTRIES error overflow. Startvalue is 1, used for ProtRAM validation! */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   830  } Fee_DebugMonitoring_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   831  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   832  #define FEE_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   833  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   834  extern Fee_DebugMonitoring_tst Fee_DebugMonitoring;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   835  #define FEE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   836  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   837  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   838  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   839  #if(FEE_ROBUST_PROG_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   840  /* Ifx robust programming */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   841  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   842  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   843      FEE_ROB_IFX_INIT,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   844      FEE_ROB_IFX_MARK_SECTOR,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   845      FEE_ROB_IFX_STORE_BUFFER,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   846      FEE_ROB_IFX_STORE_BUFFER_WAIT,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   847      FEE_ROB_IFX_COPY_DATA,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   848      FEE_ROB_IFX_STORE_COPY_WAIT,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   849      FEE_ROB_IFX_ERASE_SECTOR,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   850      FEE_ROB_IFX_WRITE_USED_MARK_SECTOR,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   851      FEE_ROB_SORT_SECTOR,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   852      FEE_ROB_IFX_FINISHED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   853  }Fee_RobIfxHdl_e;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   854  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   855  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   856  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   857      Fls_AddressType xStartAddress;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   858      uint8* DataBuffer;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   859      Fls_LengthType numBytes;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   860      uint16 offInBuf_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   861  }Fee_IfxRobustProgramming_t;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   862  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   863  #define FEE_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   864  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   865  extern Fee_IfxRobustProgramming_t Fee_IfxRobustProgramming_s;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   866  extern Fee_RobIfxHdl_e Fee_RobIfxHdl;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   867  #define FEE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   868  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   869  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   870  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   871  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   872  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_RobIfxHandling(uint8 xActLogWrSect_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   873  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   874  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   875  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   876  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   877  #if ((FEE_RB_MAINTAIN != FALSE) && (FEE_NO_FALLBACK_ACTIVE != FALSE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   878  /* Additional MainFunction write states in case NoFallback is activated */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   879  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   880  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   881      FEE_WRITE_NOFB_IDLE_E = 0,      /* Idle state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   882      FEE_WRITE_NOFB_MAINTAIN_E,      /* Maintain a NoFallback block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   883      FEE_WRITE_NOFB_BLOCK_E          /* Write a NoFallback block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   884  }Fee_WriteStateNoFb_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   885  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   886  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   887  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   888  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   889      uint32 Fee_Totalfree_bytes;    /* Total number of free bytes  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   890      uint32 Fee_hardThreshold;      /* Hard Threshold configures */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   891      uint32 Fee_softThershold;      /* Soft therosold configured*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   892  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   893  }Fee_FreeByte_thrshold_t;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   894  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   895  /*
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   896  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   897  * Extern declarations
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   898  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   899  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   900  /* Structures and variables */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   901  #define FEE_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   902  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   903  extern CONST(Fee_FlashProp_tst, FEE_CONST)          Fee_FlashProp_st[FEE_NUM_FLASH_BANKS_AVAILABLE];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   904  extern CONST (MemIf_JobResultType, AUTOMATIC)       Fee_JobTypeMapping[FEE_NUM_RET_VAL_E];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   905  extern CONST (Fee_LinkedFunctions_tst, FEE_CONST)   Fee_LinkedFunctions_cst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   906  #define FEE_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   907  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   908  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   909  #define FEE_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   910  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   911  extern P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA)       Fee_PageBytePtr_cpu8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   912  extern VAR(Fee_RdWrOrder_tst, AUTOMATIC)            Fee_RdWrOrder_st;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   913  extern VAR(Fee_LLSectorOrder_tst, AUTOMATIC)        Fee_LLSectorOrder_st[FEE_NUM_FLASH_BANKS_AVAILABLE];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   914  extern VAR(Fee_LLEraseOrderType_tst, AUTOMATIC)     Fee_LLEraseOrder_st;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   915  extern VAR(Fee_OrderFifo_tst, AUTOMATIC)            Fee_OrderFifo_st[FEE_QUEUE_SIZE];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   916  extern VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC) Fee_GlobInfoLastRdHeader_st;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   917  extern VAR(Fee_GlobInfoWrBlock_tst, FEE_VAR)        Fee_GlobInfoWrBlock_st;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   918  extern VAR(Fee_LLSecReorgStruct_tst, FEE_VAR)       Fee_LLSecReorgStruct_st;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   919  extern VAR(MemIf_JobResultType, AUTOMATIC)          Fee_JobResult[FEE_QUEUE_SIZE];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   920  #define FEE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   921  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   922  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   923  #define FEE_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   924  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   925  extern CONSTP2VAR(uint8, AUTOMATIC, FEE_APPL_DATA)  Fee_MarkerBufBytePtr_cpu8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   926  extern CONSTP2VAR(uint8, AUTOMATIC, FEE_APPL_DATA)  Fee_DataBytePtr_cpu8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   927  #define FEE_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   928  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   929  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   930  #define FEE_START_SEC_VAR_INIT_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   931  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   932  extern VAR(uint8, FEE_VAR)                          Fee_Prv_stInit_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   933  extern VAR(uint8, FEE_VAR)                          Fee_Prv_stReorg_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   934  extern VAR(uint8, FEE_VAR)                          Fee_NumFlashBanksUsed_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   935  extern VAR(uint8, AUTOMATIC)                        Fee_idxActQueueBackUp;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   936  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   937  /* Buffer to hold 2nd header page contents. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   938  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)    /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   939  extern VAR(uint8, AUTOMATIC) Fee_hdr2Buffer_au8[FEE_PAGE_LEN];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   940  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   941  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   942  /* Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   943  #if (defined(RBA_FLSIFX_FLASH) || defined(RBA_FLSJDP_FLASH))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   944  extern VAR(uint8, AUTOMATIC)                        Fee_hdrBuffer_au8[FEE_PAGE_LEN];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   945  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   946  /* END Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   947  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   948  #define FEE_STOP_SEC_VAR_INIT_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   949  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   950  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   951  #define FEE_START_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   952  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   953  extern VAR(MemIf_StatusType, FEE_VAR)               Fee_GlobModuleState_st;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   954  extern VAR(Fee_Rb_WorkingStateType_ten, AUTOMATIC)  Fee_Rb_WorkingStateBackUp_en;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   955  #define FEE_STOP_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   956  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   957  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   958  #define FEE_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   959  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   960  extern VAR(uint8, AUTOMATIC)                        Fee_idxLLSectorOrder_au8[FEE_NUM_FLASH_BANKS_AVAILABLE];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   961  extern VAR(uint8, FEE_VAR)                          Fee_idxActQueue_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   962  extern VAR(uint8, FEE_CONST)                        Fee_CacheUpdCompForSect_au8[FEE_NUM_FLASH_BANKS_AVAILABLE];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   963  extern VAR(uint8, AUTOMATIC)                        Fee_RdWrRetries_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   964  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   965  #if (FEE_RB_ACT_ERASE_SUSPENSION != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   966  extern VAR(boolean, AUTOMATIC) Fee_Prv_stSuspendActiv_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   967  extern VAR(boolean, AUTOMATIC) Fee_Prv_stHardReOrgErase_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   968  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   969  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   970  #if (FEE_RB_ADDONS_CCAS == TRUE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   971  extern VAR(boolean, AUTOMATIC) Fee_Rb_stRequestStopMode_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   972  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   973  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   974  #define FEE_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   975  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   976  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   977  #define FEE_START_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   978  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   979  extern VAR(uint32, AUTOMATIC)                       Fee_llMarkerPageBuf_au32[FEE_SEC_HEADER_SIZE / 4u];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   980  extern VAR(uint32, FEE_CONST)                       Fee_Cache_au32[FEE_NUM_BLOCKS];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   981  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   982  #if(FEE_ROB_FEATURE_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   983  extern VAR(uint32, AUTOMATIC)                       Fee_DataByteStartCrc_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   984  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   985  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   986  #define FEE_STOP_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   987  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   988  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   989  #define FEE_START_SEC_VAR_CLEARED_SECURED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   990  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   991  extern VAR(uint32, AUTOMATIC)                       Fee_llPageBuf_au32[(FEE_LL_PAGEBUFFSIZE / 4u) + 2u];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   992  extern VAR(uint32, AUTOMATIC)                       Fee_llDataBuf_au32[FEE_LL_DATABUFFSIZE / 4u];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   993  #define FEE_STOP_SEC_VAR_CLEARED_SECURED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   994  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   995  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   996  #ifdef FEE_PRV_USE_ROM_TABLE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   997  #define FEE_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   998  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   999  extern CONST(Fee_BlockPropertiesType_tst, FEE_CONST)  Fee_BlockProperties_st[FEE_NUM_BLOCKS];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1000  #define FEE_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1001  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1002  #else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1003  #define FEE_START_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1004  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1005  extern VAR(Fee_BlockPropertiesType_tst, AUTOMATIC)  Fee_BlockProperties_st[FEE_NUM_BLOCKS];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1006  #define FEE_STOP_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1007  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1008  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1009  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1010  #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1011  #define FEE_START_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1012  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1013  extern Fee_WriteStateNoFb_ten Fee_WriteStateNoFb_en;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1014  #define FEE_STOP_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1015  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1016  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1017  #define FEE_START_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1018  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1019  extern VAR(uint32, AUTOMATIC)   Fee_Rb_NoFallback_RemAdr_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1020  #define FEE_STOP_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1021  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1022  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1023  #define FEE_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1024  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1025  extern VAR(boolean, AUTOMATIC)  Fee_Rb_NoFallback_LastBlockCfg_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1026  extern VAR(boolean, AUTOMATIC)  Fee_Rb_InvalidateOldCopy_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1027  extern VAR(boolean, AUTOMATIC)  Fee_Rb_MaintainRun_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1028  #define FEE_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1029  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1030  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1031  #define FEE_START_SEC_CONST_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1032  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1033  extern const uint8 Fee_NoFallbackMarkerPattern[FEE_PAGES_USED_BY_BLK_HEADER * FEE_PAGE_LEN];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1034  #define FEE_STOP_SEC_CONST_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1035  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1036  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1037  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1038  #if((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) && (FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE != 0))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1039  /* Unknown blcok sector reorganiation with cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1040  #define FEE_START_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1041  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1042  extern VAR(uint32, AUTOMATIC) Fee_UnknownBlkCache_Addr_au32[FEE_RB_ACT_UNKNOWN_BLK_CACHE_ARRAY_SIZE];   /* Address of unknown block. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1043  #define FEE_STOP_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1044  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1045  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1046  #define FEE_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1047  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1048  extern VAR(uint16, AUTOMATIC) Fee_UnknownBlkCache_FeeIndex_u16[FEE_RB_ACT_UNKNOWN_BLK_CACHE_ARRAY_SIZE]; /* Index of unknown block. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1049  #define FEE_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1050  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1051  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1052  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1053  /* Lower Layer functions of the Fee */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1054  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1055  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1056  extern FUNC(uint32, FEE_CODE) Fee_CalculateNumOfFreeBytesInCurSector(VAR(uint32, FEE_VAR) DataEndAdr_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1057  extern FUNC(void, FEE_CODE)   Fee_InitVarAndState(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1058  extern FUNC(void, FEE_CODE)   Fee_InitCache(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1059  extern FUNC(void, FEE_CODE)   Fee_InitOrderFifoBuffer(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1060  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1061  /* Active sector detection */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1062  extern FUNC(void ,FEE_CODE)   Fee_LLSearchSectors(P2VAR(Fee_stSecDet_tst, AUTOMATIC, FEE_APPL_DATA) Fee_stSecDet_ps);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1063  extern FUNC(uint8, FEE_CODE)  Fee_LLDetectActiveSector(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1064  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLFindEmptyPage(uint8 PhySectIdxUsedSect_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1065  extern FUNC(uint8, FEE_CODE)  Fee_GetMostCurrentSectorIdx(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1066  extern FUNC(void, FEE_CODE)   Fee_CheckErasedSectorEmpty(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1067  extern FUNC(uint8, FEE_CODE)  Fee_GetPhysSectorByAddress(VAR(uint32, AUTOMATIC) Address_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1068  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1069  /* Marker handling */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1070  extern FUNC(Fee_stRetVal_ten,FEE_CODE)  Fee_LLWriteMarker(VAR(uint8, AUTOMATIC) PhySectIdx_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1071                                                            VAR(uint8, AUTOMATIC) MarkerID_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1072  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1073  /* Erase functions */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1074  extern FUNC(Fee_stRetVal_ten,FEE_CODE)  Fee_LLEraseSector(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1075  extern FUNC(void,FEE_CODE)              Fee_LLSetEraseSector(VAR(uint8, AUTOMATIC) EraseLogIdx);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1076  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1077  /* Block header access */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1078  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLSearchNextBlkHeader(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Fee_GlobInfoLastRdHeader_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1079                                                                    VAR(uint8, AUTOMATIC) CachedAccess_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1080                                                                    VAR(uint8, AUTOMATIC) FastCacheUpdate_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1081                                                                    VAR(boolean, AUTOMATIC) xForcePageBufReload_b,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1082                                                                    VAR(uint32, AUTOMATIC) strAddrHdrSearch);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1083  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1084  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLSearchSpecifiedBlkHeader(VAR(uint16, AUTOMATIC) FeeIdx_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1085                                                                         P2VAR(uint32, AUTOMATIC, FEE_APPL_DATA) LastHdrAddr_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1086                                                                         P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) GlobBlkHdr_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1087                                                                         VAR(boolean, AUTOMATIC) SearchRetry_b);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1088  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1089  #if((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1090  /* Unknown blcok sector reorganiation without cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1091  #if(FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE == 0)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1092  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLSearchUnknownBlkHeader(P2VAR(uint32, AUTOMATIC, FEE_APPL_DATA) StartHdrAddr_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1093                                                                       P2VAR(uint32, AUTOMATIC, FEE_APPL_DATA) LastHdrAddr_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1094                                                                       P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) GlobBlkHdr_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1095                                                                       P2VAR(boolean, AUTOMATIC, FEE_APPL_DATA) SearchRetry_ptr);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1096  #else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1097  /* Unknown blcok sector reorganiation with cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1098  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_BuildUpCacheUnknownBlk(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1099  #endif /* (FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE == 0) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1100  #endif /* ((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE)) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1101  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1102  extern FUNC(uint32, FEE_CODE) Fee_LLGetSecStartAddress(VAR(uint8, AUTOMATIC) xPhySectorIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1103  extern FUNC(uint32, FEE_CODE) Fee_LLGetSecEndAddress(VAR(uint8, AUTOMATIC) xPhySectorIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1104  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1105  /* Verification and handling of blocks */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1106  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLCompBlkInFlash(P2CONST(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) HeaderInfo_pcst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1107                                                               P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) Data_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1108  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLCalcBlkCrcInFlash(P2CONST(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) HeaderInfo_pcst);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1109  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLCpyBlkFromFls2Fls(P2CONST(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Fee_GlobInfoLastRdHeader_pcst, boolean Fee_WriteTwice_b);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1110  #if defined (FEE_PRV_ROBUST_SECT_OVERFLOW)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1111  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LlRobustSectorOverflow(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1112  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1113  extern FUNC(void, FEE_CODE)             Fee_LLPrepMarkerBufWithMarkerData(P2CONST(Fee_MarkerProp_t, AUTOMATIC, FEE_APPL_DATA) Marker_pcst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1114                                                                            P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) MarkerBuf_pu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1115  extern FUNC(void, FEE_CODE)             Fee_LLCopyPageBuff2Marker(P2VAR(Fee_MarkerProp_t, AUTOMATIC, FEE_APPL_DATA) Marker_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1116                                                                    P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1117  extern FUNC(void, FEE_CODE)             Fee_LLPrepPageBufWithHdrDataStart(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) HeaderInfo_pst);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1118  extern FUNC(void, FEE_CODE)             Fee_LLPrepPageBufWithHdrDataEnd(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) HeaderInfo_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1119                                                                                 P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) Data_pcu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1120                                                                                 VAR(uint32, AUTOMATIC) BlkCrc32_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1121  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1122  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1123  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1124  LOCAL_INLINE FUNC(void, FEE_CODE)       Fee_LLCopyPageBuff2HeaderStart(P2VAR(Fee_BlkHeader_tst, AUTOMATIC, FEE_APPL_DATA) BlkHdr_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1125                                                                         P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1126  #if(FEE_FAST_CACHE_INIT_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1127  LOCAL_INLINE FUNC(void, FEE_CODE)       Fee_LLCopyPageBuff2HeaderIdxAndCrc(P2VAR(Fee_BlkHeader_tst, AUTOMATIC, FEE_APPL_DATA) BlkHdr_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1128                                                                             P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1129  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1130  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1131  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1132  #if !( defined(RBA_FLSRH850P1xC_FLASH) || defined(RBA_FLSV850R1x_FLASH) || defined(RBA_FLSRH850xx_FLASH) )
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1133  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_SearchLastBlkHeader(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Fee_GlobInfoLastRdHeader_ptr);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1134  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1135  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1136  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1137  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1138  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1139  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1140  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1141  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1142  extern FUNC(uint32, FEE_CODE)           Fee_SearchHighestCacheEntry(VAR(uint32,FEE_VAR) UpperBoundary_u32, VAR(uint8, FEE_VAR) SectIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1143  extern FUNC(void, FEE_CODE)             Fee_InvalidateCacheByAddress(VAR(uint32,FEE_VAR) xAddress_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1144  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1145  extern FUNC(void, FEE_CODE)             Fee_LLCopyPageBuff2HeaderMid(P2VAR(Fee_BlkHeader_tst, AUTOMATIC, FEE_APPL_DATA) BlkHdr_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1146                                                                       P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1147  extern FUNC(void, FEE_CODE)             Fee_LLCopyPageBuff2HeaderEnd(P2VAR(Fee_BlkHeader_tst, AUTOMATIC, FEE_APPL_DATA) BlkHdr_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1148                                                                       P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1149  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLCopyData2Buffer(P2CONST(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Fee_GlobInfoLastRdHeader_pcst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1150                                                                    P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) DataPtr_pu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1151                                                                    VAR(uint16, FEE_VAR) DataOffset_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1152                                                                    VAR(uint16, FEE_VAR) DataLength_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1153  extern FUNC(void, FEE_CODE)             Fee_IncAddressInsideSector(P2VAR(uint32, AUTOMATIC, FEE_APPL_DATA) Address_u32,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1154                                                                     VAR(uint16, FEE_VAR) numBytes_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1155                                                                     VAR(boolean, FEE_VAR) EnsurePageAlign_b);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1156  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1157  /* Sector reorganization */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1158  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLCheckReorganizationNeed(VAR(uint32, AUTOMATIC) Threshold_u32,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1159                                                                        VAR(uint16, AUTOMATIC) DataLength_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1160  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLSectorReorganization(P2VAR(boolean, AUTOMATIC, FEE_APPL_DATA) SectReorgInterSt_pb);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1161  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1162  /* Block writes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1163  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_HLWriteBlock(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1164  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLWriteBlock(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Info_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1165                                                           P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) Data_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1166  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1167  /* Block reading */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1168  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_HLReadBlock(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1169  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLReadBlock(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Info_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1170                                                          P2VAR(uint8,AUTOMATIC, FEE_APPL_DATA) Data_ptr);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1171   #if(FEE_RB_MAINTAIN != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1172      /* Block maintaining*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1173      extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_HLMaintainBlock(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1174   #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1175  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1176  /* Order handling */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1177  extern FUNC(Std_ReturnType, FEE_CODE)   Fee_HLPlaceOrder(VAR(uint16, AUTOMATIC) Blocknumber_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1178                                                           VAR(uint16, AUTOMATIC) Offset_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1179                                                           P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) DataBufferPtr_pu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1180                                                           VAR(uint16, AUTOMATIC) Length_16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1181                                                           VAR(Fee_HlMode_ten, AUTOMATIC) Mode_en);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1182  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1183  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1184  /* Cache handling */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1185  extern FUNC(uint32, FEE_CODE) Fee_LLGetAddressFromCache(VAR(uint16, AUTOMATIC) FeeIdx_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1186  extern FUNC(boolean, FEE_CODE) Fee_LLCheckAddressInCache(VAR(uint32, AUTOMATIC) AdrInSector_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1187  extern FUNC(void, FEE_CODE)   Fee_LLUpdateAddressInCache(VAR(uint16, AUTOMATIC) FeeIdx_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1188                                                           VAR(uint32, AUTOMATIC) Addr_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1189  extern FUNC(void, FEE_CODE)  Fee_LLUpdateCacheStForSect(VAR(uint8, AUTOMATIC) PhySecIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1190  extern FUNC(void, FEE_CODE)  Fee_LLEraseCacheStForSect(VAR(uint8, AUTOMATIC) PhySecIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1191  extern FUNC(uint8, FEE_CODE) Fee_LLGetCacheUpdateStForSect(VAR(uint8, AUTOMATIC) PhySecIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1192  extern FUNC(uint8, FEE_CODE) Fee_LLGetCacheUpdateStForAllSect(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1193  extern FUNC(boolean, FEE_CODE) Fee_SrvBinarySearchInBlockProp(VAR(uint16, AUTOMATIC) FeeIdx_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1194                                                                P2VAR(uint16, AUTOMATIC, FEE_APPL_DATA) CacheIdx_pu16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1195  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1196  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1197  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1198  #if(FEE_FAST_CACHE_INIT_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1199  LOCAL_INLINE FUNC(boolean, FEE_CODE) Fee_SrvBinarySearchInBlockPropFast(VAR(uint16, AUTOMATIC) FeeIdx_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1200                                                                          P2VAR(uint16, AUTOMATIC, FEE_APPL_DATA) CacheIdx_pu16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1201  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1202  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1203  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1204  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_BuildUpCache(VAR(uint32, AUTOMATIC) StartAdr_u32,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1205                                                           VAR(uint32, AUTOMATIC) EndAdr_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1206  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_BuildUpCacheForAllSect(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1207  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1208  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1209  /* FEE_FAST_CACHE_INIT_ACTIVE != FALSE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1210  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1211  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1212  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1213  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1214  /* Services */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1215  extern FUNC(void, FEE_CODE)  Fee_SrvMemSet8(P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) xDest_pu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1216                                              VAR(uint32, FEE_VAR) xPattern_u32,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1217                                              VAR(uint32, FEE_VAR) numBytes_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1218  extern FUNC(void, FEE_CODE)  Fee_SrvMemCopy8(P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) xDest_pu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1219                                               P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) xSrc_pcu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1220                                               VAR(uint32, FEE_VAR) numBytes_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1221  extern FUNC(void, FEE_CODE)  Fee_SrvSetFifoMode(VAR(Fee_HlMode_ten, AUTOMATIC) Mode_en,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1222                                                  VAR(uint16, AUTOMATIC) xJobType_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1223  extern FUNC(Fee_HlMode_ten, FEE_CODE) Fee_SrvGetFifoMode(VAR(uint16, AUTOMATIC) xJobType_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1224  extern FUNC(void, FEE_CODE)           Fee_LoadNextOrder(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1225  extern FUNC(uint8, FEE_CODE)          Fee_SearchNextOrder(boolean isIntOrder_b);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1226  extern FUNC(void, FEE_CODE)           Fee_UpdateStatus(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1227  extern FUNC(void, FEE_CODE)           Fee_TriggerHardSectorReorg(VAR(Fee_Rb_WorkingStateType_ten, FEE_VAR) WorkingState_en);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1228  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1229  extern FUNC(Std_ReturnType, FEE_CODE) Fee_CheckBlockCfg(VAR(uint8, AUTOMATIC)  ApiId_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1230                                                             VAR(uint16, AUTOMATIC) BlockNum_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1231  extern FUNC(Std_ReturnType, FEE_CODE) Fee_CheckModuleSt(VAR(uint8, AUTOMATIC)  ApiId_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1232  extern FUNC(Std_ReturnType, FEE_CODE) Fee_CheckAdrPtr(VAR(uint8, AUTOMATIC) ApiId_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1233                                                        P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) DataBufferPtr_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1234  extern FUNC(Std_ReturnType, FEE_CODE) Fee_CheckBlkOfs(VAR(uint8, AUTOMATIC) ApiId_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1235                                                        VAR(uint16, AUTOMATIC) BlockNum_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1236                                                        VAR(uint16, AUTOMATIC) BlockOfs_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1237  extern FUNC(Std_ReturnType, FEE_CODE) Fee_CheckBlkLen(VAR(uint8, AUTOMATIC) ApiId_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1238                                                        VAR(uint16, AUTOMATIC) BlockNum_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1239                                                        VAR(uint16, AUTOMATIC) BlockOfs_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1240                                                        VAR(uint16, AUTOMATIC) BlockLen_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1241  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1242  /* Miscellaneous */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1243  extern FUNC(void, FEE_CODE)   Fee_CheckFlsJobResult(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1244  extern void (* Fee_Prv_ResetUsedSectors_pfn)(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1245  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1246  #if (FEE_PRV_DEBUG_MONITOR != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1247  extern FUNC(void ,FEE_CODE) Fee_DBM_RepError(VAR(uint16,FEE_VAR) FeeBlkIdx, VAR(Fee_DebugMonitoringFct_ten,FEE_VAR) xError, VAR(uint8,FEE_VAR) xErrorInfo);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1248  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1249  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1250  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1251  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1252  /*
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1253  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1254  * Inline functions (Necessary for fastening up the start up time)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1255  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1256  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1257  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1258   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1259   * Fee_LLCopyPageBuff2HeaderStart(): Extract the start of the block header data
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1260   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1261   * This function extracts the preamble of the block header data out
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1262   * of the page buffer (called every 8th byte of the flash).
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1263   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1264   * Hint: Block header structure:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1265   *       {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1266   *          uint8   Preamble_au8[3];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1267   *          uint8   BlkStatus_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1268   *          uint16  FeeIndex_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1269   *          uint16  BlkLength_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1270   *          uint16  HdrCrc16_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1271   *          uint32  BlkCrc32_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1272   *       }Fee_BlkHeader_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1273   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1274   * \param    BlkHdr_pst:    Pointer to the block header that was
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1275   *                          found in the flash.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1276   * \param    PageBuf_pu8:   Pointer to the page buffer
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1277   * \return
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1278   * \retval   none
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1279   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1280   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1281   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1282   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1283  LOCAL_INLINE FUNC(void, FEE_CODE) Fee_LLCopyPageBuff2HeaderStart(P2VAR(Fee_BlkHeader_tst, AUTOMATIC, FEE_APPL_DATA) BlkHdr_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1284                                                                   P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1285  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1286      BlkHdr_pst->Preamble_au8[0] = PageBuf_pcu8[0];      /* 0xA53C96 <- [0]: A5, [1]: 3C, [2]: 96 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1287      BlkHdr_pst->Preamble_au8[1] = PageBuf_pcu8[1];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1288      BlkHdr_pst->Preamble_au8[2] = PageBuf_pcu8[2];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1289  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1290  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1291  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1292  #if(FEE_FAST_CACHE_INIT_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1293  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1294   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1295   * Fee_LLCopyPageBuff2HeaderIdxAndCrc(): Extract the header checksum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1296   *  and the block index out of the block header data
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1297   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1298   * This function extracts the block header data out of the page buffer.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1299   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1300   * Hint: Block header structure:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1301   *       {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1302   *          uint8   Preamble_au8[3];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1303   *          uint8   BlkStatus_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1304   *          uint16  FeeIndex_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1305   *          uint16  BlkLength_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1306   *          uint16  HdrCrc16_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1307   *          uint32  BlkCrc32_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1308   *       }Fee_BlkHeader_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1309   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1310   * \param    BlkHdr_pst:    Pointer to the block header that was
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1311   *                          found in the flash.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1312   * \param    PageBuf_pcu8:  Pointer to the page buffer
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1313   * \return
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1314   * \retval   none
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1315   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1316   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1317   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1318   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1319  LOCAL_INLINE FUNC(void, FEE_CODE) Fee_LLCopyPageBuff2HeaderIdxAndCrc(P2VAR(Fee_BlkHeader_tst, AUTOMATIC, FEE_APPL_DATA) BlkHdr_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1320                                                                       P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1321  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1322      /* 0xD2E9 <- [4]: D2, [5]: E9 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1323      BlkHdr_pst->FeeIndex_u16    = (uint16)((uint16)(((uint16)(PageBuf_pcu8[4])) << 8u)  | (uint16)(PageBuf_pcu8[5]));
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1324  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1325      /* 0xABCD <- [8]: AB, [9]: CD */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1326      BlkHdr_pst->HdrCrc16_u16    = (uint16)((uint16)(((uint16)(PageBuf_pcu8[8])) << 8u)  | (uint16)(PageBuf_pcu8[9]));
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1327  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1328  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1329  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1330  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1331   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1332   * Fee_SrvBinarySearchInBlockProp(): Get the respective index out of
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1333   *                                   the block properties table
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1334   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1335   * This function searches for the respective block properties table
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1336   * index. In case unknown blocks are searched, the function will
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1337   * return with a negative response.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1338   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1339   * \param    FeeIdx_u16:    Fee index (persistent ID)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1340   * \param    CacheIdx_pu16: Pointer for the result
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1341   * \return   Success of the function
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1342   * \retval   FALSE: Corresponding index was not found
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1343   * \retval   TRUE:  Corresponding index was found
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1344   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1345   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1346   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1347   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1348   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1349  LOCAL_INLINE FUNC(boolean, FEE_CODE) Fee_SrvBinarySearchInBlockPropFast(VAR(uint16, AUTOMATIC) FeeIdx_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1350                                                                          P2VAR(uint16, AUTOMATIC, FEE_APPL_DATA) CacheIdx_pu16)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1351  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1352      VAR(boolean, AUTOMATIC)  xFuncRet_b = FALSE;    /* Function return value */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1353      VAR(uint16, AUTOMATIC)  xMid_u16;               /* Mid index for the search */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1354      VAR(uint16, AUTOMATIC)  xLeft_u16 = 0;          /* Left index for the search */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1355      VAR(uint16, AUTOMATIC)  xRight_u16 = FEE_NUM_BLOCKS - 1u; /* Right index for the search */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1356  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1357      /* Loop until the value is found */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1358      do
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1359      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1360          /* Divide search area by two */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1361          xMid_u16 = (uint16)(xLeft_u16 + ((xRight_u16 - xLeft_u16) / 2));
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1362  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1363          /* Check the cache content */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1364          if(Fee_BlockProperties_st[xMid_u16].BlockPersistentId_u16 == FeeIdx_u16)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1365          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1366              /* Index was found, set return value */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1367              *CacheIdx_pu16 = xMid_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1368  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1369              /* Return positive response */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1370              xFuncRet_b = TRUE;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1371  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1372              /* Leave the loop */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1373              return xFuncRet_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1374          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1375  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1376          /* Check the current array index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1377          if(Fee_BlockProperties_st[xMid_u16].BlockPersistentId_u16 > FeeIdx_u16)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1378          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1379              /* Check if the lowest array position is reached */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1380              if(xMid_u16 != 0)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1381              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1382                  /* Reduce the right limit to the left */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1383                  xRight_u16 = (uint16)(xMid_u16 - 1u);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1384              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1385              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1386              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1387                  /* Leave the loop with a negative response */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1388                  return xFuncRet_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1389              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1390          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1391          else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1392          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1393              /* Reduce the left limit to the right (upper limit is
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1394               * safe because of the loop condition) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1395              xLeft_u16 = (uint16)(xMid_u16 + 1u);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1396          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1397      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1398      while(xRight_u16 >= xLeft_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1399  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1400      return xFuncRet_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1401  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1402  /* FEE_FAST_CACHE_INIT_ACTIVE != FALSE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1403  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1404  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1405  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1406  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1407   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1408   * Fee_SrvRoundUp():
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1409   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1410   * This function takes the parameter value and rounds it up to the next
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1411   * multiple of the stepsize.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1412   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1413   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1414   * \param    value_u32: value to be rounded up
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1415   * \param    stepsize_u32: atomic steps to be made during the rounding
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1416   * \return   value rounded up to a multiple of the stepsize
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1417   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1418   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1419   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1420  LOCAL_INLINE uint32 Fee_SrvRoundUp(uint32 value_u32 , uint32 stepsize_u32)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1421  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1422      uint32 modValue_u32, retVal_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1423  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1424      retVal_u32 = value_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1425  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1426      modValue_u32 = value_u32 % stepsize_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1427  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1428      if(modValue_u32 != 0u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1429      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1430          retVal_u32 += stepsize_u32 - modValue_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1431      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1432  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1433      return retVal_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1434  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1435  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1436  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1437   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1438   * Fee_SrvCalcSpaceNeededForWrite():
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1439   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1440   * This function calculates the space required to perform a write operation based on a given block configuration
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1441   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1442   * \param    blockLen_u16:       data length to be writen
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1443   * \param    securityLevel_b:    single or double stored block?
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1444   * \param    noFallback_b: is the block configured as NoFallback?
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1445   * \return   space needed to write the block
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1446   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1447   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1448   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1449  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1450  LOCAL_INLINE uint32 Fee_SrvCalcSpaceNeededForWrite(uint16  blockLen_u16 , boolean securityLevel_b , boolean noFallback_b)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1451  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1452      uint32 neededSpace_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1453  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1454      // for all block types: blkSize + HdrSize
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1455      neededSpace_u32 = (uint32)FEE_BLOCK_OVERHEAD + (uint32)(blockLen_u16);
	add	d0,d0,#14
.L220:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1456  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1457  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1458  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1459      // force a page alignment of header and data size
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1460      neededSpace_u32 = Fee_SrvRoundUp(neededSpace_u32 , (uint32)FEE_PAGE_LEN);
	mov	d15,#8
.L183:
	div.u	e4,d0,d15
.L225:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1428      if(modValue_u32 != 0u)      (inlined)
	jeq	d5,#0,.L82
.L406:
	rsub	d15,d5,#8
.L407:
	add	d0,d15

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1428      if(modValue_u32 != 0u)      (inlined)
.L82:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1433      return retVal_u32;      (inlined)
	j	.L83

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1434  }      (inlined)
.L83:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1461  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1462  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1463  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1464      // for NoFallback blocks: add one page space for the NoFB header
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1465      // If NoFallback is deactivated, the parameter shall be loaded with FALSE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1466      if (noFallback_b)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1467      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1468          neededSpace_u32 += (uint32)FEE_PAGE_LEN;
	cadd	d0,d2,d0,#8

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1466      if (noFallback_b)      (inlined)
.L84:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1473      if(securityLevel_b)      (inlined)
	jeq	d1,#0,.L85
.L408:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1469      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1470  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1471  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1472      // double security blocks: check for space writing both block copies
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1473      if(securityLevel_b)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1474      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1475          neededSpace_u32 *= 2u;
	sh	d0,#1

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1473      if(securityLevel_b)      (inlined)
.L85:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1478      return neededSpace_u32;      (inlined)
	j	.L86

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1479  }      (inlined)
.L86:
	extr.u	d5,d0,#0,#16
.L181:
	mov	d4,#16392
.L409:
	call	Fee_LLCheckReorganizationNeed
.L224:
	jne	d2,#5,.L87
.L410:
	mov	d4,#4
	call	Fee_TriggerHardSectorReorg
.L411:
	j	.L88
.L87:
	movh.a	a15,#@his(Fee_Rb_WorkingState_en)
	lea	a15,[a15]@los(Fee_Rb_WorkingState_en)
.L412:
	mov	d15,#4
.L413:
	st.w	[a15],d15
.L414:
	movh.a	a15,#@his(Fee_GlobModuleState_st)
	lea	a15,[a15]@los(Fee_GlobModuleState_st)
.L415:
	mov	d15,#2
.L416:
	st.w	[a15],d15
.L88:
	j	.L89
.L60:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   809          default:
.L66:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   810          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   811              /* This state should never be reached */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   812              Fee_Rb_WorkingState_en = FEE_RB_IDLE_E;
	movh.a	a15,#@his(Fee_Rb_WorkingState_en)
	lea	a15,[a15]@los(Fee_Rb_WorkingState_en)
.L417:
	mov	d15,#0
.L418:
	st.w	[a15],d15
.L419:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   813          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   814          break;
	j	.L90

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   815      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   816  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   817      return;
.L90:
.L89:
.L81:
.L67:
	j	.L91

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   818  }
.L91:
	ret
.L146:
	
__Fee_LoadNextOrder_function_end:
	.size	Fee_LoadNextOrder,__Fee_LoadNextOrder_function_end-Fee_LoadNextOrder
.L122:
	; End of function
	
	.sdecl	'.text.rba_FeeFs1_MainFunction.Fee_SearchNextOrder',code,cluster('Fee_SearchNextOrder')
	.sect	'.text.rba_FeeFs1_MainFunction.Fee_SearchNextOrder'
	.align	2
	
	.global	Fee_SearchNextOrder

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   819  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   820  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   821   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   822   * Fee_SrvSearchNextOrder(): search the next possible order in queue
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   823   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   824   * This function searchs the next orders from the queue.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   825   * It has to be called only internally by the Fee's module.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   826   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   827   * \param    boolean isIntOrder_b  check if internal order also found
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   828   * \return
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   829   * \retval   uint8 queue number
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   830   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   831   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   832   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   833   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   834  /* MR12 RULE 1505 VIOLATION: This function is used within the same file and has no external linkage */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   835  uint8 Fee_SearchNextOrder(boolean isIntOrder_b)
; Function Fee_SearchNextOrder
.L106:
Fee_SearchNextOrder:	.type	func
	mov	d8,d4
.L226:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   836  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   837      VAR(uint8, AUTOMATIC) i;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   838      VAR(uint8, AUTOMATIC) idxActQueue_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   839      VAR(uint8, AUTOMATIC) idexHighPrioOrder_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   840  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   841      /* Check if a new job is in the queue. There are 2 prioritisations possible:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   842       *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   843       * 1. prioritisation of the job
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   844       *    If a block is configured for FeeImmediateData=yes, this block will processed before the blocks
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   845       *    with a normal priority (FeeImmediateData=no)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   846       *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   847       * 2. prioritisation of the job type:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   848       *    If there are 2 orders with the same priority, the following defined prioritisation will be used:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   849       *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   850       *   Low
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   851       *    |     Adapter orders
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   852       *    |     Nvm orders
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   853       *    V     Fee - internal orders
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   854       *   High
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   855       *  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   856  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   857      /* Reset high prio order index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   858      idexHighPrioOrder_u8 = (uint8)FEE_QUEUE_SIZE;
	mov	d9,#3
.L227:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   859  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   860      /* Reset queue activity index for order processing */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   861      idxActQueue_u8 = (uint8)FEE_QUEUE_SIZE;
	mov	d10,#3
.L228:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   862  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   863      /* Loop over order queue */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   864      for(i=0; i<(uint8)FEE_QUEUE_SIZE; i++)
	mov	d11,#0
.L229:
	j	.L92
.L93:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   865      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   866          /* Check for an available queue entry */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   867          /* For idle state: no matter if it's internal job in running, new order can be accepted;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   868           * For suspending during erase: no internal order can be accepted */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   869          if((Fee_SrvGetFifoMode(i) != FEE_NO_ORDER) && (isIntOrder_b || (i != (uint8)FEE_INTERNAL_JOB)))
	mov	d4,d11
.L230:
	call	Fee_SrvGetFifoMode
.L231:
	jeq	d2,#0,.L94
.L424:
	jne	d8,#0,.L95
.L425:
	jeq	d11,#0,.L96
.L95:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   870          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   871              /* A new order was found */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   872  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   873              /* Set the queue activity index to the current entry */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   874              idxActQueue_u8 = i;
	mov	d10,d11
.L426:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   875  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   876              /* If there is no order with a high priority available, the last found index will be assigned to
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   877               * the Fee_idxActQueue_u8 because last entry in Fee_HlJobType_ten has the highest priority.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   878               * --> Last found order will be taken
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   879               */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   880              /* Check for available high prio orders */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   881              if(Fee_OrderFifo_st[i].Prio_en == FEE_HIGH_PRIO_E)
	mul	d15,d11,#24
.L427:
	movh.a	a15,#@his(Fee_OrderFifo_st)
	lea	a15,[a15]@los(Fee_OrderFifo_st)
.L428:
	addsc.a	a15,a15,d15,#0
.L429:
	ld.w	d15,[a15]16
.L430:
	eq	d15,d15,#1
.L431:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   882              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   883                  /* This is the first high prio order */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   884                  idexHighPrioOrder_u8 = i;
	cmov	d9,d15,d11
.L97:
	j	.L98
.L96:
.L94:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   885              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   886          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   887          else
.L98:
	add	d11,#1
.L92:
	jlt.u	d11,#3,.L93
.L432:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   888          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   889              /* Do nothing */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   890          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   891      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   892  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   893      /* Check for available high prio orders */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   894      if(idexHighPrioOrder_u8 != (uint8)FEE_QUEUE_SIZE)
	eq	d15,d9,#3
.L433:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   895      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   896          /* At least one order with priority 1 was found, reset the queue activity index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   897          idxActQueue_u8 = idexHighPrioOrder_u8;
	cmovn	d10,d15,d9
.L99:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   898      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   899  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   900      return idxActQueue_u8;
	mov	d2,d10
.L232:
	j	.L100

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   901  }
.L100:
	ret
.L186:
	
__Fee_SearchNextOrder_function_end:
	.size	Fee_SearchNextOrder,__Fee_SearchNextOrder_function_end-Fee_SearchNextOrder
.L127:
	; End of function
	
	.sdecl	'.text.rba_FeeFs1_MainFunction.Fee_TriggerHardSectorReorg',code,cluster('Fee_TriggerHardSectorReorg')
	.sect	'.text.rba_FeeFs1_MainFunction.Fee_TriggerHardSectorReorg'
	.align	2
	
	.global	Fee_TriggerHardSectorReorg

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   902  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   903  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   904   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   905   * Fee_TriggerHardSectorReorg(): Triggers a hard sector reorganization
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   906   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   907   * This function saves the passed working state and triggers a
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   908   * a hard sector reorganization
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   909   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   910   * \param    Fee_Rb_WorkingStateType_ten    Current working state
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   911   * \return
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   912   * \retval   none
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   913   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   914   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   915   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   916   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   917  /* MR12 RULE 1505 VIOLATION: This function is used within the same file and has no external linkage */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   918  FUNC(void, FEE_CODE) Fee_TriggerHardSectorReorg(VAR(Fee_Rb_WorkingStateType_ten, FEE_VAR) WorkingState_en)
; Function Fee_TriggerHardSectorReorg
.L108:
Fee_TriggerHardSectorReorg:	.type	func

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   919  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   920      /* Save the current working state and queue index in order to come back afterwards */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   921      Fee_Rb_WorkingStateBackUp_en = WorkingState_en;
	movh.a	a15,#@his(Fee_Rb_WorkingStateBackUp_en)
	lea	a15,[a15]@los(Fee_Rb_WorkingStateBackUp_en)
.L438:
	st.w	[a15],d4
.L439:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   922      Fee_idxActQueueBackUp        = Fee_idxActQueue_u8;
	movh.a	a15,#@his(Fee_idxActQueue_u8)
	lea	a15,[a15]@los(Fee_idxActQueue_u8)
.L440:
	movh.a	a2,#@his(Fee_idxActQueueBackUp)
	lea	a2,[a2]@los(Fee_idxActQueueBackUp)
.L441:
	ld.bu	d15,[a15]
.L442:
	st.b	[a2],d15
.L443:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   923  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   924      #if (FEE_RB_ACT_ERASE_SUSPENSION != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   925      /* Set for no suspend possible */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   926      Fee_Prv_stHardReOrgErase_b = TRUE;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   927  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   928      /* Resume if suspend active */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   929      if(Fee_Prv_stSuspendActiv_b != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   930      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   931          /* Check if the resume is accepted */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   932          if(Fls_Rb_Resume(FEE_PHYS_SEC_START0) == E_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   933          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   934              /* Set internal working state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   935              Fee_Rb_WorkingState_en = FEE_RB_SECTOR_ERASE_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   936          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   937          else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   938          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   939              /* No error reaction necessary */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   940              ;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   941          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   942      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   943      else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   944      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   945      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   946          /* Set internal working state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   947          Fee_Rb_WorkingState_en = FEE_RB_HARD_SECTOR_REORG_MODE_E;
	movh.a	a2,#@his(Fee_Rb_WorkingState_en)
	lea	a2,[a2]@los(Fee_Rb_WorkingState_en)
.L444:
	mov	d15,#6
.L445:
	st.w	[a2],d15
.L446:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   948      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   949  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   950      /* Set the job type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   951      Fee_idxActQueue_u8 = (uint8)FEE_INTERNAL_JOB;
	mov	d15,#0
.L447:
	st.b	[a15],d15
.L448:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   952  }
	ret
.L191:
	
__Fee_TriggerHardSectorReorg_function_end:
	.size	Fee_TriggerHardSectorReorg,__Fee_TriggerHardSectorReorg_function_end-Fee_TriggerHardSectorReorg
.L132:
	; End of function
	
	.sdecl	'.rodata.rba_FeeFs1_MainFunction.Fee_JobTypeMapping',data,rom,cluster('Fee_JobTypeMapping')
	.sect	'.rodata.rba_FeeFs1_MainFunction.Fee_JobTypeMapping'
	.global	Fee_JobTypeMapping
	.align	4
Fee_JobTypeMapping:	.type	object
	.size	Fee_JobTypeMapping,36
	.word	2
	.space	4
	.word	5,4,2,2
	.word	1,2,2
	.sdecl	'.data.rba_FeeFs1_MainFunction.Fee_Rb_WorkingStateBackUp_en',data,cluster('Fee_Rb_WorkingStateBackUp_en')
	.sect	'.data.rba_FeeFs1_MainFunction.Fee_Rb_WorkingStateBackUp_en'
	.global	Fee_Rb_WorkingStateBackUp_en
	.align	4
Fee_Rb_WorkingStateBackUp_en:	.type	object
	.size	Fee_Rb_WorkingStateBackUp_en,4
	.space	4
	.sdecl	'.data.rba_FeeFs1_MainFunction.Fee_idxActQueueBackUp',data,cluster('Fee_idxActQueueBackUp')
	.sect	'.data.rba_FeeFs1_MainFunction.Fee_idxActQueueBackUp'
	.global	Fee_idxActQueueBackUp
Fee_idxActQueueBackUp:	.type	object
	.size	Fee_idxActQueueBackUp,1
	.byte	3
	.calls	'Fee_MainFunction','Fee_SearchNextOrder'
	.calls	'Fee_MainFunction','Fee_LoadNextOrder'
	.calls	'Fee_MainFunction','Fee_LLSetEraseSector'
	.calls	'Fee_MainFunction','Fee_LLCheckReorganizationNeed'
	.calls	'Fee_MainFunction','Fee_HLWriteBlock'
	.calls	'Fee_MainFunction','Fee_TriggerHardSectorReorg'
	.calls	'Fee_MainFunction','Fee_HLMaintainBlock'
	.calls	'Fee_MainFunction','Fee_HLReadBlock'
	.calls	'Fee_MainFunction','Fee_LLEraseSector'
	.calls	'Fee_MainFunction','Fee_LLSectorReorganization'
	.calls	'Fee_MainFunction','__INDIRECT__'
	.calls	'Fee_MainFunction','Fee_SrvSetFifoMode'
	.calls	'Fee_MainFunction','Fee_UpdateStatus'
	.calls	'Fee_LoadNextOrder','Fee_LLCheckReorganizationNeed'
	.calls	'Fee_LoadNextOrder','Fee_TriggerHardSectorReorg'
	.calls	'Fee_SearchNextOrder','Fee_SrvGetFifoMode'
	.calls	'Fee_MainFunction','',8
	.calls	'Fee_LoadNextOrder','',0
	.calls	'Fee_SearchNextOrder','',0
	.extern	Fee_Rb_WorkingState_en
	.extern	Fee_LLSectorOrder_st
	.extern	Fee_OrderFifo_st
	.extern	Fee_JobResult
	.extern	Fee_Prv_stInit_u8
	.extern	Fee_NumFlashBanksUsed_u8
	.extern	Fee_GlobModuleState_st
	.extern	Fee_idxActQueue_u8
	.extern	Fee_BlockProperties_st
	.extern	Fee_LLEraseSector
	.extern	Fee_LLSetEraseSector
	.extern	Fee_LLCheckReorganizationNeed
	.extern	Fee_LLSectorReorganization
	.extern	Fee_HLWriteBlock
	.extern	Fee_HLReadBlock
	.extern	Fee_HLMaintainBlock
	.extern	Fee_SrvSetFifoMode
	.extern	Fee_SrvGetFifoMode
	.extern	Fee_UpdateStatus
	.extern	__INDIRECT__
	.calls	'Fee_TriggerHardSectorReorg','',0
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L110:
	.word	16243
	.half	3
	.word	.L111
	.byte	4
.L109:
	.byte	1
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_MainFunction.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L112
.L165:
	.byte	2
	.byte	'unsigned int',0,4,7
.L167:
	.byte	3
	.byte	'Fee_SrvRoundUp',0,3,1,140,11,21
	.word	156
	.byte	1,1
.L169:
	.byte	4
	.byte	'value_u32',0,1,140,11,43
	.word	156
.L171:
	.byte	4
	.byte	'stepsize_u32',0,1,140,11,62
	.word	156
.L173:
	.byte	5,0
.L147:
	.byte	2
	.byte	'unsigned short int',0,2,7
.L140:
	.byte	2
	.byte	'unsigned char',0,1,8
.L155:
	.byte	3
	.byte	'Fee_SrvCalcSpaceNeededForWrite',0,3,1,170,11,21
	.word	156
	.byte	1,1
.L158:
	.byte	4
	.byte	'blockLen_u16',0,1,170,11,60
	.word	242
.L160:
	.byte	4
	.byte	'securityLevel_b',0,1,170,11,83
	.word	264
.L162:
	.byte	4
	.byte	'noFallback_b',0,1,170,11,109
	.word	264
.L164:
	.byte	6,5,0,0
.L142:
	.byte	7,1,137,2,9,4,8
	.byte	'FEE_ORDER_PENDING_E',0,0,8
	.byte	'FEE_ORDER_FINISHED_E',0,1,8
	.byte	'FEE_BLOCK_INVALIDATED_E',0,2,8
	.byte	'FEE_ERROR_E',0,3,8
	.byte	'FEE_SECTORCHANGE_E',0,4,8
	.byte	'FEE_SECTORFULL_E',0,5,8
	.byte	'FEE_ABORTED_E',0,6,8
	.byte	'FEE_ERASE_SECTOR_E',0,7,8
	.byte	'FEE_SEARCH_ABORTED_E',0,8,8
	.byte	'FEE_NUM_RET_VAL_E',0,9,0,9
	.byte	'Fee_LLEraseSector',0,1,178,8,41
	.word	397
	.byte	1,1,1,1,10
	.byte	'Fee_LLSetEraseSector',0,1,179,8,41,1,1,1,1,4
	.byte	'EraseLogIdx',0,1,179,8,84
	.word	264
	.byte	0,11
	.byte	'Fee_LLCheckReorganizationNeed',0,1,134,9,41
	.word	397
	.byte	1,1,1,1,4
	.byte	'Threshold_u32',0,1,134,9,94
	.word	156
	.byte	4
	.byte	'DataLength_u16',0,1,135,9,94
	.word	242
	.byte	0,12
	.word	264
	.byte	11
	.byte	'Fee_LLSectorReorganization',0,1,136,9,41
	.word	397
	.byte	1,1,1,1,4
	.byte	'SectReorgInterSt_pb',0,1,136,9,109
	.word	783
	.byte	0,9
	.byte	'Fee_HLWriteBlock',0,1,139,9,41
	.word	397
	.byte	1,1,1,1,9
	.byte	'Fee_HLReadBlock',0,1,144,9,41
	.word	397
	.byte	1,1,1,1,9
	.byte	'Fee_HLMaintainBlock',0,1,149,9,45
	.word	397
	.byte	1,1,1,1,7,2,122,9,4,8
	.byte	'FEE_NO_ORDER',0,0,8
	.byte	'FEE_READ_ORDER',0,1,8
	.byte	'FEE_WRITE_ORDER',0,2,8
	.byte	'FEE_INVALIDATE_ORDER',0,3,8
	.byte	'FEE_MAINTAIN_ORDER',0,4,8
	.byte	'FEE_FORCED_READ_ORDER',0,5,0,10
	.byte	'Fee_SrvSetFifoMode',0,1,197,9,30,1,1,1,1,4
	.byte	'Mode_en',0,1,197,9,80
	.word	950
	.byte	4
	.byte	'xJobType_u16',0,1,198,9,72
	.word	242
	.byte	0,11
	.byte	'Fee_SrvGetFifoMode',0,1,199,9,39
	.word	950
	.byte	1,1,1,1,4
	.byte	'xJobType_u16',0,1,199,9,81
	.word	242
	.byte	0,13
	.byte	'Fee_UpdateStatus',0,1,202,9,39,1,1,1,1
.L192:
	.byte	7,2,170,1,9,4,8
	.byte	'FEE_RB_IDLE_E',0,0,8
	.byte	'FEE_RB_WRITE_MODE_E',0,1,8
	.byte	'FEE_RB_READ_MODE_E',0,2,8
	.byte	'FEE_RB_INVALIDATE_MODE_E',0,3,8
	.byte	'FEE_RB_MAINTAIN_MODE_E',0,4,8
	.byte	'FEE_RB_SOFT_SECTOR_REORG_MODE_E',0,5,8
	.byte	'FEE_RB_HARD_SECTOR_REORG_MODE_E',0,6,8
	.byte	'FEE_RB_SECTOR_ERASE_E',0,7,8
	.byte	'FEE_RB_STOPMODE_E',0,8,0,14
	.word	172
	.byte	15
	.word	199
	.byte	15
	.word	218
	.byte	5,0,14
	.word	281
	.byte	15
	.word	324
	.byte	15
	.word	346
	.byte	15
	.word	371
	.byte	6,16
	.word	172
	.byte	15
	.word	199
	.byte	15
	.word	218
	.byte	17
	.word	240
	.byte	0,5,0,0,18
	.byte	'__INDIRECT__',0,3,1,1,1,1,1,19,1,12
	.word	1535
	.byte	20
	.byte	'__codeptr',0,3,1,1
	.word	1537
	.byte	2
	.byte	'char',0,1,6,20
	.byte	'sint8',0,4,76,25
	.word	1560
	.byte	20
	.byte	'uint8',0,4,81,25
	.word	264
	.byte	20
	.byte	'uint16',0,4,91,25
	.word	242
	.byte	20
	.byte	'uint32',0,4,106,24
	.word	156
	.byte	2
	.byte	'unsigned long long int',0,8,7,20
	.byte	'uint64',0,4,111,30
	.word	1626
	.byte	20
	.byte	'boolean',0,4,127,25
	.word	264
	.byte	20
	.byte	'StatusType',0,5,191,1,27
	.word	264
	.byte	20
	.byte	'Std_ReturnType',0,5,199,1,15
	.word	264
	.byte	21,5,206,1,9,8,22
	.byte	'vendorID',0
	.word	242
	.byte	2,2,35,0,22
	.byte	'moduleID',0
	.word	242
	.byte	2,2,35,2,22
	.byte	'sw_major_version',0
	.word	264
	.byte	1,2,35,4,22
	.byte	'sw_minor_version',0
	.word	264
	.byte	1,2,35,5,22
	.byte	'sw_patch_version',0
	.word	264
	.byte	1,2,35,6,0,20
	.byte	'Std_VersionInfoType',0,5,213,1,3
	.word	1727
	.byte	21,6,93,9,8,22
	.byte	'Class',0
	.word	264
	.byte	1,2,35,0,22
	.byte	'TIN',0
	.word	264
	.byte	1,2,35,1,22
	.byte	'ReturnAddress',0
	.word	156
	.byte	4,2,35,4,0,20
	.byte	'OsTrapInfoType',0,6,97,3
	.word	1877
	.byte	23,68
	.word	156
	.byte	24,16,0,21,6,154,1,9,68,22
	.byte	'store',0
	.word	1957
	.byte	68,2,35,0,0,23,68
	.word	1966
	.byte	24,0,0,20
	.byte	'Os_JumpBufType',0,6,156,1,3
	.word	1988
	.byte	20
	.byte	'Os_StackTraceType',0,6,174,1,18
	.word	156
	.byte	21,6,175,1,9,8,22
	.byte	'sp',0
	.word	156
	.byte	4,2,35,0,22
	.byte	'ctx',0
	.word	156
	.byte	4,2,35,4,0,20
	.byte	'Os_StackValueType',0,6,175,1,63
	.word	2048
	.byte	20
	.byte	'Os_StackSizeType',0,6,176,1,27
	.word	2048
	.byte	25,1,1,12
	.word	2133
	.byte	20
	.byte	'Os_VoidVoidFunctionType',0,6,179,1,16
	.word	2136
	.byte	20
	.byte	'ApplicationType',0,6,193,1,23
	.word	264
	.byte	26
	.byte	'Os_ApplicationConfigurationType_s',0,6,198,1,16,2,22
	.byte	'app_id',0
	.word	264
	.byte	1,2,35,0,22
	.byte	'access',0
	.word	264
	.byte	1,2,35,1,0,20
	.byte	'Os_ApplicationConfigurationType',0,6,201,1,3
	.word	2199
	.byte	20
	.byte	'Os_CoreStateType',0,6,203,1,16
	.word	156
	.byte	20
	.byte	'AreaIdType',0,6,204,1,16
	.word	242
	.byte	20
	.byte	'Os_PeripheralAddressType',0,6,212,1,22
	.word	156
	.byte	20
	.byte	'TickType',0,6,221,1,22
	.word	156
	.byte	20
	.byte	'Os_StopwatchTickType',0,6,225,1,22
	.word	156
	.byte	12
	.word	156
	.byte	20
	.byte	'Os_Lockable',0,6,234,1,18
	.word	2441
	.byte	20
	.byte	'CoreIdType',0,6,236,1,16
	.word	242
	.byte	20
	.byte	'SpinlockIdType',0,6,237,1,16
	.word	242
	.byte	7,6,239,1,9,4,8
	.byte	'TRYTOGETSPINLOCK_SUCCESS',0,0,8
	.byte	'TRYTOGETSPINLOCK_NOSUCCESS',0,1,0,20
	.byte	'TryToGetSpinlockType',0,6,239,1,74
	.word	2511
	.byte	7,6,174,2,9,4,8
	.byte	'APPLICATION_ACCESSIBLE',0,0,8
	.byte	'APPLICATION_RESTARTING',0,1,8
	.byte	'APPLICATION_TERMINATED',0,2,0,20
	.byte	'ApplicationStateType',0,6,174,2,92
	.word	2604
	.byte	27
	.byte	'void',0,12
	.word	2716
	.byte	28,1,1,29
	.word	264
	.byte	29
	.word	2722
	.byte	0,12
	.word	2727
	.byte	20
	.byte	'Os_FunctionEntryType',0,6,183,2,16
	.word	2741
	.byte	26
	.byte	'Os_MeterInfoType_s',0,6,193,2,16,48,22
	.byte	'elapsed',0
	.word	156
	.byte	4,2,35,0,22
	.byte	'previous',0
	.word	156
	.byte	4,2,35,4,22
	.byte	'max',0
	.word	156
	.byte	4,2,35,8,22
	.byte	'cumulative',0
	.word	156
	.byte	4,2,35,12,22
	.byte	'stackbase',0
	.word	2048
	.byte	8,2,35,16,22
	.byte	'stackusage',0
	.word	2048
	.byte	8,2,35,24,22
	.byte	'stackmax',0
	.word	2048
	.byte	8,2,35,32,22
	.byte	'stackbudget',0
	.word	2048
	.byte	8,2,35,40,0,20
	.byte	'Os_MeterInfoType',0,6,202,2,3
	.word	2776
	.byte	12
	.word	2776
	.byte	20
	.byte	'Os_MeterInfoRefType',0,6,203,2,50
	.word	2974
	.byte	20
	.byte	'EventMaskType',0,6,206,2,15
	.word	264
	.byte	20
	.byte	'Os_imaskType',0,6,211,2,16
	.word	156
	.byte	26
	.byte	'Os_ISRDynType_s',0,6,213,2,16,48,22
	.byte	'meter',0
	.word	2776
	.byte	48,2,35,0,0,20
	.byte	'Os_ISRDynType',0,6,215,2,3
	.word	3053
	.byte	12
	.word	3053
	.byte	30
	.word	3114
	.byte	26
	.byte	'Os_ISRType_s',0,6,216,2,16,24,22
	.byte	'entry_function',0
	.word	2141
	.byte	4,2,35,0,22
	.byte	'dynamic',0
	.word	3119
	.byte	4,2,35,4,22
	.byte	'imask',0
	.word	156
	.byte	4,2,35,8,22
	.byte	'stackbudget',0
	.word	2048
	.byte	8,2,35,12,22
	.byte	'access',0
	.word	264
	.byte	1,2,35,20,22
	.byte	'application',0
	.word	264
	.byte	1,2,35,21,0,20
	.byte	'Os_ISRType',0,6,223,2,3
	.word	3124
	.byte	12
	.word	2133
	.byte	30
	.word	3124
	.byte	12
	.word	3283
	.byte	20
	.byte	'ISRType',0,6,224,2,46
	.word	3288
	.byte	20
	.byte	'Os_bitmask',0,6,239,2,22
	.word	156
	.byte	20
	.byte	'Os_pset0Type',0,6,240,2,20
	.word	156
	.byte	20
	.byte	'Os_pset1Type',0,6,241,2,20
	.word	156
	.byte	20
	.byte	'Os_pset2Type',0,6,242,2,20
	.word	156
	.byte	31,6,243,2,9,4,22
	.byte	'p0',0
	.word	156
	.byte	4,2,35,0,22
	.byte	'p1',0
	.word	156
	.byte	4,2,35,0,22
	.byte	'p2',0
	.word	156
	.byte	4,2,35,0,0,20
	.byte	'Os_psetType',0,6,247,2,3
	.word	3396
	.byte	31,6,249,2,9,4,22
	.byte	't0',0
	.word	156
	.byte	4,2,35,0,22
	.byte	't1',0
	.word	156
	.byte	4,2,35,0,22
	.byte	't2',0
	.word	156
	.byte	4,2,35,0,0,20
	.byte	'Os_tpmaskType',0,6,253,2,3
	.word	3460
	.byte	20
	.byte	'Os_ActivationCountType',0,6,254,2,23
	.word	264
	.byte	26
	.byte	'Os_TaskDynType_s',0,6,128,3,16,120,22
	.byte	'terminate_jump_buf',0
	.word	1997
	.byte	68,2,35,0,22
	.byte	'meter',0
	.word	2776
	.byte	48,2,35,68,22
	.byte	'activation_count',0
	.word	264
	.byte	1,2,35,116,0,20
	.byte	'Os_TaskDynType',0,6,132,3,3
	.word	3558
	.byte	23,68
	.word	1966
	.byte	24,0,0,12
	.word	3558
	.byte	30
	.word	3684
	.byte	26
	.byte	'Os_TaskType_s',0,6,134,3,16,40,22
	.byte	'dynamic',0
	.word	3689
	.byte	4,2,35,0,22
	.byte	'entry_function',0
	.word	2141
	.byte	4,2,35,4,22
	.byte	'pset',0
	.word	3396
	.byte	4,2,35,8,22
	.byte	'base_tpmask',0
	.word	3460
	.byte	4,2,35,12,22
	.byte	'tpmask',0
	.word	3460
	.byte	4,2,35,16,22
	.byte	'core_id',0
	.word	242
	.byte	2,2,35,20,22
	.byte	'index',0
	.word	156
	.byte	4,2,35,24,22
	.byte	'stackbudget',0
	.word	2048
	.byte	8,2,35,28,22
	.byte	'activation_count',0
	.word	264
	.byte	1,2,35,36,22
	.byte	'access',0
	.word	264
	.byte	1,2,35,37,22
	.byte	'application',0
	.word	264
	.byte	1,2,35,38,0,20
	.byte	'Os_TaskType',0,6,146,3,3
	.word	3694
	.byte	30
	.word	3694
	.byte	12
	.word	3944
	.byte	20
	.byte	'TaskType',0,6,147,3,47
	.word	3949
	.byte	32
	.byte	'Os_TaskStateType',0,6,155,3,6,4,8
	.byte	'SUSPENDED',0,0,8
	.byte	'READY',0,1,8
	.byte	'WAITING',0,2,8
	.byte	'RUNNING',0,3,0,20
	.byte	'TaskStateType',0,6,156,3,31
	.word	3972
	.byte	31,6,167,3,3,4,22
	.byte	'tpmask',0
	.word	3460
	.byte	4,2,35,0,0,26
	.byte	'Os_ResourceDynType_s',0,6,166,3,16,4,22
	.byte	'saved_priority',0
	.word	4059
	.byte	4,2,35,0,0,20
	.byte	'Os_ResourceDynType',0,6,170,3,3
	.word	4082
	.byte	12
	.word	4082
	.byte	30
	.word	4162
	.byte	26
	.byte	'Os_ResourceType_s',0,6,171,3,16,12,22
	.byte	'dynamic',0
	.word	4167
	.byte	4,2,35,0,22
	.byte	'tpmask',0
	.word	3460
	.byte	4,2,35,4,22
	.byte	'access',0
	.word	264
	.byte	1,2,35,8,0,20
	.byte	'Os_ResourceType',0,6,175,3,3
	.word	4172
	.byte	21,6,181,3,9,12,22
	.byte	'maxallowedvalue',0
	.word	156
	.byte	4,2,35,0,22
	.byte	'ticksperbase',0
	.word	156
	.byte	4,2,35,4,22
	.byte	'mincycle',0
	.word	156
	.byte	4,2,35,8,0,20
	.byte	'AlarmBaseType',0,6,185,3,3
	.word	4271
	.byte	21,6,206,3,9,8,22
	.byte	'Running',0
	.word	264
	.byte	1,2,35,0,22
	.byte	'Pending',0
	.word	264
	.byte	1,2,35,1,22
	.byte	'Delay',0
	.word	156
	.byte	4,2,35,4,0,20
	.byte	'Os_CounterStatusType',0,6,210,3,3
	.word	4366
	.byte	33
	.word	264
	.byte	1,1,12
	.word	4452
	.byte	20
	.byte	'Os_CounterIncrAdvType',0,6,217,3,22
	.word	4459
	.byte	26
	.byte	's_swd',0,6,222,3,12,4,22
	.byte	'count',0
	.word	156
	.byte	4,2,35,0,0,31,6,221,3,3,4,22
	.byte	'sw',0
	.word	4495
	.byte	4,2,35,0,0,26
	.byte	'Os_CounterDynType_s',0,6,220,3,16,4,22
	.byte	'type_dependent',0
	.word	4523
	.byte	4,2,35,0,0,20
	.byte	'Os_CounterDynType',0,6,226,3,3
	.word	4542
	.byte	12
	.word	4542
	.byte	30
	.word	4620
	.byte	26
	.byte	'Os_CounterType_s',0,6,227,3,16,28,22
	.byte	'dynamic',0
	.word	4625
	.byte	4,2,35,0,22
	.byte	'advincr',0
	.word	4464
	.byte	4,2,35,4,22
	.byte	'base',0
	.word	4271
	.byte	12,2,35,8,22
	.byte	'core',0
	.word	2722
	.byte	4,2,35,20,22
	.byte	'access',0
	.word	264
	.byte	1,2,35,24,22
	.byte	'application',0
	.word	264
	.byte	1,2,35,25,0,20
	.byte	'Os_CounterType',0,6,234,3,3
	.word	4630
	.byte	12
	.word	4452
	.byte	30
	.word	4630
	.byte	12
	.word	4782
	.byte	20
	.byte	'CounterType',0,6,235,3,52
	.word	4787
	.byte	32
	.byte	'Os_ScheduleTableStatusType',0,6,240,3,6,4,8
	.byte	'SCHEDULETABLE_STOPPED',0,0,8
	.byte	'SCHEDULETABLE_NEXT',0,1,8
	.byte	'SCHEDULETABLE_WAITING',0,2,8
	.byte	'SCHEDULETABLE_RUNNING',0,3,8
	.byte	'SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS',0,4,0,20
	.byte	'ScheduleTableStatusType',0,6,241,3,41
	.word	4813
	.byte	30
	.word	.L233-.L110
	.byte	12
	.word	5013
	.byte	20
	.byte	'ScheduleTableType',0,6,128,4,58
	.word	5018
	.byte	26
	.byte	'Os_ScheduleTableDynType_s',0,6,130,4,16,16,22
	.byte	'match',0
	.word	156
	.byte	4,2,35,0,22
	.byte	'next',0
	.word	5023
	.byte	4,2,35,4,22
	.byte	'state',0
	.word	4813
	.byte	4,2,35,8,22
	.byte	'config',0
	.word	242
	.byte	2,2,35,12,0,12
	.word	5050
	.byte	30
	.word	5143
.L233:
	.byte	26
	.byte	'Os_ScheduleTableType_s',0,6,247,3,16,16,22
	.byte	'dynamic',0
	.word	5148
	.byte	4,2,35,0,22
	.byte	'counter',0
	.word	4792
	.byte	4,2,35,4,22
	.byte	'repeat',0
	.word	264
	.byte	1,2,35,8,22
	.byte	'config',0
	.word	242
	.byte	2,2,35,10,22
	.byte	'initial',0
	.word	264
	.byte	1,2,35,12,22
	.byte	'access',0
	.word	264
	.byte	1,2,35,13,22
	.byte	'application',0
	.word	264
	.byte	1,2,35,14,0,20
	.byte	'Os_ScheduleTableType',0,6,255,3,3
	.word	5153
	.byte	30
	.word	5153
	.byte	12
	.word	5333
	.byte	30
	.word	4630
	.byte	12
	.word	5343
	.byte	34
	.word	2446
	.byte	34
	.word	3396
	.byte	34
	.word	3293
	.byte	34
	.word	3954
	.byte	34
	.word	3460
	.byte	34
	.word	264
	.byte	34
	.word	3954
	.byte	26
	.byte	'Os_ControlledCoreType_s',0,6,251,6,16,112,22
	.byte	'TrapInfo',0
	.word	1877
	.byte	8,2,35,0,22
	.byte	'lock_taskaccess',0
	.word	5353
	.byte	4,2,35,8,22
	.byte	'ReadyTasks',0
	.word	5358
	.byte	4,2,35,12,22
	.byte	'RunningISR',0
	.word	5363
	.byte	4,2,35,16,22
	.byte	'RunningTask',0
	.word	5368
	.byte	4,2,35,20,22
	.byte	'RunningTPMask',0
	.word	5373
	.byte	4,2,35,24,22
	.byte	'CurrentMeteredObject',0
	.word	2979
	.byte	4,2,35,28,22
	.byte	'IdleMeter',0
	.word	2776
	.byte	48,2,35,32,22
	.byte	'AppAccess',0
	.word	264
	.byte	1,2,35,80,22
	.byte	'AppOverride',0
	.word	5378
	.byte	1,2,35,81,22
	.byte	'GetStackValueAdjust',0
	.word	2048
	.byte	8,2,35,84,22
	.byte	'InErrorHook',0
	.word	264
	.byte	1,2,35,92,22
	.byte	'ChainTaskRef',0
	.word	5383
	.byte	4,2,35,96,22
	.byte	'GetStackUsageAdjust',0
	.word	2048
	.byte	8,2,35,100,22
	.byte	'InProtectionHook',0
	.word	264
	.byte	1,2,35,108,22
	.byte	'CoreIsActive',0
	.word	264
	.byte	1,2,35,109,22
	.byte	'InShutdownHook',0
	.word	264
	.byte	1,2,35,110,0,20
	.byte	'Os_ControlledCoreType',0,6,141,7,3
	.word	5388
	.byte	12
	.word	156
	.byte	30
	.word	3124
	.byte	12
	.word	5844
	.byte	30
	.word	3694
	.byte	12
	.word	5854
	.byte	12
	.word	2776
	.byte	26
	.byte	'Os_AnyCoreType_s',0,6,151,7,16,96,22
	.byte	'DisableAllImask',0
	.word	156
	.byte	4,2,35,0,22
	.byte	'SuspendAllImask',0
	.word	156
	.byte	4,2,35,4,22
	.byte	'SuspendOSImask',0
	.word	156
	.byte	4,2,35,8,22
	.byte	'DisableAllCount',0
	.word	156
	.byte	4,2,35,12,22
	.byte	'SuspendAllCount',0
	.word	156
	.byte	4,2,35,16,22
	.byte	'SuspendOSCount',0
	.word	156
	.byte	4,2,35,20,22
	.byte	'RestartJumpBuf',0
	.word	1997
	.byte	68,2,35,24,22
	.byte	'Restartable',0
	.word	264
	.byte	1,2,35,92,0,20
	.byte	'Os_AnyCoreType',0,6,160,7,3
	.word	5869
	.byte	20
	.byte	'unsigned_int',0,7,116,22
	.word	156
	.byte	7,8,23,9,4,8
	.byte	'MEMIF_UNINIT',0,0,8
	.byte	'MEMIF_IDLE',0,1,8
	.byte	'MEMIF_BUSY',0,2,8
	.byte	'MEMIF_BUSY_INTERNAL',0,3,0,20
	.byte	'MemIf_StatusType',0,8,29,2
	.word	6131
	.byte	7,8,31,9,4,8
	.byte	'MEMIF_JOB_OK',0,0,8
	.byte	'MEMIF_JOB_FAILED',0,1,8
	.byte	'MEMIF_JOB_PENDING',0,2,8
	.byte	'MEMIF_JOB_CANCELED',0,3,8
	.byte	'MEMIF_BLOCK_INCONSISTENT',0,4,8
	.byte	'MEMIF_BLOCK_INVALID',0,5,0,20
	.byte	'MemIf_JobResultType',0,8,39,2
	.word	6225
	.byte	7,8,41,9,4,8
	.byte	'MEMIF_MODE_SLOW',0,0,8
	.byte	'MEMIF_MODE_FAST',0,1,0,20
	.byte	'MemIf_ModeType',0,8,45,2
	.word	6383
	.byte	20
	.byte	'PduIdType',0,9,22,19
	.word	242
	.byte	20
	.byte	'PduLengthType',0,9,26,19
	.word	242
	.byte	7,10,113,9,4,8
	.byte	'TP_DATACONF',0,0,8
	.byte	'TP_DATARETRY',0,1,8
	.byte	'TP_CONFPENDING',0,2,0,20
	.byte	'TpDataStateType',0,10,118,3
	.word	6488
	.byte	20
	.byte	'Can_IdType',0,11,32,16
	.word	156
	.byte	20
	.byte	'Can_HwHandleType',0,11,43,16
	.word	242
	.byte	20
	.byte	'Can_TxObjPriorityClassType',0,12,219,3,16
	.word	156
	.byte	26
	.byte	'Can_TxHwObjectConfigType',0,12,231,3,16,8,22
	.byte	'MsgObjId',0
	.word	264
	.byte	1,2,35,0,22
	.byte	'HwControllerId',0
	.word	264
	.byte	1,2,35,1,22
	.byte	'TxObjPriorityClass',0
	.word	156
	.byte	4,2,35,4,0,20
	.byte	'Can_TxHwObjectConfigType',0,12,252,3,3
	.word	6644
	.byte	26
	.byte	'Can_RxHwObjectConfigType',0,12,129,4,16,12,22
	.byte	'MaskRef',0
	.word	156
	.byte	4,2,35,0,22
	.byte	'MsgId',0
	.word	156
	.byte	4,2,35,4,22
	.byte	'MsgObjId',0
	.word	264
	.byte	1,2,35,8,22
	.byte	'HwControllerId',0
	.word	264
	.byte	1,2,35,9,0,20
	.byte	'Can_RxHwObjectConfigType',0,12,147,4,3
	.word	6780
	.byte	23,4
	.word	264
	.byte	24,3,0,26
	.byte	'Can_ControllerMOMapConfigType',0,12,181,4,16,4,22
	.byte	'ControllerMOMap',0
	.word	6920
	.byte	4,2,35,0,0,20
	.byte	'Can_ControllerMOMapConfigType',0,12,184,4,3
	.word	6929
	.byte	26
	.byte	'Can_NPCRValueType',0,12,188,4,16,2,22
	.byte	'Can_NPCRValue',0
	.word	242
	.byte	2,2,35,0,0,20
	.byte	'Can_NPCRValueType',0,12,191,4,3
	.word	7030
	.byte	26
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,12,194,4,16,8,22
	.byte	'CanControllerBaudrate',0
	.word	156
	.byte	4,2,35,0,22
	.byte	'CanControllerBaudrateCfg',0
	.word	242
	.byte	2,2,35,4,0,20
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,12,198,4,3
	.word	7105
	.byte	30
	.word	7105
	.byte	12
	.word	7270
	.byte	26
	.byte	'Can_BaudrateConfigPtrType',0,12,201,4,16,4,22
	.byte	'Can_kBaudrateConfigPtr',0
	.word	7275
	.byte	4,2,35,0,0,20
	.byte	'Can_BaudrateConfigPtrType',0,12,204,4,3
	.word	7280
	.byte	26
	.byte	'Can_EventHandlingType',0,12,226,4,16,4,22
	.byte	'CanEventType',0
	.word	6920
	.byte	4,2,35,0,0,20
	.byte	'Can_EventHandlingType',0,12,229,4,3
	.word	7380
	.byte	20
	.byte	'Rte_TransformerErrorCode',0,13,130,1,15
	.word	264
	.byte	20
	.byte	'Rte_TransformerClass',0,13,131,1,15
	.word	264
	.byte	21,13,168,1,9,12,22
	.byte	'in',0
	.word	2722
	.byte	4,2,35,0,22
	.byte	'out',0
	.word	2722
	.byte	4,2,35,4,22
	.byte	'used',0
	.word	242
	.byte	2,2,35,8,22
	.byte	'lost_data',0
	.word	264
	.byte	1,2,35,10,0,20
	.byte	'Rte_QDynType',0,13,173,1,3
	.word	7526
	.byte	7,13,175,1,9,4,8
	.byte	'RTE_DRA',0,0,8
	.byte	'RTE_WOWP',0,1,8
	.byte	'RTE_TASK',0,2,8
	.byte	'RTE_ARE',0,3,8
	.byte	'RTE_EV',0,4,8
	.byte	'RTE_MSI',0,5,0,20
	.byte	'Rte_NotificationType',0,13,182,1,3
	.word	7613
	.byte	23,128,8
	.word	264
	.byte	24,255,7,0,20
	.byte	'Impl_NVM_DstPtrType_1024',0,14,50,15
	.word	7711
	.byte	20
	.byte	'CanIf_u32_impl',0,14,69,16
	.word	156
	.byte	20
	.byte	'CanIf_u16_impl',0,14,71,16
	.word	242
	.byte	20
	.byte	'CanIf_u8_impl',0,14,73,15
	.word	264
	.byte	20
	.byte	'CanIf_ControllerModeType_Enum_impl',0,14,88,15
	.word	264
	.byte	20
	.byte	'CanIf_PduModeType_Enum_impl',0,14,90,15
	.word	264
	.byte	21,14,92,9,2,22
	.byte	'DeviceMode',0
	.word	264
	.byte	1,2,35,0,22
	.byte	'ChannelMode',0
	.word	264
	.byte	1,2,35,1,0,20
	.byte	'CanIf_ControllerStateType_struct_impl',0,14,95,3
	.word	7902
	.byte	20
	.byte	'CanIf_NotifStatusType_Enum_impl',0,14,100,15
	.word	264
	.byte	20
	.byte	'CanSM_boolean_Impl',0,14,120,15
	.word	264
	.byte	20
	.byte	'CanSM_u8_Impl',0,14,123,15
	.word	264
	.byte	20
	.byte	'CanSM_BusOffRecoveryStateType_Enum_impl',0,14,128,1,15
	.word	264
	.byte	20
	.byte	'CanSM_NetworkModeStateType_Enum_impl',0,14,132,1,15
	.word	264
	.byte	20
	.byte	'CanSM_u16_Impl',0,14,136,1,16
	.word	242
	.byte	20
	.byte	'CanSM_TimerStateType_Enum_impl',0,14,138,1,15
	.word	264
	.byte	21,14,140,1,9,4,22
	.byte	'cntTick_u16',0
	.word	242
	.byte	2,2,35,0,22
	.byte	'stTimer',0
	.word	264
	.byte	1,2,35,2,0,20
	.byte	'CanSM_TimerConfig_tst_struct_impl',0,14,143,1,3
	.word	8243
	.byte	20
	.byte	'Com_impl_u16',0,14,154,1,16
	.word	242
	.byte	20
	.byte	'Com_impl_u8',0,14,157,1,15
	.word	264
	.byte	20
	.byte	'ComM_uint32_Impl',0,14,173,1,16
	.word	156
	.byte	20
	.byte	'ComM_uint16_Impl',0,14,175,1,16
	.word	242
	.byte	20
	.byte	'ComM_uint8_Impl',0,14,177,1,15
	.word	264
	.byte	20
	.byte	'ComM_bool_Impl',0,14,179,1,15
	.word	264
	.byte	21,14,181,1,9,24,22
	.byte	'ChannelState_e',0
	.word	156
	.byte	4,2,35,0,22
	.byte	'LightTimeoutCtr_u32',0
	.word	156
	.byte	4,2,35,4,22
	.byte	'MinFullComTimeoutCtr_u16',0
	.word	242
	.byte	2,2,35,8,22
	.byte	'ChannelMode_u8',0
	.word	264
	.byte	1,2,35,10,22
	.byte	'BusSmMode_u8',0
	.word	264
	.byte	1,2,35,11,22
	.byte	'UserRequestCtr_u8',0
	.word	264
	.byte	1,2,35,12,22
	.byte	'PassiveRequestState_u8',0
	.word	264
	.byte	1,2,35,13,22
	.byte	'PncRequestCtr_u8',0
	.word	264
	.byte	1,2,35,14,22
	.byte	'InhibitionReqStatus_u8',0
	.word	264
	.byte	1,2,35,15,22
	.byte	'NmNetworkRequestStatus_b',0
	.word	264
	.byte	1,2,35,16,22
	.byte	'DiagnosticRequestState_b',0
	.word	264
	.byte	1,2,35,17,22
	.byte	'CommunicationAllowed_b',0
	.word	264
	.byte	1,2,35,18,22
	.byte	'NmBusSleepIndicationStatus_b',0
	.word	264
	.byte	1,2,35,19,22
	.byte	'NmPrepareBusSleepIndicationStatus_b',0
	.word	264
	.byte	1,2,35,20,22
	.byte	'NmNetworkModeStatus_b',0
	.word	264
	.byte	1,2,35,21,0,20
	.byte	'ComM_ChannelStruct_Impl',0,14,197,1,3
	.word	8475
	.byte	21,14,206,1,9,10,22
	.byte	'WakeUpInhibitionCtr_u16',0
	.word	242
	.byte	2,2,35,0,22
	.byte	'LimitToNoComCtr_u16',0
	.word	242
	.byte	2,2,35,2,22
	.byte	'RequestedUserMode_t',0
	.word	264
	.byte	1,2,35,4,22
	.byte	'IndicatedUserMode_t',0
	.word	264
	.byte	1,2,35,5,22
	.byte	'numChannelsInFullCom_u8',0
	.word	264
	.byte	1,2,35,6,22
	.byte	'numChannelsInSilentCom_u8',0
	.word	264
	.byte	1,2,35,7,22
	.byte	'numChannelsInNoCom_u8',0
	.word	264
	.byte	1,2,35,8,0,20
	.byte	'ComM_UserStruct_Impl',0,14,214,1,3
	.word	8979
	.byte	20
	.byte	'Dcm_IOOperationResponseType',0,14,252,1,15
	.word	264
	.byte	20
	.byte	'Dcm_RequestDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspRequestRoutineResultsOutSignal_0PrimitivType',0
	.byte	14,138,2,15
	.word	264
	.byte	20
	.byte	'Dcm_StartDataIn_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineInSignalPrimitivType',0,14,146,2,15
	.word	264
	.byte	20
	.byte	'Dcm_StartDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineOutSignalPrimitivType',0,14,150,2,15
	.word	264
	.byte	20
	.byte	'Dcm_StopDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStopRoutineOutSignalPrimitivType',0,14,154,2,15
	.word	264
	.byte	20
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockNative_1024_Type',0,14,243,3,34
	.word	7722
	.byte	23,128,8
	.word	264
	.byte	24,255,7,0,20
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockRedundant_1024_Type',0,14,246,3,34
	.word	7722
	.byte	20
	.byte	'Fls_LengthType',0,15,173,3,16
	.word	156
	.byte	26
	.byte	'Fls_JobStartType',0,15,175,3,16,1,35
	.byte	'Reserved1',0,1
	.word	264
	.byte	1,7,2,35,0,35
	.byte	'Write',0,1
	.word	264
	.byte	1,6,2,35,0,35
	.byte	'Erase',0,1
	.word	264
	.byte	1,5,2,35,0,35
	.byte	'Read',0,1
	.word	264
	.byte	1,4,2,35,0,35
	.byte	'Compare',0,1
	.word	264
	.byte	1,3,2,35,0,35
	.byte	'Reserved2',0,1
	.word	264
	.byte	3,0,2,35,0,0,20
	.byte	'Fls_JobStartType',0,15,183,3,3
	.word	9821
	.byte	20
	.byte	'Fls_17_Pmu_Job_Type',0,15,187,3,15
	.word	264
	.byte	12
	.word	264
	.byte	30
	.word	264
	.byte	12
	.word	10016
	.byte	23,2
	.word	264
	.byte	24,1,0,26
	.byte	'Fls_17_Pmu_StateType',0,15,198,3,16,48,22
	.byte	'FlsReadAddress',0
	.word	156
	.byte	4,2,35,0,22
	.byte	'FlsWriteAddress',0
	.word	156
	.byte	4,2,35,4,22
	.byte	'FlsEraseTimeoutCycleCount',0
	.word	156
	.byte	4,2,35,8,22
	.byte	'FlsWriteTimeoutCycleCount',0
	.word	156
	.byte	4,2,35,12,22
	.byte	'FlsReadLength',0
	.word	156
	.byte	4,2,35,16,22
	.byte	'FlsWriteLength',0
	.word	156
	.byte	4,2,35,20,22
	.byte	'FlsReadBufferPtr',0
	.word	10011
	.byte	4,2,35,24,22
	.byte	'FlsWriteBufferPtr',0
	.word	10021
	.byte	4,2,35,28,22
	.byte	'FlsJobResult',0
	.word	6225
	.byte	4,2,35,32,22
	.byte	'FlsMode',0
	.word	6383
	.byte	4,2,35,36,22
	.byte	'NotifCaller',0
	.word	264
	.byte	1,2,35,40,22
	.byte	'JobStarted',0
	.word	9821
	.byte	1,2,35,41,22
	.byte	'FlsJobType',0
	.word	10026
	.byte	2,2,35,42,22
	.byte	'FlsOper',0
	.word	264
	.byte	1,2,35,44,22
	.byte	'FlsTimeoutErr',0
	.word	264
	.byte	1,2,35,45,22
	.byte	'FlsTimeoutControl',0
	.word	264
	.byte	1,2,35,46,0,20
	.byte	'Fls_17_Pmu_StateType',0,15,130,4,3
	.word	10035
	.byte	20
	.byte	'Fls_NotifFunctionPtrType',0,15,137,4,16
	.word	2136
	.byte	30
	.word	156
	.byte	12
	.word	10513
	.byte	28,1,1,29
	.word	156
	.byte	29
	.word	156
	.byte	29
	.word	10518
	.byte	29
	.word	264
	.byte	0,12
	.word	10523
	.byte	20
	.byte	'Fls_WriteCmdPtrType',0,15,139,4,16
	.word	10547
	.byte	28,1,1,29
	.word	156
	.byte	0,12
	.word	10581
	.byte	20
	.byte	'Fls_EraseCmdPtrType',0,15,144,4,16
	.word	10590
	.byte	20
	.byte	'Fee_HlMode_ten',0,2,132,1,2
	.word	950
	.byte	20
	.byte	'Fee_Rb_WorkingStateType_ten',0,2,183,1,2
	.word	1223
	.byte	36
	.byte	'Fee_Rb_WorkingState_en',0,2,202,1,50
	.word	1223
	.byte	1,1,7,1,147,1,9,4,8
	.byte	'FEE_NORMAL_PRIO_E',0,0,8
	.byte	'FEE_HIGH_PRIO_E',0,1,0,20
	.byte	'Fee_HlPriority_ten',0,1,151,1,2
	.word	10719
	.byte	21,1,165,1,9,24,22
	.byte	'DataBufferPtr_pu8',0
	.word	10011
	.byte	4,2,35,0,22
	.byte	'FeeIdx_u16',0
	.word	242
	.byte	2,2,35,4,22
	.byte	'BlockPropIdx_u16',0
	.word	242
	.byte	2,2,35,6,22
	.byte	'Offset_u16',0
	.word	242
	.byte	2,2,35,8,22
	.byte	'Length_u16',0
	.word	242
	.byte	2,2,35,10,22
	.byte	'Mode_en',0
	.word	950
	.byte	4,2,35,12,22
	.byte	'Prio_en',0
	.word	10719
	.byte	4,2,35,16,22
	.byte	'SecLevel_u8',0
	.word	264
	.byte	1,2,35,20,0,20
	.byte	'Fee_OrderFifo_tst',0,1,175,1,2
	.word	10792
	.byte	7,1,246,1,9,4,8
	.byte	'FEE_SECTOR_STATE_UNDEF_E',0,0,8
	.byte	'FEE_SECTOR_ERASED_E',0,1,8
	.byte	'FEE_SECTOR_USED_E',0,2,8
	.byte	'FEE_SECTOR_FULL_E',0,3,8
	.byte	'FEE_SECTOR_REQUEST2ERASE_E',0,4,8
	.byte	'FEE_SECTOR_CONSIDERED_E',0,13,0,20
	.byte	'Fee_SectorState_ten',0,1,254,1,2
	.word	10994
	.byte	21,1,129,2,9,12,22
	.byte	'SecChngCnt_u32',0
	.word	156
	.byte	4,2,35,0,22
	.byte	'SecState_en',0
	.word	10994
	.byte	4,2,35,4,22
	.byte	'xPhySecIdx_u8',0
	.word	264
	.byte	1,2,35,8,0,20
	.byte	'Fee_LLSectorOrder_tst',0,1,134,2,2
	.word	11174
	.byte	20
	.byte	'Fee_stRetVal_ten',0,1,149,2,2
	.word	397
	.byte	30
	.word	2136
	.byte	30
	.word	2136
	.byte	21,1,192,2,9,16,22
	.byte	'BlockPersistentId_u16',0
	.word	242
	.byte	2,2,35,0,22
	.byte	'Flags_u16',0
	.word	242
	.byte	2,2,35,2,22
	.byte	'Length_u16',0
	.word	242
	.byte	2,2,35,4,22
	.byte	'JobEndNotification_pfn',0
	.word	11306
	.byte	4,2,35,8,22
	.byte	'JobErrorNotification_pfn',0
	.word	11311
	.byte	4,2,35,12,0,20
	.byte	'Fee_BlockPropertiesType_tst',0,1,199,2,2
	.word	11316
	.byte	7,1,210,2,9,4,8
	.byte	'FEE_LL_MARKER_INIT_E',0,0,8
	.byte	'FEE_LL_MARKER_BLK_CHK_E',0,1,8
	.byte	'FEE_LL_MARKER_BLK_CHK_WAIT_E',0,2,8
	.byte	'FEE_LL_MARKER_BLK_CHK_ERROR_E',0,3,8
	.byte	'FEE_LL_MARKER_BLK_CHK_FINISHED_E',0,4,8
	.byte	'FEE_LL_MARKER_WRITE_WAIT_E',0,5,8
	.byte	'FEE_LL_MARKER_WRITE_ERROR_E',0,6,8
	.byte	'FEE_LL_MARKER_VERIFY_E',0,7,8
	.byte	'FEE_LL_MARKER_VERIFY_WAIT_E',0,8,8
	.byte	'FEE_LL_MARKER_VERIFY_FINISHED_E',0,9,0,20
	.byte	'Fee_LLWrMarkerType_ten',0,1,222,2,2
	.word	11496
	.byte	7,1,225,2,9,4,8
	.byte	'FEE_HL_RDWR_BLK_INIT_E',0,0,8
	.byte	'FEE_HL_SEARCH_BLK_HDR_E',0,1,8
	.byte	'FEE_HL_READ_BLK_HDR_WAIT_E',0,2,8
	.byte	'FEE_HL_CHECK_BLK_HDR_E',0,3,8
	.byte	'FEE_HL_CALC_BLK_CS_E',0,4,8
	.byte	'FEE_HL_CHECK_BLK_CS_E',0,5,8
	.byte	'FEE_HL_RD_DATA_FROM_BLK_E',0,6,8
	.byte	'FEE_HL_COMP_BLK_E',0,7,8
	.byte	'FEE_HL_WR_BLK_E',0,8,0,20
	.byte	'Fee_HLRdWrBlockType_ten',0,1,243,2,2
	.word	11830
	.byte	7,1,246,2,9,4,8
	.byte	'FEE_LL_WR_BLK_INIT_E',0,0,8
	.byte	'FEE_LL_WR_WRITEHEADER_E',0,1,8
	.byte	'FEE_LL_WR_SIZECHECK_HSR_E',0,2,8
	.byte	'FEE_LL_WR_WRITEHEADER_WAIT_E',0,3,8
	.byte	'FEE_LL_WR_VERIFYHEADER_E',0,4,8
	.byte	'FEE_LL_WR_VERIFYHEADER_WAIT_E',0,5,8
	.byte	'FEE_LL_WR_VERIFYHEADER_ERROR_E',0,6,8
	.byte	'FEE_LL_WR_WRITEDATA_SEC_A_E',0,7,8
	.byte	'FEE_LL_WR_WAIT_WRITEDATA_SEC_A_E',0,8,8
	.byte	'FEE_LL_WR_WRITE_ERROR_E',0,9,8
	.byte	'FEE_LL_WR_WRITE_FULL_MARKER_E',0,10,8
	.byte	'FEE_LL_WR_ERASE_SECTOR_E',0,11,8
	.byte	'FEE_LL_WR_WRITE_USED_MARKER_E',0,12,8
	.byte	'FEE_LL_WR_WRITE_START_MARKER_E',0,13,8
	.byte	'FEE_LL_WR_VERIFY_BLK_E',0,14,8
	.byte	'FEE_LL_WR_WRITEHDRPG2_E',0,15,8
	.byte	'FEE_LL_WR_WAIT_WRITEHDRPG2_E',0,16,0,20
	.byte	'Fee_LLWrBlockType_ten',0,1,162,3,2
	.word	12088
	.byte	7,1,165,3,9,4,8
	.byte	'FEE_LL_CMP_BLK_INIT_E',0,0,8
	.byte	'FEE_LL_CMP_HEADER_E',0,1,8
	.byte	'FEE_LL_CMP_WAIT_HEADER_E',0,2,8
	.byte	'FEE_LL_CMP_CHECK_OVERLAP_E',0,3,8
	.byte	'FEE_LL_CMP_DATA_SEC_A_E',0,4,8
	.byte	'FEE_LL_CMP_WAIT_DATA_SEC_A_E',0,5,8
	.byte	'FEE_LL_CMP_FINISHED_E',0,6,0,20
	.byte	'Fee_LLCmpBlkType_ten',0,1,174,3,2
	.word	12623
	.byte	7,1,177,3,9,4,8
	.byte	'FEE_LL_CPY_BLK_INIT_E',0,0,8
	.byte	'FEE_LL_CPY_BLOCK_START_E',0,1,8
	.byte	'FEE_LL_CPY_BLOCK_WAIT_E',0,2,8
	.byte	'FEE_LL_CPY_BLOCK_ERROR_E',0,3,8
	.byte	'FEE_LL_CPY_BLOCK_FINISHED_E',0,4,0,20
	.byte	'Fee_LLCpyBlkType_ten',0,1,184,3,2
	.word	12843
	.byte	7,1,187,3,9,4,8
	.byte	'FEE_LL_CRC_BLK_INIT_E',0,0,8
	.byte	'FEE_LL_CRC_RD_HD_PAGE_E',0,1,8
	.byte	'FEE_LL_CRC_RD_PAGE_E',0,2,8
	.byte	'FEE_LL_CRC_CHECK_OVERLAP_E',0,3,8
	.byte	'FEE_LL_CRC_RD_ROB_PAGE_E',0,4,8
	.byte	'FEE_LL_CRC_CHECK_OVERLAP_ROB_E',0,5,8
	.byte	'FEE_LL_CRC_RD_ROB_PAGE_WAIT_E',0,6,8
	.byte	'FEE_LL_CRC_RD_PAGE_WAIT_E',0,7,8
	.byte	'FEE_LL_CRC_RD_ERROR_E',0,8,0,20
	.byte	'Fee_LLCalcCrcBlkType_ten',0,1,200,3,2
	.word	13014
	.byte	7,1,203,3,9,4,8
	.byte	'FEE_LL_INIT_READ_E',0,0,8
	.byte	'FEE_LL_BLANK_CHECK_E',0,1,8
	.byte	'FEE_LL_BLANK_CHECK_WAIT_E',0,2,8
	.byte	'FEE_LL_READ_PAGE_E',0,3,8
	.byte	'FEE_LL_WAIT_READ_PAGE_E',0,4,8
	.byte	'FEE_LL_READ_ERROR_E',0,5,8
	.byte	'FEE_LL_READ_FINISHED_E',0,6,0,20
	.byte	'Fee_LLRdStateType_ten',0,1,223,3,3
	.word	13301
	.byte	7,1,226,3,9,4,8
	.byte	'FEE_LL_INIT_BLANK_CHECK_E',0,0,8
	.byte	'FEE_LL_PERFORM_BLANK_CHECK_E',0,1,8
	.byte	'FEE_LL_WAIT_PERFORM_BLANK_CHECK_E',0,2,8
	.byte	'FEE_LL_BLANK_CHECK_ERROR_E',0,3,8
	.byte	'FEE_LL_BLANK_CHECK_FINISHED_E',0,4,0,20
	.byte	'Fee_LLBlankCheckType_ten',0,1,233,3,3
	.word	13505
	.byte	7,1,236,3,9,4,8
	.byte	'FEE_LL_FIND_CURRENT_SECTOR_E',0,0,8
	.byte	'FEE_LL_FIND_LAST_HEADER_E',0,1,8
	.byte	'FEE_LL_FINISHED_E',0,2,0,20
	.byte	'Fee_LLFndEmptyPgeType_ten',0,1,249,3,2
	.word	13702
	.byte	7,1,252,3,9,4,8
	.byte	'FEE_LL_SEARCHBLK_INIT_E',0,0,8
	.byte	'FEE_LL_SEARCHBLK_BLK_HEADER_E',0,1,0,20
	.byte	'Fee_LLSearchBlkHdrType_ten',0,1,128,4,2
	.word	13823
	.byte	7,1,132,4,9,4,8
	.byte	'FEE_LL_BLD_UP_CACHE_INIT_E',0,0,8
	.byte	'FEE_LL_BLD_UP_CACHE_READ_E',0,1,0,20
	.byte	'Fee_LLBuildUpCache_ten',0,1,136,4,2
	.word	13924
	.byte	7,1,139,4,9,4,8
	.byte	'FEE_LL_BLD_UP_CACHE_ALL_SECT_INIT_E',0,0,8
	.byte	'FEE_LL_BLD_UP_CACHE_ALL_SECT_DO_E',0,1,0,20
	.byte	'Fee_LLBuildUpCacheAllSect_ten',0,1,143,4,2
	.word	14021
	.byte	7,1,168,4,9,4,8
	.byte	'FEE_LL_REORG_INIT_E',0,0,8
	.byte	'FEE_LL_REORG_PREP_SEARCH_BLK_E',0,1,8
	.byte	'FEE_LL_REORG_SEARCH_BLK_E',0,2,8
	.byte	'FEE_LL_REORG_CHECK_BLOCK_CS_E',0,3,8
	.byte	'FEE_LL_REORG_REDUNDANT_BLK_CHK_E',0,4,8
	.byte	'FEE_LL_REORG_WRITE_BLOCK_E',0,5,8
	.byte	'FEE_LL_REORG_FINISHED_E',0,6,0,20
	.byte	'Fee_LLSecReorgType_ten',0,1,193,4,2
	.word	14141
	.byte	7,1,196,4,9,4,8
	.byte	'FEE_LL_REDUNDANT_CPY_CHK_INIT_E',0,0,8
	.byte	'FEE_LL_REDUNDANT_CPY_CHK_SEARCH_HDR_E',0,1,8
	.byte	'FEE_LL_REDUNDANT_CPY_CHK_BLK_CS_E',0,2,0,20
	.byte	'Fee_LLRedundantCpyChk_ten',0,1,201,4,2
	.word	14385
	.byte	7,1,204,4,9,4,8
	.byte	'FEE_LL_CPY_FLS2FLS_INIT_E',0,0,8
	.byte	'FEE_LL_CPY_FLS2FLS_READ_E',0,1,8
	.byte	'FEE_LL_CPY_FLS2FLS_WAIT_READ_E',0,2,8
	.byte	'FEE_LL_CPY_FLS2FLS_READ_ERROR_E',0,3,8
	.byte	'FEE_LL_CPY_FLS2FLS_HDRPG1_WRITE_E',0,4,8
	.byte	'FEE_LL_CPY_FLS2FLS_WAIT_HDRPG1_WRITE_E',0,5,8
	.byte	'FEE_LL_CPY_FLS2FLS_HDRPG1_WRITE_ERROR_E',0,6,8
	.byte	'FEE_LL_CPY_FLS2FLS_HDRPG1_VERIFY_E',0,7,8
	.byte	'FEE_LL_CPY_FLS2FLS_WAIT_HDRPG1_VERIFY_E',0,8,8
	.byte	'FEE_LL_CPY_FLS2FLS_HDRPG1_VERIFY_ERROR_E',0,9,8
	.byte	'FEE_LL_CPY_FLS2FLS_WRITE_E',0,10,8
	.byte	'FEE_LL_CPY_FLS2FLS_WAIT_WRITE_E',0,11,8
	.byte	'FEE_LL_CPY_FLS2FLS_WRITE_ERROR_E',0,12,8
	.byte	'FEE_LL_CPY_FLS2FLS_VERIFY_E',0,13,8
	.byte	'FEE_LL_CPY_FLS2FLS_WAIT_VERIFY_E',0,14,8
	.byte	'FEE_LL_CPY_FLS2FLS_VERIFY_ERROR_E',0,15,8
	.byte	'FEE_LL_CPY_FLS2FLS_HDRPG2_WRITE_E',0,16,8
	.byte	'FEE_LL_CPY_FLS2FLS_WAIT_HDRPG2_WRITE_E',0,17,8
	.byte	'FEE_LL_CPY_FLS2FLS_HDRPG2_WRITE_ERROR_E',0,18,8
	.byte	'FEE_LL_CPY_FLS2FLS_HDRPG2_VERIFY_E',0,19,8
	.byte	'FEE_LL_CPY_FLS2FLS_WAIT_HDRPG2_VERIFY_E',0,20,8
	.byte	'FEE_LL_CPY_FLS2FLS_HDRPG2_VERIFY_ERROR_E',0,21,8
	.byte	'FEE_LL_CPY_FLS2FLS_CHECK_ADR_OVERFLOW_E',0,22,8
	.byte	'FEE_LL_CPY_FLS2FLS_WRITE_FULL_MARKER_E',0,23,8
	.byte	'FEE_LL_CPY_FLS2FLS_ERASE_SECTOR_E',0,24,8
	.byte	'FEE_LL_CPY_FLS2FLS_WRITE_USED_MARKER_E',0,25,8
	.byte	'FEE_LL_CPY_FLS2FLS_WRITE_START_MARKER_E',0,26,0,20
	.byte	'Fee_LLCpyBlkFls2Fls_ten',0,1,133,5,2
	.word	14537
	.byte	7,1,133,6,9,4,8
	.byte	'FEE_ERASESEC_IDLE_E',0,0,8
	.byte	'FEE_ERASESEC_CHECK_CACHE_E',0,1,8
	.byte	'FEE_ERASESEC_START_E',0,2,8
	.byte	'FEE_ERASESEC_DO_E',0,3,8
	.byte	'FEE_ERASESEC_WRITE_MARKER_E',0,4,8
	.byte	'FEE_ERASESEC_ERROR_E',0,5,0,20
	.byte	'Fee_LLEraseStateType_ten',0,1,141,6,2
	.word	15583
	.byte	23,3
	.word	264
	.byte	24,2,0,21,1,151,6,9,16,22
	.byte	'Preamble_au8',0
	.word	15771
	.byte	3,2,35,0,22
	.byte	'BlkStatus_u8',0
	.word	264
	.byte	1,2,35,3,22
	.byte	'FeeIndex_u16',0
	.word	242
	.byte	2,2,35,4,22
	.byte	'BlkLength_u16',0
	.word	242
	.byte	2,2,35,6,22
	.byte	'HdrCrc16_u16',0
	.word	242
	.byte	2,2,35,8,22
	.byte	'BlkCrc32_u32',0
	.word	156
	.byte	4,2,35,12,0,20
	.byte	'Fee_BlkHeader_tst',0,1,159,6,2
	.word	15780
	.byte	23,36
	.word	6225
	.byte	24,8,0
.L194:
	.byte	30
	.word	15947
	.byte	23,24
	.word	11174
	.byte	24,1,0,36
	.byte	'Fee_LLSectorOrder_st',0,1,145,7,53
	.word	15961
	.byte	1,1,23,72
	.word	10792
	.byte	24,2,0,36
	.byte	'Fee_OrderFifo_st',0,1,147,7,53
	.word	16002
	.byte	1,1,23,12
	.word	6225
	.byte	24,2,0,36
	.byte	'Fee_JobResult',0,1,151,7,53
	.word	16039
	.byte	1,1,36
	.byte	'Fee_Prv_stInit_u8',0,1,164,7,53
	.word	264
	.byte	1,1,36
	.byte	'Fee_NumFlashBanksUsed_u8',0,1,166,7,53
	.word	264
	.byte	1,1,36
	.byte	'Fee_GlobModuleState_st',0,1,185,7,53
	.word	6131
	.byte	1,1,36
	.byte	'Fee_idxActQueue_u8',0,1,193,7,53
	.word	264
	.byte	1,1,23,192,1
	.word	11316
	.byte	24,11,0,36
	.byte	'Fee_BlockProperties_st',0,1,237,7,53
	.word	16202
	.byte	1,1,0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L111:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,36,0,3,8,11,15,62,15,0,0,3,46,1,3,8,32,13,58,15,59,15
	.byte	57,15,73,19,54,15,39,12,0,0,4,5,0,3,8,58,15,59,15,57,15,73,19,0,0,5,11,0,0,0,6,11,1,0,0,7,4,1,58,15,59
	.byte	15,57,15,11,15,0,0,8,40,0,3,8,28,13,0,0,9,46,0,3,8,58,15,59,15,57,15,73,19,54,15,39,12,63,12,60,12,0,0
	.byte	10,46,1,3,8,58,15,59,15,57,15,54,15,39,12,63,12,60,12,0,0,11,46,1,3,8,58,15,59,15,57,15,73,19,54,15,39
	.byte	12,63,12,60,12,0,0,12,15,0,73,19,0,0,13,46,0,3,8,58,15,59,15,57,15,54,15,39,12,63,12,60,12,0,0,14,46,1
	.byte	49,19,0,0,15,5,0,49,19,0,0,16,29,1,49,19,0,0,17,11,0,49,19,0,0,18,46,0,3,8,58,15,59,15,57,15,54,15,63
	.byte	12,60,12,0,0,19,21,0,54,15,0,0,20,22,0,3,8,58,15,59,15,57,15,73,19,0,0,21,19,1,58,15,59,15,57,15,11,15
	.byte	0,0,22,13,0,3,8,73,19,11,15,56,9,0,0,23,1,1,11,15,73,19,0,0,24,33,0,47,15,0,0,25,21,0,54,15,39,12,0,0
	.byte	26,19,1,3,8,58,15,59,15,57,15,11,15,0,0,27,59,0,3,8,0,0,28,21,1,54,15,39,12,0,0,29,5,0,73,19,0,0,30,38
	.byte	0,73,19,0,0,31,23,1,58,15,59,15,57,15,11,15,0,0,32,4,1,3,8,58,15,59,15,57,15,11,15,0,0,33,21,0,73,19,54
	.byte	15,39,12,0,0,34,53,0,73,19,0,0,35,13,0,3,8,11,15,73,19,13,15,12,15,56,9,0,0,36,52,0,3,8,58,15,59,15,57
	.byte	15,73,19,63,12,60,12,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L112:
	.word	.L235-.L234
.L234:
	.half	3
	.word	.L237-.L236
.L236:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_Prv.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Fee\\api\\Fee.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_MainFunction.c',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Platform\\Platform_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Std_Types.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\RTOS_T\\Gen\\inc\\Os.h',0,0,0,0
	.byte	'.\\Integration\\TargetIntegration\\TC275\\Include\\Mcal_TcLib.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\MemIf\\api\\MemIf_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Can_GeneralTypes.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Can_17_MCanP\\inc\\Can_17_MCanP.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Type.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Fls\\inc\\Fls_17_Pmu.h',0,0,0,0,0
.L237:
.L235:
	.sdecl	'.debug_info',debug,cluster('Fee_MainFunction')
	.sect	'.debug_info'
.L113:
	.word	310
	.half	3
	.word	.L114
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_MainFunction.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L116,.L115
	.byte	2
	.word	.L109
	.byte	3
	.byte	'Fee_MainFunction',0,1,129,1,22,1,1,1
	.word	.L102,.L139,.L101
	.byte	4
	.word	.L102,.L139
	.byte	5
	.byte	'i',0,1,131,1,27
	.word	.L140,.L141
	.byte	5
	.byte	'xRetVal',0,1,132,1,38
	.word	.L142,.L143
	.byte	5
	.byte	'stSectReorgInt_b',0,1,133,1,29
	.word	.L140,.L144
	.byte	5
	.byte	'tmpContinueToErase_b',0,1,134,1,30
	.word	.L140,.L145
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('Fee_MainFunction')
	.sect	'.debug_abbrev'
.L114:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,11,1,17,1,18,1,0,0,5,52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('Fee_MainFunction')
	.sect	'.debug_line'
.L115:
	.word	.L239-.L238
.L238:
	.half	3
	.word	.L241-.L240
.L240:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_MainFunction.c',0,0,0,0,0
.L241:
	.byte	5,22,7,0,5,2
	.word	.L102
	.byte	3,128,1,1,5,46,9
	.half	.L195-.L102
	.byte	3,3,1,5,51,9
	.half	.L196-.L195
	.byte	3,2,1,5,13,9
	.half	.L198-.L196
	.byte	3,39,1,5,14,9
	.half	.L242-.L198
	.byte	3,12,1,9
	.half	.L243-.L242
	.byte	3,199,0,1,9
	.half	.L244-.L243
	.byte	3,236,0,1,9
	.half	.L245-.L244
	.byte	3,149,127,1,9
	.half	.L246-.L245
	.byte	3,225,0,1,9
	.half	.L247-.L246
	.byte	3,140,1,1,9
	.half	.L248-.L247
	.byte	3,23,1,9
	.half	.L249-.L248
	.byte	3,130,127,1,5,13,9
	.half	.L2-.L249
	.byte	3,187,126,1,5,54,9
	.half	.L250-.L2
	.byte	1,5,32,9
	.half	.L199-.L250
	.byte	1,5,16,9
	.half	.L251-.L199
	.byte	3,3,1,5,13,9
	.half	.L252-.L251
	.byte	1,5,34,7,9
	.half	.L253-.L252
	.byte	3,2,1,5,36,9
	.half	.L254-.L253
	.byte	1,5,23,9
	.half	.L11-.L254
	.byte	3,5,1,5,47,9
	.half	.L200-.L11
	.byte	1,5,46,9
	.half	.L14-.L200
	.byte	3,3,1,5,26,9
	.half	.L255-.L14
	.byte	1,5,46,9
	.half	.L256-.L255
	.byte	1,5,49,9
	.half	.L257-.L256
	.byte	1,5,25,9
	.half	.L258-.L257
	.byte	1,5,62,7,9
	.half	.L259-.L258
	.byte	3,1,1,5,26,7,9
	.half	.L15-.L259
	.byte	3,1,1,5,44,9
	.half	.L260-.L15
	.byte	1,5,25,7,9
	.half	.L261-.L260
	.byte	3,3,1,5,46,9
	.half	.L262-.L261
	.byte	1,5,44,9
	.half	.L263-.L262
	.byte	1,5,46,9
	.half	.L264-.L263
	.byte	3,3,1,5,50,9
	.half	.L201-.L264
	.byte	3,3,1,5,48,9
	.half	.L265-.L201
	.byte	1,5,25,9
	.half	.L266-.L265
	.byte	3,3,1,5,49,9
	.half	.L16-.L266
	.byte	3,111,1,5,28,9
	.half	.L13-.L16
	.byte	1,5,47,9
	.half	.L267-.L13
	.byte	1,5,52,7,9
	.half	.L18-.L267
	.byte	3,24,1,5,92,9
	.half	.L268-.L18
	.byte	1,5,21,9
	.half	.L269-.L268
	.byte	1,5,22,7,9
	.half	.L270-.L269
	.byte	3,1,1,5,45,9
	.half	.L271-.L270
	.byte	1,5,22,7,9
	.half	.L272-.L271
	.byte	3,1,1,5,40,9
	.half	.L273-.L272
	.byte	1,5,21,7,9
	.half	.L274-.L273
	.byte	3,3,1,5,42,9
	.half	.L275-.L274
	.byte	1,5,40,9
	.half	.L276-.L275
	.byte	1,5,46,9
	.half	.L277-.L276
	.byte	3,3,1,5,44,9
	.half	.L278-.L277
	.byte	1,5,21,9
	.half	.L279-.L278
	.byte	3,3,1,5,9,9
	.half	.L12-.L279
	.byte	3,14,1,5,39,9
	.half	.L5-.L12
	.byte	3,212,0,1,5,21,9
	.half	.L197-.L5
	.byte	1,5,13,9
	.half	.L204-.L197
	.byte	3,4,1,5,25,7,9
	.half	.L280-.L204
	.byte	3,3,1,5,44,9
	.half	.L203-.L280
	.byte	3,3,1,5,9,9
	.half	.L24-.L203
	.byte	3,4,1,5,42,9
	.half	.L6-.L24
	.byte	3,6,1,5,21,9
	.half	.L205-.L6
	.byte	1,5,9,9
	.half	.L206-.L205
	.byte	3,2,1,5,38,9
	.half	.L4-.L206
	.byte	3,27,1,5,21,9
	.half	.L207-.L4
	.byte	1,5,9,9
	.half	.L208-.L207
	.byte	3,2,1,5,13,9
	.half	.L9-.L208
	.byte	3,53,1,5,37,7,9
	.half	.L281-.L9
	.byte	3,3,1,5,17,9
	.half	.L209-.L281
	.byte	1,5,24,7,9
	.half	.L282-.L209
	.byte	3,4,1,5,21,9
	.half	.L283-.L282
	.byte	1,5,49,7,9
	.half	.L284-.L283
	.byte	3,3,1,5,51,9
	.half	.L285-.L284
	.byte	3,1,1,5,25,9
	.half	.L286-.L285
	.byte	1,5,51,9
	.half	.L287-.L286
	.byte	1,5,49,9
	.half	.L288-.L287
	.byte	1,5,56,9
	.half	.L289-.L288
	.byte	3,3,1,5,54,9
	.half	.L290-.L289
	.byte	1,5,56,9
	.half	.L291-.L290
	.byte	3,1,1,5,54,9
	.half	.L292-.L291
	.byte	1,5,79,9
	.half	.L293-.L292
	.byte	3,123,1,5,50,9
	.half	.L30-.L293
	.byte	3,10,1,5,48,9
	.half	.L294-.L30
	.byte	1,5,9,9
	.half	.L28-.L294
	.byte	3,30,1,5,44,9
	.half	.L7-.L28
	.byte	3,6,1,5,13,9
	.half	.L210-.L7
	.byte	1,5,42,7,9
	.half	.L295-.L210
	.byte	3,3,1,5,40,9
	.half	.L296-.L295
	.byte	1,5,55,9
	.half	.L297-.L296
	.byte	1,5,20,9
	.half	.L33-.L297
	.byte	3,5,1,5,17,9
	.half	.L298-.L33
	.byte	1,5,46,7,9
	.half	.L299-.L298
	.byte	3,5,1,5,44,9
	.half	.L300-.L299
	.byte	1,5,9,9
	.half	.L34-.L300
	.byte	3,4,1,5,45,9
	.half	.L8-.L34
	.byte	3,6,1,5,13,9
	.half	.L211-.L8
	.byte	1,5,42,7,9
	.half	.L301-.L211
	.byte	3,3,1,5,40,9
	.half	.L302-.L301
	.byte	1,5,42,9
	.half	.L303-.L302
	.byte	3,1,1,5,17,9
	.half	.L304-.L303
	.byte	1,5,42,9
	.half	.L305-.L304
	.byte	1,5,40,9
	.half	.L306-.L305
	.byte	1,5,48,9
	.half	.L307-.L306
	.byte	3,3,1,5,46,9
	.half	.L308-.L307
	.byte	1,5,48,9
	.half	.L309-.L308
	.byte	3,1,1,5,46,9
	.half	.L310-.L309
	.byte	1,5,9,9
	.half	.L37-.L310
	.byte	3,3,1,5,38,9
	.half	.L10-.L37
	.byte	3,6,1,5,36,9
	.half	.L311-.L10
	.byte	1,5,9,9
	.half	.L312-.L311
	.byte	3,2,1,9
	.half	.L22-.L312
	.byte	3,17,1,5,5,9
	.half	.L313-.L22
	.byte	1,5,9,7,9
	.half	.L314-.L313
	.byte	3,2,1,5,22,9
	.half	.L315-.L314
	.byte	1,5,45,9
	.half	.L316-.L315
	.byte	1,5,63,9
	.half	.L317-.L316
	.byte	1,5,43,9
	.half	.L318-.L317
	.byte	1,5,26,9
	.half	.L319-.L318
	.byte	3,7,1,5,12,9
	.half	.L320-.L319
	.byte	1,5,14,7,9
	.half	.L321-.L320
	.byte	3,1,1,5,13,9
	.half	.L322-.L321
	.byte	1,5,88,7,9
	.half	.L323-.L322
	.byte	1,5,40,7,9
	.half	.L324-.L323
	.byte	3,2,1,5,49,7,9
	.half	.L42-.L324
	.byte	3,4,1,5,47,9
	.half	.L325-.L42
	.byte	1,5,65,9
	.half	.L326-.L325
	.byte	1,5,5,9
	.half	.L40-.L326
	.byte	3,10,1,5,18,7,9
	.half	.L327-.L40
	.byte	3,34,1,9
	.half	.L328-.L327
	.byte	3,102,1,9
	.half	.L329-.L328
	.byte	3,1,1,9
	.half	.L330-.L329
	.byte	3,13,1,9
	.half	.L331-.L330
	.byte	3,13,1,9
	.half	.L332-.L331
	.byte	3,1,1,9
	.half	.L333-.L332
	.byte	3,113,1,5,61,9
	.half	.L49-.L333
	.byte	3,119,1,5,60,9
	.half	.L334-.L49
	.byte	1,5,44,9
	.half	.L335-.L334
	.byte	1,5,60,9
	.half	.L336-.L335
	.byte	1,5,80,9
	.half	.L337-.L336
	.byte	1,5,21,9
	.half	.L338-.L337
	.byte	1,5,43,9
	.half	.L339-.L338
	.byte	1,5,98,9
	.half	.L340-.L339
	.byte	1,5,17,9
	.half	.L341-.L340
	.byte	1,5,121,7,9
	.half	.L342-.L341
	.byte	3,3,1,5,13,9
	.half	.L55-.L342
	.byte	3,3,1,5,61,9
	.half	.L50-.L55
	.byte	3,7,1,5,60,9
	.half	.L343-.L50
	.byte	1,5,44,9
	.half	.L344-.L343
	.byte	1,5,60,9
	.half	.L345-.L344
	.byte	1,5,80,9
	.half	.L346-.L345
	.byte	1,5,21,9
	.half	.L347-.L346
	.byte	1,5,43,9
	.half	.L348-.L347
	.byte	1,5,98,9
	.half	.L349-.L348
	.byte	1,5,17,9
	.half	.L350-.L349
	.byte	1,5,123,7,9
	.half	.L351-.L350
	.byte	3,3,1,5,13,9
	.half	.L57-.L351
	.byte	3,3,1,9
	.half	.L54-.L57
	.byte	3,10,1,5,28,9
	.half	.L56-.L54
	.byte	3,5,1,5,42,9
	.half	.L352-.L56
	.byte	1,5,9,9
	.half	.L353-.L352
	.byte	3,1,1,5,30,9
	.half	.L354-.L353
	.byte	1,5,28,9
	.half	.L355-.L354
	.byte	1,5,34,9
	.half	.L356-.L355
	.byte	3,26,1,5,32,9
	.half	.L357-.L356
	.byte	1,5,21,9
	.half	.L46-.L357
	.byte	3,4,1,5,1,9
	.half	.L358-.L46
	.byte	3,1,1,7,9
	.half	.L117-.L358
	.byte	0,1,1
.L239:
	.sdecl	'.debug_ranges',debug,cluster('Fee_MainFunction')
	.sect	'.debug_ranges'
.L116:
	.word	-1,.L102,0,.L117-.L102,0,0
	.sdecl	'.debug_info',debug,cluster('Fee_LoadNextOrder')
	.sect	'.debug_info'
.L118:
	.word	835
	.half	3
	.word	.L119
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_MainFunction.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L121,.L120
	.byte	2
	.word	.L109
	.byte	3
	.byte	'Fee_LoadNextOrder',0,1,166,5,6,1,1,1
	.word	.L104,.L146,.L103
	.byte	4
	.word	.L104,.L146
	.byte	5
	.byte	'Length_u16',0,1,168,5,12
	.word	.L147,.L148
	.byte	6
	.word	.L149
	.byte	5
	.byte	'dataLen_u16',0,1,190,5,20
	.word	.L147,.L151
	.byte	5
	.byte	'blockPropIdx_u16',0,1,190,5,34
	.word	.L147,.L152
	.byte	5
	.byte	'noFbActive_b',0,1,191,5,21
	.word	.L140,.L153
	.byte	5
	.byte	'doubleSecActive_b',0,1,191,5,36
	.word	.L140,.L154
	.byte	7
	.word	.L155,.L156,.L157
	.byte	8
	.word	.L158,.L159
	.byte	8
	.word	.L160,.L161
	.byte	8
	.word	.L162,.L163
	.byte	9
	.word	.L164,.L156,.L157
	.byte	5
	.byte	'neededSpace_u32',0,2,172,11,12
	.word	.L165,.L166
	.byte	7
	.word	.L167,.L168,.L71
	.byte	8
	.word	.L169,.L170
	.byte	8
	.word	.L171,.L172
	.byte	9
	.word	.L173,.L168,.L71
	.byte	5
	.byte	'modValue_u32',0,2,142,11,12
	.word	.L165,.L174
	.byte	5
	.byte	'retVal_u32',0,2,142,11,26
	.word	.L165,.L175
	.byte	0,0,0,0,0,4
	.word	.L64,.L88
	.byte	5
	.byte	'dataLen_u16',0,1,128,6,20
	.word	.L147,.L176
	.byte	5
	.byte	'blockPropIdx_u16',0,1,128,6,34
	.word	.L147,.L177
	.byte	5
	.byte	'noFbActive_b',0,1,129,6,21
	.word	.L140,.L178
	.byte	5
	.byte	'doubleSecActive_b',0,1,129,6,36
	.word	.L140,.L179
	.byte	7
	.word	.L155,.L180,.L181
	.byte	8
	.word	.L158,.L159
	.byte	8
	.word	.L160,.L161
	.byte	8
	.word	.L162,.L163
	.byte	9
	.word	.L164,.L180,.L181
	.byte	5
	.byte	'neededSpace_u32',0,2,172,11,12
	.word	.L165,.L182
	.byte	7
	.word	.L167,.L183,.L83
	.byte	8
	.word	.L169,.L170
	.byte	8
	.word	.L171,.L172
	.byte	9
	.word	.L173,.L183,.L83
	.byte	5
	.byte	'modValue_u32',0,2,142,11,12
	.word	.L165,.L184
	.byte	5
	.byte	'retVal_u32',0,2,142,11,26
	.word	.L165,.L185
	.byte	0,0,0,0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('Fee_LoadNextOrder')
	.sect	'.debug_abbrev'
.L119:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,11,1,17,1,18,1,0,0,5,52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,6,11,1
	.byte	85,6,0,0,7,29,1,49,16,17,1,18,1,0,0,8,5,0,49,16,2,6,0,0,9,11,1,49,16,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('Fee_LoadNextOrder')
	.sect	'.debug_line'
.L120:
	.word	.L360-.L359
.L359:
	.half	3
	.word	.L362-.L361
.L361:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_MainFunction.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_Prv.h',0,0,0,0,0
.L362:
	.byte	5,29,7,0,5,2
	.word	.L104
	.byte	3,170,5,1,5,28,9
	.half	.L363-.L104
	.byte	1,5,12,9
	.half	.L364-.L363
	.byte	1,5,28,9
	.half	.L365-.L364
	.byte	1,5,48,9
	.half	.L366-.L365
	.byte	1,5,14,9
	.half	.L367-.L366
	.byte	3,253,0,1,9
	.half	.L368-.L367
	.byte	3,134,127,1,9
	.half	.L369-.L368
	.byte	3,13,1,9
	.half	.L370-.L369
	.byte	3,1,1,9
	.half	.L371-.L370
	.byte	3,194,0,1,9
	.half	.L372-.L371
	.byte	3,177,127,1,5,13,9
	.half	.L65-.L372
	.byte	3,3,1,5,38,9
	.half	.L373-.L65
	.byte	1,5,36,9
	.half	.L374-.L373
	.byte	1,5,9,9
	.half	.L375-.L374
	.byte	3,6,1,5,13,9
	.half	.L63-.L375
	.byte	3,10,1,5,29,7,9
	.half	.L376-.L63
	.byte	3,2,1,5,33,9
	.half	.L212-.L376
	.byte	1,5,67,9
	.half	.L68-.L212
	.byte	3,4,1,5,68,9
	.half	.L69-.L68
	.byte	3,4,1,5,57,9
	.half	.L214-.L69
	.byte	3,2,1,5,34,9
	.half	.L215-.L214
	.byte	1,5,56,9
	.half	.L377-.L215
	.byte	1,5,74,9
	.half	.L378-.L377
	.byte	1,5,85,9
	.half	.L379-.L378
	.byte	1,5,111,9
	.half	.L380-.L379
	.byte	1,5,26,9
	.half	.L216-.L380
	.byte	3,5,1,4,2,5,50,9
	.half	.L156-.L216
	.byte	3,220,5,1,5,64,9
	.half	.L213-.L156
	.byte	3,5,1,5,30,9
	.half	.L168-.L213
	.byte	3,94,1,5,5,9
	.half	.L218-.L168
	.byte	3,2,1,5,36,7,9
	.half	.L381-.L218
	.byte	3,2,1,5,20,9
	.half	.L382-.L381
	.byte	1,5,5,9
	.half	.L70-.L382
	.byte	3,3,1,5,25,9
	.half	.L71-.L70
	.byte	3,35,1,5,5,9
	.half	.L72-.L71
	.byte	3,5,1,5,9,7,9
	.half	.L383-.L72
	.byte	3,2,1,5,5,9
	.half	.L73-.L383
	.byte	3,3,1,4,1,5,26,9
	.half	.L74-.L73
	.byte	3,146,122,1,5,47,9
	.half	.L157-.L74
	.byte	3,8,1,5,87,9
	.half	.L384-.L157
	.byte	1,5,13,9
	.half	.L217-.L384
	.byte	1,5,38,7,9
	.half	.L385-.L217
	.byte	3,3,1,5,37,9
	.half	.L386-.L385
	.byte	1,5,21,9
	.half	.L387-.L386
	.byte	1,5,37,9
	.half	.L388-.L387
	.byte	1,5,57,9
	.half	.L389-.L388
	.byte	1,5,17,9
	.half	.L390-.L389
	.byte	1,5,48,7,9
	.half	.L391-.L390
	.byte	3,3,1,5,68,9
	.half	.L392-.L391
	.byte	1,5,48,9
	.half	.L76-.L392
	.byte	3,5,1,5,17,9
	.half	.L77-.L76
	.byte	3,125,1,5,13,9
	.half	.L75-.L77
	.byte	3,74,1,5,38,9
	.half	.L150-.L75
	.byte	3,63,1,5,37,9
	.half	.L393-.L150
	.byte	1,5,21,9
	.half	.L394-.L393
	.byte	1,5,37,9
	.half	.L395-.L394
	.byte	1,5,57,9
	.half	.L396-.L395
	.byte	1,5,17,9
	.half	.L397-.L396
	.byte	1,5,46,7,9
	.half	.L398-.L397
	.byte	3,2,1,5,44,9
	.half	.L399-.L398
	.byte	1,5,65,9
	.half	.L400-.L399
	.byte	1,5,46,9
	.half	.L79-.L400
	.byte	3,4,1,5,44,9
	.half	.L401-.L79
	.byte	1,5,9,9
	.half	.L78-.L401
	.byte	3,4,1,5,63,9
	.half	.L64-.L78
	.byte	3,12,1,5,68,9
	.half	.L219-.L64
	.byte	3,2,1,5,57,9
	.half	.L221-.L219
	.byte	3,2,1,5,34,9
	.half	.L222-.L221
	.byte	1,5,56,9
	.half	.L402-.L222
	.byte	1,5,74,9
	.half	.L403-.L402
	.byte	1,5,85,9
	.half	.L404-.L403
	.byte	1,5,111,9
	.half	.L405-.L404
	.byte	1,5,30,9
	.half	.L223-.L405
	.byte	3,5,1,4,2,5,50,9
	.half	.L180-.L223
	.byte	3,159,5,1,5,64,9
	.half	.L220-.L180
	.byte	3,5,1,5,30,9
	.half	.L183-.L220
	.byte	3,94,1,5,5,9
	.half	.L225-.L183
	.byte	3,2,1,5,36,7,9
	.half	.L406-.L225
	.byte	3,2,1,5,20,9
	.half	.L407-.L406
	.byte	1,5,5,9
	.half	.L82-.L407
	.byte	3,3,1,5,25,9
	.half	.L83-.L82
	.byte	3,35,1,5,5,9
	.half	.L84-.L83
	.byte	3,5,1,5,9,7,9
	.half	.L408-.L84
	.byte	3,2,1,5,5,9
	.half	.L85-.L408
	.byte	3,3,1,4,1,5,26,9
	.half	.L86-.L85
	.byte	3,205,122,1,5,46,9
	.half	.L181-.L86
	.byte	3,2,1,5,85,9
	.half	.L409-.L181
	.byte	1,5,13,9
	.half	.L224-.L409
	.byte	1,5,44,7,9
	.half	.L410-.L224
	.byte	3,3,1,5,67,9
	.half	.L411-.L410
	.byte	1,5,17,9
	.half	.L87-.L411
	.byte	3,5,1,5,42,9
	.half	.L412-.L87
	.byte	1,5,40,9
	.half	.L413-.L412
	.byte	1,5,17,9
	.half	.L414-.L413
	.byte	3,3,1,5,42,9
	.half	.L415-.L414
	.byte	1,5,40,9
	.half	.L416-.L415
	.byte	1,5,9,9
	.half	.L88-.L416
	.byte	3,3,1,5,13,9
	.half	.L66-.L88
	.byte	3,9,1,5,38,9
	.half	.L417-.L66
	.byte	1,5,36,9
	.half	.L418-.L417
	.byte	1,5,9,9
	.half	.L419-.L418
	.byte	3,2,1,5,5,9
	.half	.L67-.L419
	.byte	3,3,1,5,1,9
	.half	.L91-.L67
	.byte	3,1,1,7,9
	.half	.L122-.L91
	.byte	0,1,1
.L360:
	.sdecl	'.debug_ranges',debug,cluster('Fee_LoadNextOrder')
	.sect	'.debug_ranges'
.L121:
	.word	-1,.L104,0,.L122-.L104,0,0
.L149:
	.word	-1,.L104,.L63-.L104,.L75-.L104,.L150-.L104,.L78-.L104,0,0
	.sdecl	'.debug_info',debug,cluster('Fee_SearchNextOrder')
	.sect	'.debug_info'
.L123:
	.word	320
	.half	3
	.word	.L124
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_MainFunction.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L126,.L125
	.byte	2
	.word	.L109
	.byte	3
	.byte	'Fee_SearchNextOrder',0,1,195,6,7
	.word	.L140
	.byte	1,1,1
	.word	.L106,.L186,.L105
	.byte	4
	.byte	'isIntOrder_b',0,1,195,6,35
	.word	.L140,.L187
	.byte	5
	.word	.L106,.L186
	.byte	6
	.byte	'i',0,1,197,6,27
	.word	.L140,.L188
	.byte	6
	.byte	'idxActQueue_u8',0,1,198,6,27
	.word	.L140,.L189
	.byte	6
	.byte	'idexHighPrioOrder_u8',0,1,199,6,27
	.word	.L140,.L190
	.byte	0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('Fee_SearchNextOrder')
	.sect	'.debug_abbrev'
.L124:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('Fee_SearchNextOrder')
	.sect	'.debug_line'
.L125:
	.word	.L421-.L420
.L420:
	.half	3
	.word	.L423-.L422
.L422:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_MainFunction.c',0,0,0,0,0
.L423:
	.byte	5,7,7,0,5,2
	.word	.L106
	.byte	3,194,6,1,5,26,9
	.half	.L226-.L106
	.byte	3,23,1,5,20,9
	.half	.L227-.L226
	.byte	3,3,1,5,10,9
	.half	.L228-.L227
	.byte	3,3,1,5,37,9
	.half	.L229-.L228
	.byte	1,5,32,9
	.half	.L93-.L229
	.byte	3,5,1,5,12,9
	.half	.L231-.L93
	.byte	1,5,56,7,9
	.half	.L424-.L231
	.byte	1,5,75,7,9
	.half	.L425-.L424
	.byte	1,5,28,7,9
	.half	.L95-.L425
	.byte	3,5,1,5,32,9
	.half	.L426-.L95
	.byte	3,7,1,5,16,9
	.half	.L427-.L426
	.byte	1,5,32,9
	.half	.L428-.L427
	.byte	1,5,35,9
	.half	.L429-.L428
	.byte	1,5,13,9
	.half	.L430-.L429
	.byte	1,5,38,9
	.half	.L431-.L430
	.byte	3,3,1,5,13,9
	.half	.L97-.L431
	.byte	3,125,1,5,40,9
	.half	.L98-.L97
	.byte	3,111,1,5,37,9
	.half	.L92-.L98
	.byte	1,5,5,7,9
	.half	.L432-.L92
	.byte	3,30,1,5,24,9
	.half	.L433-.L432
	.byte	3,3,1,5,5,9
	.half	.L99-.L433
	.byte	3,3,1,5,1,9
	.half	.L100-.L99
	.byte	3,1,1,7,9
	.half	.L127-.L100
	.byte	0,1,1
.L421:
	.sdecl	'.debug_ranges',debug,cluster('Fee_SearchNextOrder')
	.sect	'.debug_ranges'
.L126:
	.word	-1,.L106,0,.L127-.L106,0,0
	.sdecl	'.debug_info',debug,cluster('Fee_TriggerHardSectorReorg')
	.sect	'.debug_info'
.L128:
	.word	248
	.half	3
	.word	.L129
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_MainFunction.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L131,.L130
	.byte	2
	.word	.L109
	.byte	3
	.byte	'Fee_TriggerHardSectorReorg',0,1,150,7,22,1,1,1
	.word	.L108,.L191,.L107
	.byte	4
	.byte	'WorkingState_en',0,1,150,7,91
	.word	.L192,.L193
	.byte	5
	.word	.L108,.L191
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('Fee_TriggerHardSectorReorg')
	.sect	'.debug_abbrev'
.L129:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('Fee_TriggerHardSectorReorg')
	.sect	'.debug_line'
.L130:
	.word	.L435-.L434
.L434:
	.half	3
	.word	.L437-.L436
.L436:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_MainFunction.c',0,0,0,0,0
.L437:
	.byte	5,5,7,0,5,2
	.word	.L108
	.byte	3,152,7,1,5,34,9
	.half	.L438-.L108
	.byte	1,5,36,9
	.half	.L439-.L438
	.byte	3,1,1,5,5,9
	.half	.L440-.L439
	.byte	1,5,36,9
	.half	.L441-.L440
	.byte	1,5,34,9
	.half	.L442-.L441
	.byte	1,5,9,9
	.half	.L443-.L442
	.byte	3,25,1,5,34,9
	.half	.L444-.L443
	.byte	1,5,32,9
	.half	.L445-.L444
	.byte	1,5,26,9
	.half	.L446-.L445
	.byte	3,4,1,5,24,9
	.half	.L447-.L446
	.byte	1,5,1,9
	.half	.L448-.L447
	.byte	3,1,1,7,9
	.half	.L132-.L448
	.byte	0,1,1
.L435:
	.sdecl	'.debug_ranges',debug,cluster('Fee_TriggerHardSectorReorg')
	.sect	'.debug_ranges'
.L131:
	.word	-1,.L108,0,.L132-.L108,0,0
	.sdecl	'.debug_info',debug,cluster('Fee_JobTypeMapping')
	.sect	'.debug_info'
.L133:
	.word	188
	.half	3
	.word	.L134
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_MainFunction.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1,2
	.word	.L109
	.byte	3
	.byte	'Fee_JobTypeMapping',0,3,42,40
	.word	.L194
	.byte	1,5,3
	.word	Fee_JobTypeMapping
	.byte	0
	.sdecl	'.debug_abbrev',debug,cluster('Fee_JobTypeMapping')
	.sect	'.debug_abbrev'
.L134:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,0,0,2,61,0,24,16,0,0,3,52,0,3,8,58,15,59,15,57,15,73,16,63,12,2,9
	.byte	0,0,0
	.sdecl	'.debug_info',debug,cluster('Fee_idxActQueueBackUp')
	.sect	'.debug_info'
.L135:
	.word	191
	.half	3
	.word	.L136
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_MainFunction.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1,2
	.word	.L109
	.byte	3
	.byte	'Fee_idxActQueueBackUp',0,3,89,23
	.word	.L140
	.byte	1,5,3
	.word	Fee_idxActQueueBackUp
	.byte	0
	.sdecl	'.debug_abbrev',debug,cluster('Fee_idxActQueueBackUp')
	.sect	'.debug_abbrev'
.L136:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,0,0,2,61,0,24,16,0,0,3,52,0,3,8,58,15,59,15,57,15,73,16,63,12,2,9
	.byte	0,0,0
	.sdecl	'.debug_info',debug,cluster('Fee_Rb_WorkingStateBackUp_en')
	.sect	'.debug_info'
.L137:
	.word	198
	.half	3
	.word	.L138
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_MainFunction.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1,2
	.word	.L109
	.byte	3
	.byte	'Fee_Rb_WorkingStateBackUp_en',0,3,83,45
	.word	.L192
	.byte	1,5,3
	.word	Fee_Rb_WorkingStateBackUp_en
	.byte	0
	.sdecl	'.debug_abbrev',debug,cluster('Fee_Rb_WorkingStateBackUp_en')
	.sect	'.debug_abbrev'
.L138:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,0,0,2,61,0,24,16,0,0,3,52,0,3,8,58,15,59,15,57,15,73,16,63,12,2,9
	.byte	0,0,0
	.sdecl	'.debug_loc',debug,cluster('Fee_LoadNextOrder')
	.sect	'.debug_loc'
.L103:
	.word	-1,.L104,0,.L146-.L104
	.half	2
	.byte	138,0
	.word	0,0
.L148:
	.word	-1,.L104,.L157-.L104,.L217-.L104
	.half	1
	.byte	85
	.word	.L181-.L104,.L224-.L104
	.half	1
	.byte	85
	.word	0,0
.L159:
	.word	0,0
.L152:
	.word	-1,.L104,.L214-.L104,.L215-.L104
	.half	1
	.byte	95
	.word	0,0
.L177:
	.word	-1,.L104,.L221-.L104,.L222-.L104
	.half	1
	.byte	95
	.word	0,0
.L151:
	.word	-1,.L104,.L212-.L104,.L68-.L104
	.half	5
	.byte	144,32,157,32,0
	.word	.L69-.L104,.L213-.L104
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L176:
	.word	-1,.L104,.L219-.L104,.L220-.L104
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L154:
	.word	-1,.L104,.L216-.L104,.L217-.L104
	.half	1
	.byte	81
	.word	0,0
.L179:
	.word	-1,.L104,.L223-.L104,.L224-.L104
	.half	1
	.byte	81
	.word	0,0
.L174:
	.word	-1,.L104,.L218-.L104,.L157-.L104
	.half	1
	.byte	85
	.word	0,0
.L184:
	.word	-1,.L104,.L225-.L104,.L181-.L104
	.half	1
	.byte	85
	.word	0,0
.L166:
	.word	-1,.L104,.L213-.L104,.L217-.L104
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L182:
	.word	-1,.L104,.L220-.L104,.L224-.L104
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L163:
	.word	0,0
.L153:
	.word	-1,.L104,.L156-.L104,.L217-.L104
	.half	1
	.byte	82
	.word	0,0
.L178:
	.word	-1,.L104,.L180-.L104,.L224-.L104
	.half	1
	.byte	82
	.word	0,0
.L185:
	.word	0,0
.L175:
	.word	0,0
.L161:
	.word	0,0
.L172:
	.word	0,0
.L170:
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('Fee_MainFunction')
	.sect	'.debug_loc'
.L101:
	.word	-1,.L102,0,.L195-.L102
	.half	2
	.byte	138,0
	.word	.L195-.L102,.L139-.L102
	.half	2
	.byte	138,8
	.word	.L139-.L102,.L139-.L102
	.half	2
	.byte	138,0
	.word	0,0
.L141:
	.word	-1,.L102,.L200-.L102,.L201-.L102
	.half	1
	.byte	84
	.word	.L16-.L102,.L202-.L102
	.half	1
	.byte	84
	.word	.L13-.L102,.L18-.L102
	.half	1
	.byte	84
	.word	0,0
.L144:
	.word	-1,.L102,0,.L139-.L102
	.half	2
	.byte	145,120
	.word	0,0
.L145:
	.word	-1,.L102,.L198-.L102,.L199-.L102
	.half	5
	.byte	144,32,157,32,0
	.word	.L5-.L102,.L197-.L102
	.half	5
	.byte	144,32,157,32,0
	.word	.L6-.L102,.L205-.L102
	.half	5
	.byte	144,32,157,32,0
	.word	.L4-.L102,.L207-.L102
	.half	5
	.byte	144,32,157,32,0
	.word	.L9-.L102,.L209-.L102
	.half	5
	.byte	144,32,157,32,0
	.word	.L7-.L102,.L210-.L102
	.half	5
	.byte	144,32,157,32,0
	.word	.L8-.L102,.L211-.L102
	.half	5
	.byte	144,32,157,32,0
	.word	.L10-.L102,.L22-.L102
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L143:
	.word	-1,.L102,.L196-.L102,.L197-.L102
	.half	1
	.byte	88
	.word	.L197-.L102,.L203-.L102
	.half	1
	.byte	82
	.word	.L204-.L102,.L205-.L102
	.half	1
	.byte	88
	.word	.L205-.L102,.L4-.L102
	.half	1
	.byte	82
	.word	.L206-.L102,.L207-.L102
	.half	1
	.byte	88
	.word	.L207-.L102,.L9-.L102
	.half	1
	.byte	82
	.word	.L208-.L102,.L139-.L102
	.half	1
	.byte	88
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('Fee_SearchNextOrder')
	.sect	'.debug_loc'
.L105:
	.word	-1,.L106,0,.L186-.L106
	.half	2
	.byte	138,0
	.word	0,0
.L188:
	.word	-1,.L106,.L229-.L106,.L186-.L106
	.half	1
	.byte	91
	.word	.L230-.L106,.L231-.L106
	.half	1
	.byte	84
	.word	0,0
.L190:
	.word	-1,.L106,.L227-.L106,.L186-.L106
	.half	1
	.byte	89
	.word	0,0
.L189:
	.word	-1,.L106,.L228-.L106,.L186-.L106
	.half	1
	.byte	90
	.word	.L232-.L106,.L186-.L106
	.half	1
	.byte	82
	.word	0,0
.L187:
	.word	-1,.L106,0,.L93-.L106
	.half	1
	.byte	84
	.word	.L226-.L106,.L186-.L106
	.half	1
	.byte	88
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('Fee_TriggerHardSectorReorg')
	.sect	'.debug_loc'
.L107:
	.word	-1,.L108,0,.L191-.L108
	.half	2
	.byte	138,0
	.word	0,0
.L193:
	.word	-1,.L108,0,.L191-.L108
	.half	1
	.byte	84
	.word	0,0
	.sdecl	'.debug_frame',debug
	.sect	'.debug_frame'
.L449:
	.word	48
	.word	-1
	.byte	3,0,2,1,27,12,26,0,8,27,8,26,8,28,8,29,8,30,8,31,8,34,8,35,8,32,8,33,8,16,8,17,8,24,8,25,8,36,8,37,8,38
	.byte	8,39
	.sdecl	'.debug_frame',debug,cluster('Fee_MainFunction')
	.sect	'.debug_frame'
	.word	36
	.word	.L449,.L102,.L139-.L102
	.byte	4
	.word	(.L195-.L102)/2
	.byte	19,8,22,26,3,19,138,8,4
	.word	(.L139-.L195)/2
	.byte	19,0,8,26,0,0
	.sdecl	'.debug_frame',debug,cluster('Fee_LoadNextOrder')
	.sect	'.debug_frame'
	.word	12
	.word	.L449,.L104,.L146-.L104
	.sdecl	'.debug_frame',debug,cluster('Fee_SearchNextOrder')
	.sect	'.debug_frame'
	.word	12
	.word	.L449,.L106,.L186-.L106
	.sdecl	'.debug_frame',debug,cluster('Fee_TriggerHardSectorReorg')
	.sect	'.debug_frame'
	.word	24
	.word	.L449,.L108,.L191-.L108
	.byte	8,19,8,20,8,21,8,22,8,23,0,0

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   953  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   954  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   955  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   956  /* FEE_PRESENT == 1 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   957  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   958  /* 1 == FEE_PRV_CFG_SELECTED_FS */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   959  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   960  /*<BASDKey>
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   961  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   962  * $History__:$
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   963  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_MainFunction.c	   964  </BASDKey>*/

	; Module end
