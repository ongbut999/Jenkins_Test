	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 19053136 SN 09001910"
	.compiler_invocation	"ctc -f cc16468a -c99 --integer-enumeration -D__CPU__=tc27x -D__CPU_TC27X__ --core=tc1.6.x --eabi-compliant --fp-model=-float -D_TASKING_C_TRICORE_=1 -I.\\output\\inc -g2 -t4 --language=-comments,-gcc,+volatile,-strings --default-near-size=0 -O2ROPYGKLF-predict --default-a1-size=0 --default-a0-size=0 --source --switch=auto -o output\\objs\\BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\rba_FeeFs1_LlWriteBlock.src BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlWriteBlock.c"
	.compiler_name		"ctc"
	;source	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlWriteBlock.c'

	
$TC16X
	
	.sdecl	'.text.rba_FeeFs1_LlWriteBlock.Fee_LLWriteBlock',code,cluster('Fee_LLWriteBlock')
	.sect	'.text.rba_FeeFs1_LlWriteBlock.Fee_LLWriteBlock'
	.align	2
	
	.global	Fee_LLWriteBlock

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	     1  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	     2  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	     3  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	     4  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	     5   **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	     6   * \moduledescription
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	     7   *           AUTOSAR FEE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	     8   *           According to Document Version 3.0.0, Part of Release 4.0, Revision 2
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	     9   * \scope    INTERN
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    10   **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    11   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    12  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    13  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    14  /*
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    15   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    16   * Includes
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    17   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    18   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    19  #include "Fee.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    20  #include "rba_FeeFs1_Prv.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    21  #include "Fls.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    22  #include "Crc.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    23  #if (!defined(FLS_AR_RELEASE_MAJOR_VERSION) || (FLS_AR_RELEASE_MAJOR_VERSION != FEE_AR_RELEASE_MAJOR_VERSION))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    24      #error "AUTOSAR major version undefined or mismatched"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    25  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    26  #if (!defined(FLS_AR_RELEASE_MINOR_VERSION) || ((FLS_AR_RELEASE_MINOR_VERSION != 0) && (FLS_AR_RELEASE_MINOR_VERSION != 2)))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    27      #error "AUTOSAR minor version undefined or mismatched"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    28  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    29  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    30  #if(defined(FEE_PRV_CFG_SELECTED_FS) && (1 == FEE_PRV_CFG_SELECTED_FS))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    31  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    32  #if (FEE_PRESENT == 1)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    33  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    34  #if(FEE_ROBUST_PROG_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    35  /* Ifx robust programming */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    36  #define FEE_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    37  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    38  Fee_IfxRobustProgramming_t Fee_IfxRobustProgramming_s;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    39  #define FEE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    40  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    41  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    42  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    43  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    44  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    45   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    46   * Fee_LLWriteBlock(): Write a block into a sector
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    47   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    48   * This function is used to write a block into the memory media. The
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    49   * data is being programmed and verified afterwards automatically. In
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    50   * case a sector erase is necessary, this operation is also performed.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    51   * The marker handling is done automatically in case an ERASED,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    52   * USED or FULL marker has to be written.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    53   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    54   * \param    Info_ptr:  Pointer to the block header info
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    55   * \param    Data_pcu8: Pointer the data to be compared
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    56   * \return   Function result
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    57   * \retval   FEE_ORDER_PENDING_E:   Order is still pending
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    58   * \retval   FEE_ABORTED_E:         Order was aborted due to a wrong
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    59   *                                  FLS compare function call
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    60   * \retval   FEE_ERROR_E:           Difference detected after the
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    61   *                                  programming sequence
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    62   * \retval   FEE_SECTORFULL_E:      The write order cannot be executed
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    63   *                                  because the HSR threshold will be
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    64   *                                  exceeded
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    65   * \retval   FEE_ORDER_FINISHED_E:  Order finished successfully
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    66   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    67   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    68   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    69   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    70  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    71  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    72  FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLWriteBlock(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Info_ptr,
; Function Fee_LLWriteBlock
.L133:
Fee_LLWriteBlock:	.type	func
	sub.a	a10,#16
.L199:
	mov.aa	a13,a4
.L201:
	st.a	[a10]8,a5
.L202:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    73                                                    P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) Data_pcu8)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    74  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    75      VAR(Fee_stRetVal_ten, AUTOMATIC) xRetVal_en         = FEE_ORDER_PENDING_E;
	mov	d8,#0
.L203:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    76      VAR(Fee_stRetVal_ten, AUTOMATIC) xCompareRetVal_en  = FEE_ORDER_PENDING_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    77      VAR(Fee_stRetVal_ten, AUTOMATIC) xWrMarkerRetVal_en;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    78      VAR(Fee_stRetVal_ten, AUTOMATIC) xErSectorRetVal_en;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    79  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    80      VAR(uint16, AUTOMATIC)           xNumBytes_u16      = 0;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    81      VAR(uint16, AUTOMATIC)           xTempNumBytes_u16  = 0;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    82      VAR(uint32, AUTOMATIC)           xNumFreeBytes_u32  = 0;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    83      VAR(uint8, AUTOMATIC)            xCnt_u8            = 0;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    84      VAR(uint16, AUTOMATIC)           xCnt_u16           = 0;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    85      VAR(uint8, AUTOMATIC)            xPhySectIdx_u8     = 0;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    86      VAR(uint8, AUTOMATIC)            xLogSectIdx_u8     = 0;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    87      VAR(uint8, AUTOMATIC)            xTempPadding       = 0;
	mov	d9,#0
.L204:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    88  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    89      #if(FEE_ROB_FEATURE_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    90      VAR(uint8, AUTOMATIC)       i_u8                    = 0;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    91      VAR(uint16, AUTOMATIC)      xNumBytesCutOff_u16     = 0;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    92      VAR(uint8, AUTOMATIC)       xCrcOffset_u8           = 0;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    93      VAR(uint8, AUTOMATIC)       xNumCrcBytes_u8         = 0;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    94      VAR(uint32, AUTOMATIC)      xBlkCrc32Tmp_u32        = 0;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    95      static uint32               xBlkCrc32Result_u32     = 0;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    96      static uint8                xNumCrcBytesDone_u8     = 0;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    97      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    98  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	    99      static uint32 cntProgrammedBytes_u32 = 0;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   100      uint32 tmpAddr_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   101  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   102      /* Switch over the state machine for writing a block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   103      switch(Fee_RdWrOrder_st.Fee_LLWrBlock_en)
	movh.a	a12,#@his(Fee_RdWrOrder_st)
	lea	a12,[a12]@los(Fee_RdWrOrder_st)
.L311:
	lea	a15,[a12]60
	st.a	[a10]4,a15
	ld.w	d15,[a12]60
.L312:
	mov	d0,#16
	jlt	d0,d15,.L2
	mov	d0,#0
	jlt	d15,d0,.L2
	sub	d0,d15,d0
	movh.a	a2,#@his(.1.jmp)
	lea	a2,[a2]@los(.1.jmp)
	addsc.a	a2,a2,d0,#2
	ld.a	a2,[a2]
	ji	a2
.L2:
	j	.L3
.L200:
	
	.sdecl	'.rodata.rba_FeeFs1_LlWriteBlock..1.jmp',data,rom
	.sect	'.rodata.rba_FeeFs1_LlWriteBlock..1.jmp'
	.align	4
.1.jmp:	.type	object
	.word	.L4
	.word	.L5
	.word	.L6
	.word	.L7
	.word	.L8
	.word	.L9
	.word	.L10
	.word	.L11
	.word	.L12
	.word	.L13
	.word	.L14
	.word	.L15
	.word	.L16
	.word	.L17
	.word	.L18
	.word	.L19
	.word	.L20
	
	.sect	'.text.rba_FeeFs1_LlWriteBlock.Fee_LLWriteBlock'

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   104      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   105          /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   106          case FEE_LL_WR_BLK_INIT_E:
.L4:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   107          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   108              /* Reset state machines */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   109              Fee_RdWrOrder_st.Fee_LLNextUsedWrBlock_en  = FEE_LL_WR_BLK_INIT_E;
	lea	a13,[a12]68
.L207:
	mov	d0,#0
.L313:
	st.w	[a13],d0
.L314:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   110              Fee_RdWrOrder_st.Fee_LLNextEraseWrBlock_en = FEE_LL_WR_BLK_INIT_E;
	lea	a14,[a12]72
.L315:
	mov	d0,#0
.L316:
	st.w	[a14],d0
.L317:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   111  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   112              /* Reset the page buffer to make sure no wrong data remains inside */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   113              Fee_SrvMemSet8((uint8*)&Fee_DataBytePtr_cpu8[0], (uint8)FEE_ERASE_PATTERN, FEE_LL_DATABUFFSIZE);
	movh.a	a2,#@his(Fee_DataBytePtr_cpu8)
	lea	a2,[a2]@los(Fee_DataBytePtr_cpu8)
	ld.a	a4,[a2]
.L206:
	mov	d4,#0
.L318:
	mov	d5,#256
	call	Fee_SrvMemSet8
.L205:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   114  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   115              /* Get the logical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   116              xLogSectIdx_u8 = Fee_idxLLSectorOrder_au8[Fee_GetPhysSectorByAddress(Fee_RdWrOrder_st.xWrAddress)];
	mov.aa	a15,a12
	add.a	a15,#4
	st.a	[a10],a15
	ld.w	d4,[a15]
	call	Fee_GetPhysSectorByAddress
.L319:
	movh.a	a15,#@his(Fee_idxLLSectorOrder_au8)
	lea	a15,[a15]@los(Fee_idxLLSectorOrder_au8)
.L320:
	addsc.a	a15,a15,d2,#0
	ld.bu	d4,[a15]
.L209:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   117  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   118              #if(FEE_ROB_FEATURE_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   119              /* Get the start value for the CRC calculation and reset the considered Crc bytes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   120              xBlkCrc32Result_u32 = Fee_DataByteStartCrc_u32;
	movh.a	a15,#@his(_999001_xBlkCrc32Result_u32)
	lea	a15,[a15]@los(_999001_xBlkCrc32Result_u32)
.L321:
	movh.a	a2,#@his(Fee_DataByteStartCrc_u32)
	lea	a2,[a2]@los(Fee_DataByteStartCrc_u32)
	ld.w	d0,[a2]
.L322:
	st.w	[a15],d0
.L323:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   121              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   122  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   123              cntProgrammedBytes_u32 = 0;
	movh.a	a15,#@his(_999003_cntProgrammedBytes_u32)
	lea	a15,[a15]@los(_999003_cntProgrammedBytes_u32)
.L324:
	mov	d0,#0
.L325:
	st.w	[a15],d0
.L326:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   124  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   125              #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)    /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   126              /* Initalise the address for 2nd header page to indicate that 2nd header page is not yet programmed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   127              Fee_RdWrOrder_st.xHdPg2Address = FEE_NULL;
	lea	a15,[a12]28
.L327:
	mov	d15,#0
.L328:
	st.w	[a15],d15
.L329:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   128              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   129  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   130              /* Check the current sector state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   131              switch(Fee_LLSectorOrder_st[xLogSectIdx_u8].SecState_en)
	movh.a	a2,#@his(Fee_LLSectorOrder_st)
	lea	a2,[a2]@los(Fee_LLSectorOrder_st)
.L330:
	mul	d15,d4,#12
	addsc.a	a15,a2,d15,#0
.L331:
	ld.w	d15,[a15]4
.L332:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   132              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   133                  /* Current sector is used */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   134                  case FEE_SECTOR_USED_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   135                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   136                      /* Go on with writing of the NoFallback marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   137                      Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_SIZECHECK_HSR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   138                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   139                  break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   140  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   141                  /* Sector state is undefined */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   142                  case FEE_SECTOR_STATE_UNDEF_E:
	mov	d0,#0
	jeq	d15,d0,.L21
.L333:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   143                  case FEE_SECTOR_REQUEST2ERASE_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   144                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   145                      /* This state cannot be reached (unless the sectors did not get the chance
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   146                       * to be erased in the background after the production) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   147  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   148                      /* Erase this sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   149                      Fee_LLSetEraseSector(xLogSectIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   150  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   151                      /* Write the ERASED marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   152                      Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_ERASE_SECTOR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   153  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   154                      /* Go back to the init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   155                      Fee_RdWrOrder_st.Fee_LLNextEraseWrBlock_en = FEE_LL_WR_BLK_INIT_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   156                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   157                  break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   158  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   159                  /* Sector state is full */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   160                  case FEE_SECTOR_FULL_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   161                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   162                      /* The next sector has to be used for the current write order. The USED marker has
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   163                       * to be written before */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   164  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   165                      /* Increment the logical sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   166                      xLogSectIdx_u8++;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   167  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   168                      /* Check if the last sector is reached */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   169                      if(xLogSectIdx_u8 >= FEE_NUM_FLASH_BANKS)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   170                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   171                          /* Error case: all sectors are full (this assumption is guaranteed by the logical
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   172                           *             sector order mechanism)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   173                           * --> erase the most current sector in order to get the chance to keep data
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   174                           *     that is never written (which will be located in the oldest FULL sector).
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   175                           *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   176                           * Hint: This is a backup solution since the hard sector reorganization will
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   177                           *       run first which erases one sector already. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   178  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   179                          /* Restrict the logical sector index to the maximum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   180                          xLogSectIdx_u8 = FEE_NUM_FLASH_BANKS - 1;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   181  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   182                          /* Get the physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   183                          xPhySectIdx_u8 = Fee_LLSectorOrder_st[xLogSectIdx_u8].xPhySecIdx_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   184  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   185                          /* Get the start address for write accesses */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   186                          Fee_RdWrOrder_st.xWrAddress = Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogStartAddress_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   187  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   188                          /* Mark the sector to be erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   189                          Fee_LLSetEraseSector(xLogSectIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   190  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   191                          /* Set the next state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   192                          Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_ERASE_SECTOR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   193  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   194                          /* Come back to the write USED marker state as soon as erasing is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   195                          Fee_RdWrOrder_st.Fee_LLNextEraseWrBlock_en = FEE_LL_WR_WRITE_USED_MARKER_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   196  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   197                          /* Come back to the write of the NoFallback marker state after the USED marker is written */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   198                          Fee_RdWrOrder_st.Fee_LLNextUsedWrBlock_en = FEE_LL_WR_SIZECHECK_HSR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   199  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   200                          /* Invalidate the complete cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   201                          for(xCnt_u16=0; xCnt_u16<FEE_NUM_BLOCKS; xCnt_u16++)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   202                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   203                              /* Invalidate the corresponding cache address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   204                              Fee_LLInvalidateAddressInCache(Fee_BlockProperties_st[xCnt_u16].BlockPersistentId_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   205                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   206  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   207                          /* Invalidate the complete cache status */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   208                          for(xCnt_u8=0; xCnt_u8<FEE_NUM_FLASH_BANKS; xCnt_u8++)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   209                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   210                              /* Invalidate the corresponding physical sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   211                              Fee_LLEraseCacheStForSect(xCnt_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   212                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   213                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   214                      else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   215                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   216                          /* It is possible that the next logical sector is not erased yet!
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   217                           * In this case, the sector has to be erased first
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   218                           * Hint: it is actually not possible that the next sector after an active FULL sector
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   219                           *       is in the FULL state (error case)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   220                           *       --> erase the most current FULL sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   221  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   222                          /* Get the new physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   223                          xPhySectIdx_u8 = Fee_LLSectorOrder_st[xLogSectIdx_u8].xPhySecIdx_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   224  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   225                          /* Get the new start address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   226                          Fee_RdWrOrder_st.xWrAddress = Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogStartAddress_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   227  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   228                          /* Verify the sector state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   229                          if(Fee_LLSectorOrder_st[xLogSectIdx_u8].SecState_en == FEE_SECTOR_ERASED_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   230                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   231                              /* The new logical sector is already erased*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   232  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   233                              /* Set the next state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   234                              Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_WRITE_USED_MARKER_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   235  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   236                              /* Come back to the write of the NoFallback marker state after the USED marker is written */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   237                              Fee_RdWrOrder_st.Fee_LLNextUsedWrBlock_en = FEE_LL_WR_SIZECHECK_HSR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   238                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   239                          else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   240                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   241                              /* The new logical sector has to be erased first */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   242  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   243                              /* Mark the sector to be erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   244                              Fee_LLSetEraseSector(xLogSectIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   245  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   246                              /* Set the next state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   247                              Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_ERASE_SECTOR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   248  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   249                              /* Come back to the write USED marker state as soon as erasing is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   250                              Fee_RdWrOrder_st.Fee_LLNextEraseWrBlock_en = FEE_LL_WR_WRITE_USED_MARKER_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   251  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   252                              /* Come back to the write of the NoFallback marker state after the USED marker is written */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   253                              Fee_RdWrOrder_st.Fee_LLNextUsedWrBlock_en = FEE_LL_WR_SIZECHECK_HSR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   254                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   255                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   256                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   257                  break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   258  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   259                  /* Sector was erased before */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   260                  case FEE_SECTOR_ERASED_E:
	mov	d0,#1
	jeq	d15,d0,.L22
.L334:
	mov	d0,#2
	jeq	d15,d0,.L23
.L335:
	mov	d0,#3
	jeq	d15,d0,.L24
.L336:
	mov	d0,#4
	jeq	d15,d0,.L25
.L337:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   261                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   262                      /* State can be reached if the flash was erased before */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   263  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   264                      /* Write the USED marker next */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   265                      Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_WRITE_USED_MARKER_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   266  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   267                      /* Come back to the write of the NoFallback marker state after the USED marker is written */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   268                      Fee_RdWrOrder_st.Fee_LLNextUsedWrBlock_en = FEE_LL_WR_SIZECHECK_HSR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   269                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   270                  break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   271  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   272                  /* Default states */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   273                  case FEE_SECTOR_CONSIDERED_E:
	mov	d0,#13
	jeq	d15,d0,.L26
	j	.L27
.L23:
	mov	d15,#2
.L338:
	ld.a	a15,[a10]4
	st.w	[a15],d15
.L339:
	j	.L28
.L21:
.L25:
	call	Fee_LLSetEraseSector
.L210:
	mov	d15,#11
.L340:
	ld.a	a15,[a10]4
	st.w	[a15],d15
.L341:
	mov	d15,#0
.L342:
	st.w	[a14],d15
.L343:
	j	.L29
.L24:
	add	d4,#1
.L211:
	extr.u	d4,d4,#0,#8
.L212:
	movh.a	a4,#@his(Fee_FlashProp_st)
	lea	a4,[a4]@los(Fee_FlashProp_st)
.L344:
	movh.a	a12,#@his(Fee_NumFlashBanksUsed_u8)
	lea	a12,[a12]@los(Fee_NumFlashBanksUsed_u8)
	ld.bu	d15,[a12]
.L345:
	jlt.u	d4,d15,.L30
.L346:
	add	d15,#-1
	extr.u	d4,d15,#0,#8
.L347:
	mul	d15,d4,#12
	addsc.a	a15,a2,d15,#0
.L348:
	ld.bu	d15,[a15]8
.L214:
	sha	d15,#4
.L215:
	addsc.a	a15,a4,d15,#0
.L349:
	ld.w	d15,[a15]8
.L350:
	ld.a	a15,[a10]
	st.w	[a15],d15
.L351:
	call	Fee_LLSetEraseSector
.L213:
	mov	d15,#11
.L352:
	ld.a	a15,[a10]4
	st.w	[a15],d15
.L353:
	mov	d15,#12
.L354:
	st.w	[a14],d15
.L355:
	mov	d15,#2
.L356:
	st.w	[a13],d15
.L357:
	mov	d9,#0
.L208:
	j	.L31
.L32:
	sha	d15,d9,#4
	movh.a	a15,#@his(Fee_BlockProperties_st)
	lea	a15,[a15]@los(Fee_BlockProperties_st)
	addsc.a	a15,a15,d15,#0
	ld.hu	d4,[a15]0
	mov.u	d5,#45054
	addih	d5,d5,#51966
	call	Fee_LLUpdateAddressInCache
.L358:
	add	d9,#1
.L31:
	jlt.u	d9,#12,.L32
.L359:
	mov	d15,#0
.L216:
	j	.L33
.L34:
	mov	d4,d15
.L218:
	call	Fee_LLEraseCacheStForSect
.L219:
	add	d15,#1
.L217:
	extr.u	d15,d15,#0,#8
.L33:
	ld.bu	d0,[a12]
.L360:
	jlt.u	d15,d0,.L34
.L361:
	j	.L35
.L30:
	mul	d15,d4,#12
	addsc.a	a15,a2,d15,#0
.L362:
	ld.bu	d15,[a15]8
.L221:
	sha	d15,#4
.L222:
	addsc.a	a2,a4,d15,#0
.L363:
	ld.w	d15,[a2]8
.L364:
	ld.a	a2,[a10]
	st.w	[a2],d15
.L365:
	ld.w	d15,[a15]4
.L366:
	jne	d15,#1,.L36
.L367:
	mov	d15,#12
.L368:
	ld.a	a15,[a10]4
	st.w	[a15],d15
.L369:
	mov	d15,#2
.L370:
	st.w	[a13],d15
.L371:
	j	.L37
.L36:
	call	Fee_LLSetEraseSector
.L220:
	mov	d15,#11
.L372:
	ld.a	a15,[a10]4
	st.w	[a15],d15
.L373:
	mov	d15,#12
.L374:
	st.w	[a14],d15
.L375:
	mov	d15,#2
.L376:
	st.w	[a13],d15
.L37:
.L35:
	j	.L38
.L22:
	mov	d15,#12
.L377:
	ld.a	a15,[a10]4
	st.w	[a15],d15
.L378:
	mov	d15,#2
.L379:
	st.w	[a13],d15
.L380:
	j	.L39
.L26:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   274                  default:
.L27:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   275                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   276                      /* States should never be reached */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   277                      xRetVal_en = FEE_ABORTED_E;
	mov	d8,#6
.L381:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   278                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   279                  break;
	j	.L40

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   280              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   281          }
.L40:
.L39:
.L38:
.L29:
.L28:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   282          break;
	j	.L41

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   283  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   284  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   285          // for the first copy written whithin this stateflow, check whether
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   286          // there is enough space to the HSR for all blocks to be written.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   287          case FEE_LL_WR_SIZECHECK_HSR_E:
.L6:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   288          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   289              uint32 neededSpace_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   290  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   291              // Is it the first execution cycle?
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   292              if(Fee_GlobInfoWrBlock_st.cntCopies_u8 == FEE_CNT_FIRST_COPY)
	movh.a	a15,#@his(Fee_GlobInfoWrBlock_st)
	lea	a15,[a15]@los(Fee_GlobInfoWrBlock_st)
.L382:
	lea	a15,[a15]8
	ld.bu	d15,[a15]
.L383:
	jne	d15,#0,.L42
.L172:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   293              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   294                  uint16 dataLen_u16 , blockPropIdx_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   295                  boolean noFbActive_b , doubleSecActive_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   296  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   297                  // calculate the space needed to check against the HSR threshold
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   298                  dataLen_u16 = Info_ptr->BlkLength_u16;// if invalidate order, block length is replaced with 0
	ld.hu	d0,[a13]10
.L224:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   299  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   300                  blockPropIdx_u16 = Fee_OrderFifo_st[Fee_idxActQueue_u8].BlockPropIdx_u16;
	movh.a	a15,#@his(Fee_idxActQueue_u8)
	lea	a15,[a15]@los(Fee_idxActQueue_u8)
	ld.bu	d15,[a15]
.L384:
	mul	d15,d15,#24
.L385:
	movh.a	a15,#@his(Fee_OrderFifo_st)
	lea	a15,[a15]@los(Fee_OrderFifo_st)
.L386:
	addsc.a	a15,a15,d15,#0
.L387:
	ld.hu	d15,[a15]6
.L226:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   301  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   302                  doubleSecActive_b = (Fee_BlockProperties_st[blockPropIdx_u16].Flags_u16 & FEE_FLAG_SEC_LEVEL_MSK) > 0u;
	sha	d15,#4
.L227:
	movh.a	a15,#@his(Fee_BlockProperties_st)
	lea	a15,[a15]@los(Fee_BlockProperties_st)
.L388:
	addsc.a	a15,a15,d15,#0
.L389:
	ld.hu	d15,[a15]2
.L390:
	and	d15,#1
.L391:
	ne	d1,d15,#0
.L228:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   303  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   304                  #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   305                      noFbActive_b  = (Fee_BlockProperties_st[blockPropIdx_u16].Flags_u16 & FEE_FLAG_NOFALLBACK_MSK) > 0u;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   306                  #else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   307                      noFbActive_b = FALSE;
	mov	d2,#0
.L178:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     1  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     2  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     3  #ifndef RBA_FEEFS1_PRV_H
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     4  #define RBA_FEEFS1_PRV_H
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     5  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     6  #if(defined(FEE_PRV_CFG_SELECTED_FS) && (1 == FEE_PRV_CFG_SELECTED_FS))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     7  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     8  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	     9   **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    10   * \moduledescription
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    11   *           AUTOSAR FEE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    12   *           According to Document Version 3.0.0, Part of Release 4.0, Revision 2
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    13   * \scope    INTERN
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    14   **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    15   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    16  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    17  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    18  /*
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    19  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    20  * Defines/Macros
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    21  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    22  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    23  /* General defines */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    24  #define FEE_MAXUINT32               (0xFFFFFFFFuL)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    25  #define FEE_MAXUINT16               (0xFFFFu)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    26  #define FEE_NULL                    (0u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    27  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    28  #define FEE_MARKER_PATTERN          0xCAFEu                 /* Pattern to identify a marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    29  #define FEE_NUM_MARKER_IN_HEADER    (FEE_NUM_MARKER_E - 1)  /* A sector has at least 4 states:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    30                                                                 ERASED -> USED -> FULL -> ERASE_REQ
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    31                                                                 Value is also in used in Fee_Process.pm */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    32  #define FEE_NO_SEC_IDX_FOUND        0xFFu                   /* No active sector / matching flash bank found */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    33  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    34  #define FEE_MARKER_SIZE             8u                      /* Each marker has a size of 8 Bytes (fix value is used in Fee_Process.pm) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    35  #define FEE_MARKER_CS_SIZE          2u                      /* Size of CRC16 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    36  #define FEE_LL_DATABUFFSIZE         256u                    /* Size of the internal data buffer used for writing */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    37                                                              /* (The page buffer size is auto generated) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    38  #define FEE_LL_CRC_CALC_RESTRICTION FEE_LL_DATABUFFSIZE     /* Restriction for the Crc calculation */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    39  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    40  #define FEE_FREE_PAGES_FOR_ERASED_ST    1u                  /* Number of pages containing the erased value */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    41  #define FEE_SIZE_OF_BLOCK_CS            4                   /* Size of block checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    42  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    43  /* Special values for sector change counter within the RAM array */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    44  #define FEE_SEC_CHANGE_CNT_RESET_REQ  0xFFFFFFFFuL
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    45  #define FEE_SEC_CHANGE_CNT_UNDEF      FEE_SEC_CHANGE_CNT_RESET_REQ
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    46  #define FEE_SEC_CHANGE_CNT_ERASED     (FEE_SEC_CHANGE_CNT_RESET_REQ - 1u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    47  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    48  /* Mask for accessing block flags in the configuration and in the block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    49  #define FEE_FLAG_SEC_LEVEL_MSK      0x0001u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    50  #define FEE_FLAG_SEC_LEVEL_BP       0u       /* Security level setting is bit 0 within the block flags */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    51  #define FEE_BLK_INT_DOUBLE_STORAGE  1u       /* Internal double block storage definition */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    52  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    53  #define FEE_FLAG_DATAFILTERTYPE_ATTR_MSK      0x0006u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    54  #define FEE_FLAG_DATAFILTERTYPE_ATTR_BP       1u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    55  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    56  #define FEE_FLAG_INVALID_MSK        0x08u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    57  #define FEE_FLAG_INVALID_BP         3u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    58  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    59  #define FEE_FLAG_SURV_ATTR_MSK      0x0010u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    60  #define FEE_FLAG_SURV_ATTR_BP       4u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    61  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    62  #define FEE_FLAG_ROBUST_ATTR_MSK    0x0020
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    63  #define FEE_FLAG_ROBUST_ATTR_BP     5
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    64  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    65  #define FEE_FLAG_NOFALLBACK_MSK     0x0040u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    66  #define FEE_FLAG_NOFALLBACK_BP      6u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    67  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    68  #define FEE_MASK_BIT7               (uint8)0x80
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    69  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    70  /* Mask for accessing block flags (upper byte only) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    71  #define FEE_FLAG_JOBTYPE_MSK        0x0300u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    72  #define FEE_FLAG_JOBTYPE_BP         8u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    73  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    74  #define FEE_FLAG_JOBPRIO_MSK        0x0400u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    75  #define FEE_FLAG_JOBPRIO_BP         10u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    76  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    77  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    78  /* Macros for the conversion of the Sec Level settings:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    79   * Internal storage level:      Sec Level 1  --> 0 / Sec Level 2 --> 1
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    80   * User Config storage level:   Sec Level 1  --> 1 / Sec Level 2 --> 2 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    81  #define FEE_INT_TO_USER_STORAGE_TYPE(SEC_LEVEL) ((SEC_LEVEL) + 1u)   /* Convert the Sec Level setting from
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    82                                                                         header/properties == internal to user config format */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    83  #define FEE_CNT_FIRST_COPY          0u       /* Internal counter value for first copy */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    84  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    85  /* Erase actions */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    86  #define FEE_NO_SECTOR_TO_ERASE      0xFFu    /* No sector has to be erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    87  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    88  /* Block header validation */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    89  #define FEE_BLK_HEADER_PREAMBEL             0xA53C96uL                                  /* Pattern of preambel */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    90  #define FEE_BLK_HEADER_PREAMBEL_BYTE_2      (FEE_BLK_HEADER_PREAMBEL & 0xFFu)           /* 0x96 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    91  #define FEE_BLK_HEADER_PREAMBEL_BYTE_1      ((FEE_BLK_HEADER_PREAMBEL >> 8u) & 0xFFu)   /* 0x3C */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    92  #define FEE_BLK_HEADER_PREAMBEL_BYTE_0      ((FEE_BLK_HEADER_PREAMBEL >> 16u) & 0xFFu)  /* 0xA5 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    93  #define FEE_BLK_HEADER_SIZE                 14u                                         /* Size of block header in bytes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    94  #define FEE_BKL_HEADER_REDUCTION            FEE_VIRTUAL_PAGE_SIZE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    95  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    96  /* Calculation of free byte in current sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    97  #define FEE_LL_SECTOR_USED_FOR_WRITING      Fee_RdWrOrder_st.xWrAddress
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    98  #define FEE_LL_SECTOR_USED_FOR_READING      Fee_RdWrOrder_st.xRdAddress
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	    99  #define FEE_LL_SECTOR_USED_FOR_COMPARING    Fee_RdWrOrder_st.xCmpAddress
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   100  #define FEE_LL_SECTOR_USED_FOR_CRC_CALC     Fee_RdWrOrder_st.xCrcAddress
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   101  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   102  /* Cache usage*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   103  #define FEE_INVLD_BLOCK_PROP_IDX        0xFFFFFFFFuL    /* Invalid Fee Idx that can be passed to the block header search function
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   104                                                             in order to ignore the cache during the init phase */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   105  #define FEE_USE_CACHED_ACCESS               0x01u       /* Use the cache method for finding the next block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   106  #define FEE_USE_MANUAL_ACCESS               0x00u       /* Search manually for headers */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   107  #define FEE_UPDATE_CACHE_IN_INIT            0x01u       /* Update the cache for fast access in init */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   108  #define FEE_NO_CACHE_UPDATE                 0x00u       /* Do not use the fast access method (only evaluated blocks are added to the cache) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   109  #define FEE_CACHE_UPD_NOT_COMP_FOR_SECT     0x00u       /* The respective sector was not completely checked */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   110  #define FEE_CACHE_UPD_COMP_FOR_SECT         0x01u       /* The respective sector was checked completely */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   111  #define FEE_CACHE_UPD_COMP_FOR_ALL_SECT     0x02u       /* All sectors have been checked completely */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   112  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   113  #define Fee_LLInvalidateAddressInCache(FEEIDX) Fee_LLUpdateAddressInCache(FEEIDX, FEE_CACHE_INIT_VALUE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   114  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   115  /* Fee init defines */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   116  #define FEE_PRV_ST_INIT_RUNNING             0x00u       /* Module is still uninitialized */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   117  #define FEE_PRV_ST_INIT_DONE                0x01u       /* Module has been initialized */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   118  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   119  /* Fee reorganization defines */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   120  #define FEE_PRV_ST_REORG_IDLE               0x00u       /* No reorganization is running */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   121  #define FEE_PRV_ST_REORG_STANDARD_RUNNING   0x01u       /* Standard reorganization is running */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   122  #define FEE_PRV_ST_REORG_AFTERB_RUNNING     0x02u       /* "Afterburner" of the reorganization is runnning */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   123  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   124  /* Amount of sectors used by the emulation  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   125  #define FEE_NUM_FLASH_BANKS         Fee_NumFlashBanksUsed_u8  /* Number of sectors which can be used by the Fee */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   126  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   127  #if (FEE_RB_ADDONS_CCAS == TRUE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   128  #define FEE_RB_REQUEST_STOP_MODE            TRUE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   129  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   130  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   131  #if(FEE_ROBUST_PROG_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   132  #define FEE_ROBMARKER_BUFF_SIZE             96u
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   133  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   134  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   135  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)     /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   136  #define FEE_FIRSTDATAPAGE_NOTPROGRAMMED 0x00u            /* First data pages in Fee_LlFls2FlsCopy is not yet programmed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   137  #define FEE_FIRSTDATAPAGE_PROGRAMMED     0x01u            /* First data pages in Fee_LlFls2FlsCopy is programmed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   138  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   139  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   140  /*
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   141  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   142  * Type definitions
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   143  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   144  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   145  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   146  /* Order priority */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   147  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   148  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   149      FEE_NORMAL_PRIO_E = 0,      /* e.g. if FeeImmediateData is configured to no */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   150      FEE_HIGH_PRIO_E   = 1       /* e.g. if FeeImmediateData is configured to yes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   151  }Fee_HlPriority_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   152  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   153  /* This enumerator list contains the index inside the order queue.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   154   * Attention: The order in the enumerator is from Low (FEE_ADAPTER_JOB) to High (FEE_INTERNAL_JOB).
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   155   *            Do not change this order!
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   156   * */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   157  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   158  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   159      FEE_INTERNAL_JOB,           /* Internal job (reorganization or sector erase) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   160      FEE_NVM_JOB,                /* Nvm job */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   161      FEE_ADAPTER_JOB,            /* Adapter job (e.g. Mx17 Eep) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   162      FEE_QUEUE_SIZE              /* Size of the Fee internal queue (each job type has 1 entry) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   163  }Fee_HlJobType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   164  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   165  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   166  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   167      uint8*  DataBufferPtr_pu8;  /* Pointer to the read- or write-buffer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   168      uint16  FeeIdx_u16;         /* FeeRbBlockPersistentId */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   169      uint16  BlockPropIdx_u16;   /* Respective block properties table index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   170      uint16  Offset_u16;         /* Offset inside block (could be != 0 only for read-orders --> R4.0 Rev1) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   171      uint16  Length_u16;         /* Block length, only required for element-read-jobs */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   172      Fee_HlMode_ten Mode_en;     /* Type of this order: Read, Write, Invalidate */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   173      Fee_HlPriority_ten Prio_en; /* Priority out of the configuration */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   174      uint8   SecLevel_u8;        /* Security level out of the configuration */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   175  }Fee_OrderFifo_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   176  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   177  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   178  /* Hint:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   179   * For calculation of the sector order (old -> new -> erased -> undef) the sector change counter is a valid criteria.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   180   * The lowest valid value points to the eldest data, the most current value to the most current data.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   181   * These following defines are used for an implicit sorting:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   182   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   183   *  +------+------+------+------+------+------+------+------+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   184   *  |MarkerPattern|Ident | marker content     |marker CRC16 |
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   185   *  +------+------+------+------+------+------+------+------+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   186   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   187   *  Sector headers: 12 times available as default
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   188   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   189   *      +------+------+------+------+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   190   *    0 |Erased| Used | Full |Erase |
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   191   *      +------+------+------+------+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   192   *    4 |      |      |      |      |
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   193   *      +------+------+------+------+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   194   *    8 |      |      |      |      |
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   195   *      +------+------+------+------+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   196   *      |<---->|
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   197   *        Page
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   198   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   199   * Erased:  Sector was erased successfully. This marker also contains the sector erase counter
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   200   * Used:    Sector contains user data. This marker will be written first before data is written into a sector.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   201   *          This marker also contains the sector change counter.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   202   * Full:    Sector is completely full and must not be considered for searching for the first empty page.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   203   *          This marker also contains the sector change counter.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   204   * Erase:   Sector contains no valid data anymore and can be erased in the background task.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   205   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   206   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   207  enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   208  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   209      FEE_ERASED_MARKER_ID_E = 0x01u, /* Sector was erased successfully */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   210      FEE_USED_MARKER_ID_E,           /* Sector was used to store data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   211      FEE_FULL_MARKER_ID_E,           /* Sector is full */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   212      FEE_ERASE_REQUEST_ID_E,         /* Sector should be erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   213      FEE_START_MARKER_ID_E,            /* Double storage of USED marker, contains address of first blockheader */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   214      FEE_CLONE_START_MARKER_ID_E,    /* Marker to indicate that cloning of a defect sector has startet in this sector --> Ifx robust programming */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   215      FEE_RESERVED_MARKER_ID1_E,      /* Reserved range marker space in the sector header, currently not used! */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   216      FEE_RESERVED_MARKER_ID2_E,      /*    "       "     "      "   "    "      "         "      "    "   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   217      FEE_RESERVED_MARKER_ID3_E,      /*    "       "     "      "   "    "      "         "      "    "   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   218      FEE_RESERVED_MARKER_ID4_E,      /*    "       "     "      "   "    "      "         "      "    "   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   219      FEE_RESERVED_MARKER_ID5_E,      /*    "       "     "      "   "    "      "         "      "    "   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   220      FEE_RESERVED_MARKER_ID6_E,      /*    "       "     "      "   "    "      "         "      "    "   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   221      FEE_NUM_MARKER_E                /* Amount of required markers in the sector header + 1 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   222  };
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   223  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   224  /* Sector marker structure */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   225  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   226  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   227      uint16  xPattern;               /* Static marker pattern: 0xCAFE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   228      uint8   xIdent;                 /* Ident to identify the marker: 0x01 Erased-Marker, 0x02 Used-Marker, 0x03 Full-Marker, 0x04 Erase-Request */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   229      uint8   xContent[3];            /* Sector change counter */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   230      uint16  xChecksum;              /* Crc16 checksum, calculation over Patter, Ident and content */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   231  }Fee_MarkerProp_t;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   232  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   233  /* Sector detection type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   234  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   235  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   236      uint32  SecChngCnt_u32;         /* Sector change counter */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   237      uint8   ctErasedMarker_u8;      /* Number of found ERASED markers */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   238      uint8   ctUsedMarker_u8;        /* Number of found USED markers */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   239      uint8   ctFullMarker_u8;        /* Number of found FULL markers */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   240      uint8   ctEraseReq_u8;          /* Number of found ERASE requests */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   241      uint32  xStartAddr_u32;         /* Address of first blockheader in the sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   242      uint8   ctCloneMarker_u8;       /* Cloning of data has started (only Ifx robust programming algorithm */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   243  }Fee_stSecDet_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   244  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   245  /* Sector states */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   246  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   247  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   248      FEE_SECTOR_STATE_UNDEF_E        = 0,                      /* undefined sector-state --> no marker found */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   249      FEE_SECTOR_ERASED_E             = FEE_ERASED_MARKER_ID_E, /* sector was erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   250      FEE_SECTOR_USED_E               = FEE_USED_MARKER_ID_E,   /* sector was used to write data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   251      FEE_SECTOR_FULL_E               = FEE_FULL_MARKER_ID_E,   /* sector is full */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   252      FEE_SECTOR_REQUEST2ERASE_E      = FEE_ERASE_REQUEST_ID_E, /* sector could be erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   253      FEE_SECTOR_CONSIDERED_E         = FEE_NUM_MARKER_E        /* sector was considered in function Fee_LLDetectActiveSector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   254  }Fee_SectorState_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   255  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   256  /* Sector order after sort sequence */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   257  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   258  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   259      uint32 SecChngCnt_u32;                  /* Sector change counter */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   260      Fee_SectorState_ten SecState_en;        /* Sector state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   261      uint8 xPhySecIdx_u8;                    /* Sector index (physical sector) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   262  }Fee_LLSectorOrder_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   263  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   264  /* Fee internal return types */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   265  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   266  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   267      FEE_ORDER_PENDING_E,            /* The order is still pending*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   268      FEE_ORDER_FINISHED_E,           /* The order was finished without error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   269      FEE_BLOCK_INVALIDATED_E,        /* The block was invalidated in the block status */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   270      FEE_ERROR_E,                    /* An error occured, maybe data in flash was not valid */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   271      FEE_SECTORCHANGE_E,             /* A sector change has to be done */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   272      FEE_SECTORFULL_E,               /* The sector is full */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   273      FEE_ABORTED_E,                  /* An order was aborted*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   274      FEE_ERASE_SECTOR_E,             /* The sector must be erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   275      FEE_SEARCH_ABORTED_E,           /* Searching was aborted */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   276      FEE_NUM_RET_VAL_E               /* Number of return values */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   277  }Fee_stRetVal_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   278  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   279  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   280  /* Flash properties */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   281  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   282  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   283      uint32  Fee_PhysStartAddress_u32;       /* Physical sector: start address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   284      uint32  Fee_PhysEndAddress_u32;         /* physical sector: end address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   285      uint32  Fee_LogStartAddress_u32;        /* logical sector: start address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   286      uint32  Fee_LogEndAddress_u32;          /* logical sector: end address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   287  }Fee_FlashProp_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   288  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   289  /* Block properties for all Fee blocks
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   290   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   291   * Status Flags:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   292   * Block flags will help to specify a more detailed block configuration. The low Byte of these block flags is also stored
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   293   * in the flash (status byte inside the block header). This information (in Flash) can be used to read/write the layout
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   294   * without configuration (PAV, CB).
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   295   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   296   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   297   *                                                 |<----- Block Status Byte in Block Header ----->|
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   298   * |<---------------------------------------- Block Flags ---------------------------------------->|
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   299   *    F     E     D     C     B     A     9     8  |  7     6     5     4     3     2     1     0  |
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   300   * +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   301   * |     |     |     |     |     |Prio-| Job type  |     |     | Rob |Surv.|(Inv)| DataFilter| Sec-|
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   302   * |     |     |     |     |     |rity |           |     |     |Attr.|Attr.|     |    Type   | lvl |
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   303   * +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   304   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   305   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   306   *  0  ... SecurityLevel      => 0...SingleStorage, 1...DoubleStorage
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   307   * 1+2 ... Data Filter Type   => 0...Dynamic:         Anybody can erase this block (e.g. during migration)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   308   *                               1...Static:          Only certain users (e.g. repair shops) can erase this block
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   309   *                               2...Permanent:       Only very certain users (e.g. OEM) can erase this block
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   310   *                               3...Super Permanent: Block can never be erased
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   311   *  3 .... Invalid            => 0...Block OK, 1...Block is invalid  --> can be changed by function Fee_InvalidateBlock
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   312   *  4 .... Survival Attribute => 0...No survival, 1... Survival (even without being part of the layout)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   313   *  5 .... Robustness Attribute (Robustness against data modification during write execution)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   314   *                            => 0...Deactivated:     No additional checksum is used
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   315   *                            => 1...Activated:       Additional checksum is used
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   316   * 8+9 ... TypeOfBlock        => 0...InternalJob, 1...NvmJob, 2...AdapterJob (e.g. Mx17 Eep adapter)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   317   *  A .... Priority           => Job priority:        0...FEE_NORMAL_PRIO_E --> FeeImmediateData = No
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   318   *                                                    1...FEE_HIGH_PRIO_E   --> FeeImmediateData = Yes
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   319   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   320  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   321  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   322      uint16 BlockPersistentId_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   323      uint16 Flags_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   324      uint16 Length_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   325      void (* const JobEndNotification_pfn) (void);      /* callback function, will be called if a job was successfully finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   326      void (* const JobErrorNotification_pfn) (void);    /* callback function, will be called if a job was finished with an error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   327  }Fee_BlockPropertiesType_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   328  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   329  /* Job types corresponding to the queue index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   330  enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   331  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   332      FEE_JOB_TYPE_INTERNAL_E = 0,            /* Internal job index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   333      FEE_JOB_TYPE_NVM_E      = 1,            /* NvM job index  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   334      FEE_JOB_TYPE_ADAPTER_E  = 2             /* Adapter job index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   335  };
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   336  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   337  /* State machine types for the function Fee_LLWriteMarker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   338  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   339  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   340      FEE_LL_MARKER_INIT_E,                   /* Init state                                    */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   341      FEE_LL_MARKER_BLK_CHK_E,                /* Perform a blank check over one page           */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   342      FEE_LL_MARKER_BLK_CHK_WAIT_E,           /* Wait for the blank check order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   343      FEE_LL_MARKER_BLK_CHK_ERROR_E,          /* Differences detected                          */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   344      FEE_LL_MARKER_BLK_CHK_FINISHED_E,       /* Start write order of the marker               */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   345      FEE_LL_MARKER_WRITE_WAIT_E,             /* Wait for the write order to be finished       */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   346      FEE_LL_MARKER_WRITE_ERROR_E,            /* Read or write error                           */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   347      FEE_LL_MARKER_VERIFY_E,                 /* Verify written marker                         */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   348      FEE_LL_MARKER_VERIFY_WAIT_E,            /* Wait for verify marker                        */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   349      FEE_LL_MARKER_VERIFY_FINISHED_E         /* Verify marker finished                        */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   350  }Fee_LLWrMarkerType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   351  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   352  /* State machine types for the function Fee_HLWriteBlock and Fee_HLReadBlock */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   353  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   354  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   355      FEE_HL_RDWR_BLK_INIT_E,                 /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   356      FEE_HL_SEARCH_BLK_HDR_E,                /* Search block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   357      FEE_HL_READ_BLK_HDR_WAIT_E,                  /* Read block header for redundant blocks */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   358      FEE_HL_CHECK_BLK_HDR_E,                 /* Check block header for redundant blocks */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   359      FEE_HL_CALC_BLK_CS_E,                   /* Calculate the user checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   360      FEE_HL_CHECK_BLK_CS_E,                  /* Verify the block checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   361      FEE_HL_RD_DATA_FROM_BLK_E,              /* Read the block data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   362      FEE_HL_COMP_BLK_E,                      /* Compare the complete block data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   363  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   364      /* Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   365      #if (defined(RBA_FLSIFX_FLASH) || defined(RBA_FLSJDP_FLASH))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   366      FEE_HL_RD_WAIT_FOR_FLS_E,               /* Wait for the Fls to overstamp an invalid header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   367      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   368      /* END Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   369  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   370      FEE_HL_WR_BLK_E                         /* Write the block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   371  }Fee_HLRdWrBlockType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   372  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   373  /* State machine types for the function Fee_LLWriteBlock */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   374  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   375  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   376      FEE_LL_WR_BLK_INIT_E,                   /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   377      FEE_LL_WR_WRITEHEADER_E,                /* Write the header (and first data bytes) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   378      FEE_LL_WR_SIZECHECK_HSR_E,              /* check for space until HSR */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   379      #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   380      FEE_LL_WR_BLANKCHECK_NOFB_WR_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   381      FEE_LL_WR_BLANKCHECK_NOFB_WR_WAIT_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   382      FEE_LL_WR_WRITE_NOFB_MARKER_E,          /* Write the NoFallback marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   383      FEE_LL_WR_WRITE_NOFB_MARKER_WAIT_E,     /* Wait until the programming of the NoFallback marker is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   384      FEE_LL_WR_FILL_SECTOR_END_E,            /* Changes the active sector and fills the empty pages if necessary */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   385      FEE_LL_WR_FILL_SECTOR_END_WAIT_E,       /* Wait until the write order to fill the empty pages is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   386      FEE_LL_WR_FILL_SECTOR_END_ERROR_E,      /* Errors during write occured */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   387      FEE_LL_WR_WRITE_NOFB_MARKER_ERROR_E,    /* Errors during write occured */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   388      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   389      FEE_LL_WR_WRITEHEADER_WAIT_E,           /* Wait until the write order is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   390      FEE_LL_WR_VERIFYHEADER_E,               /* Verify the header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   391      FEE_LL_WR_VERIFYHEADER_WAIT_E,          /* Wait for the verification to end */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   392      FEE_LL_WR_VERIFYHEADER_ERROR_E,         /* Verify error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   393      FEE_LL_WR_WRITEDATA_SEC_A_E,            /* Write the data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   394      FEE_LL_WR_WAIT_WRITEDATA_SEC_A_E,       /* Wait until the write order is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   395      FEE_LL_WR_WRITE_ERROR_E,                /* Error during write (header or data page writes) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   396  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   397      FEE_LL_WR_WRITE_FULL_MARKER_E,          /* Write the FULL marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   398      FEE_LL_WR_ERASE_SECTOR_E,               /* Erase a sector and write the ERASED marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   399      FEE_LL_WR_WRITE_USED_MARKER_E,          /* Write the USED marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   400      FEE_LL_WR_WRITE_START_MARKER_E,         /* Write the START marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   401  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   402      /* Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   403      #if (defined(RBA_FLSIFX_FLASH) || defined(RBA_FLSJDP_FLASH))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   404      FEE_LL_WR_WAIT_FOR_FLS_OVERPROGRAMMING_E,   /* Wait for the Fls to overstamp an invalid header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   405      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   406      /* END Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   407  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   408      #if(FEE_ROBUST_PROG_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   409      FEE_LL_WR_WRITEDATA_IFX_HANDLING_E,     /* robust Ifx handling in case of wordline fails */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   410      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   411      FEE_LL_WR_VERIFY_BLK_E                  /* Verify the complete data including the block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   412  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   413      /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   414      #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   415      ,FEE_LL_WR_WRITEHDRPG2_E,                /* Write the 2nd header page. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   416      FEE_LL_WR_WAIT_WRITEHDRPG2_E            /* Wait until 2nd header page write is completed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   417      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   418  }Fee_LLWrBlockType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   419  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   420  /* State machine types for the function Fee_LLCompBlkInFlash */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   421  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   422  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   423      FEE_LL_CMP_BLK_INIT_E,                  /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   424      FEE_LL_CMP_HEADER_E,                    /* Compare the complete block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   425      FEE_LL_CMP_WAIT_HEADER_E,               /* Wait for the compare to finish */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   426      FEE_LL_CMP_CHECK_OVERLAP_E,             /* Check for an overlap */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   427      FEE_LL_CMP_DATA_SEC_A_E,                /* Check the header compare result and compare the data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   428      FEE_LL_CMP_WAIT_DATA_SEC_A_E,           /* Wait for the compare to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   429      FEE_LL_CMP_FINISHED_E                   /* Verify the data compare result and reset the state machine */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   430  }Fee_LLCmpBlkType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   431  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   432  /* State machine types for the function Fee_LLCopyData2Buffer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   433  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   434  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   435      FEE_LL_CPY_BLK_INIT_E,                  /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   436      FEE_LL_CPY_BLOCK_START_E,               /* Read out the data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   437      FEE_LL_CPY_BLOCK_WAIT_E,                /* Wait for the read order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   438      FEE_LL_CPY_BLOCK_ERROR_E,               /* Error in the read function */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   439      FEE_LL_CPY_BLOCK_FINISHED_E             /* Finish the function or the data transfer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   440  }Fee_LLCpyBlkType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   441  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   442  /* State machine types for the function Fee_LLCalcBlkCrcInFlash */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   443  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   444  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   445      FEE_LL_CRC_BLK_INIT_E,                  /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   446      FEE_LL_CRC_RD_HD_PAGE_E,                /* Read the header page */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   447      FEE_LL_CRC_RD_PAGE_E,                   /* Calculate the block checksums */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   448      FEE_LL_CRC_CHECK_OVERLAP_E,             /* Check for an overlap */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   449      #if(FEE_ROB_FEATURE_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   450      FEE_LL_CRC_RD_ROB_PAGE_E,               /* Retry with the robustness checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   451      FEE_LL_CRC_CHECK_OVERLAP_ROB_E,         /* Check for an overlap */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   452      FEE_LL_CRC_RD_ROB_PAGE_WAIT_E,          /* Wait until the read access is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   453      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   454      FEE_LL_CRC_RD_PAGE_WAIT_E,              /* Wait until the read access is finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   455      FEE_LL_CRC_RD_ERROR_E                   /* Read error case */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   456  }Fee_LLCalcCrcBlkType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   457  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   458  /* State machine types for reading */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   459  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   460  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   461      FEE_LL_INIT_READ_E                      /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   462      ,FEE_LL_BLANK_CHECK_E                    /* Perform a blank check */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   463      ,FEE_LL_BLANK_CHECK_WAIT_E                /* Wait for the blank check to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   464      ,FEE_LL_READ_PAGE_E                     /* Read pages */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   465      ,FEE_LL_WAIT_READ_PAGE_E                /* Wait for the read order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   466      ,FEE_LL_READ_ERROR_E                    /* Error reaction for read error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   467      ,FEE_LL_READ_FINISHED_E                 /* Finish state machine */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   468      #if (FEE_HEADER_RECHECK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   469      #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   470      ,FEE_LL_NOFALLBACK_MARKER_CHECK_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   471      ,FEE_LL_NOFALLBACK_MARKER_CHECK_WAIT_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   472      ,FEE_LL_NOFALLBACK_MARKER_CHECK_FAILED_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   473      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   474      ,FEE_LL_RECHECK_HEADER_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   475      ,FEE_LL_RECHECK_HEADER_WAIT_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   476      ,FEE_LL_RECHECK_HEADER_FAILED_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   477      ,FEE_LL_RECHECK_HEADER_FINISHED_E
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   478      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   479  } Fee_LLRdStateType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   480  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   481  /* States for function Fee_LLCheckErasePattern */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   482  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   483  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   484      FEE_LL_INIT_BLANK_CHECK_E,              /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   485      FEE_LL_PERFORM_BLANK_CHECK_E,           /* Perform a blank check */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   486      FEE_LL_WAIT_PERFORM_BLANK_CHECK_E,      /* Wait for the blank check order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   487      FEE_LL_BLANK_CHECK_ERROR_E,             /* Differences detected */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   488      FEE_LL_BLANK_CHECK_FINISHED_E           /* Finish state machine with success */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   489  } Fee_LLBlankCheckType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   490  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   491  /* State of function Fee_Prv_LLFindEmptyPage */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   492  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   493  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   494      #if ( defined(RBA_FLSRH850P1xC_FLASH) || defined(RBA_FLSV850R1x_FLASH) || defined(RBA_FLSRH850xx_FLASH) )
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   495      FEE_LL_FINDEMPTYPGE_INIT_E,             /* Initalize find empty page state machine  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   496      FEE_LL_FINDEMPTYPGE_CHECK_E,            /* Begin a blank check                      */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   497      FEE_LL_FINDEMPTYPGE_WAIT_E,             /* Wait until the blank check finished      */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   498      FEE_LL_FINDEMPTYPGE_RESULT_BLANK_E,     /* Checked chunk was completely blank       */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   499      FEE_LL_FINDEMPTYPGE_RESULT_NOT_BLANK_E  /* Checked chunk was not completely blank   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   500      #else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   501      FEE_LL_FIND_CURRENT_SECTOR_E,           /* Evaluate the sector with most current values */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   502      FEE_LL_FIND_LAST_HEADER_E,              /* Search the last block header in the active sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   503      FEE_LL_FINISHED_E                       /* Function finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   504      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   505  }Fee_LLFndEmptyPgeType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   506  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   507  /* State of the function Fee_LLSearchSpecifiedBlkHeader */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   508  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   509  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   510      FEE_LL_SEARCHBLK_INIT_E,                /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   511      FEE_LL_SEARCHBLK_BLK_HEADER_E           /* Search for the next block header*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   512  }Fee_LLSearchBlkHdrType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   513  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   514  #if(FEE_FAST_CACHE_INIT_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   515  /* State of the function Fee_BuildUpCache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   516  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   517  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   518      FEE_LL_BLD_UP_CACHE_INIT_E,             /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   519      FEE_LL_BLD_UP_CACHE_READ_E              /* Read out data directly if possible */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   520  }Fee_LLBuildUpCache_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   521  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   522  /* State of the function Fee_BuildUpCacheForAllSect */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   523  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   524  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   525      FEE_LL_BLD_UP_CACHE_ALL_SECT_INIT_E,/* Init case */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   526      FEE_LL_BLD_UP_CACHE_ALL_SECT_DO_E   /* Build up the cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   527  }Fee_LLBuildUpCacheAllSect_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   528  /* FEE_FAST_CACHE_INIT_ACTIVE != FALSE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   529  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   530  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   531  #if((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   532  #if (FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE == 0)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   533  /* Unknown blcok sector reorganiation without cache: State of the function Fee_LLSearchUnknBlkHeader */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   534  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   535  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   536      FEE_LL_SEARCHUNKNBLK_INIT_E,            /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   537      FEE_LL_SEARCHUNKNBLK_UNKN_BLK_HEADER_E, /* Search the next unknown block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   538      FEE_LL_SEARCHUNKNBLK_SPEC_BLK_HEADER_E  /* Search the next specific block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   539  }Fee_LLSearchUnknBlkHdrType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   540  #else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   541  /* Unknown block sector reorganiation with cache: states of cache build up function Fee_BuildUpCacheUnknownBlk */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   542  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   543  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   544      FEE_LL_BLD_UP_CACHE_UNKOWN_BLK_INIT_E,             /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   545      FEE_LL_BLD_UP_CACHE_UNKOWN_BLK_READ_E,             /* Read out data directly if possible */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   546      FEE_LL_BLD_UP_CACHE_UNKOWN_BLK_VALIDATEDATA_E      /* Validate the data CRC of the uknown block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   547  }Fee_LLBuildUpUnknownBlkCache_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   548  #endif /* End of (FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE == 0) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   549  #endif /* End of ((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE)) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   550  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   551  /* States for the function Fee_LLSectorReorganization */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   552  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   553  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   554      FEE_LL_REORG_INIT_E,                    /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   555      FEE_LL_REORG_PREP_SEARCH_BLK_E,         /* Prepare the next block search */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   556      FEE_LL_REORG_SEARCH_BLK_E,              /* Search for a specific block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   557      FEE_LL_REORG_CHECK_BLOCK_CS_E,          /* Evaluate the block checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   558      FEE_LL_REORG_REDUNDANT_BLK_CHK_E,       /* Check if redundant copy is not lost during sector reorg. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   559      FEE_LL_REORG_WRITE_BLOCK_E,             /* Write a block into the latest sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   560  #if((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   561      FEE_LL_REORG_SEARCH_UNK_BLK_E,          /* Search for an unknown block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   562   #if(FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE != 0) /* Unknown blcok sector reorganiation with cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   563      FEE_LL_REORG_CACHEBUILDUP_UNK_BLK_E,    /* Building of cache for unknown block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   564      FEE_LL_REORG_SEARCH_UNK_HDRBLK_WAIT_E,            /* Wait till reading of unknown block header is finished. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   565      FEE_LL_REORG_SEARCH_UNK_HDRBLK_READ_ERROR_E,    /* Failure during read of unknown block header. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   566      FEE_LL_REORG_SEARCH_UNK_HDRBLK_READ_FINISHED_E,    /* Unknown block header read successful. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   567   #endif /* End of (FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE != 0) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   568  #endif /* End of ((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE)) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   569  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   570      /* Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   571      #if (defined(RBA_FLSIFX_FLASH) || defined(RBA_FLSJDP_FLASH))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   572      FEE_LL_REORG_WAIT_FOR_FLS_E,            /* Wait for the Fls to overstamp an invalid header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   573      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   574      /* END Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   575  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   576      FEE_LL_REORG_FINISHED_E                 /* Function finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   577  }Fee_LLSecReorgType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   578  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   579  /* States for the function Fee_LLRedundantCpyChk */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   580  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   581  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   582      FEE_LL_REDUNDANT_CPY_CHK_INIT_E,            /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   583      FEE_LL_REDUNDANT_CPY_CHK_SEARCH_HDR_E,      /* Search header of redundant copy */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   584      FEE_LL_REDUNDANT_CPY_CHK_BLK_CS_E           /* Validate data CRC of redundant copy */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   585  }Fee_LLRedundantCpyChk_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   586  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   587  /* States for the function Fee_LLCpyBlkFromFls2Fls */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   588  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   589  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   590      FEE_LL_CPY_FLS2FLS_INIT_E,                      /* Init state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   591  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   592      #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   593      FEE_LL_CPY_FLS2FLS_WRITE_NOFB_MARKER_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   594      FEE_LL_CPY_FLS2FLS_WAIT_WRITE_NOFB_MARKER_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   595      FEE_LL_CPY_FLS2FLS_WRITE_NOFB_MARKER_ERROR_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   596      FEE_LL_CPY_FLS2FLS_WAIT_FILL_SECTOR_END_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   597      FEE_LL_CPY_FLS2FLS_FILL_SECTOR_END_ERROR_E,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   598      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   599  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   600      FEE_LL_CPY_FLS2FLS_READ_E,                      /* Read out the complete block (header and data) and finish the function if possible */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   601      FEE_LL_CPY_FLS2FLS_WAIT_READ_E,                 /* Wait for the read order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   602      FEE_LL_CPY_FLS2FLS_READ_ERROR_E,                /* Read error state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   603  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   604      /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   605      #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   606      FEE_LL_CPY_FLS2FLS_HDRPG1_WRITE_E,              /* Write the header page 1 into the new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   607      FEE_LL_CPY_FLS2FLS_WAIT_HDRPG1_WRITE_E,         /* Wait for the header page 1 write order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   608      FEE_LL_CPY_FLS2FLS_HDRPG1_WRITE_ERROR_E,        /* Write error state for header page 1 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   609      FEE_LL_CPY_FLS2FLS_HDRPG1_VERIFY_E,             /* Compare the header page 1 write */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   610      FEE_LL_CPY_FLS2FLS_WAIT_HDRPG1_VERIFY_E,        /* Wait for the header page 1 verification to finish */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   611      FEE_LL_CPY_FLS2FLS_HDRPG1_VERIFY_ERROR_E,       /* Verification error for header page 1 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   612      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   613  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   614      FEE_LL_CPY_FLS2FLS_WRITE_E,                     /* Write the data into the new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   615      FEE_LL_CPY_FLS2FLS_WAIT_WRITE_E,                /* Wait for the write order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   616      FEE_LL_CPY_FLS2FLS_WRITE_ERROR_E,               /* Write error state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   617      FEE_LL_CPY_FLS2FLS_VERIFY_E,                    /* Compare the programmed data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   618      FEE_LL_CPY_FLS2FLS_WAIT_VERIFY_E,               /* Wait for the verification to finish */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   619      FEE_LL_CPY_FLS2FLS_VERIFY_ERROR_E,              /* Verification error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   620  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   621      /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   622      #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   623      FEE_LL_CPY_FLS2FLS_HDRPG2_WRITE_E,              /* Write the header page 2 into the new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   624      FEE_LL_CPY_FLS2FLS_WAIT_HDRPG2_WRITE_E,         /* Wait for the header page 2 write order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   625      FEE_LL_CPY_FLS2FLS_HDRPG2_WRITE_ERROR_E,        /* Write error state for header page 2 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   626      FEE_LL_CPY_FLS2FLS_HDRPG2_VERIFY_E,             /* Compare the header page 2 write */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   627      FEE_LL_CPY_FLS2FLS_WAIT_HDRPG2_VERIFY_E,        /* Wait for the header page 2 verification to finish */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   628      FEE_LL_CPY_FLS2FLS_HDRPG2_VERIFY_ERROR_E,       /* Verification error for header page 2 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   629      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   630  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   631      FEE_LL_CPY_FLS2FLS_CHECK_ADR_OVERFLOW_E,        /* Data transfer is finished, check a possible address overflow */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   632      FEE_LL_CPY_FLS2FLS_WRITE_FULL_MARKER_E,         /* Write the FULL marker to the "old" sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   633      FEE_LL_CPY_FLS2FLS_ERASE_SECTOR_E,              /* Erase the sector that will be used as a new USED sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   634      FEE_LL_CPY_FLS2FLS_WRITE_USED_MARKER_E,         /* Write the USED marker to new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   635  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   636      #if(FEE_ROBUST_PROG_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   637      FEE_LL_CPY_FLS2FLS_ROBUST_IFX_HANDLING_E,       /* robust Ifx handling in case of wordline fails */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   638      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   639  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   640      #if defined (FEE_PRV_ROBUST_SECT_OVERFLOW)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   641      FEE_LL_CPY_FLS2FLS_ROBUST_SECT_OVERFLOW_E,      /* Robust sector reorganisation when sector overflow occurs during sector reorg. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   642      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   643  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   644      FEE_LL_CPY_FLS2FLS_WRITE_START_MARKER_E         /* Write the START marker to the new sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   645  }Fee_LLCpyBlkFls2Fls_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   646  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   647  /* States for the function Fee_LlRobustSectorOverflow */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   648  #if defined (FEE_PRV_ROBUST_SECT_OVERFLOW)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   649  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   650  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   651      FEE_LL_ROBUST_SECTOR_OVERFLOW_INIT_E,           /* Init state. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   652      FEE_LL_ROBUST_SECTOR_OVERFLOW_WR_CM_E,          /* Write Clone marker in the latest sector. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   653      FEE_LL_ROBUST_SECTOR_OVERFLOW_PREPARE_E,        /* Compute the address and number of bytes for the operation. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   654  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   655      #if ( defined(RBA_FLSRH850P1xC_FLASH) || defined(RBA_FLSV850R1x_FLASH) || defined(RBA_FLSRH850xx_FLASH) )
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   656      FEE_LL_ROBUST_SECTOR_OVERFLOW_BLANK_CHK_E,      /* Check if the page is blank, transfer only programmed pages. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   657      FEE_LL_ROBUST_SECTOR_OVERFLOW_BLANK_CHK_WAIT_E, /* Wait for Blank check operation to complete. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   658      #endif /* #if ( defined(RBA_FLSRH850P1xC_FLASH) || defined(RBA_FLSV850R1x_FLASH) || defined(RBA_FLSRH850xx_FLASH) ) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   659  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   660      FEE_LL_ROBUST_SECTOR_OVERFLOW_READ_PAGE_E,      /* Read out the programmed page in an internal buffer. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   661      FEE_LL_ROBUST_SECTOR_OVERFLOW_READ_PAGE_WAIT_E, /* Wait for Read operation to complete. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   662      FEE_LL_ROBUST_SECTOR_OVERFLOW_COPY_DATA_E,      /* Copy data to new sector. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   663      FEE_LL_ROBUST_SECTOR_OVERFLOW_COPY_DATA_WAIT_E, /* Wait for Write operation to complete. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   664      FEE_LL_ROBUST_SECTOR_OVERFLOW_VERIFY_DATA_E,    /* Verify the copied data. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   665      FEE_LL_ROBUST_SECTOR_OVERFLOW_VERIFY_DATA_WAIT_E,/* Wait for Verify operation to complete. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   666      FEE_LL_ROBUST_SECTOR_OVERFLOW_VERIFY_SUCCESS_E, /* Check if more bytes are left to be programmed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   667      FEE_LL_ROBUST_SECTOR_OVERFLOW_WR_UM_E,          /* Write Used marker in the latest sector. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   668      FEE_LL_ROBUST_SECTOR_OVERFLOW_SORT_SECT_E,      /* Sort sectors */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   669      FEE_LL_ROBUST_SECTOR_OVERFLOW_ERROR_E,          /* Error state for all kinds of error in this state machine. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   670      FEE_LL_ROBUST_SECTOR_OVERFLOW_ERASE_E           /* Re-erase the older sector, this state is reached for error handling. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   671  }Fee_LLRobustSectOverflow_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   672  #endif /* #if defined (FEE_PRV_ROBUST_SECT_OVERFLOW) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   673  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   674  /* Read / write order type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   675  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   676  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   677      uint32                              xRdAddress;                     /* Address for reading (Fee_LLReadBlock) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   678      uint32                              xWrAddress;                     /* Address for writing (Fee_LLWriteBlock) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   679      uint32                              xCmpAddress;                    /* Address for comparing (Fee_LLCompBlkInFlash) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   680      uint32                              xCrcAddress;                    /* Address for the CRC (Fee_LLCompBlkInFlash) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   681      uint32                              xCpyAddress;                    /* Address for copying (Fee_LLCompBlkInFlash) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   682      uint32                              AdrHdSearchStart_u32;           /* Start address for the header search after reloads */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   683      uint32                              xStartAddrNextSector_u32;        /* Payload of START-Marker, contains the expected address of the 1. blockheader */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   684  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   685  /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   686  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   687      uint32                              xHdPg2Address;                   /* Address for writing the header 2nd page. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   688  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   689  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   690  #if !( defined(RBA_FLSRH850P1xC_FLASH) || defined(RBA_FLSV850R1x_FLASH) || defined(RBA_FLSRH850xx_FLASH) )
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   691      uint32                              LastProgrammedAddress_u32;        /* Last programmed page during cache build up. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   692      uint32                              LastValidHdrAddress_u32;          /* Last valid header found during cache build up. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   693  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   694  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   695      Fee_LLSecReorgType_ten              Fee_LLSecReorg_en;                /* State machine for the sector reorganization */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   696      Fee_LLRedundantCpyChk_ten           Fee_LLRedundantCpyChk_en;         /* State machine for checking redundant copy */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   697      Fee_LLCpyBlkFls2Fls_ten             Fee_LLCpyBlkFls2Fls_en;           /* State machine for copying one block from one sector to another one */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   698  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   699  #if defined (FEE_PRV_ROBUST_SECT_OVERFLOW)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   700      Fee_LLRobustSectOverflow_ten        Fee_LLRobustSectOverflow_en;      /* LL state machine for Robust sector overflow */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   701  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   702  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   703      Fee_HLRdWrBlockType_ten             Fee_HLWrBlock_en;                  /* HL state machine for writing a block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   704  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   705  #if(FEE_RB_MAINTAIN != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   706      Fee_HLRdWrBlockType_ten             Fee_HLMtBlock_en;                  /* HL state machine for maintaining a block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   707   #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   708  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   709      Fee_LLWrBlockType_ten               Fee_LLWrBlock_en;                  /* LL State machine for writing a block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   710      Fee_HLRdWrBlockType_ten             Fee_HLRdBlock;                     /* state machine for reading a block High Level */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   711      Fee_LLWrBlockType_ten               Fee_LLNextUsedWrBlock_en;          /* LL state for saving the next write state if a USED marker is necessary in between */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   712      Fee_LLWrBlockType_ten               Fee_LLNextEraseWrBlock_en;         /* LL state for saving the next write state if an erase operation is necessary in between */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   713      Fee_LLCmpBlkType_ten                Fee_LLCompBlk;                     /* LL state machine for comparing data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   714      Fee_LLCpyBlkType_ten                Fee_LLCopyBlk_en;                  /* LL state machine for copying data from the flash to the user buffer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   715      Fee_LLCalcCrcBlkType_ten            Fee_LLCalcCrcBlk_en;               /* LL state machine for calculating the checksum of a block inside the flash */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   716      Fee_LLWrMarkerType_ten              Fee_LLWrMarker_en;                 /* LL state machine for writing a sector marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   717      Fee_LLRdStateType_ten               Fee_LLRdState_en;                  /* LL state machine to read a specified address in the sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   718      Fee_LLBlankCheckType_ten            Fee_LLBlankCheckState_en;          /* LL State machine to perform a blank check */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   719      Fee_LLFndEmptyPgeType_ten           Fee_LLFindEmptyPageState_en;       /* LL state machine to find an empty page within one sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   720      Fee_LLSearchBlkHdrType_ten          Fee_LLSearchBlkHdr_en;             /* LL state machine to find a specified block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   721  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   722  #if((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   723   #if(FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE == 0) /* Unknown block sector reorganiation without cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   724      Fee_LLSearchUnknBlkHdrType_ten      Fee_LLSearchUnknBlkHdr_en;          /* LL state machine to find an unknown block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   725   #else /* Unknown blcok sector reorganiation with cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   726      uint32                              Fee_UnknownBlkCacheAdd_u32;         /* Address till where the cache for unknown block is scanned */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   727      uint16                              Fee_UnknownBlkCacheIdx_u16;         /* Index till which the cache for unknown block is built */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   728      Fee_LLBuildUpUnknownBlkCache_ten    Fee_LLBuildUpCacheUnknownBlk_en;    /* LL state machine to build up the cache for unknown blocks */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   729   #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   730  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   731  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   732  #if(FEE_FAST_CACHE_INIT_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   733      Fee_LLBuildUpCache_ten              Fee_LLBuildUpCache_en;              /* LL state machine to build up the cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   734      Fee_LLBuildUpCacheAllSect_ten       Fee_LLBuildUpCacheAllSect_en;       /* LL state machine to build up the cache for all sectors */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   735  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   736  } Fee_RdWrOrder_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   737  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   738  /* Block header info type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   739  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   740  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   741      uint32 AdrBlkHeader_u32;    /* Read address for for the function Fee_LLReadBlock and Fee_LLCpyBlkFromFls2Fls */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   742      uint32 BlkCrc32_u32;        /* Block data checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   743      uint16 HdrCrc16_u16;        /* Block header checksum (start value for block data checksum) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   744      uint16 BlkLength_u16;       /* Extracted block length from the block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   745      uint16 FeeIndex_u16;        /* Fee Index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   746      uint8  BlkStatus_u8;        /* Block status */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   747  }Fee_GlobInfoLastRdHeader_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   748  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   749  /* Block write type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   750  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   751  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   752      uint16  BytesAlrdyConsid_u16;   /* Write offset in user data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   753      uint16  BytesAlrdyCompared_u16;    /* Number of bytes already compared */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   754      uint16  Bytes2Read_u16;          /* Number of bytes to read */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   755      uint8   CompareResult_u8;       /* Result of last Fls_Compare */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   756      uint8   cntWriteRetry_u8;       /* Count number of write retries */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   757      uint8   cntCopies_u8;           /* Count number of written copies */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   758  }Fee_GlobInfoWrBlock_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   759  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   760  /* Sector reorganization type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   761  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   762  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   763      uint32 xRdAddress_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   764      uint16 xNumBytesAlrdyCopied_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   765      uint16 xNumBytesLeftToRdWr_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   766      uint8  xCntCopies_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   767  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)    /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   768      uint8  xFirstDataPgPgm_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   769  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   770  }Fee_LLSecReorgStruct_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   771  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   772  /* Erase sector types */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   773  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   774  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   775      FEE_ERASESEC_IDLE_E = 0,        /* Idle state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   776      FEE_ERASESEC_CHECK_CACHE_E,     /* Check of cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   777      FEE_ERASESEC_START_E,           /* Erase sequence started */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   778      FEE_ERASESEC_DO_E,              /* Wait until erasing was finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   779      FEE_ERASESEC_WRITE_MARKER_E,    /* Write the sector ERASED marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   780      FEE_ERASESEC_ERROR_E            /* Error state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   781  }Fee_LLEraseStateType_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   782  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   783  /* Erase Order type */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   784  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   785  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   786      Fee_LLEraseStateType_ten EraseState_en; /* State machine state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   787      uint8   xPhySectorIdx_u8;               /* Idx of sector that should get erased  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   788  }Fee_LLEraseOrderType_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   789  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   790  /* Block header structure */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   791  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   792  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   793      uint8   Preamble_au8[3];    /* Preambel (0xA53C96) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   794      uint8   BlkStatus_u8;       /* Block status, contains information like security level, etc. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   795      uint16  FeeIndex_u16;       /* FeeIndex */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   796      uint16  BlkLength_u16;      /* Block length without header and block checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   797      uint16  HdrCrc16_u16;       /* Header checksum, start value is 0xCAFE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   798      uint32  BlkCrc32_u32;       /* Block data checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   799  }Fee_BlkHeader_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   800  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   801  /* Linked function structure */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   802  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   803  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   804      void(* Fee_ResetUsedSectors_pfn)(void);     /* Function for resetting the amount of used sectors */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   805  }Fee_LinkedFunctions_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   806  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   807  #if (FEE_PRV_DEBUG_MONITOR != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   808  #define FEE_DBM_ERROR_ENTRIES   15
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   809  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   810  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   811  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   812      FEE_DBM_ERROR_ERASE_FCT_E,        /* Used in function Fee_LLEraseSector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   813      FEE_DBM_ERROR_LLMARKER_FCT_E,     /* USed in function Fee_LLWriteMarker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   814      FEE_DBM_ERROR_XX_E                /* not used yet....                   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   815  } Fee_DebugMonitoringFct_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   816  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   817  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   818  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   819      uint32                       xSecChngCntVal;             /* value of sector change counter while error occurs */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   820      uint16                       FeeBlkIdx;                  /* if the error couldn't be assigned to a NvmBlock, this is 0xFFFF */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   821      Fee_DebugMonitoringFct_ten   xError;                     /* error number */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   822      uint8                        xErrorInfo;                 /* error info, if necessary */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   823  } FeeDBMErrInfo_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   824  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   825  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   826  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   827      FeeDBMErrInfo_tst  xErrorEntry[FEE_DBM_ERROR_ENTRIES];  /* array of a structure with detail info to the errors */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   828      uint8   idxNewEntry;                /* index points on the next free entry in the xErrorEntry buffer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   829      uint8   ctBuffOverflow;             /* counter countrs how often the FEE_DBM_ERROR_ENTRIES error overflow. Startvalue is 1, used for ProtRAM validation! */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   830  } Fee_DebugMonitoring_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   831  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   832  #define FEE_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   833  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   834  extern Fee_DebugMonitoring_tst Fee_DebugMonitoring;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   835  #define FEE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   836  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   837  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   838  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   839  #if(FEE_ROBUST_PROG_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   840  /* Ifx robust programming */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   841  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   842  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   843      FEE_ROB_IFX_INIT,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   844      FEE_ROB_IFX_MARK_SECTOR,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   845      FEE_ROB_IFX_STORE_BUFFER,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   846      FEE_ROB_IFX_STORE_BUFFER_WAIT,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   847      FEE_ROB_IFX_COPY_DATA,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   848      FEE_ROB_IFX_STORE_COPY_WAIT,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   849      FEE_ROB_IFX_ERASE_SECTOR,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   850      FEE_ROB_IFX_WRITE_USED_MARK_SECTOR,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   851      FEE_ROB_SORT_SECTOR,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   852      FEE_ROB_IFX_FINISHED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   853  }Fee_RobIfxHdl_e;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   854  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   855  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   856  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   857      Fls_AddressType xStartAddress;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   858      uint8* DataBuffer;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   859      Fls_LengthType numBytes;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   860      uint16 offInBuf_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   861  }Fee_IfxRobustProgramming_t;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   862  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   863  #define FEE_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   864  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   865  extern Fee_IfxRobustProgramming_t Fee_IfxRobustProgramming_s;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   866  extern Fee_RobIfxHdl_e Fee_RobIfxHdl;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   867  #define FEE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   868  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   869  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   870  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   871  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   872  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_RobIfxHandling(uint8 xActLogWrSect_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   873  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   874  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   875  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   876  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   877  #if ((FEE_RB_MAINTAIN != FALSE) && (FEE_NO_FALLBACK_ACTIVE != FALSE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   878  /* Additional MainFunction write states in case NoFallback is activated */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   879  typedef enum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   880  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   881      FEE_WRITE_NOFB_IDLE_E = 0,      /* Idle state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   882      FEE_WRITE_NOFB_MAINTAIN_E,      /* Maintain a NoFallback block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   883      FEE_WRITE_NOFB_BLOCK_E          /* Write a NoFallback block */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   884  }Fee_WriteStateNoFb_ten;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   885  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   886  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   887  typedef struct
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   888  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   889      uint32 Fee_Totalfree_bytes;    /* Total number of free bytes  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   890      uint32 Fee_hardThreshold;      /* Hard Threshold configures */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   891      uint32 Fee_softThershold;      /* Soft therosold configured*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   892  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   893  }Fee_FreeByte_thrshold_t;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   894  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   895  /*
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   896  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   897  * Extern declarations
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   898  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   899  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   900  /* Structures and variables */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   901  #define FEE_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   902  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   903  extern CONST(Fee_FlashProp_tst, FEE_CONST)          Fee_FlashProp_st[FEE_NUM_FLASH_BANKS_AVAILABLE];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   904  extern CONST (MemIf_JobResultType, AUTOMATIC)       Fee_JobTypeMapping[FEE_NUM_RET_VAL_E];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   905  extern CONST (Fee_LinkedFunctions_tst, FEE_CONST)   Fee_LinkedFunctions_cst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   906  #define FEE_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   907  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   908  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   909  #define FEE_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   910  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   911  extern P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA)       Fee_PageBytePtr_cpu8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   912  extern VAR(Fee_RdWrOrder_tst, AUTOMATIC)            Fee_RdWrOrder_st;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   913  extern VAR(Fee_LLSectorOrder_tst, AUTOMATIC)        Fee_LLSectorOrder_st[FEE_NUM_FLASH_BANKS_AVAILABLE];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   914  extern VAR(Fee_LLEraseOrderType_tst, AUTOMATIC)     Fee_LLEraseOrder_st;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   915  extern VAR(Fee_OrderFifo_tst, AUTOMATIC)            Fee_OrderFifo_st[FEE_QUEUE_SIZE];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   916  extern VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC) Fee_GlobInfoLastRdHeader_st;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   917  extern VAR(Fee_GlobInfoWrBlock_tst, FEE_VAR)        Fee_GlobInfoWrBlock_st;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   918  extern VAR(Fee_LLSecReorgStruct_tst, FEE_VAR)       Fee_LLSecReorgStruct_st;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   919  extern VAR(MemIf_JobResultType, AUTOMATIC)          Fee_JobResult[FEE_QUEUE_SIZE];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   920  #define FEE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   921  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   922  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   923  #define FEE_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   924  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   925  extern CONSTP2VAR(uint8, AUTOMATIC, FEE_APPL_DATA)  Fee_MarkerBufBytePtr_cpu8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   926  extern CONSTP2VAR(uint8, AUTOMATIC, FEE_APPL_DATA)  Fee_DataBytePtr_cpu8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   927  #define FEE_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   928  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   929  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   930  #define FEE_START_SEC_VAR_INIT_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   931  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   932  extern VAR(uint8, FEE_VAR)                          Fee_Prv_stInit_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   933  extern VAR(uint8, FEE_VAR)                          Fee_Prv_stReorg_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   934  extern VAR(uint8, FEE_VAR)                          Fee_NumFlashBanksUsed_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   935  extern VAR(uint8, AUTOMATIC)                        Fee_idxActQueueBackUp;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   936  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   937  /* Buffer to hold 2nd header page contents. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   938  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)    /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   939  extern VAR(uint8, AUTOMATIC) Fee_hdr2Buffer_au8[FEE_PAGE_LEN];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   940  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   941  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   942  /* Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   943  #if (defined(RBA_FLSIFX_FLASH) || defined(RBA_FLSJDP_FLASH))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   944  extern VAR(uint8, AUTOMATIC)                        Fee_hdrBuffer_au8[FEE_PAGE_LEN];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   945  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   946  /* END Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   947  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   948  #define FEE_STOP_SEC_VAR_INIT_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   949  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   950  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   951  #define FEE_START_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   952  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   953  extern VAR(MemIf_StatusType, FEE_VAR)               Fee_GlobModuleState_st;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   954  extern VAR(Fee_Rb_WorkingStateType_ten, AUTOMATIC)  Fee_Rb_WorkingStateBackUp_en;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   955  #define FEE_STOP_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   956  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   957  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   958  #define FEE_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   959  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   960  extern VAR(uint8, AUTOMATIC)                        Fee_idxLLSectorOrder_au8[FEE_NUM_FLASH_BANKS_AVAILABLE];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   961  extern VAR(uint8, FEE_VAR)                          Fee_idxActQueue_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   962  extern VAR(uint8, FEE_CONST)                        Fee_CacheUpdCompForSect_au8[FEE_NUM_FLASH_BANKS_AVAILABLE];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   963  extern VAR(uint8, AUTOMATIC)                        Fee_RdWrRetries_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   964  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   965  #if (FEE_RB_ACT_ERASE_SUSPENSION != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   966  extern VAR(boolean, AUTOMATIC) Fee_Prv_stSuspendActiv_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   967  extern VAR(boolean, AUTOMATIC) Fee_Prv_stHardReOrgErase_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   968  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   969  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   970  #if (FEE_RB_ADDONS_CCAS == TRUE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   971  extern VAR(boolean, AUTOMATIC) Fee_Rb_stRequestStopMode_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   972  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   973  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   974  #define FEE_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   975  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   976  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   977  #define FEE_START_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   978  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   979  extern VAR(uint32, AUTOMATIC)                       Fee_llMarkerPageBuf_au32[FEE_SEC_HEADER_SIZE / 4u];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   980  extern VAR(uint32, FEE_CONST)                       Fee_Cache_au32[FEE_NUM_BLOCKS];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   981  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   982  #if(FEE_ROB_FEATURE_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   983  extern VAR(uint32, AUTOMATIC)                       Fee_DataByteStartCrc_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   984  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   985  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   986  #define FEE_STOP_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   987  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   988  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   989  #define FEE_START_SEC_VAR_CLEARED_SECURED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   990  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   991  extern VAR(uint32, AUTOMATIC)                       Fee_llPageBuf_au32[(FEE_LL_PAGEBUFFSIZE / 4u) + 2u];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   992  extern VAR(uint32, AUTOMATIC)                       Fee_llDataBuf_au32[FEE_LL_DATABUFFSIZE / 4u];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   993  #define FEE_STOP_SEC_VAR_CLEARED_SECURED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   994  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   995  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   996  #ifdef FEE_PRV_USE_ROM_TABLE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   997  #define FEE_START_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   998  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	   999  extern CONST(Fee_BlockPropertiesType_tst, FEE_CONST)  Fee_BlockProperties_st[FEE_NUM_BLOCKS];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1000  #define FEE_STOP_SEC_CONST_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1001  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1002  #else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1003  #define FEE_START_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1004  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1005  extern VAR(Fee_BlockPropertiesType_tst, AUTOMATIC)  Fee_BlockProperties_st[FEE_NUM_BLOCKS];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1006  #define FEE_STOP_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1007  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1008  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1009  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1010  #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1011  #define FEE_START_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1012  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1013  extern Fee_WriteStateNoFb_ten Fee_WriteStateNoFb_en;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1014  #define FEE_STOP_SEC_VAR_INIT_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1015  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1016  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1017  #define FEE_START_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1018  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1019  extern VAR(uint32, AUTOMATIC)   Fee_Rb_NoFallback_RemAdr_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1020  #define FEE_STOP_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1021  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1022  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1023  #define FEE_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1024  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1025  extern VAR(boolean, AUTOMATIC)  Fee_Rb_NoFallback_LastBlockCfg_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1026  extern VAR(boolean, AUTOMATIC)  Fee_Rb_InvalidateOldCopy_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1027  extern VAR(boolean, AUTOMATIC)  Fee_Rb_MaintainRun_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1028  #define FEE_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1029  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1030  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1031  #define FEE_START_SEC_CONST_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1032  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1033  extern const uint8 Fee_NoFallbackMarkerPattern[FEE_PAGES_USED_BY_BLK_HEADER * FEE_PAGE_LEN];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1034  #define FEE_STOP_SEC_CONST_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1035  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1036  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1037  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1038  #if((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) && (FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE != 0))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1039  /* Unknown blcok sector reorganiation with cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1040  #define FEE_START_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1041  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1042  extern VAR(uint32, AUTOMATIC) Fee_UnknownBlkCache_Addr_au32[FEE_RB_ACT_UNKNOWN_BLK_CACHE_ARRAY_SIZE];   /* Address of unknown block. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1043  #define FEE_STOP_SEC_VAR_CLEARED_32
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1044  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1045  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1046  #define FEE_START_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1047  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1048  extern VAR(uint16, AUTOMATIC) Fee_UnknownBlkCache_FeeIndex_u16[FEE_RB_ACT_UNKNOWN_BLK_CACHE_ARRAY_SIZE]; /* Index of unknown block. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1049  #define FEE_STOP_SEC_VAR_CLEARED_16
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1050  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1051  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1052  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1053  /* Lower Layer functions of the Fee */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1054  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1055  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1056  extern FUNC(uint32, FEE_CODE) Fee_CalculateNumOfFreeBytesInCurSector(VAR(uint32, FEE_VAR) DataEndAdr_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1057  extern FUNC(void, FEE_CODE)   Fee_InitVarAndState(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1058  extern FUNC(void, FEE_CODE)   Fee_InitCache(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1059  extern FUNC(void, FEE_CODE)   Fee_InitOrderFifoBuffer(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1060  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1061  /* Active sector detection */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1062  extern FUNC(void ,FEE_CODE)   Fee_LLSearchSectors(P2VAR(Fee_stSecDet_tst, AUTOMATIC, FEE_APPL_DATA) Fee_stSecDet_ps);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1063  extern FUNC(uint8, FEE_CODE)  Fee_LLDetectActiveSector(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1064  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLFindEmptyPage(uint8 PhySectIdxUsedSect_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1065  extern FUNC(uint8, FEE_CODE)  Fee_GetMostCurrentSectorIdx(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1066  extern FUNC(void, FEE_CODE)   Fee_CheckErasedSectorEmpty(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1067  extern FUNC(uint8, FEE_CODE)  Fee_GetPhysSectorByAddress(VAR(uint32, AUTOMATIC) Address_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1068  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1069  /* Marker handling */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1070  extern FUNC(Fee_stRetVal_ten,FEE_CODE)  Fee_LLWriteMarker(VAR(uint8, AUTOMATIC) PhySectIdx_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1071                                                            VAR(uint8, AUTOMATIC) MarkerID_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1072  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1073  /* Erase functions */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1074  extern FUNC(Fee_stRetVal_ten,FEE_CODE)  Fee_LLEraseSector(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1075  extern FUNC(void,FEE_CODE)              Fee_LLSetEraseSector(VAR(uint8, AUTOMATIC) EraseLogIdx);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1076  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1077  /* Block header access */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1078  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLSearchNextBlkHeader(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Fee_GlobInfoLastRdHeader_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1079                                                                    VAR(uint8, AUTOMATIC) CachedAccess_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1080                                                                    VAR(uint8, AUTOMATIC) FastCacheUpdate_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1081                                                                    VAR(boolean, AUTOMATIC) xForcePageBufReload_b,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1082                                                                    VAR(uint32, AUTOMATIC) strAddrHdrSearch);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1083  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1084  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLSearchSpecifiedBlkHeader(VAR(uint16, AUTOMATIC) FeeIdx_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1085                                                                         P2VAR(uint32, AUTOMATIC, FEE_APPL_DATA) LastHdrAddr_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1086                                                                         P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) GlobBlkHdr_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1087                                                                         VAR(boolean, AUTOMATIC) SearchRetry_b);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1088  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1089  #if((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1090  /* Unknown blcok sector reorganiation without cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1091  #if(FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE == 0)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1092  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLSearchUnknownBlkHeader(P2VAR(uint32, AUTOMATIC, FEE_APPL_DATA) StartHdrAddr_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1093                                                                       P2VAR(uint32, AUTOMATIC, FEE_APPL_DATA) LastHdrAddr_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1094                                                                       P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) GlobBlkHdr_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1095                                                                       P2VAR(boolean, AUTOMATIC, FEE_APPL_DATA) SearchRetry_ptr);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1096  #else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1097  /* Unknown blcok sector reorganiation with cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1098  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_BuildUpCacheUnknownBlk(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1099  #endif /* (FEE_RB_ACT_UNKNOWN_BLOCK_CACHE_SIZE == 0) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1100  #endif /* ((FEE_RB_ACT_UNKNOWN_BLOCK_REORG != FALSE) || (FEE_RB_ACT_SURVIVAL_EVAL != FALSE)) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1101  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1102  extern FUNC(uint32, FEE_CODE) Fee_LLGetSecStartAddress(VAR(uint8, AUTOMATIC) xPhySectorIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1103  extern FUNC(uint32, FEE_CODE) Fee_LLGetSecEndAddress(VAR(uint8, AUTOMATIC) xPhySectorIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1104  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1105  /* Verification and handling of blocks */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1106  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLCompBlkInFlash(P2CONST(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) HeaderInfo_pcst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1107                                                               P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) Data_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1108  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLCalcBlkCrcInFlash(P2CONST(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) HeaderInfo_pcst);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1109  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLCpyBlkFromFls2Fls(P2CONST(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Fee_GlobInfoLastRdHeader_pcst, boolean Fee_WriteTwice_b);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1110  #if defined (FEE_PRV_ROBUST_SECT_OVERFLOW)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1111  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LlRobustSectorOverflow(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1112  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1113  extern FUNC(void, FEE_CODE)             Fee_LLPrepMarkerBufWithMarkerData(P2CONST(Fee_MarkerProp_t, AUTOMATIC, FEE_APPL_DATA) Marker_pcst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1114                                                                            P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) MarkerBuf_pu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1115  extern FUNC(void, FEE_CODE)             Fee_LLCopyPageBuff2Marker(P2VAR(Fee_MarkerProp_t, AUTOMATIC, FEE_APPL_DATA) Marker_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1116                                                                    P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1117  extern FUNC(void, FEE_CODE)             Fee_LLPrepPageBufWithHdrDataStart(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) HeaderInfo_pst);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1118  extern FUNC(void, FEE_CODE)             Fee_LLPrepPageBufWithHdrDataEnd(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) HeaderInfo_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1119                                                                                 P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) Data_pcu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1120                                                                                 VAR(uint32, AUTOMATIC) BlkCrc32_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1121  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1122  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1123  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1124  LOCAL_INLINE FUNC(void, FEE_CODE)       Fee_LLCopyPageBuff2HeaderStart(P2VAR(Fee_BlkHeader_tst, AUTOMATIC, FEE_APPL_DATA) BlkHdr_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1125                                                                         P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1126  #if(FEE_FAST_CACHE_INIT_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1127  LOCAL_INLINE FUNC(void, FEE_CODE)       Fee_LLCopyPageBuff2HeaderIdxAndCrc(P2VAR(Fee_BlkHeader_tst, AUTOMATIC, FEE_APPL_DATA) BlkHdr_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1128                                                                             P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1129  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1130  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1131  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1132  #if !( defined(RBA_FLSRH850P1xC_FLASH) || defined(RBA_FLSV850R1x_FLASH) || defined(RBA_FLSRH850xx_FLASH) )
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1133  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_SearchLastBlkHeader(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Fee_GlobInfoLastRdHeader_ptr);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1134  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1135  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1136  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1137  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1138  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1139  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1140  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1141  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1142  extern FUNC(uint32, FEE_CODE)           Fee_SearchHighestCacheEntry(VAR(uint32,FEE_VAR) UpperBoundary_u32, VAR(uint8, FEE_VAR) SectIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1143  extern FUNC(void, FEE_CODE)             Fee_InvalidateCacheByAddress(VAR(uint32,FEE_VAR) xAddress_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1144  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1145  extern FUNC(void, FEE_CODE)             Fee_LLCopyPageBuff2HeaderMid(P2VAR(Fee_BlkHeader_tst, AUTOMATIC, FEE_APPL_DATA) BlkHdr_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1146                                                                       P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1147  extern FUNC(void, FEE_CODE)             Fee_LLCopyPageBuff2HeaderEnd(P2VAR(Fee_BlkHeader_tst, AUTOMATIC, FEE_APPL_DATA) BlkHdr_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1148                                                                       P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1149  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLCopyData2Buffer(P2CONST(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Fee_GlobInfoLastRdHeader_pcst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1150                                                                    P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) DataPtr_pu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1151                                                                    VAR(uint16, FEE_VAR) DataOffset_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1152                                                                    VAR(uint16, FEE_VAR) DataLength_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1153  extern FUNC(void, FEE_CODE)             Fee_IncAddressInsideSector(P2VAR(uint32, AUTOMATIC, FEE_APPL_DATA) Address_u32,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1154                                                                     VAR(uint16, FEE_VAR) numBytes_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1155                                                                     VAR(boolean, FEE_VAR) EnsurePageAlign_b);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1156  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1157  /* Sector reorganization */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1158  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLCheckReorganizationNeed(VAR(uint32, AUTOMATIC) Threshold_u32,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1159                                                                        VAR(uint16, AUTOMATIC) DataLength_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1160  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLSectorReorganization(P2VAR(boolean, AUTOMATIC, FEE_APPL_DATA) SectReorgInterSt_pb);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1161  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1162  /* Block writes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1163  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_HLWriteBlock(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1164  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLWriteBlock(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Info_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1165                                                           P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) Data_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1166  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1167  /* Block reading */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1168  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_HLReadBlock(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1169  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_LLReadBlock(P2VAR(Fee_GlobInfoLastRdHeader_tst, AUTOMATIC, FEE_APPL_DATA) Info_ptr,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1170                                                          P2VAR(uint8,AUTOMATIC, FEE_APPL_DATA) Data_ptr);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1171   #if(FEE_RB_MAINTAIN != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1172      /* Block maintaining*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1173      extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_HLMaintainBlock(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1174   #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1175  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1176  /* Order handling */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1177  extern FUNC(Std_ReturnType, FEE_CODE)   Fee_HLPlaceOrder(VAR(uint16, AUTOMATIC) Blocknumber_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1178                                                           VAR(uint16, AUTOMATIC) Offset_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1179                                                           P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) DataBufferPtr_pu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1180                                                           VAR(uint16, AUTOMATIC) Length_16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1181                                                           VAR(Fee_HlMode_ten, AUTOMATIC) Mode_en);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1182  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1183  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1184  /* Cache handling */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1185  extern FUNC(uint32, FEE_CODE) Fee_LLGetAddressFromCache(VAR(uint16, AUTOMATIC) FeeIdx_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1186  extern FUNC(boolean, FEE_CODE) Fee_LLCheckAddressInCache(VAR(uint32, AUTOMATIC) AdrInSector_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1187  extern FUNC(void, FEE_CODE)   Fee_LLUpdateAddressInCache(VAR(uint16, AUTOMATIC) FeeIdx_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1188                                                           VAR(uint32, AUTOMATIC) Addr_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1189  extern FUNC(void, FEE_CODE)  Fee_LLUpdateCacheStForSect(VAR(uint8, AUTOMATIC) PhySecIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1190  extern FUNC(void, FEE_CODE)  Fee_LLEraseCacheStForSect(VAR(uint8, AUTOMATIC) PhySecIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1191  extern FUNC(uint8, FEE_CODE) Fee_LLGetCacheUpdateStForSect(VAR(uint8, AUTOMATIC) PhySecIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1192  extern FUNC(uint8, FEE_CODE) Fee_LLGetCacheUpdateStForAllSect(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1193  extern FUNC(boolean, FEE_CODE) Fee_SrvBinarySearchInBlockProp(VAR(uint16, AUTOMATIC) FeeIdx_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1194                                                                P2VAR(uint16, AUTOMATIC, FEE_APPL_DATA) CacheIdx_pu16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1195  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1196  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1197  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1198  #if(FEE_FAST_CACHE_INIT_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1199  LOCAL_INLINE FUNC(boolean, FEE_CODE) Fee_SrvBinarySearchInBlockPropFast(VAR(uint16, AUTOMATIC) FeeIdx_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1200                                                                          P2VAR(uint16, AUTOMATIC, FEE_APPL_DATA) CacheIdx_pu16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1201  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1202  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1203  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1204  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_BuildUpCache(VAR(uint32, AUTOMATIC) StartAdr_u32,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1205                                                           VAR(uint32, AUTOMATIC) EndAdr_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1206  extern FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_BuildUpCacheForAllSect(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1207  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1208  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1209  /* FEE_FAST_CACHE_INIT_ACTIVE != FALSE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1210  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1211  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1212  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1213  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1214  /* Services */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1215  extern FUNC(void, FEE_CODE)  Fee_SrvMemSet8(P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) xDest_pu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1216                                              VAR(uint32, FEE_VAR) xPattern_u32,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1217                                              VAR(uint32, FEE_VAR) numBytes_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1218  extern FUNC(void, FEE_CODE)  Fee_SrvMemCopy8(P2VAR(uint8, AUTOMATIC, FEE_APPL_DATA) xDest_pu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1219                                               P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) xSrc_pcu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1220                                               VAR(uint32, FEE_VAR) numBytes_u32);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1221  extern FUNC(void, FEE_CODE)  Fee_SrvSetFifoMode(VAR(Fee_HlMode_ten, AUTOMATIC) Mode_en,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1222                                                  VAR(uint16, AUTOMATIC) xJobType_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1223  extern FUNC(Fee_HlMode_ten, FEE_CODE) Fee_SrvGetFifoMode(VAR(uint16, AUTOMATIC) xJobType_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1224  extern FUNC(void, FEE_CODE)           Fee_LoadNextOrder(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1225  extern FUNC(uint8, FEE_CODE)          Fee_SearchNextOrder(boolean isIntOrder_b);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1226  extern FUNC(void, FEE_CODE)           Fee_UpdateStatus(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1227  extern FUNC(void, FEE_CODE)           Fee_TriggerHardSectorReorg(VAR(Fee_Rb_WorkingStateType_ten, FEE_VAR) WorkingState_en);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1228  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1229  extern FUNC(Std_ReturnType, FEE_CODE) Fee_CheckBlockCfg(VAR(uint8, AUTOMATIC)  ApiId_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1230                                                             VAR(uint16, AUTOMATIC) BlockNum_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1231  extern FUNC(Std_ReturnType, FEE_CODE) Fee_CheckModuleSt(VAR(uint8, AUTOMATIC)  ApiId_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1232  extern FUNC(Std_ReturnType, FEE_CODE) Fee_CheckAdrPtr(VAR(uint8, AUTOMATIC) ApiId_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1233                                                        P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) DataBufferPtr_pcu8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1234  extern FUNC(Std_ReturnType, FEE_CODE) Fee_CheckBlkOfs(VAR(uint8, AUTOMATIC) ApiId_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1235                                                        VAR(uint16, AUTOMATIC) BlockNum_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1236                                                        VAR(uint16, AUTOMATIC) BlockOfs_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1237  extern FUNC(Std_ReturnType, FEE_CODE) Fee_CheckBlkLen(VAR(uint8, AUTOMATIC) ApiId_u8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1238                                                        VAR(uint16, AUTOMATIC) BlockNum_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1239                                                        VAR(uint16, AUTOMATIC) BlockOfs_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1240                                                        VAR(uint16, AUTOMATIC) BlockLen_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1241  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1242  /* Miscellaneous */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1243  extern FUNC(void, FEE_CODE)   Fee_CheckFlsJobResult(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1244  extern void (* Fee_Prv_ResetUsedSectors_pfn)(void);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1245  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1246  #if (FEE_PRV_DEBUG_MONITOR != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1247  extern FUNC(void ,FEE_CODE) Fee_DBM_RepError(VAR(uint16,FEE_VAR) FeeBlkIdx, VAR(Fee_DebugMonitoringFct_ten,FEE_VAR) xError, VAR(uint8,FEE_VAR) xErrorInfo);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1248  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1249  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1250  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1251  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1252  /*
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1253  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1254  * Inline functions (Necessary for fastening up the start up time)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1255  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1256  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1257  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1258   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1259   * Fee_LLCopyPageBuff2HeaderStart(): Extract the start of the block header data
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1260   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1261   * This function extracts the preamble of the block header data out
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1262   * of the page buffer (called every 8th byte of the flash).
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1263   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1264   * Hint: Block header structure:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1265   *       {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1266   *          uint8   Preamble_au8[3];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1267   *          uint8   BlkStatus_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1268   *          uint16  FeeIndex_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1269   *          uint16  BlkLength_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1270   *          uint16  HdrCrc16_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1271   *          uint32  BlkCrc32_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1272   *       }Fee_BlkHeader_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1273   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1274   * \param    BlkHdr_pst:    Pointer to the block header that was
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1275   *                          found in the flash.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1276   * \param    PageBuf_pu8:   Pointer to the page buffer
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1277   * \return
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1278   * \retval   none
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1279   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1280   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1281   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1282   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1283  LOCAL_INLINE FUNC(void, FEE_CODE) Fee_LLCopyPageBuff2HeaderStart(P2VAR(Fee_BlkHeader_tst, AUTOMATIC, FEE_APPL_DATA) BlkHdr_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1284                                                                   P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1285  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1286      BlkHdr_pst->Preamble_au8[0] = PageBuf_pcu8[0];      /* 0xA53C96 <- [0]: A5, [1]: 3C, [2]: 96 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1287      BlkHdr_pst->Preamble_au8[1] = PageBuf_pcu8[1];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1288      BlkHdr_pst->Preamble_au8[2] = PageBuf_pcu8[2];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1289  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1290  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1291  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1292  #if(FEE_FAST_CACHE_INIT_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1293  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1294   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1295   * Fee_LLCopyPageBuff2HeaderIdxAndCrc(): Extract the header checksum
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1296   *  and the block index out of the block header data
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1297   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1298   * This function extracts the block header data out of the page buffer.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1299   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1300   * Hint: Block header structure:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1301   *       {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1302   *          uint8   Preamble_au8[3];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1303   *          uint8   BlkStatus_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1304   *          uint16  FeeIndex_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1305   *          uint16  BlkLength_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1306   *          uint16  HdrCrc16_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1307   *          uint32  BlkCrc32_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1308   *       }Fee_BlkHeader_tst;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1309   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1310   * \param    BlkHdr_pst:    Pointer to the block header that was
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1311   *                          found in the flash.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1312   * \param    PageBuf_pcu8:  Pointer to the page buffer
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1313   * \return
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1314   * \retval   none
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1315   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1316   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1317   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1318   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1319  LOCAL_INLINE FUNC(void, FEE_CODE) Fee_LLCopyPageBuff2HeaderIdxAndCrc(P2VAR(Fee_BlkHeader_tst, AUTOMATIC, FEE_APPL_DATA) BlkHdr_pst,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1320                                                                       P2CONST(uint8, AUTOMATIC, FEE_APPL_DATA) PageBuf_pcu8)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1321  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1322      /* 0xD2E9 <- [4]: D2, [5]: E9 */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1323      BlkHdr_pst->FeeIndex_u16    = (uint16)((uint16)(((uint16)(PageBuf_pcu8[4])) << 8u)  | (uint16)(PageBuf_pcu8[5]));
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1324  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1325      /* 0xABCD <- [8]: AB, [9]: CD */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1326      BlkHdr_pst->HdrCrc16_u16    = (uint16)((uint16)(((uint16)(PageBuf_pcu8[8])) << 8u)  | (uint16)(PageBuf_pcu8[9]));
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1327  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1328  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1329  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1330  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1331   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1332   * Fee_SrvBinarySearchInBlockProp(): Get the respective index out of
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1333   *                                   the block properties table
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1334   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1335   * This function searches for the respective block properties table
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1336   * index. In case unknown blocks are searched, the function will
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1337   * return with a negative response.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1338   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1339   * \param    FeeIdx_u16:    Fee index (persistent ID)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1340   * \param    CacheIdx_pu16: Pointer for the result
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1341   * \return   Success of the function
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1342   * \retval   FALSE: Corresponding index was not found
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1343   * \retval   TRUE:  Corresponding index was found
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1344   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1345   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1346   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1347   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1348   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1349  LOCAL_INLINE FUNC(boolean, FEE_CODE) Fee_SrvBinarySearchInBlockPropFast(VAR(uint16, AUTOMATIC) FeeIdx_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1350                                                                          P2VAR(uint16, AUTOMATIC, FEE_APPL_DATA) CacheIdx_pu16)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1351  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1352      VAR(boolean, AUTOMATIC)  xFuncRet_b = FALSE;    /* Function return value */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1353      VAR(uint16, AUTOMATIC)  xMid_u16;               /* Mid index for the search */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1354      VAR(uint16, AUTOMATIC)  xLeft_u16 = 0;          /* Left index for the search */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1355      VAR(uint16, AUTOMATIC)  xRight_u16 = FEE_NUM_BLOCKS - 1u; /* Right index for the search */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1356  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1357      /* Loop until the value is found */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1358      do
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1359      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1360          /* Divide search area by two */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1361          xMid_u16 = (uint16)(xLeft_u16 + ((xRight_u16 - xLeft_u16) / 2));
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1362  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1363          /* Check the cache content */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1364          if(Fee_BlockProperties_st[xMid_u16].BlockPersistentId_u16 == FeeIdx_u16)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1365          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1366              /* Index was found, set return value */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1367              *CacheIdx_pu16 = xMid_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1368  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1369              /* Return positive response */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1370              xFuncRet_b = TRUE;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1371  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1372              /* Leave the loop */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1373              return xFuncRet_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1374          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1375  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1376          /* Check the current array index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1377          if(Fee_BlockProperties_st[xMid_u16].BlockPersistentId_u16 > FeeIdx_u16)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1378          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1379              /* Check if the lowest array position is reached */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1380              if(xMid_u16 != 0)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1381              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1382                  /* Reduce the right limit to the left */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1383                  xRight_u16 = (uint16)(xMid_u16 - 1u);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1384              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1385              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1386              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1387                  /* Leave the loop with a negative response */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1388                  return xFuncRet_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1389              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1390          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1391          else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1392          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1393              /* Reduce the left limit to the right (upper limit is
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1394               * safe because of the loop condition) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1395              xLeft_u16 = (uint16)(xMid_u16 + 1u);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1396          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1397      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1398      while(xRight_u16 >= xLeft_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1399  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1400      return xFuncRet_b;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1401  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1402  /* FEE_FAST_CACHE_INIT_ACTIVE != FALSE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1403  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1404  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1405  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1406  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1407   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1408   * Fee_SrvRoundUp():
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1409   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1410   * This function takes the parameter value and rounds it up to the next
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1411   * multiple of the stepsize.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1412   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1413   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1414   * \param    value_u32: value to be rounded up
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1415   * \param    stepsize_u32: atomic steps to be made during the rounding
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1416   * \return   value rounded up to a multiple of the stepsize
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1417   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1418   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1419   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1420  LOCAL_INLINE uint32 Fee_SrvRoundUp(uint32 value_u32 , uint32 stepsize_u32)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1421  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1422      uint32 modValue_u32, retVal_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1423  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1424      retVal_u32 = value_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1425  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1426      modValue_u32 = value_u32 % stepsize_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1427  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1428      if(modValue_u32 != 0u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1429      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1430          retVal_u32 += stepsize_u32 - modValue_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1431      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1432  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1433      return retVal_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1434  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1435  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1436  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1437   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1438   * Fee_SrvCalcSpaceNeededForWrite():
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1439   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1440   * This function calculates the space required to perform a write operation based on a given block configuration
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1441   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1442   * \param    blockLen_u16:       data length to be writen
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1443   * \param    securityLevel_b:    single or double stored block?
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1444   * \param    noFallback_b: is the block configured as NoFallback?
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1445   * \return   space needed to write the block
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1446   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1447   *********************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1448   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1449  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1450  LOCAL_INLINE uint32 Fee_SrvCalcSpaceNeededForWrite(uint16  blockLen_u16 , boolean securityLevel_b , boolean noFallback_b)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1451  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1452      uint32 neededSpace_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1453  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1454      // for all block types: blkSize + HdrSize
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1455      neededSpace_u32 = (uint32)FEE_BLOCK_OVERHEAD + (uint32)(blockLen_u16);
	add	d0,d0,#14
.L225:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1456  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1457  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1458  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1459      // force a page alignment of header and data size
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1460      neededSpace_u32 = Fee_SrvRoundUp(neededSpace_u32 , (uint32)FEE_PAGE_LEN);
	mov	d15,#8
.L191:
	div.u	e4,d0,d15
.L229:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1428      if(modValue_u32 != 0u)      (inlined)
	jeq	d5,#0,.L43
.L392:
	rsub	d15,d5,#8
.L393:
	add	d0,d15

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1428      if(modValue_u32 != 0u)      (inlined)
.L43:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1433      return retVal_u32;      (inlined)
	j	.L44

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1434  }      (inlined)
.L44:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1461  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1462  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1463  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1464      // for NoFallback blocks: add one page space for the NoFB header
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1465      // If NoFallback is deactivated, the parameter shall be loaded with FALSE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1466      if (noFallback_b)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1467      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1468          neededSpace_u32 += (uint32)FEE_PAGE_LEN;
	cadd	d0,d2,d0,#8

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1466      if (noFallback_b)      (inlined)
.L45:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1473      if(securityLevel_b)      (inlined)
	jeq	d1,#0,.L46
.L394:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1469      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1470  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1471  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1472      // double security blocks: check for space writing both block copies
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1473      if(securityLevel_b)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1474      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1475          neededSpace_u32 *= 2u;
	sh	d0,#1

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1473      if(securityLevel_b)      (inlined)
.L46:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1478      return neededSpace_u32;      (inlined)
	j	.L47

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_Prv.h	  1479  }      (inlined)
.L47:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   308                  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   309  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   310  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   311  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   312                  neededSpace_u32 = Fee_SrvCalcSpaceNeededForWrite(dataLen_u16 , doubleSecActive_b , noFbActive_b);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   313  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   314                  if(Fee_LLCheckReorganizationNeed(FEE_REQUIRED_FREE_SPACE_BEFORE_HARD_SR, (uint16) neededSpace_u32)
	mov	d4,#16392
.L187:
	extr.u	d5,d0,#0,#16
.L188:
	call	Fee_LLCheckReorganizationNeed
.L223:
	eq	d15,d2,#5
.L395:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   315                          == FEE_SECTORFULL_E )
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   316                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   317                      /* There is not enough free space left, this is probably a retry because user orders which
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   318                       * will exceed the threshold will be blocked in the upper layer already
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   319                       * --> Abort the write order, perform a hard sector reorganization and retry
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   320                       * the whole write process after the Reorg*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   321                      xRetVal_en = FEE_SECTORFULL_E;
	cmov	d8,d15,#5
.L48:
	j	.L49
.L42:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   322  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   323                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   324  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   325              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   326              else
.L49:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   327              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   328                  // A LLWrite loop to write a second copy for a 2sec block
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   329                  // --> Don't execute the check
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   330              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   331  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   332  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   333              // If the NoFallback feature is active, go to the specific handler.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   334              // Otherwise continue the actual write
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   335              // If the decision was taken to execute the HSR, the state is going to be reset to Init
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   336              // at the end of the function.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   337              #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   338                  Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_BLANKCHECK_NOFB_WR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   339              #else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   340                  Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_WRITEHEADER_E;
	mov	d15,#1
.L396:
	ld.a	a15,[a10]4
	st.w	[a15],d15
.L170:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   341              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   342  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   343  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   344          }break;
	j	.L50

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   345  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   346  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   347  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   348  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   349  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   350  #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   351          case FEE_LL_WR_BLANKCHECK_NOFB_WR_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   352          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   353             if ((Fee_BlockProperties_st[Fee_OrderFifo_st[Fee_idxActQueue_u8].BlockPropIdx_u16].Flags_u16 & FEE_FLAG_NOFALLBACK_MSK) > 0u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   354              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   355                  /* Check if an old copy of the block is existing and also configured as NoFallback */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   356                  if ((Info_ptr->AdrBlkHeader_u32 != FEE_MAXUINT32) && (Fee_Rb_NoFallback_LastBlockCfg_b != FALSE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   357                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   358                      // Execute a blankcheck on the NoFB marker address before writing to prevent a uCSafetyFault on Renesas if the addess is non-blank
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   359  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   360                      if( Fls_Rb_BlankCheck( (Info_ptr->AdrBlkHeader_u32 - FEE_PAGE_LEN) , NULL_PTR , FEE_PAGE_LEN)!= E_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   361                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   362                          xRetVal_en = FEE_ABORTED_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   363                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   364                      else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   365                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   366                          Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_BLANKCHECK_NOFB_WR_WAIT_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   367                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   368                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   369                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   370                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   371                      // block is NoFallback, but no old copy was found
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   372                      //or the old copy wasn't configured as NoFallback
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   373                      //--> NoFB Marker Write is forbidden
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   374                      Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_FILL_SECTOR_END_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   375                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   376              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   377              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   378              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   379                  /* The block is not configured as NoFallback
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   380                   * -> go on with writing the header immediately */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   381                  Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_WRITEHEADER_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   382              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   383  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   384          }break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   385  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   386  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   387  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   388          /* Write the NoFallback marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   389          case FEE_LL_WR_WRITE_NOFB_MARKER_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   390          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   391  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   392              /* Check the NoFallback configuration for the current write order */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   393              if ((Fee_BlockProperties_st[Fee_OrderFifo_st[Fee_idxActQueue_u8].BlockPropIdx_u16].Flags_u16 & FEE_FLAG_NOFALLBACK_MSK) > 0u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   394              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   395                  /* Check if an old copy of the block is existing and also configured as NoFallback */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   396                  if ((Info_ptr->AdrBlkHeader_u32 != FEE_MAXUINT32) && (Fee_Rb_NoFallback_LastBlockCfg_b != FALSE))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   397                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   398                      /* Write the NoFallback marker to invalidate the old copy before writing any new copy */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   399                      if (Fls_Write(Info_ptr->AdrBlkHeader_u32 - FEE_PAGE_LEN, Fee_NoFallbackMarkerPattern, FEE_PAGE_LEN) != E_NOT_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   400                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   401                          /* Wait for the over programming to finish */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   402                          Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_WRITE_NOFB_MARKER_WAIT_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   403                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   404                      else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   405                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   406                          /* Return an error due to wrong parameters or a busy/not init state of the Fls */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   407                          xRetVal_en = FEE_ABORTED_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   408                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   409                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   410                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   411                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   412                      Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_FILL_SECTOR_END_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   413                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   414              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   415              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   416              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   417                  /* The block is not configured as NoFallback
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   418                   * -> go on with writing the header immediately */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   419                  Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_WRITEHEADER_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   420              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   421          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   422          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   423  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   424  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   425          /* The next sector will be used for writing in case the NoFallback marker and the block header does't fit
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   426           * into the current sector. To avoid GhostHeaders the last 2 Pages are written. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   427          case FEE_LL_WR_FILL_SECTOR_END_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   428          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   429              /* Calculate number of bytes necessary to store the block header only */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   430              xNumBytes_u16 = FEE_PAGES_USED_BY_BLK_HEADER * FEE_PAGE_LEN;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   431  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   432              /* Get the current physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   433              xPhySectIdx_u8 = Fee_GetPhysSectorByAddress(Fee_RdWrOrder_st.xWrAddress);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   434  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   435              /* Check if the sector is already filled up */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   436              if ((((Fee_RdWrOrder_st.xWrAddress + FEE_PAGE_LEN + xNumBytes_u16) - 1u) > Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogEndAddress_u32) &&
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   437                  (Fee_RdWrOrder_st.xWrAddress != Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogEndAddress_u32))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   438              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   439                  /* Fill the sector end with the NoFallback marker pattern */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   440                  if (Fls_Write(Fee_RdWrOrder_st.xWrAddress,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   441                                Fee_NoFallbackMarkerPattern,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   442                                (Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogEndAddress_u32 - Fee_RdWrOrder_st.xWrAddress) + 1u) != E_NOT_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   443                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   444                      /* Since there is not enough space to write the NoFallback marker and the block header
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   445                       * -> the write address is set to the end of the logical sector to switch to the next sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   446                      Fee_RdWrOrder_st.xWrAddress = Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogEndAddress_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   447  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   448                      /* Wait for the over programming to finish */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   449                      Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_FILL_SECTOR_END_WAIT_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   450                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   451                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   452                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   453                      /* Return an error due to wrong parameters or a busy/not init state of the Fls */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   454                      xRetVal_en = FEE_ABORTED_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   455                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   456              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   457              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   458              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   459                  /* The NoFallback marker and the block header fits into the current sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   460  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   461                  /* Write the block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   462                  Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_WRITEHEADER_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   463              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   464          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   465          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   466  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   467          /* Errors during write occured */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   468          case FEE_LL_WR_FILL_SECTOR_END_ERROR_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   469          case FEE_LL_WR_WRITE_NOFB_MARKER_ERROR_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   470          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   471              /* Return error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   472              xRetVal_en = FEE_ERROR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   473          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   474          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   475  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   476  #endif //(FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   477  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   478          /* Write the block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   479          case FEE_LL_WR_WRITEHEADER_E:
.L5:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   480          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   481              /* Calculate number of bytes necessary to store the block header only */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   482              xNumBytes_u16 = FEE_PAGES_USED_BY_BLK_HEADER * FEE_PAGE_LEN;
	mov	d15,#16
.L231:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   483  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   484  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   485              #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   486              /* Check the NoFallback configuration for the current write order */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   487              if ((Fee_BlockProperties_st[Fee_OrderFifo_st[Fee_idxActQueue_u8].BlockPropIdx_u16].Flags_u16 & FEE_FLAG_NOFALLBACK_MSK) > 0u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   488              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   489                  /* Increment the write address with the size of the NoFallback marker
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   490                   * -> It is always insured that the current write address remains in the current sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   491                  Fee_IncAddressInsideSector(&Fee_RdWrOrder_st.xWrAddress, FEE_PAGE_LEN, TRUE);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   492              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   493              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   494  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   495  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   496              #if (STD_OFF != FEE_SET_MODE_SUPPORTED)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   497              /* Check for a FastMode order */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   498              if(Fls_Mode == MEMIF_MODE_FAST)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   499              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   500                  /* Align the address to 16 bytes but only if it is not already aligned */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   501                  if ((Fee_RdWrOrder_st.xWrAddress % FEE_FASTMODE_ALIGNMENT) != 0u)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   502                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   503                      /* Get the current physical sector index before aligning the write address
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   504                       * -> Necessary in case the alignment leads to an overflow! */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   505                      xPhySectIdx_u8 = Fee_GetPhysSectorByAddress(Fee_RdWrOrder_st.xWrAddress);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   506  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   507                      /* Align the write address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   508                      Fee_RdWrOrder_st.xWrAddress &= (~((uint32)FEE_FASTMODE_ALIGNMENT - 1uL));
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   509                      Fee_RdWrOrder_st.xWrAddress += FEE_FASTMODE_ALIGNMENT;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   510  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   511                      /* Overflow handling
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   512                       * -> If the write address is after the alignment behind the logical end address,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   513                       *    the write address is set to the end of the logical sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   514                      if (Fee_RdWrOrder_st.xWrAddress >= Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogEndAddress_u32)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   515                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   516                          Fee_RdWrOrder_st.xWrAddress = Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogEndAddress_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   517                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   518                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   519              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   520              /* #if (STD_OFF != FEE_SET_MODE_SUPPORTED) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   521              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   522  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   523  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   524              /* 1st check: Check if the complete block header fits in the active sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   525              if(Fee_CalculateNumOfFreeBytesInCurSector(FEE_LL_SECTOR_USED_FOR_WRITING) >= xNumBytes_u16)
	mov.aa	a14,a12
	add.a	a14,#4
	ld.w	d4,[a14]
	call	Fee_CalculateNumOfFreeBytesInCurSector
.L230:
	jlt.u	d2,d15,.L51
.L397:
	lea	a15,[a12]28
.L398:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   526              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   527  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   528                  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)    /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   529                  /* For blocks > 2 pages, header will be written in 2 parts. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   530                  if ((Info_ptr->BlkLength_u16 + FEE_BLOCK_OVERHEAD) > (FEE_PAGES_USED_BY_BLK_HEADER * FEE_PAGE_LEN))
	ld.hu	d0,[a13]10
.L399:
	jlt.u	d0,#3,.L52
.L400:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   531                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   532                      /* Block header must be stored in 2 steps. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   533                      /* Store the address where 2nd header page must be programmed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   534                      Fee_RdWrOrder_st.xHdPg2Address = Fee_RdWrOrder_st.xWrAddress + FEE_PAGE_LEN;
	ld.w	d0,[a14]
.L401:
	add	d0,d0,#8
.L402:
	st.w	[a15],d0
.L403:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   535  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   536                      /* Copy the 2nd page information to an internal buffer. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   537                      Fee_SrvMemCopy8(Fee_hdr2Buffer_au8,(Fee_PageBytePtr_cpu8+FEE_PAGE_LEN),FEE_PAGE_LEN);
	movh.a	a4,#@his(Fee_hdr2Buffer_au8)
	lea	a4,[a4]@los(Fee_hdr2Buffer_au8)
.L404:
	movh.a	a15,#@his(Fee_PageBytePtr_cpu8)
	lea	a15,[a15]@los(Fee_PageBytePtr_cpu8)
	ld.a	a15,[a15]
.L405:
	lea	a5,[a15]8
.L406:
	mov	d4,#8
	call	Fee_SrvMemCopy8
.L407:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   538  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   539                      /* Only one page must be programmed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   540                      xTempNumBytes_u16 = FEE_PAGE_LEN;
	mov	d5,#8
.L233:
	j	.L53
.L52:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   541                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   542                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   543                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   544                      /* Block data fits into the header itself. Complete block can be written in 1 step itself. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   545                      xTempNumBytes_u16 = xNumBytes_u16;
	mov	d5,d15
.L234:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   546  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   547                      /* Set the xHdPg2Address = FEE_MAXUINT32 to indicate that the 2nd header page is also programmed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   548                      Fee_RdWrOrder_st.xHdPg2Address = FEE_MAXUINT32;
	mov	d0,#-1
.L408:
	st.w	[a15],d0
.L53:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   549                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   550                  #else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   551                      xTempNumBytes_u16 = xNumBytes_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   552                  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   553                  /* Write the header and some data bytes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   554                  if(Fls_Write(Fee_RdWrOrder_st.xWrAddress, (uint8*)&Fee_PageBytePtr_cpu8[0], xTempNumBytes_u16) != E_NOT_OK)
	ld.w	d4,[a14]
	movh.a	a15,#@his(Fee_PageBytePtr_cpu8)
	lea	a15,[a15]@los(Fee_PageBytePtr_cpu8)
	ld.a	a4,[a15]
	call	Fls_17_Pmu_Write
.L235:
	jeq	d2,#1,.L54
.L409:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   555                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   556                      cntProgrammedBytes_u32 += xNumBytes_u16;
	movh.a	a15,#@his(_999003_cntProgrammedBytes_u32)
	lea	a15,[a15]@los(_999003_cntProgrammedBytes_u32)
	ld.w	d0,[a15]
.L410:
	add	d0,d0,#16
	st.w	[a15],d0
.L411:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   557  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   558                      /* Save the address for the block header (will be used for the checksum verification in the flash) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   559                      Info_ptr->AdrBlkHeader_u32 = Fee_RdWrOrder_st.xWrAddress;
	ld.w	d0,[a14]
.L412:
	st.w	[a13],d0
.L413:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   560  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   561                      /* Mark the cache entry in order to be safe against write interruptions */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   562                      Fee_LLUpdateAddressInCache(Info_ptr->FeeIndex_u16, FEE_CACHE_TMP_INVALID_VALUE);
	ld.hu	d4,[a13]12
.L414:
	mov.u	d5,#51966
	addih	d5,d5,#45054
	call	Fee_LLUpdateAddressInCache
.L415:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   563  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   564                      /* Increment the write address (if increment is behind the sector end address, the address will be set to
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   565                       * the sector end address) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   566                      Fee_IncAddressInsideSector(&Fee_RdWrOrder_st.xWrAddress, xNumBytes_u16, TRUE);
	mov	d5,#1
	mov.aa	a4,a14
	mov	d4,d15
.L236:
	call	Fee_IncAddressInsideSector
.L237:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   567  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   568                      /* Wait for the write order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   569                      Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_WRITEHEADER_WAIT_E;
	mov	d15,#3
.L232:
	ld.a	a15,[a10]4
	st.w	[a15],d15
.L416:
	j	.L55
.L54:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   570                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   571                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   572                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   573                      /* Return an error due to wrong parameters or a busy/not init state of the Fls */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   574                      xRetVal_en = FEE_ABORTED_E;
	mov	d8,#6
.L55:
	j	.L56
.L51:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   575                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   576  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   577              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   578              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   579              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   580                  /* There are not enough bytes free to store at least the complete header (the block header should
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   581                   * not be splitted over several sectors!) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   582  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   583                  /* The FULL marker has to be written first */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   584                  Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_WRITE_FULL_MARKER_E;
	mov	d15,#10
.L238:
	st.w	[a12]60,d15
.L417:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   585  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   586                  /* Come back to the write header state after the FULL marker is written */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   587                  Fee_RdWrOrder_st.Fee_LLNextUsedWrBlock_en = FEE_LL_WR_WRITEHEADER_E;
	lea	a15,[a12]68
.L418:
	mov	d15,#1
.L419:
	st.w	[a15],d15
.L56:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   588              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   589          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   590          break;
	j	.L57

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   591  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   592  #if (FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   593          //Wait for the end of the blankcheck before writing a NoFB marker
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   594          case FEE_LL_WR_BLANKCHECK_NOFB_WR_WAIT_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   595          /* Wait for the end of the programming */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   596          case FEE_LL_WR_WRITE_NOFB_MARKER_WAIT_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   597          /* Wait for the over programming to finish */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   598          case FEE_LL_WR_FILL_SECTOR_END_WAIT_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   599  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   600          /* Write the block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   601          case FEE_LL_WR_WRITEHEADER_WAIT_E:
.L7:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   602          /* Wait for the verification to end */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   603          case FEE_LL_WR_VERIFYHEADER_WAIT_E:
.L9:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   604          /* Wait for the write order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   605          case FEE_LL_WR_WAIT_WRITEDATA_SEC_A_E:
.L12:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   606          /* Wait for the 2nd header page write order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   607  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)    /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   608          case FEE_LL_WR_WAIT_WRITEHDRPG2_E:
.L20:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   609  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   610          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   611              /* The next state (FEE_LL_WR_WRITEDATA_SEC_A_E / FEE_LL_WR_VERIFYHEADER_ERROR_E) will be set by
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   612               * the Fee_JobEndNotification() or Fee_JobErrorNotification() function automatically
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   613               * (the verification of the data will be done * in one step after the data was written) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   614  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   615              /* Check whether the OS is currently running or not */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   616              if (Fee_stMain == FEE_POLLING_MODE_E)
	movh.a	a15,#@his(Fee_stMain)
	lea	a15,[a15]@los(Fee_stMain)
	ld.w	d15,[a15]
.L420:
	jne	d15,#0,.L58
.L421:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   617              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   618                  /* Call the Fls main function manually */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   619                  Fls_MainFunction();
	call	Fls_17_Pmu_MainFunction
.L58:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   620              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   621  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   622              #if (STD_ON == FEE_POLLING_MODE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   623              /* Use the FLS polling mechanism in order to reach the next state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   624              Fee_CheckFlsJobResult();
	call	Fee_CheckFlsJobResult
.L422:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   625              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   626          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   627          break;
	j	.L59

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   628  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   629          /* Verify the header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   630          case FEE_LL_WR_VERIFYHEADER_E:
.L8:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   631          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   632              #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)    /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   633              /* Check if complete header must be verified or only first page. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   634              if (Fee_RdWrOrder_st.xHdPg2Address != FEE_MAXUINT32)
	lea	a15,[a12]28
	ld.w	d15,[a15]
.L423:
	eq	d0,d15,#-1
.L424:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   635              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   636                  /* One header page 1 was programmed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   637                  xTempNumBytes_u16 = FEE_PAGE_LEN;
	mov	d15,#8
	seln	d5,d0,d15,#16
.L239:
	j	.L61
.L60:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   638              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   639              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   640              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   641              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   642                  /* Complete block was programmed in one step, 2 bytes block or invalidate request. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   643                  xTempNumBytes_u16 = FEE_PAGE_LEN * FEE_PAGES_USED_BY_BLK_HEADER;
	mov	d5,#16
.L61:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   644              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   645  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   646              /* MR12 RULE 11.3 VIOLATION: Cast necessary for byte wise access */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   647              if (Fls_Compare(Info_ptr->AdrBlkHeader_u32,
	ld.w	d4,[a13]
	movh.a	a15,#@his(Fee_PageBytePtr_cpu8)
	lea	a15,[a15]@los(Fee_PageBytePtr_cpu8)
	ld.a	a4,[a15]
.L241:
	call	Fls_17_Pmu_Compare
.L240:
	jeq	d2,#0,.L62
.L425:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   648                              (uint8*)Fee_PageBytePtr_cpu8,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   649                              xTempNumBytes_u16) != E_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   650              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   651                  /* An error occured due to wrong parameters or a busy/not init state of the Fls */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   652                  xRetVal_en = FEE_ABORTED_E;
	mov	d8,#6
.L426:
	j	.L63
.L62:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   653              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   654              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   655              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   656                  /* Set the next state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   657                  Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_VERIFYHEADER_WAIT_E;
	mov	d15,#5
.L427:
	ld.a	a15,[a10]4
	st.w	[a15],d15
.L63:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   658              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   659          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   660          break;
	j	.L64

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   661  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   662          /* Verify or write error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   663          case FEE_LL_WR_WRITE_ERROR_E:
.L13:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   664          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   665              #if(FEE_ROBUST_PROG_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   666              /* check if the robust handling for IFX flashes is necessary */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   667              if (Fls_Rb_GetRobustProgStatus(&Fee_IfxRobustProgramming_s.xStartAddress,  &Fee_IfxRobustProgramming_s.DataBuffer, &Fee_IfxRobustProgramming_s.numBytes) == E_NOT_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   668              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   669                  /* Fls_Write was finished with success */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   670                  Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_WRITEDATA_IFX_HANDLING_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   671              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   672              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   673              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   674              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   675                  xRetVal_en = FEE_ERROR_E;
	mov	d8,#3
.L428:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   676              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   677          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   678          break;
	j	.L65

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   679  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   680  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   681  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   682          case FEE_LL_WR_VERIFYHEADER_ERROR_E:
.L10:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   683          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   684             /* The current block header in the flash is invalid
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   685              * --> execute write order again at the next write address (increment was
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   686              *     done already by the number of programmed bytes)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   687              * --> Return an error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   688             xRetVal_en = FEE_ERROR_E;
	mov	d8,#3
.L429:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   689          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   690          break;
	j	.L66

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   691  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   692          /* Prepare the data */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   693          case FEE_LL_WR_WRITEDATA_SEC_A_E:
.L11:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   694          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   695              /* Calculate the amount of bytes which are left (maybe the header pages already contain
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   696               * all necessary data bytes) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   697              xNumBytes_u16 = (uint16)(Info_ptr->BlkLength_u16 - Fee_GlobInfoWrBlock_st.BytesAlrdyConsid_u16);
	movh.a	a14,#@his(Fee_GlobInfoWrBlock_st)
	lea	a14,[a14]@los(Fee_GlobInfoWrBlock_st)
.L430:
	ld.hu	d15,[a13]10
.L431:
	ld.hu	d0,[a14]0
.L432:
	sub	d15,d0
.L433:
	extr.u	d10,d15,#0,#16
.L245:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   698  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   699              /* Check if an additional write order is necessary */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   700              if (xNumBytes_u16 == 0)
	jne	d10,#0,.L67
.L434:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   701              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   702                  /* Block header pages and the complete data has already been written, verify the content */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   703                  Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_VERIFY_BLK_E;
	mov	d15,#14
.L435:
	ld.a	a15,[a10]4
	st.w	[a15],d15
.L436:
	j	.L68
.L67:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   704              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   705              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   706              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   707                  /* Calculate number of free bytes in the currently active sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   708                  xNumFreeBytes_u32 = Fee_CalculateNumOfFreeBytesInCurSector(FEE_LL_SECTOR_USED_FOR_WRITING);
	mov.aa	a15,a12
	add.a	a15,#4
	st.a	[a10],a15
	ld.w	d4,[a15]
	call	Fee_CalculateNumOfFreeBytesInCurSector
.L244:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   709  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   710                  /* At least one page has to be free */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   711                  if (xNumFreeBytes_u32 >= FEE_PAGE_LEN)
	jlt.u	d2,#8,.L69
.L437:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   712                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   713                      /* Check if the complete data can be written to the active sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   714                      if(xNumFreeBytes_u32 < xNumBytes_u16)
	jge.u	d2,d10,.L70
.L438:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   715                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   716                          /* Restrict number of bytes to the maximum for the currently active sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   717                          xNumBytes_u16 = (uint16)xNumFreeBytes_u32;
	extr.u	d10,d2,#0,#16
.L70:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   718                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   719  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   720                      /* The complete data buffer can be used this time,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   721                       * check if the complete data fits into the internal data buffer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   722                      if(FEE_LL_DATABUFFSIZE < xNumBytes_u16)
	mov	d0,#256
.L439:
	ge.u	d15,d0,d10
.L440:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   723                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   724                          /* Restrict the number of bytes to the maximum size of the internal data buffer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   725                          xNumBytes_u16 = FEE_LL_DATABUFFSIZE;
	cmovn	d10,d15,d0
.L71:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   726                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   727  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   728                      /*Check if the complete data length is  multiple of PAGE_SIZE*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   729                      if((xNumBytes_u16 % FEE_VIRTUAL_PAGE_SIZE) != 0U)
	and	d15,d10,#7
.L441:
	jeq	d15,#0,.L72
.L442:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   730                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   731                          /*Calculate the length of padding data*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   732                          xTempPadding = FEE_VIRTUAL_PAGE_SIZE - (xNumBytes_u16 % FEE_VIRTUAL_PAGE_SIZE);
	rsub	d9,d15,#8
.L72:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   733                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   734  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   735                      /* Reset the page buffer to make sure no wrong data remains inside */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   736                      Fee_SrvMemSet8((uint8*)&Fee_DataBytePtr_cpu8[0], (uint8)FEE_ERASE_PATTERN, (xNumBytes_u16 + xTempPadding));
	add	d9,d10
.L243:
	movh.a	a12,#@his(Fee_DataBytePtr_cpu8)
	lea	a12,[a12]@los(Fee_DataBytePtr_cpu8)
	ld.a	a4,[a12]
.L443:
	mov	d4,#0
.L444:
	mov	d5,d9
	call	Fee_SrvMemSet8
.L246:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   737  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   738                      #if(FEE_ROB_FEATURE_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   739                      /* Increment the considered Crc bytes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   740                      xNumCrcBytesDone_u8 = 0;
	movh.a	a15,#@his(_999002_xNumCrcBytesDone_u8)
	lea	a15,[a15]@los(_999002_xNumCrcBytesDone_u8)
.L445:
	mov	d0,#0
.L446:
	st.b	[a15],d0
.L447:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   741  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   742                      /* Get the number of cut off bytes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   743                      xNumBytesCutOff_u16 = (uint16)((Info_ptr->BlkLength_u16 - Fee_GlobInfoWrBlock_st.BytesAlrdyConsid_u16) - xNumBytes_u16);
	ld.hu	d3,[a14]0
.L448:
	ld.hu	d0,[a13]10
.L449:
	sub	d0,d3
.L450:
	sub	d1,d0,d10
.L451:
	extr.u	d1,d1,#0,#16
.L247:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   744  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   745                      /* Check for an activated robustness attribute */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   746                      if((((Fee_BlockProperties_st[Fee_OrderFifo_st[Fee_idxActQueue_u8].BlockPropIdx_u16].Flags_u16 &
	movh.a	a2,#@his(Fee_idxActQueue_u8)
	lea	a2,[a2]@los(Fee_idxActQueue_u8)
	ld.bu	d2,[a2]
.L452:
	mul	d15,d2,#24
.L453:
	movh.a	a2,#@his(Fee_OrderFifo_st)
	lea	a2,[a2]@los(Fee_OrderFifo_st)
.L454:
	addsc.a	a2,a2,d15,#0
.L455:
	ld.hu	d2,[a2]6
	sha	d2,#4
.L456:
	movh.a	a2,#@his(Fee_BlockProperties_st)
	lea	a2,[a2]@los(Fee_BlockProperties_st)
.L457:
	addsc.a	a2,a2,d2,#0
.L458:
	ld.hu	d15,[a2]2
.L459:
	and	d15,#32
.L460:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   747                            (uint16)FEE_FLAG_ROBUST_ATTR_MSK) >> (uint16)FEE_FLAG_ROBUST_ATTR_BP) > 0))
	sha	d2,d15,#-5
.L461:
	jeq	d2,#0,.L73
.L462:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   748                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   749                          /* The robust feature is active for this block, check if this is the
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   750                           * last complete data transfer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   751                          if(((uint16)((Info_ptr->BlkLength_u16 -
	jge.u	d1,#4,.L74
.L463:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   752                                        Fee_GlobInfoWrBlock_st.BytesAlrdyConsid_u16) - xNumBytes_u16)) < FEE_SIZE_OF_BLOCK_CS)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   753                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   754                              /* The last transfer with data only has finished, now the checksum is at least part
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   755                               * of the stream and must be considered */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   756  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   757                              /* Get the offset for the CRC transfer, e.g. 3 Bytes:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   758                               *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   759                               * xCrcOffset_u8:           0  1  2  3 |  1  2  3
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   760                               * xNumBytes_u16:           4  3  2  1 |  3  2  1
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   761                               * xBlkCrc32Result_u32:    5A C3 B8 76 | C3 B8 76
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   762                               * Fee_DataBytePtr_cpu8[]: 76 B8 C3 5A | 76 B8 5A
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   763                               *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   764                               * */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   765                              if((Info_ptr->BlkLength_u16 - Fee_GlobInfoWrBlock_st.BytesAlrdyConsid_u16) > FEE_SIZE_OF_BLOCK_CS)
	jlt	d0,#5,.L75
.L464:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   766                              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   767                                  /* The first CRC byte has to be transfered */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   768                                  xCrcOffset_u8 = 0;
	mov	d11,#0
.L249:
	j	.L76
.L75:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   769                              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   770                              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   771                              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   772                                  /* Some CRC bytes have already been transfered */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   773                                  xCrcOffset_u8 = (uint8)(FEE_SIZE_OF_BLOCK_CS -
	rsub	d0,d0,#4
.L465:
	extr.u	d11,d0,#0,#8
.L76:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   774                                                         (Info_ptr->BlkLength_u16 - Fee_GlobInfoWrBlock_st.BytesAlrdyConsid_u16));
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   775                              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   776  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   777                              /* Get the number of CRC bytes to transfer this time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   778                              if(xNumBytesCutOff_u16 > FEE_SIZE_OF_BLOCK_CS)
	jlt.u	d1,#5,.L77
.L466:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   779                              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   780                                  /* No CRC bytes can be transfered now, only the complete data fits into
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   781                                   * the current sector or data buffer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   782                                  xNumCrcBytes_u8 = 0;
	mov	d12,#0
.L250:
	j	.L78
.L77:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   783                              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   784                              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   785                              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   786                                  /* Some CRC bytes can be added now */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   787                                  if((xNumBytesCutOff_u16 == 0) && (xNumBytes_u16 < FEE_SIZE_OF_BLOCK_CS))
	jne	d1,#0,.L79
.L467:
	jge.u	d10,#4,.L80
.L468:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   788                                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   789                                      /* All the bytes to be transfered are CRC bytes and there is no limitation */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   790                                      xNumCrcBytes_u8 = (uint8)(xNumBytes_u16);
	mov	d12,d10
.L251:
	j	.L81
.L80:
.L79:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   791                                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   792                                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   793                                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   794                                      /* The number of bytes to transfer is limited */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   795                                      xNumCrcBytes_u8 = (uint8)(FEE_SIZE_OF_BLOCK_CS - xNumBytesCutOff_u16);
	rsub	d12,d1,#4
.L81:
.L78:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   796                                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   797                              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   798  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   799                              /* Check if data bytes are left */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   800                              if(xNumBytes_u16 > xNumCrcBytes_u8)
	jge.u	d12,d10,.L82
.L469:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   801                              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   802                                  /* Data bytes are left */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   803                                  Fee_SrvMemCopy8((uint8*)&Fee_DataBytePtr_cpu8[0],
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   804                                                  &Data_pcu8[Fee_GlobInfoWrBlock_st.BytesAlrdyConsid_u16],
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   805                                                  (xNumBytes_u16 - xNumCrcBytes_u8));
	sub	d15,d10,d12
.L470:
	ld.a	a4,[a12]
.L471:
	ld.a	a2,[a10]8
.L252:
	addsc.a	a5,a2,d3,#0
.L472:
	mov	d4,d15
	call	Fee_SrvMemCopy8
.L248:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   806  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   807                                  /* Calculate the CRC for the user data over the internal data buffer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   808                                  xBlkCrc32Tmp_u32 = Crc_CalculateCRC32(&Fee_DataBytePtr_cpu8[0],
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   809                                                                       (uint32)(xNumBytes_u16 -
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   810                                                                                xNumCrcBytes_u8),
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   811                                                                       xBlkCrc32Result_u32,
	movh.a	a13,#@his(_999001_xBlkCrc32Result_u32)
.L242:
	lea	a13,[a13]@los(_999001_xBlkCrc32Result_u32)
.L473:
	ld.a	a4,[a12]
.L474:
	ld.w	d5,[a13]
.L475:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   812                                                                       FALSE);
	mov	d6,#0
	mov	d4,d15
	call	Crc_CalculateCRC32
.L253:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   813  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   814                                  /* Save the final checksum */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   815                                  xBlkCrc32Result_u32 = xBlkCrc32Tmp_u32;
	st.w	[a13],d2
.L476:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   816  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   817                                  /* Add data offset */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   818                                  xNumCrcBytesDone_u8 = (uint8)(xNumBytes_u16 - xNumCrcBytes_u8);
	st.b	[a15],d15
.L82:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   819                              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   820  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   821                              /* Loop over the CRC bytes (amount of bytes to transfer is set by xNumBytes_u16) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   822                              for(i_u8=0; i_u8<xNumCrcBytes_u8; i_u8++)
	mov	d15,#0
.L254:
	j	.L83
.L84:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   823                              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   824                                  /* Prepare the data buffer with the robustness CRC */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   825                                  Fee_DataBytePtr_cpu8[xNumCrcBytesDone_u8 + i_u8] =
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   826                                                                    (uint8)((xBlkCrc32Result_u32 >> ((24 - (i_u8*8)) - (xCrcOffset_u8*8))) & 0xFFu);
	movh.a	a2,#@his(_999001_xBlkCrc32Result_u32)
	lea	a2,[a2]@los(_999001_xBlkCrc32Result_u32)
.L477:
	ld.a	a4,[a12]
.L478:
	ld.bu	d0,[a15]
.L479:
	add	d0,d15
.L480:
	addsc.a	a4,a4,d0,#0
.L481:
	ld.w	d0,[a2]
.L482:
	sha	d1,d15,#3
.L483:
	rsub	d1,d1,#24
.L484:
	sha	d2,d11,#3
.L485:
	sub	d1,d2
.L486:
	rsub	d1,#0
	sh	d0,d0,d1
.L487:
	st.b	[a4],d0
.L488:
	add	d15,#1
.L255:
	extr.u	d15,d15,#0,#8
.L83:
	jlt.u	d15,d12,.L84
.L489:
	j	.L85
.L74:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   827                              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   828                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   829                          else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   830                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   831                              /* Additional transfers might follow, continue with copying the data only */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   832                              Fee_SrvMemCopy8((uint8*)&Fee_DataBytePtr_cpu8[0],
	ld.a	a4,[a12]
.L490:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   833                                              &Data_pcu8[Fee_GlobInfoWrBlock_st.BytesAlrdyConsid_u16],
	ld.a	a15,[a10]8
.L257:
	addsc.a	a5,a15,d3,#0
.L491:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   834                                              xNumBytes_u16);
	mov	d4,d10
.L259:
	call	Fee_SrvMemCopy8
.L256:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   835  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   836                              /* Calculate the CRC for the user data over the internal data buffer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   837                              xBlkCrc32Tmp_u32 = Crc_CalculateCRC32(&Fee_DataBytePtr_cpu8[0],
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   838                                                                   (uint32)xNumBytes_u16,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   839                                                                    xBlkCrc32Result_u32,
	movh.a	a15,#@his(_999001_xBlkCrc32Result_u32)
.L258:
	lea	a15,[a15]@los(_999001_xBlkCrc32Result_u32)
.L492:
	ld.a	a4,[a12]
.L493:
	ld.w	d5,[a15]
.L494:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   840                                                                    FALSE);
	mov	d6,#0
	mov	d4,d10
.L260:
	call	Crc_CalculateCRC32
.L261:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   841  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   842                              /* Save the start value for the next call */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   843                              xBlkCrc32Result_u32 = xBlkCrc32Tmp_u32;
	st.w	[a15],d2
.L85:
	j	.L86
.L73:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   844                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   845                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   846                      else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   847                      #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   848                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   849                          /* The robustness feature is inactive, continue with copying the data only */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   850                          Fee_SrvMemCopy8((uint8*)&Fee_DataBytePtr_cpu8[0],
	ld.a	a4,[a12]
.L495:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   851                                          &Data_pcu8[Fee_GlobInfoWrBlock_st.BytesAlrdyConsid_u16],
	ld.a	a15,[a10]8
.L262:
	addsc.a	a5,a15,d3,#0
.L496:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   852                                          xNumBytes_u16);
	mov	d4,d10
.L263:
	call	Fee_SrvMemCopy8
.L86:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   853                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   854  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   855                      /* Write the data, rounding up to the nearest FEE_VIRTUAL_PAGE_SIZE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   856                      if(Fls_Write(Fee_RdWrOrder_st.xWrAddress, &Fee_DataBytePtr_cpu8[0], (xNumBytes_u16 + xTempPadding)) != E_NOT_OK)
	ld.a	a15,[a10]
	ld.w	d4,[a15]
	ld.a	a4,[a12]
	mov	d5,d9
	call	Fls_17_Pmu_Write
.L497:
	jeq	d2,#1,.L87
.L498:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   857                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   858                          cntProgrammedBytes_u32 += xNumBytes_u16;
	movh.a	a15,#@his(_999003_cntProgrammedBytes_u32)
	lea	a15,[a15]@los(_999003_cntProgrammedBytes_u32)
	ld.w	d15,[a15]
.L499:
	add	d15,d10
	st.w	[a15],d15
.L500:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   859  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   860                          /* Update amount of already programmed data (will be used to calculate the rest in the next run) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   861                          Fee_GlobInfoWrBlock_st.BytesAlrdyConsid_u16 = (uint16)(Fee_GlobInfoWrBlock_st.BytesAlrdyConsid_u16 +
	ld.hu	d15,[a14]0
.L501:
	add	d15,d10
.L502:
	st.h	[a14],d15
.L503:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   862                                                                                 xNumBytes_u16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   863  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   864                          /* Increment the write address (if increment is behind the sector end address, the address will be set to
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   865                           * the sector end address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   866                          Fee_IncAddressInsideSector(&Fee_RdWrOrder_st.xWrAddress, xNumBytes_u16, TRUE);
	mov	d5,#1
	ld.a	a4,[a10]
	mov	d4,d10
.L264:
	call	Fee_IncAddressInsideSector
.L265:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   867  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   868                          /* Wait for the write order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   869                          Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_WAIT_WRITEDATA_SEC_A_E;
	mov	d15,#8
.L504:
	ld.a	a15,[a10]4
	st.w	[a15],d15
.L505:
	j	.L88
.L87:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   870                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   871                      else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   872                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   873                          /* Return an error due to wrong parameters or a busy/not init state of the Fls */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   874                          xRetVal_en = FEE_ABORTED_E;
	mov	d8,#6
.L88:
	j	.L89
.L69:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   875                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   876                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   877                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   878                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   879                      /* The sector is full */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   880  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   881                      /* The FULL marker has to be written first */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   882                      Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_WRITE_FULL_MARKER_E;
	mov	d15,#10
.L506:
	st.w	[a12]60,d15
.L507:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   883  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   884                      /* Come back to the write data state after the FULL marker is written */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   885                      Fee_RdWrOrder_st.Fee_LLNextUsedWrBlock_en = FEE_LL_WR_WRITEDATA_SEC_A_E;
	lea	a15,[a12]68
.L508:
	mov	d15,#7
.L509:
	st.w	[a15],d15
.L89:
.L68:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   886                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   887              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   888          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   889          break;
	j	.L90

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   890  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   891          /* Write the FULL marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   892          case FEE_LL_WR_WRITE_FULL_MARKER_E:
.L14:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   893          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   894              /* Get the physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   895              xPhySectIdx_u8 = Fee_GetPhysSectorByAddress(Fee_RdWrOrder_st.xWrAddress);
	mov.aa	a13,a12
.L267:
	add.a	a13,#4
	ld.w	d4,[a13]
	call	Fee_GetPhysSectorByAddress
.L266:
	mov	d15,d2
.L270:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   896  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   897              /* Write the FULL marker to the respective sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   898              if(Fee_LLWriteMarker(xPhySectIdx_u8, FEE_FULL_MARKER_ID_E) != FEE_ORDER_PENDING_E)
	mov	d5,#3
	mov	d4,d15
.L269:
	call	Fee_LLWriteMarker
.L272:
	jeq	d2,#0,.L91
.L510:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   899              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   900                  /*
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   901                   * Writing of "FULL" Marker was finished
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   902                   * -----------------------------------
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   903                   * --> Set Fee_RdWrOrder_st.xWrAddress to the first empty page in next logical sector
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   904                   * --> Write the USED Marker in the next logical sector
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   905                   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   906  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   907                  /* Get logical sector and increment it */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   908                  xLogSectIdx_u8 = (uint8)(Fee_idxLLSectorOrder_au8[xPhySectIdx_u8] + 1);
	movh.a	a15,#@his(Fee_idxLLSectorOrder_au8)
	lea	a15,[a15]@los(Fee_idxLLSectorOrder_au8)
.L511:
	addsc.a	a15,a15,d15,#0
	ld.bu	d15,[a15]
.L271:
	add	d15,#1
.L512:
	extr.u	d4,d15,#0,#8
.L273:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   909  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   910                  /* Check if switching from last to first sector requires an overflow */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   911                  if (xLogSectIdx_u8 >= FEE_NUM_FLASH_BANKS)
	movh.a	a15,#@his(Fee_NumFlashBanksUsed_u8)
	lea	a15,[a15]@los(Fee_NumFlashBanksUsed_u8)
	ld.bu	d15,[a15]
.L513:
	jlt.u	d4,d15,.L92
.L514:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   912                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   913                      /* Reset the logical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   914                      xLogSectIdx_u8 = FEE_NUM_FLASH_BANKS-1;
	add	d15,#-1
	extr.u	d4,d15,#0,#8
.L92:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   915                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   916  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   917                  /* Get the new physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   918                  xPhySectIdx_u8 = Fee_LLSectorOrder_st[xLogSectIdx_u8].xPhySecIdx_u8;
	movh.a	a15,#@his(Fee_LLSectorOrder_st)
	lea	a15,[a15]@los(Fee_LLSectorOrder_st)
.L515:
	mul	d15,d4,#12
	addsc.a	a15,a15,d15,#0
.L516:
	ld.bu	d9,[a15]8
.L268:
	movh.a	a14,#@his(Fee_FlashProp_st)
	lea	a14,[a14]@los(Fee_FlashProp_st)
.L517:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   919  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   920                  /* Erase the new logical sector if necessary  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   921                  if((Fee_LLSectorOrder_st[xLogSectIdx_u8].SecState_en == FEE_SECTOR_STATE_UNDEF_E) ||
	ld.w	d15,[a15]4
.L518:
	jeq	d15,#0,.L93
.L519:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   922                     (Fee_LLSectorOrder_st[xLogSectIdx_u8].SecState_en == FEE_SECTOR_REQUEST2ERASE_E))
	jne	d15,#4,.L94
.L93:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   923                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   924                      /* Mark this sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   925                      Fee_LLSetEraseSector(xLogSectIdx_u8);
	call	Fee_LLSetEraseSector
.L274:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   926  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   927                      /* Save new write address  */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   928                      Fee_RdWrOrder_st.xWrAddress = Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogStartAddress_u32;
	sha	d9,#4
.L275:
	addsc.a	a15,a14,d9,#0
.L520:
	ld.w	d15,[a15]8
.L521:
	st.w	[a13],d15
.L522:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   929  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   930                      /* Set erase state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   931                      Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_ERASE_SECTOR_E;
	mov	d15,#11
.L523:
	st.w	[a12]60,d15
.L524:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   932  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   933                      /* Come back to the write USED marker state after the ERASED marker is written */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   934                      Fee_RdWrOrder_st.Fee_LLNextEraseWrBlock_en = FEE_LL_WR_WRITE_USED_MARKER_E;
	lea	a15,[a12]72
.L525:
	mov	d15,#12
.L526:
	st.w	[a15],d15
.L527:
	j	.L95
.L94:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   935                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   936                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   937                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   938                      /* New logical sector is already erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   939  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   940                      /* Set the new write address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   941                      Fee_RdWrOrder_st.xWrAddress = Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogStartAddress_u32;
	sha	d9,#4
.L276:
	addsc.a	a15,a14,d9,#0
.L528:
	ld.w	d15,[a15]8
.L529:
	st.w	[a13],d15
.L530:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   942  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   943                      /* Write the USED marker next */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   944                      Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_WRITE_USED_MARKER_E;
	mov	d15,#12
.L531:
	ld.a	a15,[a10]4
	st.w	[a15],d15
.L95:
.L91:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   945                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   946              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   947          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   948          break;
	j	.L96

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   949  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   950          /* Erase the sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   951          case FEE_LL_WR_ERASE_SECTOR_E:
.L15:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   952          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   953              /* Get the erase result */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   954              xErSectorRetVal_en = Fee_LLEraseSector();
	call	Fee_LLEraseSector
.L277:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   955  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   956              /* Check the erase sector result */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   957              if(xErSectorRetVal_en != FEE_ORDER_PENDING_E)
	jeq	d2,#0,.L97
.L532:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   958              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   959                  /* Sector erase is done. New write address was already set before */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   960  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   961                  /* Verify the error return */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   962                  if((xErSectorRetVal_en == FEE_ERROR_E) || (xErSectorRetVal_en == FEE_ABORTED_E))
	jeq	d2,#3,.L98
.L533:
	jne	d2,#6,.L99
.L98:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   963                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   964                      /* Return an error
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   965                       * --> Write order will be finished unsuccessfully because the error reaction
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   966                       *     cannot be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   967                      xRetVal_en = FEE_ERROR_E;
	mov	d8,#3
.L534:
	j	.L100
.L99:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   968                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   969                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   970                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   971                      /* Get back the previous state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   972                      Fee_RdWrOrder_st.Fee_LLWrBlock_en = Fee_RdWrOrder_st.Fee_LLNextEraseWrBlock_en;
	lea	a15,[a12]72
	ld.w	d15,[a15]
.L535:
	st.w	[a12]60,d15
.L100:
.L97:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   973                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   974              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   975          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   976          break;
	j	.L101

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   977  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   978          /* Write the USED marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   979          case FEE_LL_WR_WRITE_USED_MARKER_E:
.L16:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   980          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   981              /* Get the new physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   982              xPhySectIdx_u8 = Fee_GetPhysSectorByAddress(Fee_RdWrOrder_st.xWrAddress);
	mov.aa	a15,a12
	add.a	a15,#4
	ld.w	d4,[a15]
	call	Fee_GetPhysSectorByAddress
.L278:
	mov	d15,d2
.L280:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   983  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   984              /* Mark the cache status for this sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   985              Fee_LLUpdateCacheStForSect(xPhySectIdx_u8);
	mov	d4,d15
.L279:
	call	Fee_LLUpdateCacheStForSect
.L282:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   986  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   987              /* Write the USED marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   988              xWrMarkerRetVal_en = Fee_LLWriteMarker(xPhySectIdx_u8, FEE_USED_MARKER_ID_E);
	mov	d5,#2
	mov	d4,d15
.L283:
	call	Fee_LLWriteMarker
.L284:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   989  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   990              /* Check the write USED marker result */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   991              if(xWrMarkerRetVal_en != FEE_ORDER_PENDING_E)
	jeq	d2,#0,.L102
.L536:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   992              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   993                  /* Setting the write address to the first empty page in the next logical sector
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   994                   * was already set in the the previous state (FEE_LL_WR_WRITE_FULL_MARKER_E) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   995  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   996                  /* Verify whether it was possible to write the USED marker or not */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   997                  if(xWrMarkerRetVal_en == FEE_ORDER_FINISHED_E)
	jne	d2,#1,.L103
.L537:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   998                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	   999                      /* Write Marker with the start-Address as Payload. This marker is more or less the double storage
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1000                       * of the USED Marker and contains the Address of the first  blockheader */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1001                      tmpAddr_u32 = Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogStartAddress_u32;
	movh.a	a15,#@his(Fee_FlashProp_st)
	lea	a15,[a15]@los(Fee_FlashProp_st)
.L538:
	sha	d15,#4
.L281:
	addsc.a	a15,a15,d15,#0
.L539:
	ld.w	d0,[a15]8
.L286:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1002  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1003                      /* Calculate how many bytes have to be written in the "new" sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1004                      if (cntProgrammedBytes_u32 > 0uL)
	movh.a	a2,#@his(_999003_cntProgrammedBytes_u32)
	lea	a2,[a2]@los(_999003_cntProgrammedBytes_u32)
	ld.w	d15,[a2]
.L540:
	jeq	d15,#0,.L104
.L541:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1005                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1006                          /* Parts of the block are in the "old" (and hopefully FULL) sector.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1007                           * -> calculate number of bytes which will be stored from the current block into the "new" sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1008                          tmpAddr_u32 += (uint32)(FEE_BLOCK_OVERHEAD + Info_ptr->BlkLength_u16) - cntProgrammedBytes_u32;
	ld.hu	d1,[a13]10
	sub	d1,d15
	add	d15,d1,#14
.L542:
	add	d0,d15
.L543:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1009  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1010                          /* Ensure correct page alignment */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1011                          while ((tmpAddr_u32 % FEE_PAGE_LEN) != 0u)
	j	.L105
.L106:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1012                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1013                              tmpAddr_u32++;
	add	d0,#1
.L105:
	and	d15,d0,#7
.L544:
	jne	d15,#0,.L106
.L545:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1014                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1015  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1016                          /* Check if the block is maybe greater then 1 sector and so the sector contains programmed pages, but no blockheader */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1017                          if (tmpAddr_u32 >= Fee_FlashProp_st[xPhySectIdx_u8].Fee_LogEndAddress_u32)
	ld.w	d15,[a15]12
.L546:
	lt.u	d15,d0,d15
.L547:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1018                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1019                              tmpAddr_u32 = FEE_MAXUINT32;
	cmovn	d0,d15,#-1
.L107:
	j	.L108
.L104:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1020                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1021                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1022                      else
.L108:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1023                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1024                          /* First blockheader will be stored on the first page of the logic sector.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1025                           * -> No additional correction required */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1026                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1027  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1028                      Fee_RdWrOrder_st.xStartAddrNextSector_u32 = tmpAddr_u32;
	st.w	[a12]24,d0
.L548:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1029  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1030                      /* Get back to the previous state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1031                      Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_WRITE_START_MARKER_E;
	mov	d15,#13
.L549:
	st.w	[a12]60,d15
.L550:
	j	.L109
.L103:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1032                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1033                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1034                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1035                      /* The complete sector has to be erased again. Otherwise there might be
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1036                       * data getting lost in the future! */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1037  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1038                      /* Get corresponding logical sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1039                      xLogSectIdx_u8 = Fee_idxLLSectorOrder_au8[xPhySectIdx_u8];
	movh.a	a15,#@his(Fee_idxLLSectorOrder_au8)
	lea	a15,[a15]@los(Fee_idxLLSectorOrder_au8)
.L551:
	addsc.a	a15,a15,d15,#0
	ld.bu	d4,[a15]
.L288:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1040  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1041                      /* Mark this sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1042                      Fee_LLSetEraseSector(xLogSectIdx_u8);
	call	Fee_LLSetEraseSector
.L285:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1043  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1044                      /* Set erase state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1045                      Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_ERASE_SECTOR_E;
	mov	d15,#11
.L287:
	st.w	[a12]60,d15
.L552:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1046  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1047                      /* Come back to the write USED marker state after the ERASED marker is written
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1048                       * (Next state after the write USED marker state was already saved to
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1049                       *  Fee_RdWrOrder_st.Fee_LLNextUsedWrBlock_en in the former step)*/
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1050                      Fee_RdWrOrder_st.Fee_LLNextEraseWrBlock_en = FEE_LL_WR_WRITE_USED_MARKER_E;
	lea	a15,[a12]72
.L553:
	mov	d15,#12
.L554:
	st.w	[a15],d15
.L109:
.L102:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1051                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1052              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1053          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1054          break;
	j	.L110

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1055  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1056          /* Write the START marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1057          case FEE_LL_WR_WRITE_START_MARKER_E:
.L17:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1058          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1059              /* Get the new physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1060              xPhySectIdx_u8 = Fee_GetPhysSectorByAddress(Fee_RdWrOrder_st.xWrAddress);
	mov.aa	a15,a12
	add.a	a15,#4
	ld.w	d4,[a15]
	call	Fee_GetPhysSectorByAddress
.L289:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1061  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1062              /* Write the USED marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1063              xWrMarkerRetVal_en = Fee_LLWriteMarker(xPhySectIdx_u8, FEE_START_MARKER_ID_E);
	mov	d5,#5
	mov	d4,d2
.L291:
	call	Fee_LLWriteMarker
.L290:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1064  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1065              /* Check the write USED marker result */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1066              if(xWrMarkerRetVal_en != FEE_ORDER_PENDING_E)
	jeq	d2,#0,.L111
.L555:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1067              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1068                  /* Get back to the previous state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1069                  Fee_RdWrOrder_st.Fee_LLWrBlock_en = Fee_RdWrOrder_st.Fee_LLNextUsedWrBlock_en;
	lea	a15,[a12]68
	ld.w	d15,[a15]
.L556:
	st.w	[a12]60,d15
.L111:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1070              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1071          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1072          break;
	j	.L112

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1073  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1074          /* Verify the block data and header content */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1075          case FEE_LL_WR_VERIFY_BLK_E:
.L18:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1076          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1077              /* Check if the complete block was written first (blocks are always written with as much data as possible) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1078              if(Fee_GlobInfoWrBlock_st.BytesAlrdyConsid_u16 < Fee_GlobInfoLastRdHeader_st.BlkLength_u16)
	movh.a	a14,#@his(Fee_GlobInfoWrBlock_st)
	lea	a14,[a14]@los(Fee_GlobInfoWrBlock_st)
.L557:
	ld.hu	d15,[a14]0
.L558:
	movh.a	a15,#@his(Fee_GlobInfoLastRdHeader_st)
	lea	a15,[a15]@los(Fee_GlobInfoLastRdHeader_st)
.L559:
	ld.hu	d0,[a15]10
.L560:
	jge.u	d15,d0,.L113
.L561:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1079              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1080                  /* Check whether the last order filled up the sector already or not */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1081                  if(Fee_CalculateNumOfFreeBytesInCurSector(FEE_LL_SECTOR_USED_FOR_WRITING) == 0u)
	mov.aa	a15,a12
	add.a	a15,#4
	ld.w	d4,[a15]
	call	Fee_CalculateNumOfFreeBytesInCurSector
.L292:
	jne	d2,#0,.L114
.L562:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1082                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1083                      /* The current sector was filled up completely and there are still data bytes to
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1084                       * program. Necessary steps:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1085                       * 1. write FULL marker
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1086                       * 2. switch active write sector
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1087                       * 3. write USED marker
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1088                       * 4. write the rest of the data
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1089                       */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1090  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1091                      /* Set the next state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1092                      Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_WRITE_FULL_MARKER_E;
	mov	d15,#10
.L563:
	st.w	[a12]60,d15
.L564:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1093  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1094                      /* Come back to the write data state after the FULL marker was written */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1095                      Fee_RdWrOrder_st.Fee_LLNextUsedWrBlock_en = FEE_LL_WR_WRITEDATA_SEC_A_E;
	lea	a15,[a12]68
.L565:
	mov	d15,#7
.L566:
	st.w	[a15],d15
.L567:
	j	.L115
.L114:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1096                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1097                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1098                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1099                      /* Go on with the write order */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1100                      Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_WRITEDATA_SEC_A_E;
	mov	d15,#7
.L568:
	ld.a	a15,[a10]4
	st.w	[a15],d15
.L115:
	j	.L116
.L113:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1101                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1102              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1103              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1104              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1105                  #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)    /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1106                  /* Check if 2nd header page is programmed. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1107                  if (Fee_RdWrOrder_st.xHdPg2Address != FEE_MAXUINT32)
	lea	a15,[a12]28
	ld.w	d15,[a15]
.L569:
	jeq	d15,#-1,.L117
.L570:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1108                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1109                      /* First write the 2nd header page. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1110                      Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_WRITEHDRPG2_E;
	mov	d15,#15
.L571:
	ld.a	a15,[a10]4
	st.w	[a15],d15
.L572:
	j	.L118
.L117:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1111                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1112                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1113                  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1114                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1115                      /* Compare the complete programmed data including the block header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1116                      xCompareRetVal_en = Fee_LLCalcBlkCrcInFlash(Info_ptr);
	mov.aa	a4,a13
	call	Fee_LLCalcBlkCrcInFlash
.L293:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1117  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1118                      /* Check the busy state of the compare function */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1119                      if(xCompareRetVal_en != FEE_ORDER_PENDING_E)
	jeq	d2,#0,.L119
.L573:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1120                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1121                          /* Check the compare result */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1122                          if(xCompareRetVal_en == FEE_ORDER_FINISHED_E)
	jne	d2,#1,.L120
.L574:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1123                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1124                              /* Block in flash is correct, verify the security level depending
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1125                               * on the config out of the PFlash, not out of the DFlash */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1126  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1127                              /* Verify the security level out of the PFlash */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1128                              // Shift isn't required when accessing the security bit because it has the offset 0
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1129                              if(((Fee_BlockProperties_st[Fee_OrderFifo_st[Fee_idxActQueue_u8].BlockPropIdx_u16].Flags_u16 &
	movh.a	a15,#@his(Fee_idxActQueue_u8)
	lea	a15,[a15]@los(Fee_idxActQueue_u8)
	ld.bu	d15,[a15]
.L575:
	mul	d15,d15,#24
.L576:
	movh.a	a15,#@his(Fee_OrderFifo_st)
	lea	a15,[a15]@los(Fee_OrderFifo_st)
.L577:
	addsc.a	a15,a15,d15,#0
.L578:
	ld.hu	d15,[a15]6
	sha	d15,#4
.L579:
	movh.a	a15,#@his(Fee_BlockProperties_st)
	lea	a15,[a15]@los(Fee_BlockProperties_st)
.L580:
	addsc.a	a15,a15,d15,#0
.L581:
	ld.hu	d15,[a15]2
.L582:
	jz.t	d15:0,.L121
.L583:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1130                                      FEE_FLAG_SEC_LEVEL_MSK) == FEE_BLK_INT_DOUBLE_STORAGE) &&
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1131                               (Fee_GlobInfoWrBlock_st.cntCopies_u8 == FEE_CNT_FIRST_COPY))
	lea	a2,[a14]8
	ld.bu	d15,[a2]
.L584:
	jne	d15,#0,.L122
.L585:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1132                              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1133                                  /* Reset state machine because there is still one copy to program */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1134                                  Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_BLK_INIT_E;
	mov	d0,#0
.L586:
	ld.a	a15,[a10]4
	st.w	[a15],d0
.L587:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1135  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1136                                  /* Increment the copy counter for the next check */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1137                                  Fee_GlobInfoWrBlock_st.cntCopies_u8++;
	add	d15,#1
	st.b	[a2],d15
.L588:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1138  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1139                                  #if(FEE_NO_FALLBACK_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1140                                  /* Set the address of the second copy of this block to write the NoFallback marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1141                                  Info_ptr->AdrBlkHeader_u32 = Fee_Rb_NoFallback_RemAdr_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1142                                  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1143  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1144                                  /* Reset the already considered bytes */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1145                                  Fee_LLPrepPageBufWithHdrDataStart(Info_ptr);
	mov.aa	a4,a13
.L295:
	call	Fee_LLPrepPageBufWithHdrDataStart
.L294:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1146                                  Fee_LLPrepPageBufWithHdrDataEnd(Info_ptr, Data_pcu8, Info_ptr->BlkCrc32_u32);
	ld.w	d4,[a13]4
	mov.aa	a4,a13
.L296:
	ld.a	a5,[a10]8
.L298:
	call	Fee_LLPrepPageBufWithHdrDataEnd
.L297:
	j	.L123
.L122:
.L121:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1147                              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1148                              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1149                              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1150                                  /* All required copies were stored correctly */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1151                                  xRetVal_en = FEE_ORDER_FINISHED_E;
	mov	d8,#1
.L123:
	j	.L124
.L120:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1152                              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1153  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1154                              /* The cache update was already done inside the compare function */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1155                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1156                          else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1157                          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1158                              /* The current block in flash is invalid or the compare order was aborted
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1159                               * --> execute write order again at the next write address (increment was
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1160                               *     done already by the number of programmed bytes) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1161                              /* Return error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1162                              xRetVal_en = FEE_ERROR_E;
	mov	d8,#3
.L124:
.L119:
.L118:
.L116:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1163  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1164                              /* Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1165                              #if (defined(RBA_FLSIFX_FLASH) || defined(RBA_FLSJDP_FLASH))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1166                              if(xCompareRetVal_en == FEE_ERROR_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1167                              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1168                                  if(E_NOT_OK != Fls_Write(Info_ptr->AdrBlkHeader_u32, Fee_hdrBuffer_au8, FEE_PAGE_LEN))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1169                                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1170                                      Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_WAIT_FOR_FLS_OVERPROGRAMMING_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1171                                      xRetVal_en                        = FEE_ORDER_PENDING_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1172                                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1173                                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1174                                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1175                                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1176                              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1177                              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1178                              /* END Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1179                          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1180                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1181                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1182              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1183          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1184          break;
	j	.L125

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1185  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1186          /* Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1187          #if (defined(RBA_FLSIFX_FLASH) || defined(RBA_FLSJDP_FLASH))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1188          case FEE_LL_WR_WAIT_FOR_FLS_OVERPROGRAMMING_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1189          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1190              if(Fls_GetJobResult() != MEMIF_JOB_PENDING)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1191              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1192                  xRetVal_en = FEE_ERROR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1193              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1194          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1195          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1196          #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1197          /* END Workaround Overstamp invalid header to reduce init time */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1198  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1199          #if (FEE_PAGES_USED_BY_BLK_HEADER == 2u)    /* Robust block programming states (Hdpg1 -> Data -> Hdpg2 write) */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1200          case FEE_LL_WR_WRITEHDRPG2_E:
.L19:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1201          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1202              /* Trigger write for 2nd header page. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1203              if(Fls_Write(Fee_RdWrOrder_st.xHdPg2Address, (uint8*)&Fee_hdr2Buffer_au8[0], FEE_PAGE_LEN) != E_NOT_OK)
	lea	a15,[a12]28
	ld.w	d4,[a15]
	movh.a	a4,#@his(Fee_hdr2Buffer_au8)
.L300:
	lea	a4,[a4]@los(Fee_hdr2Buffer_au8)
	mov	d5,#8
	call	Fls_17_Pmu_Write
.L299:
	jeq	d2,#1,.L126
.L589:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1204              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1205                  /* Set the xHdPg2Address = FEE_MAXUINT32 to indicate that 2nd header page write is started */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1206                  Fee_RdWrOrder_st.xHdPg2Address = FEE_MAXUINT32;
	mov	d15,#-1
.L590:
	st.w	[a15],d15
.L591:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1207  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1208                  Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_WAIT_WRITEHDRPG2_E;
	mov	d15,#16
.L592:
	ld.a	a15,[a10]4
	st.w	[a15],d15
.L593:
	j	.L127
.L126:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1209              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1210              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1211              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1212                  /* Return an error due to wrong parameters or a busy/not init state of the Fls */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1213                  xRetVal_en = FEE_ABORTED_E;
	mov	d8,#6
.L127:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1214              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1215          }break;
	j	.L128

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1216          #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1217  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1218          #if(FEE_ROBUST_PROG_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1219          case FEE_LL_WR_WRITEDATA_IFX_HANDLING_E:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1220          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1221              /* Get the new physical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1222              xPhySectIdx_u8 = Fee_GetPhysSectorByAddress(Fee_RdWrOrder_st.xWrAddress);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1223  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1224              /* Get corresponding logical sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1225              xLogSectIdx_u8 = Fee_idxLLSectorOrder_au8[xPhySectIdx_u8];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1226  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1227              if (Fee_RobIfxHandling(xLogSectIdx_u8) != FEE_ORDER_PENDING_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1228              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1229                  xRetVal_en = FEE_ERROR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1230              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1231          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1232          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1233          #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1234  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1235          /* Default */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1236          default:
.L3:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1237          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1238              /* State should never be reached */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1239              xRetVal_en = FEE_ABORTED_E;
	mov	d8,#6
.L594:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1240          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1241          break;
	j	.L129

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1242      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1243  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1244  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1245      /* Reset state machine if necessary */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1246      if(xRetVal_en != FEE_ORDER_PENDING_E)
.L129:
.L128:
.L125:
.L112:
.L110:
.L101:
.L96:
.L90:
.L66:
.L65:
.L64:
.L59:
.L57:
.L50:
.L41:
	jeq	d8,#0,.L130
.L595:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1247      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1248          /* Order was finished with or without error */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1249          Fee_RdWrOrder_st.Fee_LLWrBlock_en = FEE_LL_WR_BLK_INIT_E;
	mov	d15,#0
.L596:
	ld.a	a15,[a10]4
	st.w	[a15],d15
.L597:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1250  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1251          /* This additional reset is necessary, because it cannot be reset in the initialization state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1252          Fee_GlobInfoWrBlock_st.cntCopies_u8 = FEE_CNT_FIRST_COPY;
	movh.a	a15,#@his(Fee_GlobInfoWrBlock_st)
	lea	a15,[a15]@los(Fee_GlobInfoWrBlock_st)
.L598:
	lea	a15,[a15]8
.L599:
	mov	d15,#0
.L600:
	st.b	[a15],d15
.L130:

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1253      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1254  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1255      return (xRetVal_en);
	mov	d2,d8
.L301:
	j	.L131

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1256  }
.L131:
	ret
.L144:
	
__Fee_LLWriteBlock_function_end:
	.size	Fee_LLWriteBlock,__Fee_LLWriteBlock_function_end-Fee_LLWriteBlock
.L142:
	; End of function
	
	.sdecl	'.data.rba_FeeFs1_LlWriteBlock._999001_xBlkCrc32Result_u32',data,cluster('_999001_xBlkCrc32Result_u32')
	.sect	'.data.rba_FeeFs1_LlWriteBlock._999001_xBlkCrc32Result_u32'
	.align	4
_999001_xBlkCrc32Result_u32:	.type	object
	.size	_999001_xBlkCrc32Result_u32,4
	.space	4
	.sdecl	'.data.rba_FeeFs1_LlWriteBlock._999002_xNumCrcBytesDone_u8',data,cluster('_999002_xNumCrcBytesDone_u8')
	.sect	'.data.rba_FeeFs1_LlWriteBlock._999002_xNumCrcBytesDone_u8'
_999002_xNumCrcBytesDone_u8:	.type	object
	.size	_999002_xNumCrcBytesDone_u8,1
	.space	1
	.sdecl	'.data.rba_FeeFs1_LlWriteBlock._999003_cntProgrammedBytes_u32',data,cluster('_999003_cntProgrammedBytes_u32')
	.sect	'.data.rba_FeeFs1_LlWriteBlock._999003_cntProgrammedBytes_u32'
	.align	4
_999003_cntProgrammedBytes_u32:	.type	object
	.size	_999003_cntProgrammedBytes_u32,4
	.space	4
	.calls	'Fee_LLWriteBlock','Fee_SrvMemSet8'
	.calls	'Fee_LLWriteBlock','Fee_GetPhysSectorByAddress'
	.calls	'Fee_LLWriteBlock','Fee_LLSetEraseSector'
	.calls	'Fee_LLWriteBlock','Fee_LLUpdateAddressInCache'
	.calls	'Fee_LLWriteBlock','Fee_LLEraseCacheStForSect'
	.calls	'Fee_LLWriteBlock','Fee_LLCheckReorganizationNeed'
	.calls	'Fee_LLWriteBlock','Fee_CalculateNumOfFreeBytesInCurSector'
	.calls	'Fee_LLWriteBlock','Fee_SrvMemCopy8'
	.calls	'Fee_LLWriteBlock','Fls_17_Pmu_Write'
	.calls	'Fee_LLWriteBlock','Fee_IncAddressInsideSector'
	.calls	'Fee_LLWriteBlock','Fls_17_Pmu_MainFunction'
	.calls	'Fee_LLWriteBlock','Fee_CheckFlsJobResult'
	.calls	'Fee_LLWriteBlock','Fls_17_Pmu_Compare'
	.calls	'Fee_LLWriteBlock','Crc_CalculateCRC32'
	.calls	'Fee_LLWriteBlock','Fee_LLWriteMarker'
	.calls	'Fee_LLWriteBlock','Fee_LLEraseSector'
	.calls	'Fee_LLWriteBlock','Fee_LLUpdateCacheStForSect'
	.calls	'Fee_LLWriteBlock','Fee_LLCalcBlkCrcInFlash'
	.calls	'Fee_LLWriteBlock','Fee_LLPrepPageBufWithHdrDataStart'
	.calls	'Fee_LLWriteBlock','Fee_LLPrepPageBufWithHdrDataEnd'
	.extern	Fls_17_Pmu_Write
	.extern	Fls_17_Pmu_Compare
	.extern	Fls_17_Pmu_MainFunction
	.extern	Fee_stMain
	.extern	Fee_FlashProp_st
	.extern	Fee_PageBytePtr_cpu8
	.extern	Fee_RdWrOrder_st
	.extern	Fee_LLSectorOrder_st
	.extern	Fee_OrderFifo_st
	.extern	Fee_GlobInfoLastRdHeader_st
	.extern	Fee_GlobInfoWrBlock_st
	.extern	Fee_DataBytePtr_cpu8
	.extern	Fee_NumFlashBanksUsed_u8
	.extern	Fee_hdr2Buffer_au8
	.extern	Fee_idxLLSectorOrder_au8
	.extern	Fee_idxActQueue_u8
	.extern	Fee_DataByteStartCrc_u32
	.extern	Fee_BlockProperties_st
	.extern	Fee_CalculateNumOfFreeBytesInCurSector
	.extern	Fee_GetPhysSectorByAddress
	.extern	Fee_LLWriteMarker
	.extern	Fee_LLEraseSector
	.extern	Fee_LLSetEraseSector
	.extern	Fee_LLCalcBlkCrcInFlash
	.extern	Fee_LLPrepPageBufWithHdrDataStart
	.extern	Fee_LLPrepPageBufWithHdrDataEnd
	.extern	Fee_IncAddressInsideSector
	.extern	Fee_LLCheckReorganizationNeed
	.extern	Fee_LLUpdateAddressInCache
	.extern	Fee_LLUpdateCacheStForSect
	.extern	Fee_LLEraseCacheStForSect
	.extern	Fee_SrvMemSet8
	.extern	Fee_SrvMemCopy8
	.extern	Fee_CheckFlsJobResult
	.extern	Crc_CalculateCRC32
	.calls	'Fee_LLWriteBlock','',16
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L135:
	.word	18566
	.half	3
	.word	.L136
	.byte	4
.L134:
	.byte	1
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlWriteBlock.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L137
.L156:
	.byte	2
	.byte	'unsigned int',0,4,7
.L190:
	.byte	3
	.byte	'Fee_SrvRoundUp',0,3,1,140,11,21
	.word	156
	.byte	1,1
.L192:
	.byte	4
	.byte	'value_u32',0,1,140,11,43
	.word	156
.L194:
	.byte	4
	.byte	'stepsize_u32',0,1,140,11,62
	.word	156
.L196:
	.byte	5,0
.L153:
	.byte	2
	.byte	'unsigned short int',0,2,7
.L158:
	.byte	2
	.byte	'unsigned char',0,1,8
.L177:
	.byte	3
	.byte	'Fee_SrvCalcSpaceNeededForWrite',0,3,1,170,11,21
	.word	156
	.byte	1,1
.L179:
	.byte	4
	.byte	'blockLen_u16',0,1,170,11,60
	.word	242
.L181:
	.byte	4
	.byte	'securityLevel_b',0,1,170,11,83
	.word	264
.L183:
	.byte	4
	.byte	'noFallback_b',0,1,170,11,109
	.word	264
.L185:
	.byte	6,5,0,0,7
	.word	264
.L147:
	.byte	8
	.word	397
	.byte	9
	.byte	'Fls_17_Pmu_Write',0,2,184,6,23
	.word	264
	.byte	1,1,1,1,4
	.byte	'TargetAddress',0,2,184,6,57
	.word	156
	.byte	4
	.byte	'SourceAddressPtr',0,2,185,6,47
	.word	402
	.byte	4
	.byte	'Length',0,2,186,6,49
	.word	156
	.byte	0,9
	.byte	'Fls_17_Pmu_Compare',0,2,216,6,23
	.word	264
	.byte	1,1,1,1,4
	.byte	'SourceAddress',0,2,216,6,59
	.word	156
	.byte	4
	.byte	'TargetAddressPtr',0,2,217,6,42
	.word	402
	.byte	4
	.byte	'Length',0,2,218,6,44
	.word	156
	.byte	0,10
	.byte	'Fls_17_Pmu_MainFunction',0,2,134,8,13,1,1,1,1,9
	.byte	'Fee_CalculateNumOfFreeBytesInCurSector',0,1,160,8,31
	.word	156
	.byte	1,1,1,1,4
	.byte	'DataEndAdr_u32',0,1,160,8,91
	.word	156
	.byte	0,9
	.byte	'Fee_GetPhysSectorByAddress',0,1,171,8,31
	.word	264
	.byte	1,1,1,1,4
	.byte	'Address_u32',0,1,171,8,81
	.word	156
	.byte	0
.L143:
	.byte	11,1,137,2,9,4,12
	.byte	'FEE_ORDER_PENDING_E',0,0,12
	.byte	'FEE_ORDER_FINISHED_E',0,1,12
	.byte	'FEE_BLOCK_INVALIDATED_E',0,2,12
	.byte	'FEE_ERROR_E',0,3,12
	.byte	'FEE_SECTORCHANGE_E',0,4,12
	.byte	'FEE_SECTORFULL_E',0,5,12
	.byte	'FEE_ABORTED_E',0,6,12
	.byte	'FEE_ERASE_SECTOR_E',0,7,12
	.byte	'FEE_SEARCH_ABORTED_E',0,8,12
	.byte	'FEE_NUM_RET_VAL_E',0,9,0,9
	.byte	'Fee_LLWriteMarker',0,1,174,8,41
	.word	773
	.byte	1,1,1,1,4
	.byte	'PhySectIdx_u8',0,1,174,8,81
	.word	264
	.byte	4
	.byte	'MarkerID_u8',0,1,175,8,81
	.word	264
	.byte	0,13
	.byte	'Fee_LLEraseSector',0,1,178,8,41
	.word	773
	.byte	1,1,1,1,14
	.byte	'Fee_LLSetEraseSector',0,1,179,8,41,1,1,1,1,4
	.byte	'EraseLogIdx',0,1,179,8,84
	.word	264
	.byte	0,15,1,227,5,9,16,16
	.byte	'AdrBlkHeader_u32',0
	.word	156
	.byte	4,2,35,0,16
	.byte	'BlkCrc32_u32',0
	.word	156
	.byte	4,2,35,4,16
	.byte	'HdrCrc16_u16',0
	.word	242
	.byte	2,2,35,8,16
	.byte	'BlkLength_u16',0
	.word	242
	.byte	2,2,35,10,16
	.byte	'FeeIndex_u16',0
	.word	242
	.byte	2,2,35,12,16
	.byte	'BlkStatus_u8',0
	.word	264
	.byte	1,2,35,14,0,7
	.word	1144
	.byte	8
	.word	1288
	.byte	9
	.byte	'Fee_LLCalcBlkCrcInFlash',0,1,212,8,41
	.word	773
	.byte	1,1,1,1,4
	.byte	'HeaderInfo_pcst',0,1,212,8,129,1
	.word	1293
	.byte	0
.L145:
	.byte	8
	.word	1144
	.byte	14
	.byte	'Fee_LLPrepPageBufWithHdrDataStart',0,1,221,8,41,1,1,1,1,4
	.byte	'HeaderInfo_pst',0,1,221,8,137,1
	.word	1362
	.byte	0,14
	.byte	'Fee_LLPrepPageBufWithHdrDataEnd',0,1,222,8,41,1,1,1,1,4
	.byte	'HeaderInfo_pst',0,1,222,8,135,1
	.word	1362
	.byte	4
	.byte	'Data_pcu8',0,1,223,8,121
	.word	402
	.byte	4
	.byte	'BlkCrc32_u32',0,1,224,8,103
	.word	156
	.byte	0,8
	.word	156
	.byte	14
	.byte	'Fee_IncAddressInsideSector',0,1,129,9,41,1,1,1,1,4
	.byte	'Address_u32',0,1,129,9,108
	.word	1544
	.byte	4
	.byte	'numBytes_u16',0,1,130,9,89
	.word	242
	.byte	4
	.byte	'EnsurePageAlign_b',0,1,131,9,90
	.word	264
	.byte	0,9
	.byte	'Fee_LLCheckReorganizationNeed',0,1,134,9,41
	.word	773
	.byte	1,1,1,1,4
	.byte	'Threshold_u32',0,1,134,9,94
	.word	156
	.byte	4
	.byte	'DataLength_u16',0,1,135,9,94
	.word	242
	.byte	0,14
	.byte	'Fee_LLUpdateAddressInCache',0,1,163,9,31,1,1,1,1,4
	.byte	'FeeIdx_u16',0,1,163,9,81
	.word	242
	.byte	4
	.byte	'Addr_u32',0,1,164,9,81
	.word	156
	.byte	0,14
	.byte	'Fee_LLUpdateCacheStForSect',0,1,165,9,30,1,1,1,1,4
	.byte	'PhySecIdx_u8',0,1,165,9,79
	.word	264
	.byte	0,14
	.byte	'Fee_LLEraseCacheStForSect',0,1,166,9,30,1,1,1,1,4
	.byte	'PhySecIdx_u8',0,1,166,9,78
	.word	264
	.byte	0,8
	.word	264
	.byte	14
	.byte	'Fee_SrvMemSet8',0,1,191,9,30,1,1,1,1,4
	.byte	'xDest_pu8',0,1,191,9,84
	.word	1939
	.byte	4
	.byte	'xPattern_u32',0,1,192,9,66
	.word	156
	.byte	4
	.byte	'numBytes_u32',0,1,193,9,66
	.word	156
	.byte	0,14
	.byte	'Fee_SrvMemCopy8',0,1,194,9,30,1,1,1,1,4
	.byte	'xDest_pu8',0,1,194,9,85
	.word	1939
	.byte	4
	.byte	'xSrc_pcu8',0,1,195,9,87
	.word	402
	.byte	4
	.byte	'numBytes_u32',0,1,196,9,67
	.word	156
	.byte	0,10
	.byte	'Fee_CheckFlsJobResult',0,1,219,9,31,1,1,1,1,17
	.word	172
	.byte	18
	.word	199
	.byte	18
	.word	218
	.byte	5,0,17
	.word	281
	.byte	18
	.word	324
	.byte	18
	.word	346
	.byte	18
	.word	371
	.byte	6,19
	.word	172
	.byte	18
	.word	199
	.byte	18
	.word	218
	.byte	20
	.word	240
	.byte	0,5,0,0,9
	.byte	'Crc_CalculateCRC32',0,3,80,15
	.word	156
	.byte	1,1,1,1,4
	.byte	'Crc_DataPtr',0,3,80,47
	.word	402
	.byte	4
	.byte	'Crc_Length',0,3,80,67
	.word	156
	.byte	4
	.byte	'Crc_StartValue32',0,3,80,86
	.word	156
	.byte	4
	.byte	'Crc_IsFirstCall',0,3,81,42
	.word	264
	.byte	0,21,1,8
	.word	2331
	.byte	22
	.byte	'__codeptr',0,4,1,1
	.word	2333
	.byte	2
	.byte	'char',0,1,6,22
	.byte	'sint8',0,5,76,25
	.word	2356
	.byte	22
	.byte	'uint8',0,5,81,25
	.word	264
	.byte	22
	.byte	'uint16',0,5,91,25
	.word	242
	.byte	22
	.byte	'uint32',0,5,106,24
	.word	156
	.byte	2
	.byte	'unsigned long long int',0,8,7,22
	.byte	'uint64',0,5,111,30
	.word	2422
	.byte	22
	.byte	'boolean',0,5,127,25
	.word	264
	.byte	22
	.byte	'StatusType',0,6,191,1,27
	.word	264
	.byte	22
	.byte	'Std_ReturnType',0,6,199,1,15
	.word	264
	.byte	15,6,206,1,9,8,16
	.byte	'vendorID',0
	.word	242
	.byte	2,2,35,0,16
	.byte	'moduleID',0
	.word	242
	.byte	2,2,35,2,16
	.byte	'sw_major_version',0
	.word	264
	.byte	1,2,35,4,16
	.byte	'sw_minor_version',0
	.word	264
	.byte	1,2,35,5,16
	.byte	'sw_patch_version',0
	.word	264
	.byte	1,2,35,6,0,22
	.byte	'Std_VersionInfoType',0,6,213,1,3
	.word	2523
	.byte	15,7,93,9,8,16
	.byte	'Class',0
	.word	264
	.byte	1,2,35,0,16
	.byte	'TIN',0
	.word	264
	.byte	1,2,35,1,16
	.byte	'ReturnAddress',0
	.word	156
	.byte	4,2,35,4,0,22
	.byte	'OsTrapInfoType',0,7,97,3
	.word	2673
	.byte	23,68
	.word	156
	.byte	24,16,0,15,7,154,1,9,68,16
	.byte	'store',0
	.word	2753
	.byte	68,2,35,0,0,23,68
	.word	2762
	.byte	24,0,0,22
	.byte	'Os_JumpBufType',0,7,156,1,3
	.word	2784
	.byte	22
	.byte	'Os_StackTraceType',0,7,174,1,18
	.word	156
	.byte	15,7,175,1,9,8,16
	.byte	'sp',0
	.word	156
	.byte	4,2,35,0,16
	.byte	'ctx',0
	.word	156
	.byte	4,2,35,4,0,22
	.byte	'Os_StackValueType',0,7,175,1,63
	.word	2844
	.byte	22
	.byte	'Os_StackSizeType',0,7,176,1,27
	.word	2844
	.byte	25,1,1,8
	.word	2929
	.byte	22
	.byte	'Os_VoidVoidFunctionType',0,7,179,1,16
	.word	2932
	.byte	22
	.byte	'ApplicationType',0,7,193,1,23
	.word	264
	.byte	26
	.byte	'Os_ApplicationConfigurationType_s',0,7,198,1,16,2,16
	.byte	'app_id',0
	.word	264
	.byte	1,2,35,0,16
	.byte	'access',0
	.word	264
	.byte	1,2,35,1,0,22
	.byte	'Os_ApplicationConfigurationType',0,7,201,1,3
	.word	2995
	.byte	22
	.byte	'Os_CoreStateType',0,7,203,1,16
	.word	156
	.byte	22
	.byte	'AreaIdType',0,7,204,1,16
	.word	242
	.byte	22
	.byte	'Os_PeripheralAddressType',0,7,212,1,22
	.word	156
	.byte	22
	.byte	'TickType',0,7,221,1,22
	.word	156
	.byte	22
	.byte	'Os_StopwatchTickType',0,7,225,1,22
	.word	156
	.byte	22
	.byte	'Os_Lockable',0,7,234,1,18
	.word	1544
	.byte	22
	.byte	'CoreIdType',0,7,236,1,16
	.word	242
	.byte	22
	.byte	'SpinlockIdType',0,7,237,1,16
	.word	242
	.byte	11,7,239,1,9,4,12
	.byte	'TRYTOGETSPINLOCK_SUCCESS',0,0,12
	.byte	'TRYTOGETSPINLOCK_NOSUCCESS',0,1,0,22
	.byte	'TryToGetSpinlockType',0,7,239,1,74
	.word	3302
	.byte	11,7,174,2,9,4,12
	.byte	'APPLICATION_ACCESSIBLE',0,0,12
	.byte	'APPLICATION_RESTARTING',0,1,12
	.byte	'APPLICATION_TERMINATED',0,2,0,22
	.byte	'ApplicationStateType',0,7,174,2,92
	.word	3395
	.byte	27
	.byte	'void',0,8
	.word	3507
	.byte	28,1,1,29
	.word	264
	.byte	29
	.word	3513
	.byte	0,8
	.word	3518
	.byte	22
	.byte	'Os_FunctionEntryType',0,7,183,2,16
	.word	3532
	.byte	26
	.byte	'Os_MeterInfoType_s',0,7,193,2,16,48,16
	.byte	'elapsed',0
	.word	156
	.byte	4,2,35,0,16
	.byte	'previous',0
	.word	156
	.byte	4,2,35,4,16
	.byte	'max',0
	.word	156
	.byte	4,2,35,8,16
	.byte	'cumulative',0
	.word	156
	.byte	4,2,35,12,16
	.byte	'stackbase',0
	.word	2844
	.byte	8,2,35,16,16
	.byte	'stackusage',0
	.word	2844
	.byte	8,2,35,24,16
	.byte	'stackmax',0
	.word	2844
	.byte	8,2,35,32,16
	.byte	'stackbudget',0
	.word	2844
	.byte	8,2,35,40,0,22
	.byte	'Os_MeterInfoType',0,7,202,2,3
	.word	3567
	.byte	8
	.word	3567
	.byte	22
	.byte	'Os_MeterInfoRefType',0,7,203,2,50
	.word	3765
	.byte	22
	.byte	'EventMaskType',0,7,206,2,15
	.word	264
	.byte	22
	.byte	'Os_imaskType',0,7,211,2,16
	.word	156
	.byte	26
	.byte	'Os_ISRDynType_s',0,7,213,2,16,48,16
	.byte	'meter',0
	.word	3567
	.byte	48,2,35,0,0,22
	.byte	'Os_ISRDynType',0,7,215,2,3
	.word	3844
	.byte	8
	.word	3844
	.byte	7
	.word	3905
	.byte	26
	.byte	'Os_ISRType_s',0,7,216,2,16,24,16
	.byte	'entry_function',0
	.word	2937
	.byte	4,2,35,0,16
	.byte	'dynamic',0
	.word	3910
	.byte	4,2,35,4,16
	.byte	'imask',0
	.word	156
	.byte	4,2,35,8,16
	.byte	'stackbudget',0
	.word	2844
	.byte	8,2,35,12,16
	.byte	'access',0
	.word	264
	.byte	1,2,35,20,16
	.byte	'application',0
	.word	264
	.byte	1,2,35,21,0,22
	.byte	'Os_ISRType',0,7,223,2,3
	.word	3915
	.byte	8
	.word	2929
	.byte	7
	.word	3915
	.byte	8
	.word	4074
	.byte	22
	.byte	'ISRType',0,7,224,2,46
	.word	4079
	.byte	22
	.byte	'Os_bitmask',0,7,239,2,22
	.word	156
	.byte	22
	.byte	'Os_pset0Type',0,7,240,2,20
	.word	156
	.byte	22
	.byte	'Os_pset1Type',0,7,241,2,20
	.word	156
	.byte	22
	.byte	'Os_pset2Type',0,7,242,2,20
	.word	156
	.byte	30,7,243,2,9,4,16
	.byte	'p0',0
	.word	156
	.byte	4,2,35,0,16
	.byte	'p1',0
	.word	156
	.byte	4,2,35,0,16
	.byte	'p2',0
	.word	156
	.byte	4,2,35,0,0,22
	.byte	'Os_psetType',0,7,247,2,3
	.word	4187
	.byte	30,7,249,2,9,4,16
	.byte	't0',0
	.word	156
	.byte	4,2,35,0,16
	.byte	't1',0
	.word	156
	.byte	4,2,35,0,16
	.byte	't2',0
	.word	156
	.byte	4,2,35,0,0,22
	.byte	'Os_tpmaskType',0,7,253,2,3
	.word	4251
	.byte	22
	.byte	'Os_ActivationCountType',0,7,254,2,23
	.word	264
	.byte	26
	.byte	'Os_TaskDynType_s',0,7,128,3,16,120,16
	.byte	'terminate_jump_buf',0
	.word	2793
	.byte	68,2,35,0,16
	.byte	'meter',0
	.word	3567
	.byte	48,2,35,68,16
	.byte	'activation_count',0
	.word	264
	.byte	1,2,35,116,0,22
	.byte	'Os_TaskDynType',0,7,132,3,3
	.word	4349
	.byte	23,68
	.word	2762
	.byte	24,0,0,8
	.word	4349
	.byte	7
	.word	4475
	.byte	26
	.byte	'Os_TaskType_s',0,7,134,3,16,40,16
	.byte	'dynamic',0
	.word	4480
	.byte	4,2,35,0,16
	.byte	'entry_function',0
	.word	2937
	.byte	4,2,35,4,16
	.byte	'pset',0
	.word	4187
	.byte	4,2,35,8,16
	.byte	'base_tpmask',0
	.word	4251
	.byte	4,2,35,12,16
	.byte	'tpmask',0
	.word	4251
	.byte	4,2,35,16,16
	.byte	'core_id',0
	.word	242
	.byte	2,2,35,20,16
	.byte	'index',0
	.word	156
	.byte	4,2,35,24,16
	.byte	'stackbudget',0
	.word	2844
	.byte	8,2,35,28,16
	.byte	'activation_count',0
	.word	264
	.byte	1,2,35,36,16
	.byte	'access',0
	.word	264
	.byte	1,2,35,37,16
	.byte	'application',0
	.word	264
	.byte	1,2,35,38,0,22
	.byte	'Os_TaskType',0,7,146,3,3
	.word	4485
	.byte	7
	.word	4485
	.byte	8
	.word	4735
	.byte	22
	.byte	'TaskType',0,7,147,3,47
	.word	4740
	.byte	31
	.byte	'Os_TaskStateType',0,7,155,3,6,4,12
	.byte	'SUSPENDED',0,0,12
	.byte	'READY',0,1,12
	.byte	'WAITING',0,2,12
	.byte	'RUNNING',0,3,0,22
	.byte	'TaskStateType',0,7,156,3,31
	.word	4763
	.byte	30,7,167,3,3,4,16
	.byte	'tpmask',0
	.word	4251
	.byte	4,2,35,0,0,26
	.byte	'Os_ResourceDynType_s',0,7,166,3,16,4,16
	.byte	'saved_priority',0
	.word	4850
	.byte	4,2,35,0,0,22
	.byte	'Os_ResourceDynType',0,7,170,3,3
	.word	4873
	.byte	8
	.word	4873
	.byte	7
	.word	4953
	.byte	26
	.byte	'Os_ResourceType_s',0,7,171,3,16,12,16
	.byte	'dynamic',0
	.word	4958
	.byte	4,2,35,0,16
	.byte	'tpmask',0
	.word	4251
	.byte	4,2,35,4,16
	.byte	'access',0
	.word	264
	.byte	1,2,35,8,0,22
	.byte	'Os_ResourceType',0,7,175,3,3
	.word	4963
	.byte	15,7,181,3,9,12,16
	.byte	'maxallowedvalue',0
	.word	156
	.byte	4,2,35,0,16
	.byte	'ticksperbase',0
	.word	156
	.byte	4,2,35,4,16
	.byte	'mincycle',0
	.word	156
	.byte	4,2,35,8,0,22
	.byte	'AlarmBaseType',0,7,185,3,3
	.word	5062
	.byte	15,7,206,3,9,8,16
	.byte	'Running',0
	.word	264
	.byte	1,2,35,0,16
	.byte	'Pending',0
	.word	264
	.byte	1,2,35,1,16
	.byte	'Delay',0
	.word	156
	.byte	4,2,35,4,0,22
	.byte	'Os_CounterStatusType',0,7,210,3,3
	.word	5157
	.byte	32
	.word	264
	.byte	1,1,8
	.word	5243
	.byte	22
	.byte	'Os_CounterIncrAdvType',0,7,217,3,22
	.word	5250
	.byte	26
	.byte	's_swd',0,7,222,3,12,4,16
	.byte	'count',0
	.word	156
	.byte	4,2,35,0,0,30,7,221,3,3,4,16
	.byte	'sw',0
	.word	5286
	.byte	4,2,35,0,0,26
	.byte	'Os_CounterDynType_s',0,7,220,3,16,4,16
	.byte	'type_dependent',0
	.word	5314
	.byte	4,2,35,0,0,22
	.byte	'Os_CounterDynType',0,7,226,3,3
	.word	5333
	.byte	8
	.word	5333
	.byte	7
	.word	5411
	.byte	26
	.byte	'Os_CounterType_s',0,7,227,3,16,28,16
	.byte	'dynamic',0
	.word	5416
	.byte	4,2,35,0,16
	.byte	'advincr',0
	.word	5255
	.byte	4,2,35,4,16
	.byte	'base',0
	.word	5062
	.byte	12,2,35,8,16
	.byte	'core',0
	.word	3513
	.byte	4,2,35,20,16
	.byte	'access',0
	.word	264
	.byte	1,2,35,24,16
	.byte	'application',0
	.word	264
	.byte	1,2,35,25,0,22
	.byte	'Os_CounterType',0,7,234,3,3
	.word	5421
	.byte	8
	.word	5243
	.byte	7
	.word	5421
	.byte	8
	.word	5573
	.byte	22
	.byte	'CounterType',0,7,235,3,52
	.word	5578
	.byte	31
	.byte	'Os_ScheduleTableStatusType',0,7,240,3,6,4,12
	.byte	'SCHEDULETABLE_STOPPED',0,0,12
	.byte	'SCHEDULETABLE_NEXT',0,1,12
	.byte	'SCHEDULETABLE_WAITING',0,2,12
	.byte	'SCHEDULETABLE_RUNNING',0,3,12
	.byte	'SCHEDULETABLE_RUNNING_AND_SYNCHRONOUS',0,4,0,22
	.byte	'ScheduleTableStatusType',0,7,241,3,41
	.word	5604
	.byte	7
	.word	.L302-.L135
	.byte	8
	.word	5804
	.byte	22
	.byte	'ScheduleTableType',0,7,128,4,58
	.word	5809
	.byte	26
	.byte	'Os_ScheduleTableDynType_s',0,7,130,4,16,16,16
	.byte	'match',0
	.word	156
	.byte	4,2,35,0,16
	.byte	'next',0
	.word	5814
	.byte	4,2,35,4,16
	.byte	'state',0
	.word	5604
	.byte	4,2,35,8,16
	.byte	'config',0
	.word	242
	.byte	2,2,35,12,0,8
	.word	5841
	.byte	7
	.word	5934
.L302:
	.byte	26
	.byte	'Os_ScheduleTableType_s',0,7,247,3,16,16,16
	.byte	'dynamic',0
	.word	5939
	.byte	4,2,35,0,16
	.byte	'counter',0
	.word	5583
	.byte	4,2,35,4,16
	.byte	'repeat',0
	.word	264
	.byte	1,2,35,8,16
	.byte	'config',0
	.word	242
	.byte	2,2,35,10,16
	.byte	'initial',0
	.word	264
	.byte	1,2,35,12,16
	.byte	'access',0
	.word	264
	.byte	1,2,35,13,16
	.byte	'application',0
	.word	264
	.byte	1,2,35,14,0,22
	.byte	'Os_ScheduleTableType',0,7,255,3,3
	.word	5944
	.byte	7
	.word	5944
	.byte	8
	.word	6124
	.byte	7
	.word	5421
	.byte	8
	.word	6134
	.byte	33
	.word	3237
	.byte	33
	.word	4187
	.byte	33
	.word	4084
	.byte	33
	.word	4745
	.byte	33
	.word	4251
	.byte	33
	.word	264
	.byte	33
	.word	4745
	.byte	26
	.byte	'Os_ControlledCoreType_s',0,7,251,6,16,112,16
	.byte	'TrapInfo',0
	.word	2673
	.byte	8,2,35,0,16
	.byte	'lock_taskaccess',0
	.word	6144
	.byte	4,2,35,8,16
	.byte	'ReadyTasks',0
	.word	6149
	.byte	4,2,35,12,16
	.byte	'RunningISR',0
	.word	6154
	.byte	4,2,35,16,16
	.byte	'RunningTask',0
	.word	6159
	.byte	4,2,35,20,16
	.byte	'RunningTPMask',0
	.word	6164
	.byte	4,2,35,24,16
	.byte	'CurrentMeteredObject',0
	.word	3770
	.byte	4,2,35,28,16
	.byte	'IdleMeter',0
	.word	3567
	.byte	48,2,35,32,16
	.byte	'AppAccess',0
	.word	264
	.byte	1,2,35,80,16
	.byte	'AppOverride',0
	.word	6169
	.byte	1,2,35,81,16
	.byte	'GetStackValueAdjust',0
	.word	2844
	.byte	8,2,35,84,16
	.byte	'InErrorHook',0
	.word	264
	.byte	1,2,35,92,16
	.byte	'ChainTaskRef',0
	.word	6174
	.byte	4,2,35,96,16
	.byte	'GetStackUsageAdjust',0
	.word	2844
	.byte	8,2,35,100,16
	.byte	'InProtectionHook',0
	.word	264
	.byte	1,2,35,108,16
	.byte	'CoreIsActive',0
	.word	264
	.byte	1,2,35,109,16
	.byte	'InShutdownHook',0
	.word	264
	.byte	1,2,35,110,0,22
	.byte	'Os_ControlledCoreType',0,7,141,7,3
	.word	6179
	.byte	8
	.word	156
	.byte	7
	.word	3915
	.byte	8
	.word	6635
	.byte	7
	.word	4485
	.byte	8
	.word	6645
	.byte	8
	.word	3567
	.byte	26
	.byte	'Os_AnyCoreType_s',0,7,151,7,16,96,16
	.byte	'DisableAllImask',0
	.word	156
	.byte	4,2,35,0,16
	.byte	'SuspendAllImask',0
	.word	156
	.byte	4,2,35,4,16
	.byte	'SuspendOSImask',0
	.word	156
	.byte	4,2,35,8,16
	.byte	'DisableAllCount',0
	.word	156
	.byte	4,2,35,12,16
	.byte	'SuspendAllCount',0
	.word	156
	.byte	4,2,35,16,16
	.byte	'SuspendOSCount',0
	.word	156
	.byte	4,2,35,20,16
	.byte	'RestartJumpBuf',0
	.word	2793
	.byte	68,2,35,24,16
	.byte	'Restartable',0
	.word	264
	.byte	1,2,35,92,0,22
	.byte	'Os_AnyCoreType',0,7,160,7,3
	.word	6660
	.byte	22
	.byte	'unsigned_int',0,8,116,22
	.word	156
	.byte	11,9,31,9,4,12
	.byte	'MEMIF_JOB_OK',0,0,12
	.byte	'MEMIF_JOB_FAILED',0,1,12
	.byte	'MEMIF_JOB_PENDING',0,2,12
	.byte	'MEMIF_JOB_CANCELED',0,3,12
	.byte	'MEMIF_BLOCK_INCONSISTENT',0,4,12
	.byte	'MEMIF_BLOCK_INVALID',0,5,0,22
	.byte	'MemIf_JobResultType',0,9,39,2
	.word	6922
	.byte	11,9,41,9,4,12
	.byte	'MEMIF_MODE_SLOW',0,0,12
	.byte	'MEMIF_MODE_FAST',0,1,0,22
	.byte	'MemIf_ModeType',0,9,45,2
	.word	7080
	.byte	22
	.byte	'PduIdType',0,10,22,19
	.word	242
	.byte	22
	.byte	'PduLengthType',0,10,26,19
	.word	242
	.byte	11,11,113,9,4,12
	.byte	'TP_DATACONF',0,0,12
	.byte	'TP_DATARETRY',0,1,12
	.byte	'TP_CONFPENDING',0,2,0,22
	.byte	'TpDataStateType',0,11,118,3
	.word	7185
	.byte	22
	.byte	'Can_IdType',0,12,32,16
	.word	156
	.byte	22
	.byte	'Can_HwHandleType',0,12,43,16
	.word	242
	.byte	22
	.byte	'Can_TxObjPriorityClassType',0,13,219,3,16
	.word	156
	.byte	26
	.byte	'Can_TxHwObjectConfigType',0,13,231,3,16,8,16
	.byte	'MsgObjId',0
	.word	264
	.byte	1,2,35,0,16
	.byte	'HwControllerId',0
	.word	264
	.byte	1,2,35,1,16
	.byte	'TxObjPriorityClass',0
	.word	156
	.byte	4,2,35,4,0,22
	.byte	'Can_TxHwObjectConfigType',0,13,252,3,3
	.word	7341
	.byte	26
	.byte	'Can_RxHwObjectConfigType',0,13,129,4,16,12,16
	.byte	'MaskRef',0
	.word	156
	.byte	4,2,35,0,16
	.byte	'MsgId',0
	.word	156
	.byte	4,2,35,4,16
	.byte	'MsgObjId',0
	.word	264
	.byte	1,2,35,8,16
	.byte	'HwControllerId',0
	.word	264
	.byte	1,2,35,9,0,22
	.byte	'Can_RxHwObjectConfigType',0,13,147,4,3
	.word	7477
	.byte	23,4
	.word	264
	.byte	24,3,0,26
	.byte	'Can_ControllerMOMapConfigType',0,13,181,4,16,4,16
	.byte	'ControllerMOMap',0
	.word	7617
	.byte	4,2,35,0,0,22
	.byte	'Can_ControllerMOMapConfigType',0,13,184,4,3
	.word	7626
	.byte	26
	.byte	'Can_NPCRValueType',0,13,188,4,16,2,16
	.byte	'Can_NPCRValue',0
	.word	242
	.byte	2,2,35,0,0,22
	.byte	'Can_NPCRValueType',0,13,191,4,3
	.word	7727
	.byte	26
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,13,194,4,16,8,16
	.byte	'CanControllerBaudrate',0
	.word	156
	.byte	4,2,35,0,16
	.byte	'CanControllerBaudrateCfg',0
	.word	242
	.byte	2,2,35,4,0,22
	.byte	'Can_17_MCanP_ControllerBaudrateConfigType',0,13,198,4,3
	.word	7802
	.byte	7
	.word	7802
	.byte	8
	.word	7967
	.byte	26
	.byte	'Can_BaudrateConfigPtrType',0,13,201,4,16,4,16
	.byte	'Can_kBaudrateConfigPtr',0
	.word	7972
	.byte	4,2,35,0,0,22
	.byte	'Can_BaudrateConfigPtrType',0,13,204,4,3
	.word	7977
	.byte	26
	.byte	'Can_EventHandlingType',0,13,226,4,16,4,16
	.byte	'CanEventType',0
	.word	7617
	.byte	4,2,35,0,0,22
	.byte	'Can_EventHandlingType',0,13,229,4,3
	.word	8077
	.byte	22
	.byte	'Rte_TransformerErrorCode',0,14,130,1,15
	.word	264
	.byte	22
	.byte	'Rte_TransformerClass',0,14,131,1,15
	.word	264
	.byte	15,14,168,1,9,12,16
	.byte	'in',0
	.word	3513
	.byte	4,2,35,0,16
	.byte	'out',0
	.word	3513
	.byte	4,2,35,4,16
	.byte	'used',0
	.word	242
	.byte	2,2,35,8,16
	.byte	'lost_data',0
	.word	264
	.byte	1,2,35,10,0,22
	.byte	'Rte_QDynType',0,14,173,1,3
	.word	8223
	.byte	11,14,175,1,9,4,12
	.byte	'RTE_DRA',0,0,12
	.byte	'RTE_WOWP',0,1,12
	.byte	'RTE_TASK',0,2,12
	.byte	'RTE_ARE',0,3,12
	.byte	'RTE_EV',0,4,12
	.byte	'RTE_MSI',0,5,0,22
	.byte	'Rte_NotificationType',0,14,182,1,3
	.word	8310
	.byte	23,128,8
	.word	264
	.byte	24,255,7,0,22
	.byte	'Impl_NVM_DstPtrType_1024',0,15,50,15
	.word	8408
	.byte	22
	.byte	'CanIf_u32_impl',0,15,69,16
	.word	156
	.byte	22
	.byte	'CanIf_u16_impl',0,15,71,16
	.word	242
	.byte	22
	.byte	'CanIf_u8_impl',0,15,73,15
	.word	264
	.byte	22
	.byte	'CanIf_ControllerModeType_Enum_impl',0,15,88,15
	.word	264
	.byte	22
	.byte	'CanIf_PduModeType_Enum_impl',0,15,90,15
	.word	264
	.byte	15,15,92,9,2,16
	.byte	'DeviceMode',0
	.word	264
	.byte	1,2,35,0,16
	.byte	'ChannelMode',0
	.word	264
	.byte	1,2,35,1,0,22
	.byte	'CanIf_ControllerStateType_struct_impl',0,15,95,3
	.word	8599
	.byte	22
	.byte	'CanIf_NotifStatusType_Enum_impl',0,15,100,15
	.word	264
	.byte	22
	.byte	'CanSM_boolean_Impl',0,15,120,15
	.word	264
	.byte	22
	.byte	'CanSM_u8_Impl',0,15,123,15
	.word	264
	.byte	22
	.byte	'CanSM_BusOffRecoveryStateType_Enum_impl',0,15,128,1,15
	.word	264
	.byte	22
	.byte	'CanSM_NetworkModeStateType_Enum_impl',0,15,132,1,15
	.word	264
	.byte	22
	.byte	'CanSM_u16_Impl',0,15,136,1,16
	.word	242
	.byte	22
	.byte	'CanSM_TimerStateType_Enum_impl',0,15,138,1,15
	.word	264
	.byte	15,15,140,1,9,4,16
	.byte	'cntTick_u16',0
	.word	242
	.byte	2,2,35,0,16
	.byte	'stTimer',0
	.word	264
	.byte	1,2,35,2,0,22
	.byte	'CanSM_TimerConfig_tst_struct_impl',0,15,143,1,3
	.word	8940
	.byte	22
	.byte	'Com_impl_u16',0,15,154,1,16
	.word	242
	.byte	22
	.byte	'Com_impl_u8',0,15,157,1,15
	.word	264
	.byte	22
	.byte	'ComM_uint32_Impl',0,15,173,1,16
	.word	156
	.byte	22
	.byte	'ComM_uint16_Impl',0,15,175,1,16
	.word	242
	.byte	22
	.byte	'ComM_uint8_Impl',0,15,177,1,15
	.word	264
	.byte	22
	.byte	'ComM_bool_Impl',0,15,179,1,15
	.word	264
	.byte	15,15,181,1,9,24,16
	.byte	'ChannelState_e',0
	.word	156
	.byte	4,2,35,0,16
	.byte	'LightTimeoutCtr_u32',0
	.word	156
	.byte	4,2,35,4,16
	.byte	'MinFullComTimeoutCtr_u16',0
	.word	242
	.byte	2,2,35,8,16
	.byte	'ChannelMode_u8',0
	.word	264
	.byte	1,2,35,10,16
	.byte	'BusSmMode_u8',0
	.word	264
	.byte	1,2,35,11,16
	.byte	'UserRequestCtr_u8',0
	.word	264
	.byte	1,2,35,12,16
	.byte	'PassiveRequestState_u8',0
	.word	264
	.byte	1,2,35,13,16
	.byte	'PncRequestCtr_u8',0
	.word	264
	.byte	1,2,35,14,16
	.byte	'InhibitionReqStatus_u8',0
	.word	264
	.byte	1,2,35,15,16
	.byte	'NmNetworkRequestStatus_b',0
	.word	264
	.byte	1,2,35,16,16
	.byte	'DiagnosticRequestState_b',0
	.word	264
	.byte	1,2,35,17,16
	.byte	'CommunicationAllowed_b',0
	.word	264
	.byte	1,2,35,18,16
	.byte	'NmBusSleepIndicationStatus_b',0
	.word	264
	.byte	1,2,35,19,16
	.byte	'NmPrepareBusSleepIndicationStatus_b',0
	.word	264
	.byte	1,2,35,20,16
	.byte	'NmNetworkModeStatus_b',0
	.word	264
	.byte	1,2,35,21,0,22
	.byte	'ComM_ChannelStruct_Impl',0,15,197,1,3
	.word	9172
	.byte	15,15,206,1,9,10,16
	.byte	'WakeUpInhibitionCtr_u16',0
	.word	242
	.byte	2,2,35,0,16
	.byte	'LimitToNoComCtr_u16',0
	.word	242
	.byte	2,2,35,2,16
	.byte	'RequestedUserMode_t',0
	.word	264
	.byte	1,2,35,4,16
	.byte	'IndicatedUserMode_t',0
	.word	264
	.byte	1,2,35,5,16
	.byte	'numChannelsInFullCom_u8',0
	.word	264
	.byte	1,2,35,6,16
	.byte	'numChannelsInSilentCom_u8',0
	.word	264
	.byte	1,2,35,7,16
	.byte	'numChannelsInNoCom_u8',0
	.word	264
	.byte	1,2,35,8,0,22
	.byte	'ComM_UserStruct_Impl',0,15,214,1,3
	.word	9676
	.byte	22
	.byte	'Dcm_IOOperationResponseType',0,15,252,1,15
	.word	264
	.byte	22
	.byte	'Dcm_RequestDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspRequestRoutineResultsOutSignal_0PrimitivType',0
	.byte	15,138,2,15
	.word	264
	.byte	22
	.byte	'Dcm_StartDataIn_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineInSignalPrimitivType',0,15,146,2,15
	.word	264
	.byte	22
	.byte	'Dcm_StartDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStartRoutineOutSignalPrimitivType',0,15,150,2,15
	.word	264
	.byte	22
	.byte	'Dcm_StopDataOut_DcmDspRoutine_DriveVacuumPump_DcmDspStopRoutineOutSignalPrimitivType',0,15,154,2,15
	.word	264
	.byte	22
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockNative_1024_Type',0,15,243,3,34
	.word	8419
	.byte	23,128,8
	.word	264
	.byte	24,255,7,0,22
	.byte	'Rte_PimType_ASW_NVM_ASW_NVM_BlockRedundant_1024_Type',0,15,246,3,34
	.word	8419
	.byte	22
	.byte	'Fls_AddressType',0,2,171,3,16
	.word	156
	.byte	22
	.byte	'Fls_LengthType',0,2,173,3,16
	.word	156
	.byte	26
	.byte	'Fls_JobStartType',0,2,175,3,16,1,34
	.byte	'Reserved1',0,1
	.word	264
	.byte	1,7,2,35,0,34
	.byte	'Write',0,1
	.word	264
	.byte	1,6,2,35,0,34
	.byte	'Erase',0,1
	.word	264
	.byte	1,5,2,35,0,34
	.byte	'Read',0,1
	.word	264
	.byte	1,4,2,35,0,34
	.byte	'Compare',0,1
	.word	264
	.byte	1,3,2,35,0,34
	.byte	'Reserved2',0,1
	.word	264
	.byte	3,0,2,35,0,0,22
	.byte	'Fls_JobStartType',0,2,183,3,3
	.word	10543
	.byte	22
	.byte	'Fls_17_Pmu_Job_Type',0,2,187,3,15
	.word	264
	.byte	23,2
	.word	264
	.byte	24,1,0,26
	.byte	'Fls_17_Pmu_StateType',0,2,198,3,16,48,16
	.byte	'FlsReadAddress',0
	.word	156
	.byte	4,2,35,0,16
	.byte	'FlsWriteAddress',0
	.word	156
	.byte	4,2,35,4,16
	.byte	'FlsEraseTimeoutCycleCount',0
	.word	156
	.byte	4,2,35,8,16
	.byte	'FlsWriteTimeoutCycleCount',0
	.word	156
	.byte	4,2,35,12,16
	.byte	'FlsReadLength',0
	.word	156
	.byte	4,2,35,16,16
	.byte	'FlsWriteLength',0
	.word	156
	.byte	4,2,35,20,16
	.byte	'FlsReadBufferPtr',0
	.word	1939
	.byte	4,2,35,24,16
	.byte	'FlsWriteBufferPtr',0
	.word	402
	.byte	4,2,35,28,16
	.byte	'FlsJobResult',0
	.word	6922
	.byte	4,2,35,32,16
	.byte	'FlsMode',0
	.word	7080
	.byte	4,2,35,36,16
	.byte	'NotifCaller',0
	.word	264
	.byte	1,2,35,40,16
	.byte	'JobStarted',0
	.word	10543
	.byte	1,2,35,41,16
	.byte	'FlsJobType',0
	.word	10733
	.byte	2,2,35,42,16
	.byte	'FlsOper',0
	.word	264
	.byte	1,2,35,44,16
	.byte	'FlsTimeoutErr',0
	.word	264
	.byte	1,2,35,45,16
	.byte	'FlsTimeoutControl',0
	.word	264
	.byte	1,2,35,46,0,22
	.byte	'Fls_17_Pmu_StateType',0,2,130,4,3
	.word	10742
	.byte	22
	.byte	'Fls_NotifFunctionPtrType',0,2,137,4,16
	.word	2932
	.byte	7
	.word	156
	.byte	8
	.word	11220
	.byte	28,1,1,29
	.word	156
	.byte	29
	.word	156
	.byte	29
	.word	11225
	.byte	29
	.word	264
	.byte	0,8
	.word	11230
	.byte	22
	.byte	'Fls_WriteCmdPtrType',0,2,139,4,16
	.word	11254
	.byte	28,1,1,29
	.word	156
	.byte	0,8
	.word	11288
	.byte	22
	.byte	'Fls_EraseCmdPtrType',0,2,144,4,16
	.word	11297
	.byte	11,16,115,9,4,12
	.byte	'FEE_POLLING_MODE_E',0,0,12
	.byte	'FEE_NORMAL_MODE_E',0,1,0,22
	.byte	'Fee_stMainType',0,16,119,2
	.word	11331
	.byte	11,16,122,9,4,12
	.byte	'FEE_NO_ORDER',0,0,12
	.byte	'FEE_READ_ORDER',0,1,12
	.byte	'FEE_WRITE_ORDER',0,2,12
	.byte	'FEE_INVALIDATE_ORDER',0,3,12
	.byte	'FEE_MAINTAIN_ORDER',0,4,12
	.byte	'FEE_FORCED_READ_ORDER',0,5,0,22
	.byte	'Fee_HlMode_ten',0,16,132,1,2
	.word	11401
	.byte	35
	.byte	'Fee_stMain',0,16,203,1,39
	.word	11331
	.byte	1,1,11,1,147,1,9,4,12
	.byte	'FEE_NORMAL_PRIO_E',0,0,12
	.byte	'FEE_HIGH_PRIO_E',0,1,0,22
	.byte	'Fee_HlPriority_ten',0,1,151,1,2
	.word	11571
	.byte	15,1,165,1,9,24,16
	.byte	'DataBufferPtr_pu8',0
	.word	1939
	.byte	4,2,35,0,16
	.byte	'FeeIdx_u16',0
	.word	242
	.byte	2,2,35,4,16
	.byte	'BlockPropIdx_u16',0
	.word	242
	.byte	2,2,35,6,16
	.byte	'Offset_u16',0
	.word	242
	.byte	2,2,35,8,16
	.byte	'Length_u16',0
	.word	242
	.byte	2,2,35,10,16
	.byte	'Mode_en',0
	.word	11401
	.byte	4,2,35,12,16
	.byte	'Prio_en',0
	.word	11571
	.byte	4,2,35,16,16
	.byte	'SecLevel_u8',0
	.word	264
	.byte	1,2,35,20,0,22
	.byte	'Fee_OrderFifo_tst',0,1,175,1,2
	.word	11644
	.byte	11,1,246,1,9,4,12
	.byte	'FEE_SECTOR_STATE_UNDEF_E',0,0,12
	.byte	'FEE_SECTOR_ERASED_E',0,1,12
	.byte	'FEE_SECTOR_USED_E',0,2,12
	.byte	'FEE_SECTOR_FULL_E',0,3,12
	.byte	'FEE_SECTOR_REQUEST2ERASE_E',0,4,12
	.byte	'FEE_SECTOR_CONSIDERED_E',0,13,0,22
	.byte	'Fee_SectorState_ten',0,1,254,1,2
	.word	11846
	.byte	15,1,129,2,9,12,16
	.byte	'SecChngCnt_u32',0
	.word	156
	.byte	4,2,35,0,16
	.byte	'SecState_en',0
	.word	11846
	.byte	4,2,35,4,16
	.byte	'xPhySecIdx_u8',0
	.word	264
	.byte	1,2,35,8,0,22
	.byte	'Fee_LLSectorOrder_tst',0,1,134,2,2
	.word	12026
	.byte	22
	.byte	'Fee_stRetVal_ten',0,1,149,2,2
	.word	773
	.byte	15,1,153,2,9,16,16
	.byte	'Fee_PhysStartAddress_u32',0
	.word	156
	.byte	4,2,35,0,16
	.byte	'Fee_PhysEndAddress_u32',0
	.word	156
	.byte	4,2,35,4,16
	.byte	'Fee_LogStartAddress_u32',0
	.word	156
	.byte	4,2,35,8,16
	.byte	'Fee_LogEndAddress_u32',0
	.word	156
	.byte	4,2,35,12,0,22
	.byte	'Fee_FlashProp_tst',0,1,159,2,2
	.word	12158
	.byte	7
	.word	2932
	.byte	7
	.word	2932
	.byte	15,1,192,2,9,16,16
	.byte	'BlockPersistentId_u16',0
	.word	242
	.byte	2,2,35,0,16
	.byte	'Flags_u16',0
	.word	242
	.byte	2,2,35,2,16
	.byte	'Length_u16',0
	.word	242
	.byte	2,2,35,4,16
	.byte	'JobEndNotification_pfn',0
	.word	12322
	.byte	4,2,35,8,16
	.byte	'JobErrorNotification_pfn',0
	.word	12327
	.byte	4,2,35,12,0,22
	.byte	'Fee_BlockPropertiesType_tst',0,1,199,2,2
	.word	12332
	.byte	11,1,210,2,9,4,12
	.byte	'FEE_LL_MARKER_INIT_E',0,0,12
	.byte	'FEE_LL_MARKER_BLK_CHK_E',0,1,12
	.byte	'FEE_LL_MARKER_BLK_CHK_WAIT_E',0,2,12
	.byte	'FEE_LL_MARKER_BLK_CHK_ERROR_E',0,3,12
	.byte	'FEE_LL_MARKER_BLK_CHK_FINISHED_E',0,4,12
	.byte	'FEE_LL_MARKER_WRITE_WAIT_E',0,5,12
	.byte	'FEE_LL_MARKER_WRITE_ERROR_E',0,6,12
	.byte	'FEE_LL_MARKER_VERIFY_E',0,7,12
	.byte	'FEE_LL_MARKER_VERIFY_WAIT_E',0,8,12
	.byte	'FEE_LL_MARKER_VERIFY_FINISHED_E',0,9,0,22
	.byte	'Fee_LLWrMarkerType_ten',0,1,222,2,2
	.word	12512
	.byte	11,1,225,2,9,4,12
	.byte	'FEE_HL_RDWR_BLK_INIT_E',0,0,12
	.byte	'FEE_HL_SEARCH_BLK_HDR_E',0,1,12
	.byte	'FEE_HL_READ_BLK_HDR_WAIT_E',0,2,12
	.byte	'FEE_HL_CHECK_BLK_HDR_E',0,3,12
	.byte	'FEE_HL_CALC_BLK_CS_E',0,4,12
	.byte	'FEE_HL_CHECK_BLK_CS_E',0,5,12
	.byte	'FEE_HL_RD_DATA_FROM_BLK_E',0,6,12
	.byte	'FEE_HL_COMP_BLK_E',0,7,12
	.byte	'FEE_HL_WR_BLK_E',0,8,0,22
	.byte	'Fee_HLRdWrBlockType_ten',0,1,243,2,2
	.word	12846
	.byte	11,1,246,2,9,4,12
	.byte	'FEE_LL_WR_BLK_INIT_E',0,0,12
	.byte	'FEE_LL_WR_WRITEHEADER_E',0,1,12
	.byte	'FEE_LL_WR_SIZECHECK_HSR_E',0,2,12
	.byte	'FEE_LL_WR_WRITEHEADER_WAIT_E',0,3,12
	.byte	'FEE_LL_WR_VERIFYHEADER_E',0,4,12
	.byte	'FEE_LL_WR_VERIFYHEADER_WAIT_E',0,5,12
	.byte	'FEE_LL_WR_VERIFYHEADER_ERROR_E',0,6,12
	.byte	'FEE_LL_WR_WRITEDATA_SEC_A_E',0,7,12
	.byte	'FEE_LL_WR_WAIT_WRITEDATA_SEC_A_E',0,8,12
	.byte	'FEE_LL_WR_WRITE_ERROR_E',0,9,12
	.byte	'FEE_LL_WR_WRITE_FULL_MARKER_E',0,10,12
	.byte	'FEE_LL_WR_ERASE_SECTOR_E',0,11,12
	.byte	'FEE_LL_WR_WRITE_USED_MARKER_E',0,12,12
	.byte	'FEE_LL_WR_WRITE_START_MARKER_E',0,13,12
	.byte	'FEE_LL_WR_VERIFY_BLK_E',0,14,12
	.byte	'FEE_LL_WR_WRITEHDRPG2_E',0,15,12
	.byte	'FEE_LL_WR_WAIT_WRITEHDRPG2_E',0,16,0,22
	.byte	'Fee_LLWrBlockType_ten',0,1,162,3,2
	.word	13104
	.byte	11,1,165,3,9,4,12
	.byte	'FEE_LL_CMP_BLK_INIT_E',0,0,12
	.byte	'FEE_LL_CMP_HEADER_E',0,1,12
	.byte	'FEE_LL_CMP_WAIT_HEADER_E',0,2,12
	.byte	'FEE_LL_CMP_CHECK_OVERLAP_E',0,3,12
	.byte	'FEE_LL_CMP_DATA_SEC_A_E',0,4,12
	.byte	'FEE_LL_CMP_WAIT_DATA_SEC_A_E',0,5,12
	.byte	'FEE_LL_CMP_FINISHED_E',0,6,0,22
	.byte	'Fee_LLCmpBlkType_ten',0,1,174,3,2
	.word	13639
	.byte	11,1,177,3,9,4,12
	.byte	'FEE_LL_CPY_BLK_INIT_E',0,0,12
	.byte	'FEE_LL_CPY_BLOCK_START_E',0,1,12
	.byte	'FEE_LL_CPY_BLOCK_WAIT_E',0,2,12
	.byte	'FEE_LL_CPY_BLOCK_ERROR_E',0,3,12
	.byte	'FEE_LL_CPY_BLOCK_FINISHED_E',0,4,0,22
	.byte	'Fee_LLCpyBlkType_ten',0,1,184,3,2
	.word	13859
	.byte	11,1,187,3,9,4,12
	.byte	'FEE_LL_CRC_BLK_INIT_E',0,0,12
	.byte	'FEE_LL_CRC_RD_HD_PAGE_E',0,1,12
	.byte	'FEE_LL_CRC_RD_PAGE_E',0,2,12
	.byte	'FEE_LL_CRC_CHECK_OVERLAP_E',0,3,12
	.byte	'FEE_LL_CRC_RD_ROB_PAGE_E',0,4,12
	.byte	'FEE_LL_CRC_CHECK_OVERLAP_ROB_E',0,5,12
	.byte	'FEE_LL_CRC_RD_ROB_PAGE_WAIT_E',0,6,12
	.byte	'FEE_LL_CRC_RD_PAGE_WAIT_E',0,7,12
	.byte	'FEE_LL_CRC_RD_ERROR_E',0,8,0,22
	.byte	'Fee_LLCalcCrcBlkType_ten',0,1,200,3,2
	.word	14030
	.byte	11,1,203,3,9,4,12
	.byte	'FEE_LL_INIT_READ_E',0,0,12
	.byte	'FEE_LL_BLANK_CHECK_E',0,1,12
	.byte	'FEE_LL_BLANK_CHECK_WAIT_E',0,2,12
	.byte	'FEE_LL_READ_PAGE_E',0,3,12
	.byte	'FEE_LL_WAIT_READ_PAGE_E',0,4,12
	.byte	'FEE_LL_READ_ERROR_E',0,5,12
	.byte	'FEE_LL_READ_FINISHED_E',0,6,0,22
	.byte	'Fee_LLRdStateType_ten',0,1,223,3,3
	.word	14317
	.byte	11,1,226,3,9,4,12
	.byte	'FEE_LL_INIT_BLANK_CHECK_E',0,0,12
	.byte	'FEE_LL_PERFORM_BLANK_CHECK_E',0,1,12
	.byte	'FEE_LL_WAIT_PERFORM_BLANK_CHECK_E',0,2,12
	.byte	'FEE_LL_BLANK_CHECK_ERROR_E',0,3,12
	.byte	'FEE_LL_BLANK_CHECK_FINISHED_E',0,4,0,22
	.byte	'Fee_LLBlankCheckType_ten',0,1,233,3,3
	.word	14521
	.byte	11,1,236,3,9,4,12
	.byte	'FEE_LL_FIND_CURRENT_SECTOR_E',0,0,12
	.byte	'FEE_LL_FIND_LAST_HEADER_E',0,1,12
	.byte	'FEE_LL_FINISHED_E',0,2,0,22
	.byte	'Fee_LLFndEmptyPgeType_ten',0,1,249,3,2
	.word	14718
	.byte	11,1,252,3,9,4,12
	.byte	'FEE_LL_SEARCHBLK_INIT_E',0,0,12
	.byte	'FEE_LL_SEARCHBLK_BLK_HEADER_E',0,1,0,22
	.byte	'Fee_LLSearchBlkHdrType_ten',0,1,128,4,2
	.word	14839
	.byte	11,1,132,4,9,4,12
	.byte	'FEE_LL_BLD_UP_CACHE_INIT_E',0,0,12
	.byte	'FEE_LL_BLD_UP_CACHE_READ_E',0,1,0,22
	.byte	'Fee_LLBuildUpCache_ten',0,1,136,4,2
	.word	14940
	.byte	11,1,139,4,9,4,12
	.byte	'FEE_LL_BLD_UP_CACHE_ALL_SECT_INIT_E',0,0,12
	.byte	'FEE_LL_BLD_UP_CACHE_ALL_SECT_DO_E',0,1,0,22
	.byte	'Fee_LLBuildUpCacheAllSect_ten',0,1,143,4,2
	.word	15037
	.byte	11,1,168,4,9,4,12
	.byte	'FEE_LL_REORG_INIT_E',0,0,12
	.byte	'FEE_LL_REORG_PREP_SEARCH_BLK_E',0,1,12
	.byte	'FEE_LL_REORG_SEARCH_BLK_E',0,2,12
	.byte	'FEE_LL_REORG_CHECK_BLOCK_CS_E',0,3,12
	.byte	'FEE_LL_REORG_REDUNDANT_BLK_CHK_E',0,4,12
	.byte	'FEE_LL_REORG_WRITE_BLOCK_E',0,5,12
	.byte	'FEE_LL_REORG_FINISHED_E',0,6,0,22
	.byte	'Fee_LLSecReorgType_ten',0,1,193,4,2
	.word	15157
	.byte	11,1,196,4,9,4,12
	.byte	'FEE_LL_REDUNDANT_CPY_CHK_INIT_E',0,0,12
	.byte	'FEE_LL_REDUNDANT_CPY_CHK_SEARCH_HDR_E',0,1,12
	.byte	'FEE_LL_REDUNDANT_CPY_CHK_BLK_CS_E',0,2,0,22
	.byte	'Fee_LLRedundantCpyChk_ten',0,1,201,4,2
	.word	15401
	.byte	11,1,204,4,9,4,12
	.byte	'FEE_LL_CPY_FLS2FLS_INIT_E',0,0,12
	.byte	'FEE_LL_CPY_FLS2FLS_READ_E',0,1,12
	.byte	'FEE_LL_CPY_FLS2FLS_WAIT_READ_E',0,2,12
	.byte	'FEE_LL_CPY_FLS2FLS_READ_ERROR_E',0,3,12
	.byte	'FEE_LL_CPY_FLS2FLS_HDRPG1_WRITE_E',0,4,12
	.byte	'FEE_LL_CPY_FLS2FLS_WAIT_HDRPG1_WRITE_E',0,5,12
	.byte	'FEE_LL_CPY_FLS2FLS_HDRPG1_WRITE_ERROR_E',0,6,12
	.byte	'FEE_LL_CPY_FLS2FLS_HDRPG1_VERIFY_E',0,7,12
	.byte	'FEE_LL_CPY_FLS2FLS_WAIT_HDRPG1_VERIFY_E',0,8,12
	.byte	'FEE_LL_CPY_FLS2FLS_HDRPG1_VERIFY_ERROR_E',0,9,12
	.byte	'FEE_LL_CPY_FLS2FLS_WRITE_E',0,10,12
	.byte	'FEE_LL_CPY_FLS2FLS_WAIT_WRITE_E',0,11,12
	.byte	'FEE_LL_CPY_FLS2FLS_WRITE_ERROR_E',0,12,12
	.byte	'FEE_LL_CPY_FLS2FLS_VERIFY_E',0,13,12
	.byte	'FEE_LL_CPY_FLS2FLS_WAIT_VERIFY_E',0,14,12
	.byte	'FEE_LL_CPY_FLS2FLS_VERIFY_ERROR_E',0,15,12
	.byte	'FEE_LL_CPY_FLS2FLS_HDRPG2_WRITE_E',0,16,12
	.byte	'FEE_LL_CPY_FLS2FLS_WAIT_HDRPG2_WRITE_E',0,17,12
	.byte	'FEE_LL_CPY_FLS2FLS_HDRPG2_WRITE_ERROR_E',0,18,12
	.byte	'FEE_LL_CPY_FLS2FLS_HDRPG2_VERIFY_E',0,19,12
	.byte	'FEE_LL_CPY_FLS2FLS_WAIT_HDRPG2_VERIFY_E',0,20,12
	.byte	'FEE_LL_CPY_FLS2FLS_HDRPG2_VERIFY_ERROR_E',0,21,12
	.byte	'FEE_LL_CPY_FLS2FLS_CHECK_ADR_OVERFLOW_E',0,22,12
	.byte	'FEE_LL_CPY_FLS2FLS_WRITE_FULL_MARKER_E',0,23,12
	.byte	'FEE_LL_CPY_FLS2FLS_ERASE_SECTOR_E',0,24,12
	.byte	'FEE_LL_CPY_FLS2FLS_WRITE_USED_MARKER_E',0,25,12
	.byte	'FEE_LL_CPY_FLS2FLS_WRITE_START_MARKER_E',0,26,0,22
	.byte	'Fee_LLCpyBlkFls2Fls_ten',0,1,133,5,2
	.word	15553
	.byte	15,1,163,5,9,116,16
	.byte	'xRdAddress',0
	.word	156
	.byte	4,2,35,0,16
	.byte	'xWrAddress',0
	.word	156
	.byte	4,2,35,4,16
	.byte	'xCmpAddress',0
	.word	156
	.byte	4,2,35,8,16
	.byte	'xCrcAddress',0
	.word	156
	.byte	4,2,35,12,16
	.byte	'xCpyAddress',0
	.word	156
	.byte	4,2,35,16,16
	.byte	'AdrHdSearchStart_u32',0
	.word	156
	.byte	4,2,35,20,16
	.byte	'xStartAddrNextSector_u32',0
	.word	156
	.byte	4,2,35,24,16
	.byte	'xHdPg2Address',0
	.word	156
	.byte	4,2,35,28,16
	.byte	'LastProgrammedAddress_u32',0
	.word	156
	.byte	4,2,35,32,16
	.byte	'LastValidHdrAddress_u32',0
	.word	156
	.byte	4,2,35,36,16
	.byte	'Fee_LLSecReorg_en',0
	.word	15157
	.byte	4,2,35,40,16
	.byte	'Fee_LLRedundantCpyChk_en',0
	.word	15401
	.byte	4,2,35,44,16
	.byte	'Fee_LLCpyBlkFls2Fls_en',0
	.word	15553
	.byte	4,2,35,48,16
	.byte	'Fee_HLWrBlock_en',0
	.word	12846
	.byte	4,2,35,52,16
	.byte	'Fee_HLMtBlock_en',0
	.word	12846
	.byte	4,2,35,56,16
	.byte	'Fee_LLWrBlock_en',0
	.word	13104
	.byte	4,2,35,60,16
	.byte	'Fee_HLRdBlock',0
	.word	12846
	.byte	4,2,35,64,16
	.byte	'Fee_LLNextUsedWrBlock_en',0
	.word	13104
	.byte	4,2,35,68,16
	.byte	'Fee_LLNextEraseWrBlock_en',0
	.word	13104
	.byte	4,2,35,72,16
	.byte	'Fee_LLCompBlk',0
	.word	13639
	.byte	4,2,35,76,16
	.byte	'Fee_LLCopyBlk_en',0
	.word	13859
	.byte	4,2,35,80,16
	.byte	'Fee_LLCalcCrcBlk_en',0
	.word	14030
	.byte	4,2,35,84,16
	.byte	'Fee_LLWrMarker_en',0
	.word	12512
	.byte	4,2,35,88,16
	.byte	'Fee_LLRdState_en',0
	.word	14317
	.byte	4,2,35,92,16
	.byte	'Fee_LLBlankCheckState_en',0
	.word	14521
	.byte	4,2,35,96,16
	.byte	'Fee_LLFindEmptyPageState_en',0
	.word	14718
	.byte	4,2,35,100,16
	.byte	'Fee_LLSearchBlkHdr_en',0
	.word	14839
	.byte	4,2,35,104,16
	.byte	'Fee_LLBuildUpCache_en',0
	.word	14940
	.byte	4,2,35,108,16
	.byte	'Fee_LLBuildUpCacheAllSect_en',0
	.word	15037
	.byte	4,2,35,112,0,22
	.byte	'Fee_RdWrOrder_tst',0,1,224,5,3
	.word	16599
	.byte	22
	.byte	'Fee_GlobInfoLastRdHeader_tst',0,1,235,5,2
	.word	1144
	.byte	15,1,238,5,9,10,16
	.byte	'BytesAlrdyConsid_u16',0
	.word	242
	.byte	2,2,35,0,16
	.byte	'BytesAlrdyCompared_u16',0
	.word	242
	.byte	2,2,35,2,16
	.byte	'Bytes2Read_u16',0
	.word	242
	.byte	2,2,35,4,16
	.byte	'CompareResult_u8',0
	.word	264
	.byte	1,2,35,6,16
	.byte	'cntWriteRetry_u8',0
	.word	264
	.byte	1,2,35,7,16
	.byte	'cntCopies_u8',0
	.word	264
	.byte	1,2,35,8,0,22
	.byte	'Fee_GlobInfoWrBlock_tst',0,1,246,5,2
	.word	17494
	.byte	11,1,133,6,9,4,12
	.byte	'FEE_ERASESEC_IDLE_E',0,0,12
	.byte	'FEE_ERASESEC_CHECK_CACHE_E',0,1,12
	.byte	'FEE_ERASESEC_START_E',0,2,12
	.byte	'FEE_ERASESEC_DO_E',0,3,12
	.byte	'FEE_ERASESEC_WRITE_MARKER_E',0,4,12
	.byte	'FEE_ERASESEC_ERROR_E',0,5,0,22
	.byte	'Fee_LLEraseStateType_ten',0,1,141,6,2
	.word	17694
	.byte	23,3
	.word	264
	.byte	24,2,0,15,1,151,6,9,16,16
	.byte	'Preamble_au8',0
	.word	17882
	.byte	3,2,35,0,16
	.byte	'BlkStatus_u8',0
	.word	264
	.byte	1,2,35,3,16
	.byte	'FeeIndex_u16',0
	.word	242
	.byte	2,2,35,4,16
	.byte	'BlkLength_u16',0
	.word	242
	.byte	2,2,35,6,16
	.byte	'HdrCrc16_u16',0
	.word	242
	.byte	2,2,35,8,16
	.byte	'BlkCrc32_u32',0
	.word	156
	.byte	4,2,35,12,0,22
	.byte	'Fee_BlkHeader_tst',0,1,159,6,2
	.word	17891
	.byte	23,32
	.word	12158
	.byte	24,1,0,7
	.word	18058
	.byte	35
	.byte	'Fee_FlashProp_st',0,1,135,7,53
	.word	18067
	.byte	1,1,35
	.byte	'Fee_PageBytePtr_cpu8',0,1,143,7,53
	.word	1939
	.byte	1,1,35
	.byte	'Fee_RdWrOrder_st',0,1,144,7,53
	.word	16599
	.byte	1,1,23,24
	.word	12026
	.byte	24,1,0,35
	.byte	'Fee_LLSectorOrder_st',0,1,145,7,53
	.word	18160
	.byte	1,1,23,72
	.word	11644
	.byte	24,2,0,35
	.byte	'Fee_OrderFifo_st',0,1,147,7,53
	.word	18201
	.byte	1,1,35
	.byte	'Fee_GlobInfoLastRdHeader_st',0,1,148,7,53
	.word	1144
	.byte	1,1,35
	.byte	'Fee_GlobInfoWrBlock_st',0,1,149,7,53
	.word	17494
	.byte	1,1,7
	.word	1939
	.byte	35
	.byte	'Fee_DataBytePtr_cpu8',0,1,158,7,53
	.word	18311
	.byte	1,1,35
	.byte	'Fee_NumFlashBanksUsed_u8',0,1,166,7,53
	.word	264
	.byte	1,1,23,8
	.word	264
	.byte	24,7,0,35
	.byte	'Fee_hdr2Buffer_au8',0,1,171,7,30
	.word	18384
	.byte	1,1,35
	.byte	'Fee_idxLLSectorOrder_au8',0,1,192,7,53
	.word	10733
	.byte	1,1,35
	.byte	'Fee_idxActQueue_u8',0,1,193,7,53
	.word	264
	.byte	1,1,35
	.byte	'Fee_DataByteStartCrc_u32',0,1,215,7,53
	.word	156
	.byte	1,1,23,192,1
	.word	12332
	.byte	24,11,0,35
	.byte	'Fee_BlockProperties_st',0,1,237,7,53
	.word	18525
	.byte	1,1,0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L136:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,36,0,3,8,11,15,62,15,0,0,3,46,1,3,8,32,13,58,15,59,15
	.byte	57,15,73,19,54,15,39,12,0,0,4,5,0,3,8,58,15,59,15,57,15,73,19,0,0,5,11,0,0,0,6,11,1,0,0,7,38,0,73,19,0
	.byte	0,8,15,0,73,19,0,0,9,46,1,3,8,58,15,59,15,57,15,73,19,54,15,39,12,63,12,60,12,0,0,10,46,0,3,8,58,15,59
	.byte	15,57,15,54,15,39,12,63,12,60,12,0,0,11,4,1,58,15,59,15,57,15,11,15,0,0,12,40,0,3,8,28,13,0,0,13,46,0
	.byte	3,8,58,15,59,15,57,15,73,19,54,15,39,12,63,12,60,12,0,0,14,46,1,3,8,58,15,59,15,57,15,54,15,39,12,63,12
	.byte	60,12,0,0,15,19,1,58,15,59,15,57,15,11,15,0,0,16,13,0,3,8,73,19,11,15,56,9,0,0,17,46,1,49,19,0,0,18,5
	.byte	0,49,19,0,0,19,29,1,49,19,0,0,20,11,0,49,19,0,0,21,21,0,54,15,0,0,22,22,0,3,8,58,15,59,15,57,15,73,19
	.byte	0,0,23,1,1,11,15,73,19,0,0,24,33,0,47,15,0,0,25,21,0,54,15,39,12,0,0,26,19,1,3,8,58,15,59,15,57,15,11
	.byte	15,0,0,27,59,0,3,8,0,0,28,21,1,54,15,39,12,0,0,29,5,0,73,19,0,0,30,23,1,58,15,59,15,57,15,11,15,0,0,31
	.byte	4,1,3,8,58,15,59,15,57,15,11,15,0,0,32,21,0,73,19,54,15,39,12,0,0,33,53,0,73,19,0,0,34,13,0,3,8,11,15
	.byte	73,19,13,15,12,15,56,9,0,0,35,52,0,3,8,58,15,59,15,57,15,73,19,63,12,60,12,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L137:
	.word	.L304-.L303
.L303:
	.half	3
	.word	.L306-.L305
.L305:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_Prv.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Fls\\inc\\Fls_17_Pmu.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Crc\\Crc_32.h',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlWriteBlock.c',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Platform\\Platform_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Std_Types.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\RTOS_T\\Gen\\inc\\Os.h',0,0,0,0
	.byte	'.\\Integration\\TargetIntegration\\TC275\\Include\\Mcal_TcLib.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\MemIf\\api\\MemIf_Types.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Cfg.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\ComStack\\ComStack_Types.h',0,0,0,0
	.byte	'.\\Integration\\BSW\\Include\\Can_GeneralTypes.h',0,0,0,0
	.byte	'.\\Targets\\TC275\\MCAL\\MCAL_Modules\\Can_17_MCanP\\inc\\Can_17_MCanP.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte.h',0,0,0,0
	.byte	'.\\RTE\\gen\\Rte_Type.h',0,0,0,0
	.byte	'.\\BSW\\src\\BSW\\Gen\\Fee\\api\\Fee.h',0,0,0,0,0
.L306:
.L304:
	.sdecl	'.debug_info',debug,cluster('Fee_LLWriteBlock')
	.sect	'.debug_info'
.L138:
	.word	1216
	.half	3
	.word	.L139
	.byte	4,1
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlWriteBlock.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'C:\\Users\\HUR4HC\\Desktop\\Main_extract\\',0,12,1
	.word	.L141,.L140
	.byte	2
	.word	.L134
	.byte	3
	.byte	'Fee_LLWriteBlock',0,1,72,34
	.word	.L143
	.byte	1,1,1
	.word	.L133,.L144,.L132
	.byte	4
	.byte	'Info_ptr',0,1,72,113
	.word	.L145,.L146
	.byte	4
	.byte	'Data_pcu8',0,1,73,92
	.word	.L147,.L148
	.byte	5
	.word	.L133,.L144
	.byte	6
	.byte	'xRetVal_en',0,1,75,38
	.word	.L143,.L149
	.byte	6
	.byte	'xCompareRetVal_en',0,1,76,38
	.word	.L143,.L150
	.byte	6
	.byte	'xWrMarkerRetVal_en',0,1,77,38
	.word	.L143,.L151
	.byte	6
	.byte	'xErSectorRetVal_en',0,1,78,38
	.word	.L143,.L152
	.byte	6
	.byte	'xNumBytes_u16',0,1,80,38
	.word	.L153,.L154
	.byte	6
	.byte	'xTempNumBytes_u16',0,1,81,38
	.word	.L153,.L155
	.byte	6
	.byte	'xNumFreeBytes_u32',0,1,82,38
	.word	.L156,.L157
	.byte	6
	.byte	'xCnt_u8',0,1,83,38
	.word	.L158,.L159
	.byte	6
	.byte	'xCnt_u16',0,1,84,38
	.word	.L153,.L160
	.byte	6
	.byte	'xPhySectIdx_u8',0,1,85,38
	.word	.L158,.L161
	.byte	6
	.byte	'xLogSectIdx_u8',0,1,86,38
	.word	.L158,.L162
	.byte	6
	.byte	'xTempPadding',0,1,87,38
	.word	.L158,.L163
	.byte	6
	.byte	'i_u8',0,1,90,33
	.word	.L158,.L164
	.byte	6
	.byte	'xNumBytesCutOff_u16',0,1,91,33
	.word	.L153,.L165
	.byte	6
	.byte	'xCrcOffset_u8',0,1,92,33
	.word	.L158,.L166
	.byte	6
	.byte	'xNumCrcBytes_u8',0,1,93,33
	.word	.L158,.L167
	.byte	6
	.byte	'xBlkCrc32Tmp_u32',0,1,94,33
	.word	.L156,.L168
	.byte	7
	.byte	'xBlkCrc32Result_u32',0,1,95,33
	.word	.L156
	.byte	5,3
	.word	_999001_xBlkCrc32Result_u32
	.byte	7
	.byte	'xNumCrcBytesDone_u8',0,1,96,33
	.word	.L158
	.byte	5,3
	.word	_999002_xNumCrcBytesDone_u8
	.byte	7
	.byte	'cntProgrammedBytes_u32',0,1,99,19
	.word	.L156
	.byte	5,3
	.word	_999003_cntProgrammedBytes_u32
	.byte	6
	.byte	'tmpAddr_u32',0,1,100,12
	.word	.L156,.L169
	.byte	5
	.word	.L6,.L170
	.byte	6
	.byte	'neededSpace_u32',0,1,161,2,20
	.word	.L156,.L171
	.byte	5
	.word	.L172,.L48
	.byte	6
	.byte	'dataLen_u16',0,1,166,2,24
	.word	.L153,.L173
	.byte	6
	.byte	'blockPropIdx_u16',0,1,166,2,38
	.word	.L153,.L174
	.byte	6
	.byte	'noFbActive_b',0,1,167,2,25
	.word	.L158,.L175
	.byte	6
	.byte	'doubleSecActive_b',0,1,167,2,40
	.word	.L158,.L176
	.byte	8
	.word	.L177,.L178,.L47
	.byte	9
	.word	.L179,.L180
	.byte	9
	.word	.L181,.L182
	.byte	9
	.word	.L183,.L184
	.byte	10
	.word	.L185,.L186
	.byte	6
	.byte	'neededSpace_u32',0,2,172,11,12
	.word	.L156,.L189
	.byte	8
	.word	.L190,.L191,.L44
	.byte	9
	.word	.L192,.L193
	.byte	9
	.word	.L194,.L195
	.byte	11
	.word	.L196,.L191,.L44
	.byte	6
	.byte	'modValue_u32',0,2,142,11,12
	.word	.L156,.L197
	.byte	6
	.byte	'retVal_u32',0,2,142,11,26
	.word	.L156,.L198
	.byte	0,0,0,0,8
	.word	.L177,.L187,.L188
	.byte	9
	.word	.L179,.L180
	.byte	9
	.word	.L181,.L182
	.byte	9
	.word	.L183,.L184
	.byte	0,0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('Fee_LLWriteBlock')
	.sect	'.debug_abbrev'
.L139:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,73,16
	.byte	54,15,39,12,63,12,17,1,18,1,64,6,0,0,4,5,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,5,11,1,17,1,18,1,0,0,6
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,7,52,0,3,8,58,15,59,15,57,15,73,16,2,9,0,0,8,29,1,49,16,17,1
	.byte	18,1,0,0,9,5,0,49,16,2,6,0,0,10,11,1,49,16,85,6,0,0,11,11,1,49,16,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('Fee_LLWriteBlock')
	.sect	'.debug_line'
.L140:
	.word	.L308-.L307
.L307:
	.half	3
	.word	.L310-.L309
.L309:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_LlWriteBlock.c',0,0,0,0
	.byte	'BSW\\src\\BSW\\Gen\\Rba_FeeFs1\\src\\rba_FeeFs1_Prv.h',0,0,0,0,0
.L310:
	.byte	5,34,7,0,5,2
	.word	.L133
	.byte	3,199,0,1,5,57,9
	.half	.L202-.L133
	.byte	3,3,1,9
	.half	.L203-.L202
	.byte	3,12,1,5,12,9
	.half	.L204-.L203
	.byte	3,16,1,5,28,9
	.half	.L311-.L204
	.byte	1,5,5,9
	.half	.L312-.L311
	.byte	1,5,29,9
	.half	.L4-.L312
	.byte	3,6,1,5,58,9
	.half	.L207-.L4
	.byte	1,5,56,9
	.half	.L313-.L207
	.byte	1,5,29,9
	.half	.L314-.L313
	.byte	3,1,1,5,58,9
	.half	.L315-.L314
	.byte	1,5,56,9
	.half	.L316-.L315
	.byte	1,5,37,9
	.half	.L317-.L316
	.byte	3,3,1,5,62,9
	.half	.L206-.L317
	.byte	1,5,88,9
	.half	.L318-.L206
	.byte	1,5,98,9
	.half	.L205-.L318
	.byte	3,3,1,5,30,9
	.half	.L319-.L205
	.byte	1,5,54,9
	.half	.L320-.L319
	.byte	1,5,13,9
	.half	.L209-.L320
	.byte	3,4,1,5,35,9
	.half	.L321-.L209
	.byte	1,5,33,9
	.half	.L322-.L321
	.byte	1,5,13,9
	.half	.L323-.L322
	.byte	3,3,1,5,38,9
	.half	.L324-.L323
	.byte	1,5,36,9
	.half	.L325-.L324
	.byte	1,5,29,9
	.half	.L326-.L325
	.byte	3,4,1,5,46,9
	.half	.L327-.L326
	.byte	1,5,44,9
	.half	.L328-.L327
	.byte	1,5,20,9
	.half	.L329-.L328
	.byte	3,4,1,5,40,9
	.half	.L330-.L329
	.byte	1,5,56,9
	.half	.L331-.L330
	.byte	1,5,22,9
	.half	.L332-.L331
	.byte	3,11,1,9
	.half	.L333-.L332
	.byte	3,246,0,1,9
	.half	.L334-.L333
	.byte	3,130,127,1,9
	.half	.L335-.L334
	.byte	3,26,1,9
	.half	.L336-.L335
	.byte	3,111,1,9
	.half	.L337-.L336
	.byte	3,130,1,1,5,57,9
	.half	.L23-.L337
	.byte	3,248,126,1,5,55,9
	.half	.L338-.L23
	.byte	1,5,17,9
	.half	.L339-.L338
	.byte	3,2,1,5,42,9
	.half	.L25-.L339
	.byte	3,10,1,5,57,9
	.half	.L210-.L25
	.byte	3,3,1,5,55,9
	.half	.L340-.L210
	.byte	1,5,66,9
	.half	.L341-.L340
	.byte	3,3,1,5,64,9
	.half	.L342-.L341
	.byte	1,5,17,9
	.half	.L343-.L342
	.byte	3,2,1,5,35,9
	.half	.L24-.L343
	.byte	3,9,1,5,55,9
	.half	.L212-.L24
	.byte	3,20,1,5,42,9
	.half	.L344-.L212
	.byte	3,111,1,5,21,9
	.half	.L345-.L344
	.byte	1,5,62,7,9
	.half	.L346-.L345
	.byte	3,11,1,9
	.half	.L347-.L346
	.byte	3,3,1,5,78,9
	.half	.L348-.L347
	.byte	1,5,72,9
	.half	.L214-.L348
	.byte	3,3,1,5,71,9
	.half	.L215-.L214
	.byte	1,5,87,9
	.half	.L349-.L215
	.byte	1,5,53,9
	.half	.L350-.L349
	.byte	1,5,46,9
	.half	.L351-.L350
	.byte	3,3,1,5,61,9
	.half	.L213-.L351
	.byte	3,3,1,5,59,9
	.half	.L352-.L213
	.byte	1,5,70,9
	.half	.L353-.L352
	.byte	3,3,1,5,68,9
	.half	.L354-.L353
	.byte	1,5,69,9
	.half	.L355-.L354
	.byte	3,3,1,5,67,9
	.half	.L356-.L355
	.byte	1,5,37,9
	.half	.L357-.L356
	.byte	3,3,1,5,64,9
	.half	.L208-.L357
	.byte	1,5,29,9
	.half	.L32-.L208
	.byte	3,3,1,5,74,9
	.half	.L358-.L32
	.byte	3,125,1,5,64,9
	.half	.L31-.L358
	.byte	1,5,36,7,9
	.half	.L359-.L31
	.byte	3,7,1,5,67,9
	.half	.L216-.L359
	.byte	1,5,55,9
	.half	.L34-.L216
	.byte	3,3,1,5,76,9
	.half	.L219-.L34
	.byte	3,125,1,5,48,9
	.half	.L33-.L219
	.byte	1,5,67,9
	.half	.L360-.L33
	.byte	1,7,9
	.half	.L361-.L360
	.byte	1,5,62,9
	.half	.L30-.L361
	.byte	3,15,1,5,78,9
	.half	.L362-.L30
	.byte	1,5,72,9
	.half	.L221-.L362
	.byte	3,3,1,5,71,9
	.half	.L222-.L221
	.byte	1,5,87,9
	.half	.L363-.L222
	.byte	1,5,53,9
	.half	.L364-.L363
	.byte	1,5,64,9
	.half	.L365-.L364
	.byte	3,3,1,5,25,9
	.half	.L366-.L365
	.byte	1,5,65,7,9
	.half	.L367-.L366
	.byte	3,5,1,5,63,9
	.half	.L368-.L367
	.byte	1,5,73,9
	.half	.L369-.L368
	.byte	3,3,1,5,71,9
	.half	.L370-.L369
	.byte	1,5,94,9
	.half	.L371-.L370
	.byte	3,125,1,5,50,9
	.half	.L36-.L371
	.byte	3,10,1,5,65,9
	.half	.L220-.L36
	.byte	3,3,1,5,63,9
	.half	.L372-.L220
	.byte	1,5,74,9
	.half	.L373-.L372
	.byte	3,3,1,5,72,9
	.half	.L374-.L373
	.byte	1,5,73,9
	.half	.L375-.L374
	.byte	3,3,1,5,71,9
	.half	.L376-.L375
	.byte	1,5,17,9
	.half	.L35-.L376
	.byte	3,4,1,5,57,9
	.half	.L22-.L35
	.byte	3,8,1,5,55,9
	.half	.L377-.L22
	.byte	1,5,65,9
	.half	.L378-.L377
	.byte	3,3,1,5,63,9
	.half	.L379-.L378
	.byte	1,5,17,9
	.half	.L380-.L379
	.byte	3,2,1,5,32,9
	.half	.L27-.L380
	.byte	3,7,1,5,17,9
	.half	.L381-.L27
	.byte	3,2,1,5,9,9
	.half	.L28-.L381
	.byte	3,3,1,5,16,9
	.half	.L6-.L28
	.byte	3,10,1,5,38,9
	.half	.L382-.L6
	.byte	1,5,13,9
	.half	.L383-.L382
	.byte	1,5,39,7,9
	.half	.L172-.L383
	.byte	3,6,1,5,53,9
	.half	.L224-.L172
	.byte	3,2,1,5,52,9
	.half	.L384-.L224
	.byte	1,5,36,9
	.half	.L385-.L384
	.byte	1,5,52,9
	.half	.L386-.L385
	.byte	1,5,72,9
	.half	.L387-.L386
	.byte	1,5,61,9
	.half	.L226-.L387
	.byte	3,2,1,5,38,9
	.half	.L227-.L226
	.byte	1,5,60,9
	.half	.L388-.L227
	.byte	1,5,78,9
	.half	.L389-.L388
	.byte	1,5,89,9
	.half	.L390-.L389
	.byte	1,5,115,9
	.half	.L391-.L390
	.byte	1,5,34,9
	.half	.L228-.L391
	.byte	3,5,1,4,2,5,50,9
	.half	.L178-.L228
	.byte	3,252,8,1,5,64,9
	.half	.L225-.L178
	.byte	3,5,1,5,30,9
	.half	.L191-.L225
	.byte	3,94,1,5,5,9
	.half	.L229-.L191
	.byte	3,2,1,5,36,7,9
	.half	.L392-.L229
	.byte	3,2,1,5,20,9
	.half	.L393-.L392
	.byte	1,5,5,9
	.half	.L43-.L393
	.byte	3,3,1,5,25,9
	.half	.L44-.L43
	.byte	3,35,1,5,5,9
	.half	.L45-.L44
	.byte	3,5,1,5,9,7,9
	.half	.L394-.L45
	.byte	3,2,1,5,5,9
	.half	.L46-.L394
	.byte	3,3,1,4,1,5,50,9
	.half	.L47-.L46
	.byte	3,244,118,1,5,90,9
	.half	.L187-.L47
	.byte	1,5,17,9
	.half	.L223-.L187
	.byte	1,5,32,9
	.half	.L395-.L223
	.byte	3,7,1,5,17,9
	.half	.L48-.L395
	.byte	3,121,1,5,53,9
	.half	.L49-.L48
	.byte	3,26,1,5,51,9
	.half	.L396-.L49
	.byte	1,5,10,9
	.half	.L170-.L396
	.byte	3,4,1,5,27,9
	.half	.L5-.L170
	.byte	3,138,1,1,5,55,9
	.half	.L231-.L5
	.byte	3,43,1,5,13,9
	.half	.L230-.L231
	.byte	1,5,29,7,9
	.half	.L397-.L230
	.byte	3,242,124,1,5,30,9
	.half	.L398-.L397
	.byte	3,147,3,1,5,17,9
	.half	.L399-.L398
	.byte	1,5,70,7,9
	.half	.L400-.L399
	.byte	3,4,1,5,82,9
	.half	.L401-.L400
	.byte	1,5,52,9
	.half	.L402-.L401
	.byte	1,5,37,9
	.half	.L403-.L402
	.byte	3,3,1,5,57,9
	.half	.L404-.L403
	.byte	1,5,77,9
	.half	.L405-.L404
	.byte	1,5,92,9
	.half	.L406-.L405
	.byte	1,5,39,9
	.half	.L407-.L406
	.byte	3,3,1,5,96,9
	.half	.L233-.L407
	.byte	3,122,1,5,39,9
	.half	.L52-.L233
	.byte	3,11,1,5,54,9
	.half	.L234-.L52
	.byte	3,3,1,5,52,9
	.half	.L408-.L234
	.byte	1,5,20,9
	.half	.L53-.L408
	.byte	3,6,1,5,17,9
	.half	.L235-.L53
	.byte	1,5,21,7,9
	.half	.L409-.L235
	.byte	3,2,1,5,44,9
	.half	.L410-.L409
	.byte	1,5,66,9
	.half	.L411-.L410
	.byte	3,3,1,5,48,9
	.half	.L412-.L411
	.byte	1,5,56,9
	.half	.L413-.L412
	.byte	3,3,1,5,72,9
	.half	.L414-.L413
	.byte	1,5,93,9
	.half	.L415-.L414
	.byte	3,4,1,5,57,9
	.half	.L237-.L415
	.byte	3,3,1,5,55,9
	.half	.L232-.L237
	.byte	1,5,60,9
	.half	.L416-.L232
	.byte	3,115,1,5,32,9
	.half	.L54-.L416
	.byte	3,18,1,5,17,9
	.half	.L55-.L54
	.byte	3,125,1,5,53,9
	.half	.L51-.L55
	.byte	3,13,1,5,51,9
	.half	.L238-.L51
	.byte	1,5,33,9
	.half	.L417-.L238
	.byte	3,3,1,5,61,9
	.half	.L418-.L417
	.byte	1,5,59,9
	.half	.L419-.L418
	.byte	1,5,9,9
	.half	.L56-.L419
	.byte	3,3,1,5,17,9
	.half	.L20-.L56
	.byte	3,26,1,5,13,9
	.half	.L420-.L20
	.byte	1,5,17,7,9
	.half	.L421-.L420
	.byte	3,3,1,5,34,9
	.half	.L58-.L421
	.byte	3,5,1,5,9,9
	.half	.L422-.L58
	.byte	3,3,1,5,33,9
	.half	.L8-.L422
	.byte	3,7,1,5,13,9
	.half	.L423-.L8
	.byte	1,5,35,9
	.half	.L424-.L423
	.byte	3,3,1,5,49,9
	.half	.L239-.L424
	.byte	1,5,35,9
	.half	.L60-.L239
	.byte	3,6,1,5,17,9
	.half	.L61-.L60
	.byte	3,4,1,5,13,9
	.half	.L240-.L61
	.byte	1,5,28,7,9
	.half	.L425-.L240
	.byte	3,5,1,5,43,9
	.half	.L426-.L425
	.byte	1,5,53,9
	.half	.L62-.L426
	.byte	3,5,1,5,51,9
	.half	.L427-.L62
	.byte	1,5,9,9
	.half	.L63-.L427
	.byte	3,3,1,5,28,9
	.half	.L13-.L63
	.byte	3,15,1,5,9,9
	.half	.L428-.L13
	.byte	3,3,1,5,23,9
	.half	.L10-.L428
	.byte	3,10,1,5,9,9
	.half	.L429-.L10
	.byte	3,2,1,5,64,9
	.half	.L11-.L429
	.byte	3,7,1,5,46,9
	.half	.L430-.L11
	.byte	1,5,86,9
	.half	.L431-.L430
	.byte	1,5,62,9
	.half	.L432-.L431
	.byte	1,5,29,9
	.half	.L433-.L432
	.byte	1,5,13,9
	.half	.L245-.L433
	.byte	3,3,1,5,53,7,9
	.half	.L434-.L245
	.byte	3,3,1,5,51,9
	.half	.L435-.L434
	.byte	1,5,75,9
	.half	.L436-.L435
	.byte	1,5,76,9
	.half	.L67-.L436
	.byte	3,5,1,5,17,9
	.half	.L244-.L67
	.byte	3,3,1,5,21,7,9
	.half	.L437-.L244
	.byte	3,3,1,5,41,7,9
	.half	.L438-.L437
	.byte	3,3,1,5,24,9
	.half	.L70-.L438
	.byte	3,5,1,5,21,9
	.half	.L439-.L70
	.byte	1,5,39,9
	.half	.L440-.L439
	.byte	3,3,1,5,25,9
	.half	.L71-.L440
	.byte	3,4,1,5,21,9
	.half	.L441-.L71
	.byte	1,5,62,7,9
	.half	.L442-.L441
	.byte	3,3,1,5,111,9
	.half	.L72-.L442
	.byte	3,4,1,5,45,9
	.half	.L243-.L72
	.byte	1,5,70,9
	.half	.L443-.L243
	.byte	1,5,111,9
	.half	.L444-.L443
	.byte	1,5,21,9
	.half	.L246-.L444
	.byte	3,4,1,5,43,9
	.half	.L445-.L246
	.byte	1,5,41,9
	.half	.L446-.L445
	.byte	1,5,101,9
	.half	.L447-.L446
	.byte	3,3,1,5,61,9
	.half	.L448-.L447
	.byte	1,5,77,9
	.half	.L449-.L448
	.byte	1,5,124,9
	.half	.L450-.L449
	.byte	1,5,43,9
	.half	.L451-.L450
	.byte	1,5,67,9
	.half	.L247-.L451
	.byte	3,3,1,5,66,9
	.half	.L452-.L247
	.byte	1,5,50,9
	.half	.L453-.L452
	.byte	1,5,66,9
	.half	.L454-.L453
	.byte	1,5,86,9
	.half	.L455-.L454
	.byte	1,5,27,9
	.half	.L456-.L455
	.byte	1,5,49,9
	.half	.L457-.L456
	.byte	1,5,104,9
	.half	.L458-.L457
	.byte	1,5,115,9
	.half	.L459-.L458
	.byte	1,5,61,9
	.half	.L460-.L459
	.byte	3,1,1,5,21,9
	.half	.L461-.L460
	.byte	3,127,1,5,25,7,9
	.half	.L462-.L461
	.byte	3,5,1,5,29,7,9
	.half	.L463-.L462
	.byte	3,14,1,5,47,7,9
	.half	.L464-.L463
	.byte	3,3,1,5,50,9
	.half	.L249-.L464
	.byte	1,5,78,9
	.half	.L75-.L249
	.byte	3,5,1,5,49,9
	.half	.L465-.L75
	.byte	1,5,29,9
	.half	.L76-.L465
	.byte	3,5,1,5,49,7,9
	.half	.L466-.L76
	.byte	3,4,1,5,52,9
	.half	.L250-.L466
	.byte	1,5,36,9
	.half	.L77-.L250
	.byte	3,5,1,5,81,7,9
	.half	.L467-.L77
	.byte	1,5,53,7,9
	.half	.L468-.L467
	.byte	3,3,1,5,77,9
	.half	.L251-.L468
	.byte	1,5,84,9
	.half	.L79-.L251
	.byte	3,5,1,5,29,9
	.half	.L78-.L79
	.byte	3,5,1,5,64,7,9
	.half	.L469-.L78
	.byte	3,5,1,5,58,9
	.half	.L470-.L469
	.byte	3,126,1,5,59,9
	.half	.L471-.L470
	.byte	3,1,1,5,64,9
	.half	.L472-.L471
	.byte	3,1,1,5,70,9
	.half	.L248-.L472
	.byte	3,6,1,5,72,9
	.half	.L473-.L248
	.byte	3,125,1,5,70,9
	.half	.L474-.L473
	.byte	3,3,1,9
	.half	.L475-.L474
	.byte	3,1,1,5,53,9
	.half	.L253-.L475
	.byte	3,3,1,9
	.half	.L476-.L253
	.byte	3,3,1,5,37,9
	.half	.L82-.L476
	.byte	3,4,1,5,61,9
	.half	.L254-.L82
	.byte	1,5,76,9
	.half	.L84-.L254
	.byte	3,4,1,5,33,9
	.half	.L477-.L84
	.byte	3,127,1,5,54,9
	.half	.L478-.L477
	.byte	1,5,74,9
	.half	.L479-.L478
	.byte	1,5,53,9
	.half	.L480-.L479
	.byte	1,5,76,9
	.half	.L481-.L480
	.byte	3,1,1,5,107,9
	.half	.L482-.L481
	.byte	1,5,104,9
	.half	.L483-.L482
	.byte	1,5,119,9
	.half	.L484-.L483
	.byte	1,5,116,9
	.half	.L485-.L484
	.byte	1,5,96,9
	.half	.L486-.L485
	.byte	1,5,82,9
	.half	.L487-.L486
	.byte	3,127,1,5,67,9
	.half	.L488-.L487
	.byte	3,125,1,5,61,9
	.half	.L83-.L488
	.byte	1,7,9
	.half	.L489-.L83
	.byte	1,5,54,9
	.half	.L74-.L489
	.byte	3,10,1,5,55,9
	.half	.L490-.L74
	.byte	3,1,1,5,45,9
	.half	.L491-.L490
	.byte	3,1,1,5,67,9
	.half	.L256-.L491
	.byte	3,5,1,5,68,9
	.half	.L492-.L256
	.byte	3,126,1,5,67,9
	.half	.L493-.L492
	.byte	3,2,1,9
	.half	.L494-.L493
	.byte	3,1,1,5,49,9
	.half	.L261-.L494
	.byte	3,3,1,5,25,9
	.half	.L85-.L261
	.byte	3,114,1,5,50,9
	.half	.L73-.L85
	.byte	3,21,1,5,51,9
	.half	.L495-.L73
	.byte	3,1,1,5,41,9
	.half	.L496-.L495
	.byte	3,1,1,5,24,9
	.half	.L86-.L496
	.byte	3,4,1,5,21,9
	.half	.L497-.L86
	.byte	1,5,25,7,9
	.half	.L498-.L497
	.byte	3,2,1,5,48,9
	.half	.L499-.L498
	.byte	1,5,102,9
	.half	.L500-.L499
	.byte	3,3,1,5,124,9
	.half	.L501-.L500
	.byte	1,5,69,9
	.half	.L502-.L501
	.byte	1,5,97,9
	.half	.L503-.L502
	.byte	3,5,1,5,61,9
	.half	.L265-.L503
	.byte	3,3,1,5,59,9
	.half	.L504-.L265
	.byte	1,5,64,9
	.half	.L505-.L504
	.byte	3,117,1,5,36,9
	.half	.L87-.L505
	.byte	3,16,1,5,21,9
	.half	.L88-.L87
	.byte	3,125,1,5,57,9
	.half	.L69-.L88
	.byte	3,11,1,5,55,9
	.half	.L506-.L69
	.byte	1,5,37,9
	.half	.L507-.L506
	.byte	3,3,1,5,65,9
	.half	.L508-.L507
	.byte	1,5,63,9
	.half	.L509-.L508
	.byte	1,5,9,9
	.half	.L68-.L509
	.byte	3,4,1,5,73,9
	.half	.L14-.L68
	.byte	3,6,1,5,28,9
	.half	.L266-.L14
	.byte	1,5,50,9
	.half	.L270-.L266
	.byte	3,3,1,5,13,9
	.half	.L272-.L270
	.byte	1,5,42,7,9
	.half	.L510-.L272
	.byte	3,10,1,5,66,9
	.half	.L511-.L510
	.byte	1,5,83,9
	.half	.L271-.L511
	.byte	1,5,34,9
	.half	.L512-.L271
	.byte	1,5,39,9
	.half	.L273-.L512
	.byte	3,3,1,5,17,9
	.half	.L513-.L273
	.byte	1,5,57,7,9
	.half	.L514-.L513
	.byte	3,3,1,5,34,9
	.half	.L92-.L514
	.byte	3,4,1,5,54,9
	.half	.L515-.L92
	.byte	1,5,70,9
	.half	.L516-.L515
	.byte	1,5,55,9
	.half	.L268-.L516
	.byte	3,164,122,1,5,57,9
	.half	.L517-.L268
	.byte	3,223,5,1,5,20,9
	.half	.L518-.L517
	.byte	1,5,70,7,9
	.half	.L519-.L518
	.byte	3,1,1,5,42,7,9
	.half	.L93-.L519
	.byte	3,3,1,5,68,9
	.half	.L274-.L93
	.byte	3,3,1,5,67,9
	.half	.L275-.L274
	.byte	1,5,83,9
	.half	.L520-.L275
	.byte	1,5,49,9
	.half	.L521-.L520
	.byte	1,5,57,9
	.half	.L522-.L521
	.byte	3,3,1,5,55,9
	.half	.L523-.L522
	.byte	1,5,37,9
	.half	.L524-.L523
	.byte	3,3,1,5,66,9
	.half	.L525-.L524
	.byte	1,5,64,9
	.half	.L526-.L525
	.byte	1,5,57,9
	.half	.L527-.L526
	.byte	3,119,1,5,68,9
	.half	.L94-.L527
	.byte	3,16,1,5,67,9
	.half	.L276-.L94
	.byte	1,5,83,9
	.half	.L528-.L276
	.byte	1,5,49,9
	.half	.L529-.L528
	.byte	1,5,57,9
	.half	.L530-.L529
	.byte	3,3,1,5,55,9
	.half	.L531-.L530
	.byte	1,5,9,9
	.half	.L91-.L531
	.byte	3,4,1,5,51,9
	.half	.L15-.L91
	.byte	3,6,1,5,13,9
	.half	.L277-.L15
	.byte	3,3,1,5,20,7,9
	.half	.L532-.L277
	.byte	3,5,1,5,79,7,9
	.half	.L533-.L532
	.byte	1,5,32,7,9
	.half	.L98-.L533
	.byte	3,5,1,5,45,9
	.half	.L534-.L98
	.byte	1,5,73,9
	.half	.L99-.L534
	.byte	3,5,1,5,55,9
	.half	.L535-.L99
	.byte	1,5,9,9
	.half	.L97-.L535
	.byte	3,4,1,5,73,9
	.half	.L16-.L97
	.byte	3,6,1,5,28,9
	.half	.L278-.L16
	.byte	1,5,40,9
	.half	.L280-.L278
	.byte	3,3,1,5,68,9
	.half	.L282-.L280
	.byte	3,3,1,5,13,9
	.half	.L284-.L282
	.byte	3,3,1,5,17,7,9
	.half	.L536-.L284
	.byte	3,6,1,5,35,7,9
	.half	.L537-.L536
	.byte	3,4,1,5,52,9
	.half	.L538-.L537
	.byte	1,5,51,9
	.half	.L281-.L538
	.byte	1,5,67,9
	.half	.L539-.L281
	.byte	1,5,25,9
	.half	.L286-.L539
	.byte	3,3,1,5,21,9
	.half	.L540-.L286
	.byte	1,5,78,7,9
	.half	.L541-.L540
	.byte	3,4,1,5,37,9
	.half	.L542-.L541
	.byte	1,5,66,9
	.half	.L543-.L542
	.byte	3,3,1,5,40,9
	.half	.L106-.L543
	.byte	3,2,1,5,33,9
	.half	.L105-.L106
	.byte	3,126,1,5,66,9
	.half	.L544-.L105
	.byte	1,5,76,7,9
	.half	.L545-.L544
	.byte	3,6,1,5,25,9
	.half	.L546-.L545
	.byte	1,5,41,9
	.half	.L547-.L546
	.byte	3,2,1,5,25,9
	.half	.L107-.L547
	.byte	3,126,1,5,63,9
	.half	.L108-.L107
	.byte	3,11,1,5,57,9
	.half	.L548-.L108
	.byte	3,3,1,5,55,9
	.half	.L549-.L548
	.byte	1,5,76,9
	.half	.L550-.L549
	.byte	3,125,1,5,38,9
	.half	.L103-.L550
	.byte	3,11,1,5,62,9
	.half	.L551-.L103
	.byte	1,5,42,9
	.half	.L288-.L551
	.byte	3,3,1,5,57,9
	.half	.L285-.L288
	.byte	3,3,1,5,55,9
	.half	.L287-.L285
	.byte	1,5,37,9
	.half	.L552-.L287
	.byte	3,5,1,5,66,9
	.half	.L553-.L552
	.byte	1,5,64,9
	.half	.L554-.L553
	.byte	1,5,9,9
	.half	.L102-.L554
	.byte	3,4,1,5,73,9
	.half	.L17-.L102
	.byte	3,6,1,5,68,9
	.half	.L289-.L17
	.byte	3,3,1,5,13,9
	.half	.L290-.L289
	.byte	3,3,1,5,69,7,9
	.half	.L555-.L290
	.byte	3,3,1,5,51,9
	.half	.L556-.L555
	.byte	1,5,9,9
	.half	.L111-.L556
	.byte	3,3,1,5,16,9
	.half	.L18-.L111
	.byte	3,6,1,5,38,9
	.half	.L557-.L18
	.byte	1,5,62,9
	.half	.L558-.L557
	.byte	1,5,89,9
	.half	.L559-.L558
	.byte	1,5,13,9
	.half	.L560-.L559
	.byte	1,5,59,7,9
	.half	.L561-.L560
	.byte	3,3,1,5,17,9
	.half	.L292-.L561
	.byte	1,5,57,7,9
	.half	.L562-.L292
	.byte	3,11,1,5,55,9
	.half	.L563-.L562
	.byte	1,5,37,9
	.half	.L564-.L563
	.byte	3,3,1,5,65,9
	.half	.L565-.L564
	.byte	1,5,63,9
	.half	.L566-.L565
	.byte	1,5,86,9
	.half	.L567-.L566
	.byte	3,125,1,5,57,9
	.half	.L114-.L567
	.byte	3,8,1,5,55,9
	.half	.L568-.L114
	.byte	1,5,17,9
	.half	.L115-.L568
	.byte	3,125,1,5,37,9
	.half	.L113-.L115
	.byte	3,10,1,5,17,9
	.half	.L569-.L113
	.byte	1,5,57,7,9
	.half	.L570-.L569
	.byte	3,3,1,5,55,9
	.half	.L571-.L570
	.byte	1,5,80,9
	.half	.L572-.L571
	.byte	1,5,65,9
	.half	.L117-.L572
	.byte	3,6,1,5,21,9
	.half	.L293-.L117
	.byte	3,3,1,5,25,7,9
	.half	.L573-.L293
	.byte	3,3,1,5,74,7,9
	.half	.L574-.L573
	.byte	3,7,1,5,73,9
	.half	.L575-.L574
	.byte	1,5,57,9
	.half	.L576-.L575
	.byte	1,5,73,9
	.half	.L577-.L576
	.byte	1,5,93,9
	.half	.L578-.L577
	.byte	1,5,34,9
	.half	.L579-.L578
	.byte	1,5,56,9
	.half	.L580-.L579
	.byte	1,5,111,9
	.half	.L581-.L580
	.byte	1,5,32,9
	.half	.L582-.L581
	.byte	1,5,53,7,9
	.half	.L583-.L582
	.byte	3,2,1,5,67,9
	.half	.L584-.L583
	.byte	1,5,69,7,9
	.half	.L585-.L584
	.byte	3,3,1,5,67,9
	.half	.L586-.L585
	.byte	1,5,68,9
	.half	.L587-.L586
	.byte	3,3,1,5,67,9
	.half	.L588-.L587
	.byte	3,8,1,5,94,9
	.half	.L294-.L588
	.byte	3,1,1,5,89,9
	.half	.L297-.L294
	.byte	3,116,1,5,44,9
	.half	.L121-.L297
	.byte	3,17,1,5,29,9
	.half	.L123-.L121
	.byte	3,125,1,5,40,9
	.half	.L120-.L123
	.byte	3,14,1,5,9,9
	.half	.L116-.L120
	.byte	3,22,1,5,16,9
	.half	.L19-.L116
	.byte	3,19,1,5,13,9
	.half	.L299-.L19
	.byte	1,5,50,7,9
	.half	.L589-.L299
	.byte	3,3,1,5,48,9
	.half	.L590-.L589
	.byte	1,5,53,9
	.half	.L591-.L590
	.byte	3,2,1,5,51,9
	.half	.L592-.L591
	.byte	1,5,63,9
	.half	.L593-.L592
	.byte	3,126,1,5,28,9
	.half	.L126-.L593
	.byte	3,7,1,5,10,9
	.half	.L127-.L126
	.byte	3,2,1,5,24,9
	.half	.L3-.L127
	.byte	3,24,1,5,9,9
	.half	.L594-.L3
	.byte	3,2,1,5,5,9
	.half	.L41-.L594
	.byte	3,5,1,5,45,7,9
	.half	.L595-.L41
	.byte	3,3,1,5,43,9
	.half	.L596-.L595
	.byte	1,5,9,9
	.half	.L597-.L596
	.byte	3,3,1,5,31,9
	.half	.L598-.L597
	.byte	1,5,47,9
	.half	.L599-.L598
	.byte	1,5,45,9
	.half	.L600-.L599
	.byte	1,5,5,9
	.half	.L130-.L600
	.byte	3,3,1,5,1,9
	.half	.L131-.L130
	.byte	3,1,1,7,9
	.half	.L142-.L131
	.byte	0,1,1
.L308:
	.sdecl	'.debug_ranges',debug,cluster('Fee_LLWriteBlock')
	.sect	'.debug_ranges'
.L141:
	.word	-1,.L133,0,.L142-.L133,0,0
.L186:
	.word	-1,.L133,.L178-.L133,.L47-.L133,.L187-.L133,.L188-.L133,0,0
	.sdecl	'.debug_loc',debug,cluster('Fee_LLWriteBlock')
	.sect	'.debug_loc'
.L148:
	.word	-1,.L133,0,.L200-.L133
	.half	1
	.byte	101
	.word	.L202-.L133,.L200-.L133
	.half	2
	.byte	145,120
	.word	.L4-.L133,.L205-.L133
	.half	1
	.byte	101
	.word	.L4-.L133,.L60-.L133
	.half	2
	.byte	145,120
	.word	.L6-.L133,.L223-.L133
	.half	1
	.byte	101
	.word	.L5-.L133,.L230-.L133
	.half	1
	.byte	101
	.word	.L20-.L133,.L58-.L133
	.half	1
	.byte	101
	.word	.L8-.L133,.L60-.L133
	.half	1
	.byte	101
	.word	.L61-.L133,.L240-.L133
	.half	1
	.byte	101
	.word	.L61-.L133,.L144-.L133
	.half	2
	.byte	145,120
	.word	.L13-.L133,.L244-.L133
	.half	1
	.byte	101
	.word	.L252-.L133,.L248-.L133
	.half	1
	.byte	98
	.word	.L257-.L133,.L258-.L133
	.half	1
	.byte	111
	.word	.L262-.L133,.L86-.L133
	.half	1
	.byte	111
	.word	.L14-.L133,.L266-.L133
	.half	1
	.byte	101
	.word	.L15-.L133,.L277-.L133
	.half	1
	.byte	101
	.word	.L16-.L133,.L278-.L133
	.half	1
	.byte	101
	.word	.L17-.L133,.L289-.L133
	.half	1
	.byte	101
	.word	.L18-.L133,.L292-.L133
	.half	1
	.byte	101
	.word	.L113-.L133,.L293-.L133
	.half	1
	.byte	101
	.word	.L298-.L133,.L297-.L133
	.half	1
	.byte	101
	.word	.L19-.L133,.L299-.L133
	.half	1
	.byte	101
	.word	.L3-.L133,.L41-.L133
	.half	1
	.byte	101
	.word	0,0
.L132:
	.word	-1,.L133,0,.L199-.L133
	.half	2
	.byte	138,0
	.word	.L199-.L133,.L144-.L133
	.half	2
	.byte	138,16
	.word	.L144-.L133,.L144-.L133
	.half	2
	.byte	138,0
	.word	0,0
.L146:
	.word	-1,.L133,0,.L200-.L133
	.half	1
	.byte	100
	.word	.L201-.L133,.L200-.L133
	.half	1
	.byte	109
	.word	.L4-.L133,.L206-.L133
	.half	1
	.byte	100
	.word	.L4-.L133,.L207-.L133
	.half	1
	.byte	109
	.word	.L6-.L133,.L223-.L133
	.half	1
	.byte	100
	.word	.L6-.L133,.L60-.L133
	.half	1
	.byte	109
	.word	.L5-.L133,.L230-.L133
	.half	1
	.byte	100
	.word	.L20-.L133,.L58-.L133
	.half	1
	.byte	100
	.word	.L8-.L133,.L60-.L133
	.half	1
	.byte	100
	.word	.L61-.L133,.L241-.L133
	.half	1
	.byte	100
	.word	.L61-.L133,.L242-.L133
	.half	1
	.byte	109
	.word	.L13-.L133,.L244-.L133
	.half	1
	.byte	100
	.word	.L74-.L133,.L85-.L133
	.half	1
	.byte	109
	.word	.L73-.L133,.L86-.L133
	.half	1
	.byte	109
	.word	.L69-.L133,.L68-.L133
	.half	1
	.byte	109
	.word	.L14-.L133,.L266-.L133
	.half	1
	.byte	100
	.word	.L14-.L133,.L267-.L133
	.half	1
	.byte	109
	.word	.L15-.L133,.L277-.L133
	.half	1
	.byte	100
	.word	.L15-.L133,.L41-.L133
	.half	1
	.byte	109
	.word	.L16-.L133,.L278-.L133
	.half	1
	.byte	100
	.word	.L17-.L133,.L289-.L133
	.half	1
	.byte	100
	.word	.L18-.L133,.L292-.L133
	.half	1
	.byte	100
	.word	.L113-.L133,.L293-.L133
	.half	1
	.byte	100
	.word	.L295-.L133,.L294-.L133
	.half	1
	.byte	100
	.word	.L296-.L133,.L297-.L133
	.half	1
	.byte	100
	.word	.L19-.L133,.L300-.L133
	.half	1
	.byte	100
	.word	.L3-.L133,.L41-.L133
	.half	1
	.byte	100
	.word	0,0
.L180:
	.word	0,0
.L174:
	.word	-1,.L133,.L226-.L133,.L227-.L133
	.half	1
	.byte	95
	.word	0,0
.L173:
	.word	-1,.L133,.L224-.L133,.L225-.L133
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L176:
	.word	-1,.L133,.L228-.L133,.L223-.L133
	.half	1
	.byte	81
	.word	0,0
.L164:
	.word	-1,.L133,.L254-.L133,.L255-.L133
	.half	1
	.byte	95
	.word	.L83-.L133,.L74-.L133
	.half	1
	.byte	95
	.word	0,0
.L197:
	.word	-1,.L133,.L229-.L133,.L188-.L133
	.half	1
	.byte	85
	.word	0,0
.L171:
	.word	0,0
.L189:
	.word	-1,.L133,.L225-.L133,.L223-.L133
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L184:
	.word	0,0
.L175:
	.word	-1,.L133,.L178-.L133,.L223-.L133
	.half	1
	.byte	82
	.word	0,0
.L198:
	.word	0,0
.L182:
	.word	0,0
.L195:
	.word	0,0
.L169:
	.word	-1,.L133,.L286-.L133,.L103-.L133
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L193:
	.word	0,0
.L168:
	.word	-1,.L133,.L253-.L133,.L82-.L133
	.half	1
	.byte	82
	.word	.L261-.L133,.L85-.L133
	.half	1
	.byte	82
	.word	0,0
.L160:
	.word	-1,.L133,.L208-.L133,.L30-.L133
	.half	1
	.byte	89
	.word	0,0
.L159:
	.word	-1,.L133,.L216-.L133,.L217-.L133
	.half	1
	.byte	95
	.word	.L218-.L133,.L219-.L133
	.half	1
	.byte	84
	.word	.L33-.L133,.L30-.L133
	.half	1
	.byte	95
	.word	0,0
.L150:
	.word	-1,.L133,.L293-.L133,.L294-.L133
	.half	1
	.byte	82
	.word	.L121-.L133,.L123-.L133
	.half	1
	.byte	82
	.word	.L120-.L133,.L116-.L133
	.half	1
	.byte	82
	.word	0,0
.L166:
	.word	-1,.L133,.L249-.L133,.L75-.L133
	.half	1
	.byte	91
	.word	.L76-.L133,.L74-.L133
	.half	1
	.byte	91
	.word	0,0
.L152:
	.word	-1,.L133,.L277-.L133,.L16-.L133
	.half	1
	.byte	82
	.word	0,0
.L162:
	.word	-1,.L133,.L209-.L133,.L210-.L133
	.half	1
	.byte	84
	.word	.L24-.L133,.L211-.L133
	.half	1
	.byte	84
	.word	.L212-.L133,.L213-.L133
	.half	1
	.byte	84
	.word	.L30-.L133,.L220-.L133
	.half	1
	.byte	84
	.word	.L22-.L133,.L28-.L133
	.half	1
	.byte	84
	.word	.L273-.L133,.L274-.L133
	.half	1
	.byte	84
	.word	.L94-.L133,.L91-.L133
	.half	1
	.byte	84
	.word	.L288-.L133,.L285-.L133
	.half	1
	.byte	84
	.word	0,0
.L165:
	.word	-1,.L133,.L247-.L133,.L248-.L133
	.half	1
	.byte	81
	.word	.L74-.L133,.L256-.L133
	.half	1
	.byte	81
	.word	.L73-.L133,.L86-.L133
	.half	1
	.byte	81
	.word	0,0
.L154:
	.word	-1,.L133,.L231-.L133,.L232-.L133
	.half	1
	.byte	95
	.word	.L236-.L133,.L237-.L133
	.half	1
	.byte	84
	.word	.L54-.L133,.L55-.L133
	.half	1
	.byte	95
	.word	.L51-.L133,.L238-.L133
	.half	1
	.byte	95
	.word	.L245-.L133,.L14-.L133
	.half	1
	.byte	90
	.word	.L259-.L133,.L256-.L133
	.half	1
	.byte	84
	.word	.L260-.L133,.L261-.L133
	.half	1
	.byte	84
	.word	.L263-.L133,.L86-.L133
	.half	1
	.byte	84
	.word	.L264-.L133,.L265-.L133
	.half	1
	.byte	84
	.word	0,0
.L167:
	.word	-1,.L133,.L250-.L133,.L77-.L133
	.half	1
	.byte	92
	.word	.L251-.L133,.L79-.L133
	.half	1
	.byte	92
	.word	.L78-.L133,.L74-.L133
	.half	1
	.byte	92
	.word	0,0
.L157:
	.word	-1,.L133,.L244-.L133,.L246-.L133
	.half	1
	.byte	82
	.word	.L69-.L133,.L68-.L133
	.half	1
	.byte	82
	.word	0,0
.L161:
	.word	-1,.L133,.L214-.L133,.L215-.L133
	.half	1
	.byte	95
	.word	.L221-.L133,.L222-.L133
	.half	1
	.byte	95
	.word	.L266-.L133,.L269-.L133
	.half	1
	.byte	82
	.word	.L270-.L133,.L271-.L133
	.half	1
	.byte	95
	.word	.L269-.L133,.L272-.L133
	.half	1
	.byte	84
	.word	.L268-.L133,.L275-.L133
	.half	1
	.byte	89
	.word	.L94-.L133,.L276-.L133
	.half	1
	.byte	89
	.word	.L278-.L133,.L279-.L133
	.half	1
	.byte	82
	.word	.L280-.L133,.L281-.L133
	.half	1
	.byte	95
	.word	.L279-.L133,.L282-.L133
	.half	1
	.byte	84
	.word	.L283-.L133,.L284-.L133
	.half	1
	.byte	84
	.word	.L103-.L133,.L287-.L133
	.half	1
	.byte	95
	.word	.L289-.L133,.L290-.L133
	.half	1
	.byte	82
	.word	.L291-.L133,.L290-.L133
	.half	1
	.byte	84
	.word	0,0
.L149:
	.word	-1,.L133,.L203-.L133,.L200-.L133
	.half	1
	.byte	88
	.word	.L4-.L133,.L60-.L133
	.half	1
	.byte	88
	.word	.L61-.L133,.L144-.L133
	.half	1
	.byte	88
	.word	.L301-.L133,.L144-.L133
	.half	1
	.byte	82
	.word	0,0
.L155:
	.word	-1,.L133,.L233-.L133,.L52-.L133
	.half	1
	.byte	85
	.word	.L234-.L133,.L235-.L133
	.half	1
	.byte	85
	.word	.L239-.L133,.L60-.L133
	.half	1
	.byte	85
	.word	.L61-.L133,.L240-.L133
	.half	1
	.byte	85
	.word	0,0
.L163:
	.word	-1,.L133,.L204-.L133,.L200-.L133
	.half	1
	.byte	89
	.word	.L4-.L133,.L208-.L133
	.half	1
	.byte	89
	.word	.L30-.L133,.L35-.L133
	.half	1
	.byte	89
	.word	.L22-.L133,.L28-.L133
	.half	1
	.byte	89
	.word	.L6-.L133,.L60-.L133
	.half	1
	.byte	89
	.word	.L61-.L133,.L243-.L133
	.half	1
	.byte	89
	.word	.L69-.L133,.L68-.L133
	.half	1
	.byte	89
	.word	.L14-.L133,.L268-.L133
	.half	1
	.byte	89
	.word	.L15-.L133,.L41-.L133
	.half	1
	.byte	89
	.word	0,0
.L151:
	.word	-1,.L133,.L284-.L133,.L285-.L133
	.half	1
	.byte	82
	.word	.L290-.L133,.L18-.L133
	.half	1
	.byte	82
	.word	0,0
	.sdecl	'.debug_frame',debug
	.sect	'.debug_frame'
.L601:
	.word	48
	.word	-1
	.byte	3,0,2,1,27,12,26,0,8,27,8,26,8,28,8,29,8,30,8,31,8,34,8,35,8,32,8,33,8,16,8,17,8,24,8,25,8,36,8,37,8,38
	.byte	8,39
	.sdecl	'.debug_frame',debug,cluster('Fee_LLWriteBlock')
	.sect	'.debug_frame'
	.word	36
	.word	.L601,.L133,.L144-.L133
	.byte	4
	.word	(.L199-.L133)/2
	.byte	19,16,22,26,3,19,138,16,4
	.word	(.L144-.L199)/2
	.byte	19,0,8,26,0,0

; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1257  #define FEE_STOP_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1258  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1259  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1260  #if(FEE_ROBUST_PROG_ACTIVE != FALSE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1261  #define FEE_START_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1262  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1263  Fee_RobIfxHdl_e Fee_RobIfxHdl;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1264  #define FEE_STOP_SEC_VAR_CLEARED_UNSPECIFIED
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1265  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1266  /* MR12 RULE 8.5 VIOLATION: This variable needs to keep its value but it is not used outside of this file */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1267  #define FEE_START_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1268  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1269  uint8 Fee_RobMarkerBuff_au8[FEE_ROBMARKER_BUFF_SIZE];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1270  #define FEE_STOP_SEC_VAR_CLEARED_8
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1271  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1272  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1273  /**
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1274   ***************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1275   * Fee_RobIfxHandling(): Funktion to handle robust programming algorithm for Ifx DFLASHs
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1276   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1277   * In case of a wordline fail, this function is called and will do the following steps:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1278   * 1. check if the next logical sector is erased. If not, erase this sector.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1279   * 2. write the clone marker in the new sector. This marker indicates that there might be data
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1280   *    in the sector, written by this algorithm
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1281   * 3. copy the data of the defect wordline at the same location in the clone sector
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1282   * 4. copy data 1:1 from the old sector to the new sector, starting after the sectorheader,
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1283   *    stopping at the wordline which causes the defect
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1284   * 5. writing the used marker in the sector
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1285   * 6. sort the now old sector at the end of the logical list.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1286   *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1287   * \param    none
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1288   * \retval   FEE_ORDER_PENDING_E:   Order is still pending
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1289   * \retval   FEE_ABORTED_E:         Order was aborted due to a wrong
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1290   *                                  FLS write function call
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1291   * \retval   FEE_ERROR_E:           writing is still done in the last logical sector. Do not
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1292   *                                  start the algotihm.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1293   * \retval   FEE_ORDER_FINISHED_E:  Order finished successfully
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1294   * \seealso
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1295   * \usedresources
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1296   ***************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1297   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1298  #define FEE_START_SEC_CODE
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1299  #include "Fee_MemMap.h"
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1300  FUNC(Fee_stRetVal_ten, FEE_CODE) Fee_RobIfxHandling(uint8 xActLogWrSect_u8)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1301  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1302      Fee_stRetVal_ten xRetVal_en = FEE_ORDER_PENDING_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1303      uint32 i;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1304      uint8 xLogSectIdx_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1305      uint8 xPhySectIdx_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1306      Fls_AddressType BaseAddress;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1307      uint32 tmpNumBytes2Clone_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1308      uint32 xOffsetInSector_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1309      uint8 xPhySecIdx_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1310  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1311      switch (Fee_RobIfxHdl){
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1312          case FEE_ROB_IFX_INIT:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1313          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1314              /* in the statemashine of the robustness algorithmus for IFX programming, at least one marker has to be written. During this
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1315               * write, max. the marker-section size will be overwritten in the Wordline-Buffer, again. To prevent loss of data, this buffer
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1316               * has to be backuped before starting any marker or erase operation. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1317              for (i=0;i<FEE_ROBMARKER_BUFF_SIZE;i++)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1318              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1319                  Fee_RobMarkerBuff_au8[i] = Fee_IfxRobustProgramming_s.DataBuffer[i];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1320              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1321              /* check if the next sector is erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1322              /* Get the logical sector index */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1323              xLogSectIdx_u8 = xActLogWrSect_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1324  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1325              xOffsetInSector_u32 = Fee_IfxRobustProgramming_s.xStartAddress - Fee_FlashProp_st[Fee_LLSectorOrder_st[xLogSectIdx_u8].xPhySecIdx_u8].Fee_PhysStartAddress_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1326  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1327              xLogSectIdx_u8++;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1328  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1329              if (xLogSectIdx_u8 < FEE_NUM_FLASH_BANKS)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1330              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1331                  /* We are not in the last sector --> it should be possible to start with the robust Ifx Flash handling */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1332                  /* first, set write address to the logical start address of the next sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1333                  Fee_RdWrOrder_st.xWrAddress = Fee_FlashProp_st[Fee_LLSectorOrder_st[xLogSectIdx_u8].xPhySecIdx_u8].Fee_PhysStartAddress_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1334  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1335                  /* calculate correct WriteAddress */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1336                  Fee_RdWrOrder_st.xWrAddress += xOffsetInSector_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1337  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1338                  /* check if the first wordline is in the buffer. In this case it is necessary to start programming AFTER the sector header section */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1339                  if (Fee_RdWrOrder_st.xWrAddress <= Fee_LLGetSecStartAddress(Fee_LLSectorOrder_st[xLogSectIdx_u8].xPhySecIdx_u8))
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1340                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1341                      /* set write address to the beginn of the logical sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1342                      Fee_RdWrOrder_st.xWrAddress = Fee_LLGetSecStartAddress(Fee_LLSectorOrder_st[xLogSectIdx_u8].xPhySecIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1343  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1344                      /* calculate now the offset in the buffer to ensure, that data has to be copied. Theoretically it could be happen that the error happens
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1345                       * inside the sector header and so nothing could be stored ore copied! */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1346                      xOffsetInSector_u32 = Fee_RdWrOrder_st.xWrAddress - Fee_FlashProp_st[Fee_LLSectorOrder_st[xLogSectIdx_u8].xPhySecIdx_u8].Fee_PhysStartAddress_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1347  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1348                      if (xOffsetInSector_u32 >= Fee_IfxRobustProgramming_s.numBytes)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1349                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1350                          Fee_IfxRobustProgramming_s.numBytes = 0;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1351                      }else{
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1352                          /* start copying of the buffer with the offset of the sector header */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1353                          /* MR12 RULE 10.3 VIOLATION: Masking is faster and more efficient */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1354                          Fee_IfxRobustProgramming_s.offInBuf_u16 = (uint16)(Fee_RdWrOrder_st.xWrAddress & FEE_MAXUINT16);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1355  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1356                          /* reduce number of byte that have to be programmed in the flash */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1357                          Fee_IfxRobustProgramming_s.numBytes -= Fee_IfxRobustProgramming_s.offInBuf_u16;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1358                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1359                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1360                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1361                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1362                      Fee_IfxRobustProgramming_s.offInBuf_u16 = 0;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1363                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1364                  if (Fee_IfxRobustProgramming_s.numBytes > 0uL)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1365                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1366                      /* now check if the next sector is still erased */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1367                      if (Fee_LLSectorOrder_st[xLogSectIdx_u8].SecState_en ==  FEE_SECTOR_ERASED_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1368                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1369                          /* the next logical sector is still erase --> mark this sector as clone sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1370                          Fee_RobIfxHdl = FEE_ROB_IFX_MARK_SECTOR;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1371                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1372                      else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1373                      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1374                          /* the sector which should be used to clone the current sector is not erased yet --> erase this sector first */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1375                          Fee_LLSetEraseSector(xLogSectIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1376                          Fee_RobIfxHdl = FEE_ROB_IFX_ERASE_SECTOR;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1377                      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1378                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1379                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1380                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1381                      /* the wordline error happens while writing in the sector header --> now robust handling for this use case planned
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1382                       * --> finish special handling */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1383                      Fee_RobIfxHdl = FEE_ROB_IFX_FINISHED;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1384                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1385  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1386              }else{
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1387                  xRetVal_en = FEE_ERROR_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1388              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1389          }break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1390  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1391          case FEE_ROB_IFX_MARK_SECTOR:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1392          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1393              /* Get the physical sector index of the FULL sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1394              xPhySectIdx_u8 = Fee_GetPhysSectorByAddress(Fee_RdWrOrder_st.xWrAddress);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1395  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1396              /* Write the CLONE_START marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1397              if(Fee_LLWriteMarker(xPhySectIdx_u8, FEE_CLONE_START_MARKER_ID_E) != FEE_ORDER_PENDING_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1398              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1399                  /* in the sector header, there is the information available, that a clone procedure has started. Now it
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1400                   * is allowed to write data in this sector.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1401                   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1402                  Fee_RobIfxHdl = FEE_ROB_IFX_STORE_BUFFER;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1403              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1404          }break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1405  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1406          case FEE_ROB_IFX_STORE_BUFFER:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1407          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1408              /* before writing the buffer, it was necessary to write at least one marker. Because the Fls-Driver will always backup the WordLine, it is
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1409               * possible that the whole markersection in the buffer was overwritten. Because of this, the markersection size of the buffer was backuped
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1410               * and has to be restored before writing this data, too. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1411              for (i=0;i<FEE_ROBMARKER_BUFF_SIZE;i++)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1412              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1413                  (Fee_IfxRobustProgramming_s.DataBuffer[i]) = Fee_RobMarkerBuff_au8[i];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1414              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1415  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1416              if(Fls_Write(Fee_RdWrOrder_st.xWrAddress, (uint8*)(&Fee_IfxRobustProgramming_s.DataBuffer[Fee_IfxRobustProgramming_s.offInBuf_u16]), Fee_IfxRobustProgramming_s.numBytes) != E_NOT_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1417              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1418                  Fee_RdWrOrder_st.xWrAddress += Fee_IfxRobustProgramming_s.numBytes;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1419                  /* Wait for the write order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1420                  Fee_RobIfxHdl = FEE_ROB_IFX_STORE_BUFFER_WAIT;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1421              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1422              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1423              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1424                  /* Return an error due to wrong parameters or a busy/not init state of the Fls */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1425                  xRetVal_en = FEE_ABORTED_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1426              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1427  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1428          }break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1429  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1430          case FEE_ROB_IFX_STORE_BUFFER_WAIT:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1431          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1432              /* The next state (FEE_ROB_IFX_COPY_DATA) will be set by the Fee_JobEndNotification() or
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1433               * Fee_JobErrorNotification() function automatically */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1434  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1435              /* Check whether the OS is currently running or not */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1436              if (Fee_stMain == FEE_POLLING_MODE_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1437              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1438                  /* Call the Fls main function manually */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1439                  Fls_MainFunction();
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1440              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1441  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1442              #if (STD_ON == FEE_POLLING_MODE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1443              /* Use the FLS polling mechanism in order to reach the next state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1444              Fee_CheckFlsJobResult();
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1445              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1446          }break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1447  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1448          case FEE_ROB_IFX_COPY_DATA:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1449          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1450              /* if there is a offset in the data buffer, the first wordline had the error. In this case there is no data to copy --> go directly in the state
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1451              * Write-Used-Marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1452              if (Fee_IfxRobustProgramming_s.offInBuf_u16 == 0)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1453              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1454                  /* in the state FEE_ROB_IFX_INIT the xLogSectIdx_u8 was incremented once and so the new sector was found. The current write
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1455                  * address could not belong to the logical oldest sector --> new calculation of the previous sector is possible */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1456                  xPhySectIdx_u8 = Fee_GetPhysSectorByAddress(Fee_RdWrOrder_st.xWrAddress);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1457                  xLogSectIdx_u8 = Fee_idxLLSectorOrder_au8[xPhySectIdx_u8];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1458                  /* start-Address of copying data is the start-address of the logical sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1459                  Fee_RdWrOrder_st.xWrAddress = Fee_LLGetSecStartAddress(xPhySectIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1460  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1461                  /* switch back to the sector which was used bevore */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1462                  xLogSectIdx_u8--;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1463  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1464                  /* start-Address is the start of the logical sector which was used bevore */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1465                  BaseAddress = Fee_LLGetSecStartAddress(Fee_LLSectorOrder_st[xLogSectIdx_u8].xPhySecIdx_u8);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1466  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1467                  /* start- and base-address are both in the old sector. The difference is the number of byte that have to be programmed */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1468                  tmpNumBytes2Clone_u32 = Fee_IfxRobustProgramming_s.xStartAddress - BaseAddress;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1469  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1470                  /* if the error happens while programming the first wordline, it is possible that no data could be copied. In this case go directly to writing the
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1471                  * used marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1472                  /* Write the data. The Write-Address was set into the correct sector in the state FEE_ROB_IFX_INIT. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1473                  /* MISRA RULE 11.3 VIOLATION: Cast necessary and not critical */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1474                  if(Fls_Write(Fee_RdWrOrder_st.xWrAddress, (uint8*)BaseAddress, tmpNumBytes2Clone_u32) != E_NOT_OK)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1475                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1476                      /* add copied bytes to the write address */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1477                      Fee_RdWrOrder_st.xWrAddress += tmpNumBytes2Clone_u32;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1478  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1479                      /* add bytes in the clone buffer */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1480                      Fee_RdWrOrder_st.xWrAddress +=  Fee_IfxRobustProgramming_s.numBytes;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1481  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1482                      /* Wait for the write order to be finished */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1483                      Fee_RobIfxHdl = FEE_ROB_IFX_STORE_COPY_WAIT;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1484                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1485                  else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1486                  {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1487                      /* Return an error due to wrong parameters or a busy/not init state of the Fls */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1488                      xRetVal_en = FEE_ABORTED_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1489                  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1490              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1491              else
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1492              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1493                  Fee_RobIfxHdl = FEE_ROB_IFX_WRITE_USED_MARK_SECTOR;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1494              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1495          }break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1496  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1497          case FEE_ROB_IFX_STORE_COPY_WAIT:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1498          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1499              /* The next state (FEE_ROB_IFX_COPY_DATA) will be set by the Fee_JobEndNotification() or
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1500              * Fee_JobErrorNotification() function automatically */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1501  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1502              /* Check whether the OS is currently running or not */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1503              if (Fee_stMain == FEE_POLLING_MODE_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1504              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1505                  /* Call the Fls main function manually */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1506                  Fls_MainFunction();
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1507              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1508  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1509              #if (STD_ON == FEE_POLLING_MODE)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1510              /* Use the FLS polling mechanism in order to reach the next state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1511              Fee_CheckFlsJobResult();
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1512              #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1513          }break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1514  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1515          case FEE_ROB_IFX_ERASE_SECTOR:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1516          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1517              if(Fee_LLEraseSector() == FEE_ORDER_FINISHED_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1518              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1519                  /* the next logical sector is now erased --> mark this sector as clone sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1520                  Fee_RobIfxHdl = FEE_ROB_IFX_MARK_SECTOR;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1521              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1522          }break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1523  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1524          case FEE_ROB_IFX_WRITE_USED_MARK_SECTOR:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1525          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1526              /* Get the physical sector index of the FULL sector */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1527              xPhySectIdx_u8 = Fee_GetPhysSectorByAddress(Fee_RdWrOrder_st.xWrAddress);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1528  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1529              /* Write the CLONE_START marker */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1530              if(Fee_LLWriteMarker(xPhySectIdx_u8, FEE_USED_MARKER_ID_E) != FEE_ORDER_PENDING_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1531              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1532                  /* in the sector header, there is the information available, that a clone procedure has started. Now it
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1533                   * is allowed to write data in this sector.
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1534                   */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1535                  Fee_RobIfxHdl = FEE_ROB_SORT_SECTOR;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1536              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1537          }break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1538  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1539          case FEE_ROB_SORT_SECTOR:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1540          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1541              /* step1: invalidate complete cache */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1542              for (i=0;i<FEE_NUM_BLOCKS;i++)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1543              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1544                  Fee_Cache_au32[i] = FEE_CACHE_TMP_INVALID_VALUE;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1545              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1546  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1547              /* step2: invalidate sector cache state */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1548              for (i=0;i<FEE_NUM_FLASH_BANKS_AVAILABLE;i++)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1549              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1550                  Fee_CacheUpdCompForSect_au8[i] = FEE_CACHE_UPD_NOT_COMP_FOR_SECT;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1551              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1552              /* step3: now it is possible that the hard reorganisation has to be startet, because free space in flash was reduced by 1
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1553               * sector. To prevent any replacement reaction, it is a great idea to put the old sector at the end of the sector list and
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1554               * mark the sector with request to erase marker. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1555  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1556              /* in the state FEE_ROB_IFX_INIT the xLogSectIdx_u8 was incremented once and so the new sector was found. The current write
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1557               * address could not belong to the logical oldest sector --> new calculation of the previous sector is possible */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1558              xLogSectIdx_u8 = Fee_idxLLSectorOrder_au8[Fee_GetPhysSectorByAddress(Fee_RdWrOrder_st.xWrAddress)];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1559              xPhySecIdx_u8 = Fee_LLSectorOrder_st[xLogSectIdx_u8-1].xPhySecIdx_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1560  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1561              /* Loop over all sectors and reorganize the sector order:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1562               * - The sector with the error in the wordl-line will be set to the last entry in the array
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1563               * - the clone sector (and all following sectors) will be shifted by 1 entry
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1564               *
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1565               */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1566              for( ; xLogSectIdx_u8<FEE_NUM_FLASH_BANKS; xLogSectIdx_u8++)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1567              {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1568                  /* Reorganize the sector order */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1569                  Fee_LLSectorOrder_st[xLogSectIdx_u8-1] = Fee_LLSectorOrder_st[xLogSectIdx_u8];
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1570  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1571                  /* Reorganize the array Ram table */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1572                  Fee_idxLLSectorOrder_au8[Fee_LLSectorOrder_st[xLogSectIdx_u8-1].xPhySecIdx_u8] = xLogSectIdx_u8-1;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1573              }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1574  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1575              /* Update the state information of the last sector in the ring with the data of the sector with the wordline failure. */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1576              Fee_LLSectorOrder_st[FEE_NUM_FLASH_BANKS-1].xPhySecIdx_u8   = xPhySecIdx_u8;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1577              Fee_idxLLSectorOrder_au8[xPhySecIdx_u8] = FEE_NUM_FLASH_BANKS-1;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1578  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1579              /* mark the last sector as ready to erase */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1580              Fee_LLSetEraseSector(FEE_NUM_FLASH_BANKS-1);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1581  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1582              Fee_RobIfxHdl = FEE_ROB_IFX_FINISHED;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1583          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1584          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1585  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1586          case FEE_ROB_IFX_FINISHED:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1587          default:
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1588          {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1589              xRetVal_en = FEE_ORDER_FINISHED_E;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1590          }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1591          break;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1592      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1593  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1594      if (xRetVal_en != FEE_ORDER_PENDING_E)
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1595      {
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1596          Fee_RobIfxHdl = FEE_ROB_IFX_INIT;
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1597      }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1598      return(xRetVal_en);
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1599  }
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1600  /* FEE_ROBUST_PROG_ACTIVE */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1601  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1602  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1603  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1604  /* 1 == FEE_PRV_CFG_SELECTED_FS */
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1605  #endif
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1606  
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1607  /*<BASDKey>
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1608  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1609  * $History__:$
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1610  **********************************************************************************************************************
; BSW\src\BSW\Gen\Rba_FeeFs1\src\rba_FeeFs1_LlWriteBlock.c	  1611  </BASDKey>*/

	; Module end
